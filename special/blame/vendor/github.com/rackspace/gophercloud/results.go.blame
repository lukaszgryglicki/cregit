0000000000000000000000000000000000000000;;	package gophercloud
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/results.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/results.go][vendor/github.com/rackspace/gophercloud/results.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/mitchellh/mapstructure"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Result is an internal type to be used by individual resource packages, but its
0000000000000000000000000000000000000000;;	methods will be available on a wide variety of user-facing embedding types.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It acts as a base struct that other Result types, returned from request
0000000000000000000000000000000000000000;;	functions, can embed for convenience. All Results capture basic information
0000000000000000000000000000000000000000;;	from the HTTP transaction that was performed, including the response body,
0000000000000000000000000000000000000000;;	HTTP headers, and any errors that happened.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Generally, each Result type will have an Extract method that can be used to
0000000000000000000000000000000000000000;;	further interpret the result's payload in a specific context. Extensions or
0000000000000000000000000000000000000000;;	providers can then provide additional extraction functions to pull out
0000000000000000000000000000000000000000;;	provider- or extension-specific information as well.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type Result struct {
0000000000000000000000000000000000000000;;		// Body is the payload of the HTTP response from the server. In most cases,
0000000000000000000000000000000000000000;;		// this will be the deserialized JSON structure.
0000000000000000000000000000000000000000;;		Body interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Header contains the HTTP header structure from the original response.
0000000000000000000000000000000000000000;;		Header http.Header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Err is an error that occurred during the operation. It's deferred until
0000000000000000000000000000000000000000;;		// extraction to make it easier to chain the Extract call.
0000000000000000000000000000000000000000;;		Err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrettyPrintJSON creates a string containing the full response body as
0000000000000000000000000000000000000000;;	// pretty-printed JSON. It's useful for capturing test fixtures and for
0000000000000000000000000000000000000000;;	// debugging extraction bugs. If you include its output in an issue related to
0000000000000000000000000000000000000000;;	// a buggy extraction function, we will all love you forever.
0000000000000000000000000000000000000000;;	func (r Result) PrettyPrintJSON() string {
0000000000000000000000000000000000000000;;		pretty, err := json.MarshalIndent(r.Body, "", "  ")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(pretty)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrResult is an internal type to be used by individual resource packages, but
0000000000000000000000000000000000000000;;	// its methods will be available on a wide variety of user-facing embedding
0000000000000000000000000000000000000000;;	// types.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It represents results that only contain a potential error and
0000000000000000000000000000000000000000;;	// nothing else. Usually, if the operation executed successfully, the Err field
0000000000000000000000000000000000000000;;	// will be nil; otherwise it will be stocked with a relevant error. Use the
0000000000000000000000000000000000000000;;	// ExtractErr method
0000000000000000000000000000000000000000;;	// to cleanly pull it out.
0000000000000000000000000000000000000000;;	type ErrResult struct {
0000000000000000000000000000000000000000;;		Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractErr is a function that extracts error information, or nil, from a result.
0000000000000000000000000000000000000000;;	func (r ErrResult) ExtractErr() error {
0000000000000000000000000000000000000000;;		return r.Err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	HeaderResult is an internal type to be used by individual resource packages, but
0000000000000000000000000000000000000000;;	its methods will be available on a wide variety of user-facing embedding types.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It represents a result that only contains an error (possibly nil) and an
0000000000000000000000000000000000000000;;	http.Header. This is used, for example, by the objectstorage packages in
0000000000000000000000000000000000000000;;	openstack, because most of the operations don't return response bodies, but do
0000000000000000000000000000000000000000;;	have relevant information in headers.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type HeaderResult struct {
0000000000000000000000000000000000000000;;		Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractHeader will return the http.Header and error from the HeaderResult.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   header, err := objects.Create(client, "my_container", objects.CreateOpts{}).ExtractHeader()
0000000000000000000000000000000000000000;;	func (hr HeaderResult) ExtractHeader() (http.Header, error) {
0000000000000000000000000000000000000000;;		return hr.Header, hr.Err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeHeader is a function that decodes a header (usually of type map[string]interface{}) to
0000000000000000000000000000000000000000;;	// another type (usually a struct). This function is used by the objectstorage package to give
0000000000000000000000000000000000000000;;	// users access to response headers without having to query a map. A DecodeHookFunction is used,
0000000000000000000000000000000000000000;;	// because OpenStack-based clients return header values as arrays (Go slices).
0000000000000000000000000000000000000000;;	func DecodeHeader(from, to interface{}) error {
0000000000000000000000000000000000000000;;		config := &mapstructure.DecoderConfig{
0000000000000000000000000000000000000000;;			DecodeHook: func(from, to reflect.Kind, data interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;				if from == reflect.Slice {
0000000000000000000000000000000000000000;;					return data.([]string)[0], nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return data, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Result:           to,
0000000000000000000000000000000000000000;;			WeaklyTypedInput: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decoder, err := mapstructure.NewDecoder(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := decoder.Decode(from); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC3339Milli describes a common time format used by some API responses.
0000000000000000000000000000000000000000;;	const RFC3339Milli = "2006-01-02T15:04:05.999999Z"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Time format used in cloud orchestration
0000000000000000000000000000000000000000;;	const STACK_TIME_FMT = "2006-01-02T15:04:05"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Link is an internal type to be used in packages of collection resources that are
0000000000000000000000000000000000000000;;	paginated in a certain way.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It's a response substructure common to many paginated collection results that is
0000000000000000000000000000000000000000;;	used to point to related pages. Usually, the one we care about is the one with
0000000000000000000000000000000000000000;;	Rel field set to "next".
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type Link struct {
0000000000000000000000000000000000000000;;		Href string `mapstructure:"href"`
0000000000000000000000000000000000000000;;		Rel  string `mapstructure:"rel"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	ExtractNextURL is an internal function useful for packages of collection
0000000000000000000000000000000000000000;;	resources that are paginated in a certain way.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It attempts attempts to extract the "next" URL from slice of Link structs, or
0000000000000000000000000000000000000000;;	"" if no such URL is present.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func ExtractNextURL(links []Link) (string, error) {
0000000000000000000000000000000000000000;;		var url string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, l := range links {
0000000000000000000000000000000000000000;;			if l.Rel == "next" {
0000000000000000000000000000000000000000;;				url = l.Href
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if url == "" {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return url, nil
0000000000000000000000000000000000000000;;	}
