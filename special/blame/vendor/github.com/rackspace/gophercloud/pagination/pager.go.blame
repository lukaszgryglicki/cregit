0000000000000000000000000000000000000000;;	package pagination
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/pagination/pager.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/pagination/pager.go][vendor/github.com/rackspace/gophercloud/pagination/pager.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrPageNotAvailable is returned from a Pager when a next or previous page is requested, but does not exist.
0000000000000000000000000000000000000000;;		ErrPageNotAvailable = errors.New("The requested page does not exist.")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Page must be satisfied by the result type of any resource collection.
0000000000000000000000000000000000000000;;	// It allows clients to interact with the resource uniformly, regardless of whether or not or how it's paginated.
0000000000000000000000000000000000000000;;	// Generally, rather than implementing this interface directly, implementors should embed one of the concrete PageBase structs,
0000000000000000000000000000000000000000;;	// instead.
0000000000000000000000000000000000000000;;	// Depending on the pagination strategy of a particular resource, there may be an additional subinterface that the result type
0000000000000000000000000000000000000000;;	// will need to implement.
0000000000000000000000000000000000000000;;	type Page interface {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NextPageURL generates the URL for the page of data that follows this collection.
0000000000000000000000000000000000000000;;		// Return "" if no such page exists.
0000000000000000000000000000000000000000;;		NextPageURL() (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsEmpty returns true if this Page has no items in it.
0000000000000000000000000000000000000000;;		IsEmpty() (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetBody returns the Page Body. This is used in the `AllPages` method.
0000000000000000000000000000000000000000;;		GetBody() interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pager knows how to advance through a specific resource collection, one page at a time.
0000000000000000000000000000000000000000;;	type Pager struct {
0000000000000000000000000000000000000000;;		client *gophercloud.ServiceClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		initialURL string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createPage func(r PageResult) Page
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Headers supplies additional HTTP headers to populate on each paged request.
0000000000000000000000000000000000000000;;		Headers map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPager constructs a manually-configured pager.
0000000000000000000000000000000000000000;;	// Supply the URL for the first page, a function that requests a specific page given a URL, and a function that counts a page.
0000000000000000000000000000000000000000;;	func NewPager(client *gophercloud.ServiceClient, initialURL string, createPage func(r PageResult) Page) Pager {
0000000000000000000000000000000000000000;;		return Pager{
0000000000000000000000000000000000000000;;			client:     client,
0000000000000000000000000000000000000000;;			initialURL: initialURL,
0000000000000000000000000000000000000000;;			createPage: createPage,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithPageCreator returns a new Pager that substitutes a different page creation function. This is
0000000000000000000000000000000000000000;;	// useful for overriding List functions in delegation.
0000000000000000000000000000000000000000;;	func (p Pager) WithPageCreator(createPage func(r PageResult) Page) Pager {
0000000000000000000000000000000000000000;;		return Pager{
0000000000000000000000000000000000000000;;			client:     p.client,
0000000000000000000000000000000000000000;;			initialURL: p.initialURL,
0000000000000000000000000000000000000000;;			createPage: createPage,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Pager) fetchNextPage(url string) (Page, error) {
0000000000000000000000000000000000000000;;		resp, err := Request(p.client, p.Headers, url)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remembered, err := PageResultFrom(resp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p.createPage(remembered), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachPage iterates over each page returned by a Pager, yielding one at a time to a handler function.
0000000000000000000000000000000000000000;;	// Return "false" from the handler to prematurely stop iterating.
0000000000000000000000000000000000000000;;	func (p Pager) EachPage(handler func(Page) (bool, error)) error {
0000000000000000000000000000000000000000;;		if p.Err != nil {
0000000000000000000000000000000000000000;;			return p.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		currentURL := p.initialURL
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			currentPage, err := p.fetchNextPage(currentURL)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			empty, err := currentPage.IsEmpty()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if empty {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ok, err := handler(currentPage)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			currentURL, err = currentPage.NextPageURL()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if currentURL == "" {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllPages returns all the pages from a `List` operation in a single page,
0000000000000000000000000000000000000000;;	// allowing the user to retrieve all the pages at once.
0000000000000000000000000000000000000000;;	func (p Pager) AllPages() (Page, error) {
0000000000000000000000000000000000000000;;		// pagesSlice holds all the pages until they get converted into as Page Body.
0000000000000000000000000000000000000000;;		var pagesSlice []interface{}
0000000000000000000000000000000000000000;;		// body will contain the final concatenated Page body.
0000000000000000000000000000000000000000;;		var body reflect.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Grab a test page to ascertain the page body type.
0000000000000000000000000000000000000000;;		testPage, err := p.fetchNextPage(p.initialURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Store the page type so we can use reflection to create a new mega-page of
0000000000000000000000000000000000000000;;		// that type.
0000000000000000000000000000000000000000;;		pageType := reflect.TypeOf(testPage)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if it's a single page, just return the testPage (first page)
0000000000000000000000000000000000000000;;		if _, found := pageType.FieldByName("SinglePageBase"); found {
0000000000000000000000000000000000000000;;			return testPage, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Switch on the page body type. Recognized types are `map[string]interface{}`,
0000000000000000000000000000000000000000;;		// `[]byte`, and `[]interface{}`.
0000000000000000000000000000000000000000;;		switch testPage.GetBody().(type) {
0000000000000000000000000000000000000000;;		case map[string]interface{}:
0000000000000000000000000000000000000000;;			// key is the map key for the page body if the body type is `map[string]interface{}`.
0000000000000000000000000000000000000000;;			var key string
0000000000000000000000000000000000000000;;			// Iterate over the pages to concatenate the bodies.
0000000000000000000000000000000000000000;;			err := p.EachPage(func(page Page) (bool, error) {
0000000000000000000000000000000000000000;;				b := page.GetBody().(map[string]interface{})
0000000000000000000000000000000000000000;;				for k := range b {
0000000000000000000000000000000000000000;;					// If it's a linked page, we don't want the `links`, we want the other one.
0000000000000000000000000000000000000000;;					if !strings.HasSuffix(k, "links") {
0000000000000000000000000000000000000000;;						key = k
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch keyType := b[key].(type) {
0000000000000000000000000000000000000000;;				case map[string]interface{}:
0000000000000000000000000000000000000000;;					pagesSlice = append(pagesSlice, keyType)
0000000000000000000000000000000000000000;;				case []interface{}:
0000000000000000000000000000000000000000;;					pagesSlice = append(pagesSlice, b[key].([]interface{})...)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return false, fmt.Errorf("Unsupported page body type: %+v", keyType)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Set body to value of type `map[string]interface{}`
0000000000000000000000000000000000000000;;			body = reflect.MakeMap(reflect.MapOf(reflect.TypeOf(key), reflect.TypeOf(pagesSlice)))
0000000000000000000000000000000000000000;;			body.SetMapIndex(reflect.ValueOf(key), reflect.ValueOf(pagesSlice))
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			// Iterate over the pages to concatenate the bodies.
0000000000000000000000000000000000000000;;			err := p.EachPage(func(page Page) (bool, error) {
0000000000000000000000000000000000000000;;				b := page.GetBody().([]byte)
0000000000000000000000000000000000000000;;				pagesSlice = append(pagesSlice, b)
0000000000000000000000000000000000000000;;				// seperate pages with a comma
0000000000000000000000000000000000000000;;				pagesSlice = append(pagesSlice, []byte{10})
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(pagesSlice) > 0 {
0000000000000000000000000000000000000000;;				// Remove the trailing comma.
0000000000000000000000000000000000000000;;				pagesSlice = pagesSlice[:len(pagesSlice)-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var b []byte
0000000000000000000000000000000000000000;;			// Combine the slice of slices in to a single slice.
0000000000000000000000000000000000000000;;			for _, slice := range pagesSlice {
0000000000000000000000000000000000000000;;				b = append(b, slice.([]byte)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Set body to value of type `bytes`.
0000000000000000000000000000000000000000;;			body = reflect.New(reflect.TypeOf(b)).Elem()
0000000000000000000000000000000000000000;;			body.SetBytes(b)
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			// Iterate over the pages to concatenate the bodies.
0000000000000000000000000000000000000000;;			err := p.EachPage(func(page Page) (bool, error) {
0000000000000000000000000000000000000000;;				b := page.GetBody().([]interface{})
0000000000000000000000000000000000000000;;				pagesSlice = append(pagesSlice, b...)
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Set body to value of type `[]interface{}`
0000000000000000000000000000000000000000;;			body = reflect.MakeSlice(reflect.TypeOf(pagesSlice), len(pagesSlice), len(pagesSlice))
0000000000000000000000000000000000000000;;			for i, s := range pagesSlice {
0000000000000000000000000000000000000000;;				body.Index(i).Set(reflect.ValueOf(s))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Page body has unrecognized type.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Each `Extract*` function is expecting a specific type of page coming back,
0000000000000000000000000000000000000000;;		// otherwise the type assertion in those functions will fail. pageType is needed
0000000000000000000000000000000000000000;;		// to create a type in this method that has the same type that the `Extract*`
0000000000000000000000000000000000000000;;		// function is expecting and set the Body of that object to the concatenated
0000000000000000000000000000000000000000;;		// pages.
0000000000000000000000000000000000000000;;		page := reflect.New(pageType)
0000000000000000000000000000000000000000;;		// Set the page body to be the concatenated pages.
0000000000000000000000000000000000000000;;		page.Elem().FieldByName("Body").Set(body)
0000000000000000000000000000000000000000;;		// Set any additional headers that were pass along. The `objectstorage` pacakge,
0000000000000000000000000000000000000000;;		// for example, passes a Content-Type header.
0000000000000000000000000000000000000000;;		h := make(http.Header)
0000000000000000000000000000000000000000;;		for k, v := range p.Headers {
0000000000000000000000000000000000000000;;			h.Add(k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		page.Elem().FieldByName("Header").Set(reflect.ValueOf(h))
0000000000000000000000000000000000000000;;		// Type assert the page to a Page interface so that the type assertion in the
0000000000000000000000000000000000000000;;		// `Extract*` methods will work.
0000000000000000000000000000000000000000;;		return page.Elem().Interface().(Page), err
0000000000000000000000000000000000000000;;	}
