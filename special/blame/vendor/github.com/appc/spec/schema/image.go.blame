0000000000000000000000000000000000000000;;	// Copyright 2015 The appc Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8d973c48ce204bda083f5a578278a9cd3743f879;Godeps/_workspace/src/github.com/appc/spec/schema/image.go[Godeps/_workspace/src/github.com/appc/spec/schema/image.go][vendor/github.com/appc/spec/schema/image.go];	
0000000000000000000000000000000000000000;;	package schema
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/appc/spec/schema/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"go4.org/errorutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ACIExtension      = ".aci"
0000000000000000000000000000000000000000;;		ImageManifestKind = types.ACKind("ImageManifest")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ImageManifest struct {
0000000000000000000000000000000000000000;;		ACKind        types.ACKind       `json:"acKind"`
0000000000000000000000000000000000000000;;		ACVersion     types.SemVer       `json:"acVersion"`
0000000000000000000000000000000000000000;;		Name          types.ACIdentifier `json:"name"`
0000000000000000000000000000000000000000;;		Labels        types.Labels       `json:"labels,omitempty"`
0000000000000000000000000000000000000000;;		App           *types.App         `json:"app,omitempty"`
0000000000000000000000000000000000000000;;		Annotations   types.Annotations  `json:"annotations,omitempty"`
0000000000000000000000000000000000000000;;		Dependencies  types.Dependencies `json:"dependencies,omitempty"`
0000000000000000000000000000000000000000;;		PathWhitelist []string           `json:"pathWhitelist,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// imageManifest is a model to facilitate extra validation during the
0000000000000000000000000000000000000000;;	// unmarshalling of the ImageManifest
0000000000000000000000000000000000000000;;	type imageManifest ImageManifest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BlankImageManifest() *ImageManifest {
0000000000000000000000000000000000000000;;		return &ImageManifest{ACKind: ImageManifestKind, ACVersion: AppContainerVersion}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (im *ImageManifest) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		a := imageManifest(*im)
0000000000000000000000000000000000000000;;		err := json.Unmarshal(data, &a)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if serr, ok := err.(*json.SyntaxError); ok {
0000000000000000000000000000000000000000;;				line, col, highlight := errorutil.HighlightBytePosition(bytes.NewReader(data), serr.Offset)
0000000000000000000000000000000000000000;;				return fmt.Errorf("\nError at line %d, column %d\n%s%v", line, col, highlight, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nim := ImageManifest(a)
0000000000000000000000000000000000000000;;		if err := nim.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*im = nim
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (im ImageManifest) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if err := im.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(imageManifest(im))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var imKindError = types.InvalidACKindError(ImageManifestKind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assertValid performs extra assertions on an ImageManifest to ensure that
0000000000000000000000000000000000000000;;	// fields are set appropriately, etc. It is used exclusively when marshalling
0000000000000000000000000000000000000000;;	// and unmarshalling an ImageManifest. Most field-specific validation is
0000000000000000000000000000000000000000;;	// performed through the individual types being marshalled; assertValid()
0000000000000000000000000000000000000000;;	// should only deal with higher-level validation.
0000000000000000000000000000000000000000;;	func (im *ImageManifest) assertValid() error {
0000000000000000000000000000000000000000;;		if im.ACKind != ImageManifestKind {
0000000000000000000000000000000000000000;;			return imKindError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if im.ACVersion.Empty() {
0000000000000000000000000000000000000000;;			return errors.New(`acVersion must be set`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if im.Name.Empty() {
0000000000000000000000000000000000000000;;			return errors.New(`name must be set`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (im *ImageManifest) GetLabel(name string) (val string, ok bool) {
0000000000000000000000000000000000000000;;		return im.Labels.Get(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (im *ImageManifest) GetAnnotation(name string) (val string, ok bool) {
0000000000000000000000000000000000000000;;		return im.Annotations.Get(name)
0000000000000000000000000000000000000000;;	}
