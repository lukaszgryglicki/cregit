0000000000000000000000000000000000000000;;	// Copyright 2015 The appc Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8d973c48ce204bda083f5a578278a9cd3743f879;Godeps/_workspace/src/github.com/appc/spec/schema/pod.go[Godeps/_workspace/src/github.com/appc/spec/schema/pod.go][vendor/github.com/appc/spec/schema/pod.go];	
0000000000000000000000000000000000000000;;	package schema
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/appc/spec/schema/types"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"go4.org/errorutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const PodManifestKind = types.ACKind("PodManifest")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PodManifest struct {
0000000000000000000000000000000000000000;;		ACVersion       types.SemVer          `json:"acVersion"`
0000000000000000000000000000000000000000;;		ACKind          types.ACKind          `json:"acKind"`
0000000000000000000000000000000000000000;;		Apps            AppList               `json:"apps"`
0000000000000000000000000000000000000000;;		Volumes         []types.Volume        `json:"volumes"`
0000000000000000000000000000000000000000;;		Isolators       []types.Isolator      `json:"isolators"`
0000000000000000000000000000000000000000;;		Annotations     types.Annotations     `json:"annotations"`
0000000000000000000000000000000000000000;;		Ports           []types.ExposedPort   `json:"ports"`
0000000000000000000000000000000000000000;;		UserAnnotations types.UserAnnotations `json:"userAnnotations,omitempty"`
0000000000000000000000000000000000000000;;		UserLabels      types.UserLabels      `json:"userLabels,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// podManifest is a model to facilitate extra validation during the
0000000000000000000000000000000000000000;;	// unmarshalling of the PodManifest
0000000000000000000000000000000000000000;;	type podManifest PodManifest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BlankPodManifest() *PodManifest {
0000000000000000000000000000000000000000;;		return &PodManifest{ACKind: PodManifestKind, ACVersion: AppContainerVersion}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm *PodManifest) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		p := podManifest(*pm)
0000000000000000000000000000000000000000;;		err := json.Unmarshal(data, &p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if serr, ok := err.(*json.SyntaxError); ok {
0000000000000000000000000000000000000000;;				line, col, highlight := errorutil.HighlightBytePosition(bytes.NewReader(data), serr.Offset)
0000000000000000000000000000000000000000;;				return fmt.Errorf("\nError at line %d, column %d\n%s%v", line, col, highlight, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		npm := PodManifest(p)
0000000000000000000000000000000000000000;;		if err := npm.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*pm = npm
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pm PodManifest) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if err := pm.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(podManifest(pm))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var pmKindError = types.InvalidACKindError(PodManifestKind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assertValid performs extra assertions on an PodManifest to
0000000000000000000000000000000000000000;;	// ensure that fields are set appropriately, etc. It is used exclusively when
0000000000000000000000000000000000000000;;	// marshalling and unmarshalling an PodManifest. Most
0000000000000000000000000000000000000000;;	// field-specific validation is performed through the individual types being
0000000000000000000000000000000000000000;;	// marshalled; assertValid() should only deal with higher-level validation.
0000000000000000000000000000000000000000;;	func (pm *PodManifest) assertValid() error {
0000000000000000000000000000000000000000;;		if pm.ACKind != PodManifestKind {
0000000000000000000000000000000000000000;;			return pmKindError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AppList []RuntimeApp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type appList AppList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (al *AppList) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		a := appList{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(data, &a)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nal := AppList(a)
0000000000000000000000000000000000000000;;		if err := nal.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*al = nal
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (al AppList) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if err := al.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(appList(al))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (al AppList) assertValid() error {
0000000000000000000000000000000000000000;;		seen := map[types.ACName]bool{}
0000000000000000000000000000000000000000;;		for _, a := range al {
0000000000000000000000000000000000000000;;			if _, ok := seen[a.Name]; ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf(`duplicate apps of name %q`, a.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			seen[a.Name] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get retrieves an app by the specified name from the AppList; if there is
0000000000000000000000000000000000000000;;	// no such app, nil is returned. The returned *RuntimeApp MUST be considered
0000000000000000000000000000000000000000;;	// read-only.
0000000000000000000000000000000000000000;;	func (al AppList) Get(name types.ACName) *RuntimeApp {
0000000000000000000000000000000000000000;;		for _, a := range al {
0000000000000000000000000000000000000000;;			if name.Equals(a.Name) {
0000000000000000000000000000000000000000;;				aa := a
0000000000000000000000000000000000000000;;				return &aa
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mount describes the mapping between a volume and the path it is mounted
0000000000000000000000000000000000000000;;	// inside of an app's filesystem.
0000000000000000000000000000000000000000;;	// The AppVolume is optional. If missing, the pod-level Volume of the
0000000000000000000000000000000000000000;;	// same name shall be used.
0000000000000000000000000000000000000000;;	type Mount struct {
0000000000000000000000000000000000000000;;		Volume    types.ACName  `json:"volume"`
0000000000000000000000000000000000000000;;		Path      string        `json:"path"`
0000000000000000000000000000000000000000;;		AppVolume *types.Volume `json:"appVolume,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r Mount) assertValid() error {
0000000000000000000000000000000000000000;;		if r.Volume.Empty() {
0000000000000000000000000000000000000000;;			return errors.New("volume must be set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.Path == "" {
0000000000000000000000000000000000000000;;			return errors.New("path must be set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RuntimeApp describes an application referenced in a PodManifest
0000000000000000000000000000000000000000;;	type RuntimeApp struct {
0000000000000000000000000000000000000000;;		Name           types.ACName      `json:"name"`
0000000000000000000000000000000000000000;;		Image          RuntimeImage      `json:"image"`
0000000000000000000000000000000000000000;;		App            *types.App        `json:"app,omitempty"`
0000000000000000000000000000000000000000;;		ReadOnlyRootFS bool              `json:"readOnlyRootFS,omitempty"`
0000000000000000000000000000000000000000;;		Mounts         []Mount           `json:"mounts,omitempty"`
0000000000000000000000000000000000000000;;		Annotations    types.Annotations `json:"annotations,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RuntimeImage describes an image referenced in a RuntimeApp
0000000000000000000000000000000000000000;;	type RuntimeImage struct {
0000000000000000000000000000000000000000;;		Name   *types.ACIdentifier `json:"name,omitempty"`
0000000000000000000000000000000000000000;;		ID     types.Hash          `json:"id"`
0000000000000000000000000000000000000000;;		Labels types.Labels        `json:"labels,omitempty"`
0000000000000000000000000000000000000000;;	}
