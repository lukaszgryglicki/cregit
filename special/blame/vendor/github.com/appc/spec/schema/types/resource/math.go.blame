0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors All rights reserved.
e1b2a6921d4ce46e5ce744e6c28b538bd077b3b7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inf "gopkg.in/inf.v0"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// maxInt64Factors is the highest value that will be checked when removing factors of 10 from an int64.
0000000000000000000000000000000000000000;;		// It is also the maximum decimal digits that can be represented with an int64.
0000000000000000000000000000000000000000;;		maxInt64Factors = 18
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Commonly needed big.Int values-- treat as read only!
0000000000000000000000000000000000000000;;		bigTen      = big.NewInt(10)
0000000000000000000000000000000000000000;;		bigZero     = big.NewInt(0)
0000000000000000000000000000000000000000;;		bigOne      = big.NewInt(1)
0000000000000000000000000000000000000000;;		bigThousand = big.NewInt(1000)
0000000000000000000000000000000000000000;;		big1024     = big.NewInt(1024)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Commonly needed inf.Dec values-- treat as read only!
0000000000000000000000000000000000000000;;		decZero      = inf.NewDec(0, 0)
0000000000000000000000000000000000000000;;		decOne       = inf.NewDec(1, 0)
0000000000000000000000000000000000000000;;		decMinusOne  = inf.NewDec(-1, 0)
0000000000000000000000000000000000000000;;		decThousand  = inf.NewDec(1000, 0)
0000000000000000000000000000000000000000;;		dec1024      = inf.NewDec(1024, 0)
0000000000000000000000000000000000000000;;		decMinus1024 = inf.NewDec(-1024, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Largest (in magnitude) number allowed.
0000000000000000000000000000000000000000;;		maxAllowed = infDecAmount{inf.NewDec((1<<63)-1, 0)} // == max int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The maximum value we can represent milli-units for.
0000000000000000000000000000000000000000;;		// Compare with the return value of Quantity.Value() to
0000000000000000000000000000000000000000;;		// see if it's safe to use Quantity.MilliValue().
0000000000000000000000000000000000000000;;		MaxMilliValue = int64(((1 << 63) - 1) / 1000)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const mostNegative = -(mostPositive + 1)
0000000000000000000000000000000000000000;;	const mostPositive = 1<<63 - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// int64Add returns a+b, or false if that would overflow int64.
0000000000000000000000000000000000000000;;	func int64Add(a, b int64) (int64, bool) {
0000000000000000000000000000000000000000;;		c := a + b
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case a > 0 && b > 0:
0000000000000000000000000000000000000000;;			if c < 0 {
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case a < 0 && b < 0:
0000000000000000000000000000000000000000;;			if c > 0 {
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if a == mostNegative && b == mostNegative {
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// int64Multiply returns a*b, or false if that would overflow or underflow int64.
0000000000000000000000000000000000000000;;	func int64Multiply(a, b int64) (int64, bool) {
0000000000000000000000000000000000000000;;		if a == 0 || b == 0 || a == 1 || b == 1 {
0000000000000000000000000000000000000000;;			return a * b, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a == mostNegative || b == mostNegative {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := a * b
0000000000000000000000000000000000000000;;		return c, c/b == a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// int64MultiplyScale returns a*b, assuming b is greater than one, or false if that would overflow or underflow int64.
0000000000000000000000000000000000000000;;	// Use when b is known to be greater than one.
0000000000000000000000000000000000000000;;	func int64MultiplyScale(a int64, b int64) (int64, bool) {
0000000000000000000000000000000000000000;;		if a == 0 || a == 1 {
0000000000000000000000000000000000000000;;			return a * b, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a == mostNegative && b != 1 {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := a * b
0000000000000000000000000000000000000000;;		return c, c/b == a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// int64MultiplyScale10 multiplies a by 10, or returns false if that would overflow. This method is faster than
0000000000000000000000000000000000000000;;	// int64Multiply(a, 10) because the compiler can optimize constant factor multiplication.
0000000000000000000000000000000000000000;;	func int64MultiplyScale10(a int64) (int64, bool) {
0000000000000000000000000000000000000000;;		if a == 0 || a == 1 {
0000000000000000000000000000000000000000;;			return a * 10, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a == mostNegative {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := a * 10
0000000000000000000000000000000000000000;;		return c, c/10 == a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// int64MultiplyScale100 multiplies a by 100, or returns false if that would overflow. This method is faster than
0000000000000000000000000000000000000000;;	// int64Multiply(a, 100) because the compiler can optimize constant factor multiplication.
0000000000000000000000000000000000000000;;	func int64MultiplyScale100(a int64) (int64, bool) {
0000000000000000000000000000000000000000;;		if a == 0 || a == 1 {
0000000000000000000000000000000000000000;;			return a * 100, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a == mostNegative {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := a * 100
0000000000000000000000000000000000000000;;		return c, c/100 == a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// int64MultiplyScale1000 multiplies a by 1000, or returns false if that would overflow. This method is faster than
0000000000000000000000000000000000000000;;	// int64Multiply(a, 1000) because the compiler can optimize constant factor multiplication.
0000000000000000000000000000000000000000;;	func int64MultiplyScale1000(a int64) (int64, bool) {
0000000000000000000000000000000000000000;;		if a == 0 || a == 1 {
0000000000000000000000000000000000000000;;			return a * 1000, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a == mostNegative {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := a * 1000
0000000000000000000000000000000000000000;;		return c, c/1000 == a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// positiveScaleInt64 multiplies base by 10^scale, returning false if the
0000000000000000000000000000000000000000;;	// value overflows. Passing a negative scale is undefined.
0000000000000000000000000000000000000000;;	func positiveScaleInt64(base int64, scale Scale) (int64, bool) {
0000000000000000000000000000000000000000;;		switch scale {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return base, true
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			return int64MultiplyScale10(base)
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			return int64MultiplyScale100(base)
0000000000000000000000000000000000000000;;		case 3:
0000000000000000000000000000000000000000;;			return int64MultiplyScale1000(base)
0000000000000000000000000000000000000000;;		case 6:
0000000000000000000000000000000000000000;;			return int64MultiplyScale(base, 1000000)
0000000000000000000000000000000000000000;;		case 9:
0000000000000000000000000000000000000000;;			return int64MultiplyScale(base, 1000000000)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			value := base
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			for i := Scale(0); i < scale; i++ {
0000000000000000000000000000000000000000;;				if value, ok = int64MultiplyScale(value, 10); !ok {
0000000000000000000000000000000000000000;;					return 0, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return value, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// negativeScaleInt64 reduces base by the provided scale, rounding up, until the
0000000000000000000000000000000000000000;;	// value is zero or the scale is reached. Passing a negative scale is undefined.
0000000000000000000000000000000000000000;;	// The value returned, if not exact, is rounded away from zero.
0000000000000000000000000000000000000000;;	func negativeScaleInt64(base int64, scale Scale) (result int64, exact bool) {
0000000000000000000000000000000000000000;;		if scale == 0 {
0000000000000000000000000000000000000000;;			return base, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		value := base
0000000000000000000000000000000000000000;;		var fraction bool
0000000000000000000000000000000000000000;;		for i := Scale(0); i < scale; i++ {
0000000000000000000000000000000000000000;;			if !fraction && value%10 != 0 {
0000000000000000000000000000000000000000;;				fraction = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value = value / 10
0000000000000000000000000000000000000000;;			if value == 0 {
0000000000000000000000000000000000000000;;				if fraction {
0000000000000000000000000000000000000000;;					if base > 0 {
0000000000000000000000000000000000000000;;						return 1, false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return -1, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return 0, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fraction {
0000000000000000000000000000000000000000;;			if base > 0 {
0000000000000000000000000000000000000000;;				value += 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				value += -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value, !fraction
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pow10Int64(b int64) int64 {
0000000000000000000000000000000000000000;;		switch b {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			return 10
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			return 100
0000000000000000000000000000000000000000;;		case 3:
0000000000000000000000000000000000000000;;			return 1000
0000000000000000000000000000000000000000;;		case 4:
0000000000000000000000000000000000000000;;			return 10000
0000000000000000000000000000000000000000;;		case 5:
0000000000000000000000000000000000000000;;			return 100000
0000000000000000000000000000000000000000;;		case 6:
0000000000000000000000000000000000000000;;			return 1000000
0000000000000000000000000000000000000000;;		case 7:
0000000000000000000000000000000000000000;;			return 10000000
0000000000000000000000000000000000000000;;		case 8:
0000000000000000000000000000000000000000;;			return 100000000
0000000000000000000000000000000000000000;;		case 9:
0000000000000000000000000000000000000000;;			return 1000000000
0000000000000000000000000000000000000000;;		case 10:
0000000000000000000000000000000000000000;;			return 10000000000
0000000000000000000000000000000000000000;;		case 11:
0000000000000000000000000000000000000000;;			return 100000000000
0000000000000000000000000000000000000000;;		case 12:
0000000000000000000000000000000000000000;;			return 1000000000000
0000000000000000000000000000000000000000;;		case 13:
0000000000000000000000000000000000000000;;			return 10000000000000
0000000000000000000000000000000000000000;;		case 14:
0000000000000000000000000000000000000000;;			return 100000000000000
0000000000000000000000000000000000000000;;		case 15:
0000000000000000000000000000000000000000;;			return 1000000000000000
0000000000000000000000000000000000000000;;		case 16:
0000000000000000000000000000000000000000;;			return 10000000000000000
0000000000000000000000000000000000000000;;		case 17:
0000000000000000000000000000000000000000;;			return 100000000000000000
0000000000000000000000000000000000000000;;		case 18:
0000000000000000000000000000000000000000;;			return 1000000000000000000
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// powInt64 raises a to the bth power. Is not overflow aware.
0000000000000000000000000000000000000000;;	func powInt64(a, b int64) int64 {
0000000000000000000000000000000000000000;;		p := int64(1)
0000000000000000000000000000000000000000;;		for b > 0 {
0000000000000000000000000000000000000000;;			if b&1 != 0 {
0000000000000000000000000000000000000000;;				p *= a
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b >>= 1
0000000000000000000000000000000000000000;;			a *= a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// negativeScaleInt64 returns the result of dividing base by scale * 10 and the remainder, or
0000000000000000000000000000000000000000;;	// false if no such division is possible. Dividing by negative scales is undefined.
0000000000000000000000000000000000000000;;	func divideByScaleInt64(base int64, scale Scale) (result, remainder int64, exact bool) {
0000000000000000000000000000000000000000;;		if scale == 0 {
0000000000000000000000000000000000000000;;			return base, 0, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// the max scale representable in base 10 in an int64 is 18 decimal places
0000000000000000000000000000000000000000;;		if scale >= 18 {
0000000000000000000000000000000000000000;;			return 0, base, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		divisor := pow10Int64(int64(scale))
0000000000000000000000000000000000000000;;		return base / divisor, base % divisor, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeInt64Factors divides in a loop; the return values have the property that
0000000000000000000000000000000000000000;;	// value == result * base ^ scale
0000000000000000000000000000000000000000;;	func removeInt64Factors(value int64, base int64) (result int64, times int32) {
0000000000000000000000000000000000000000;;		times = 0
0000000000000000000000000000000000000000;;		result = value
0000000000000000000000000000000000000000;;		negative := result < 0
0000000000000000000000000000000000000000;;		if negative {
0000000000000000000000000000000000000000;;			result = -result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch base {
0000000000000000000000000000000000000000;;		// allow the compiler to optimize the common cases
0000000000000000000000000000000000000000;;		case 10:
0000000000000000000000000000000000000000;;			for result >= 10 && result%10 == 0 {
0000000000000000000000000000000000000000;;				times++
0000000000000000000000000000000000000000;;				result = result / 10
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		// allow the compiler to optimize the common cases
0000000000000000000000000000000000000000;;		case 1024:
0000000000000000000000000000000000000000;;			for result >= 1024 && result%1024 == 0 {
0000000000000000000000000000000000000000;;				times++
0000000000000000000000000000000000000000;;				result = result / 1024
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			for result >= base && result%base == 0 {
0000000000000000000000000000000000000000;;				times++
0000000000000000000000000000000000000000;;				result = result / base
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if negative {
0000000000000000000000000000000000000000;;			result = -result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, times
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeBigIntFactors divides in a loop; the return values have the property that
0000000000000000000000000000000000000000;;	// d == result * factor ^ times
0000000000000000000000000000000000000000;;	// d may be modified in place.
0000000000000000000000000000000000000000;;	// If d == 0, then the return values will be (0, 0)
0000000000000000000000000000000000000000;;	func removeBigIntFactors(d, factor *big.Int) (result *big.Int, times int32) {
0000000000000000000000000000000000000000;;		q := big.NewInt(0)
0000000000000000000000000000000000000000;;		m := big.NewInt(0)
0000000000000000000000000000000000000000;;		for d.Cmp(bigZero) != 0 {
0000000000000000000000000000000000000000;;			q.DivMod(d, factor, m)
0000000000000000000000000000000000000000;;			if m.Cmp(bigZero) != 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			times++
0000000000000000000000000000000000000000;;			d, q = q, d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d, times
0000000000000000000000000000000000000000;;	}
