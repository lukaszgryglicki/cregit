0000000000000000000000000000000000000000;;	// Copyright 2015 The appc Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8d973c48ce204bda083f5a578278a9cd3743f879;Godeps/_workspace/src/github.com/appc/spec/schema/types/isolator_resources.go[Godeps/_workspace/src/github.com/appc/spec/schema/types/isolator_resources.go][vendor/github.com/appc/spec/schema/types/isolator_resources.go];	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/appc/spec/schema/types/resource"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrDefaultTrue     = errors.New("default must be false")
0000000000000000000000000000000000000000;;		ErrDefaultRequired = errors.New("default must be true")
0000000000000000000000000000000000000000;;		ErrRequestNonEmpty = errors.New("request not supported by this resource, must be empty")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ResourceIsolatorNames = make(map[ACIdentifier]struct{})
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ResourceBlockBandwidthName   = "resource/block-bandwidth"
0000000000000000000000000000000000000000;;		ResourceBlockIOPSName        = "resource/block-iops"
0000000000000000000000000000000000000000;;		ResourceCPUName              = "resource/cpu"
0000000000000000000000000000000000000000;;		ResourceMemoryName           = "resource/memory"
0000000000000000000000000000000000000000;;		ResourceNetworkBandwidthName = "resource/network-bandwidth"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		for name, con := range map[ACIdentifier]IsolatorValueConstructor{
0000000000000000000000000000000000000000;;			ResourceBlockBandwidthName:   func() IsolatorValue { return &ResourceBlockBandwidth{} },
0000000000000000000000000000000000000000;;			ResourceBlockIOPSName:        func() IsolatorValue { return &ResourceBlockIOPS{} },
0000000000000000000000000000000000000000;;			ResourceCPUName:              func() IsolatorValue { return &ResourceCPU{} },
0000000000000000000000000000000000000000;;			ResourceMemoryName:           func() IsolatorValue { return &ResourceMemory{} },
0000000000000000000000000000000000000000;;			ResourceNetworkBandwidthName: func() IsolatorValue { return &ResourceNetworkBandwidth{} },
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			AddIsolatorName(name, ResourceIsolatorNames)
0000000000000000000000000000000000000000;;			AddIsolatorValueConstructor(name, con)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Resource interface {
0000000000000000000000000000000000000000;;		Limit() *resource.Quantity
0000000000000000000000000000000000000000;;		Request() *resource.Quantity
0000000000000000000000000000000000000000;;		Default() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceBase struct {
0000000000000000000000000000000000000000;;		val resourceValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type resourceValue struct {
0000000000000000000000000000000000000000;;		Default bool               `json:"default"`
0000000000000000000000000000000000000000;;		Request *resource.Quantity `json:"request"`
0000000000000000000000000000000000000000;;		Limit   *resource.Quantity `json:"limit"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceBase) Limit() *resource.Quantity {
0000000000000000000000000000000000000000;;		return r.val.Limit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r ResourceBase) Request() *resource.Quantity {
0000000000000000000000000000000000000000;;		return r.val.Request
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r ResourceBase) Default() bool {
0000000000000000000000000000000000000000;;		return r.val.Default
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *ResourceBase) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		return json.Unmarshal(b, &r.val)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceBase) AssertValid() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(lucab): both need to be clarified in spec,
0000000000000000000000000000000000000000;;	// see https://github.com/appc/spec/issues/625
0000000000000000000000000000000000000000;;	func (l ResourceBase) multipleAllowed() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (l ResourceBase) Conflicts() []ACIdentifier {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceBlockBandwidth struct {
0000000000000000000000000000000000000000;;		ResourceBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceBlockBandwidth) AssertValid() error {
0000000000000000000000000000000000000000;;		if r.Default() != true {
0000000000000000000000000000000000000000;;			return ErrDefaultRequired
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.Request() != nil {
0000000000000000000000000000000000000000;;			return ErrRequestNonEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceBlockIOPS struct {
0000000000000000000000000000000000000000;;		ResourceBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceBlockIOPS) AssertValid() error {
0000000000000000000000000000000000000000;;		if r.Default() != true {
0000000000000000000000000000000000000000;;			return ErrDefaultRequired
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.Request() != nil {
0000000000000000000000000000000000000000;;			return ErrRequestNonEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceCPU struct {
0000000000000000000000000000000000000000;;		ResourceBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceCPU) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("ResourceCPU(request=%s, limit=%s)", r.Request(), r.Limit())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceCPU) AssertValid() error {
0000000000000000000000000000000000000000;;		if r.Default() != false {
0000000000000000000000000000000000000000;;			return ErrDefaultTrue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceCPU) AsIsolator() Isolator {
0000000000000000000000000000000000000000;;		isol := isolatorMap[ResourceCPUName]()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := json.Marshal(r.val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		valRaw := json.RawMessage(b)
0000000000000000000000000000000000000000;;		return Isolator{
0000000000000000000000000000000000000000;;			Name:     ResourceCPUName,
0000000000000000000000000000000000000000;;			ValueRaw: &valRaw,
0000000000000000000000000000000000000000;;			value:    isol,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResourceCPUIsolator(request, limit string) (*ResourceCPU, error) {
0000000000000000000000000000000000000000;;		req, err := resource.ParseQuantity(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lim, err := resource.ParseQuantity(limit)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing limit: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res := &ResourceCPU{
0000000000000000000000000000000000000000;;			ResourceBase{
0000000000000000000000000000000000000000;;				resourceValue{
0000000000000000000000000000000000000000;;					Request: &req,
0000000000000000000000000000000000000000;;					Limit:   &lim,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := res.AssertValid(); err != nil {
0000000000000000000000000000000000000000;;			// should never happen
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceMemory struct {
0000000000000000000000000000000000000000;;		ResourceBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceMemory) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("ResourceMemory(request=%s, limit=%s)", r.Request(), r.Limit())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceMemory) AssertValid() error {
0000000000000000000000000000000000000000;;		if r.Default() != false {
0000000000000000000000000000000000000000;;			return ErrDefaultTrue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceMemory) AsIsolator() Isolator {
0000000000000000000000000000000000000000;;		isol := isolatorMap[ResourceMemoryName]()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := json.Marshal(r.val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		valRaw := json.RawMessage(b)
0000000000000000000000000000000000000000;;		return Isolator{
0000000000000000000000000000000000000000;;			Name:     ResourceMemoryName,
0000000000000000000000000000000000000000;;			ValueRaw: &valRaw,
0000000000000000000000000000000000000000;;			value:    isol,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResourceMemoryIsolator(request, limit string) (*ResourceMemory, error) {
0000000000000000000000000000000000000000;;		req, err := resource.ParseQuantity(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lim, err := resource.ParseQuantity(limit)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing limit: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res := &ResourceMemory{
0000000000000000000000000000000000000000;;			ResourceBase{
0000000000000000000000000000000000000000;;				resourceValue{
0000000000000000000000000000000000000000;;					Request: &req,
0000000000000000000000000000000000000000;;					Limit:   &lim,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := res.AssertValid(); err != nil {
0000000000000000000000000000000000000000;;			// should never happen
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceNetworkBandwidth struct {
0000000000000000000000000000000000000000;;		ResourceBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r ResourceNetworkBandwidth) AssertValid() error {
0000000000000000000000000000000000000000;;		if r.Default() != true {
0000000000000000000000000000000000000000;;			return ErrDefaultRequired
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.Request() != nil {
0000000000000000000000000000000000000000;;			return ErrRequestNonEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
