0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors All rights reserved.
e1b2a6921d4ce46e5ce744e6c28b538bd077b3b7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inf "gopkg.in/inf.v0"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scale is used for getting and setting the base-10 scaled value.
0000000000000000000000000000000000000000;;	// Base-2 scales are omitted for mathematical simplicity.
0000000000000000000000000000000000000000;;	// See Quantity.ScaledValue for more details.
0000000000000000000000000000000000000000;;	type Scale int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// infScale adapts a Scale value to an inf.Scale value.
0000000000000000000000000000000000000000;;	func (s Scale) infScale() inf.Scale {
0000000000000000000000000000000000000000;;		return inf.Scale(-s) // inf.Scale is upside-down
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Nano  Scale = -9
0000000000000000000000000000000000000000;;		Micro Scale = -6
0000000000000000000000000000000000000000;;		Milli Scale = -3
0000000000000000000000000000000000000000;;		Kilo  Scale = 3
0000000000000000000000000000000000000000;;		Mega  Scale = 6
0000000000000000000000000000000000000000;;		Giga  Scale = 9
0000000000000000000000000000000000000000;;		Tera  Scale = 12
0000000000000000000000000000000000000000;;		Peta  Scale = 15
0000000000000000000000000000000000000000;;		Exa   Scale = 18
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		Zero = int64Amount{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Used by quantity strings - treat as read only
0000000000000000000000000000000000000000;;		zeroBytes = []byte("0")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// int64Amount represents a fixed precision numerator and arbitrary scale exponent. It is faster
0000000000000000000000000000000000000000;;	// than operations on inf.Dec for values that can be represented as int64.
0000000000000000000000000000000000000000;;	type int64Amount struct {
0000000000000000000000000000000000000000;;		value int64
0000000000000000000000000000000000000000;;		scale Scale
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign returns 0 if the value is zero, -1 if it is less than 0, or 1 if it is greater than 0.
0000000000000000000000000000000000000000;;	func (a int64Amount) Sign() int {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case a.value == 0:
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		case a.value > 0:
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsInt64 returns the current amount as an int64 at scale 0, or false if the value cannot be
0000000000000000000000000000000000000000;;	// represented in an int64 OR would result in a loss of precision. This method is intended as
0000000000000000000000000000000000000000;;	// an optimization to avoid calling AsDec.
0000000000000000000000000000000000000000;;	func (a int64Amount) AsInt64() (int64, bool) {
0000000000000000000000000000000000000000;;		if a.scale == 0 {
0000000000000000000000000000000000000000;;			return a.value, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.scale < 0 {
0000000000000000000000000000000000000000;;			// TODO: attempt to reduce factors, although it is assumed that factors are reduced prior
0000000000000000000000000000000000000000;;			// to the int64Amount being created.
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return positiveScaleInt64(a.value, a.scale)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsScaledInt64 returns an int64 representing the value of this amount at the specified scale,
0000000000000000000000000000000000000000;;	// rounding up, or false if that would result in overflow. (1e20).AsScaledInt64(1) would result
0000000000000000000000000000000000000000;;	// in overflow because 1e19 is not representable as an int64. Note that setting a scale larger
0000000000000000000000000000000000000000;;	// than the current value may result in loss of precision - i.e. (1e-6).AsScaledInt64(0) would
0000000000000000000000000000000000000000;;	// return 1, because 0.000001 is rounded up to 1.
0000000000000000000000000000000000000000;;	func (a int64Amount) AsScaledInt64(scale Scale) (result int64, ok bool) {
0000000000000000000000000000000000000000;;		if a.scale < scale {
0000000000000000000000000000000000000000;;			result, _ = negativeScaleInt64(a.value, scale-a.scale)
0000000000000000000000000000000000000000;;			return result, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return positiveScaleInt64(a.value, a.scale-scale)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsDec returns an inf.Dec representation of this value.
0000000000000000000000000000000000000000;;	func (a int64Amount) AsDec() *inf.Dec {
0000000000000000000000000000000000000000;;		var base inf.Dec
0000000000000000000000000000000000000000;;		base.SetUnscaled(a.value)
0000000000000000000000000000000000000000;;		base.SetScale(inf.Scale(-a.scale))
0000000000000000000000000000000000000000;;		return &base
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cmp returns 0 if a and b are equal, 1 if a is greater than b, or -1 if a is less than b.
0000000000000000000000000000000000000000;;	func (a int64Amount) Cmp(b int64Amount) int {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case a.scale == b.scale:
0000000000000000000000000000000000000000;;			// compare only the unscaled portion
0000000000000000000000000000000000000000;;		case a.scale > b.scale:
0000000000000000000000000000000000000000;;			result, remainder, exact := divideByScaleInt64(b.value, a.scale-b.scale)
0000000000000000000000000000000000000000;;			if !exact {
0000000000000000000000000000000000000000;;				return a.AsDec().Cmp(b.AsDec())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result == a.value {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case remainder == 0:
0000000000000000000000000000000000000000;;					return 0
0000000000000000000000000000000000000000;;				case remainder > 0:
0000000000000000000000000000000000000000;;					return -1
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.value = result
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			result, remainder, exact := divideByScaleInt64(a.value, b.scale-a.scale)
0000000000000000000000000000000000000000;;			if !exact {
0000000000000000000000000000000000000000;;				return a.AsDec().Cmp(b.AsDec())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result == b.value {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case remainder == 0:
0000000000000000000000000000000000000000;;					return 0
0000000000000000000000000000000000000000;;				case remainder > 0:
0000000000000000000000000000000000000000;;					return 1
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return -1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a.value = result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case a.value == b.value:
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		case a.value < b.value:
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds two int64Amounts together, matching scales. It will return false and not mutate
0000000000000000000000000000000000000000;;	// a if overflow or underflow would result.
0000000000000000000000000000000000000000;;	func (a *int64Amount) Add(b int64Amount) bool {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case b.value == 0:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case a.value == 0:
0000000000000000000000000000000000000000;;			a.value = b.value
0000000000000000000000000000000000000000;;			a.scale = b.scale
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case a.scale == b.scale:
0000000000000000000000000000000000000000;;			c, ok := int64Add(a.value, b.value)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a.value = c
0000000000000000000000000000000000000000;;		case a.scale > b.scale:
0000000000000000000000000000000000000000;;			c, ok := positiveScaleInt64(a.value, a.scale-b.scale)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c, ok = int64Add(c, b.value)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a.scale = b.scale
0000000000000000000000000000000000000000;;			a.value = c
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			c, ok := positiveScaleInt64(b.value, b.scale-a.scale)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c, ok = int64Add(a.value, c)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a.value = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sub removes the value of b from the current amount, or returns false if underflow would result.
0000000000000000000000000000000000000000;;	func (a *int64Amount) Sub(b int64Amount) bool {
0000000000000000000000000000000000000000;;		return a.Add(int64Amount{value: -b.value, scale: b.scale})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsScale adjusts this amount to set a minimum scale, rounding up, and returns true iff no precision
0000000000000000000000000000000000000000;;	// was lost. (1.1e5).AsScale(5) would return 1.1e5, but (1.1e5).AsScale(6) would return 1e6.
0000000000000000000000000000000000000000;;	func (a int64Amount) AsScale(scale Scale) (int64Amount, bool) {
0000000000000000000000000000000000000000;;		if a.scale >= scale {
0000000000000000000000000000000000000000;;			return a, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, exact := negativeScaleInt64(a.value, scale-a.scale)
0000000000000000000000000000000000000000;;		return int64Amount{value: result, scale: scale}, exact
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsCanonicalBytes accepts a buffer to write the base-10 string value of this field to, and returns
0000000000000000000000000000000000000000;;	// either that buffer or a larger buffer and the current exponent of the value. The value is adjusted
0000000000000000000000000000000000000000;;	// until the exponent is a multiple of 3 - i.e. 1.1e5 would return "110", 3.
0000000000000000000000000000000000000000;;	func (a int64Amount) AsCanonicalBytes(out []byte) (result []byte, exponent int32) {
0000000000000000000000000000000000000000;;		mantissa := a.value
0000000000000000000000000000000000000000;;		exponent = int32(a.scale)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		amount, times := removeInt64Factors(mantissa, 10)
0000000000000000000000000000000000000000;;		exponent += int32(times)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure exponent is a multiple of 3
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		switch exponent % 3 {
0000000000000000000000000000000000000000;;		case 1, -2:
0000000000000000000000000000000000000000;;			amount, ok = int64MultiplyScale10(amount)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return infDecAmount{a.AsDec()}.AsCanonicalBytes(out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			exponent = exponent - 1
0000000000000000000000000000000000000000;;		case 2, -1:
0000000000000000000000000000000000000000;;			amount, ok = int64MultiplyScale100(amount)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return infDecAmount{a.AsDec()}.AsCanonicalBytes(out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			exponent = exponent - 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.AppendInt(out, amount, 10), exponent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsCanonicalBase1024Bytes accepts a buffer to write the base-1024 string value of this field to, and returns
0000000000000000000000000000000000000000;;	// either that buffer or a larger buffer and the current exponent of the value. 2048 is 2 * 1024 ^ 1 and would
0000000000000000000000000000000000000000;;	// return []byte("2048"), 1.
0000000000000000000000000000000000000000;;	func (a int64Amount) AsCanonicalBase1024Bytes(out []byte) (result []byte, exponent int32) {
0000000000000000000000000000000000000000;;		value, ok := a.AsScaledInt64(0)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return infDecAmount{a.AsDec()}.AsCanonicalBase1024Bytes(out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		amount, exponent := removeInt64Factors(value, 1024)
0000000000000000000000000000000000000000;;		return strconv.AppendInt(out, amount, 10), exponent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// infDecAmount implements common operations over an inf.Dec that are specific to the quantity
0000000000000000000000000000000000000000;;	// representation.
0000000000000000000000000000000000000000;;	type infDecAmount struct {
0000000000000000000000000000000000000000;;		*inf.Dec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsScale adjusts this amount to set a minimum scale, rounding up, and returns true iff no precision
0000000000000000000000000000000000000000;;	// was lost. (1.1e5).AsScale(5) would return 1.1e5, but (1.1e5).AsScale(6) would return 1e6.
0000000000000000000000000000000000000000;;	func (a infDecAmount) AsScale(scale Scale) (infDecAmount, bool) {
0000000000000000000000000000000000000000;;		tmp := &inf.Dec{}
0000000000000000000000000000000000000000;;		tmp.Round(a.Dec, scale.infScale(), inf.RoundUp)
0000000000000000000000000000000000000000;;		return infDecAmount{tmp}, tmp.Cmp(a.Dec) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsCanonicalBytes accepts a buffer to write the base-10 string value of this field to, and returns
0000000000000000000000000000000000000000;;	// either that buffer or a larger buffer and the current exponent of the value. The value is adjusted
0000000000000000000000000000000000000000;;	// until the exponent is a multiple of 3 - i.e. 1.1e5 would return "110", 3.
0000000000000000000000000000000000000000;;	func (a infDecAmount) AsCanonicalBytes(out []byte) (result []byte, exponent int32) {
0000000000000000000000000000000000000000;;		mantissa := a.Dec.UnscaledBig()
0000000000000000000000000000000000000000;;		exponent = int32(-a.Dec.Scale())
0000000000000000000000000000000000000000;;		amount := big.NewInt(0).Set(mantissa)
0000000000000000000000000000000000000000;;		// move all factors of 10 into the exponent for easy reasoning
0000000000000000000000000000000000000000;;		amount, times := removeBigIntFactors(amount, bigTen)
0000000000000000000000000000000000000000;;		exponent += times
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure exponent is a multiple of 3
0000000000000000000000000000000000000000;;		for exponent%3 != 0 {
0000000000000000000000000000000000000000;;			amount.Mul(amount, bigTen)
0000000000000000000000000000000000000000;;			exponent--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return append(out, amount.String()...), exponent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsCanonicalBase1024Bytes accepts a buffer to write the base-1024 string value of this field to, and returns
0000000000000000000000000000000000000000;;	// either that buffer or a larger buffer and the current exponent of the value. 2048 is 2 * 1024 ^ 1 and would
0000000000000000000000000000000000000000;;	// return []byte("2048"), 1.
0000000000000000000000000000000000000000;;	func (a infDecAmount) AsCanonicalBase1024Bytes(out []byte) (result []byte, exponent int32) {
0000000000000000000000000000000000000000;;		tmp := &inf.Dec{}
0000000000000000000000000000000000000000;;		tmp.Round(a.Dec, 0, inf.RoundUp)
0000000000000000000000000000000000000000;;		amount, exponent := removeBigIntFactors(tmp.UnscaledBig(), big1024)
0000000000000000000000000000000000000000;;		return append(out, amount.String()...), exponent
0000000000000000000000000000000000000000;;	}
