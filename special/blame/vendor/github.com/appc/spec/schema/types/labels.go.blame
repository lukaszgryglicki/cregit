0000000000000000000000000000000000000000;;	// Copyright 2015 The appc Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8d973c48ce204bda083f5a578278a9cd3743f879;Godeps/_workspace/src/github.com/appc/spec/schema/types/labels.go[Godeps/_workspace/src/github.com/appc/spec/schema/types/labels.go][vendor/github.com/appc/spec/schema/types/labels.go];	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ValidOSArch = map[string][]string{
0000000000000000000000000000000000000000;;		"linux":   {"amd64", "i386", "aarch64", "aarch64_be", "armv6l", "armv7l", "armv7b", "ppc64", "ppc64le", "s390x"},
0000000000000000000000000000000000000000;;		"freebsd": {"amd64", "i386", "arm"},
0000000000000000000000000000000000000000;;		"darwin":  {"x86_64", "i386"},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Labels []Label
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type labels Labels
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Label struct {
0000000000000000000000000000000000000000;;		Name  ACIdentifier `json:"name"`
0000000000000000000000000000000000000000;;		Value string       `json:"value"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// {appc,go}ArchTuple are internal helper types used to translate arch tuple between go and appc
0000000000000000000000000000000000000000;;	type appcArchTuple struct {
0000000000000000000000000000000000000000;;		appcOs   string
0000000000000000000000000000000000000000;;		appcArch string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type goArchTuple struct {
0000000000000000000000000000000000000000;;		goOs         string
0000000000000000000000000000000000000000;;		goArch       string
0000000000000000000000000000000000000000;;		goArchFlavor string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidOsArch checks if a OS-architecture combination is valid given a map
0000000000000000000000000000000000000000;;	// of valid OS-architectures
0000000000000000000000000000000000000000;;	func IsValidOSArch(labels map[ACIdentifier]string, validOSArch map[string][]string) error {
0000000000000000000000000000000000000000;;		if os, ok := labels["os"]; ok {
0000000000000000000000000000000000000000;;			if validArchs, ok := validOSArch[os]; !ok {
0000000000000000000000000000000000000000;;				// Not a whitelisted OS. TODO: how to warn rather than fail?
0000000000000000000000000000000000000000;;				validOses := make([]string, 0, len(validOSArch))
0000000000000000000000000000000000000000;;				for validOs := range validOSArch {
0000000000000000000000000000000000000000;;					validOses = append(validOses, validOs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Strings(validOses)
0000000000000000000000000000000000000000;;				return fmt.Errorf(`bad os %#v (must be one of: %v)`, os, validOses)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Whitelisted OS. We check arch here, as arch makes sense only
0000000000000000000000000000000000000000;;				// when os is defined.
0000000000000000000000000000000000000000;;				if arch, ok := labels["arch"]; ok {
0000000000000000000000000000000000000000;;					found := false
0000000000000000000000000000000000000000;;					for _, validArch := range validArchs {
0000000000000000000000000000000000000000;;						if arch == validArch {
0000000000000000000000000000000000000000;;							found = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !found {
0000000000000000000000000000000000000000;;						return fmt.Errorf(`bad arch %#v for %v (must be one of: %v)`, arch, os, validArchs)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l Labels) assertValid() error {
0000000000000000000000000000000000000000;;		seen := map[ACIdentifier]string{}
0000000000000000000000000000000000000000;;		for _, lbl := range l {
0000000000000000000000000000000000000000;;			if lbl.Name == "name" {
0000000000000000000000000000000000000000;;				return fmt.Errorf(`invalid label name: "name"`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, ok := seen[lbl.Name]
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf(`duplicate labels of name %q`, lbl.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			seen[lbl.Name] = lbl.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return IsValidOSArch(seen, ValidOSArch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l Labels) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if err := l.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(labels(l))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *Labels) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var jl labels
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &jl); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nl := Labels(jl)
0000000000000000000000000000000000000000;;		if err := nl.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*l = nl
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get retrieves the value of the label by the given name from Labels, if it exists
0000000000000000000000000000000000000000;;	func (l Labels) Get(name string) (val string, ok bool) {
0000000000000000000000000000000000000000;;		for _, lbl := range l {
0000000000000000000000000000000000000000;;			if lbl.Name.String() == name {
0000000000000000000000000000000000000000;;				return lbl.Value, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToMap creates a map[ACIdentifier]string.
0000000000000000000000000000000000000000;;	func (l Labels) ToMap() map[ACIdentifier]string {
0000000000000000000000000000000000000000;;		labelsMap := make(map[ACIdentifier]string)
0000000000000000000000000000000000000000;;		for _, lbl := range l {
0000000000000000000000000000000000000000;;			labelsMap[lbl.Name] = lbl.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labelsMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelsFromMap creates Labels from a map[ACIdentifier]string
0000000000000000000000000000000000000000;;	func LabelsFromMap(labelsMap map[ACIdentifier]string) (Labels, error) {
0000000000000000000000000000000000000000;;		labels := Labels{}
0000000000000000000000000000000000000000;;		for n, v := range labelsMap {
0000000000000000000000000000000000000000;;			labels = append(labels, Label{Name: n, Value: v})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := labels.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labels, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToAppcOSArch translates a Golang arch tuple (OS, architecture, flavor) into
0000000000000000000000000000000000000000;;	// an appc arch tuple (OS, architecture)
0000000000000000000000000000000000000000;;	func ToAppcOSArch(goOs string, goArch string, goArchFlavor string) (appcOs string, appcArch string, e error) {
0000000000000000000000000000000000000000;;		tabularAppcToGo := map[goArchTuple]appcArchTuple{
0000000000000000000000000000000000000000;;			{"linux", "amd64", ""}:   {"linux", "amd64"},
0000000000000000000000000000000000000000;;			{"linux", "386", ""}:     {"linux", "i386"},
0000000000000000000000000000000000000000;;			{"linux", "arm64", ""}:   {"linux", "aarch64"},
0000000000000000000000000000000000000000;;			{"linux", "arm", ""}:     {"linux", "armv6l"},
0000000000000000000000000000000000000000;;			{"linux", "arm", "6"}:    {"linux", "armv6l"},
0000000000000000000000000000000000000000;;			{"linux", "arm", "7"}:    {"linux", "armv7l"},
0000000000000000000000000000000000000000;;			{"linux", "ppc64", ""}:   {"linux", "ppc64"},
0000000000000000000000000000000000000000;;			{"linux", "ppc64le", ""}: {"linux", "ppc64le"},
0000000000000000000000000000000000000000;;			{"linux", "s390x", ""}:   {"linux", "s390x"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"freebsd", "amd64", ""}: {"freebsd", "amd64"},
0000000000000000000000000000000000000000;;			{"freebsd", "386", ""}:   {"freebsd", "i386"},
0000000000000000000000000000000000000000;;			{"freebsd", "arm", ""}:   {"freebsd", "arm"},
0000000000000000000000000000000000000000;;			{"freebsd", "arm", "5"}:  {"freebsd", "arm"},
0000000000000000000000000000000000000000;;			{"freebsd", "arm", "6"}:  {"freebsd", "arm"},
0000000000000000000000000000000000000000;;			{"freebsd", "arm", "7"}:  {"freebsd", "arm"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"darwin", "amd64", ""}: {"darwin", "x86_64"},
0000000000000000000000000000000000000000;;			{"darwin", "386", ""}:   {"darwin", "i386"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		archTuple, ok := tabularAppcToGo[goArchTuple{goOs, goArch, goArchFlavor}]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("unknown arch tuple: %q - %q - %q", goOs, goArch, goArchFlavor)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return archTuple.appcOs, archTuple.appcArch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToGoOSArch translates an appc arch tuple (OS, architecture) into
0000000000000000000000000000000000000000;;	// a Golang arch tuple (OS, architecture, flavor)
0000000000000000000000000000000000000000;;	func ToGoOSArch(appcOs string, appcArch string) (goOs string, goArch string, goArchFlavor string, e error) {
0000000000000000000000000000000000000000;;		tabularGoToAppc := map[appcArchTuple]goArchTuple{
0000000000000000000000000000000000000000;;			// {"linux", "aarch64_be"}: nil,
0000000000000000000000000000000000000000;;			// {"linux", "armv7b"}: nil,
0000000000000000000000000000000000000000;;			{"linux", "aarch64"}: {"linux", "arm64", ""},
0000000000000000000000000000000000000000;;			{"linux", "amd64"}:   {"linux", "amd64", ""},
0000000000000000000000000000000000000000;;			{"linux", "armv6l"}:  {"linux", "arm", "6"},
0000000000000000000000000000000000000000;;			{"linux", "armv7l"}:  {"linux", "arm", "7"},
0000000000000000000000000000000000000000;;			{"linux", "i386"}:    {"linux", "386", ""},
0000000000000000000000000000000000000000;;			{"linux", "ppc64"}:   {"linux", "ppc64", ""},
0000000000000000000000000000000000000000;;			{"linux", "ppc64le"}: {"linux", "ppc64le", ""},
0000000000000000000000000000000000000000;;			{"linux", "s390x"}:   {"linux", "s390x", ""},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"freebsd", "amd64"}: {"freebsd", "amd64", ""},
0000000000000000000000000000000000000000;;			{"freebsd", "arm"}:   {"freebsd", "arm", "6"},
0000000000000000000000000000000000000000;;			{"freebsd", "386"}:   {"freebsd", "i386", ""},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"darwin", "amd64"}: {"darwin", "x86_64", ""},
0000000000000000000000000000000000000000;;			{"darwin", "386"}:   {"darwin", "i386", ""},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		archTuple, ok := tabularGoToAppc[appcArchTuple{appcOs, appcArch}]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", "", "", fmt.Errorf("unknown arch tuple: %q - %q", appcOs, appcArch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return archTuple.goOs, archTuple.goArch, archTuple.goArchFlavor, nil
0000000000000000000000000000000000000000;;	}
