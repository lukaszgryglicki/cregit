0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors All rights reserved.
e1b2a6921d4ce46e5ce744e6c28b538bd077b3b7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type suffix string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// suffixer can interpret and construct suffixes.
0000000000000000000000000000000000000000;;	type suffixer interface {
0000000000000000000000000000000000000000;;		interpret(suffix) (base, exponent int32, fmt Format, ok bool)
0000000000000000000000000000000000000000;;		construct(base, exponent int32, fmt Format) (s suffix, ok bool)
0000000000000000000000000000000000000000;;		constructBytes(base, exponent int32, fmt Format) (s []byte, ok bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// quantitySuffixer handles suffixes for all three formats that quantity
0000000000000000000000000000000000000000;;	// can handle.
0000000000000000000000000000000000000000;;	var quantitySuffixer = newSuffixer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bePair struct {
0000000000000000000000000000000000000000;;		base, exponent int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type listSuffixer struct {
0000000000000000000000000000000000000000;;		suffixToBE      map[suffix]bePair
0000000000000000000000000000000000000000;;		beToSuffix      map[bePair]suffix
0000000000000000000000000000000000000000;;		beToSuffixBytes map[bePair][]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ls *listSuffixer) addSuffix(s suffix, pair bePair) {
0000000000000000000000000000000000000000;;		if ls.suffixToBE == nil {
0000000000000000000000000000000000000000;;			ls.suffixToBE = map[suffix]bePair{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ls.beToSuffix == nil {
0000000000000000000000000000000000000000;;			ls.beToSuffix = map[bePair]suffix{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ls.beToSuffixBytes == nil {
0000000000000000000000000000000000000000;;			ls.beToSuffixBytes = map[bePair][]byte{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ls.suffixToBE[s] = pair
0000000000000000000000000000000000000000;;		ls.beToSuffix[pair] = s
0000000000000000000000000000000000000000;;		ls.beToSuffixBytes[pair] = []byte(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ls *listSuffixer) lookup(s suffix) (base, exponent int32, ok bool) {
0000000000000000000000000000000000000000;;		pair, ok := ls.suffixToBE[s]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pair.base, pair.exponent, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ls *listSuffixer) construct(base, exponent int32) (s suffix, ok bool) {
0000000000000000000000000000000000000000;;		s, ok = ls.beToSuffix[bePair{base, exponent}]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ls *listSuffixer) constructBytes(base, exponent int32) (s []byte, ok bool) {
0000000000000000000000000000000000000000;;		s, ok = ls.beToSuffixBytes[bePair{base, exponent}]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type suffixHandler struct {
0000000000000000000000000000000000000000;;		decSuffixes listSuffixer
0000000000000000000000000000000000000000;;		binSuffixes listSuffixer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fastLookup struct {
0000000000000000000000000000000000000000;;		*suffixHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l fastLookup) interpret(s suffix) (base, exponent int32, format Format, ok bool) {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			return 10, 0, DecimalSI, true
0000000000000000000000000000000000000000;;		case "n":
0000000000000000000000000000000000000000;;			return 10, -9, DecimalSI, true
0000000000000000000000000000000000000000;;		case "u":
0000000000000000000000000000000000000000;;			return 10, -6, DecimalSI, true
0000000000000000000000000000000000000000;;		case "m":
0000000000000000000000000000000000000000;;			return 10, -3, DecimalSI, true
0000000000000000000000000000000000000000;;		case "k":
0000000000000000000000000000000000000000;;			return 10, 3, DecimalSI, true
0000000000000000000000000000000000000000;;		case "M":
0000000000000000000000000000000000000000;;			return 10, 6, DecimalSI, true
0000000000000000000000000000000000000000;;		case "G":
0000000000000000000000000000000000000000;;			return 10, 9, DecimalSI, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.suffixHandler.interpret(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSuffixer() suffixer {
0000000000000000000000000000000000000000;;		sh := &suffixHandler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IMPORTANT: if you change this section you must change fastLookup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sh.binSuffixes.addSuffix("Ki", bePair{2, 10})
0000000000000000000000000000000000000000;;		sh.binSuffixes.addSuffix("Mi", bePair{2, 20})
0000000000000000000000000000000000000000;;		sh.binSuffixes.addSuffix("Gi", bePair{2, 30})
0000000000000000000000000000000000000000;;		sh.binSuffixes.addSuffix("Ti", bePair{2, 40})
0000000000000000000000000000000000000000;;		sh.binSuffixes.addSuffix("Pi", bePair{2, 50})
0000000000000000000000000000000000000000;;		sh.binSuffixes.addSuffix("Ei", bePair{2, 60})
0000000000000000000000000000000000000000;;		// Don't emit an error when trying to produce
0000000000000000000000000000000000000000;;		// a suffix for 2^0.
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("", bePair{2, 0})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("n", bePair{10, -9})
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("u", bePair{10, -6})
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("m", bePair{10, -3})
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("", bePair{10, 0})
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("k", bePair{10, 3})
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("M", bePair{10, 6})
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("G", bePair{10, 9})
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("T", bePair{10, 12})
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("P", bePair{10, 15})
0000000000000000000000000000000000000000;;		sh.decSuffixes.addSuffix("E", bePair{10, 18})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fastLookup{sh}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sh *suffixHandler) construct(base, exponent int32, fmt Format) (s suffix, ok bool) {
0000000000000000000000000000000000000000;;		switch fmt {
0000000000000000000000000000000000000000;;		case DecimalSI:
0000000000000000000000000000000000000000;;			return sh.decSuffixes.construct(base, exponent)
0000000000000000000000000000000000000000;;		case BinarySI:
0000000000000000000000000000000000000000;;			return sh.binSuffixes.construct(base, exponent)
0000000000000000000000000000000000000000;;		case DecimalExponent:
0000000000000000000000000000000000000000;;			if base != 10 {
0000000000000000000000000000000000000000;;				return "", false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exponent == 0 {
0000000000000000000000000000000000000000;;				return "", true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return suffix("e" + strconv.FormatInt(int64(exponent), 10)), true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sh *suffixHandler) constructBytes(base, exponent int32, format Format) (s []byte, ok bool) {
0000000000000000000000000000000000000000;;		switch format {
0000000000000000000000000000000000000000;;		case DecimalSI:
0000000000000000000000000000000000000000;;			return sh.decSuffixes.constructBytes(base, exponent)
0000000000000000000000000000000000000000;;		case BinarySI:
0000000000000000000000000000000000000000;;			return sh.binSuffixes.constructBytes(base, exponent)
0000000000000000000000000000000000000000;;		case DecimalExponent:
0000000000000000000000000000000000000000;;			if base != 10 {
0000000000000000000000000000000000000000;;				return nil, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exponent == 0 {
0000000000000000000000000000000000000000;;				return nil, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result := make([]byte, 8, 8)
0000000000000000000000000000000000000000;;			result[0] = 'e'
0000000000000000000000000000000000000000;;			number := strconv.AppendInt(result[1:1], int64(exponent), 10)
0000000000000000000000000000000000000000;;			if &result[1] == &number[0] {
0000000000000000000000000000000000000000;;				return result[:1+len(number)], true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result[:1], number...)
0000000000000000000000000000000000000000;;			return result, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sh *suffixHandler) interpret(suffix suffix) (base, exponent int32, fmt Format, ok bool) {
0000000000000000000000000000000000000000;;		// Try lookup tables first
0000000000000000000000000000000000000000;;		if b, e, ok := sh.decSuffixes.lookup(suffix); ok {
0000000000000000000000000000000000000000;;			return b, e, DecimalSI, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b, e, ok := sh.binSuffixes.lookup(suffix); ok {
0000000000000000000000000000000000000000;;			return b, e, BinarySI, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(suffix) > 1 && (suffix[0] == 'E' || suffix[0] == 'e') {
0000000000000000000000000000000000000000;;			parsed, err := strconv.ParseInt(string(suffix[1:]), 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, 0, DecimalExponent, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 10, int32(parsed), DecimalExponent, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0, 0, DecimalExponent, false
0000000000000000000000000000000000000000;;	}
