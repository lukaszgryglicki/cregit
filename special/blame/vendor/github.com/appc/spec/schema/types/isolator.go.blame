0000000000000000000000000000000000000000;;	// Copyright 2015 The appc Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8d973c48ce204bda083f5a578278a9cd3743f879;Godeps/_workspace/src/github.com/appc/spec/schema/types/isolator.go[Godeps/_workspace/src/github.com/appc/spec/schema/types/isolator.go][vendor/github.com/appc/spec/schema/types/isolator.go];	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		isolatorMap map[ACIdentifier]IsolatorValueConstructor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrIncompatibleIsolator is returned whenever an Isolators set contains
0000000000000000000000000000000000000000;;		// conflicting IsolatorValue instances
0000000000000000000000000000000000000000;;		ErrIncompatibleIsolator = errors.New("isolators set contains incompatible types")
0000000000000000000000000000000000000000;;		// ErrInvalidIsolator is returned upon validation failures due to improper
0000000000000000000000000000000000000000;;		// or partially constructed Isolator instances (eg. from incomplete direct construction)
0000000000000000000000000000000000000000;;		ErrInvalidIsolator = errors.New("invalid isolator")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		isolatorMap = make(map[ACIdentifier]IsolatorValueConstructor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type IsolatorValueConstructor func() IsolatorValue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddIsolatorValueConstructor(n ACIdentifier, i IsolatorValueConstructor) {
0000000000000000000000000000000000000000;;		isolatorMap[n] = i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AddIsolatorName(n ACIdentifier, ns map[ACIdentifier]struct{}) {
0000000000000000000000000000000000000000;;		ns[n] = struct{}{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Isolators encapsulates a list of individual Isolators for the ImageManifest
0000000000000000000000000000000000000000;;	// and PodManifest schemas.
0000000000000000000000000000000000000000;;	type Isolators []Isolator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assertValid checks that every single isolator is valid and that
0000000000000000000000000000000000000000;;	// the whole set is well built
0000000000000000000000000000000000000000;;	func (isolators Isolators) assertValid() error {
0000000000000000000000000000000000000000;;		typesMap := make(map[ACIdentifier]bool)
0000000000000000000000000000000000000000;;		for _, i := range isolators {
0000000000000000000000000000000000000000;;			v := i.Value()
0000000000000000000000000000000000000000;;			if v == nil {
0000000000000000000000000000000000000000;;				return ErrInvalidIsolator
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := v.AssertValid(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := typesMap[i.Name]; ok {
0000000000000000000000000000000000000000;;				if !v.multipleAllowed() {
0000000000000000000000000000000000000000;;					return fmt.Errorf(`isolators set contains too many instances of type %s"`, i.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range v.Conflicts() {
0000000000000000000000000000000000000000;;				if _, found := typesMap[c]; found {
0000000000000000000000000000000000000000;;					return ErrIncompatibleIsolator
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			typesMap[i.Name] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetByName returns the last isolator in the list by the given name.
0000000000000000000000000000000000000000;;	func (is *Isolators) GetByName(name ACIdentifier) *Isolator {
0000000000000000000000000000000000000000;;		var i Isolator
0000000000000000000000000000000000000000;;		for j := len(*is) - 1; j >= 0; j-- {
0000000000000000000000000000000000000000;;			i = []Isolator(*is)[j]
0000000000000000000000000000000000000000;;			if i.Name == name {
0000000000000000000000000000000000000000;;				return &i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceIsolatorsByName overrides matching isolator types with a new
0000000000000000000000000000000000000000;;	// isolator, deleting them all and appending the new one instead
0000000000000000000000000000000000000000;;	func (is *Isolators) ReplaceIsolatorsByName(newIs Isolator, oldNames []ACIdentifier) {
0000000000000000000000000000000000000000;;		var i Isolator
0000000000000000000000000000000000000000;;		for j := len(*is) - 1; j >= 0; j-- {
0000000000000000000000000000000000000000;;			i = []Isolator(*is)[j]
0000000000000000000000000000000000000000;;			for _, name := range oldNames {
0000000000000000000000000000000000000000;;				if i.Name == name {
0000000000000000000000000000000000000000;;					*is = append((*is)[:j], (*is)[j+1:]...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*is = append((*is)[:], newIs)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unrecognized returns a set of isolators that are not recognized.
0000000000000000000000000000000000000000;;	// An isolator is not recognized if it has not had an associated
0000000000000000000000000000000000000000;;	// constructor registered with AddIsolatorValueConstructor.
0000000000000000000000000000000000000000;;	func (is *Isolators) Unrecognized() Isolators {
0000000000000000000000000000000000000000;;		u := Isolators{}
0000000000000000000000000000000000000000;;		for _, i := range *is {
0000000000000000000000000000000000000000;;			if i.value == nil {
0000000000000000000000000000000000000000;;				u = append(u, i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsolatorValue encapsulates the actual value of an Isolator which may be
0000000000000000000000000000000000000000;;	// serialized as any arbitrary JSON blob. Specific Isolator types should
0000000000000000000000000000000000000000;;	// implement this interface to facilitate unmarshalling and validation.
0000000000000000000000000000000000000000;;	type IsolatorValue interface {
0000000000000000000000000000000000000000;;		// UnmarshalJSON unserialize a JSON-encoded isolator
0000000000000000000000000000000000000000;;		UnmarshalJSON(b []byte) error
0000000000000000000000000000000000000000;;		// AssertValid returns a non-nil error value if an IsolatorValue is not valid
0000000000000000000000000000000000000000;;		// according to appc spec
0000000000000000000000000000000000000000;;		AssertValid() error
0000000000000000000000000000000000000000;;		// Conflicts returns a list of conflicting isolators types, which cannot co-exist
0000000000000000000000000000000000000000;;		// together with this IsolatorValue
0000000000000000000000000000000000000000;;		Conflicts() []ACIdentifier
0000000000000000000000000000000000000000;;		// multipleAllowed specifies whether multiple isolator instances are allowed
0000000000000000000000000000000000000000;;		// for this isolator type
0000000000000000000000000000000000000000;;		multipleAllowed() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Isolator is a model for unmarshalling isolator types from their JSON-encoded
0000000000000000000000000000000000000000;;	// representation.
0000000000000000000000000000000000000000;;	type Isolator struct {
0000000000000000000000000000000000000000;;		// Name is the name of the Isolator type as defined in the specification.
0000000000000000000000000000000000000000;;		Name ACIdentifier `json:"name"`
0000000000000000000000000000000000000000;;		// ValueRaw captures the raw JSON value of an Isolator that was
0000000000000000000000000000000000000000;;		// unmarshalled. This field is used for unmarshalling only. It MUST NOT
0000000000000000000000000000000000000000;;		// be referenced by external users of the Isolator struct. It is
0000000000000000000000000000000000000000;;		// exported only to satisfy Go's unfortunate requirement that fields
0000000000000000000000000000000000000000;;		// must be capitalized to be unmarshalled successfully.
0000000000000000000000000000000000000000;;		ValueRaw *json.RawMessage `json:"value"`
0000000000000000000000000000000000000000;;		// value captures the "true" value of the isolator.
0000000000000000000000000000000000000000;;		value IsolatorValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isolator is a shadow type used for unmarshalling.
0000000000000000000000000000000000000000;;	type isolator Isolator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value returns the raw Value of this Isolator. Users should perform a type
0000000000000000000000000000000000000000;;	// switch/assertion on this value to extract the underlying isolator type.
0000000000000000000000000000000000000000;;	func (i *Isolator) Value() IsolatorValue {
0000000000000000000000000000000000000000;;		return i.value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON populates this Isolator from a JSON-encoded representation. To
0000000000000000000000000000000000000000;;	// unmarshal the Value of the Isolator, it will use the appropriate constructor
0000000000000000000000000000000000000000;;	// as registered by AddIsolatorValueConstructor.
0000000000000000000000000000000000000000;;	func (i *Isolator) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var ii isolator
0000000000000000000000000000000000000000;;		err := json.Unmarshal(b, &ii)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst IsolatorValue
0000000000000000000000000000000000000000;;		con, ok := isolatorMap[ii.Name]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			dst = con()
0000000000000000000000000000000000000000;;			err = dst.UnmarshalJSON(*ii.ValueRaw)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = dst.AssertValid()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i.value = dst
0000000000000000000000000000000000000000;;		i.ValueRaw = ii.ValueRaw
0000000000000000000000000000000000000000;;		i.Name = ii.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
