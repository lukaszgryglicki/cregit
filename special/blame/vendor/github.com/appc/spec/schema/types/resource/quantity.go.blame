0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors All rights reserved.
e1b2a6921d4ce46e5ce744e6c28b538bd077b3b7;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inf "gopkg.in/inf.v0"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Quantity is a fixed-point representation of a number.
0000000000000000000000000000000000000000;;	// It provides convenient marshaling/unmarshaling in JSON and YAML,
0000000000000000000000000000000000000000;;	// in addition to String() and Int64() accessors.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The serialization format is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// <quantity>        ::= <signedNumber><suffix>
0000000000000000000000000000000000000000;;	//   (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
0000000000000000000000000000000000000000;;	// <digit>           ::= 0 | 1 | ... | 9
0000000000000000000000000000000000000000;;	// <digits>          ::= <digit> | <digit><digits>
0000000000000000000000000000000000000000;;	// <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits>
0000000000000000000000000000000000000000;;	// <sign>            ::= "+" | "-"
0000000000000000000000000000000000000000;;	// <signedNumber>    ::= <number> | <sign><number>
0000000000000000000000000000000000000000;;	// <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI>
0000000000000000000000000000000000000000;;	// <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
0000000000000000000000000000000000000000;;	//   (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
0000000000000000000000000000000000000000;;	// <decimalSI>       ::= m | "" | k | M | G | T | P | E
0000000000000000000000000000000000000000;;	//   (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
0000000000000000000000000000000000000000;;	// <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// No matter which of the three exponent forms is used, no quantity may represent
0000000000000000000000000000000000000000;;	// a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal
0000000000000000000000000000000000000000;;	// places. Numbers larger or more precise will be capped or rounded up.
0000000000000000000000000000000000000000;;	// (E.g.: 0.1m will rounded up to 1m.)
0000000000000000000000000000000000000000;;	// This may be extended in the future if we require larger or smaller quantities.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When a Quantity is parsed from a string, it will remember the type of suffix
0000000000000000000000000000000000000000;;	// it had, and will use the same type again when it is serialized.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Before serializing, Quantity will be put in "canonical form".
0000000000000000000000000000000000000000;;	// This means that Exponent/suffix will be adjusted up or down (with a
0000000000000000000000000000000000000000;;	// corresponding increase or decrease in Mantissa) such that:
0000000000000000000000000000000000000000;;	//   a. No precision is lost
0000000000000000000000000000000000000000;;	//   b. No fractional digits will be emitted
0000000000000000000000000000000000000000;;	//   c. The exponent (or suffix) is as large as possible.
0000000000000000000000000000000000000000;;	// The sign will be omitted unless the number is negative.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Examples:
0000000000000000000000000000000000000000;;	//   1.5 will be serialized as "1500m"
0000000000000000000000000000000000000000;;	//   1.5Gi will be serialized as "1536Mi"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: We reserve the right to amend this canonical format, perhaps to
0000000000000000000000000000000000000000;;	//   allow 1.5 to be canonical.
0000000000000000000000000000000000000000;;	// TODO: Remove above disclaimer after all bikeshedding about format is over,
0000000000000000000000000000000000000000;;	//   or after March 2015.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that the quantity will NEVER be internally represented by a
0000000000000000000000000000000000000000;;	// floating point number. That is the whole point of this exercise.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Non-canonical values will still parse as long as they are well formed,
0000000000000000000000000000000000000000;;	// but will be re-emitted in their canonical form. (So always use canonical
0000000000000000000000000000000000000000;;	// form, or don't diff.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This format is intended to make it difficult to use these numbers without
0000000000000000000000000000000000000000;;	// writing some sort of special handling code in the hopes that that will
0000000000000000000000000000000000000000;;	// cause implementors to also use a fixed point implementation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +gencopy=false
0000000000000000000000000000000000000000;;	// +protobuf=true
0000000000000000000000000000000000000000;;	// +protobuf.embed=string
0000000000000000000000000000000000000000;;	// +protobuf.options.marshal=false
0000000000000000000000000000000000000000;;	// +protobuf.options.(gogoproto.goproto_stringer)=false
0000000000000000000000000000000000000000;;	type Quantity struct {
0000000000000000000000000000000000000000;;		// i is the quantity in int64 scaled form, if d.Dec == nil
0000000000000000000000000000000000000000;;		i int64Amount
0000000000000000000000000000000000000000;;		// d is the quantity in inf.Dec form if d.Dec != nil
0000000000000000000000000000000000000000;;		d infDecAmount
0000000000000000000000000000000000000000;;		// s is the generated value of this quantity to avoid recalculation
0000000000000000000000000000000000000000;;		s string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Change Format at will. See the comment for Canonicalize for
0000000000000000000000000000000000000000;;		// more details.
0000000000000000000000000000000000000000;;		Format
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CanonicalValue allows a quantity amount to be converted to a string.
0000000000000000000000000000000000000000;;	type CanonicalValue interface {
0000000000000000000000000000000000000000;;		// AsCanonicalBytes returns a byte array representing the string representation
0000000000000000000000000000000000000000;;		// of the value mantissa and an int32 representing its exponent in base-10. Callers may
0000000000000000000000000000000000000000;;		// pass a byte slice to the method to avoid allocations.
0000000000000000000000000000000000000000;;		AsCanonicalBytes(out []byte) ([]byte, int32)
0000000000000000000000000000000000000000;;		// AsCanonicalBase1024Bytes returns a byte array representing the string representation
0000000000000000000000000000000000000000;;		// of the value mantissa and an int32 representing its exponent in base-1024. Callers
0000000000000000000000000000000000000000;;		// may pass a byte slice to the method to avoid allocations.
0000000000000000000000000000000000000000;;		AsCanonicalBase1024Bytes(out []byte) ([]byte, int32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Format lists the three possible formattings of a quantity.
0000000000000000000000000000000000000000;;	type Format string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DecimalExponent = Format("DecimalExponent") // e.g., 12e6
0000000000000000000000000000000000000000;;		BinarySI        = Format("BinarySI")        // e.g., 12Mi (12 * 2^20)
0000000000000000000000000000000000000000;;		DecimalSI       = Format("DecimalSI")       // e.g., 12M  (12 * 10^6)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustParse turns the given string into a quantity or panics; for tests
0000000000000000000000000000000000000000;;	// or others cases where you know the string is valid.
0000000000000000000000000000000000000000;;	func MustParse(str string) Quantity {
0000000000000000000000000000000000000000;;		q, err := ParseQuantity(str)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("cannot parse '%v': %v", str, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// splitREString is used to separate a number from its suffix; as such,
0000000000000000000000000000000000000000;;		// this is overly permissive, but that's OK-- it will be checked later.
0000000000000000000000000000000000000000;;		splitREString = "^([+-]?[0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// splitRE is used to get the various parts of a number.
0000000000000000000000000000000000000000;;		splitRE = regexp.MustCompile(splitREString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Errors that could happen while parsing a string.
0000000000000000000000000000000000000000;;		ErrFormatWrong = errors.New("quantities must match the regular expression '" + splitREString + "'")
0000000000000000000000000000000000000000;;		ErrNumeric     = errors.New("unable to parse numeric part of quantity")
0000000000000000000000000000000000000000;;		ErrSuffix      = errors.New("unable to parse quantity's suffix")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseQuantityString is a fast scanner for quantity values.
0000000000000000000000000000000000000000;;	func parseQuantityString(str string) (positive bool, value, num, denom, suffix string, err error) {
0000000000000000000000000000000000000000;;		positive = true
0000000000000000000000000000000000000000;;		pos := 0
0000000000000000000000000000000000000000;;		end := len(str)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle leading sign
0000000000000000000000000000000000000000;;		if pos < end {
0000000000000000000000000000000000000000;;			switch str[0] {
0000000000000000000000000000000000000000;;			case '-':
0000000000000000000000000000000000000000;;				positive = false
0000000000000000000000000000000000000000;;				pos++
0000000000000000000000000000000000000000;;			case '+':
0000000000000000000000000000000000000000;;				pos++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// strip leading zeros
0000000000000000000000000000000000000000;;	Zeroes:
0000000000000000000000000000000000000000;;		for i := pos; ; i++ {
0000000000000000000000000000000000000000;;			if i >= end {
0000000000000000000000000000000000000000;;				num = "0"
0000000000000000000000000000000000000000;;				value = num
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch str[i] {
0000000000000000000000000000000000000000;;			case '0':
0000000000000000000000000000000000000000;;				pos++
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				break Zeroes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// extract the numerator
0000000000000000000000000000000000000000;;	Num:
0000000000000000000000000000000000000000;;		for i := pos; ; i++ {
0000000000000000000000000000000000000000;;			if i >= end {
0000000000000000000000000000000000000000;;				num = str[pos:end]
0000000000000000000000000000000000000000;;				value = str[0:end]
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch str[i] {
0000000000000000000000000000000000000000;;			case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				num = str[pos:i]
0000000000000000000000000000000000000000;;				pos = i
0000000000000000000000000000000000000000;;				break Num
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we stripped all numerator positions, always return 0
0000000000000000000000000000000000000000;;		if len(num) == 0 {
0000000000000000000000000000000000000000;;			num = "0"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle a denominator
0000000000000000000000000000000000000000;;		if pos < end && str[pos] == '.' {
0000000000000000000000000000000000000000;;			pos++
0000000000000000000000000000000000000000;;		Denom:
0000000000000000000000000000000000000000;;			for i := pos; ; i++ {
0000000000000000000000000000000000000000;;				if i >= end {
0000000000000000000000000000000000000000;;					denom = str[pos:end]
0000000000000000000000000000000000000000;;					value = str[0:end]
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch str[i] {
0000000000000000000000000000000000000000;;				case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					denom = str[pos:i]
0000000000000000000000000000000000000000;;					pos = i
0000000000000000000000000000000000000000;;					break Denom
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: we currently allow 1.G, but we may not want to in the future.
0000000000000000000000000000000000000000;;			// if len(denom) == 0 {
0000000000000000000000000000000000000000;;			// 	err = ErrFormatWrong
0000000000000000000000000000000000000000;;			// 	return
0000000000000000000000000000000000000000;;			// }
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value = str[0:pos]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// grab the elements of the suffix
0000000000000000000000000000000000000000;;		suffixStart := pos
0000000000000000000000000000000000000000;;		for i := pos; ; i++ {
0000000000000000000000000000000000000000;;			if i >= end {
0000000000000000000000000000000000000000;;				suffix = str[suffixStart:end]
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.ContainsAny(str[i:i+1], "eEinumkKMGTP") {
0000000000000000000000000000000000000000;;				pos = i
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pos < end {
0000000000000000000000000000000000000000;;			switch str[pos] {
0000000000000000000000000000000000000000;;			case '-', '+':
0000000000000000000000000000000000000000;;				pos++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	Suffix:
0000000000000000000000000000000000000000;;		for i := pos; ; i++ {
0000000000000000000000000000000000000000;;			if i >= end {
0000000000000000000000000000000000000000;;				suffix = str[suffixStart:end]
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch str[i] {
0000000000000000000000000000000000000000;;			case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				break Suffix
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// we encountered a non decimal in the Suffix loop, but the last character
0000000000000000000000000000000000000000;;		// was not a valid exponent
0000000000000000000000000000000000000000;;		err = ErrFormatWrong
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseQuantity turns str into a Quantity, or returns an error.
0000000000000000000000000000000000000000;;	func ParseQuantity(str string) (Quantity, error) {
0000000000000000000000000000000000000000;;		if len(str) == 0 {
0000000000000000000000000000000000000000;;			return Quantity{}, ErrFormatWrong
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if str == "0" {
0000000000000000000000000000000000000000;;			return Quantity{Format: DecimalSI, s: str}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		positive, value, num, denom, suf, err := parseQuantityString(str)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Quantity{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		base, exponent, format, ok := quantitySuffixer.interpret(suffix(suf))
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return Quantity{}, ErrSuffix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		precision := int32(0)
0000000000000000000000000000000000000000;;		scale := int32(0)
0000000000000000000000000000000000000000;;		mantissa := int64(1)
0000000000000000000000000000000000000000;;		switch format {
0000000000000000000000000000000000000000;;		case DecimalExponent, DecimalSI:
0000000000000000000000000000000000000000;;			scale = exponent
0000000000000000000000000000000000000000;;			precision = maxInt64Factors - int32(len(num)+len(denom))
0000000000000000000000000000000000000000;;		case BinarySI:
0000000000000000000000000000000000000000;;			scale = 0
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case exponent >= 0 && len(denom) == 0:
0000000000000000000000000000000000000000;;				// only handle positive binary numbers with the fast path
0000000000000000000000000000000000000000;;				mantissa = int64(int64(mantissa) << uint64(exponent))
0000000000000000000000000000000000000000;;				// 1Mi (2^20) has ~6 digits of decimal precision, so exponent*3/10 -1 is roughly the precision
0000000000000000000000000000000000000000;;				precision = 15 - int32(len(num)) - int32(float32(exponent)*3/10) - 1
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				precision = -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if precision >= 0 {
0000000000000000000000000000000000000000;;			// if we have a denominator, shift the entire value to the left by the number of places in the
0000000000000000000000000000000000000000;;			// denominator
0000000000000000000000000000000000000000;;			scale -= int32(len(denom))
0000000000000000000000000000000000000000;;			if scale >= int32(Nano) {
0000000000000000000000000000000000000000;;				shifted := num + denom
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var value int64
0000000000000000000000000000000000000000;;				value, err := strconv.ParseInt(shifted, 10, 64)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return Quantity{}, ErrNumeric
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if result, ok := int64Multiply(value, int64(mantissa)); ok {
0000000000000000000000000000000000000000;;					if !positive {
0000000000000000000000000000000000000000;;						result = -result
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// if the number is in canonical form, reuse the string
0000000000000000000000000000000000000000;;					switch format {
0000000000000000000000000000000000000000;;					case BinarySI:
0000000000000000000000000000000000000000;;						if exponent%10 == 0 && (value&0x07 != 0) {
0000000000000000000000000000000000000000;;							return Quantity{i: int64Amount{value: result, scale: Scale(scale)}, Format: format, s: str}, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						if scale%3 == 0 && !strings.HasSuffix(shifted, "000") && shifted[0] != '0' {
0000000000000000000000000000000000000000;;							return Quantity{i: int64Amount{value: result, scale: Scale(scale)}, Format: format, s: str}, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return Quantity{i: int64Amount{value: result, scale: Scale(scale)}, Format: format}, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		amount := new(inf.Dec)
0000000000000000000000000000000000000000;;		if _, ok := amount.SetString(value); !ok {
0000000000000000000000000000000000000000;;			return Quantity{}, ErrNumeric
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// So that no one but us has to think about suffixes, remove it.
0000000000000000000000000000000000000000;;		if base == 10 {
0000000000000000000000000000000000000000;;			amount.SetScale(amount.Scale() + Scale(exponent).infScale())
0000000000000000000000000000000000000000;;		} else if base == 2 {
0000000000000000000000000000000000000000;;			// numericSuffix = 2 ** exponent
0000000000000000000000000000000000000000;;			numericSuffix := big.NewInt(1).Lsh(bigOne, uint(exponent))
0000000000000000000000000000000000000000;;			ub := amount.UnscaledBig()
0000000000000000000000000000000000000000;;			amount.SetUnscaledBig(ub.Mul(ub, numericSuffix))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cap at min/max bounds.
0000000000000000000000000000000000000000;;		sign := amount.Sign()
0000000000000000000000000000000000000000;;		if sign == -1 {
0000000000000000000000000000000000000000;;			amount.Neg(amount)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This rounds non-zero values up to the minimum representable value, under the theory that
0000000000000000000000000000000000000000;;		// if you want some resources, you should get some resources, even if you asked for way too small
0000000000000000000000000000000000000000;;		// of an amount.  Arguably, this should be inf.RoundHalfUp (normal rounding), but that would have
0000000000000000000000000000000000000000;;		// the side effect of rounding values < .5n to zero.
0000000000000000000000000000000000000000;;		if v, ok := amount.Unscaled(); v != int64(0) || !ok {
0000000000000000000000000000000000000000;;			amount.Round(amount, Nano.infScale(), inf.RoundUp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The max is just a simple cap.
0000000000000000000000000000000000000000;;		// TODO: this prevents accumulating quantities greater than int64, for instance quota across a cluster
0000000000000000000000000000000000000000;;		if format == BinarySI && amount.Cmp(maxAllowed.Dec) > 0 {
0000000000000000000000000000000000000000;;			amount.Set(maxAllowed.Dec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if format == BinarySI && amount.Cmp(decOne) < 0 && amount.Cmp(decZero) > 0 {
0000000000000000000000000000000000000000;;			// This avoids rounding and hopefully confusion, too.
0000000000000000000000000000000000000000;;			format = DecimalSI
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sign == -1 {
0000000000000000000000000000000000000000;;			amount.Neg(amount)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Quantity{d: infDecAmount{amount}, Format: format}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CanonicalizeBytes returns the canonical form of q and its suffix (see comment on Quantity).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note about BinarySI:
0000000000000000000000000000000000000000;;	// * If q.Format is set to BinarySI and q.Amount represents a non-zero value between
0000000000000000000000000000000000000000;;	//   -1 and +1, it will be emitted as if q.Format were DecimalSI.
0000000000000000000000000000000000000000;;	// * Otherwise, if q.Format is set to BinarySI, frational parts of q.Amount will be
0000000000000000000000000000000000000000;;	//   rounded up. (1.1i becomes 2i.)
0000000000000000000000000000000000000000;;	func (q *Quantity) CanonicalizeBytes(out []byte) (result, suffix []byte) {
0000000000000000000000000000000000000000;;		if q.IsZero() {
0000000000000000000000000000000000000000;;			return zeroBytes, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rounded CanonicalValue
0000000000000000000000000000000000000000;;		format := q.Format
0000000000000000000000000000000000000000;;		switch format {
0000000000000000000000000000000000000000;;		case DecimalExponent, DecimalSI:
0000000000000000000000000000000000000000;;		case BinarySI:
0000000000000000000000000000000000000000;;			if q.CmpInt64(-1024) > 0 && q.CmpInt64(1024) < 0 {
0000000000000000000000000000000000000000;;				// This avoids rounding and hopefully confusion, too.
0000000000000000000000000000000000000000;;				format = DecimalSI
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				var exact bool
0000000000000000000000000000000000000000;;				if rounded, exact = q.AsScale(0); !exact {
0000000000000000000000000000000000000000;;					// Don't lose precision-- show as DecimalSI
0000000000000000000000000000000000000000;;					format = DecimalSI
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			format = DecimalExponent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: If BinarySI formatting is requested but would cause rounding, upgrade to
0000000000000000000000000000000000000000;;		// one of the other formats.
0000000000000000000000000000000000000000;;		switch format {
0000000000000000000000000000000000000000;;		case DecimalExponent, DecimalSI:
0000000000000000000000000000000000000000;;			number, exponent := q.AsCanonicalBytes(out)
0000000000000000000000000000000000000000;;			suffix, _ := quantitySuffixer.constructBytes(10, exponent, format)
0000000000000000000000000000000000000000;;			return number, suffix
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// format must be BinarySI
0000000000000000000000000000000000000000;;			number, exponent := rounded.AsCanonicalBase1024Bytes(out)
0000000000000000000000000000000000000000;;			suffix, _ := quantitySuffixer.constructBytes(2, exponent*10, format)
0000000000000000000000000000000000000000;;			return number, suffix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsInt64 returns a representation of the current value as an int64 if a fast conversion
0000000000000000000000000000000000000000;;	// is possible. If false is returned, callers must use the inf.Dec form of this quantity.
0000000000000000000000000000000000000000;;	func (q *Quantity) AsInt64() (int64, bool) {
0000000000000000000000000000000000000000;;		if q.d.Dec != nil {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q.i.AsInt64()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToDec promotes the quantity in place to use an inf.Dec representation and returns itself.
0000000000000000000000000000000000000000;;	func (q *Quantity) ToDec() *Quantity {
0000000000000000000000000000000000000000;;		if q.d.Dec == nil {
0000000000000000000000000000000000000000;;			q.d.Dec = q.i.AsDec()
0000000000000000000000000000000000000000;;			q.i = int64Amount{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsDec returns the quantity as represented by a scaled inf.Dec.
0000000000000000000000000000000000000000;;	func (q *Quantity) AsDec() *inf.Dec {
0000000000000000000000000000000000000000;;		if q.d.Dec != nil {
0000000000000000000000000000000000000000;;			return q.d.Dec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.d.Dec = q.i.AsDec()
0000000000000000000000000000000000000000;;		q.i = int64Amount{}
0000000000000000000000000000000000000000;;		return q.d.Dec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsCanonicalBytes returns the canonical byte representation of this quantity as a mantissa
0000000000000000000000000000000000000000;;	// and base 10 exponent. The out byte slice may be passed to the method to avoid an extra
0000000000000000000000000000000000000000;;	// allocation.
0000000000000000000000000000000000000000;;	func (q *Quantity) AsCanonicalBytes(out []byte) (result []byte, exponent int32) {
0000000000000000000000000000000000000000;;		if q.d.Dec != nil {
0000000000000000000000000000000000000000;;			return q.d.AsCanonicalBytes(out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q.i.AsCanonicalBytes(out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsZero returns true if the quantity is equal to zero.
0000000000000000000000000000000000000000;;	func (q *Quantity) IsZero() bool {
0000000000000000000000000000000000000000;;		if q.d.Dec != nil {
0000000000000000000000000000000000000000;;			return q.d.Dec.Sign() == 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q.i.value == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign returns 0 if the quantity is zero, -1 if the quantity is less than zero, or 1 if the
0000000000000000000000000000000000000000;;	// quantity is greater than zero.
0000000000000000000000000000000000000000;;	func (q *Quantity) Sign() int {
0000000000000000000000000000000000000000;;		if q.d.Dec != nil {
0000000000000000000000000000000000000000;;			return q.d.Dec.Sign()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q.i.Sign()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsScaled returns the current value, rounded up to the provided scale, and returns
0000000000000000000000000000000000000000;;	// false if the scale resulted in a loss of precision.
0000000000000000000000000000000000000000;;	func (q *Quantity) AsScale(scale Scale) (CanonicalValue, bool) {
0000000000000000000000000000000000000000;;		if q.d.Dec != nil {
0000000000000000000000000000000000000000;;			return q.d.AsScale(scale)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q.i.AsScale(scale)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundUp updates the quantity to the provided scale, ensuring that the value is at
0000000000000000000000000000000000000000;;	// least 1. False is returned if the rounding operation resulted in a loss of precision.
0000000000000000000000000000000000000000;;	// Negative numbers are rounded away from zero (-9 scale 1 rounds to -10).
0000000000000000000000000000000000000000;;	func (q *Quantity) RoundUp(scale Scale) bool {
0000000000000000000000000000000000000000;;		if q.d.Dec != nil {
0000000000000000000000000000000000000000;;			q.s = ""
0000000000000000000000000000000000000000;;			d, exact := q.d.AsScale(scale)
0000000000000000000000000000000000000000;;			q.d = d
0000000000000000000000000000000000000000;;			return exact
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// avoid clearing the string value if we have already calculated it
0000000000000000000000000000000000000000;;		if q.i.scale >= scale {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.s = ""
0000000000000000000000000000000000000000;;		i, exact := q.i.AsScale(scale)
0000000000000000000000000000000000000000;;		q.i = i
0000000000000000000000000000000000000000;;		return exact
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds the provide y quantity to the current value. If the current value is zero,
0000000000000000000000000000000000000000;;	// the format of the quantity will be updated to the format of y.
0000000000000000000000000000000000000000;;	func (q *Quantity) Add(y Quantity) {
0000000000000000000000000000000000000000;;		q.s = ""
0000000000000000000000000000000000000000;;		if q.d.Dec == nil && y.d.Dec == nil {
0000000000000000000000000000000000000000;;			if q.i.value == 0 {
0000000000000000000000000000000000000000;;				q.Format = y.Format
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if q.i.Add(y.i) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if q.IsZero() {
0000000000000000000000000000000000000000;;			q.Format = y.Format
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.ToDec().d.Dec.Add(q.d.Dec, y.AsDec())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sub subtracts the provided quantity from the current value in place. If the current
0000000000000000000000000000000000000000;;	// value is zero, the format of the quantity will be updated to the format of y.
0000000000000000000000000000000000000000;;	func (q *Quantity) Sub(y Quantity) {
0000000000000000000000000000000000000000;;		q.s = ""
0000000000000000000000000000000000000000;;		if q.IsZero() {
0000000000000000000000000000000000000000;;			q.Format = y.Format
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if q.d.Dec == nil && y.d.Dec == nil && q.i.Sub(y.i) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.ToDec().d.Dec.Sub(q.d.Dec, y.AsDec())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cmp returns 0 if the quantity is equal to y, -1 if the quantity is less than y, or 1 if the
0000000000000000000000000000000000000000;;	// quantity is greater than y.
0000000000000000000000000000000000000000;;	func (q *Quantity) Cmp(y Quantity) int {
0000000000000000000000000000000000000000;;		if q.d.Dec == nil && y.d.Dec == nil {
0000000000000000000000000000000000000000;;			return q.i.Cmp(y.i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q.AsDec().Cmp(y.AsDec())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CmpInt64 returns 0 if the quantity is equal to y, -1 if the quantity is less than y, or 1 if the
0000000000000000000000000000000000000000;;	// quantity is greater than y.
0000000000000000000000000000000000000000;;	func (q *Quantity) CmpInt64(y int64) int {
0000000000000000000000000000000000000000;;		if q.d.Dec != nil {
0000000000000000000000000000000000000000;;			return q.d.Dec.Cmp(inf.NewDec(y, inf.Scale(0)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q.i.Cmp(int64Amount{value: y})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Neg sets quantity to be the negative value of itself.
0000000000000000000000000000000000000000;;	func (q *Quantity) Neg() {
0000000000000000000000000000000000000000;;		q.s = ""
0000000000000000000000000000000000000000;;		if q.d.Dec == nil {
0000000000000000000000000000000000000000;;			q.i.value = -q.i.value
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.d.Dec.Neg(q.d.Dec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// int64QuantityExpectedBytes is the expected width in bytes of the canonical string representation
0000000000000000000000000000000000000000;;	// of most Quantity values.
0000000000000000000000000000000000000000;;	const int64QuantityExpectedBytes = 18
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String formats the Quantity as a string, caching the result if not calculated.
0000000000000000000000000000000000000000;;	// String is an expensive operation and caching this result significantly reduces the cost of
0000000000000000000000000000000000000000;;	// normal parse / marshal operations on Quantity.
0000000000000000000000000000000000000000;;	func (q *Quantity) String() string {
0000000000000000000000000000000000000000;;		if len(q.s) == 0 {
0000000000000000000000000000000000000000;;			result := make([]byte, 0, int64QuantityExpectedBytes)
0000000000000000000000000000000000000000;;			number, suffix := q.CanonicalizeBytes(result)
0000000000000000000000000000000000000000;;			number = append(number, suffix...)
0000000000000000000000000000000000000000;;			q.s = string(number)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q.s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements the json.Marshaller interface.
0000000000000000000000000000000000000000;;	func (q Quantity) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(q.s) > 0 {
0000000000000000000000000000000000000000;;			out := make([]byte, len(q.s)+2)
0000000000000000000000000000000000000000;;			out[0], out[len(out)-1] = '"', '"'
0000000000000000000000000000000000000000;;			copy(out[1:], q.s)
0000000000000000000000000000000000000000;;			return out, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := make([]byte, int64QuantityExpectedBytes, int64QuantityExpectedBytes)
0000000000000000000000000000000000000000;;		result[0] = '"'
0000000000000000000000000000000000000000;;		number, suffix := q.CanonicalizeBytes(result[1:1])
0000000000000000000000000000000000000000;;		// if the same slice was returned to us that we passed in, avoid another allocation by copying number into
0000000000000000000000000000000000000000;;		// the source slice and returning that
0000000000000000000000000000000000000000;;		if len(number) > 0 && &number[0] == &result[1] && (len(number)+len(suffix)+2) <= int64QuantityExpectedBytes {
0000000000000000000000000000000000000000;;			number = append(number, suffix...)
0000000000000000000000000000000000000000;;			number = append(number, '"')
0000000000000000000000000000000000000000;;			return result[:1+len(number)], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if CanonicalizeBytes needed more space than our slice provided, we may need to allocate again so use
0000000000000000000000000000000000000000;;		// append
0000000000000000000000000000000000000000;;		result = result[:1]
0000000000000000000000000000000000000000;;		result = append(result, number...)
0000000000000000000000000000000000000000;;		result = append(result, suffix...)
0000000000000000000000000000000000000000;;		result = append(result, '"')
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements the json.Unmarshaller interface.
0000000000000000000000000000000000000000;;	// TODO: Remove support for leading/trailing whitespace
0000000000000000000000000000000000000000;;	func (q *Quantity) UnmarshalJSON(value []byte) error {
0000000000000000000000000000000000000000;;		l := len(value)
0000000000000000000000000000000000000000;;		if l == 4 && bytes.Equal(value, []byte("null")) {
0000000000000000000000000000000000000000;;			q.d.Dec = nil
0000000000000000000000000000000000000000;;			q.i = int64Amount{}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l >= 2 && value[0] == '"' && value[l-1] == '"' {
0000000000000000000000000000000000000000;;			value = value[1 : l-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parsed, err := ParseQuantity(strings.TrimSpace(string(value)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This copy is safe because parsed will not be referred to again.
0000000000000000000000000000000000000000;;		*q = parsed
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewQuantity returns a new Quantity representing the given
0000000000000000000000000000000000000000;;	// value in the given format.
0000000000000000000000000000000000000000;;	func NewQuantity(value int64, format Format) *Quantity {
0000000000000000000000000000000000000000;;		return &Quantity{
0000000000000000000000000000000000000000;;			i:      int64Amount{value: value},
0000000000000000000000000000000000000000;;			Format: format,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMilliQuantity returns a new Quantity representing the given
0000000000000000000000000000000000000000;;	// value * 1/1000 in the given format. Note that BinarySI formatting
0000000000000000000000000000000000000000;;	// will round fractional values, and will be changed to DecimalSI for
0000000000000000000000000000000000000000;;	// values x where (-1 < x < 1) && (x != 0).
0000000000000000000000000000000000000000;;	func NewMilliQuantity(value int64, format Format) *Quantity {
0000000000000000000000000000000000000000;;		return &Quantity{
0000000000000000000000000000000000000000;;			i:      int64Amount{value: value, scale: -3},
0000000000000000000000000000000000000000;;			Format: format,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewScaledQuantity returns a new Quantity representing the given
0000000000000000000000000000000000000000;;	// value * 10^scale in DecimalSI format.
0000000000000000000000000000000000000000;;	func NewScaledQuantity(value int64, scale Scale) *Quantity {
0000000000000000000000000000000000000000;;		return &Quantity{
0000000000000000000000000000000000000000;;			i:      int64Amount{value: value, scale: scale},
0000000000000000000000000000000000000000;;			Format: DecimalSI,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value returns the value of q; any fractional part will be lost.
0000000000000000000000000000000000000000;;	func (q *Quantity) Value() int64 {
0000000000000000000000000000000000000000;;		return q.ScaledValue(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MilliValue returns the value of ceil(q * 1000); this could overflow an int64;
0000000000000000000000000000000000000000;;	// if that's a concern, call Value() first to verify the number is small enough.
0000000000000000000000000000000000000000;;	func (q *Quantity) MilliValue() int64 {
0000000000000000000000000000000000000000;;		return q.ScaledValue(Milli)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaledValue returns the value of ceil(q * 10^scale); this could overflow an int64.
0000000000000000000000000000000000000000;;	// To detect overflow, call Value() first and verify the expected magnitude.
0000000000000000000000000000000000000000;;	func (q *Quantity) ScaledValue(scale Scale) int64 {
0000000000000000000000000000000000000000;;		if q.d.Dec == nil {
0000000000000000000000000000000000000000;;			i, _ := q.i.AsScaledInt64(scale)
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dec := q.d.Dec
0000000000000000000000000000000000000000;;		return scaledValue(dec.UnscaledBig(), int(dec.Scale()), int(scale.infScale()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets q's value to be value.
0000000000000000000000000000000000000000;;	func (q *Quantity) Set(value int64) {
0000000000000000000000000000000000000000;;		q.SetScaled(value, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMilli sets q's value to be value * 1/1000.
0000000000000000000000000000000000000000;;	func (q *Quantity) SetMilli(value int64) {
0000000000000000000000000000000000000000;;		q.SetScaled(value, Milli)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetScaled sets q's value to be value * 10^scale
0000000000000000000000000000000000000000;;	func (q *Quantity) SetScaled(value int64, scale Scale) {
0000000000000000000000000000000000000000;;		q.s = ""
0000000000000000000000000000000000000000;;		q.d.Dec = nil
0000000000000000000000000000000000000000;;		q.i = int64Amount{value: value, scale: scale}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy is a convenience function that makes a deep copy for you. Non-deep
0000000000000000000000000000000000000000;;	// copies of quantities share pointers and you will regret that.
0000000000000000000000000000000000000000;;	func (q *Quantity) Copy() *Quantity {
0000000000000000000000000000000000000000;;		if q.d.Dec == nil {
0000000000000000000000000000000000000000;;			return &Quantity{
0000000000000000000000000000000000000000;;				s:      q.s,
0000000000000000000000000000000000000000;;				i:      q.i,
0000000000000000000000000000000000000000;;				Format: q.Format,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tmp := &inf.Dec{}
0000000000000000000000000000000000000000;;		return &Quantity{
0000000000000000000000000000000000000000;;			s:      q.s,
0000000000000000000000000000000000000000;;			d:      infDecAmount{tmp.Set(q.d.Dec)},
0000000000000000000000000000000000000000;;			Format: q.Format,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// qFlag is a helper type for the Flag function
0000000000000000000000000000000000000000;;	type qFlag struct {
0000000000000000000000000000000000000000;;		dest *Quantity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sets the value of the internal Quantity. (used by flag & pflag)
0000000000000000000000000000000000000000;;	func (qf qFlag) Set(val string) error {
0000000000000000000000000000000000000000;;		q, err := ParseQuantity(val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This copy is OK because q will not be referenced again.
0000000000000000000000000000000000000000;;		*qf.dest = q
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converts the value of the internal Quantity to a string. (used by flag & pflag)
0000000000000000000000000000000000000000;;	func (qf qFlag) String() string {
0000000000000000000000000000000000000000;;		return qf.dest.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// States the type of flag this is (Quantity). (used by pflag)
0000000000000000000000000000000000000000;;	func (qf qFlag) Type() string {
0000000000000000000000000000000000000000;;		return "quantity"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QuantityFlag is a helper that makes a quantity flag (using standard flag package).
0000000000000000000000000000000000000000;;	// Will panic if defaultValue is not a valid quantity.
0000000000000000000000000000000000000000;;	func QuantityFlag(flagName, defaultValue, description string) *Quantity {
0000000000000000000000000000000000000000;;		q := MustParse(defaultValue)
0000000000000000000000000000000000000000;;		flag.Var(NewQuantityFlagValue(&q), flagName, description)
0000000000000000000000000000000000000000;;		return &q
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewQuantityFlagValue returns an object that can be used to back a flag,
0000000000000000000000000000000000000000;;	// pointing at the given Quantity variable.
0000000000000000000000000000000000000000;;	func NewQuantityFlagValue(q *Quantity) flag.Value {
0000000000000000000000000000000000000000;;		return qFlag{q}
0000000000000000000000000000000000000000;;	}
