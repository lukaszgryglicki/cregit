0000000000000000000000000000000000000000;;	// Copyright 2015 The appc Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8d973c48ce204bda083f5a578278a9cd3743f879;Godeps/_workspace/src/github.com/appc/spec/schema/types/acname.go[Godeps/_workspace/src/github.com/appc/spec/schema/types/acname.go][vendor/github.com/appc/spec/schema/types/acname.go];	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ValidACName is a regular expression that defines a valid ACName
0000000000000000000000000000000000000000;;		ValidACName = regexp.MustCompile("^[a-z0-9]+([-][a-z0-9]+)*$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		invalidACNameChars = regexp.MustCompile("[^a-z0-9-]")
0000000000000000000000000000000000000000;;		invalidACNameEdges = regexp.MustCompile("(^[-]+)|([-]+$)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrEmptyACName         = ACNameError("ACName cannot be empty")
0000000000000000000000000000000000000000;;		ErrInvalidEdgeInACName = ACNameError("ACName must start and end with only lower case " +
0000000000000000000000000000000000000000;;			"alphanumeric characters")
0000000000000000000000000000000000000000;;		ErrInvalidCharInACName = ACNameError("ACName must contain only lower case " +
0000000000000000000000000000000000000000;;			`alphanumeric characters plus "-"`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ACName (an App-Container Name) is a format used by keys in different formats
0000000000000000000000000000000000000000;;	// of the App Container Standard. An ACName is restricted to numeric and lowercase
0000000000000000000000000000000000000000;;	// characters accepted by the DNS RFC[1] plus "-"; all alphabetical characters must
0000000000000000000000000000000000000000;;	// be lowercase only. Furthermore, the first and last character ("edges") must be
0000000000000000000000000000000000000000;;	// alphanumeric, and an ACName cannot be empty. Programmatically, an ACName must
0000000000000000000000000000000000000000;;	// conform to the regular expression ValidACName.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// [1] http://tools.ietf.org/html/rfc1123#page-13
0000000000000000000000000000000000000000;;	type ACName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n ACName) String() string {
0000000000000000000000000000000000000000;;		return string(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets the ACName to the given value, if it is valid; if not,
0000000000000000000000000000000000000000;;	// an error is returned.
0000000000000000000000000000000000000000;;	func (n *ACName) Set(s string) error {
0000000000000000000000000000000000000000;;		nn, err := NewACName(s)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			*n = *nn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equals checks whether a given ACName is equal to this one.
0000000000000000000000000000000000000000;;	func (n ACName) Equals(o ACName) bool {
0000000000000000000000000000000000000000;;		return strings.ToLower(string(n)) == strings.ToLower(string(o))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty returns a boolean indicating whether this ACName is empty.
0000000000000000000000000000000000000000;;	func (n ACName) Empty() bool {
0000000000000000000000000000000000000000;;		return n.String() == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewACName generates a new ACName from a string. If the given string is
0000000000000000000000000000000000000000;;	// not a valid ACName, nil and an error are returned.
0000000000000000000000000000000000000000;;	func NewACName(s string) (*ACName, error) {
0000000000000000000000000000000000000000;;		n := ACName(s)
0000000000000000000000000000000000000000;;		if err := n.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustACName generates a new ACName from a string, If the given string is
0000000000000000000000000000000000000000;;	// not a valid ACName, it panics.
0000000000000000000000000000000000000000;;	func MustACName(s string) *ACName {
0000000000000000000000000000000000000000;;		n, err := NewACName(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n ACName) assertValid() error {
0000000000000000000000000000000000000000;;		s := string(n)
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return ErrEmptyACName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if invalidACNameChars.MatchString(s) {
0000000000000000000000000000000000000000;;			return ErrInvalidCharInACName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if invalidACNameEdges.MatchString(s) {
0000000000000000000000000000000000000000;;			return ErrInvalidEdgeInACName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements the json.Unmarshaler interface
0000000000000000000000000000000000000000;;	func (n *ACName) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nn, err := NewACName(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*n = *nn
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements the json.Marshaler interface
0000000000000000000000000000000000000000;;	func (n ACName) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if err := n.assertValid(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(n.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SanitizeACName replaces every invalid ACName character in s with a dash
0000000000000000000000000000000000000000;;	// making it a legal ACName string. If the character is an upper case letter it
0000000000000000000000000000000000000000;;	// replaces it with its lower case. It also removes illegal edge characters
0000000000000000000000000000000000000000;;	// (hyphens).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is a helper function and its algorithm is not part of the spec. It
0000000000000000000000000000000000000000;;	// should not be called without the user explicitly asking for a suggestion.
0000000000000000000000000000000000000000;;	func SanitizeACName(s string) (string, error) {
0000000000000000000000000000000000000000;;		s = strings.ToLower(s)
0000000000000000000000000000000000000000;;		s = invalidACNameChars.ReplaceAllString(s, "-")
0000000000000000000000000000000000000000;;		s = invalidACNameEdges.ReplaceAllString(s, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return "", errors.New("must contain at least one valid character")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
