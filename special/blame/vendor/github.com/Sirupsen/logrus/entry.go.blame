0000000000000000000000000000000000000000;;	package logrus
fb7a692d29014e605484d1379339c3bb1445f46a;Godeps/_workspace/src/github.com/Sirupsen/logrus/entry.go[Godeps/_workspace/src/github.com/Sirupsen/logrus/entry.go][vendor/github.com/Sirupsen/logrus/entry.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An entry is the final or intermediate Logrus logging entry. It contains all
0000000000000000000000000000000000000000;;	// the fields passed with WithField{,s}. It's finally logged when Debug, Info,
0000000000000000000000000000000000000000;;	// Warn, Error, Fatal or Panic is called on it. These objects can be reused and
0000000000000000000000000000000000000000;;	// passed around as much as you wish to avoid field duplication.
0000000000000000000000000000000000000000;;	type Entry struct {
0000000000000000000000000000000000000000;;		Logger *Logger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Contains all the fields set by the user.
0000000000000000000000000000000000000000;;		Data Fields
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Time at which the log entry was created
0000000000000000000000000000000000000000;;		Time time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Level the log entry was logged at: Debug, Info, Warn, Error, Fatal or Panic
0000000000000000000000000000000000000000;;		Level Level
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Message passed to Debug, Info, Warn, Error, Fatal or Panic
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewEntry(logger *Logger) *Entry {
0000000000000000000000000000000000000000;;		return &Entry{
0000000000000000000000000000000000000000;;			Logger: logger,
0000000000000000000000000000000000000000;;			// Default is three fields, give a little extra room
0000000000000000000000000000000000000000;;			Data: make(Fields, 5),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a reader for the entry, which is a proxy to the formatter.
0000000000000000000000000000000000000000;;	func (entry *Entry) Reader() (*bytes.Buffer, error) {
0000000000000000000000000000000000000000;;		serialized, err := entry.Logger.Formatter.Format(entry)
0000000000000000000000000000000000000000;;		return bytes.NewBuffer(serialized), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the string representation from the reader and ultimately the
0000000000000000000000000000000000000000;;	// formatter.
0000000000000000000000000000000000000000;;	func (entry *Entry) String() (string, error) {
0000000000000000000000000000000000000000;;		reader, err := entry.Reader()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return reader.String(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a single field to the Entry.
0000000000000000000000000000000000000000;;	func (entry *Entry) WithField(key string, value interface{}) *Entry {
0000000000000000000000000000000000000000;;		return entry.WithFields(Fields{key: value})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a map of fields to the Entry.
0000000000000000000000000000000000000000;;	func (entry *Entry) WithFields(fields Fields) *Entry {
0000000000000000000000000000000000000000;;		data := Fields{}
0000000000000000000000000000000000000000;;		for k, v := range entry.Data {
0000000000000000000000000000000000000000;;			data[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range fields {
0000000000000000000000000000000000000000;;			data[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Entry{Logger: entry.Logger, Data: data}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) log(level Level, msg string) {
0000000000000000000000000000000000000000;;		entry.Time = time.Now()
0000000000000000000000000000000000000000;;		entry.Level = level
0000000000000000000000000000000000000000;;		entry.Message = msg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := entry.Logger.Hooks.Fire(level, entry); err != nil {
0000000000000000000000000000000000000000;;			entry.Logger.mu.Lock()
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Failed to fire hook: %v\n", err)
0000000000000000000000000000000000000000;;			entry.Logger.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader, err := entry.Reader()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			entry.Logger.mu.Lock()
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Failed to obtain reader, %v\n", err)
0000000000000000000000000000000000000000;;			entry.Logger.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entry.Logger.mu.Lock()
0000000000000000000000000000000000000000;;		defer entry.Logger.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = io.Copy(entry.Logger.Out, reader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Failed to write to log, %v\n", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To avoid Entry#log() returning a value that only would make sense for
0000000000000000000000000000000000000000;;		// panic() to use in Entry#Panic(), we avoid the allocation by checking
0000000000000000000000000000000000000000;;		// directly here.
0000000000000000000000000000000000000000;;		if level <= PanicLevel {
0000000000000000000000000000000000000000;;			panic(entry)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Debug(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= DebugLevel {
0000000000000000000000000000000000000000;;			entry.log(DebugLevel, fmt.Sprint(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Print(args ...interface{}) {
0000000000000000000000000000000000000000;;		entry.Info(args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Info(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= InfoLevel {
0000000000000000000000000000000000000000;;			entry.log(InfoLevel, fmt.Sprint(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Warn(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= WarnLevel {
0000000000000000000000000000000000000000;;			entry.log(WarnLevel, fmt.Sprint(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Error(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= ErrorLevel {
0000000000000000000000000000000000000000;;			entry.log(ErrorLevel, fmt.Sprint(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Fatal(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= FatalLevel {
0000000000000000000000000000000000000000;;			entry.log(FatalLevel, fmt.Sprint(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		os.Exit(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Panic(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= PanicLevel {
0000000000000000000000000000000000000000;;			entry.log(PanicLevel, fmt.Sprint(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic(fmt.Sprint(args...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Entry Printf family functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Debugf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= DebugLevel {
0000000000000000000000000000000000000000;;			entry.Debug(fmt.Sprintf(format, args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Infof(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= InfoLevel {
0000000000000000000000000000000000000000;;			entry.Info(fmt.Sprintf(format, args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Printf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		entry.Infof(format, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Warnf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= WarnLevel {
0000000000000000000000000000000000000000;;			entry.Warn(fmt.Sprintf(format, args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Warningf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		entry.Warnf(format, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Errorf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= ErrorLevel {
0000000000000000000000000000000000000000;;			entry.Error(fmt.Sprintf(format, args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Fatalf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= FatalLevel {
0000000000000000000000000000000000000000;;			entry.Fatal(fmt.Sprintf(format, args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Panicf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= PanicLevel {
0000000000000000000000000000000000000000;;			entry.Panic(fmt.Sprintf(format, args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Entry Println family functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Debugln(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= DebugLevel {
0000000000000000000000000000000000000000;;			entry.Debug(entry.sprintlnn(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Infoln(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= InfoLevel {
0000000000000000000000000000000000000000;;			entry.Info(entry.sprintlnn(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Println(args ...interface{}) {
0000000000000000000000000000000000000000;;		entry.Infoln(args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Warnln(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= WarnLevel {
0000000000000000000000000000000000000000;;			entry.Warn(entry.sprintlnn(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Warningln(args ...interface{}) {
0000000000000000000000000000000000000000;;		entry.Warnln(args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Errorln(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= ErrorLevel {
0000000000000000000000000000000000000000;;			entry.Error(entry.sprintlnn(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Fatalln(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= FatalLevel {
0000000000000000000000000000000000000000;;			entry.Fatal(entry.sprintlnn(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (entry *Entry) Panicln(args ...interface{}) {
0000000000000000000000000000000000000000;;		if entry.Logger.Level >= PanicLevel {
0000000000000000000000000000000000000000;;			entry.Panic(entry.sprintlnn(args...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sprintlnn => Sprint no newline. This is to get the behavior of how
0000000000000000000000000000000000000000;;	// fmt.Sprintln where spaces are always added between operands, regardless of
0000000000000000000000000000000000000000;;	// their type. Instead of vendoring the Sprintln implementation to spare a
0000000000000000000000000000000000000000;;	// string allocation, we do the simplest thing.
0000000000000000000000000000000000000000;;	func (entry *Entry) sprintlnn(args ...interface{}) string {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintln(args...)
0000000000000000000000000000000000000000;;		return msg[:len(msg)-1]
0000000000000000000000000000000000000000;;	}
