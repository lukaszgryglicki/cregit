0000000000000000000000000000000000000000;;	package logrus
fb7a692d29014e605484d1379339c3bb1445f46a;Godeps/_workspace/src/github.com/Sirupsen/logrus/hooks.go[Godeps/_workspace/src/github.com/Sirupsen/logrus/hooks.go][vendor/github.com/Sirupsen/logrus/hooks.go];	
0000000000000000000000000000000000000000;;	// A hook to be fired when logging on the logging levels returned from
0000000000000000000000000000000000000000;;	// `Levels()` on your implementation of the interface. Note that this is not
0000000000000000000000000000000000000000;;	// fired in a goroutine or a channel with workers, you should handle such
0000000000000000000000000000000000000000;;	// functionality yourself if your call is non-blocking and you don't wish for
0000000000000000000000000000000000000000;;	// the logging calls for levels returned from `Levels()` to block.
0000000000000000000000000000000000000000;;	type Hook interface {
0000000000000000000000000000000000000000;;		Levels() []Level
0000000000000000000000000000000000000000;;		Fire(*Entry) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Internal type for storing the hooks on a logger instance.
0000000000000000000000000000000000000000;;	type levelHooks map[Level][]Hook
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a hook to an instance of logger. This is called with
0000000000000000000000000000000000000000;;	// `log.Hooks.Add(new(MyHook))` where `MyHook` implements the `Hook` interface.
0000000000000000000000000000000000000000;;	func (hooks levelHooks) Add(hook Hook) {
0000000000000000000000000000000000000000;;		for _, level := range hook.Levels() {
0000000000000000000000000000000000000000;;			hooks[level] = append(hooks[level], hook)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fire all the hooks for the passed level. Used by `entry.log` to fire
0000000000000000000000000000000000000000;;	// appropriate hooks for a log entry.
0000000000000000000000000000000000000000;;	func (hooks levelHooks) Fire(level Level, entry *Entry) error {
0000000000000000000000000000000000000000;;		for _, hook := range hooks[level] {
0000000000000000000000000000000000000000;;			if err := hook.Fire(entry); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
