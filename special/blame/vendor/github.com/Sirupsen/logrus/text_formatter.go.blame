0000000000000000000000000000000000000000;;	package logrus
fb7a692d29014e605484d1379339c3bb1445f46a;Godeps/_workspace/src/github.com/Sirupsen/logrus/text_formatter.go[Godeps/_workspace/src/github.com/Sirupsen/logrus/text_formatter.go][vendor/github.com/Sirupsen/logrus/text_formatter.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		nocolor = 0
0000000000000000000000000000000000000000;;		red     = 31
0000000000000000000000000000000000000000;;		green   = 32
0000000000000000000000000000000000000000;;		yellow  = 33
0000000000000000000000000000000000000000;;		blue    = 34
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		baseTimestamp time.Time
0000000000000000000000000000000000000000;;		isTerminal    bool
0000000000000000000000000000000000000000;;		noQuoteNeeded *regexp.Regexp
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		baseTimestamp = time.Now()
0000000000000000000000000000000000000000;;		isTerminal = IsTerminal()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func miniTS() int {
0000000000000000000000000000000000000000;;		return int(time.Since(baseTimestamp) / time.Second)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TextFormatter struct {
0000000000000000000000000000000000000000;;		// Set to true to bypass checking for a TTY before outputting colors.
0000000000000000000000000000000000000000;;		ForceColors   bool
0000000000000000000000000000000000000000;;		DisableColors bool
0000000000000000000000000000000000000000;;		// Set to true to disable timestamp logging (useful when the output
0000000000000000000000000000000000000000;;		// is redirected to a logging system already adding a timestamp)
0000000000000000000000000000000000000000;;		DisableTimestamp bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *TextFormatter) Format(entry *Entry) ([]byte, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var keys []string
0000000000000000000000000000000000000000;;		for k := range entry.Data {
0000000000000000000000000000000000000000;;			keys = append(keys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prefixFieldClashes(entry.Data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isColored := (f.ForceColors || isTerminal) && !f.DisableColors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isColored {
0000000000000000000000000000000000000000;;			printColored(b, entry, keys)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if !f.DisableTimestamp {
0000000000000000000000000000000000000000;;				f.appendKeyValue(b, "time", entry.Time.Format(time.RFC3339))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.appendKeyValue(b, "level", entry.Level.String())
0000000000000000000000000000000000000000;;			f.appendKeyValue(b, "msg", entry.Message)
0000000000000000000000000000000000000000;;			for _, key := range keys {
0000000000000000000000000000000000000000;;				f.appendKeyValue(b, key, entry.Data[key])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.WriteByte('\n')
0000000000000000000000000000000000000000;;		return b.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printColored(b *bytes.Buffer, entry *Entry, keys []string) {
0000000000000000000000000000000000000000;;		var levelColor int
0000000000000000000000000000000000000000;;		switch entry.Level {
0000000000000000000000000000000000000000;;		case WarnLevel:
0000000000000000000000000000000000000000;;			levelColor = yellow
0000000000000000000000000000000000000000;;		case ErrorLevel, FatalLevel, PanicLevel:
0000000000000000000000000000000000000000;;			levelColor = red
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			levelColor = blue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		levelText := strings.ToUpper(entry.Level.String())[0:4]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(b, "\x1b[%dm%s\x1b[0m[%04d] %-44s ", levelColor, levelText, miniTS(), entry.Message)
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			v := entry.Data[k]
0000000000000000000000000000000000000000;;			fmt.Fprintf(b, " \x1b[%dm%s\x1b[0m=%v", levelColor, k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func needsQuoting(text string) bool {
0000000000000000000000000000000000000000;;		for _, ch := range text {
0000000000000000000000000000000000000000;;			if !((ch >= 'a' && ch <= 'z') ||
0000000000000000000000000000000000000000;;				(ch >= 'A' && ch <= 'Z') ||
0000000000000000000000000000000000000000;;				(ch >= '0' && ch < '9') ||
0000000000000000000000000000000000000000;;				ch == '-' || ch == '.') {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *TextFormatter) appendKeyValue(b *bytes.Buffer, key, value interface{}) {
0000000000000000000000000000000000000000;;		switch value.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			if needsQuoting(value.(string)) {
0000000000000000000000000000000000000000;;				fmt.Fprintf(b, "%v=%s ", key, value)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(b, "%v=%q ", key, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case error:
0000000000000000000000000000000000000000;;			if needsQuoting(value.(error).Error()) {
0000000000000000000000000000000000000000;;				fmt.Fprintf(b, "%v=%s ", key, value)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(b, "%v=%q ", key, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			fmt.Fprintf(b, "%v=%v ", key, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
