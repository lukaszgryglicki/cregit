0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	// +build linux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fsnotify
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/sys/unix"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fdPoller struct {
0000000000000000000000000000000000000000;;		fd   int    // File descriptor (as returned by the inotify_init() syscall)
0000000000000000000000000000000000000000;;		epfd int    // Epoll file descriptor
0000000000000000000000000000000000000000;;		pipe [2]int // Pipe for waking up
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func emptyPoller(fd int) *fdPoller {
0000000000000000000000000000000000000000;;		poller := new(fdPoller)
0000000000000000000000000000000000000000;;		poller.fd = fd
0000000000000000000000000000000000000000;;		poller.epfd = -1
0000000000000000000000000000000000000000;;		poller.pipe[0] = -1
0000000000000000000000000000000000000000;;		poller.pipe[1] = -1
0000000000000000000000000000000000000000;;		return poller
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new inotify poller.
0000000000000000000000000000000000000000;;	// This creates an inotify handler, and an epoll handler.
0000000000000000000000000000000000000000;;	func newFdPoller(fd int) (*fdPoller, error) {
0000000000000000000000000000000000000000;;		var errno error
0000000000000000000000000000000000000000;;		poller := emptyPoller(fd)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if errno != nil {
0000000000000000000000000000000000000000;;				poller.close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		poller.fd = fd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create epoll fd
0000000000000000000000000000000000000000;;		poller.epfd, errno = unix.EpollCreate1(0)
0000000000000000000000000000000000000000;;		if poller.epfd == -1 {
0000000000000000000000000000000000000000;;			return nil, errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Create pipe; pipe[0] is the read end, pipe[1] the write end.
0000000000000000000000000000000000000000;;		errno = unix.Pipe2(poller.pipe[:], unix.O_NONBLOCK)
0000000000000000000000000000000000000000;;		if errno != nil {
0000000000000000000000000000000000000000;;			return nil, errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register inotify fd with epoll
0000000000000000000000000000000000000000;;		event := unix.EpollEvent{
0000000000000000000000000000000000000000;;			Fd:     int32(poller.fd),
0000000000000000000000000000000000000000;;			Events: unix.EPOLLIN,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errno = unix.EpollCtl(poller.epfd, unix.EPOLL_CTL_ADD, poller.fd, &event)
0000000000000000000000000000000000000000;;		if errno != nil {
0000000000000000000000000000000000000000;;			return nil, errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register pipe fd with epoll
0000000000000000000000000000000000000000;;		event = unix.EpollEvent{
0000000000000000000000000000000000000000;;			Fd:     int32(poller.pipe[0]),
0000000000000000000000000000000000000000;;			Events: unix.EPOLLIN,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errno = unix.EpollCtl(poller.epfd, unix.EPOLL_CTL_ADD, poller.pipe[0], &event)
0000000000000000000000000000000000000000;;		if errno != nil {
0000000000000000000000000000000000000000;;			return nil, errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return poller, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait using epoll.
0000000000000000000000000000000000000000;;	// Returns true if something is ready to be read,
0000000000000000000000000000000000000000;;	// false if there is not.
0000000000000000000000000000000000000000;;	func (poller *fdPoller) wait() (bool, error) {
0000000000000000000000000000000000000000;;		// 3 possible events per fd, and 2 fds, makes a maximum of 6 events.
0000000000000000000000000000000000000000;;		// I don't know whether epoll_wait returns the number of events returned,
0000000000000000000000000000000000000000;;		// or the total number of events ready.
0000000000000000000000000000000000000000;;		// I decided to catch both by making the buffer one larger than the maximum.
0000000000000000000000000000000000000000;;		events := make([]unix.EpollEvent, 7)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n, errno := unix.EpollWait(poller.epfd, events, -1)
0000000000000000000000000000000000000000;;			if n == -1 {
0000000000000000000000000000000000000000;;				if errno == unix.EINTR {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, errno
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n == 0 {
0000000000000000000000000000000000000000;;				// If there are no events, try again.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n > 6 {
0000000000000000000000000000000000000000;;				// This should never happen. More events were returned than should be possible.
0000000000000000000000000000000000000000;;				return false, errors.New("epoll_wait returned more events than I know what to do with")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ready := events[:n]
0000000000000000000000000000000000000000;;			epollhup := false
0000000000000000000000000000000000000000;;			epollerr := false
0000000000000000000000000000000000000000;;			epollin := false
0000000000000000000000000000000000000000;;			for _, event := range ready {
0000000000000000000000000000000000000000;;				if event.Fd == int32(poller.fd) {
0000000000000000000000000000000000000000;;					if event.Events&unix.EPOLLHUP != 0 {
0000000000000000000000000000000000000000;;						// This should not happen, but if it does, treat it as a wakeup.
0000000000000000000000000000000000000000;;						epollhup = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if event.Events&unix.EPOLLERR != 0 {
0000000000000000000000000000000000000000;;						// If an error is waiting on the file descriptor, we should pretend
0000000000000000000000000000000000000000;;						// something is ready to read, and let unix.Read pick up the error.
0000000000000000000000000000000000000000;;						epollerr = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if event.Events&unix.EPOLLIN != 0 {
0000000000000000000000000000000000000000;;						// There is data to read.
0000000000000000000000000000000000000000;;						epollin = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if event.Fd == int32(poller.pipe[0]) {
0000000000000000000000000000000000000000;;					if event.Events&unix.EPOLLHUP != 0 {
0000000000000000000000000000000000000000;;						// Write pipe descriptor was closed, by us. This means we're closing down the
0000000000000000000000000000000000000000;;						// watcher, and we should wake up.
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if event.Events&unix.EPOLLERR != 0 {
0000000000000000000000000000000000000000;;						// If an error is waiting on the pipe file descriptor.
0000000000000000000000000000000000000000;;						// This is an absolute mystery, and should never ever happen.
0000000000000000000000000000000000000000;;						return false, errors.New("Error on the pipe descriptor.")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if event.Events&unix.EPOLLIN != 0 {
0000000000000000000000000000000000000000;;						// This is a regular wakeup, so we have to clear the buffer.
0000000000000000000000000000000000000000;;						err := poller.clearWake()
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return false, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if epollhup || epollerr || epollin {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close the write end of the poller.
0000000000000000000000000000000000000000;;	func (poller *fdPoller) wake() error {
0000000000000000000000000000000000000000;;		buf := make([]byte, 1)
0000000000000000000000000000000000000000;;		n, errno := unix.Write(poller.pipe[1], buf)
0000000000000000000000000000000000000000;;		if n == -1 {
0000000000000000000000000000000000000000;;			if errno == unix.EAGAIN {
0000000000000000000000000000000000000000;;				// Buffer is full, poller will wake.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (poller *fdPoller) clearWake() error {
0000000000000000000000000000000000000000;;		// You have to be woken up a LOT in order to get to 100!
0000000000000000000000000000000000000000;;		buf := make([]byte, 100)
0000000000000000000000000000000000000000;;		n, errno := unix.Read(poller.pipe[0], buf)
0000000000000000000000000000000000000000;;		if n == -1 {
0000000000000000000000000000000000000000;;			if errno == unix.EAGAIN {
0000000000000000000000000000000000000000;;				// Buffer is empty, someone else cleared our wake.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close all poller file descriptors, but not the one passed to it.
0000000000000000000000000000000000000000;;	func (poller *fdPoller) close() {
0000000000000000000000000000000000000000;;		if poller.pipe[1] != -1 {
0000000000000000000000000000000000000000;;			unix.Close(poller.pipe[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if poller.pipe[0] != -1 {
0000000000000000000000000000000000000000;;			unix.Close(poller.pipe[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if poller.epfd != -1 {
0000000000000000000000000000000000000000;;			unix.Close(poller.epfd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
