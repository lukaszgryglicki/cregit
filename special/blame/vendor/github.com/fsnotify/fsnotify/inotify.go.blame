0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	// +build linux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fsnotify
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/sys/unix"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watcher watches a set of files, delivering events to a channel.
0000000000000000000000000000000000000000;;	type Watcher struct {
0000000000000000000000000000000000000000;;		Events   chan Event
0000000000000000000000000000000000000000;;		Errors   chan error
0000000000000000000000000000000000000000;;		mu       sync.Mutex // Map access
0000000000000000000000000000000000000000;;		cv       *sync.Cond // sync removing on rm_watch with IN_IGNORE
0000000000000000000000000000000000000000;;		fd       int
0000000000000000000000000000000000000000;;		poller   *fdPoller
0000000000000000000000000000000000000000;;		watches  map[string]*watch // Map of inotify watches (key: path)
0000000000000000000000000000000000000000;;		paths    map[int]string    // Map of watched paths (key: watch descriptor)
0000000000000000000000000000000000000000;;		done     chan struct{}     // Channel for sending a "quit message" to the reader goroutine
0000000000000000000000000000000000000000;;		doneResp chan struct{}     // Channel to respond to Close
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.
0000000000000000000000000000000000000000;;	func NewWatcher() (*Watcher, error) {
0000000000000000000000000000000000000000;;		// Create inotify fd
0000000000000000000000000000000000000000;;		fd, errno := unix.InotifyInit()
0000000000000000000000000000000000000000;;		if fd == -1 {
0000000000000000000000000000000000000000;;			return nil, errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Create epoll
0000000000000000000000000000000000000000;;		poller, err := newFdPoller(fd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			unix.Close(fd)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w := &Watcher{
0000000000000000000000000000000000000000;;			fd:       fd,
0000000000000000000000000000000000000000;;			poller:   poller,
0000000000000000000000000000000000000000;;			watches:  make(map[string]*watch),
0000000000000000000000000000000000000000;;			paths:    make(map[int]string),
0000000000000000000000000000000000000000;;			Events:   make(chan Event),
0000000000000000000000000000000000000000;;			Errors:   make(chan error),
0000000000000000000000000000000000000000;;			done:     make(chan struct{}),
0000000000000000000000000000000000000000;;			doneResp: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.cv = sync.NewCond(&w.mu)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go w.readEvents()
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *Watcher) isClosed() bool {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-w.done:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close removes all watches and closes the events channel.
0000000000000000000000000000000000000000;;	func (w *Watcher) Close() error {
0000000000000000000000000000000000000000;;		if w.isClosed() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send 'close' signal to goroutine, and set the Watcher to closed.
0000000000000000000000000000000000000000;;		close(w.done)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wake up goroutine
0000000000000000000000000000000000000000;;		w.poller.wake()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for goroutine to close
0000000000000000000000000000000000000000;;		<-w.doneResp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add starts watching the named file or directory (non-recursively).
0000000000000000000000000000000000000000;;	func (w *Watcher) Add(name string) error {
0000000000000000000000000000000000000000;;		name = filepath.Clean(name)
0000000000000000000000000000000000000000;;		if w.isClosed() {
0000000000000000000000000000000000000000;;			return errors.New("inotify instance already closed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const agnosticEvents = unix.IN_MOVED_TO | unix.IN_MOVED_FROM |
0000000000000000000000000000000000000000;;			unix.IN_CREATE | unix.IN_ATTRIB | unix.IN_MODIFY |
0000000000000000000000000000000000000000;;			unix.IN_MOVE_SELF | unix.IN_DELETE | unix.IN_DELETE_SELF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var flags uint32 = agnosticEvents
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		watchEntry, found := w.watches[name]
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			watchEntry.flags |= flags
0000000000000000000000000000000000000000;;			flags |= unix.IN_MASK_ADD
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wd, errno := unix.InotifyAddWatch(w.fd, name, flags)
0000000000000000000000000000000000000000;;		if wd == -1 {
0000000000000000000000000000000000000000;;			return errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		w.watches[name] = &watch{wd: uint32(wd), flags: flags}
0000000000000000000000000000000000000000;;		w.paths[wd] = name
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove stops watching the named file or directory (non-recursively).
0000000000000000000000000000000000000000;;	func (w *Watcher) Remove(name string) error {
0000000000000000000000000000000000000000;;		name = filepath.Clean(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fetch the watch.
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		defer w.mu.Unlock()
0000000000000000000000000000000000000000;;		watch, ok := w.watches[name]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove it from inotify.
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't remove non-existent inotify watch for: %s", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// inotify_rm_watch will return EINVAL if the file has been deleted;
0000000000000000000000000000000000000000;;		// the inotify will already have been removed.
0000000000000000000000000000000000000000;;		// watches and pathes are deleted in ignoreLinux() implicitly and asynchronously
0000000000000000000000000000000000000000;;		// by calling inotify_rm_watch() below. e.g. readEvents() goroutine receives IN_IGNORE
0000000000000000000000000000000000000000;;		// so that EINVAL means that the wd is being rm_watch()ed or its file removed
0000000000000000000000000000000000000000;;		// by another thread and we have not received IN_IGNORE event.
0000000000000000000000000000000000000000;;		success, errno := unix.InotifyRmWatch(w.fd, watch.wd)
0000000000000000000000000000000000000000;;		if success == -1 {
0000000000000000000000000000000000000000;;			// TODO: Perhaps it's not helpful to return an error here in every case.
0000000000000000000000000000000000000000;;			// the only two possible errors are:
0000000000000000000000000000000000000000;;			// EBADF, which happens when w.fd is not a valid file descriptor of any kind.
0000000000000000000000000000000000000000;;			// EINVAL, which is when fd is not an inotify descriptor or wd is not a valid watch descriptor.
0000000000000000000000000000000000000000;;			// Watch descriptors are invalidated when they are removed explicitly or implicitly;
0000000000000000000000000000000000000000;;			// explicitly by inotify_rm_watch, implicitly when the file they are watching is deleted.
0000000000000000000000000000000000000000;;			return errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait until ignoreLinux() deleting maps
0000000000000000000000000000000000000000;;		exists := true
0000000000000000000000000000000000000000;;		for exists {
0000000000000000000000000000000000000000;;			w.cv.Wait()
0000000000000000000000000000000000000000;;			_, exists = w.watches[name]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watch struct {
0000000000000000000000000000000000000000;;		wd    uint32 // Watch descriptor (as returned by the inotify_add_watch() syscall)
0000000000000000000000000000000000000000;;		flags uint32 // inotify flags of this watch (see inotify(7) for the list of valid flags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readEvents reads from the inotify file descriptor, converts the
0000000000000000000000000000000000000000;;	// received events into Event objects and sends them via the Events channel
0000000000000000000000000000000000000000;;	func (w *Watcher) readEvents() {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			buf   [unix.SizeofInotifyEvent * 4096]byte // Buffer for a maximum of 4096 raw events
0000000000000000000000000000000000000000;;			n     int                                  // Number of bytes read with read()
0000000000000000000000000000000000000000;;			errno error                                // Syscall errno
0000000000000000000000000000000000000000;;			ok    bool                                 // For poller.wait
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer close(w.doneResp)
0000000000000000000000000000000000000000;;		defer close(w.Errors)
0000000000000000000000000000000000000000;;		defer close(w.Events)
0000000000000000000000000000000000000000;;		defer unix.Close(w.fd)
0000000000000000000000000000000000000000;;		defer w.poller.close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// See if we have been closed.
0000000000000000000000000000000000000000;;			if w.isClosed() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ok, errno = w.poller.wait()
0000000000000000000000000000000000000000;;			if errno != nil {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case w.Errors <- errno:
0000000000000000000000000000000000000000;;				case <-w.done:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n, errno = unix.Read(w.fd, buf[:])
0000000000000000000000000000000000000000;;			// If a signal interrupted execution, see if we've been asked to close, and try again.
0000000000000000000000000000000000000000;;			// http://man7.org/linux/man-pages/man7/signal.7.html :
0000000000000000000000000000000000000000;;			// "Before Linux 3.8, reads from an inotify(7) file descriptor were not restartable"
0000000000000000000000000000000000000000;;			if errno == unix.EINTR {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// unix.Read might have been woken up by Close. If so, we're done.
0000000000000000000000000000000000000000;;			if w.isClosed() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if n < unix.SizeofInotifyEvent {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				if n == 0 {
0000000000000000000000000000000000000000;;					// If EOF is received. This should really never happen.
0000000000000000000000000000000000000000;;					err = io.EOF
0000000000000000000000000000000000000000;;				} else if n < 0 {
0000000000000000000000000000000000000000;;					// If an error occurred while reading.
0000000000000000000000000000000000000000;;					err = errno
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Read was too short.
0000000000000000000000000000000000000000;;					err = errors.New("notify: short read in readEvents()")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case w.Errors <- err:
0000000000000000000000000000000000000000;;				case <-w.done:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var offset uint32
0000000000000000000000000000000000000000;;			// We don't know how many events we just read into the buffer
0000000000000000000000000000000000000000;;			// While the offset points to at least one whole event...
0000000000000000000000000000000000000000;;			for offset <= uint32(n-unix.SizeofInotifyEvent) {
0000000000000000000000000000000000000000;;				// Point "raw" to the event in the buffer
0000000000000000000000000000000000000000;;				raw := (*unix.InotifyEvent)(unsafe.Pointer(&buf[offset]))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				mask := uint32(raw.Mask)
0000000000000000000000000000000000000000;;				nameLen := uint32(raw.Len)
0000000000000000000000000000000000000000;;				// If the event happened to the watched directory or the watched file, the kernel
0000000000000000000000000000000000000000;;				// doesn't append the filename to the event, but we would like to always fill the
0000000000000000000000000000000000000000;;				// the "Name" field with a valid filename. We retrieve the path of the watch from
0000000000000000000000000000000000000000;;				// the "paths" map.
0000000000000000000000000000000000000000;;				w.mu.Lock()
0000000000000000000000000000000000000000;;				name := w.paths[int(raw.Wd)]
0000000000000000000000000000000000000000;;				w.mu.Unlock()
0000000000000000000000000000000000000000;;				if nameLen > 0 {
0000000000000000000000000000000000000000;;					// Point "bytes" at the first byte of the filename
0000000000000000000000000000000000000000;;					bytes := (*[unix.PathMax]byte)(unsafe.Pointer(&buf[offset+unix.SizeofInotifyEvent]))
0000000000000000000000000000000000000000;;					// The filename is padded with NULL bytes. TrimRight() gets rid of those.
0000000000000000000000000000000000000000;;					name += "/" + strings.TrimRight(string(bytes[0:nameLen]), "\000")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				event := newEvent(name, mask)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Send the events that are not ignored on the events channel
0000000000000000000000000000000000000000;;				if !event.ignoreLinux(w, raw.Wd, mask) {
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case w.Events <- event:
0000000000000000000000000000000000000000;;					case <-w.done:
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Move to the next event in the buffer
0000000000000000000000000000000000000000;;				offset += unix.SizeofInotifyEvent + nameLen
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Certain types of events can be "ignored" and not sent over the Events
0000000000000000000000000000000000000000;;	// channel. Such as events marked ignore by the kernel, or MODIFY events
0000000000000000000000000000000000000000;;	// against files that do not exist.
0000000000000000000000000000000000000000;;	func (e *Event) ignoreLinux(w *Watcher, wd int32, mask uint32) bool {
0000000000000000000000000000000000000000;;		// Ignore anything the inotify API says to ignore
0000000000000000000000000000000000000000;;		if mask&unix.IN_IGNORED == unix.IN_IGNORED {
0000000000000000000000000000000000000000;;			w.mu.Lock()
0000000000000000000000000000000000000000;;			defer w.mu.Unlock()
0000000000000000000000000000000000000000;;			name := w.paths[int(wd)]
0000000000000000000000000000000000000000;;			delete(w.paths, int(wd))
0000000000000000000000000000000000000000;;			delete(w.watches, name)
0000000000000000000000000000000000000000;;			w.cv.Broadcast()
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the event is not a DELETE or RENAME, the file must exist.
0000000000000000000000000000000000000000;;		// Otherwise the event is ignored.
0000000000000000000000000000000000000000;;		// *Note*: this was put in place because it was seen that a MODIFY
0000000000000000000000000000000000000000;;		// event was sent after the DELETE. This ignores that MODIFY and
0000000000000000000000000000000000000000;;		// assumes a DELETE will come or has come if the file doesn't exist.
0000000000000000000000000000000000000000;;		if !(e.Op&Remove == Remove || e.Op&Rename == Rename) {
0000000000000000000000000000000000000000;;			_, statErr := os.Lstat(e.Name)
0000000000000000000000000000000000000000;;			return os.IsNotExist(statErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newEvent returns an platform-independent Event based on an inotify mask.
0000000000000000000000000000000000000000;;	func newEvent(name string, mask uint32) Event {
0000000000000000000000000000000000000000;;		e := Event{Name: name}
0000000000000000000000000000000000000000;;		if mask&unix.IN_CREATE == unix.IN_CREATE || mask&unix.IN_MOVED_TO == unix.IN_MOVED_TO {
0000000000000000000000000000000000000000;;			e.Op |= Create
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&unix.IN_DELETE_SELF == unix.IN_DELETE_SELF || mask&unix.IN_DELETE == unix.IN_DELETE {
0000000000000000000000000000000000000000;;			e.Op |= Remove
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&unix.IN_MODIFY == unix.IN_MODIFY {
0000000000000000000000000000000000000000;;			e.Op |= Write
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&unix.IN_MOVE_SELF == unix.IN_MOVE_SELF || mask&unix.IN_MOVED_FROM == unix.IN_MOVED_FROM {
0000000000000000000000000000000000000000;;			e.Op |= Rename
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&unix.IN_ATTRIB == unix.IN_ATTRIB {
0000000000000000000000000000000000000000;;			e.Op |= Chmod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
