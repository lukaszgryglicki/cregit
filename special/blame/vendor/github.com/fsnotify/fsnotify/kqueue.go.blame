0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	// +build freebsd openbsd netbsd dragonfly darwin
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fsnotify
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/sys/unix"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watcher watches a set of files, delivering events to a channel.
0000000000000000000000000000000000000000;;	type Watcher struct {
0000000000000000000000000000000000000000;;		Events chan Event
0000000000000000000000000000000000000000;;		Errors chan error
0000000000000000000000000000000000000000;;		done   chan bool // Channel for sending a "quit message" to the reader goroutine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kq int // File descriptor (as returned by the kqueue() syscall).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu              sync.Mutex        // Protects access to watcher data
0000000000000000000000000000000000000000;;		watches         map[string]int    // Map of watched file descriptors (key: path).
0000000000000000000000000000000000000000;;		externalWatches map[string]bool   // Map of watches added by user of the library.
0000000000000000000000000000000000000000;;		dirFlags        map[string]uint32 // Map of watched directories to fflags used in kqueue.
0000000000000000000000000000000000000000;;		paths           map[int]pathInfo  // Map file descriptors to path names for processing kqueue events.
0000000000000000000000000000000000000000;;		fileExists      map[string]bool   // Keep track of if we know this file exists (to stop duplicate create events).
0000000000000000000000000000000000000000;;		isClosed        bool              // Set to true when Close() is first called
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pathInfo struct {
0000000000000000000000000000000000000000;;		name  string
0000000000000000000000000000000000000000;;		isDir bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.
0000000000000000000000000000000000000000;;	func NewWatcher() (*Watcher, error) {
0000000000000000000000000000000000000000;;		kq, err := kqueue()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := &Watcher{
0000000000000000000000000000000000000000;;			kq:              kq,
0000000000000000000000000000000000000000;;			watches:         make(map[string]int),
0000000000000000000000000000000000000000;;			dirFlags:        make(map[string]uint32),
0000000000000000000000000000000000000000;;			paths:           make(map[int]pathInfo),
0000000000000000000000000000000000000000;;			fileExists:      make(map[string]bool),
0000000000000000000000000000000000000000;;			externalWatches: make(map[string]bool),
0000000000000000000000000000000000000000;;			Events:          make(chan Event),
0000000000000000000000000000000000000000;;			Errors:          make(chan error),
0000000000000000000000000000000000000000;;			done:            make(chan bool),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go w.readEvents()
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close removes all watches and closes the events channel.
0000000000000000000000000000000000000000;;	func (w *Watcher) Close() error {
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		if w.isClosed {
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.isClosed = true
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// copy paths to remove while locked
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		var pathsToRemove = make([]string, 0, len(w.watches))
0000000000000000000000000000000000000000;;		for name := range w.watches {
0000000000000000000000000000000000000000;;			pathsToRemove = append(pathsToRemove, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;		// unlock before calling Remove, which also locks
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for _, name := range pathsToRemove {
0000000000000000000000000000000000000000;;			if e := w.Remove(name); e != nil && err == nil {
0000000000000000000000000000000000000000;;				err = e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send "quit" message to the reader goroutine:
0000000000000000000000000000000000000000;;		w.done <- true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add starts watching the named file or directory (non-recursively).
0000000000000000000000000000000000000000;;	func (w *Watcher) Add(name string) error {
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		w.externalWatches[name] = true
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;		_, err := w.addWatch(name, noteAllEvents)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove stops watching the the named file or directory (non-recursively).
0000000000000000000000000000000000000000;;	func (w *Watcher) Remove(name string) error {
0000000000000000000000000000000000000000;;		name = filepath.Clean(name)
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		watchfd, ok := w.watches[name]
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't remove non-existent kevent watch for: %s", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const registerRemove = unix.EV_DELETE
0000000000000000000000000000000000000000;;		if err := register(w.kq, []int{watchfd}, registerRemove, 0); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unix.Close(watchfd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		isDir := w.paths[watchfd].isDir
0000000000000000000000000000000000000000;;		delete(w.watches, name)
0000000000000000000000000000000000000000;;		delete(w.paths, watchfd)
0000000000000000000000000000000000000000;;		delete(w.dirFlags, name)
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find all watched paths that are in this directory that are not external.
0000000000000000000000000000000000000000;;		if isDir {
0000000000000000000000000000000000000000;;			var pathsToRemove []string
0000000000000000000000000000000000000000;;			w.mu.Lock()
0000000000000000000000000000000000000000;;			for _, path := range w.paths {
0000000000000000000000000000000000000000;;				wdir, _ := filepath.Split(path.name)
0000000000000000000000000000000000000000;;				if filepath.Clean(wdir) == name {
0000000000000000000000000000000000000000;;					if !w.externalWatches[path.name] {
0000000000000000000000000000000000000000;;						pathsToRemove = append(pathsToRemove, path.name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;			for _, name := range pathsToRemove {
0000000000000000000000000000000000000000;;				// Since these are internal, not much sense in propagating error
0000000000000000000000000000000000000000;;				// to the user, as that will just confuse them with an error about
0000000000000000000000000000000000000000;;				// a path they did not explicitly watch themselves.
0000000000000000000000000000000000000000;;				w.Remove(name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch all events (except NOTE_EXTEND, NOTE_LINK, NOTE_REVOKE)
0000000000000000000000000000000000000000;;	const noteAllEvents = unix.NOTE_DELETE | unix.NOTE_WRITE | unix.NOTE_ATTRIB | unix.NOTE_RENAME
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keventWaitTime to block on each read from kevent
0000000000000000000000000000000000000000;;	var keventWaitTime = durationToTimespec(100 * time.Millisecond)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addWatch adds name to the watched file set.
0000000000000000000000000000000000000000;;	// The flags are interpreted as described in kevent(2).
0000000000000000000000000000000000000000;;	// Returns the real path to the file which was added, if any, which may be different from the one passed in the case of symlinks.
0000000000000000000000000000000000000000;;	func (w *Watcher) addWatch(name string, flags uint32) (string, error) {
0000000000000000000000000000000000000000;;		var isDir bool
0000000000000000000000000000000000000000;;		// Make ./name and name equivalent
0000000000000000000000000000000000000000;;		name = filepath.Clean(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		if w.isClosed {
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;			return "", errors.New("kevent instance already closed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		watchfd, alreadyWatching := w.watches[name]
0000000000000000000000000000000000000000;;		// We already have a watch, but we can still override flags.
0000000000000000000000000000000000000000;;		if alreadyWatching {
0000000000000000000000000000000000000000;;			isDir = w.paths[watchfd].isDir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !alreadyWatching {
0000000000000000000000000000000000000000;;			fi, err := os.Lstat(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Don't watch sockets.
0000000000000000000000000000000000000000;;			if fi.Mode()&os.ModeSocket == os.ModeSocket {
0000000000000000000000000000000000000000;;				return "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Don't watch named pipes.
0000000000000000000000000000000000000000;;			if fi.Mode()&os.ModeNamedPipe == os.ModeNamedPipe {
0000000000000000000000000000000000000000;;				return "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Follow Symlinks
0000000000000000000000000000000000000000;;			// Unfortunately, Linux can add bogus symlinks to watch list without
0000000000000000000000000000000000000000;;			// issue, and Windows can't do symlinks period (AFAIK). To  maintain
0000000000000000000000000000000000000000;;			// consistency, we will act like everything is fine. There will simply
0000000000000000000000000000000000000000;;			// be no file events for broken symlinks.
0000000000000000000000000000000000000000;;			// Hence the returns of nil on errors.
0000000000000000000000000000000000000000;;			if fi.Mode()&os.ModeSymlink == os.ModeSymlink {
0000000000000000000000000000000000000000;;				name, err = filepath.EvalSymlinks(name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				w.mu.Lock()
0000000000000000000000000000000000000000;;				_, alreadyWatching = w.watches[name]
0000000000000000000000000000000000000000;;				w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if alreadyWatching {
0000000000000000000000000000000000000000;;					return name, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				fi, err = os.Lstat(name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return "", nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			watchfd, err = unix.Open(name, openMode, 0700)
0000000000000000000000000000000000000000;;			if watchfd == -1 {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isDir = fi.IsDir()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const registerAdd = unix.EV_ADD | unix.EV_CLEAR | unix.EV_ENABLE
0000000000000000000000000000000000000000;;		if err := register(w.kq, []int{watchfd}, registerAdd, flags); err != nil {
0000000000000000000000000000000000000000;;			unix.Close(watchfd)
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !alreadyWatching {
0000000000000000000000000000000000000000;;			w.mu.Lock()
0000000000000000000000000000000000000000;;			w.watches[name] = watchfd
0000000000000000000000000000000000000000;;			w.paths[watchfd] = pathInfo{name: name, isDir: isDir}
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isDir {
0000000000000000000000000000000000000000;;			// Watch the directory if it has not been watched before,
0000000000000000000000000000000000000000;;			// or if it was watched before, but perhaps only a NOTE_DELETE (watchDirectoryFiles)
0000000000000000000000000000000000000000;;			w.mu.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			watchDir := (flags&unix.NOTE_WRITE) == unix.NOTE_WRITE &&
0000000000000000000000000000000000000000;;				(!alreadyWatching || (w.dirFlags[name]&unix.NOTE_WRITE) != unix.NOTE_WRITE)
0000000000000000000000000000000000000000;;			// Store flags so this watch can be updated later
0000000000000000000000000000000000000000;;			w.dirFlags[name] = flags
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if watchDir {
0000000000000000000000000000000000000000;;				if err := w.watchDirectoryFiles(name); err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readEvents reads from kqueue and converts the received kevents into
0000000000000000000000000000000000000000;;	// Event values that it sends down the Events channel.
0000000000000000000000000000000000000000;;	func (w *Watcher) readEvents() {
0000000000000000000000000000000000000000;;		eventBuffer := make([]unix.Kevent_t, 10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// See if there is a message on the "done" channel
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-w.done:
0000000000000000000000000000000000000000;;				err := unix.Close(w.kq)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					w.Errors <- err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				close(w.Events)
0000000000000000000000000000000000000000;;				close(w.Errors)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get new events
0000000000000000000000000000000000000000;;			kevents, err := read(w.kq, eventBuffer, &keventWaitTime)
0000000000000000000000000000000000000000;;			// EINTR is okay, the syscall was interrupted before timeout expired.
0000000000000000000000000000000000000000;;			if err != nil && err != unix.EINTR {
0000000000000000000000000000000000000000;;				w.Errors <- err
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Flush the events we received to the Events channel
0000000000000000000000000000000000000000;;			for len(kevents) > 0 {
0000000000000000000000000000000000000000;;				kevent := &kevents[0]
0000000000000000000000000000000000000000;;				watchfd := int(kevent.Ident)
0000000000000000000000000000000000000000;;				mask := uint32(kevent.Fflags)
0000000000000000000000000000000000000000;;				w.mu.Lock()
0000000000000000000000000000000000000000;;				path := w.paths[watchfd]
0000000000000000000000000000000000000000;;				w.mu.Unlock()
0000000000000000000000000000000000000000;;				event := newEvent(path.name, mask)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if path.isDir && !(event.Op&Remove == Remove) {
0000000000000000000000000000000000000000;;					// Double check to make sure the directory exists. This can happen when
0000000000000000000000000000000000000000;;					// we do a rm -fr on a recursively watched folders and we receive a
0000000000000000000000000000000000000000;;					// modification event first but the folder has been deleted and later
0000000000000000000000000000000000000000;;					// receive the delete event
0000000000000000000000000000000000000000;;					if _, err := os.Lstat(event.Name); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;						// mark is as delete event
0000000000000000000000000000000000000000;;						event.Op |= Remove
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if event.Op&Rename == Rename || event.Op&Remove == Remove {
0000000000000000000000000000000000000000;;					w.Remove(event.Name)
0000000000000000000000000000000000000000;;					w.mu.Lock()
0000000000000000000000000000000000000000;;					delete(w.fileExists, event.Name)
0000000000000000000000000000000000000000;;					w.mu.Unlock()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if path.isDir && event.Op&Write == Write && !(event.Op&Remove == Remove) {
0000000000000000000000000000000000000000;;					w.sendDirectoryChangeEvents(event.Name)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Send the event on the Events channel
0000000000000000000000000000000000000000;;					w.Events <- event
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if event.Op&Remove == Remove {
0000000000000000000000000000000000000000;;					// Look for a file that may have overwritten this.
0000000000000000000000000000000000000000;;					// For example, mv f1 f2 will delete f2, then create f2.
0000000000000000000000000000000000000000;;					if path.isDir {
0000000000000000000000000000000000000000;;						fileDir := filepath.Clean(event.Name)
0000000000000000000000000000000000000000;;						w.mu.Lock()
0000000000000000000000000000000000000000;;						_, found := w.watches[fileDir]
0000000000000000000000000000000000000000;;						w.mu.Unlock()
0000000000000000000000000000000000000000;;						if found {
0000000000000000000000000000000000000000;;							// make sure the directory exists before we watch for changes. When we
0000000000000000000000000000000000000000;;							// do a recursive watch and perform rm -fr, the parent directory might
0000000000000000000000000000000000000000;;							// have gone missing, ignore the missing directory and let the
0000000000000000000000000000000000000000;;							// upcoming delete event remove the watch from the parent directory.
0000000000000000000000000000000000000000;;							if _, err := os.Lstat(fileDir); err == nil {
0000000000000000000000000000000000000000;;								w.sendDirectoryChangeEvents(fileDir)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						filePath := filepath.Clean(event.Name)
0000000000000000000000000000000000000000;;						if fileInfo, err := os.Lstat(filePath); err == nil {
0000000000000000000000000000000000000000;;							w.sendFileCreatedEventIfNew(filePath, fileInfo)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Move to next event
0000000000000000000000000000000000000000;;				kevents = kevents[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newEvent returns an platform-independent Event based on kqueue Fflags.
0000000000000000000000000000000000000000;;	func newEvent(name string, mask uint32) Event {
0000000000000000000000000000000000000000;;		e := Event{Name: name}
0000000000000000000000000000000000000000;;		if mask&unix.NOTE_DELETE == unix.NOTE_DELETE {
0000000000000000000000000000000000000000;;			e.Op |= Remove
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&unix.NOTE_WRITE == unix.NOTE_WRITE {
0000000000000000000000000000000000000000;;			e.Op |= Write
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&unix.NOTE_RENAME == unix.NOTE_RENAME {
0000000000000000000000000000000000000000;;			e.Op |= Rename
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&unix.NOTE_ATTRIB == unix.NOTE_ATTRIB {
0000000000000000000000000000000000000000;;			e.Op |= Chmod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCreateEvent(name string) Event {
0000000000000000000000000000000000000000;;		return Event{Name: name, Op: Create}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchDirectoryFiles to mimic inotify when adding a watch on a directory
0000000000000000000000000000000000000000;;	func (w *Watcher) watchDirectoryFiles(dirPath string) error {
0000000000000000000000000000000000000000;;		// Get all files
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(dirPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, fileInfo := range files {
0000000000000000000000000000000000000000;;			filePath := filepath.Join(dirPath, fileInfo.Name())
0000000000000000000000000000000000000000;;			filePath, err = w.internalWatch(filePath, fileInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.mu.Lock()
0000000000000000000000000000000000000000;;			w.fileExists[filePath] = true
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendDirectoryEvents searches the directory for newly created files
0000000000000000000000000000000000000000;;	// and sends them over the event channel. This functionality is to have
0000000000000000000000000000000000000000;;	// the BSD version of fsnotify match Linux inotify which provides a
0000000000000000000000000000000000000000;;	// create event for files created in a watched directory.
0000000000000000000000000000000000000000;;	func (w *Watcher) sendDirectoryChangeEvents(dirPath string) {
0000000000000000000000000000000000000000;;		// Get all files
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(dirPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			w.Errors <- err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Search for new files
0000000000000000000000000000000000000000;;		for _, fileInfo := range files {
0000000000000000000000000000000000000000;;			filePath := filepath.Join(dirPath, fileInfo.Name())
0000000000000000000000000000000000000000;;			err := w.sendFileCreatedEventIfNew(filePath, fileInfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendFileCreatedEvent sends a create event if the file isn't already being tracked.
0000000000000000000000000000000000000000;;	func (w *Watcher) sendFileCreatedEventIfNew(filePath string, fileInfo os.FileInfo) (err error) {
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		_, doesExist := w.fileExists[filePath]
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;		if !doesExist {
0000000000000000000000000000000000000000;;			// Send create event
0000000000000000000000000000000000000000;;			w.Events <- newCreateEvent(filePath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// like watchDirectoryFiles (but without doing another ReadDir)
0000000000000000000000000000000000000000;;		filePath, err = w.internalWatch(filePath, fileInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		w.fileExists[filePath] = true
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *Watcher) internalWatch(name string, fileInfo os.FileInfo) (string, error) {
0000000000000000000000000000000000000000;;		if fileInfo.IsDir() {
0000000000000000000000000000000000000000;;			// mimic Linux providing delete events for subdirectories
0000000000000000000000000000000000000000;;			// but preserve the flags used if currently watching subdirectory
0000000000000000000000000000000000000000;;			w.mu.Lock()
0000000000000000000000000000000000000000;;			flags := w.dirFlags[name]
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			flags |= unix.NOTE_DELETE | unix.NOTE_RENAME
0000000000000000000000000000000000000000;;			return w.addWatch(name, flags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// watch file to mimic Linux inotify
0000000000000000000000000000000000000000;;		return w.addWatch(name, noteAllEvents)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kqueue creates a new kernel event queue and returns a descriptor.
0000000000000000000000000000000000000000;;	func kqueue() (kq int, err error) {
0000000000000000000000000000000000000000;;		kq, err = unix.Kqueue()
0000000000000000000000000000000000000000;;		if kq == -1 {
0000000000000000000000000000000000000000;;			return kq, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kq, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// register events with the queue
0000000000000000000000000000000000000000;;	func register(kq int, fds []int, flags int, fflags uint32) error {
0000000000000000000000000000000000000000;;		changes := make([]unix.Kevent_t, len(fds))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, fd := range fds {
0000000000000000000000000000000000000000;;			// SetKevent converts int to the platform-specific types:
0000000000000000000000000000000000000000;;			unix.SetKevent(&changes[i], fd, unix.EVFILT_VNODE, flags)
0000000000000000000000000000000000000000;;			changes[i].Fflags = fflags
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// register the events
0000000000000000000000000000000000000000;;		success, err := unix.Kevent(kq, changes, nil, nil)
0000000000000000000000000000000000000000;;		if success == -1 {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// read retrieves pending events, or waits until an event occurs.
0000000000000000000000000000000000000000;;	// A timeout of nil blocks indefinitely, while 0 polls the queue.
0000000000000000000000000000000000000000;;	func read(kq int, events []unix.Kevent_t, timeout *unix.Timespec) ([]unix.Kevent_t, error) {
0000000000000000000000000000000000000000;;		n, err := unix.Kevent(kq, nil, events, timeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return events[0:n], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// durationToTimespec prepares a timeout value
0000000000000000000000000000000000000000;;	func durationToTimespec(d time.Duration) unix.Timespec {
0000000000000000000000000000000000000000;;		return unix.NsecToTimespec(d.Nanoseconds())
0000000000000000000000000000000000000000;;	}
