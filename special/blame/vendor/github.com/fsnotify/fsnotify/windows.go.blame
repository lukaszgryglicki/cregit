0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	// +build windows
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fsnotify
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watcher watches a set of files, delivering events to a channel.
0000000000000000000000000000000000000000;;	type Watcher struct {
0000000000000000000000000000000000000000;;		Events   chan Event
0000000000000000000000000000000000000000;;		Errors   chan error
0000000000000000000000000000000000000000;;		isClosed bool           // Set to true when Close() is first called
0000000000000000000000000000000000000000;;		mu       sync.Mutex     // Map access
0000000000000000000000000000000000000000;;		port     syscall.Handle // Handle to completion port
0000000000000000000000000000000000000000;;		watches  watchMap       // Map of watches (key: i-number)
0000000000000000000000000000000000000000;;		input    chan *input    // Inputs to the reader are sent on this channel
0000000000000000000000000000000000000000;;		quit     chan chan<- error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWatcher establishes a new watcher with the underlying OS and begins waiting for events.
0000000000000000000000000000000000000000;;	func NewWatcher() (*Watcher, error) {
0000000000000000000000000000000000000000;;		port, e := syscall.CreateIoCompletionPort(syscall.InvalidHandle, 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, os.NewSyscallError("CreateIoCompletionPort", e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w := &Watcher{
0000000000000000000000000000000000000000;;			port:    port,
0000000000000000000000000000000000000000;;			watches: make(watchMap),
0000000000000000000000000000000000000000;;			input:   make(chan *input, 1),
0000000000000000000000000000000000000000;;			Events:  make(chan Event, 50),
0000000000000000000000000000000000000000;;			Errors:  make(chan error),
0000000000000000000000000000000000000000;;			quit:    make(chan chan<- error, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go w.readEvents()
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close removes all watches and closes the events channel.
0000000000000000000000000000000000000000;;	func (w *Watcher) Close() error {
0000000000000000000000000000000000000000;;		if w.isClosed {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.isClosed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send "quit" message to the reader goroutine
0000000000000000000000000000000000000000;;		ch := make(chan error)
0000000000000000000000000000000000000000;;		w.quit <- ch
0000000000000000000000000000000000000000;;		if err := w.wakeupReader(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return <-ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add starts watching the named file or directory (non-recursively).
0000000000000000000000000000000000000000;;	func (w *Watcher) Add(name string) error {
0000000000000000000000000000000000000000;;		if w.isClosed {
0000000000000000000000000000000000000000;;			return errors.New("watcher already closed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		in := &input{
0000000000000000000000000000000000000000;;			op:    opAddWatch,
0000000000000000000000000000000000000000;;			path:  filepath.Clean(name),
0000000000000000000000000000000000000000;;			flags: sysFSALLEVENTS,
0000000000000000000000000000000000000000;;			reply: make(chan error),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.input <- in
0000000000000000000000000000000000000000;;		if err := w.wakeupReader(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return <-in.reply
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove stops watching the the named file or directory (non-recursively).
0000000000000000000000000000000000000000;;	func (w *Watcher) Remove(name string) error {
0000000000000000000000000000000000000000;;		in := &input{
0000000000000000000000000000000000000000;;			op:    opRemoveWatch,
0000000000000000000000000000000000000000;;			path:  filepath.Clean(name),
0000000000000000000000000000000000000000;;			reply: make(chan error),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.input <- in
0000000000000000000000000000000000000000;;		if err := w.wakeupReader(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return <-in.reply
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Options for AddWatch
0000000000000000000000000000000000000000;;		sysFSONESHOT = 0x80000000
0000000000000000000000000000000000000000;;		sysFSONLYDIR = 0x1000000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Events
0000000000000000000000000000000000000000;;		sysFSACCESS     = 0x1
0000000000000000000000000000000000000000;;		sysFSALLEVENTS  = 0xfff
0000000000000000000000000000000000000000;;		sysFSATTRIB     = 0x4
0000000000000000000000000000000000000000;;		sysFSCLOSE      = 0x18
0000000000000000000000000000000000000000;;		sysFSCREATE     = 0x100
0000000000000000000000000000000000000000;;		sysFSDELETE     = 0x200
0000000000000000000000000000000000000000;;		sysFSDELETESELF = 0x400
0000000000000000000000000000000000000000;;		sysFSMODIFY     = 0x2
0000000000000000000000000000000000000000;;		sysFSMOVE       = 0xc0
0000000000000000000000000000000000000000;;		sysFSMOVEDFROM  = 0x40
0000000000000000000000000000000000000000;;		sysFSMOVEDTO    = 0x80
0000000000000000000000000000000000000000;;		sysFSMOVESELF   = 0x800
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Special events
0000000000000000000000000000000000000000;;		sysFSIGNORED   = 0x8000
0000000000000000000000000000000000000000;;		sysFSQOVERFLOW = 0x4000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEvent(name string, mask uint32) Event {
0000000000000000000000000000000000000000;;		e := Event{Name: name}
0000000000000000000000000000000000000000;;		if mask&sysFSCREATE == sysFSCREATE || mask&sysFSMOVEDTO == sysFSMOVEDTO {
0000000000000000000000000000000000000000;;			e.Op |= Create
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&sysFSDELETE == sysFSDELETE || mask&sysFSDELETESELF == sysFSDELETESELF {
0000000000000000000000000000000000000000;;			e.Op |= Remove
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&sysFSMODIFY == sysFSMODIFY {
0000000000000000000000000000000000000000;;			e.Op |= Write
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&sysFSMOVE == sysFSMOVE || mask&sysFSMOVESELF == sysFSMOVESELF || mask&sysFSMOVEDFROM == sysFSMOVEDFROM {
0000000000000000000000000000000000000000;;			e.Op |= Rename
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&sysFSATTRIB == sysFSATTRIB {
0000000000000000000000000000000000000000;;			e.Op |= Chmod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		opAddWatch = iota
0000000000000000000000000000000000000000;;		opRemoveWatch
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		provisional uint64 = 1 << (32 + iota)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type input struct {
0000000000000000000000000000000000000000;;		op    int
0000000000000000000000000000000000000000;;		path  string
0000000000000000000000000000000000000000;;		flags uint32
0000000000000000000000000000000000000000;;		reply chan error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type inode struct {
0000000000000000000000000000000000000000;;		handle syscall.Handle
0000000000000000000000000000000000000000;;		volume uint32
0000000000000000000000000000000000000000;;		index  uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watch struct {
0000000000000000000000000000000000000000;;		ov     syscall.Overlapped
0000000000000000000000000000000000000000;;		ino    *inode            // i-number
0000000000000000000000000000000000000000;;		path   string            // Directory path
0000000000000000000000000000000000000000;;		mask   uint64            // Directory itself is being watched with these notify flags
0000000000000000000000000000000000000000;;		names  map[string]uint64 // Map of names being watched and their notify flags
0000000000000000000000000000000000000000;;		rename string            // Remembers the old name while renaming a file
0000000000000000000000000000000000000000;;		buf    [4096]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type indexMap map[uint64]*watch
0000000000000000000000000000000000000000;;	type watchMap map[uint32]indexMap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *Watcher) wakeupReader() error {
0000000000000000000000000000000000000000;;		e := syscall.PostQueuedCompletionStatus(w.port, 0, 0, nil)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return os.NewSyscallError("PostQueuedCompletionStatus", e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDir(pathname string) (dir string, err error) {
0000000000000000000000000000000000000000;;		attr, e := syscall.GetFileAttributes(syscall.StringToUTF16Ptr(pathname))
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return "", os.NewSyscallError("GetFileAttributes", e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if attr&syscall.FILE_ATTRIBUTE_DIRECTORY != 0 {
0000000000000000000000000000000000000000;;			dir = pathname
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dir, _ = filepath.Split(pathname)
0000000000000000000000000000000000000000;;			dir = filepath.Clean(dir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getIno(path string) (ino *inode, err error) {
0000000000000000000000000000000000000000;;		h, e := syscall.CreateFile(syscall.StringToUTF16Ptr(path),
0000000000000000000000000000000000000000;;			syscall.FILE_LIST_DIRECTORY,
0000000000000000000000000000000000000000;;			syscall.FILE_SHARE_READ|syscall.FILE_SHARE_WRITE|syscall.FILE_SHARE_DELETE,
0000000000000000000000000000000000000000;;			nil, syscall.OPEN_EXISTING,
0000000000000000000000000000000000000000;;			syscall.FILE_FLAG_BACKUP_SEMANTICS|syscall.FILE_FLAG_OVERLAPPED, 0)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, os.NewSyscallError("CreateFile", e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var fi syscall.ByHandleFileInformation
0000000000000000000000000000000000000000;;		if e = syscall.GetFileInformationByHandle(h, &fi); e != nil {
0000000000000000000000000000000000000000;;			syscall.CloseHandle(h)
0000000000000000000000000000000000000000;;			return nil, os.NewSyscallError("GetFileInformationByHandle", e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ino = &inode{
0000000000000000000000000000000000000000;;			handle: h,
0000000000000000000000000000000000000000;;			volume: fi.VolumeSerialNumber,
0000000000000000000000000000000000000000;;			index:  uint64(fi.FileIndexHigh)<<32 | uint64(fi.FileIndexLow),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ino, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Must run within the I/O thread.
0000000000000000000000000000000000000000;;	func (m watchMap) get(ino *inode) *watch {
0000000000000000000000000000000000000000;;		if i := m[ino.volume]; i != nil {
0000000000000000000000000000000000000000;;			return i[ino.index]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Must run within the I/O thread.
0000000000000000000000000000000000000000;;	func (m watchMap) set(ino *inode, watch *watch) {
0000000000000000000000000000000000000000;;		i := m[ino.volume]
0000000000000000000000000000000000000000;;		if i == nil {
0000000000000000000000000000000000000000;;			i = make(indexMap)
0000000000000000000000000000000000000000;;			m[ino.volume] = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i[ino.index] = watch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Must run within the I/O thread.
0000000000000000000000000000000000000000;;	func (w *Watcher) addWatch(pathname string, flags uint64) error {
0000000000000000000000000000000000000000;;		dir, err := getDir(pathname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if flags&sysFSONLYDIR != 0 && pathname != dir {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ino, err := getIno(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		watchEntry := w.watches.get(ino)
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;		if watchEntry == nil {
0000000000000000000000000000000000000000;;			if _, e := syscall.CreateIoCompletionPort(ino.handle, w.port, 0, 0); e != nil {
0000000000000000000000000000000000000000;;				syscall.CloseHandle(ino.handle)
0000000000000000000000000000000000000000;;				return os.NewSyscallError("CreateIoCompletionPort", e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			watchEntry = &watch{
0000000000000000000000000000000000000000;;				ino:   ino,
0000000000000000000000000000000000000000;;				path:  dir,
0000000000000000000000000000000000000000;;				names: make(map[string]uint64),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.mu.Lock()
0000000000000000000000000000000000000000;;			w.watches.set(ino, watchEntry)
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;			flags |= provisional
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			syscall.CloseHandle(ino.handle)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pathname == dir {
0000000000000000000000000000000000000000;;			watchEntry.mask |= flags
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			watchEntry.names[filepath.Base(pathname)] |= flags
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = w.startRead(watchEntry); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pathname == dir {
0000000000000000000000000000000000000000;;			watchEntry.mask &= ^provisional
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			watchEntry.names[filepath.Base(pathname)] &= ^provisional
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Must run within the I/O thread.
0000000000000000000000000000000000000000;;	func (w *Watcher) remWatch(pathname string) error {
0000000000000000000000000000000000000000;;		dir, err := getDir(pathname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ino, err := getIno(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		watch := w.watches.get(ino)
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;		if watch == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't remove non-existent watch for: %s", pathname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pathname == dir {
0000000000000000000000000000000000000000;;			w.sendEvent(watch.path, watch.mask&sysFSIGNORED)
0000000000000000000000000000000000000000;;			watch.mask = 0
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			name := filepath.Base(pathname)
0000000000000000000000000000000000000000;;			w.sendEvent(filepath.Join(watch.path, name), watch.names[name]&sysFSIGNORED)
0000000000000000000000000000000000000000;;			delete(watch.names, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.startRead(watch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Must run within the I/O thread.
0000000000000000000000000000000000000000;;	func (w *Watcher) deleteWatch(watch *watch) {
0000000000000000000000000000000000000000;;		for name, mask := range watch.names {
0000000000000000000000000000000000000000;;			if mask&provisional == 0 {
0000000000000000000000000000000000000000;;				w.sendEvent(filepath.Join(watch.path, name), mask&sysFSIGNORED)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(watch.names, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if watch.mask != 0 {
0000000000000000000000000000000000000000;;			if watch.mask&provisional == 0 {
0000000000000000000000000000000000000000;;				w.sendEvent(watch.path, watch.mask&sysFSIGNORED)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			watch.mask = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Must run within the I/O thread.
0000000000000000000000000000000000000000;;	func (w *Watcher) startRead(watch *watch) error {
0000000000000000000000000000000000000000;;		if e := syscall.CancelIo(watch.ino.handle); e != nil {
0000000000000000000000000000000000000000;;			w.Errors <- os.NewSyscallError("CancelIo", e)
0000000000000000000000000000000000000000;;			w.deleteWatch(watch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mask := toWindowsFlags(watch.mask)
0000000000000000000000000000000000000000;;		for _, m := range watch.names {
0000000000000000000000000000000000000000;;			mask |= toWindowsFlags(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask == 0 {
0000000000000000000000000000000000000000;;			if e := syscall.CloseHandle(watch.ino.handle); e != nil {
0000000000000000000000000000000000000000;;				w.Errors <- os.NewSyscallError("CloseHandle", e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.mu.Lock()
0000000000000000000000000000000000000000;;			delete(w.watches[watch.ino.volume], watch.ino.index)
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e := syscall.ReadDirectoryChanges(watch.ino.handle, &watch.buf[0],
0000000000000000000000000000000000000000;;			uint32(unsafe.Sizeof(watch.buf)), false, mask, nil, &watch.ov, 0)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			err := os.NewSyscallError("ReadDirectoryChanges", e)
0000000000000000000000000000000000000000;;			if e == syscall.ERROR_ACCESS_DENIED && watch.mask&provisional == 0 {
0000000000000000000000000000000000000000;;				// Watched directory was probably removed
0000000000000000000000000000000000000000;;				if w.sendEvent(watch.path, watch.mask&sysFSDELETESELF) {
0000000000000000000000000000000000000000;;					if watch.mask&sysFSONESHOT != 0 {
0000000000000000000000000000000000000000;;						watch.mask = 0
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.deleteWatch(watch)
0000000000000000000000000000000000000000;;			w.startRead(watch)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readEvents reads from the I/O completion port, converts the
0000000000000000000000000000000000000000;;	// received events into Event objects and sends them via the Events channel.
0000000000000000000000000000000000000000;;	// Entry point to the I/O thread.
0000000000000000000000000000000000000000;;	func (w *Watcher) readEvents() {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			n, key uint32
0000000000000000000000000000000000000000;;			ov     *syscall.Overlapped
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		runtime.LockOSThread()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			e := syscall.GetQueuedCompletionStatus(w.port, &n, &key, &ov, syscall.INFINITE)
0000000000000000000000000000000000000000;;			watch := (*watch)(unsafe.Pointer(ov))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if watch == nil {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case ch := <-w.quit:
0000000000000000000000000000000000000000;;					w.mu.Lock()
0000000000000000000000000000000000000000;;					var indexes []indexMap
0000000000000000000000000000000000000000;;					for _, index := range w.watches {
0000000000000000000000000000000000000000;;						indexes = append(indexes, index)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.mu.Unlock()
0000000000000000000000000000000000000000;;					for _, index := range indexes {
0000000000000000000000000000000000000000;;						for _, watch := range index {
0000000000000000000000000000000000000000;;							w.deleteWatch(watch)
0000000000000000000000000000000000000000;;							w.startRead(watch)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					if e := syscall.CloseHandle(w.port); e != nil {
0000000000000000000000000000000000000000;;						err = os.NewSyscallError("CloseHandle", e)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					close(w.Events)
0000000000000000000000000000000000000000;;					close(w.Errors)
0000000000000000000000000000000000000000;;					ch <- err
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				case in := <-w.input:
0000000000000000000000000000000000000000;;					switch in.op {
0000000000000000000000000000000000000000;;					case opAddWatch:
0000000000000000000000000000000000000000;;						in.reply <- w.addWatch(in.path, uint64(in.flags))
0000000000000000000000000000000000000000;;					case opRemoveWatch:
0000000000000000000000000000000000000000;;						in.reply <- w.remWatch(in.path)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch e {
0000000000000000000000000000000000000000;;			case syscall.ERROR_MORE_DATA:
0000000000000000000000000000000000000000;;				if watch == nil {
0000000000000000000000000000000000000000;;					w.Errors <- errors.New("ERROR_MORE_DATA has unexpectedly null lpOverlapped buffer")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// The i/o succeeded but the buffer is full.
0000000000000000000000000000000000000000;;					// In theory we should be building up a full packet.
0000000000000000000000000000000000000000;;					// In practice we can get away with just carrying on.
0000000000000000000000000000000000000000;;					n = uint32(unsafe.Sizeof(watch.buf))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case syscall.ERROR_ACCESS_DENIED:
0000000000000000000000000000000000000000;;				// Watched directory was probably removed
0000000000000000000000000000000000000000;;				w.sendEvent(watch.path, watch.mask&sysFSDELETESELF)
0000000000000000000000000000000000000000;;				w.deleteWatch(watch)
0000000000000000000000000000000000000000;;				w.startRead(watch)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case syscall.ERROR_OPERATION_ABORTED:
0000000000000000000000000000000000000000;;				// CancelIo was called on this handle
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				w.Errors <- os.NewSyscallError("GetQueuedCompletionPort", e)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var offset uint32
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if n == 0 {
0000000000000000000000000000000000000000;;					w.Events <- newEvent("", sysFSQOVERFLOW)
0000000000000000000000000000000000000000;;					w.Errors <- errors.New("short read in readEvents()")
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Point "raw" to the event in the buffer
0000000000000000000000000000000000000000;;				raw := (*syscall.FileNotifyInformation)(unsafe.Pointer(&watch.buf[offset]))
0000000000000000000000000000000000000000;;				buf := (*[syscall.MAX_PATH]uint16)(unsafe.Pointer(&raw.FileName))
0000000000000000000000000000000000000000;;				name := syscall.UTF16ToString(buf[:raw.FileNameLength/2])
0000000000000000000000000000000000000000;;				fullname := filepath.Join(watch.path, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var mask uint64
0000000000000000000000000000000000000000;;				switch raw.Action {
0000000000000000000000000000000000000000;;				case syscall.FILE_ACTION_REMOVED:
0000000000000000000000000000000000000000;;					mask = sysFSDELETESELF
0000000000000000000000000000000000000000;;				case syscall.FILE_ACTION_MODIFIED:
0000000000000000000000000000000000000000;;					mask = sysFSMODIFY
0000000000000000000000000000000000000000;;				case syscall.FILE_ACTION_RENAMED_OLD_NAME:
0000000000000000000000000000000000000000;;					watch.rename = name
0000000000000000000000000000000000000000;;				case syscall.FILE_ACTION_RENAMED_NEW_NAME:
0000000000000000000000000000000000000000;;					if watch.names[watch.rename] != 0 {
0000000000000000000000000000000000000000;;						watch.names[name] |= watch.names[watch.rename]
0000000000000000000000000000000000000000;;						delete(watch.names, watch.rename)
0000000000000000000000000000000000000000;;						mask = sysFSMOVESELF
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sendNameEvent := func() {
0000000000000000000000000000000000000000;;					if w.sendEvent(fullname, watch.names[name]&mask) {
0000000000000000000000000000000000000000;;						if watch.names[name]&sysFSONESHOT != 0 {
0000000000000000000000000000000000000000;;							delete(watch.names, name)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if raw.Action != syscall.FILE_ACTION_RENAMED_NEW_NAME {
0000000000000000000000000000000000000000;;					sendNameEvent()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if raw.Action == syscall.FILE_ACTION_REMOVED {
0000000000000000000000000000000000000000;;					w.sendEvent(fullname, watch.names[name]&sysFSIGNORED)
0000000000000000000000000000000000000000;;					delete(watch.names, name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if w.sendEvent(fullname, watch.mask&toFSnotifyFlags(raw.Action)) {
0000000000000000000000000000000000000000;;					if watch.mask&sysFSONESHOT != 0 {
0000000000000000000000000000000000000000;;						watch.mask = 0
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if raw.Action == syscall.FILE_ACTION_RENAMED_NEW_NAME {
0000000000000000000000000000000000000000;;					fullname = filepath.Join(watch.path, watch.rename)
0000000000000000000000000000000000000000;;					sendNameEvent()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Move to the next event in the buffer
0000000000000000000000000000000000000000;;				if raw.NextEntryOffset == 0 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				offset += raw.NextEntryOffset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Error!
0000000000000000000000000000000000000000;;				if offset >= n {
0000000000000000000000000000000000000000;;					w.Errors <- errors.New("Windows system assumed buffer larger than it is, events have likely been missed.")
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := w.startRead(watch); err != nil {
0000000000000000000000000000000000000000;;				w.Errors <- err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *Watcher) sendEvent(name string, mask uint64) bool {
0000000000000000000000000000000000000000;;		if mask == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		event := newEvent(name, uint32(mask))
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case ch := <-w.quit:
0000000000000000000000000000000000000000;;			w.quit <- ch
0000000000000000000000000000000000000000;;		case w.Events <- event:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toWindowsFlags(mask uint64) uint32 {
0000000000000000000000000000000000000000;;		var m uint32
0000000000000000000000000000000000000000;;		if mask&sysFSACCESS != 0 {
0000000000000000000000000000000000000000;;			m |= syscall.FILE_NOTIFY_CHANGE_LAST_ACCESS
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&sysFSMODIFY != 0 {
0000000000000000000000000000000000000000;;			m |= syscall.FILE_NOTIFY_CHANGE_LAST_WRITE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&sysFSATTRIB != 0 {
0000000000000000000000000000000000000000;;			m |= syscall.FILE_NOTIFY_CHANGE_ATTRIBUTES
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask&(sysFSMOVE|sysFSCREATE|sysFSDELETE) != 0 {
0000000000000000000000000000000000000000;;			m |= syscall.FILE_NOTIFY_CHANGE_FILE_NAME | syscall.FILE_NOTIFY_CHANGE_DIR_NAME
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toFSnotifyFlags(action uint32) uint64 {
0000000000000000000000000000000000000000;;		switch action {
0000000000000000000000000000000000000000;;		case syscall.FILE_ACTION_ADDED:
0000000000000000000000000000000000000000;;			return sysFSCREATE
0000000000000000000000000000000000000000;;		case syscall.FILE_ACTION_REMOVED:
0000000000000000000000000000000000000000;;			return sysFSDELETE
0000000000000000000000000000000000000000;;		case syscall.FILE_ACTION_MODIFIED:
0000000000000000000000000000000000000000;;			return sysFSMODIFY
0000000000000000000000000000000000000000;;		case syscall.FILE_ACTION_RENAMED_OLD_NAME:
0000000000000000000000000000000000000000;;			return sysFSMOVEDFROM
0000000000000000000000000000000000000000;;		case syscall.FILE_ACTION_RENAMED_NEW_NAME:
0000000000000000000000000000000000000000;;			return sysFSMOVEDTO
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
