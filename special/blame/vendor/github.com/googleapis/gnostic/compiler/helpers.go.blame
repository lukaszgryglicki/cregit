0000000000000000000000000000000000000000;;	// Copyright 2017 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8337c2fc62f66cf6db7638dc013660183869f458;;	
0000000000000000000000000000000000000000;;	package compiler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compiler helper functions, usually called from generated code
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UnpackMap(in interface{}) (yaml.MapSlice, bool) {
0000000000000000000000000000000000000000;;		m, ok := in.(yaml.MapSlice)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return m, ok
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// do we have an empty array?
0000000000000000000000000000000000000000;;			a, ok := in.([]interface{})
0000000000000000000000000000000000000000;;			if ok && len(a) == 0 {
0000000000000000000000000000000000000000;;				// if so, return an empty map
0000000000000000000000000000000000000000;;				return yaml.MapSlice{}, ok
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, ok
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SortedKeysForMap(m yaml.MapSlice) []string {
0000000000000000000000000000000000000000;;		keys := make([]string, 0)
0000000000000000000000000000000000000000;;		for _, item := range m {
0000000000000000000000000000000000000000;;			keys = append(keys, item.Key.(string))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MapHasKey(m yaml.MapSlice, key string) bool {
0000000000000000000000000000000000000000;;		for _, item := range m {
0000000000000000000000000000000000000000;;			itemKey, ok := item.Key.(string)
0000000000000000000000000000000000000000;;			if ok && key == itemKey {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MapValueForKey(m yaml.MapSlice, key string) interface{} {
0000000000000000000000000000000000000000;;		for _, item := range m {
0000000000000000000000000000000000000000;;			itemKey, ok := item.Key.(string)
0000000000000000000000000000000000000000;;			if ok && key == itemKey {
0000000000000000000000000000000000000000;;				return item.Value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ConvertInterfaceArrayToStringArray(interfaceArray []interface{}) []string {
0000000000000000000000000000000000000000;;		stringArray := make([]string, 0)
0000000000000000000000000000000000000000;;		for _, item := range interfaceArray {
0000000000000000000000000000000000000000;;			v, ok := item.(string)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				stringArray = append(stringArray, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stringArray
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PatternMatches(pattern string, value string) bool {
0000000000000000000000000000000000000000;;		// if pattern contains a subpattern like "{path}", replace it with ".*"
0000000000000000000000000000000000000000;;		if pattern[0] != '^' {
0000000000000000000000000000000000000000;;			subpatternPattern := regexp.MustCompile("^.*(\\{.*\\}).*$")
0000000000000000000000000000000000000000;;			if matches := subpatternPattern.FindSubmatch([]byte(pattern)); matches != nil {
0000000000000000000000000000000000000000;;				match := string(matches[1])
0000000000000000000000000000000000000000;;				pattern = strings.Replace(pattern, match, ".*", -1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matched, err := regexp.Match(pattern, []byte(value))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return matched
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MissingKeysInMap(m yaml.MapSlice, requiredKeys []string) []string {
0000000000000000000000000000000000000000;;		missingKeys := make([]string, 0)
0000000000000000000000000000000000000000;;		for _, k := range requiredKeys {
0000000000000000000000000000000000000000;;			if !MapHasKey(m, k) {
0000000000000000000000000000000000000000;;				missingKeys = append(missingKeys, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return missingKeys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func InvalidKeysInMap(m yaml.MapSlice, allowedKeys []string, allowedPatterns []string) []string {
0000000000000000000000000000000000000000;;		invalidKeys := make([]string, 0)
0000000000000000000000000000000000000000;;		for _, item := range m {
0000000000000000000000000000000000000000;;			itemKey, ok := item.Key.(string)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				key := itemKey
0000000000000000000000000000000000000000;;				found := false
0000000000000000000000000000000000000000;;				// does the key match an allowed key?
0000000000000000000000000000000000000000;;				for _, allowedKey := range allowedKeys {
0000000000000000000000000000000000000000;;					if key == allowedKey {
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					// does the key match an allowed pattern?
0000000000000000000000000000000000000000;;					for _, allowedPattern := range allowedPatterns {
0000000000000000000000000000000000000000;;						if PatternMatches(allowedPattern, key) {
0000000000000000000000000000000000000000;;							found = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !found {
0000000000000000000000000000000000000000;;						invalidKeys = append(invalidKeys, key)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return invalidKeys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// describe a map (for debugging purposes)
0000000000000000000000000000000000000000;;	func DescribeMap(in interface{}, indent string) string {
0000000000000000000000000000000000000000;;		description := ""
0000000000000000000000000000000000000000;;		m, ok := in.(map[string]interface{})
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			keys := make([]string, 0)
0000000000000000000000000000000000000000;;			for k, _ := range m {
0000000000000000000000000000000000000000;;				keys = append(keys, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(keys)
0000000000000000000000000000000000000000;;			for _, k := range keys {
0000000000000000000000000000000000000000;;				v := m[k]
0000000000000000000000000000000000000000;;				description += fmt.Sprintf("%s%s:\n", indent, k)
0000000000000000000000000000000000000000;;				description += DescribeMap(v, indent+"  ")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return description
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a, ok := in.([]interface{})
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			for i, v := range a {
0000000000000000000000000000000000000000;;				description += fmt.Sprintf("%s%d:\n", indent, i)
0000000000000000000000000000000000000000;;				description += DescribeMap(v, indent+"  ")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return description
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		description += fmt.Sprintf("%s%+v\n", indent, in)
0000000000000000000000000000000000000000;;		return description
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PluralProperties(count int) string {
0000000000000000000000000000000000000000;;		if count == 1 {
0000000000000000000000000000000000000000;;			return "property"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return "properties"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StringArrayContainsValue(array []string, value string) bool {
0000000000000000000000000000000000000000;;		for _, item := range array {
0000000000000000000000000000000000000000;;			if item == value {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StringArrayContainsValues(array []string, values []string) bool {
0000000000000000000000000000000000000000;;		for _, value := range values {
0000000000000000000000000000000000000000;;			if !StringArrayContainsValue(array, value) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
