0000000000000000000000000000000000000000;;	// Copyright 2017 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8337c2fc62f66cf6db7638dc013660183869f458;;	
0000000000000000000000000000000000000000;;	package compiler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// basic error type
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		Context *Context
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewError(context *Context, message string) *Error {
0000000000000000000000000000000000000000;;		return &Error{Context: context, Message: message}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err *Error) Error() string {
0000000000000000000000000000000000000000;;		if err.Context != nil {
0000000000000000000000000000000000000000;;			return "ERROR " + err.Context.Description() + " " + err.Message
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return "ERROR " + err.Message
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// container for groups of errors
0000000000000000000000000000000000000000;;	type ErrorGroup struct {
0000000000000000000000000000000000000000;;		Errors []error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewErrorGroupOrNil(errors []error) error {
0000000000000000000000000000000000000000;;		if len(errors) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if len(errors) == 1 {
0000000000000000000000000000000000000000;;			return errors[0]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return &ErrorGroup{Errors: errors}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (group *ErrorGroup) Error() string {
0000000000000000000000000000000000000000;;		result := ""
0000000000000000000000000000000000000000;;		for i, err := range group.Errors {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				result += "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result += err.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
