0000000000000000000000000000000000000000;;	// Copyright 2017 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8337c2fc62f66cf6db7638dc013660183869f458;;	
0000000000000000000000000000000000000000;;	package compiler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/ptypes/any"
0000000000000000000000000000000000000000;;		ext_plugin "github.com/googleapis/gnostic/extensions"
0000000000000000000000000000000000000000;;		yaml "gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ExtensionHandler struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func HandleExtension(context *Context, in interface{}, extensionName string) (bool, *any.Any, error) {
0000000000000000000000000000000000000000;;		handled := false
0000000000000000000000000000000000000000;;		var errFromPlugin error
0000000000000000000000000000000000000000;;		var outFromPlugin *any.Any
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if context.ExtensionHandlers != nil && len(*(context.ExtensionHandlers)) != 0 {
0000000000000000000000000000000000000000;;			for _, customAnyProtoGenerator := range *(context.ExtensionHandlers) {
0000000000000000000000000000000000000000;;				outFromPlugin, errFromPlugin = customAnyProtoGenerator.handle(in, extensionName)
0000000000000000000000000000000000000000;;				if outFromPlugin == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					handled = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return handled, outFromPlugin, errFromPlugin
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (extensionHandlers *ExtensionHandler) handle(in interface{}, extensionName string) (*any.Any, error) {
0000000000000000000000000000000000000000;;		if extensionHandlers.Name != "" {
0000000000000000000000000000000000000000;;			binary, _ := yaml.Marshal(in)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request := &ext_plugin.ExtensionHandlerRequest{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			version := &ext_plugin.Version{}
0000000000000000000000000000000000000000;;			version.Major = 0
0000000000000000000000000000000000000000;;			version.Minor = 1
0000000000000000000000000000000000000000;;			version.Patch = 0
0000000000000000000000000000000000000000;;			request.CompilerVersion = version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request.Wrapper = &ext_plugin.Wrapper{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			request.Wrapper.Version = "v2"
0000000000000000000000000000000000000000;;			request.Wrapper.Yaml = string(binary)
0000000000000000000000000000000000000000;;			request.Wrapper.ExtensionName = extensionName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			requestBytes, _ := proto.Marshal(request)
0000000000000000000000000000000000000000;;			cmd := exec.Command(extensionHandlers.Name)
0000000000000000000000000000000000000000;;			cmd.Stdin = bytes.NewReader(requestBytes)
0000000000000000000000000000000000000000;;			output, err := cmd.Output()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fmt.Printf("Error: %+v\n", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			response := &ext_plugin.ExtensionHandlerResponse{}
0000000000000000000000000000000000000000;;			err = proto.Unmarshal(output, response)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fmt.Printf("Error: %+v\n", err)
0000000000000000000000000000000000000000;;				fmt.Printf("%s\n", string(output))
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !response.Handled {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(response.Error) != 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("Errors when parsing: %+v for field %s by vendor extension handler %s. Details %+v", in, extensionName, extensionHandlers.Name, strings.Join(response.Error, ","))
0000000000000000000000000000000000000000;;				return nil, errors.New(message)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return response.Value, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
