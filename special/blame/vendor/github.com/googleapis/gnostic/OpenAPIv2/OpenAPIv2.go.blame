0000000000000000000000000000000000000000;;	// Copyright 2017 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
8337c2fc62f66cf6db7638dc013660183869f458;;	
0000000000000000000000000000000000000000;;	// THIS FILE IS AUTOMATICALLY GENERATED.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package openapi_v2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"github.com/googleapis/gnostic/compiler"
0000000000000000000000000000000000000000;;		"gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Version() string {
0000000000000000000000000000000000000000;;		return "openapi_v2"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewAdditionalPropertiesItem(in interface{}, context *compiler.Context) (*AdditionalPropertiesItem, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &AdditionalPropertiesItem{}
0000000000000000000000000000000000000000;;		matched := false
0000000000000000000000000000000000000000;;		// Schema schema = 1;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewSchema(m, compiler.NewContext("schema", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &AdditionalPropertiesItem_Schema{Schema: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// bool boolean = 2;
0000000000000000000000000000000000000000;;		boolValue, ok := in.(bool)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			x.Oneof = &AdditionalPropertiesItem_Boolean{Boolean: boolValue}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matched {
0000000000000000000000000000000000000000;;			// since the oneof matched one of its possibilities, discard any matching errors
0000000000000000000000000000000000000000;;			errors = make([]error, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewAny(in interface{}, context *compiler.Context) (*Any, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Any{}
0000000000000000000000000000000000000000;;		bytes, _ := yaml.Marshal(in)
0000000000000000000000000000000000000000;;		x.Yaml = string(bytes)
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewApiKeySecurity(in interface{}, context *compiler.Context) (*ApiKeySecurity, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &ApiKeySecurity{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"in", "name", "type"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"description", "in", "name", "type"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [apiKey]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"apiKey"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string in = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "in")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.In, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [header query]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"header", "query"}, x.In) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 5;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBasicAuthenticationSecurity(in interface{}, context *compiler.Context) (*BasicAuthenticationSecurity, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &BasicAuthenticationSecurity{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"type"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"description", "type"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [basic]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"basic"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 3;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBodyParameter(in interface{}, context *compiler.Context) (*BodyParameter, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &BodyParameter{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"in", "name", "schema"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"description", "in", "name", "required", "schema"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string in = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "in")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.In, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [body]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"body"}, x.In) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool required = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "required")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.Required, ok = v4.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for required: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Schema schema = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "schema")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Schema, err = NewSchema(v5, compiler.NewContext("schema", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 6;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewContact(in interface{}, context *compiler.Context) (*Contact, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Contact{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"email", "name", "url"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string url = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "url")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Url, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for url: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string email = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "email")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Email, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for email: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 4;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDefault(in interface{}, context *compiler.Context) (*Default, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Default{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedAny additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: Any
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedAny{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					result := &Any{}
0000000000000000000000000000000000000000;;					handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;					if handled {
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;							result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;							result.Value = resultFromExt
0000000000000000000000000000000000000000;;							pair.Value = result
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDefinitions(in interface{}, context *compiler.Context) (*Definitions, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Definitions{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedSchema additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: Schema
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedSchema, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedSchema{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					pair.Value, err = NewSchema(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errors = append(errors, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDocument(in interface{}, context *compiler.Context) (*Document, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Document{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"info", "paths", "swagger"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"basePath", "consumes", "definitions", "externalDocs", "host", "info", "parameters", "paths", "produces", "responses", "schemes", "security", "securityDefinitions", "swagger", "tags"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string swagger = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "swagger")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Swagger, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for swagger: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [2.0]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"2.0"}, x.Swagger) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for swagger: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Info info = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "info")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Info, err = NewInfo(v2, compiler.NewContext("info", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string host = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "host")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Host, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for host: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string base_path = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "basePath")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.BasePath, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for basePath: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated string schemes = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "schemes")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				v, ok := v5.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.Schemes = compiler.ConvertInterfaceArrayToStringArray(v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for schemes: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [http https ws wss]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValues([]string{"http", "https", "ws", "wss"}, x.Schemes) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for schemes: %+v", v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated string consumes = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "consumes")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				v, ok := v6.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.Consumes = compiler.ConvertInterfaceArrayToStringArray(v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for consumes: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated string produces = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "produces")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				v, ok := v7.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.Produces = compiler.ConvertInterfaceArrayToStringArray(v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for produces: %+v (%T)", v7, v7)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Paths paths = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "paths")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Paths, err = NewPaths(v8, compiler.NewContext("paths", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Definitions definitions = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "definitions")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Definitions, err = NewDefinitions(v9, compiler.NewContext("definitions", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ParameterDefinitions parameters = 10;
0000000000000000000000000000000000000000;;			v10 := compiler.MapValueForKey(m, "parameters")
0000000000000000000000000000000000000000;;			if v10 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Parameters, err = NewParameterDefinitions(v10, compiler.NewContext("parameters", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ResponseDefinitions responses = 11;
0000000000000000000000000000000000000000;;			v11 := compiler.MapValueForKey(m, "responses")
0000000000000000000000000000000000000000;;			if v11 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Responses, err = NewResponseDefinitions(v11, compiler.NewContext("responses", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated SecurityRequirement security = 12;
0000000000000000000000000000000000000000;;			v12 := compiler.MapValueForKey(m, "security")
0000000000000000000000000000000000000000;;			if v12 != nil {
0000000000000000000000000000000000000000;;				// repeated SecurityRequirement
0000000000000000000000000000000000000000;;				x.Security = make([]*SecurityRequirement, 0)
0000000000000000000000000000000000000000;;				a, ok := v12.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewSecurityRequirement(item, compiler.NewContext("security", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Security = append(x.Security, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// SecurityDefinitions security_definitions = 13;
0000000000000000000000000000000000000000;;			v13 := compiler.MapValueForKey(m, "securityDefinitions")
0000000000000000000000000000000000000000;;			if v13 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.SecurityDefinitions, err = NewSecurityDefinitions(v13, compiler.NewContext("securityDefinitions", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated Tag tags = 14;
0000000000000000000000000000000000000000;;			v14 := compiler.MapValueForKey(m, "tags")
0000000000000000000000000000000000000000;;			if v14 != nil {
0000000000000000000000000000000000000000;;				// repeated Tag
0000000000000000000000000000000000000000;;				x.Tags = make([]*Tag, 0)
0000000000000000000000000000000000000000;;				a, ok := v14.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewTag(item, compiler.NewContext("tags", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Tags = append(x.Tags, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ExternalDocs external_docs = 15;
0000000000000000000000000000000000000000;;			v15 := compiler.MapValueForKey(m, "externalDocs")
0000000000000000000000000000000000000000;;			if v15 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.ExternalDocs, err = NewExternalDocs(v15, compiler.NewContext("externalDocs", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 16;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewExamples(in interface{}, context *compiler.Context) (*Examples, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Examples{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedAny additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: Any
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedAny{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					result := &Any{}
0000000000000000000000000000000000000000;;					handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;					if handled {
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;							result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;							result.Value = resultFromExt
0000000000000000000000000000000000000000;;							pair.Value = result
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewExternalDocs(in interface{}, context *compiler.Context) (*ExternalDocs, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &ExternalDocs{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"url"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"description", "url"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string url = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "url")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Url, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for url: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 3;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFileSchema(in interface{}, context *compiler.Context) (*FileSchema, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &FileSchema{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"type"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"default", "description", "example", "externalDocs", "format", "readOnly", "required", "title", "type"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string format = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "format")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Format, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for format: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string title = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "title")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Title, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for title: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any default = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "default")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Default, err = NewAny(v4, compiler.NewContext("default", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated string required = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "required")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				v, ok := v5.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.Required = compiler.ConvertInterfaceArrayToStringArray(v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for required: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v6.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [file]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"file"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool read_only = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "readOnly")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				x.ReadOnly, ok = v7.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for readOnly: %+v (%T)", v7, v7)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ExternalDocs external_docs = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "externalDocs")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.ExternalDocs, err = NewExternalDocs(v8, compiler.NewContext("externalDocs", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any example = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "example")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Example, err = NewAny(v9, compiler.NewContext("example", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 10;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFormDataParameterSubSchema(in interface{}, context *compiler.Context) (*FormDataParameterSubSchema, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &FormDataParameterSubSchema{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"allowEmptyValue", "collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool required = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "required")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Required, ok = v1.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for required: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string in = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "in")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.In, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [formData]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"formData"}, x.In) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool allow_empty_value = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "allowEmptyValue")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				x.AllowEmptyValue, ok = v5.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for allowEmptyValue: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v6.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [string number boolean integer array file]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"string", "number", "boolean", "integer", "array", "file"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string format = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "format")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				x.Format, ok = v7.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for format: %+v (%T)", v7, v7)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// PrimitivesItems items = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "items")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Items, err = NewPrimitivesItems(v8, compiler.NewContext("items", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string collection_format = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "collectionFormat")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				x.CollectionFormat, ok = v9.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v9, v9)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [csv ssv tsv pipes multi]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"csv", "ssv", "tsv", "pipes", "multi"}, x.CollectionFormat) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v9, v9)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any default = 10;
0000000000000000000000000000000000000000;;			v10 := compiler.MapValueForKey(m, "default")
0000000000000000000000000000000000000000;;			if v10 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Default, err = NewAny(v10, compiler.NewContext("default", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float maximum = 11;
0000000000000000000000000000000000000000;;			v11 := compiler.MapValueForKey(m, "maximum")
0000000000000000000000000000000000000000;;			if v11 != nil {
0000000000000000000000000000000000000000;;				switch v11 := v11.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Maximum = v11
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maximum: %+v (%T)", v11, v11)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_maximum = 12;
0000000000000000000000000000000000000000;;			v12 := compiler.MapValueForKey(m, "exclusiveMaximum")
0000000000000000000000000000000000000000;;			if v12 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMaximum, ok = v12.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMaximum: %+v (%T)", v12, v12)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float minimum = 13;
0000000000000000000000000000000000000000;;			v13 := compiler.MapValueForKey(m, "minimum")
0000000000000000000000000000000000000000;;			if v13 != nil {
0000000000000000000000000000000000000000;;				switch v13 := v13.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Minimum = v13
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minimum: %+v (%T)", v13, v13)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_minimum = 14;
0000000000000000000000000000000000000000;;			v14 := compiler.MapValueForKey(m, "exclusiveMinimum")
0000000000000000000000000000000000000000;;			if v14 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMinimum, ok = v14.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMinimum: %+v (%T)", v14, v14)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_length = 15;
0000000000000000000000000000000000000000;;			v15 := compiler.MapValueForKey(m, "maxLength")
0000000000000000000000000000000000000000;;			if v15 != nil {
0000000000000000000000000000000000000000;;				t, ok := v15.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxLength: %+v (%T)", v15, v15)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_length = 16;
0000000000000000000000000000000000000000;;			v16 := compiler.MapValueForKey(m, "minLength")
0000000000000000000000000000000000000000;;			if v16 != nil {
0000000000000000000000000000000000000000;;				t, ok := v16.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minLength: %+v (%T)", v16, v16)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string pattern = 17;
0000000000000000000000000000000000000000;;			v17 := compiler.MapValueForKey(m, "pattern")
0000000000000000000000000000000000000000;;			if v17 != nil {
0000000000000000000000000000000000000000;;				x.Pattern, ok = v17.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for pattern: %+v (%T)", v17, v17)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_items = 18;
0000000000000000000000000000000000000000;;			v18 := compiler.MapValueForKey(m, "maxItems")
0000000000000000000000000000000000000000;;			if v18 != nil {
0000000000000000000000000000000000000000;;				t, ok := v18.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxItems: %+v (%T)", v18, v18)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_items = 19;
0000000000000000000000000000000000000000;;			v19 := compiler.MapValueForKey(m, "minItems")
0000000000000000000000000000000000000000;;			if v19 != nil {
0000000000000000000000000000000000000000;;				t, ok := v19.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minItems: %+v (%T)", v19, v19)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool unique_items = 20;
0000000000000000000000000000000000000000;;			v20 := compiler.MapValueForKey(m, "uniqueItems")
0000000000000000000000000000000000000000;;			if v20 != nil {
0000000000000000000000000000000000000000;;				x.UniqueItems, ok = v20.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for uniqueItems: %+v (%T)", v20, v20)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated Any enum = 21;
0000000000000000000000000000000000000000;;			v21 := compiler.MapValueForKey(m, "enum")
0000000000000000000000000000000000000000;;			if v21 != nil {
0000000000000000000000000000000000000000;;				// repeated Any
0000000000000000000000000000000000000000;;				x.Enum = make([]*Any, 0)
0000000000000000000000000000000000000000;;				a, ok := v21.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewAny(item, compiler.NewContext("enum", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Enum = append(x.Enum, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float multiple_of = 22;
0000000000000000000000000000000000000000;;			v22 := compiler.MapValueForKey(m, "multipleOf")
0000000000000000000000000000000000000000;;			if v22 != nil {
0000000000000000000000000000000000000000;;				switch v22 := v22.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.MultipleOf = v22
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for multipleOf: %+v (%T)", v22, v22)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 23;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHeader(in interface{}, context *compiler.Context) (*Header, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Header{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"type"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "pattern", "type", "uniqueItems"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [string number integer boolean array]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"string", "number", "integer", "boolean", "array"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string format = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "format")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Format, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for format: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// PrimitivesItems items = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "items")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Items, err = NewPrimitivesItems(v3, compiler.NewContext("items", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string collection_format = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "collectionFormat")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.CollectionFormat, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [csv ssv tsv pipes]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"csv", "ssv", "tsv", "pipes"}, x.CollectionFormat) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any default = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "default")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Default, err = NewAny(v5, compiler.NewContext("default", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float maximum = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "maximum")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				switch v6 := v6.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Maximum = v6
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maximum: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_maximum = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "exclusiveMaximum")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMaximum, ok = v7.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMaximum: %+v (%T)", v7, v7)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float minimum = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "minimum")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				switch v8 := v8.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Minimum = v8
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minimum: %+v (%T)", v8, v8)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_minimum = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "exclusiveMinimum")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMinimum, ok = v9.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMinimum: %+v (%T)", v9, v9)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_length = 10;
0000000000000000000000000000000000000000;;			v10 := compiler.MapValueForKey(m, "maxLength")
0000000000000000000000000000000000000000;;			if v10 != nil {
0000000000000000000000000000000000000000;;				t, ok := v10.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxLength: %+v (%T)", v10, v10)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_length = 11;
0000000000000000000000000000000000000000;;			v11 := compiler.MapValueForKey(m, "minLength")
0000000000000000000000000000000000000000;;			if v11 != nil {
0000000000000000000000000000000000000000;;				t, ok := v11.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minLength: %+v (%T)", v11, v11)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string pattern = 12;
0000000000000000000000000000000000000000;;			v12 := compiler.MapValueForKey(m, "pattern")
0000000000000000000000000000000000000000;;			if v12 != nil {
0000000000000000000000000000000000000000;;				x.Pattern, ok = v12.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for pattern: %+v (%T)", v12, v12)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_items = 13;
0000000000000000000000000000000000000000;;			v13 := compiler.MapValueForKey(m, "maxItems")
0000000000000000000000000000000000000000;;			if v13 != nil {
0000000000000000000000000000000000000000;;				t, ok := v13.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxItems: %+v (%T)", v13, v13)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_items = 14;
0000000000000000000000000000000000000000;;			v14 := compiler.MapValueForKey(m, "minItems")
0000000000000000000000000000000000000000;;			if v14 != nil {
0000000000000000000000000000000000000000;;				t, ok := v14.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minItems: %+v (%T)", v14, v14)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool unique_items = 15;
0000000000000000000000000000000000000000;;			v15 := compiler.MapValueForKey(m, "uniqueItems")
0000000000000000000000000000000000000000;;			if v15 != nil {
0000000000000000000000000000000000000000;;				x.UniqueItems, ok = v15.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for uniqueItems: %+v (%T)", v15, v15)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated Any enum = 16;
0000000000000000000000000000000000000000;;			v16 := compiler.MapValueForKey(m, "enum")
0000000000000000000000000000000000000000;;			if v16 != nil {
0000000000000000000000000000000000000000;;				// repeated Any
0000000000000000000000000000000000000000;;				x.Enum = make([]*Any, 0)
0000000000000000000000000000000000000000;;				a, ok := v16.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewAny(item, compiler.NewContext("enum", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Enum = append(x.Enum, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float multiple_of = 17;
0000000000000000000000000000000000000000;;			v17 := compiler.MapValueForKey(m, "multipleOf")
0000000000000000000000000000000000000000;;			if v17 != nil {
0000000000000000000000000000000000000000;;				switch v17 := v17.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.MultipleOf = v17
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for multipleOf: %+v (%T)", v17, v17)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 18;
0000000000000000000000000000000000000000;;			v18 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v18 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v18.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v18, v18)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 19;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHeaderParameterSubSchema(in interface{}, context *compiler.Context) (*HeaderParameterSubSchema, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &HeaderParameterSubSchema{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool required = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "required")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Required, ok = v1.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for required: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string in = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "in")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.In, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [header]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"header"}, x.In) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v5.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [string number boolean integer array]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"string", "number", "boolean", "integer", "array"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string format = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "format")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				x.Format, ok = v6.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for format: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// PrimitivesItems items = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "items")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Items, err = NewPrimitivesItems(v7, compiler.NewContext("items", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string collection_format = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "collectionFormat")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				x.CollectionFormat, ok = v8.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v8, v8)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [csv ssv tsv pipes]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"csv", "ssv", "tsv", "pipes"}, x.CollectionFormat) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v8, v8)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any default = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "default")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Default, err = NewAny(v9, compiler.NewContext("default", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float maximum = 10;
0000000000000000000000000000000000000000;;			v10 := compiler.MapValueForKey(m, "maximum")
0000000000000000000000000000000000000000;;			if v10 != nil {
0000000000000000000000000000000000000000;;				switch v10 := v10.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Maximum = v10
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maximum: %+v (%T)", v10, v10)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_maximum = 11;
0000000000000000000000000000000000000000;;			v11 := compiler.MapValueForKey(m, "exclusiveMaximum")
0000000000000000000000000000000000000000;;			if v11 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMaximum, ok = v11.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMaximum: %+v (%T)", v11, v11)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float minimum = 12;
0000000000000000000000000000000000000000;;			v12 := compiler.MapValueForKey(m, "minimum")
0000000000000000000000000000000000000000;;			if v12 != nil {
0000000000000000000000000000000000000000;;				switch v12 := v12.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Minimum = v12
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minimum: %+v (%T)", v12, v12)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_minimum = 13;
0000000000000000000000000000000000000000;;			v13 := compiler.MapValueForKey(m, "exclusiveMinimum")
0000000000000000000000000000000000000000;;			if v13 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMinimum, ok = v13.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMinimum: %+v (%T)", v13, v13)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_length = 14;
0000000000000000000000000000000000000000;;			v14 := compiler.MapValueForKey(m, "maxLength")
0000000000000000000000000000000000000000;;			if v14 != nil {
0000000000000000000000000000000000000000;;				t, ok := v14.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxLength: %+v (%T)", v14, v14)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_length = 15;
0000000000000000000000000000000000000000;;			v15 := compiler.MapValueForKey(m, "minLength")
0000000000000000000000000000000000000000;;			if v15 != nil {
0000000000000000000000000000000000000000;;				t, ok := v15.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minLength: %+v (%T)", v15, v15)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string pattern = 16;
0000000000000000000000000000000000000000;;			v16 := compiler.MapValueForKey(m, "pattern")
0000000000000000000000000000000000000000;;			if v16 != nil {
0000000000000000000000000000000000000000;;				x.Pattern, ok = v16.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for pattern: %+v (%T)", v16, v16)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_items = 17;
0000000000000000000000000000000000000000;;			v17 := compiler.MapValueForKey(m, "maxItems")
0000000000000000000000000000000000000000;;			if v17 != nil {
0000000000000000000000000000000000000000;;				t, ok := v17.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxItems: %+v (%T)", v17, v17)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_items = 18;
0000000000000000000000000000000000000000;;			v18 := compiler.MapValueForKey(m, "minItems")
0000000000000000000000000000000000000000;;			if v18 != nil {
0000000000000000000000000000000000000000;;				t, ok := v18.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minItems: %+v (%T)", v18, v18)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool unique_items = 19;
0000000000000000000000000000000000000000;;			v19 := compiler.MapValueForKey(m, "uniqueItems")
0000000000000000000000000000000000000000;;			if v19 != nil {
0000000000000000000000000000000000000000;;				x.UniqueItems, ok = v19.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for uniqueItems: %+v (%T)", v19, v19)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated Any enum = 20;
0000000000000000000000000000000000000000;;			v20 := compiler.MapValueForKey(m, "enum")
0000000000000000000000000000000000000000;;			if v20 != nil {
0000000000000000000000000000000000000000;;				// repeated Any
0000000000000000000000000000000000000000;;				x.Enum = make([]*Any, 0)
0000000000000000000000000000000000000000;;				a, ok := v20.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewAny(item, compiler.NewContext("enum", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Enum = append(x.Enum, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float multiple_of = 21;
0000000000000000000000000000000000000000;;			v21 := compiler.MapValueForKey(m, "multipleOf")
0000000000000000000000000000000000000000;;			if v21 != nil {
0000000000000000000000000000000000000000;;				switch v21 := v21.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.MultipleOf = v21
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for multipleOf: %+v (%T)", v21, v21)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 22;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHeaders(in interface{}, context *compiler.Context) (*Headers, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Headers{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedHeader additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: Header
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedHeader, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedHeader{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					pair.Value, err = NewHeader(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errors = append(errors, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewInfo(in interface{}, context *compiler.Context) (*Info, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Info{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"title", "version"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"contact", "description", "license", "termsOfService", "title", "version"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string title = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "title")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Title, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for title: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string version = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "version")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Version, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for version: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string terms_of_service = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "termsOfService")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.TermsOfService, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for termsOfService: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Contact contact = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "contact")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Contact, err = NewContact(v5, compiler.NewContext("contact", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// License license = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "license")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.License, err = NewLicense(v6, compiler.NewContext("license", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 7;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewItemsItem(in interface{}, context *compiler.Context) (*ItemsItem, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &ItemsItem{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value for item array: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			x.Schema = make([]*Schema, 0)
0000000000000000000000000000000000000000;;			y, err := NewSchema(m, compiler.NewContext("<array>", context))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.Schema = append(x.Schema, y)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewJsonReference(in interface{}, context *compiler.Context) (*JsonReference, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &JsonReference{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"$ref"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"$ref", "description"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string _ref = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "$ref")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.XRef, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for $ref: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewLicense(in interface{}, context *compiler.Context) (*License, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &License{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"name"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "url"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string url = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "url")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Url, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for url: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 3;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedAny(in interface{}, context *compiler.Context) (*NamedAny, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NamedAny{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "value"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any value = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "value")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Value, err = NewAny(v2, compiler.NewContext("value", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedHeader(in interface{}, context *compiler.Context) (*NamedHeader, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NamedHeader{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "value"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Header value = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "value")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Value, err = NewHeader(v2, compiler.NewContext("value", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedParameter(in interface{}, context *compiler.Context) (*NamedParameter, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NamedParameter{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "value"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Parameter value = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "value")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Value, err = NewParameter(v2, compiler.NewContext("value", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedPathItem(in interface{}, context *compiler.Context) (*NamedPathItem, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NamedPathItem{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "value"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// PathItem value = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "value")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Value, err = NewPathItem(v2, compiler.NewContext("value", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedResponse(in interface{}, context *compiler.Context) (*NamedResponse, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NamedResponse{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "value"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Response value = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "value")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Value, err = NewResponse(v2, compiler.NewContext("value", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedResponseValue(in interface{}, context *compiler.Context) (*NamedResponseValue, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NamedResponseValue{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "value"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ResponseValue value = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "value")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Value, err = NewResponseValue(v2, compiler.NewContext("value", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedSchema(in interface{}, context *compiler.Context) (*NamedSchema, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NamedSchema{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "value"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Schema value = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "value")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Value, err = NewSchema(v2, compiler.NewContext("value", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedSecurityDefinitionsItem(in interface{}, context *compiler.Context) (*NamedSecurityDefinitionsItem, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NamedSecurityDefinitionsItem{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "value"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// SecurityDefinitionsItem value = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "value")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Value, err = NewSecurityDefinitionsItem(v2, compiler.NewContext("value", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedString(in interface{}, context *compiler.Context) (*NamedString, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NamedString{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "value"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string value = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "value")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Value, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for value: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNamedStringArray(in interface{}, context *compiler.Context) (*NamedStringArray, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NamedStringArray{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"name", "value"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// StringArray value = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "value")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Value, err = NewStringArray(v2, compiler.NewContext("value", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNonBodyParameter(in interface{}, context *compiler.Context) (*NonBodyParameter, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &NonBodyParameter{}
0000000000000000000000000000000000000000;;		matched := false
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"in", "name", "type"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// HeaderParameterSubSchema header_parameter_sub_schema = 1;
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewHeaderParameterSubSchema(m, compiler.NewContext("headerParameterSubSchema", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &NonBodyParameter_HeaderParameterSubSchema{HeaderParameterSubSchema: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// FormDataParameterSubSchema form_data_parameter_sub_schema = 2;
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewFormDataParameterSubSchema(m, compiler.NewContext("formDataParameterSubSchema", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &NonBodyParameter_FormDataParameterSubSchema{FormDataParameterSubSchema: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// QueryParameterSubSchema query_parameter_sub_schema = 3;
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewQueryParameterSubSchema(m, compiler.NewContext("queryParameterSubSchema", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &NonBodyParameter_QueryParameterSubSchema{QueryParameterSubSchema: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// PathParameterSubSchema path_parameter_sub_schema = 4;
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewPathParameterSubSchema(m, compiler.NewContext("pathParameterSubSchema", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &NonBodyParameter_PathParameterSubSchema{PathParameterSubSchema: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matched {
0000000000000000000000000000000000000000;;			// since the oneof matched one of its possibilities, discard any matching errors
0000000000000000000000000000000000000000;;			errors = make([]error, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOauth2AccessCodeSecurity(in interface{}, context *compiler.Context) (*Oauth2AccessCodeSecurity, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Oauth2AccessCodeSecurity{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"authorizationUrl", "flow", "tokenUrl", "type"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"authorizationUrl", "description", "flow", "scopes", "tokenUrl", "type"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [oauth2]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"oauth2"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string flow = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "flow")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Flow, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for flow: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [accessCode]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"accessCode"}, x.Flow) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for flow: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Oauth2Scopes scopes = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "scopes")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Scopes, err = NewOauth2Scopes(v3, compiler.NewContext("scopes", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string authorization_url = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "authorizationUrl")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.AuthorizationUrl, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for authorizationUrl: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string token_url = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "tokenUrl")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				x.TokenUrl, ok = v5.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for tokenUrl: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v6.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 7;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOauth2ApplicationSecurity(in interface{}, context *compiler.Context) (*Oauth2ApplicationSecurity, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Oauth2ApplicationSecurity{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"flow", "tokenUrl", "type"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"description", "flow", "scopes", "tokenUrl", "type"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [oauth2]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"oauth2"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string flow = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "flow")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Flow, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for flow: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [application]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"application"}, x.Flow) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for flow: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Oauth2Scopes scopes = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "scopes")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Scopes, err = NewOauth2Scopes(v3, compiler.NewContext("scopes", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string token_url = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "tokenUrl")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.TokenUrl, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for tokenUrl: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v5.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 6;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOauth2ImplicitSecurity(in interface{}, context *compiler.Context) (*Oauth2ImplicitSecurity, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Oauth2ImplicitSecurity{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"authorizationUrl", "flow", "type"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"authorizationUrl", "description", "flow", "scopes", "type"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [oauth2]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"oauth2"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string flow = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "flow")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Flow, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for flow: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [implicit]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"implicit"}, x.Flow) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for flow: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Oauth2Scopes scopes = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "scopes")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Scopes, err = NewOauth2Scopes(v3, compiler.NewContext("scopes", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string authorization_url = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "authorizationUrl")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.AuthorizationUrl, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for authorizationUrl: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v5.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 6;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOauth2PasswordSecurity(in interface{}, context *compiler.Context) (*Oauth2PasswordSecurity, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Oauth2PasswordSecurity{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"flow", "tokenUrl", "type"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"description", "flow", "scopes", "tokenUrl", "type"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [oauth2]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"oauth2"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string flow = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "flow")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Flow, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for flow: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [password]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"password"}, x.Flow) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for flow: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Oauth2Scopes scopes = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "scopes")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Scopes, err = NewOauth2Scopes(v3, compiler.NewContext("scopes", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string token_url = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "tokenUrl")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.TokenUrl, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for tokenUrl: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v5.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 6;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOauth2Scopes(in interface{}, context *compiler.Context) (*Oauth2Scopes, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Oauth2Scopes{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedString additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: string
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedString, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedString{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					pair.Value = v.(string)
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOperation(in interface{}, context *compiler.Context) (*Operation, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Operation{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"responses"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"consumes", "deprecated", "description", "externalDocs", "operationId", "parameters", "produces", "responses", "schemes", "security", "summary", "tags"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated string tags = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "tags")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				v, ok := v1.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.Tags = compiler.ConvertInterfaceArrayToStringArray(v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for tags: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string summary = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "summary")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Summary, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for summary: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ExternalDocs external_docs = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "externalDocs")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.ExternalDocs, err = NewExternalDocs(v4, compiler.NewContext("externalDocs", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string operation_id = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "operationId")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				x.OperationId, ok = v5.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for operationId: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated string produces = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "produces")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				v, ok := v6.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.Produces = compiler.ConvertInterfaceArrayToStringArray(v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for produces: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated string consumes = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "consumes")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				v, ok := v7.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.Consumes = compiler.ConvertInterfaceArrayToStringArray(v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for consumes: %+v (%T)", v7, v7)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated ParametersItem parameters = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "parameters")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				// repeated ParametersItem
0000000000000000000000000000000000000000;;				x.Parameters = make([]*ParametersItem, 0)
0000000000000000000000000000000000000000;;				a, ok := v8.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewParametersItem(item, compiler.NewContext("parameters", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Parameters = append(x.Parameters, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Responses responses = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "responses")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Responses, err = NewResponses(v9, compiler.NewContext("responses", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated string schemes = 10;
0000000000000000000000000000000000000000;;			v10 := compiler.MapValueForKey(m, "schemes")
0000000000000000000000000000000000000000;;			if v10 != nil {
0000000000000000000000000000000000000000;;				v, ok := v10.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.Schemes = compiler.ConvertInterfaceArrayToStringArray(v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for schemes: %+v (%T)", v10, v10)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [http https ws wss]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValues([]string{"http", "https", "ws", "wss"}, x.Schemes) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for schemes: %+v", v10)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool deprecated = 11;
0000000000000000000000000000000000000000;;			v11 := compiler.MapValueForKey(m, "deprecated")
0000000000000000000000000000000000000000;;			if v11 != nil {
0000000000000000000000000000000000000000;;				x.Deprecated, ok = v11.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for deprecated: %+v (%T)", v11, v11)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated SecurityRequirement security = 12;
0000000000000000000000000000000000000000;;			v12 := compiler.MapValueForKey(m, "security")
0000000000000000000000000000000000000000;;			if v12 != nil {
0000000000000000000000000000000000000000;;				// repeated SecurityRequirement
0000000000000000000000000000000000000000;;				x.Security = make([]*SecurityRequirement, 0)
0000000000000000000000000000000000000000;;				a, ok := v12.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewSecurityRequirement(item, compiler.NewContext("security", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Security = append(x.Security, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 13;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewParameter(in interface{}, context *compiler.Context) (*Parameter, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Parameter{}
0000000000000000000000000000000000000000;;		matched := false
0000000000000000000000000000000000000000;;		// BodyParameter body_parameter = 1;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewBodyParameter(m, compiler.NewContext("bodyParameter", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &Parameter_BodyParameter{BodyParameter: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// NonBodyParameter non_body_parameter = 2;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewNonBodyParameter(m, compiler.NewContext("nonBodyParameter", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &Parameter_NonBodyParameter{NonBodyParameter: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matched {
0000000000000000000000000000000000000000;;			// since the oneof matched one of its possibilities, discard any matching errors
0000000000000000000000000000000000000000;;			errors = make([]error, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewParameterDefinitions(in interface{}, context *compiler.Context) (*ParameterDefinitions, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &ParameterDefinitions{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedParameter additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: Parameter
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedParameter, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedParameter{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					pair.Value, err = NewParameter(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errors = append(errors, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewParametersItem(in interface{}, context *compiler.Context) (*ParametersItem, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &ParametersItem{}
0000000000000000000000000000000000000000;;		matched := false
0000000000000000000000000000000000000000;;		// Parameter parameter = 1;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewParameter(m, compiler.NewContext("parameter", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &ParametersItem_Parameter{Parameter: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// JsonReference json_reference = 2;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewJsonReference(m, compiler.NewContext("jsonReference", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &ParametersItem_JsonReference{JsonReference: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matched {
0000000000000000000000000000000000000000;;			// since the oneof matched one of its possibilities, discard any matching errors
0000000000000000000000000000000000000000;;			errors = make([]error, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPathItem(in interface{}, context *compiler.Context) (*PathItem, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &PathItem{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"$ref", "delete", "get", "head", "options", "parameters", "patch", "post", "put"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string _ref = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "$ref")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.XRef, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for $ref: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Operation get = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "get")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Get, err = NewOperation(v2, compiler.NewContext("get", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Operation put = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "put")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Put, err = NewOperation(v3, compiler.NewContext("put", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Operation post = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "post")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Post, err = NewOperation(v4, compiler.NewContext("post", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Operation delete = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "delete")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Delete, err = NewOperation(v5, compiler.NewContext("delete", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Operation options = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "options")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Options, err = NewOperation(v6, compiler.NewContext("options", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Operation head = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "head")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Head, err = NewOperation(v7, compiler.NewContext("head", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Operation patch = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "patch")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Patch, err = NewOperation(v8, compiler.NewContext("patch", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated ParametersItem parameters = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "parameters")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				// repeated ParametersItem
0000000000000000000000000000000000000000;;				x.Parameters = make([]*ParametersItem, 0)
0000000000000000000000000000000000000000;;				a, ok := v9.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewParametersItem(item, compiler.NewContext("parameters", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Parameters = append(x.Parameters, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 10;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPathParameterSubSchema(in interface{}, context *compiler.Context) (*PathParameterSubSchema, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &PathParameterSubSchema{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"required"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool required = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "required")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Required, ok = v1.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for required: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string in = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "in")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.In, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [path]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"path"}, x.In) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v5.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [string number boolean integer array]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"string", "number", "boolean", "integer", "array"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string format = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "format")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				x.Format, ok = v6.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for format: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// PrimitivesItems items = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "items")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Items, err = NewPrimitivesItems(v7, compiler.NewContext("items", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string collection_format = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "collectionFormat")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				x.CollectionFormat, ok = v8.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v8, v8)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [csv ssv tsv pipes]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"csv", "ssv", "tsv", "pipes"}, x.CollectionFormat) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v8, v8)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any default = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "default")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Default, err = NewAny(v9, compiler.NewContext("default", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float maximum = 10;
0000000000000000000000000000000000000000;;			v10 := compiler.MapValueForKey(m, "maximum")
0000000000000000000000000000000000000000;;			if v10 != nil {
0000000000000000000000000000000000000000;;				switch v10 := v10.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Maximum = v10
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v10)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maximum: %+v (%T)", v10, v10)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_maximum = 11;
0000000000000000000000000000000000000000;;			v11 := compiler.MapValueForKey(m, "exclusiveMaximum")
0000000000000000000000000000000000000000;;			if v11 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMaximum, ok = v11.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMaximum: %+v (%T)", v11, v11)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float minimum = 12;
0000000000000000000000000000000000000000;;			v12 := compiler.MapValueForKey(m, "minimum")
0000000000000000000000000000000000000000;;			if v12 != nil {
0000000000000000000000000000000000000000;;				switch v12 := v12.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Minimum = v12
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v12)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minimum: %+v (%T)", v12, v12)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_minimum = 13;
0000000000000000000000000000000000000000;;			v13 := compiler.MapValueForKey(m, "exclusiveMinimum")
0000000000000000000000000000000000000000;;			if v13 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMinimum, ok = v13.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMinimum: %+v (%T)", v13, v13)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_length = 14;
0000000000000000000000000000000000000000;;			v14 := compiler.MapValueForKey(m, "maxLength")
0000000000000000000000000000000000000000;;			if v14 != nil {
0000000000000000000000000000000000000000;;				t, ok := v14.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxLength: %+v (%T)", v14, v14)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_length = 15;
0000000000000000000000000000000000000000;;			v15 := compiler.MapValueForKey(m, "minLength")
0000000000000000000000000000000000000000;;			if v15 != nil {
0000000000000000000000000000000000000000;;				t, ok := v15.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minLength: %+v (%T)", v15, v15)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string pattern = 16;
0000000000000000000000000000000000000000;;			v16 := compiler.MapValueForKey(m, "pattern")
0000000000000000000000000000000000000000;;			if v16 != nil {
0000000000000000000000000000000000000000;;				x.Pattern, ok = v16.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for pattern: %+v (%T)", v16, v16)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_items = 17;
0000000000000000000000000000000000000000;;			v17 := compiler.MapValueForKey(m, "maxItems")
0000000000000000000000000000000000000000;;			if v17 != nil {
0000000000000000000000000000000000000000;;				t, ok := v17.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxItems: %+v (%T)", v17, v17)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_items = 18;
0000000000000000000000000000000000000000;;			v18 := compiler.MapValueForKey(m, "minItems")
0000000000000000000000000000000000000000;;			if v18 != nil {
0000000000000000000000000000000000000000;;				t, ok := v18.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minItems: %+v (%T)", v18, v18)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool unique_items = 19;
0000000000000000000000000000000000000000;;			v19 := compiler.MapValueForKey(m, "uniqueItems")
0000000000000000000000000000000000000000;;			if v19 != nil {
0000000000000000000000000000000000000000;;				x.UniqueItems, ok = v19.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for uniqueItems: %+v (%T)", v19, v19)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated Any enum = 20;
0000000000000000000000000000000000000000;;			v20 := compiler.MapValueForKey(m, "enum")
0000000000000000000000000000000000000000;;			if v20 != nil {
0000000000000000000000000000000000000000;;				// repeated Any
0000000000000000000000000000000000000000;;				x.Enum = make([]*Any, 0)
0000000000000000000000000000000000000000;;				a, ok := v20.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewAny(item, compiler.NewContext("enum", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Enum = append(x.Enum, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float multiple_of = 21;
0000000000000000000000000000000000000000;;			v21 := compiler.MapValueForKey(m, "multipleOf")
0000000000000000000000000000000000000000;;			if v21 != nil {
0000000000000000000000000000000000000000;;				switch v21 := v21.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.MultipleOf = v21
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v21)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for multipleOf: %+v (%T)", v21, v21)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 22;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPaths(in interface{}, context *compiler.Context) (*Paths, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Paths{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-", "^/"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 1;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedPathItem path = 2;
0000000000000000000000000000000000000000;;			// MAP: PathItem ^/
0000000000000000000000000000000000000000;;			x.Path = make([]*NamedPathItem, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^/", k) {
0000000000000000000000000000000000000000;;						pair := &NamedPathItem{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						var err error
0000000000000000000000000000000000000000;;						pair.Value, err = NewPathItem(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Path = append(x.Path, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPrimitivesItems(in interface{}, context *compiler.Context) (*PrimitivesItems, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &PrimitivesItems{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"collectionFormat", "default", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "pattern", "type", "uniqueItems"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [string number integer boolean array]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"string", "number", "integer", "boolean", "array"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string format = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "format")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Format, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for format: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// PrimitivesItems items = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "items")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Items, err = NewPrimitivesItems(v3, compiler.NewContext("items", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string collection_format = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "collectionFormat")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.CollectionFormat, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [csv ssv tsv pipes]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"csv", "ssv", "tsv", "pipes"}, x.CollectionFormat) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any default = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "default")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Default, err = NewAny(v5, compiler.NewContext("default", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float maximum = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "maximum")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				switch v6 := v6.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Maximum = v6
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v6)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maximum: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_maximum = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "exclusiveMaximum")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMaximum, ok = v7.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMaximum: %+v (%T)", v7, v7)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float minimum = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "minimum")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				switch v8 := v8.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Minimum = v8
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v8)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minimum: %+v (%T)", v8, v8)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_minimum = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "exclusiveMinimum")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMinimum, ok = v9.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMinimum: %+v (%T)", v9, v9)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_length = 10;
0000000000000000000000000000000000000000;;			v10 := compiler.MapValueForKey(m, "maxLength")
0000000000000000000000000000000000000000;;			if v10 != nil {
0000000000000000000000000000000000000000;;				t, ok := v10.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxLength: %+v (%T)", v10, v10)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_length = 11;
0000000000000000000000000000000000000000;;			v11 := compiler.MapValueForKey(m, "minLength")
0000000000000000000000000000000000000000;;			if v11 != nil {
0000000000000000000000000000000000000000;;				t, ok := v11.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minLength: %+v (%T)", v11, v11)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string pattern = 12;
0000000000000000000000000000000000000000;;			v12 := compiler.MapValueForKey(m, "pattern")
0000000000000000000000000000000000000000;;			if v12 != nil {
0000000000000000000000000000000000000000;;				x.Pattern, ok = v12.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for pattern: %+v (%T)", v12, v12)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_items = 13;
0000000000000000000000000000000000000000;;			v13 := compiler.MapValueForKey(m, "maxItems")
0000000000000000000000000000000000000000;;			if v13 != nil {
0000000000000000000000000000000000000000;;				t, ok := v13.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxItems: %+v (%T)", v13, v13)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_items = 14;
0000000000000000000000000000000000000000;;			v14 := compiler.MapValueForKey(m, "minItems")
0000000000000000000000000000000000000000;;			if v14 != nil {
0000000000000000000000000000000000000000;;				t, ok := v14.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minItems: %+v (%T)", v14, v14)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool unique_items = 15;
0000000000000000000000000000000000000000;;			v15 := compiler.MapValueForKey(m, "uniqueItems")
0000000000000000000000000000000000000000;;			if v15 != nil {
0000000000000000000000000000000000000000;;				x.UniqueItems, ok = v15.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for uniqueItems: %+v (%T)", v15, v15)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated Any enum = 16;
0000000000000000000000000000000000000000;;			v16 := compiler.MapValueForKey(m, "enum")
0000000000000000000000000000000000000000;;			if v16 != nil {
0000000000000000000000000000000000000000;;				// repeated Any
0000000000000000000000000000000000000000;;				x.Enum = make([]*Any, 0)
0000000000000000000000000000000000000000;;				a, ok := v16.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewAny(item, compiler.NewContext("enum", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Enum = append(x.Enum, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float multiple_of = 17;
0000000000000000000000000000000000000000;;			v17 := compiler.MapValueForKey(m, "multipleOf")
0000000000000000000000000000000000000000;;			if v17 != nil {
0000000000000000000000000000000000000000;;				switch v17 := v17.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.MultipleOf = v17
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v17)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for multipleOf: %+v (%T)", v17, v17)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 18;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewProperties(in interface{}, context *compiler.Context) (*Properties, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Properties{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedSchema additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: Schema
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedSchema, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedSchema{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					pair.Value, err = NewSchema(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errors = append(errors, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewQueryParameterSubSchema(in interface{}, context *compiler.Context) (*QueryParameterSubSchema, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &QueryParameterSubSchema{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"allowEmptyValue", "collectionFormat", "default", "description", "enum", "exclusiveMaximum", "exclusiveMinimum", "format", "in", "items", "maxItems", "maxLength", "maximum", "minItems", "minLength", "minimum", "multipleOf", "name", "pattern", "required", "type", "uniqueItems"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool required = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "required")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Required, ok = v1.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for required: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string in = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "in")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.In, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [query]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"query"}, x.In) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for in: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool allow_empty_value = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "allowEmptyValue")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				x.AllowEmptyValue, ok = v5.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for allowEmptyValue: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string type = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				x.Type, ok = v6.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [string number boolean integer array]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"string", "number", "boolean", "integer", "array"}, x.Type) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for type: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string format = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "format")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				x.Format, ok = v7.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for format: %+v (%T)", v7, v7)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// PrimitivesItems items = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "items")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Items, err = NewPrimitivesItems(v8, compiler.NewContext("items", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string collection_format = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "collectionFormat")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				x.CollectionFormat, ok = v9.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v9, v9)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for valid enum values
0000000000000000000000000000000000000000;;				// [csv ssv tsv pipes multi]
0000000000000000000000000000000000000000;;				if ok && !compiler.StringArrayContainsValue([]string{"csv", "ssv", "tsv", "pipes", "multi"}, x.CollectionFormat) {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for collectionFormat: %+v (%T)", v9, v9)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any default = 10;
0000000000000000000000000000000000000000;;			v10 := compiler.MapValueForKey(m, "default")
0000000000000000000000000000000000000000;;			if v10 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Default, err = NewAny(v10, compiler.NewContext("default", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float maximum = 11;
0000000000000000000000000000000000000000;;			v11 := compiler.MapValueForKey(m, "maximum")
0000000000000000000000000000000000000000;;			if v11 != nil {
0000000000000000000000000000000000000000;;				switch v11 := v11.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Maximum = v11
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v11)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maximum: %+v (%T)", v11, v11)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_maximum = 12;
0000000000000000000000000000000000000000;;			v12 := compiler.MapValueForKey(m, "exclusiveMaximum")
0000000000000000000000000000000000000000;;			if v12 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMaximum, ok = v12.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMaximum: %+v (%T)", v12, v12)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float minimum = 13;
0000000000000000000000000000000000000000;;			v13 := compiler.MapValueForKey(m, "minimum")
0000000000000000000000000000000000000000;;			if v13 != nil {
0000000000000000000000000000000000000000;;				switch v13 := v13.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Minimum = v13
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v13)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minimum: %+v (%T)", v13, v13)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_minimum = 14;
0000000000000000000000000000000000000000;;			v14 := compiler.MapValueForKey(m, "exclusiveMinimum")
0000000000000000000000000000000000000000;;			if v14 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMinimum, ok = v14.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMinimum: %+v (%T)", v14, v14)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_length = 15;
0000000000000000000000000000000000000000;;			v15 := compiler.MapValueForKey(m, "maxLength")
0000000000000000000000000000000000000000;;			if v15 != nil {
0000000000000000000000000000000000000000;;				t, ok := v15.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxLength: %+v (%T)", v15, v15)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_length = 16;
0000000000000000000000000000000000000000;;			v16 := compiler.MapValueForKey(m, "minLength")
0000000000000000000000000000000000000000;;			if v16 != nil {
0000000000000000000000000000000000000000;;				t, ok := v16.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minLength: %+v (%T)", v16, v16)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string pattern = 17;
0000000000000000000000000000000000000000;;			v17 := compiler.MapValueForKey(m, "pattern")
0000000000000000000000000000000000000000;;			if v17 != nil {
0000000000000000000000000000000000000000;;				x.Pattern, ok = v17.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for pattern: %+v (%T)", v17, v17)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_items = 18;
0000000000000000000000000000000000000000;;			v18 := compiler.MapValueForKey(m, "maxItems")
0000000000000000000000000000000000000000;;			if v18 != nil {
0000000000000000000000000000000000000000;;				t, ok := v18.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxItems: %+v (%T)", v18, v18)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_items = 19;
0000000000000000000000000000000000000000;;			v19 := compiler.MapValueForKey(m, "minItems")
0000000000000000000000000000000000000000;;			if v19 != nil {
0000000000000000000000000000000000000000;;				t, ok := v19.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minItems: %+v (%T)", v19, v19)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool unique_items = 20;
0000000000000000000000000000000000000000;;			v20 := compiler.MapValueForKey(m, "uniqueItems")
0000000000000000000000000000000000000000;;			if v20 != nil {
0000000000000000000000000000000000000000;;				x.UniqueItems, ok = v20.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for uniqueItems: %+v (%T)", v20, v20)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated Any enum = 21;
0000000000000000000000000000000000000000;;			v21 := compiler.MapValueForKey(m, "enum")
0000000000000000000000000000000000000000;;			if v21 != nil {
0000000000000000000000000000000000000000;;				// repeated Any
0000000000000000000000000000000000000000;;				x.Enum = make([]*Any, 0)
0000000000000000000000000000000000000000;;				a, ok := v21.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewAny(item, compiler.NewContext("enum", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Enum = append(x.Enum, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float multiple_of = 22;
0000000000000000000000000000000000000000;;			v22 := compiler.MapValueForKey(m, "multipleOf")
0000000000000000000000000000000000000000;;			if v22 != nil {
0000000000000000000000000000000000000000;;				switch v22 := v22.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.MultipleOf = v22
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v22)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for multipleOf: %+v (%T)", v22, v22)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 23;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResponse(in interface{}, context *compiler.Context) (*Response, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Response{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"description"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"description", "examples", "headers", "schema"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// SchemaItem schema = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "schema")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Schema, err = NewSchemaItem(v2, compiler.NewContext("schema", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Headers headers = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "headers")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Headers, err = NewHeaders(v3, compiler.NewContext("headers", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Examples examples = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "examples")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Examples, err = NewExamples(v4, compiler.NewContext("examples", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 5;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResponseDefinitions(in interface{}, context *compiler.Context) (*ResponseDefinitions, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &ResponseDefinitions{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedResponse additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: Response
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedResponse, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedResponse{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					pair.Value, err = NewResponse(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errors = append(errors, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResponseValue(in interface{}, context *compiler.Context) (*ResponseValue, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &ResponseValue{}
0000000000000000000000000000000000000000;;		matched := false
0000000000000000000000000000000000000000;;		// Response response = 1;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewResponse(m, compiler.NewContext("response", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &ResponseValue_Response{Response: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// JsonReference json_reference = 2;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewJsonReference(m, compiler.NewContext("jsonReference", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &ResponseValue_JsonReference{JsonReference: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matched {
0000000000000000000000000000000000000000;;			// since the oneof matched one of its possibilities, discard any matching errors
0000000000000000000000000000000000000000;;			errors = make([]error, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResponses(in interface{}, context *compiler.Context) (*Responses, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Responses{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^([0-9]{3})$|^(default)$", "^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedResponseValue response_code = 1;
0000000000000000000000000000000000000000;;			// MAP: ResponseValue ^([0-9]{3})$|^(default)$
0000000000000000000000000000000000000000;;			x.ResponseCode = make([]*NamedResponseValue, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^([0-9]{3})$|^(default)$", k) {
0000000000000000000000000000000000000000;;						pair := &NamedResponseValue{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						var err error
0000000000000000000000000000000000000000;;						pair.Value, err = NewResponseValue(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.ResponseCode = append(x.ResponseCode, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 2;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSchema(in interface{}, context *compiler.Context) (*Schema, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Schema{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"$ref", "additionalProperties", "allOf", "default", "description", "discriminator", "enum", "example", "exclusiveMaximum", "exclusiveMinimum", "externalDocs", "format", "items", "maxItems", "maxLength", "maxProperties", "maximum", "minItems", "minLength", "minProperties", "minimum", "multipleOf", "pattern", "properties", "readOnly", "required", "title", "type", "uniqueItems", "xml"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string _ref = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "$ref")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.XRef, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for $ref: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string format = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "format")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Format, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for format: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string title = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "title")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Title, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for title: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v4.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any default = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "default")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Default, err = NewAny(v5, compiler.NewContext("default", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float multiple_of = 6;
0000000000000000000000000000000000000000;;			v6 := compiler.MapValueForKey(m, "multipleOf")
0000000000000000000000000000000000000000;;			if v6 != nil {
0000000000000000000000000000000000000000;;				switch v6 := v6.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.MultipleOf = v6
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v6)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v6)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v6)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v6)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v6)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.MultipleOf = float64(v6)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for multipleOf: %+v (%T)", v6, v6)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float maximum = 7;
0000000000000000000000000000000000000000;;			v7 := compiler.MapValueForKey(m, "maximum")
0000000000000000000000000000000000000000;;			if v7 != nil {
0000000000000000000000000000000000000000;;				switch v7 := v7.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Maximum = v7
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v7)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v7)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v7)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v7)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v7)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Maximum = float64(v7)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maximum: %+v (%T)", v7, v7)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_maximum = 8;
0000000000000000000000000000000000000000;;			v8 := compiler.MapValueForKey(m, "exclusiveMaximum")
0000000000000000000000000000000000000000;;			if v8 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMaximum, ok = v8.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMaximum: %+v (%T)", v8, v8)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// float minimum = 9;
0000000000000000000000000000000000000000;;			v9 := compiler.MapValueForKey(m, "minimum")
0000000000000000000000000000000000000000;;			if v9 != nil {
0000000000000000000000000000000000000000;;				switch v9 := v9.(type) {
0000000000000000000000000000000000000000;;				case float64:
0000000000000000000000000000000000000000;;					x.Minimum = v9
0000000000000000000000000000000000000000;;				case float32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v9)
0000000000000000000000000000000000000000;;				case uint64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v9)
0000000000000000000000000000000000000000;;				case uint32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v9)
0000000000000000000000000000000000000000;;				case int64:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v9)
0000000000000000000000000000000000000000;;				case int32:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v9)
0000000000000000000000000000000000000000;;				case int:
0000000000000000000000000000000000000000;;					x.Minimum = float64(v9)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minimum: %+v (%T)", v9, v9)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool exclusive_minimum = 10;
0000000000000000000000000000000000000000;;			v10 := compiler.MapValueForKey(m, "exclusiveMinimum")
0000000000000000000000000000000000000000;;			if v10 != nil {
0000000000000000000000000000000000000000;;				x.ExclusiveMinimum, ok = v10.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for exclusiveMinimum: %+v (%T)", v10, v10)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_length = 11;
0000000000000000000000000000000000000000;;			v11 := compiler.MapValueForKey(m, "maxLength")
0000000000000000000000000000000000000000;;			if v11 != nil {
0000000000000000000000000000000000000000;;				t, ok := v11.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxLength: %+v (%T)", v11, v11)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_length = 12;
0000000000000000000000000000000000000000;;			v12 := compiler.MapValueForKey(m, "minLength")
0000000000000000000000000000000000000000;;			if v12 != nil {
0000000000000000000000000000000000000000;;				t, ok := v12.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinLength = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minLength: %+v (%T)", v12, v12)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string pattern = 13;
0000000000000000000000000000000000000000;;			v13 := compiler.MapValueForKey(m, "pattern")
0000000000000000000000000000000000000000;;			if v13 != nil {
0000000000000000000000000000000000000000;;				x.Pattern, ok = v13.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for pattern: %+v (%T)", v13, v13)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_items = 14;
0000000000000000000000000000000000000000;;			v14 := compiler.MapValueForKey(m, "maxItems")
0000000000000000000000000000000000000000;;			if v14 != nil {
0000000000000000000000000000000000000000;;				t, ok := v14.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxItems: %+v (%T)", v14, v14)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_items = 15;
0000000000000000000000000000000000000000;;			v15 := compiler.MapValueForKey(m, "minItems")
0000000000000000000000000000000000000000;;			if v15 != nil {
0000000000000000000000000000000000000000;;				t, ok := v15.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinItems = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minItems: %+v (%T)", v15, v15)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool unique_items = 16;
0000000000000000000000000000000000000000;;			v16 := compiler.MapValueForKey(m, "uniqueItems")
0000000000000000000000000000000000000000;;			if v16 != nil {
0000000000000000000000000000000000000000;;				x.UniqueItems, ok = v16.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for uniqueItems: %+v (%T)", v16, v16)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 max_properties = 17;
0000000000000000000000000000000000000000;;			v17 := compiler.MapValueForKey(m, "maxProperties")
0000000000000000000000000000000000000000;;			if v17 != nil {
0000000000000000000000000000000000000000;;				t, ok := v17.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MaxProperties = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for maxProperties: %+v (%T)", v17, v17)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// int64 min_properties = 18;
0000000000000000000000000000000000000000;;			v18 := compiler.MapValueForKey(m, "minProperties")
0000000000000000000000000000000000000000;;			if v18 != nil {
0000000000000000000000000000000000000000;;				t, ok := v18.(int)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.MinProperties = int64(t)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for minProperties: %+v (%T)", v18, v18)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated string required = 19;
0000000000000000000000000000000000000000;;			v19 := compiler.MapValueForKey(m, "required")
0000000000000000000000000000000000000000;;			if v19 != nil {
0000000000000000000000000000000000000000;;				v, ok := v19.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.Required = compiler.ConvertInterfaceArrayToStringArray(v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for required: %+v (%T)", v19, v19)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated Any enum = 20;
0000000000000000000000000000000000000000;;			v20 := compiler.MapValueForKey(m, "enum")
0000000000000000000000000000000000000000;;			if v20 != nil {
0000000000000000000000000000000000000000;;				// repeated Any
0000000000000000000000000000000000000000;;				x.Enum = make([]*Any, 0)
0000000000000000000000000000000000000000;;				a, ok := v20.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewAny(item, compiler.NewContext("enum", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.Enum = append(x.Enum, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// AdditionalPropertiesItem additional_properties = 21;
0000000000000000000000000000000000000000;;			v21 := compiler.MapValueForKey(m, "additionalProperties")
0000000000000000000000000000000000000000;;			if v21 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.AdditionalProperties, err = NewAdditionalPropertiesItem(v21, compiler.NewContext("additionalProperties", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TypeItem type = 22;
0000000000000000000000000000000000000000;;			v22 := compiler.MapValueForKey(m, "type")
0000000000000000000000000000000000000000;;			if v22 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Type, err = NewTypeItem(v22, compiler.NewContext("type", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ItemsItem items = 23;
0000000000000000000000000000000000000000;;			v23 := compiler.MapValueForKey(m, "items")
0000000000000000000000000000000000000000;;			if v23 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Items, err = NewItemsItem(v23, compiler.NewContext("items", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated Schema all_of = 24;
0000000000000000000000000000000000000000;;			v24 := compiler.MapValueForKey(m, "allOf")
0000000000000000000000000000000000000000;;			if v24 != nil {
0000000000000000000000000000000000000000;;				// repeated Schema
0000000000000000000000000000000000000000;;				x.AllOf = make([]*Schema, 0)
0000000000000000000000000000000000000000;;				a, ok := v24.([]interface{})
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					for _, item := range a {
0000000000000000000000000000000000000000;;						y, err := NewSchema(item, compiler.NewContext("allOf", context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.AllOf = append(x.AllOf, y)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Properties properties = 25;
0000000000000000000000000000000000000000;;			v25 := compiler.MapValueForKey(m, "properties")
0000000000000000000000000000000000000000;;			if v25 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Properties, err = NewProperties(v25, compiler.NewContext("properties", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string discriminator = 26;
0000000000000000000000000000000000000000;;			v26 := compiler.MapValueForKey(m, "discriminator")
0000000000000000000000000000000000000000;;			if v26 != nil {
0000000000000000000000000000000000000000;;				x.Discriminator, ok = v26.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for discriminator: %+v (%T)", v26, v26)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool read_only = 27;
0000000000000000000000000000000000000000;;			v27 := compiler.MapValueForKey(m, "readOnly")
0000000000000000000000000000000000000000;;			if v27 != nil {
0000000000000000000000000000000000000000;;				x.ReadOnly, ok = v27.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for readOnly: %+v (%T)", v27, v27)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Xml xml = 28;
0000000000000000000000000000000000000000;;			v28 := compiler.MapValueForKey(m, "xml")
0000000000000000000000000000000000000000;;			if v28 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Xml, err = NewXml(v28, compiler.NewContext("xml", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ExternalDocs external_docs = 29;
0000000000000000000000000000000000000000;;			v29 := compiler.MapValueForKey(m, "externalDocs")
0000000000000000000000000000000000000000;;			if v29 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.ExternalDocs, err = NewExternalDocs(v29, compiler.NewContext("externalDocs", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any example = 30;
0000000000000000000000000000000000000000;;			v30 := compiler.MapValueForKey(m, "example")
0000000000000000000000000000000000000000;;			if v30 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.Example, err = NewAny(v30, compiler.NewContext("example", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 31;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSchemaItem(in interface{}, context *compiler.Context) (*SchemaItem, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &SchemaItem{}
0000000000000000000000000000000000000000;;		matched := false
0000000000000000000000000000000000000000;;		// Schema schema = 1;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewSchema(m, compiler.NewContext("schema", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &SchemaItem_Schema{Schema: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// FileSchema file_schema = 2;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewFileSchema(m, compiler.NewContext("fileSchema", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &SchemaItem_FileSchema{FileSchema: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matched {
0000000000000000000000000000000000000000;;			// since the oneof matched one of its possibilities, discard any matching errors
0000000000000000000000000000000000000000;;			errors = make([]error, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSecurityDefinitions(in interface{}, context *compiler.Context) (*SecurityDefinitions, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &SecurityDefinitions{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedSecurityDefinitionsItem additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: SecurityDefinitionsItem
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedSecurityDefinitionsItem, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedSecurityDefinitionsItem{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					pair.Value, err = NewSecurityDefinitionsItem(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errors = append(errors, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSecurityDefinitionsItem(in interface{}, context *compiler.Context) (*SecurityDefinitionsItem, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &SecurityDefinitionsItem{}
0000000000000000000000000000000000000000;;		matched := false
0000000000000000000000000000000000000000;;		// BasicAuthenticationSecurity basic_authentication_security = 1;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewBasicAuthenticationSecurity(m, compiler.NewContext("basicAuthenticationSecurity", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &SecurityDefinitionsItem_BasicAuthenticationSecurity{BasicAuthenticationSecurity: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// ApiKeySecurity api_key_security = 2;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewApiKeySecurity(m, compiler.NewContext("apiKeySecurity", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &SecurityDefinitionsItem_ApiKeySecurity{ApiKeySecurity: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Oauth2ImplicitSecurity oauth2_implicit_security = 3;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewOauth2ImplicitSecurity(m, compiler.NewContext("oauth2ImplicitSecurity", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &SecurityDefinitionsItem_Oauth2ImplicitSecurity{Oauth2ImplicitSecurity: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Oauth2PasswordSecurity oauth2_password_security = 4;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewOauth2PasswordSecurity(m, compiler.NewContext("oauth2PasswordSecurity", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &SecurityDefinitionsItem_Oauth2PasswordSecurity{Oauth2PasswordSecurity: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Oauth2ApplicationSecurity oauth2_application_security = 5;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewOauth2ApplicationSecurity(m, compiler.NewContext("oauth2ApplicationSecurity", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &SecurityDefinitionsItem_Oauth2ApplicationSecurity{Oauth2ApplicationSecurity: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Oauth2AccessCodeSecurity oauth2_access_code_security = 6;
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// errors might be ok here, they mean we just don't have the right subtype
0000000000000000000000000000000000000000;;				t, matching_error := NewOauth2AccessCodeSecurity(m, compiler.NewContext("oauth2AccessCodeSecurity", context))
0000000000000000000000000000000000000000;;				if matching_error == nil {
0000000000000000000000000000000000000000;;					x.Oneof = &SecurityDefinitionsItem_Oauth2AccessCodeSecurity{Oauth2AccessCodeSecurity: t}
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errors = append(errors, matching_error)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matched {
0000000000000000000000000000000000000000;;			// since the oneof matched one of its possibilities, discard any matching errors
0000000000000000000000000000000000000000;;			errors = make([]error, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSecurityRequirement(in interface{}, context *compiler.Context) (*SecurityRequirement, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &SecurityRequirement{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedStringArray additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: StringArray
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedStringArray, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedStringArray{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					pair.Value, err = NewStringArray(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errors = append(errors, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewStringArray(in interface{}, context *compiler.Context) (*StringArray, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &StringArray{}
0000000000000000000000000000000000000000;;		a, ok := in.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value for StringArray: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			x.Value = make([]string, 0)
0000000000000000000000000000000000000000;;			for _, s := range a {
0000000000000000000000000000000000000000;;				x.Value = append(x.Value, s.(string))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewTag(in interface{}, context *compiler.Context) (*Tag, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Tag{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			requiredKeys := []string{"name"}
0000000000000000000000000000000000000000;;			missingKeys := compiler.MissingKeysInMap(m, requiredKeys)
0000000000000000000000000000000000000000;;			if len(missingKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("is missing required %s: %+v", compiler.PluralProperties(len(missingKeys)), strings.Join(missingKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allowedKeys := []string{"description", "externalDocs", "name"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string description = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "description")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Description, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for description: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ExternalDocs external_docs = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "externalDocs")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				x.ExternalDocs, err = NewExternalDocs(v3, compiler.NewContext("externalDocs", context))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 4;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewTypeItem(in interface{}, context *compiler.Context) (*TypeItem, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &TypeItem{}
0000000000000000000000000000000000000000;;		switch in := in.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			x.Value = make([]string, 0)
0000000000000000000000000000000000000000;;			x.Value = append(x.Value, in)
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			x.Value = make([]string, 0)
0000000000000000000000000000000000000000;;			for _, v := range in {
0000000000000000000000000000000000000000;;				value, ok := v.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					x.Value = append(x.Value, value)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for string array element: %+v (%T)", value, value)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value for string array: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewVendorExtension(in interface{}, context *compiler.Context) (*VendorExtension, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &VendorExtension{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// repeated NamedAny additional_properties = 1;
0000000000000000000000000000000000000000;;			// MAP: Any
0000000000000000000000000000000000000000;;			x.AdditionalProperties = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					pair := &NamedAny{}
0000000000000000000000000000000000000000;;					pair.Name = k
0000000000000000000000000000000000000000;;					result := &Any{}
0000000000000000000000000000000000000000;;					handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;					if handled {
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;							result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;							result.Value = resultFromExt
0000000000000000000000000000000000000000;;							pair.Value = result
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errors = append(errors, err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x.AdditionalProperties = append(x.AdditionalProperties, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewXml(in interface{}, context *compiler.Context) (*Xml, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		x := &Xml{}
0000000000000000000000000000000000000000;;		m, ok := compiler.UnpackMap(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("has unexpected value: %+v (%T)", in, in)
0000000000000000000000000000000000000000;;			errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			allowedKeys := []string{"attribute", "name", "namespace", "prefix", "wrapped"}
0000000000000000000000000000000000000000;;			allowedPatterns := []string{"^x-"}
0000000000000000000000000000000000000000;;			invalidKeys := compiler.InvalidKeysInMap(m, allowedKeys, allowedPatterns)
0000000000000000000000000000000000000000;;			if len(invalidKeys) > 0 {
0000000000000000000000000000000000000000;;				message := fmt.Sprintf("has invalid %s: %+v", compiler.PluralProperties(len(invalidKeys)), strings.Join(invalidKeys, ", "))
0000000000000000000000000000000000000000;;				errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string name = 1;
0000000000000000000000000000000000000000;;			v1 := compiler.MapValueForKey(m, "name")
0000000000000000000000000000000000000000;;			if v1 != nil {
0000000000000000000000000000000000000000;;				x.Name, ok = v1.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for name: %+v (%T)", v1, v1)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string namespace = 2;
0000000000000000000000000000000000000000;;			v2 := compiler.MapValueForKey(m, "namespace")
0000000000000000000000000000000000000000;;			if v2 != nil {
0000000000000000000000000000000000000000;;				x.Namespace, ok = v2.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for namespace: %+v (%T)", v2, v2)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// string prefix = 3;
0000000000000000000000000000000000000000;;			v3 := compiler.MapValueForKey(m, "prefix")
0000000000000000000000000000000000000000;;			if v3 != nil {
0000000000000000000000000000000000000000;;				x.Prefix, ok = v3.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for prefix: %+v (%T)", v3, v3)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool attribute = 4;
0000000000000000000000000000000000000000;;			v4 := compiler.MapValueForKey(m, "attribute")
0000000000000000000000000000000000000000;;			if v4 != nil {
0000000000000000000000000000000000000000;;				x.Attribute, ok = v4.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for attribute: %+v (%T)", v4, v4)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// bool wrapped = 5;
0000000000000000000000000000000000000000;;			v5 := compiler.MapValueForKey(m, "wrapped")
0000000000000000000000000000000000000000;;			if v5 != nil {
0000000000000000000000000000000000000000;;				x.Wrapped, ok = v5.(bool)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					message := fmt.Sprintf("has unexpected value for wrapped: %+v (%T)", v5, v5)
0000000000000000000000000000000000000000;;					errors = append(errors, compiler.NewError(context, message))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// repeated NamedAny vendor_extension = 6;
0000000000000000000000000000000000000000;;			// MAP: Any ^x-
0000000000000000000000000000000000000000;;			x.VendorExtension = make([]*NamedAny, 0)
0000000000000000000000000000000000000000;;			for _, item := range m {
0000000000000000000000000000000000000000;;				k, ok := item.Key.(string)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					v := item.Value
0000000000000000000000000000000000000000;;					if compiler.PatternMatches("^x-", k) {
0000000000000000000000000000000000000000;;						pair := &NamedAny{}
0000000000000000000000000000000000000000;;						pair.Name = k
0000000000000000000000000000000000000000;;						result := &Any{}
0000000000000000000000000000000000000000;;						handled, resultFromExt, err := compiler.HandleExtension(context, v, k)
0000000000000000000000000000000000000000;;						if handled {
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								bytes, _ := yaml.Marshal(v)
0000000000000000000000000000000000000000;;								result.Yaml = string(bytes)
0000000000000000000000000000000000000000;;								result.Value = resultFromExt
0000000000000000000000000000000000000000;;								pair.Value = result
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							pair.Value, err = NewAny(v, compiler.NewContext(k, context))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								errors = append(errors, err)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.VendorExtension = append(x.VendorExtension, pair)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *AdditionalPropertiesItem) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*AdditionalPropertiesItem_Schema)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.Schema.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Any) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ApiKeySecurity) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *BasicAuthenticationSecurity) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *BodyParameter) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Schema != nil {
0000000000000000000000000000000000000000;;			_, err := m.Schema.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Contact) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Default) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Definitions) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Document) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Info != nil {
0000000000000000000000000000000000000000;;			_, err := m.Info.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Paths != nil {
0000000000000000000000000000000000000000;;			_, err := m.Paths.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Definitions != nil {
0000000000000000000000000000000000000000;;			_, err := m.Definitions.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Parameters != nil {
0000000000000000000000000000000000000000;;			_, err := m.Parameters.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Responses != nil {
0000000000000000000000000000000000000000;;			_, err := m.Responses.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Security {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.SecurityDefinitions != nil {
0000000000000000000000000000000000000000;;			_, err := m.SecurityDefinitions.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Tags {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.ExternalDocs != nil {
0000000000000000000000000000000000000000;;			_, err := m.ExternalDocs.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Examples) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ExternalDocs) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *FileSchema) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Default != nil {
0000000000000000000000000000000000000000;;			_, err := m.Default.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.ExternalDocs != nil {
0000000000000000000000000000000000000000;;			_, err := m.ExternalDocs.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Example != nil {
0000000000000000000000000000000000000000;;			_, err := m.Example.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *FormDataParameterSubSchema) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Items != nil {
0000000000000000000000000000000000000000;;			_, err := m.Items.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Default != nil {
0000000000000000000000000000000000000000;;			_, err := m.Default.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Enum {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Header) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Items != nil {
0000000000000000000000000000000000000000;;			_, err := m.Items.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Default != nil {
0000000000000000000000000000000000000000;;			_, err := m.Default.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Enum {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *HeaderParameterSubSchema) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Items != nil {
0000000000000000000000000000000000000000;;			_, err := m.Items.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Default != nil {
0000000000000000000000000000000000000000;;			_, err := m.Default.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Enum {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Headers) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Info) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Contact != nil {
0000000000000000000000000000000000000000;;			_, err := m.Contact.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.License != nil {
0000000000000000000000000000000000000000;;			_, err := m.License.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ItemsItem) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.Schema {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *JsonReference) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.XRef != "" {
0000000000000000000000000000000000000000;;			info, err := compiler.ReadInfoForRef(root, m.XRef)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if info != nil {
0000000000000000000000000000000000000000;;				replacement, err := NewJsonReference(info, nil)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					*m = *replacement
0000000000000000000000000000000000000000;;					return m.ResolveReferences(root)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return info, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *License) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NamedAny) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Value != nil {
0000000000000000000000000000000000000000;;			_, err := m.Value.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NamedHeader) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Value != nil {
0000000000000000000000000000000000000000;;			_, err := m.Value.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NamedParameter) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Value != nil {
0000000000000000000000000000000000000000;;			_, err := m.Value.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NamedPathItem) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Value != nil {
0000000000000000000000000000000000000000;;			_, err := m.Value.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NamedResponse) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Value != nil {
0000000000000000000000000000000000000000;;			_, err := m.Value.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NamedResponseValue) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Value != nil {
0000000000000000000000000000000000000000;;			_, err := m.Value.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NamedSchema) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Value != nil {
0000000000000000000000000000000000000000;;			_, err := m.Value.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NamedSecurityDefinitionsItem) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Value != nil {
0000000000000000000000000000000000000000;;			_, err := m.Value.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NamedString) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NamedStringArray) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Value != nil {
0000000000000000000000000000000000000000;;			_, err := m.Value.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *NonBodyParameter) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*NonBodyParameter_HeaderParameterSubSchema)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.HeaderParameterSubSchema.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*NonBodyParameter_FormDataParameterSubSchema)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.FormDataParameterSubSchema.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*NonBodyParameter_QueryParameterSubSchema)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.QueryParameterSubSchema.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*NonBodyParameter_PathParameterSubSchema)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.PathParameterSubSchema.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Oauth2AccessCodeSecurity) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Scopes != nil {
0000000000000000000000000000000000000000;;			_, err := m.Scopes.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Oauth2ApplicationSecurity) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Scopes != nil {
0000000000000000000000000000000000000000;;			_, err := m.Scopes.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Oauth2ImplicitSecurity) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Scopes != nil {
0000000000000000000000000000000000000000;;			_, err := m.Scopes.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Oauth2PasswordSecurity) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Scopes != nil {
0000000000000000000000000000000000000000;;			_, err := m.Scopes.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Oauth2Scopes) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Operation) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.ExternalDocs != nil {
0000000000000000000000000000000000000000;;			_, err := m.ExternalDocs.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Parameters {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Responses != nil {
0000000000000000000000000000000000000000;;			_, err := m.Responses.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Security {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Parameter) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*Parameter_BodyParameter)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.BodyParameter.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*Parameter_NonBodyParameter)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.NonBodyParameter.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ParameterDefinitions) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ParametersItem) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*ParametersItem_Parameter)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.Parameter.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*ParametersItem_JsonReference)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				info, err := p.JsonReference.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				} else if info != nil {
0000000000000000000000000000000000000000;;					n, err := NewParametersItem(info, nil)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					} else if n != nil {
0000000000000000000000000000000000000000;;						*m = *n
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *PathItem) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.XRef != "" {
0000000000000000000000000000000000000000;;			info, err := compiler.ReadInfoForRef(root, m.XRef)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if info != nil {
0000000000000000000000000000000000000000;;				replacement, err := NewPathItem(info, nil)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					*m = *replacement
0000000000000000000000000000000000000000;;					return m.ResolveReferences(root)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return info, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Get != nil {
0000000000000000000000000000000000000000;;			_, err := m.Get.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Put != nil {
0000000000000000000000000000000000000000;;			_, err := m.Put.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Post != nil {
0000000000000000000000000000000000000000;;			_, err := m.Post.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Delete != nil {
0000000000000000000000000000000000000000;;			_, err := m.Delete.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Options != nil {
0000000000000000000000000000000000000000;;			_, err := m.Options.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Head != nil {
0000000000000000000000000000000000000000;;			_, err := m.Head.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Patch != nil {
0000000000000000000000000000000000000000;;			_, err := m.Patch.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Parameters {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *PathParameterSubSchema) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Items != nil {
0000000000000000000000000000000000000000;;			_, err := m.Items.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Default != nil {
0000000000000000000000000000000000000000;;			_, err := m.Default.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Enum {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Paths) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Path {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *PrimitivesItems) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Items != nil {
0000000000000000000000000000000000000000;;			_, err := m.Items.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Default != nil {
0000000000000000000000000000000000000000;;			_, err := m.Default.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Enum {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Properties) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *QueryParameterSubSchema) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Items != nil {
0000000000000000000000000000000000000000;;			_, err := m.Items.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Default != nil {
0000000000000000000000000000000000000000;;			_, err := m.Default.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Enum {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Response) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.Schema != nil {
0000000000000000000000000000000000000000;;			_, err := m.Schema.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Headers != nil {
0000000000000000000000000000000000000000;;			_, err := m.Headers.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Examples != nil {
0000000000000000000000000000000000000000;;			_, err := m.Examples.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ResponseDefinitions) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ResponseValue) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*ResponseValue_Response)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.Response.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*ResponseValue_JsonReference)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				info, err := p.JsonReference.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				} else if info != nil {
0000000000000000000000000000000000000000;;					n, err := NewResponseValue(info, nil)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					} else if n != nil {
0000000000000000000000000000000000000000;;						*m = *n
0000000000000000000000000000000000000000;;						return nil, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Responses) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.ResponseCode {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Schema) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.XRef != "" {
0000000000000000000000000000000000000000;;			info, err := compiler.ReadInfoForRef(root, m.XRef)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if info != nil {
0000000000000000000000000000000000000000;;				replacement, err := NewSchema(info, nil)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					*m = *replacement
0000000000000000000000000000000000000000;;					return m.ResolveReferences(root)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return info, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Default != nil {
0000000000000000000000000000000000000000;;			_, err := m.Default.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.Enum {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.AdditionalProperties != nil {
0000000000000000000000000000000000000000;;			_, err := m.AdditionalProperties.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Type != nil {
0000000000000000000000000000000000000000;;			_, err := m.Type.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Items != nil {
0000000000000000000000000000000000000000;;			_, err := m.Items.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.AllOf {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Properties != nil {
0000000000000000000000000000000000000000;;			_, err := m.Properties.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Xml != nil {
0000000000000000000000000000000000000000;;			_, err := m.Xml.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.ExternalDocs != nil {
0000000000000000000000000000000000000000;;			_, err := m.ExternalDocs.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Example != nil {
0000000000000000000000000000000000000000;;			_, err := m.Example.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *SchemaItem) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*SchemaItem_Schema)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.Schema.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*SchemaItem_FileSchema)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.FileSchema.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *SecurityDefinitions) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *SecurityDefinitionsItem) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*SecurityDefinitionsItem_BasicAuthenticationSecurity)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.BasicAuthenticationSecurity.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*SecurityDefinitionsItem_ApiKeySecurity)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.ApiKeySecurity.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*SecurityDefinitionsItem_Oauth2ImplicitSecurity)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.Oauth2ImplicitSecurity.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*SecurityDefinitionsItem_Oauth2PasswordSecurity)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.Oauth2PasswordSecurity.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*SecurityDefinitionsItem_Oauth2ApplicationSecurity)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.Oauth2ApplicationSecurity.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			p, ok := m.Oneof.(*SecurityDefinitionsItem_Oauth2AccessCodeSecurity)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				_, err := p.Oauth2AccessCodeSecurity.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *SecurityRequirement) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *StringArray) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Tag) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		if m.ExternalDocs != nil {
0000000000000000000000000000000000000000;;			_, err := m.ExternalDocs.ResolveReferences(root)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *TypeItem) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *VendorExtension) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.AdditionalProperties {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Xml) ResolveReferences(root string) (interface{}, error) {
0000000000000000000000000000000000000000;;		errors := make([]error, 0)
0000000000000000000000000000000000000000;;		for _, item := range m.VendorExtension {
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				_, err := item.ResolveReferences(root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errors = append(errors, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, compiler.NewErrorGroupOrNil(errors)
0000000000000000000000000000000000000000;;	}
