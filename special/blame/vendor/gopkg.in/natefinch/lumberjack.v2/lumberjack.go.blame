0000000000000000000000000000000000000000;;	// Package lumberjack provides a rolling logger.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that this is v2.0 of lumberjack, and should be imported using gopkg.in
0000000000000000000000000000000000000000;;	// thusly:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   import "gopkg.in/natefinch/lumberjack.v2"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The package name remains simply lumberjack, and the code resides at
0000000000000000000000000000000000000000;;	// https://github.com/natefinch/lumberjack under the v2.0 branch.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Lumberjack is intended to be one part of a logging infrastructure.
0000000000000000000000000000000000000000;;	// It is not an all-in-one solution, but instead is a pluggable
0000000000000000000000000000000000000000;;	// component at the bottom of the logging stack that simply controls the files
0000000000000000000000000000000000000000;;	// to which logs are written.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Lumberjack plays well with any logging package that can write to an
0000000000000000000000000000000000000000;;	// io.Writer, including the standard library's log package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Lumberjack assumes that only one process is writing to the output files.
0000000000000000000000000000000000000000;;	// Using the same lumberjack configuration from multiple processes on the same
0000000000000000000000000000000000000000;;	// machine will result in improper behavior.
0000000000000000000000000000000000000000;;	package lumberjack
e8cf22b73534e2943b6376fbac535ae2fb4b668d;Godeps/_workspace/src/gopkg.in/natefinch/lumberjack.v2/lumberjack.go[Godeps/_workspace/src/gopkg.in/natefinch/lumberjack.v2/lumberjack.go][vendor/gopkg.in/natefinch/lumberjack.v2/lumberjack.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		backupTimeFormat = "2006-01-02T15-04-05.000"
0000000000000000000000000000000000000000;;		defaultMaxSize   = 100
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensure we always implement io.WriteCloser
0000000000000000000000000000000000000000;;	var _ io.WriteCloser = (*Logger)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Logger is an io.WriteCloser that writes to the specified filename.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Logger opens or creates the logfile on first Write.  If the file exists and
0000000000000000000000000000000000000000;;	// is less than MaxSize megabytes, lumberjack will open and append to that file.
0000000000000000000000000000000000000000;;	// If the file exists and its size is >= MaxSize megabytes, the file is renamed
0000000000000000000000000000000000000000;;	// by putting the current time in a timestamp in the name immediately before the
0000000000000000000000000000000000000000;;	// file's extension (or the end of the filename if there's no extension). A new
0000000000000000000000000000000000000000;;	// log file is then created using original filename.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Whenever a write would cause the current log file exceed MaxSize megabytes,
0000000000000000000000000000000000000000;;	// the current file is closed, renamed, and a new log file created with the
0000000000000000000000000000000000000000;;	// original name. Thus, the filename you give Logger is always the "current" log
0000000000000000000000000000000000000000;;	// file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Cleaning Up Old Log Files
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Whenever a new logfile gets created, old log files may be deleted.  The most
0000000000000000000000000000000000000000;;	// recent files according to the encoded timestamp will be retained, up to a
0000000000000000000000000000000000000000;;	// number equal to MaxBackups (or all of them if MaxBackups is 0).  Any files
0000000000000000000000000000000000000000;;	// with an encoded timestamp older than MaxAge days are deleted, regardless of
0000000000000000000000000000000000000000;;	// MaxBackups.  Note that the time encoded in the timestamp is the rotation
0000000000000000000000000000000000000000;;	// time, which may differ from the last time that file was written to.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If MaxBackups and MaxAge are both 0, no old log files will be deleted.
0000000000000000000000000000000000000000;;	type Logger struct {
0000000000000000000000000000000000000000;;		// Filename is the file to write logs to.  Backup log files will be retained
0000000000000000000000000000000000000000;;		// in the same directory.  It uses <processname>-lumberjack.log in
0000000000000000000000000000000000000000;;		// os.TempDir() if empty.
0000000000000000000000000000000000000000;;		Filename string `json:"filename" yaml:"filename"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxSize is the maximum size in megabytes of the log file before it gets
0000000000000000000000000000000000000000;;		// rotated. It defaults to 100 megabytes.
0000000000000000000000000000000000000000;;		MaxSize int `json:"maxsize" yaml:"maxsize"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxAge is the maximum number of days to retain old log files based on the
0000000000000000000000000000000000000000;;		// timestamp encoded in their filename.  Note that a day is defined as 24
0000000000000000000000000000000000000000;;		// hours and may not exactly correspond to calendar days due to daylight
0000000000000000000000000000000000000000;;		// savings, leap seconds, etc. The default is not to remove old log files
0000000000000000000000000000000000000000;;		// based on age.
0000000000000000000000000000000000000000;;		MaxAge int `json:"maxage" yaml:"maxage"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxBackups is the maximum number of old log files to retain.  The default
0000000000000000000000000000000000000000;;		// is to retain all old log files (though MaxAge may still cause them to get
0000000000000000000000000000000000000000;;		// deleted.)
0000000000000000000000000000000000000000;;		MaxBackups int `json:"maxbackups" yaml:"maxbackups"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LocalTime determines if the time used for formatting the timestamps in
0000000000000000000000000000000000000000;;		// backup files is the computer's local time.  The default is to use UTC
0000000000000000000000000000000000000000;;		// time.
0000000000000000000000000000000000000000;;		LocalTime bool `json:"localtime" yaml:"localtime"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size int64
0000000000000000000000000000000000000000;;		file *os.File
0000000000000000000000000000000000000000;;		mu   sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// currentTime exists so it can be mocked out by tests.
0000000000000000000000000000000000000000;;		currentTime = time.Now
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// os_Stat exists so it can be mocked out by tests.
0000000000000000000000000000000000000000;;		os_Stat = os.Stat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// megabyte is the conversion factor between MaxSize and bytes.  It is a
0000000000000000000000000000000000000000;;		// variable so tests can mock it out and not need to write megabytes of data
0000000000000000000000000000000000000000;;		// to disk.
0000000000000000000000000000000000000000;;		megabyte = 1024 * 1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write implements io.Writer.  If a write would cause the log file to be larger
0000000000000000000000000000000000000000;;	// than MaxSize, the file is closed, renamed to include a timestamp of the
0000000000000000000000000000000000000000;;	// current time, and a new log file is created using the original log file name.
0000000000000000000000000000000000000000;;	// If the length of the write is greater than MaxSize, an error is returned.
0000000000000000000000000000000000000000;;	func (l *Logger) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		defer l.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		writeLen := int64(len(p))
0000000000000000000000000000000000000000;;		if writeLen > l.max() {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf(
0000000000000000000000000000000000000000;;				"write length %d exceeds maximum file size %d", writeLen, l.max(),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.file == nil {
0000000000000000000000000000000000000000;;			if err = l.openExistingOrNew(len(p)); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.size+writeLen > l.max() {
0000000000000000000000000000000000000000;;			if err := l.rotate(); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err = l.file.Write(p)
0000000000000000000000000000000000000000;;		l.size += int64(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close implements io.Closer, and closes the current logfile.
0000000000000000000000000000000000000000;;	func (l *Logger) Close() error {
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		defer l.mu.Unlock()
0000000000000000000000000000000000000000;;		return l.close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// close closes the file if it is open.
0000000000000000000000000000000000000000;;	func (l *Logger) close() error {
0000000000000000000000000000000000000000;;		if l.file == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := l.file.Close()
0000000000000000000000000000000000000000;;		l.file = nil
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rotate causes Logger to close the existing log file and immediately create a
0000000000000000000000000000000000000000;;	// new one.  This is a helper function for applications that want to initiate
0000000000000000000000000000000000000000;;	// rotations outside of the normal rotation rules, such as in response to
0000000000000000000000000000000000000000;;	// SIGHUP.  After rotating, this initiates a cleanup of old log files according
0000000000000000000000000000000000000000;;	// to the normal rules.
0000000000000000000000000000000000000000;;	func (l *Logger) Rotate() error {
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		defer l.mu.Unlock()
0000000000000000000000000000000000000000;;		return l.rotate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rotate closes the current file, moves it aside with a timestamp in the name,
0000000000000000000000000000000000000000;;	// (if it exists), opens a new file with the original filename, and then runs
0000000000000000000000000000000000000000;;	// cleanup.
0000000000000000000000000000000000000000;;	func (l *Logger) rotate() error {
0000000000000000000000000000000000000000;;		if err := l.close(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := l.openNew(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.cleanup()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// openNew opens a new log file for writing, moving any old log file out of the
0000000000000000000000000000000000000000;;	// way.  This methods assumes the file has already been closed.
0000000000000000000000000000000000000000;;	func (l *Logger) openNew() error {
0000000000000000000000000000000000000000;;		err := os.MkdirAll(l.dir(), 0744)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't make directories for new logfile: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := l.filename()
0000000000000000000000000000000000000000;;		mode := os.FileMode(0644)
0000000000000000000000000000000000000000;;		info, err := os_Stat(name)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// Copy the mode off the old logfile.
0000000000000000000000000000000000000000;;			mode = info.Mode()
0000000000000000000000000000000000000000;;			// move the existing file
0000000000000000000000000000000000000000;;			newname := backupName(name, l.LocalTime)
0000000000000000000000000000000000000000;;			if err := os.Rename(name, newname); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("can't rename log file: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// this is a no-op anywhere but linux
0000000000000000000000000000000000000000;;			if err := chown(name, info); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we use truncate here because this should only get called when we've moved
0000000000000000000000000000000000000000;;		// the file ourselves. if someone else creates the file in the meantime,
0000000000000000000000000000000000000000;;		// just wipe out the contents.
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(name, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, mode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't open new logfile: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.file = f
0000000000000000000000000000000000000000;;		l.size = 0
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// backupName creates a new filename from the given name, inserting a timestamp
0000000000000000000000000000000000000000;;	// between the filename and the extension, using the local time if requested
0000000000000000000000000000000000000000;;	// (otherwise UTC).
0000000000000000000000000000000000000000;;	func backupName(name string, local bool) string {
0000000000000000000000000000000000000000;;		dir := filepath.Dir(name)
0000000000000000000000000000000000000000;;		filename := filepath.Base(name)
0000000000000000000000000000000000000000;;		ext := filepath.Ext(filename)
0000000000000000000000000000000000000000;;		prefix := filename[:len(filename)-len(ext)]
0000000000000000000000000000000000000000;;		t := currentTime()
0000000000000000000000000000000000000000;;		if !local {
0000000000000000000000000000000000000000;;			t = t.UTC()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timestamp := t.Format(backupTimeFormat)
0000000000000000000000000000000000000000;;		return filepath.Join(dir, fmt.Sprintf("%s-%s%s", prefix, timestamp, ext))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// openExistingOrNew opens the logfile if it exists and if the current write
0000000000000000000000000000000000000000;;	// would not put it over MaxSize.  If there is no such file or the write would
0000000000000000000000000000000000000000;;	// put it over the MaxSize, a new file is created.
0000000000000000000000000000000000000000;;	func (l *Logger) openExistingOrNew(writeLen int) error {
0000000000000000000000000000000000000000;;		filename := l.filename()
0000000000000000000000000000000000000000;;		info, err := os_Stat(filename)
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return l.openNew()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error getting log file info: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if info.Size()+int64(writeLen) >= l.max() {
0000000000000000000000000000000000000000;;			return l.rotate()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		file, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if we fail to open the old log file for some reason, just ignore
0000000000000000000000000000000000000000;;			// it and open a new log file.
0000000000000000000000000000000000000000;;			return l.openNew()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.file = file
0000000000000000000000000000000000000000;;		l.size = info.Size()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genFilename generates the name of the logfile from the current time.
0000000000000000000000000000000000000000;;	func (l *Logger) filename() string {
0000000000000000000000000000000000000000;;		if l.Filename != "" {
0000000000000000000000000000000000000000;;			return l.Filename
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := filepath.Base(os.Args[0]) + "-lumberjack.log"
0000000000000000000000000000000000000000;;		return filepath.Join(os.TempDir(), name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cleanup deletes old log files, keeping at most l.MaxBackups files, as long as
0000000000000000000000000000000000000000;;	// none of them are older than MaxAge.
0000000000000000000000000000000000000000;;	func (l *Logger) cleanup() error {
0000000000000000000000000000000000000000;;		if l.MaxBackups == 0 && l.MaxAge == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		files, err := l.oldLogFiles()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var deletes []logInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.MaxBackups > 0 && l.MaxBackups < len(files) {
0000000000000000000000000000000000000000;;			deletes = files[l.MaxBackups:]
0000000000000000000000000000000000000000;;			files = files[:l.MaxBackups]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.MaxAge > 0 {
0000000000000000000000000000000000000000;;			diff := time.Duration(int64(24*time.Hour) * int64(l.MaxAge))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cutoff := currentTime().Add(-1 * diff)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, f := range files {
0000000000000000000000000000000000000000;;				if f.timestamp.Before(cutoff) {
0000000000000000000000000000000000000000;;					deletes = append(deletes, f)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(deletes) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go deleteAll(l.dir(), deletes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deleteAll(dir string, files []logInfo) {
0000000000000000000000000000000000000000;;		// remove files on a separate goroutine
0000000000000000000000000000000000000000;;		for _, f := range files {
0000000000000000000000000000000000000000;;			// what am I going to do, log this?
0000000000000000000000000000000000000000;;			_ = os.Remove(filepath.Join(dir, f.Name()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// oldLogFiles returns the list of backup log files stored in the same
0000000000000000000000000000000000000000;;	// directory as the current log file, sorted by ModTime
0000000000000000000000000000000000000000;;	func (l *Logger) oldLogFiles() ([]logInfo, error) {
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(l.dir())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("can't read log file directory: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		logFiles := []logInfo{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prefix, ext := l.prefixAndExt()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range files {
0000000000000000000000000000000000000000;;			if f.IsDir() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name := l.timeFromName(f.Name(), prefix, ext)
0000000000000000000000000000000000000000;;			if name == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t, err := time.Parse(backupTimeFormat, name)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				logFiles = append(logFiles, logInfo{t, f})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// error parsing means that the suffix at the end was not generated
0000000000000000000000000000000000000000;;			// by lumberjack, and therefore it's not a backup file.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Sort(byFormatTime(logFiles))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return logFiles, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timeFromName extracts the formatted time from the filename by stripping off
0000000000000000000000000000000000000000;;	// the filename's prefix and extension. This prevents someone's filename from
0000000000000000000000000000000000000000;;	// confusing time.parse.
0000000000000000000000000000000000000000;;	func (l *Logger) timeFromName(filename, prefix, ext string) string {
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(filename, prefix) {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		filename = filename[len(prefix):]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(filename, ext) {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		filename = filename[:len(filename)-len(ext)]
0000000000000000000000000000000000000000;;		return filename
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// max returns the maximum size in bytes of log files before rolling.
0000000000000000000000000000000000000000;;	func (l *Logger) max() int64 {
0000000000000000000000000000000000000000;;		if l.MaxSize == 0 {
0000000000000000000000000000000000000000;;			return int64(defaultMaxSize * megabyte)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int64(l.MaxSize) * int64(megabyte)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dir returns the directory for the current filename.
0000000000000000000000000000000000000000;;	func (l *Logger) dir() string {
0000000000000000000000000000000000000000;;		return filepath.Dir(l.filename())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prefixAndExt returns the filename part and extension part from the Logger's
0000000000000000000000000000000000000000;;	// filename.
0000000000000000000000000000000000000000;;	func (l *Logger) prefixAndExt() (prefix, ext string) {
0000000000000000000000000000000000000000;;		filename := filepath.Base(l.filename())
0000000000000000000000000000000000000000;;		ext = filepath.Ext(filename)
0000000000000000000000000000000000000000;;		prefix = filename[:len(filename)-len(ext)] + "-"
0000000000000000000000000000000000000000;;		return prefix, ext
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logInfo is a convenience struct to return the filename and its embedded
0000000000000000000000000000000000000000;;	// timestamp.
0000000000000000000000000000000000000000;;	type logInfo struct {
0000000000000000000000000000000000000000;;		timestamp time.Time
0000000000000000000000000000000000000000;;		os.FileInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// byFormatTime sorts by newest time formatted in the name.
0000000000000000000000000000000000000000;;	type byFormatTime []logInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b byFormatTime) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return b[i].timestamp.After(b[j].timestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b byFormatTime) Swap(i, j int) {
0000000000000000000000000000000000000000;;		b[i], b[j] = b[j], b[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b byFormatTime) Len() int {
0000000000000000000000000000000000000000;;		return len(b)
0000000000000000000000000000000000000000;;	}
