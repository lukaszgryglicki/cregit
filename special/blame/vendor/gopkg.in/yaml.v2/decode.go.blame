0000000000000000000000000000000000000000;;	package yaml
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/gopkg.in/v2/yaml/decode.go[Godeps/_workspace/src/gopkg.in/v2/yaml/decode.go][vendor/gopkg.in/yaml.v2/decode.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		documentNode = 1 << iota
0000000000000000000000000000000000000000;;		mappingNode
0000000000000000000000000000000000000000;;		sequenceNode
0000000000000000000000000000000000000000;;		scalarNode
0000000000000000000000000000000000000000;;		aliasNode
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type node struct {
0000000000000000000000000000000000000000;;		kind         int
0000000000000000000000000000000000000000;;		line, column int
0000000000000000000000000000000000000000;;		tag          string
0000000000000000000000000000000000000000;;		value        string
0000000000000000000000000000000000000000;;		implicit     bool
0000000000000000000000000000000000000000;;		children     []*node
0000000000000000000000000000000000000000;;		anchors      map[string]*node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Parser, produces a node tree out of a libyaml event stream.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type parser struct {
0000000000000000000000000000000000000000;;		parser yaml_parser_t
0000000000000000000000000000000000000000;;		event  yaml_event_t
0000000000000000000000000000000000000000;;		doc    *node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newParser(b []byte) *parser {
0000000000000000000000000000000000000000;;		p := parser{}
0000000000000000000000000000000000000000;;		if !yaml_parser_initialize(&p.parser) {
0000000000000000000000000000000000000000;;			panic("failed to initialize YAML emitter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b) == 0 {
0000000000000000000000000000000000000000;;			b = []byte{'\n'}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_parser_set_input_string(&p.parser, b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.skip()
0000000000000000000000000000000000000000;;		if p.event.typ != yaml_STREAM_START_EVENT {
0000000000000000000000000000000000000000;;			panic("expected stream start event, got " + strconv.Itoa(int(p.event.typ)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.skip()
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) destroy() {
0000000000000000000000000000000000000000;;		if p.event.typ != yaml_NO_EVENT {
0000000000000000000000000000000000000000;;			yaml_event_delete(&p.event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_parser_delete(&p.parser)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) skip() {
0000000000000000000000000000000000000000;;		if p.event.typ != yaml_NO_EVENT {
0000000000000000000000000000000000000000;;			if p.event.typ == yaml_STREAM_END_EVENT {
0000000000000000000000000000000000000000;;				failf("attempted to go past the end of stream; corrupted value?")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			yaml_event_delete(&p.event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !yaml_parser_parse(&p.parser, &p.event) {
0000000000000000000000000000000000000000;;			p.fail()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) fail() {
0000000000000000000000000000000000000000;;		var where string
0000000000000000000000000000000000000000;;		var line int
0000000000000000000000000000000000000000;;		if p.parser.problem_mark.line != 0 {
0000000000000000000000000000000000000000;;			line = p.parser.problem_mark.line
0000000000000000000000000000000000000000;;		} else if p.parser.context_mark.line != 0 {
0000000000000000000000000000000000000000;;			line = p.parser.context_mark.line
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if line != 0 {
0000000000000000000000000000000000000000;;			where = "line " + strconv.Itoa(line) + ": "
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var msg string
0000000000000000000000000000000000000000;;		if len(p.parser.problem) > 0 {
0000000000000000000000000000000000000000;;			msg = p.parser.problem
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			msg = "unknown problem parsing YAML content"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		failf("%s%s", where, msg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) anchor(n *node, anchor []byte) {
0000000000000000000000000000000000000000;;		if anchor != nil {
0000000000000000000000000000000000000000;;			p.doc.anchors[string(anchor)] = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) parse() *node {
0000000000000000000000000000000000000000;;		switch p.event.typ {
0000000000000000000000000000000000000000;;		case yaml_SCALAR_EVENT:
0000000000000000000000000000000000000000;;			return p.scalar()
0000000000000000000000000000000000000000;;		case yaml_ALIAS_EVENT:
0000000000000000000000000000000000000000;;			return p.alias()
0000000000000000000000000000000000000000;;		case yaml_MAPPING_START_EVENT:
0000000000000000000000000000000000000000;;			return p.mapping()
0000000000000000000000000000000000000000;;		case yaml_SEQUENCE_START_EVENT:
0000000000000000000000000000000000000000;;			return p.sequence()
0000000000000000000000000000000000000000;;		case yaml_DOCUMENT_START_EVENT:
0000000000000000000000000000000000000000;;			return p.document()
0000000000000000000000000000000000000000;;		case yaml_STREAM_END_EVENT:
0000000000000000000000000000000000000000;;			// Happens when attempting to decode an empty buffer.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("attempted to parse unknown event: " + strconv.Itoa(int(p.event.typ)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) node(kind int) *node {
0000000000000000000000000000000000000000;;		return &node{
0000000000000000000000000000000000000000;;			kind:   kind,
0000000000000000000000000000000000000000;;			line:   p.event.start_mark.line,
0000000000000000000000000000000000000000;;			column: p.event.start_mark.column,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) document() *node {
0000000000000000000000000000000000000000;;		n := p.node(documentNode)
0000000000000000000000000000000000000000;;		n.anchors = make(map[string]*node)
0000000000000000000000000000000000000000;;		p.doc = n
0000000000000000000000000000000000000000;;		p.skip()
0000000000000000000000000000000000000000;;		n.children = append(n.children, p.parse())
0000000000000000000000000000000000000000;;		if p.event.typ != yaml_DOCUMENT_END_EVENT {
0000000000000000000000000000000000000000;;			panic("expected end of document event but got " + strconv.Itoa(int(p.event.typ)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.skip()
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) alias() *node {
0000000000000000000000000000000000000000;;		n := p.node(aliasNode)
0000000000000000000000000000000000000000;;		n.value = string(p.event.anchor)
0000000000000000000000000000000000000000;;		p.skip()
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) scalar() *node {
0000000000000000000000000000000000000000;;		n := p.node(scalarNode)
0000000000000000000000000000000000000000;;		n.value = string(p.event.value)
0000000000000000000000000000000000000000;;		n.tag = string(p.event.tag)
0000000000000000000000000000000000000000;;		n.implicit = p.event.implicit
0000000000000000000000000000000000000000;;		p.anchor(n, p.event.anchor)
0000000000000000000000000000000000000000;;		p.skip()
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) sequence() *node {
0000000000000000000000000000000000000000;;		n := p.node(sequenceNode)
0000000000000000000000000000000000000000;;		p.anchor(n, p.event.anchor)
0000000000000000000000000000000000000000;;		p.skip()
0000000000000000000000000000000000000000;;		for p.event.typ != yaml_SEQUENCE_END_EVENT {
0000000000000000000000000000000000000000;;			n.children = append(n.children, p.parse())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.skip()
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) mapping() *node {
0000000000000000000000000000000000000000;;		n := p.node(mappingNode)
0000000000000000000000000000000000000000;;		p.anchor(n, p.event.anchor)
0000000000000000000000000000000000000000;;		p.skip()
0000000000000000000000000000000000000000;;		for p.event.typ != yaml_MAPPING_END_EVENT {
0000000000000000000000000000000000000000;;			n.children = append(n.children, p.parse(), p.parse())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.skip()
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Decoder, unmarshals a node into a provided value.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decoder struct {
0000000000000000000000000000000000000000;;		doc     *node
0000000000000000000000000000000000000000;;		aliases map[string]bool
0000000000000000000000000000000000000000;;		mapType reflect.Type
0000000000000000000000000000000000000000;;		terrors []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		mapItemType    = reflect.TypeOf(MapItem{})
0000000000000000000000000000000000000000;;		durationType   = reflect.TypeOf(time.Duration(0))
0000000000000000000000000000000000000000;;		defaultMapType = reflect.TypeOf(map[interface{}]interface{}{})
0000000000000000000000000000000000000000;;		ifaceType      = defaultMapType.Elem()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDecoder() *decoder {
0000000000000000000000000000000000000000;;		d := &decoder{mapType: defaultMapType}
0000000000000000000000000000000000000000;;		d.aliases = make(map[string]bool)
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) terror(n *node, tag string, out reflect.Value) {
0000000000000000000000000000000000000000;;		if n.tag != "" {
0000000000000000000000000000000000000000;;			tag = n.tag
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value := n.value
0000000000000000000000000000000000000000;;		if tag != yaml_SEQ_TAG && tag != yaml_MAP_TAG {
0000000000000000000000000000000000000000;;			if len(value) > 10 {
0000000000000000000000000000000000000000;;				value = " `" + value[:7] + "...`"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				value = " `" + value + "`"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.terrors = append(d.terrors, fmt.Sprintf("line %d: cannot unmarshal %s%s into %s", n.line+1, shortTag(tag), value, out.Type()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) callUnmarshaler(n *node, u Unmarshaler) (good bool) {
0000000000000000000000000000000000000000;;		terrlen := len(d.terrors)
0000000000000000000000000000000000000000;;		err := u.UnmarshalYAML(func(v interface{}) (err error) {
0000000000000000000000000000000000000000;;			defer handleErr(&err)
0000000000000000000000000000000000000000;;			d.unmarshal(n, reflect.ValueOf(v))
0000000000000000000000000000000000000000;;			if len(d.terrors) > terrlen {
0000000000000000000000000000000000000000;;				issues := d.terrors[terrlen:]
0000000000000000000000000000000000000000;;				d.terrors = d.terrors[:terrlen]
0000000000000000000000000000000000000000;;				return &TypeError{issues}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if e, ok := err.(*TypeError); ok {
0000000000000000000000000000000000000000;;			d.terrors = append(d.terrors, e.Errors...)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fail(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// d.prepare initializes and dereferences pointers and calls UnmarshalYAML
0000000000000000000000000000000000000000;;	// if a value is found to implement it.
0000000000000000000000000000000000000000;;	// It returns the initialized and dereferenced out value, whether
0000000000000000000000000000000000000000;;	// unmarshalling was already done by UnmarshalYAML, and if so whether
0000000000000000000000000000000000000000;;	// its types unmarshalled appropriately.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If n holds a null value, prepare returns before doing anything.
0000000000000000000000000000000000000000;;	func (d *decoder) prepare(n *node, out reflect.Value) (newout reflect.Value, unmarshaled, good bool) {
0000000000000000000000000000000000000000;;		if n.tag == yaml_NULL_TAG || n.kind == scalarNode && n.tag == "" && (n.value == "null" || n.value == "") {
0000000000000000000000000000000000000000;;			return out, false, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		again := true
0000000000000000000000000000000000000000;;		for again {
0000000000000000000000000000000000000000;;			again = false
0000000000000000000000000000000000000000;;			if out.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				if out.IsNil() {
0000000000000000000000000000000000000000;;					out.Set(reflect.New(out.Type().Elem()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out = out.Elem()
0000000000000000000000000000000000000000;;				again = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out.CanAddr() {
0000000000000000000000000000000000000000;;				if u, ok := out.Addr().Interface().(Unmarshaler); ok {
0000000000000000000000000000000000000000;;					good = d.callUnmarshaler(n, u)
0000000000000000000000000000000000000000;;					return out, true, good
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, false, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) unmarshal(n *node, out reflect.Value) (good bool) {
0000000000000000000000000000000000000000;;		switch n.kind {
0000000000000000000000000000000000000000;;		case documentNode:
0000000000000000000000000000000000000000;;			return d.document(n, out)
0000000000000000000000000000000000000000;;		case aliasNode:
0000000000000000000000000000000000000000;;			return d.alias(n, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out, unmarshaled, good := d.prepare(n, out)
0000000000000000000000000000000000000000;;		if unmarshaled {
0000000000000000000000000000000000000000;;			return good
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch n.kind {
0000000000000000000000000000000000000000;;		case scalarNode:
0000000000000000000000000000000000000000;;			good = d.scalar(n, out)
0000000000000000000000000000000000000000;;		case mappingNode:
0000000000000000000000000000000000000000;;			good = d.mapping(n, out)
0000000000000000000000000000000000000000;;		case sequenceNode:
0000000000000000000000000000000000000000;;			good = d.sequence(n, out)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("internal error: unknown node kind: " + strconv.Itoa(n.kind))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return good
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) document(n *node, out reflect.Value) (good bool) {
0000000000000000000000000000000000000000;;		if len(n.children) == 1 {
0000000000000000000000000000000000000000;;			d.doc = n
0000000000000000000000000000000000000000;;			d.unmarshal(n.children[0], out)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) alias(n *node, out reflect.Value) (good bool) {
0000000000000000000000000000000000000000;;		an, ok := d.doc.anchors[n.value]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			failf("unknown anchor '%s' referenced", n.value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.aliases[n.value] {
0000000000000000000000000000000000000000;;			failf("anchor '%s' value contains itself", n.value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.aliases[n.value] = true
0000000000000000000000000000000000000000;;		good = d.unmarshal(an, out)
0000000000000000000000000000000000000000;;		delete(d.aliases, n.value)
0000000000000000000000000000000000000000;;		return good
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var zeroValue reflect.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func resetMap(out reflect.Value) {
0000000000000000000000000000000000000000;;		for _, k := range out.MapKeys() {
0000000000000000000000000000000000000000;;			out.SetMapIndex(k, zeroValue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) scalar(n *node, out reflect.Value) (good bool) {
0000000000000000000000000000000000000000;;		var tag string
0000000000000000000000000000000000000000;;		var resolved interface{}
0000000000000000000000000000000000000000;;		if n.tag == "" && !n.implicit {
0000000000000000000000000000000000000000;;			tag = yaml_STR_TAG
0000000000000000000000000000000000000000;;			resolved = n.value
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			tag, resolved = resolve(n.tag, n.value)
0000000000000000000000000000000000000000;;			if tag == yaml_BINARY_TAG {
0000000000000000000000000000000000000000;;				data, err := base64.StdEncoding.DecodeString(resolved.(string))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					failf("!!binary value contains invalid base64 data")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				resolved = string(data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resolved == nil {
0000000000000000000000000000000000000000;;			if out.Kind() == reflect.Map && !out.CanAddr() {
0000000000000000000000000000000000000000;;				resetMap(out)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out.Set(reflect.Zero(out.Type()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s, ok := resolved.(string); ok && out.CanAddr() {
0000000000000000000000000000000000000000;;			if u, ok := out.Addr().Interface().(encoding.TextUnmarshaler); ok {
0000000000000000000000000000000000000000;;				err := u.UnmarshalText([]byte(s))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					fail(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch out.Kind() {
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			if tag == yaml_BINARY_TAG {
0000000000000000000000000000000000000000;;				out.SetString(resolved.(string))
0000000000000000000000000000000000000000;;				good = true
0000000000000000000000000000000000000000;;			} else if resolved != nil {
0000000000000000000000000000000000000000;;				out.SetString(n.value)
0000000000000000000000000000000000000000;;				good = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if resolved == nil {
0000000000000000000000000000000000000000;;				out.Set(reflect.Zero(out.Type()))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out.Set(reflect.ValueOf(resolved))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			good = true
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			switch resolved := resolved.(type) {
0000000000000000000000000000000000000000;;			case int:
0000000000000000000000000000000000000000;;				if !out.OverflowInt(int64(resolved)) {
0000000000000000000000000000000000000000;;					out.SetInt(int64(resolved))
0000000000000000000000000000000000000000;;					good = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case int64:
0000000000000000000000000000000000000000;;				if !out.OverflowInt(resolved) {
0000000000000000000000000000000000000000;;					out.SetInt(resolved)
0000000000000000000000000000000000000000;;					good = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case uint64:
0000000000000000000000000000000000000000;;				if resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {
0000000000000000000000000000000000000000;;					out.SetInt(int64(resolved))
0000000000000000000000000000000000000000;;					good = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case float64:
0000000000000000000000000000000000000000;;				if resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {
0000000000000000000000000000000000000000;;					out.SetInt(int64(resolved))
0000000000000000000000000000000000000000;;					good = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case string:
0000000000000000000000000000000000000000;;				if out.Type() == durationType {
0000000000000000000000000000000000000000;;					d, err := time.ParseDuration(resolved)
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						out.SetInt(int64(d))
0000000000000000000000000000000000000000;;						good = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			switch resolved := resolved.(type) {
0000000000000000000000000000000000000000;;			case int:
0000000000000000000000000000000000000000;;				if resolved >= 0 && !out.OverflowUint(uint64(resolved)) {
0000000000000000000000000000000000000000;;					out.SetUint(uint64(resolved))
0000000000000000000000000000000000000000;;					good = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case int64:
0000000000000000000000000000000000000000;;				if resolved >= 0 && !out.OverflowUint(uint64(resolved)) {
0000000000000000000000000000000000000000;;					out.SetUint(uint64(resolved))
0000000000000000000000000000000000000000;;					good = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case uint64:
0000000000000000000000000000000000000000;;				if !out.OverflowUint(uint64(resolved)) {
0000000000000000000000000000000000000000;;					out.SetUint(uint64(resolved))
0000000000000000000000000000000000000000;;					good = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case float64:
0000000000000000000000000000000000000000;;				if resolved <= math.MaxUint64 && !out.OverflowUint(uint64(resolved)) {
0000000000000000000000000000000000000000;;					out.SetUint(uint64(resolved))
0000000000000000000000000000000000000000;;					good = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			switch resolved := resolved.(type) {
0000000000000000000000000000000000000000;;			case bool:
0000000000000000000000000000000000000000;;				out.SetBool(resolved)
0000000000000000000000000000000000000000;;				good = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			switch resolved := resolved.(type) {
0000000000000000000000000000000000000000;;			case int:
0000000000000000000000000000000000000000;;				out.SetFloat(float64(resolved))
0000000000000000000000000000000000000000;;				good = true
0000000000000000000000000000000000000000;;			case int64:
0000000000000000000000000000000000000000;;				out.SetFloat(float64(resolved))
0000000000000000000000000000000000000000;;				good = true
0000000000000000000000000000000000000000;;			case uint64:
0000000000000000000000000000000000000000;;				out.SetFloat(float64(resolved))
0000000000000000000000000000000000000000;;				good = true
0000000000000000000000000000000000000000;;			case float64:
0000000000000000000000000000000000000000;;				out.SetFloat(resolved)
0000000000000000000000000000000000000000;;				good = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if out.Type().Elem() == reflect.TypeOf(resolved) {
0000000000000000000000000000000000000000;;				// TODO DOes this make sense? When is out a Ptr except when decoding a nil value?
0000000000000000000000000000000000000000;;				elem := reflect.New(out.Type().Elem())
0000000000000000000000000000000000000000;;				elem.Elem().Set(reflect.ValueOf(resolved))
0000000000000000000000000000000000000000;;				out.Set(elem)
0000000000000000000000000000000000000000;;				good = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !good {
0000000000000000000000000000000000000000;;			d.terror(n, tag, out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return good
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func settableValueOf(i interface{}) reflect.Value {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(i)
0000000000000000000000000000000000000000;;		sv := reflect.New(v.Type()).Elem()
0000000000000000000000000000000000000000;;		sv.Set(v)
0000000000000000000000000000000000000000;;		return sv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) sequence(n *node, out reflect.Value) (good bool) {
0000000000000000000000000000000000000000;;		l := len(n.children)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var iface reflect.Value
0000000000000000000000000000000000000000;;		switch out.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			out.Set(reflect.MakeSlice(out.Type(), l, l))
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			// No type hints. Will have to use a generic sequence.
0000000000000000000000000000000000000000;;			iface = out
0000000000000000000000000000000000000000;;			out = settableValueOf(make([]interface{}, l))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.terror(n, yaml_SEQ_TAG, out)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		et := out.Type().Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j := 0
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			e := reflect.New(et).Elem()
0000000000000000000000000000000000000000;;			if ok := d.unmarshal(n.children[i], e); ok {
0000000000000000000000000000000000000000;;				out.Index(j).Set(e)
0000000000000000000000000000000000000000;;				j++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Set(out.Slice(0, j))
0000000000000000000000000000000000000000;;		if iface.IsValid() {
0000000000000000000000000000000000000000;;			iface.Set(out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) mapping(n *node, out reflect.Value) (good bool) {
0000000000000000000000000000000000000000;;		switch out.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return d.mappingStruct(n, out)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			return d.mappingSlice(n, out)
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			// okay
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if d.mapType.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;				iface := out
0000000000000000000000000000000000000000;;				out = reflect.MakeMap(d.mapType)
0000000000000000000000000000000000000000;;				iface.Set(out)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				slicev := reflect.New(d.mapType).Elem()
0000000000000000000000000000000000000000;;				if !d.mappingSlice(n, slicev) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out.Set(slicev)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.terror(n, yaml_MAP_TAG, out)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		outt := out.Type()
0000000000000000000000000000000000000000;;		kt := outt.Key()
0000000000000000000000000000000000000000;;		et := outt.Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapType := d.mapType
0000000000000000000000000000000000000000;;		if outt.Key() == ifaceType && outt.Elem() == ifaceType {
0000000000000000000000000000000000000000;;			d.mapType = outt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if out.IsNil() {
0000000000000000000000000000000000000000;;			out.Set(reflect.MakeMap(outt))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := len(n.children)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i += 2 {
0000000000000000000000000000000000000000;;			if isMerge(n.children[i]) {
0000000000000000000000000000000000000000;;				d.merge(n.children[i+1], out)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			k := reflect.New(kt).Elem()
0000000000000000000000000000000000000000;;			if d.unmarshal(n.children[i], k) {
0000000000000000000000000000000000000000;;				kkind := k.Kind()
0000000000000000000000000000000000000000;;				if kkind == reflect.Interface {
0000000000000000000000000000000000000000;;					kkind = k.Elem().Kind()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if kkind == reflect.Map || kkind == reflect.Slice {
0000000000000000000000000000000000000000;;					failf("invalid map key: %#v", k.Interface())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e := reflect.New(et).Elem()
0000000000000000000000000000000000000000;;				if d.unmarshal(n.children[i+1], e) {
0000000000000000000000000000000000000000;;					out.SetMapIndex(k, e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.mapType = mapType
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) mappingSlice(n *node, out reflect.Value) (good bool) {
0000000000000000000000000000000000000000;;		outt := out.Type()
0000000000000000000000000000000000000000;;		if outt.Elem() != mapItemType {
0000000000000000000000000000000000000000;;			d.terror(n, yaml_MAP_TAG, out)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapType := d.mapType
0000000000000000000000000000000000000000;;		d.mapType = outt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var slice []MapItem
0000000000000000000000000000000000000000;;		var l = len(n.children)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i += 2 {
0000000000000000000000000000000000000000;;			if isMerge(n.children[i]) {
0000000000000000000000000000000000000000;;				d.merge(n.children[i+1], out)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			item := MapItem{}
0000000000000000000000000000000000000000;;			k := reflect.ValueOf(&item.Key).Elem()
0000000000000000000000000000000000000000;;			if d.unmarshal(n.children[i], k) {
0000000000000000000000000000000000000000;;				v := reflect.ValueOf(&item.Value).Elem()
0000000000000000000000000000000000000000;;				if d.unmarshal(n.children[i+1], v) {
0000000000000000000000000000000000000000;;					slice = append(slice, item)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Set(reflect.ValueOf(slice))
0000000000000000000000000000000000000000;;		d.mapType = mapType
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) mappingStruct(n *node, out reflect.Value) (good bool) {
0000000000000000000000000000000000000000;;		sinfo, err := getStructInfo(out.Type())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := settableValueOf("")
0000000000000000000000000000000000000000;;		l := len(n.children)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var inlineMap reflect.Value
0000000000000000000000000000000000000000;;		var elemType reflect.Type
0000000000000000000000000000000000000000;;		if sinfo.InlineMap != -1 {
0000000000000000000000000000000000000000;;			inlineMap = out.Field(sinfo.InlineMap)
0000000000000000000000000000000000000000;;			inlineMap.Set(reflect.New(inlineMap.Type()).Elem())
0000000000000000000000000000000000000000;;			elemType = inlineMap.Type().Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < l; i += 2 {
0000000000000000000000000000000000000000;;			ni := n.children[i]
0000000000000000000000000000000000000000;;			if isMerge(ni) {
0000000000000000000000000000000000000000;;				d.merge(n.children[i+1], out)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !d.unmarshal(ni, name) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if info, ok := sinfo.FieldsMap[name.String()]; ok {
0000000000000000000000000000000000000000;;				var field reflect.Value
0000000000000000000000000000000000000000;;				if info.Inline == nil {
0000000000000000000000000000000000000000;;					field = out.Field(info.Num)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					field = out.FieldByIndex(info.Inline)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.unmarshal(n.children[i+1], field)
0000000000000000000000000000000000000000;;			} else if sinfo.InlineMap != -1 {
0000000000000000000000000000000000000000;;				if inlineMap.IsNil() {
0000000000000000000000000000000000000000;;					inlineMap.Set(reflect.MakeMap(inlineMap.Type()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				value := reflect.New(elemType).Elem()
0000000000000000000000000000000000000000;;				d.unmarshal(n.children[i+1], value)
0000000000000000000000000000000000000000;;				inlineMap.SetMapIndex(name, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func failWantMap() {
0000000000000000000000000000000000000000;;		failf("map merge requires map or sequence of maps as the value")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) merge(n *node, out reflect.Value) {
0000000000000000000000000000000000000000;;		switch n.kind {
0000000000000000000000000000000000000000;;		case mappingNode:
0000000000000000000000000000000000000000;;			d.unmarshal(n, out)
0000000000000000000000000000000000000000;;		case aliasNode:
0000000000000000000000000000000000000000;;			an, ok := d.doc.anchors[n.value]
0000000000000000000000000000000000000000;;			if ok && an.kind != mappingNode {
0000000000000000000000000000000000000000;;				failWantMap()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.unmarshal(n, out)
0000000000000000000000000000000000000000;;		case sequenceNode:
0000000000000000000000000000000000000000;;			// Step backwards as earlier nodes take precedence.
0000000000000000000000000000000000000000;;			for i := len(n.children) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;				ni := n.children[i]
0000000000000000000000000000000000000000;;				if ni.kind == aliasNode {
0000000000000000000000000000000000000000;;					an, ok := d.doc.anchors[ni.value]
0000000000000000000000000000000000000000;;					if ok && an.kind != mappingNode {
0000000000000000000000000000000000000000;;						failWantMap()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if ni.kind != mappingNode {
0000000000000000000000000000000000000000;;					failWantMap()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.unmarshal(ni, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			failWantMap()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isMerge(n *node) bool {
0000000000000000000000000000000000000000;;		return n.kind == scalarNode && n.value == "<<" && (n.implicit == true || n.tag == yaml_MERGE_TAG)
0000000000000000000000000000000000000000;;	}
