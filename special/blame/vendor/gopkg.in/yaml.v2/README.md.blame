0000000000000000000000000000000000000000;;	# YAML support for the Go language
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Introduction
0000000000000000000000000000000000000000;;	------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The yaml package enables Go programs to comfortably encode and decode YAML
0000000000000000000000000000000000000000;;	values. It was developed within [Canonical](https://www.canonical.com) as
0000000000000000000000000000000000000000;;	part of the [juju](https://juju.ubuntu.com) project, and is based on a
0000000000000000000000000000000000000000;;	pure Go port of the well-known [libyaml](http://pyyaml.org/wiki/LibYAML)
0000000000000000000000000000000000000000;;	C library to parse and generate YAML data quickly and reliably.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Compatibility
0000000000000000000000000000000000000000;;	-------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The yaml package supports most of YAML 1.1 and 1.2, including support for
0000000000000000000000000000000000000000;;	anchors, tags, map merging, etc. Multi-document unmarshalling is not yet
0000000000000000000000000000000000000000;;	implemented, and base-60 floats from YAML 1.1 are purposefully not
0000000000000000000000000000000000000000;;	supported since they're a poor design and are gone in YAML 1.2.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Installation and usage
0000000000000000000000000000000000000000;;	----------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The import path for the package is *gopkg.in/yaml.v2*.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To install it, run:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    go get gopkg.in/yaml.v2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	API documentation
0000000000000000000000000000000000000000;;	-----------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If opened in a browser, the import path itself leads to the API documentation:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * [https://gopkg.in/yaml.v2](https://gopkg.in/yaml.v2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	API stability
0000000000000000000000000000000000000000;;	-------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The package API for yaml v2 will remain stable as described in [gopkg.in](https://gopkg.in).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	License
0000000000000000000000000000000000000000;;	-------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The yaml package is licensed under the LGPL with an exception that allows it to be linked statically. Please see the LICENSE file for details.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example
0000000000000000000000000000000000000000;;	-------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```Go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;	        "fmt"
0000000000000000000000000000000000000000;;	        "log"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        "gopkg.in/yaml.v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var data = `
0000000000000000000000000000000000000000;;	a: Easy!
0000000000000000000000000000000000000000;;	b:
0000000000000000000000000000000000000000;;	  c: 2
0000000000000000000000000000000000000000;;	  d: [3, 4]
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type T struct {
0000000000000000000000000000000000000000;;	        A string
0000000000000000000000000000000000000000;;	        B struct {
0000000000000000000000000000000000000000;;	                RenamedC int   `yaml:"c"`
0000000000000000000000000000000000000000;;	                D        []int `yaml:",flow"`
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;	        t := T{}
0000000000000000000000000000000000000000;;	    
0000000000000000000000000000000000000000;;	        err := yaml.Unmarshal([]byte(data), &t)
0000000000000000000000000000000000000000;;	        if err != nil {
0000000000000000000000000000000000000000;;	                log.Fatalf("error: %v", err)
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	        fmt.Printf("--- t:\n%v\n\n", t)
0000000000000000000000000000000000000000;;	    
0000000000000000000000000000000000000000;;	        d, err := yaml.Marshal(&t)
0000000000000000000000000000000000000000;;	        if err != nil {
0000000000000000000000000000000000000000;;	                log.Fatalf("error: %v", err)
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	        fmt.Printf("--- t dump:\n%s\n\n", string(d))
0000000000000000000000000000000000000000;;	    
0000000000000000000000000000000000000000;;	        m := make(map[interface{}]interface{})
0000000000000000000000000000000000000000;;	    
0000000000000000000000000000000000000000;;	        err = yaml.Unmarshal([]byte(data), &m)
0000000000000000000000000000000000000000;;	        if err != nil {
0000000000000000000000000000000000000000;;	                log.Fatalf("error: %v", err)
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	        fmt.Printf("--- m:\n%v\n\n", m)
0000000000000000000000000000000000000000;;	    
0000000000000000000000000000000000000000;;	        d, err = yaml.Marshal(&m)
0000000000000000000000000000000000000000;;	        if err != nil {
0000000000000000000000000000000000000000;;	                log.Fatalf("error: %v", err)
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	        fmt.Printf("--- m dump:\n%s\n\n", string(d))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This example will generate the following output:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	--- t:
0000000000000000000000000000000000000000;;	{Easy! {2 [3 4]}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	--- t dump:
0000000000000000000000000000000000000000;;	a: Easy!
0000000000000000000000000000000000000000;;	b:
0000000000000000000000000000000000000000;;	  c: 2
0000000000000000000000000000000000000000;;	  d: [3, 4]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	--- m:
0000000000000000000000000000000000000000;;	map[a:Easy! b:map[c:2 d:[3 4]]]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	--- m dump:
0000000000000000000000000000000000000000;;	a: Easy!
0000000000000000000000000000000000000000;;	b:
0000000000000000000000000000000000000000;;	  c: 2
0000000000000000000000000000000000000000;;	  d:
0000000000000000000000000000000000000000;;	  - 3
0000000000000000000000000000000000000000;;	  - 4
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
