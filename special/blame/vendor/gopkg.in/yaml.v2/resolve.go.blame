0000000000000000000000000000000000000000;;	package yaml
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/gopkg.in/v2/yaml/resolve.go[Godeps/_workspace/src/gopkg.in/v2/yaml/resolve.go][vendor/gopkg.in/yaml.v2/resolve.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type resolveMapItem struct {
0000000000000000000000000000000000000000;;		value interface{}
0000000000000000000000000000000000000000;;		tag   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var resolveTable = make([]byte, 256)
0000000000000000000000000000000000000000;;	var resolveMap = make(map[string]resolveMapItem)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		t := resolveTable
0000000000000000000000000000000000000000;;		t[int('+')] = 'S' // Sign
0000000000000000000000000000000000000000;;		t[int('-')] = 'S'
0000000000000000000000000000000000000000;;		for _, c := range "0123456789" {
0000000000000000000000000000000000000000;;			t[int(c)] = 'D' // Digit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range "yYnNtTfFoO~" {
0000000000000000000000000000000000000000;;			t[int(c)] = 'M' // In map
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t[int('.')] = '.' // Float (potentially in map)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resolveMapList = []struct {
0000000000000000000000000000000000000000;;			v   interface{}
0000000000000000000000000000000000000000;;			tag string
0000000000000000000000000000000000000000;;			l   []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{true, yaml_BOOL_TAG, []string{"y", "Y", "yes", "Yes", "YES"}},
0000000000000000000000000000000000000000;;			{true, yaml_BOOL_TAG, []string{"true", "True", "TRUE"}},
0000000000000000000000000000000000000000;;			{true, yaml_BOOL_TAG, []string{"on", "On", "ON"}},
0000000000000000000000000000000000000000;;			{false, yaml_BOOL_TAG, []string{"n", "N", "no", "No", "NO"}},
0000000000000000000000000000000000000000;;			{false, yaml_BOOL_TAG, []string{"false", "False", "FALSE"}},
0000000000000000000000000000000000000000;;			{false, yaml_BOOL_TAG, []string{"off", "Off", "OFF"}},
0000000000000000000000000000000000000000;;			{nil, yaml_NULL_TAG, []string{"", "~", "null", "Null", "NULL"}},
0000000000000000000000000000000000000000;;			{math.NaN(), yaml_FLOAT_TAG, []string{".nan", ".NaN", ".NAN"}},
0000000000000000000000000000000000000000;;			{math.Inf(+1), yaml_FLOAT_TAG, []string{".inf", ".Inf", ".INF"}},
0000000000000000000000000000000000000000;;			{math.Inf(+1), yaml_FLOAT_TAG, []string{"+.inf", "+.Inf", "+.INF"}},
0000000000000000000000000000000000000000;;			{math.Inf(-1), yaml_FLOAT_TAG, []string{"-.inf", "-.Inf", "-.INF"}},
0000000000000000000000000000000000000000;;			{"<<", yaml_MERGE_TAG, []string{"<<"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := resolveMap
0000000000000000000000000000000000000000;;		for _, item := range resolveMapList {
0000000000000000000000000000000000000000;;			for _, s := range item.l {
0000000000000000000000000000000000000000;;				m[s] = resolveMapItem{item.v, item.tag}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const longTagPrefix = "tag:yaml.org,2002:"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shortTag(tag string) string {
0000000000000000000000000000000000000000;;		// TODO This can easily be made faster and produce less garbage.
0000000000000000000000000000000000000000;;		if strings.HasPrefix(tag, longTagPrefix) {
0000000000000000000000000000000000000000;;			return "!!" + tag[len(longTagPrefix):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func longTag(tag string) string {
0000000000000000000000000000000000000000;;		if strings.HasPrefix(tag, "!!") {
0000000000000000000000000000000000000000;;			return longTagPrefix + tag[2:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func resolvableTag(tag string) bool {
0000000000000000000000000000000000000000;;		switch tag {
0000000000000000000000000000000000000000;;		case "", yaml_STR_TAG, yaml_BOOL_TAG, yaml_INT_TAG, yaml_FLOAT_TAG, yaml_NULL_TAG:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func resolve(tag string, in string) (rtag string, out interface{}) {
0000000000000000000000000000000000000000;;		if !resolvableTag(tag) {
0000000000000000000000000000000000000000;;			return tag, in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			switch tag {
0000000000000000000000000000000000000000;;			case "", rtag, yaml_STR_TAG, yaml_BINARY_TAG:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			failf("cannot decode %s `%s` as a %s", shortTag(rtag), in, shortTag(tag))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Any data is accepted as a !!str or !!binary.
0000000000000000000000000000000000000000;;		// Otherwise, the prefix is enough of a hint about what it might be.
0000000000000000000000000000000000000000;;		hint := byte('N')
0000000000000000000000000000000000000000;;		if in != "" {
0000000000000000000000000000000000000000;;			hint = resolveTable[in[0]]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hint != 0 && tag != yaml_STR_TAG && tag != yaml_BINARY_TAG {
0000000000000000000000000000000000000000;;			// Handle things we can lookup in a map.
0000000000000000000000000000000000000000;;			if item, ok := resolveMap[in]; ok {
0000000000000000000000000000000000000000;;				return item.tag, item.value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Base 60 floats are a bad idea, were dropped in YAML 1.2, and
0000000000000000000000000000000000000000;;			// are purposefully unsupported here. They're still quoted on
0000000000000000000000000000000000000000;;			// the way out for compatibility with other parser, though.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch hint {
0000000000000000000000000000000000000000;;			case 'M':
0000000000000000000000000000000000000000;;				// We've already checked the map above.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '.':
0000000000000000000000000000000000000000;;				// Not in the map, so maybe a normal float.
0000000000000000000000000000000000000000;;				floatv, err := strconv.ParseFloat(in, 64)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					return yaml_FLOAT_TAG, floatv
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case 'D', 'S':
0000000000000000000000000000000000000000;;				// Int, float, or timestamp.
0000000000000000000000000000000000000000;;				plain := strings.Replace(in, "_", "", -1)
0000000000000000000000000000000000000000;;				intv, err := strconv.ParseInt(plain, 0, 64)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					if intv == int64(int(intv)) {
0000000000000000000000000000000000000000;;						return yaml_INT_TAG, int(intv)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return yaml_INT_TAG, intv
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				uintv, err := strconv.ParseUint(plain, 0, 64)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					return yaml_INT_TAG, uintv
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				floatv, err := strconv.ParseFloat(plain, 64)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					return yaml_FLOAT_TAG, floatv
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if strings.HasPrefix(plain, "0b") {
0000000000000000000000000000000000000000;;					intv, err := strconv.ParseInt(plain[2:], 2, 64)
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						if intv == int64(int(intv)) {
0000000000000000000000000000000000000000;;							return yaml_INT_TAG, int(intv)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							return yaml_INT_TAG, intv
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					uintv, err := strconv.ParseUint(plain[2:], 2, 64)
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						return yaml_INT_TAG, uintv
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if strings.HasPrefix(plain, "-0b") {
0000000000000000000000000000000000000000;;					intv, err := strconv.ParseInt(plain[3:], 2, 64)
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						if intv == int64(int(intv)) {
0000000000000000000000000000000000000000;;							return yaml_INT_TAG, -int(intv)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							return yaml_INT_TAG, -intv
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// XXX Handle timestamps here.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("resolveTable item not yet handled: " + string(rune(hint)) + " (with " + in + ")")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tag == yaml_BINARY_TAG {
0000000000000000000000000000000000000000;;			return yaml_BINARY_TAG, in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if utf8.ValidString(in) {
0000000000000000000000000000000000000000;;			return yaml_STR_TAG, in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return yaml_BINARY_TAG, encodeBase64(in)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encodeBase64 encodes s as base64 that is broken up into multiple lines
0000000000000000000000000000000000000000;;	// as appropriate for the resulting length.
0000000000000000000000000000000000000000;;	func encodeBase64(s string) string {
0000000000000000000000000000000000000000;;		const lineLen = 70
0000000000000000000000000000000000000000;;		encLen := base64.StdEncoding.EncodedLen(len(s))
0000000000000000000000000000000000000000;;		lines := encLen/lineLen + 1
0000000000000000000000000000000000000000;;		buf := make([]byte, encLen*2+lines)
0000000000000000000000000000000000000000;;		in := buf[0:encLen]
0000000000000000000000000000000000000000;;		out := buf[encLen:]
0000000000000000000000000000000000000000;;		base64.StdEncoding.Encode(in, []byte(s))
0000000000000000000000000000000000000000;;		k := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(in); i += lineLen {
0000000000000000000000000000000000000000;;			j := i + lineLen
0000000000000000000000000000000000000000;;			if j > len(in) {
0000000000000000000000000000000000000000;;				j = len(in)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			k += copy(out[k:], in[i:j])
0000000000000000000000000000000000000000;;			if lines > 1 {
0000000000000000000000000000000000000000;;				out[k] = '\n'
0000000000000000000000000000000000000000;;				k++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(out[:k])
0000000000000000000000000000000000000000;;	}
