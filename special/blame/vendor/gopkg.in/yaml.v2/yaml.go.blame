0000000000000000000000000000000000000000;;	// Package yaml implements YAML support for the Go language.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Source code and other details for the project are available at GitHub:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   https://github.com/go-yaml/yaml
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package yaml
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/gopkg.in/v2/yaml/yaml.go[Godeps/_workspace/src/gopkg.in/v2/yaml/yaml.go][vendor/gopkg.in/yaml.v2/yaml.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MapSlice encodes and decodes as a YAML map.
0000000000000000000000000000000000000000;;	// The order of keys is preserved when encoding and decoding.
0000000000000000000000000000000000000000;;	type MapSlice []MapItem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MapItem is an item in a MapSlice.
0000000000000000000000000000000000000000;;	type MapItem struct {
0000000000000000000000000000000000000000;;		Key, Value interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Unmarshaler interface may be implemented by types to customize their
0000000000000000000000000000000000000000;;	// behavior when being unmarshaled from a YAML document. The UnmarshalYAML
0000000000000000000000000000000000000000;;	// method receives a function that may be called to unmarshal the original
0000000000000000000000000000000000000000;;	// YAML value into a field or variable. It is safe to call the unmarshal
0000000000000000000000000000000000000000;;	// function parameter more than once if necessary.
0000000000000000000000000000000000000000;;	type Unmarshaler interface {
0000000000000000000000000000000000000000;;		UnmarshalYAML(unmarshal func(interface{}) error) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Marshaler interface may be implemented by types to customize their
0000000000000000000000000000000000000000;;	// behavior when being marshaled into a YAML document. The returned value
0000000000000000000000000000000000000000;;	// is marshaled in place of the original value implementing Marshaler.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If an error is returned by MarshalYAML, the marshaling procedure stops
0000000000000000000000000000000000000000;;	// and returns with the provided error.
0000000000000000000000000000000000000000;;	type Marshaler interface {
0000000000000000000000000000000000000000;;		MarshalYAML() (interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal decodes the first document found within the in byte slice
0000000000000000000000000000000000000000;;	// and assigns decoded values into the out value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Maps and pointers (to a struct, string, int, etc) are accepted as out
0000000000000000000000000000000000000000;;	// values. If an internal pointer within a struct is not initialized,
0000000000000000000000000000000000000000;;	// the yaml package will initialize it if necessary for unmarshalling
0000000000000000000000000000000000000000;;	// the provided data. The out parameter must not be nil.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The type of the decoded values should be compatible with the respective
0000000000000000000000000000000000000000;;	// values in out. If one or more values cannot be decoded due to a type
0000000000000000000000000000000000000000;;	// mismatches, decoding continues partially until the end of the YAML
0000000000000000000000000000000000000000;;	// content, and a *yaml.TypeError is returned with details for all
0000000000000000000000000000000000000000;;	// missed values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Struct fields are only unmarshalled if they are exported (have an
0000000000000000000000000000000000000000;;	// upper case first letter), and are unmarshalled using the field name
0000000000000000000000000000000000000000;;	// lowercased as the default key. Custom keys may be defined via the
0000000000000000000000000000000000000000;;	// "yaml" name in the field tag: the content preceding the first comma
0000000000000000000000000000000000000000;;	// is used as the key, and the following comma-separated options are
0000000000000000000000000000000000000000;;	// used to tweak the marshalling process (see Marshal).
0000000000000000000000000000000000000000;;	// Conflicting names result in a runtime error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     type T struct {
0000000000000000000000000000000000000000;;	//         F int `yaml:"a,omitempty"`
0000000000000000000000000000000000000000;;	//         B int
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//     var t T
0000000000000000000000000000000000000000;;	//     yaml.Unmarshal([]byte("a: 1\nb: 2"), &t)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the documentation of Marshal for the format of tags and a list of
0000000000000000000000000000000000000000;;	// supported tag options.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func Unmarshal(in []byte, out interface{}) (err error) {
0000000000000000000000000000000000000000;;		defer handleErr(&err)
0000000000000000000000000000000000000000;;		d := newDecoder()
0000000000000000000000000000000000000000;;		p := newParser(in)
0000000000000000000000000000000000000000;;		defer p.destroy()
0000000000000000000000000000000000000000;;		node := p.parse()
0000000000000000000000000000000000000000;;		if node != nil {
0000000000000000000000000000000000000000;;			v := reflect.ValueOf(out)
0000000000000000000000000000000000000000;;			if v.Kind() == reflect.Ptr && !v.IsNil() {
0000000000000000000000000000000000000000;;				v = v.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.unmarshal(node, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(d.terrors) > 0 {
0000000000000000000000000000000000000000;;			return &TypeError{d.terrors}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal serializes the value provided into a YAML document. The structure
0000000000000000000000000000000000000000;;	// of the generated document will reflect the structure of the value itself.
0000000000000000000000000000000000000000;;	// Maps and pointers (to struct, string, int, etc) are accepted as the in value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Struct fields are only unmarshalled if they are exported (have an upper case
0000000000000000000000000000000000000000;;	// first letter), and are unmarshalled using the field name lowercased as the
0000000000000000000000000000000000000000;;	// default key. Custom keys may be defined via the "yaml" name in the field
0000000000000000000000000000000000000000;;	// tag: the content preceding the first comma is used as the key, and the
0000000000000000000000000000000000000000;;	// following comma-separated options are used to tweak the marshalling process.
0000000000000000000000000000000000000000;;	// Conflicting names result in a runtime error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The field tag format accepted is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     `(...) yaml:"[<key>][,<flag1>[,<flag2>]]" (...)`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following flags are currently supported:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     omitempty    Only include the field if it's not set to the zero
0000000000000000000000000000000000000000;;	//                  value for the type or to empty slices or maps.
0000000000000000000000000000000000000000;;	//                  Does not apply to zero valued structs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     flow         Marshal using a flow style (useful for structs,
0000000000000000000000000000000000000000;;	//                  sequences and maps).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     inline       Inline the field, which must be a struct or a map,
0000000000000000000000000000000000000000;;	//                  causing all of its fields or keys to be processed as if
0000000000000000000000000000000000000000;;	//                  they were part of the outer struct. For maps, keys must
0000000000000000000000000000000000000000;;	//                  not conflict with the yaml keys of other struct fields.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In addition, if the key is "-", the field is ignored.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     type T struct {
0000000000000000000000000000000000000000;;	//         F int "a,omitempty"
0000000000000000000000000000000000000000;;	//         B int
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//     yaml.Marshal(&T{B: 2}) // Returns "b: 2\n"
0000000000000000000000000000000000000000;;	//     yaml.Marshal(&T{F: 1}} // Returns "a: 1\nb: 0\n"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func Marshal(in interface{}) (out []byte, err error) {
0000000000000000000000000000000000000000;;		defer handleErr(&err)
0000000000000000000000000000000000000000;;		e := newEncoder()
0000000000000000000000000000000000000000;;		defer e.destroy()
0000000000000000000000000000000000000000;;		e.marshal("", reflect.ValueOf(in))
0000000000000000000000000000000000000000;;		e.finish()
0000000000000000000000000000000000000000;;		out = e.out
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleErr(err *error) {
0000000000000000000000000000000000000000;;		if v := recover(); v != nil {
0000000000000000000000000000000000000000;;			if e, ok := v.(yamlError); ok {
0000000000000000000000000000000000000000;;				*err = e.err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				panic(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yamlError struct {
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fail(err error) {
0000000000000000000000000000000000000000;;		panic(yamlError{err})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func failf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		panic(yamlError{fmt.Errorf("yaml: "+format, args...)})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A TypeError is returned by Unmarshal when one or more fields in
0000000000000000000000000000000000000000;;	// the YAML document cannot be properly decoded into the requested
0000000000000000000000000000000000000000;;	// types. When this error is returned, the value is still
0000000000000000000000000000000000000000;;	// unmarshaled partially.
0000000000000000000000000000000000000000;;	type TypeError struct {
0000000000000000000000000000000000000000;;		Errors []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TypeError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("yaml: unmarshal errors:\n  %s", strings.Join(e.Errors, "\n  "))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// --------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Maintain a mapping of keys to structure field indexes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The code in this section was copied from mgo/bson.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// structInfo holds details for the serialization of fields of
0000000000000000000000000000000000000000;;	// a given struct.
0000000000000000000000000000000000000000;;	type structInfo struct {
0000000000000000000000000000000000000000;;		FieldsMap  map[string]fieldInfo
0000000000000000000000000000000000000000;;		FieldsList []fieldInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InlineMap is the number of the field in the struct that
0000000000000000000000000000000000000000;;		// contains an ,inline map, or -1 if there's none.
0000000000000000000000000000000000000000;;		InlineMap int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fieldInfo struct {
0000000000000000000000000000000000000000;;		Key       string
0000000000000000000000000000000000000000;;		Num       int
0000000000000000000000000000000000000000;;		OmitEmpty bool
0000000000000000000000000000000000000000;;		Flow      bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Inline holds the field index if the field is part of an inlined struct.
0000000000000000000000000000000000000000;;		Inline []int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var structMap = make(map[reflect.Type]*structInfo)
0000000000000000000000000000000000000000;;	var fieldMapMutex sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getStructInfo(st reflect.Type) (*structInfo, error) {
0000000000000000000000000000000000000000;;		fieldMapMutex.RLock()
0000000000000000000000000000000000000000;;		sinfo, found := structMap[st]
0000000000000000000000000000000000000000;;		fieldMapMutex.RUnlock()
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			return sinfo, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := st.NumField()
0000000000000000000000000000000000000000;;		fieldsMap := make(map[string]fieldInfo)
0000000000000000000000000000000000000000;;		fieldsList := make([]fieldInfo, 0, n)
0000000000000000000000000000000000000000;;		inlineMap := -1
0000000000000000000000000000000000000000;;		for i := 0; i != n; i++ {
0000000000000000000000000000000000000000;;			field := st.Field(i)
0000000000000000000000000000000000000000;;			if field.PkgPath != "" {
0000000000000000000000000000000000000000;;				continue // Private field
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			info := fieldInfo{Num: i}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tag := field.Tag.Get("yaml")
0000000000000000000000000000000000000000;;			if tag == "" && strings.Index(string(field.Tag), ":") < 0 {
0000000000000000000000000000000000000000;;				tag = string(field.Tag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tag == "-" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			inline := false
0000000000000000000000000000000000000000;;			fields := strings.Split(tag, ",")
0000000000000000000000000000000000000000;;			if len(fields) > 1 {
0000000000000000000000000000000000000000;;				for _, flag := range fields[1:] {
0000000000000000000000000000000000000000;;					switch flag {
0000000000000000000000000000000000000000;;					case "omitempty":
0000000000000000000000000000000000000000;;						info.OmitEmpty = true
0000000000000000000000000000000000000000;;					case "flow":
0000000000000000000000000000000000000000;;						info.Flow = true
0000000000000000000000000000000000000000;;					case "inline":
0000000000000000000000000000000000000000;;						inline = true
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						return nil, errors.New(fmt.Sprintf("Unsupported flag %q in tag %q of type %s", flag, tag, st))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tag = fields[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if inline {
0000000000000000000000000000000000000000;;				switch field.Type.Kind() {
0000000000000000000000000000000000000000;;				case reflect.Map:
0000000000000000000000000000000000000000;;					if inlineMap >= 0 {
0000000000000000000000000000000000000000;;						return nil, errors.New("Multiple ,inline maps in struct " + st.String())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if field.Type.Key() != reflect.TypeOf("") {
0000000000000000000000000000000000000000;;						return nil, errors.New("Option ,inline needs a map with string keys in struct " + st.String())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					inlineMap = info.Num
0000000000000000000000000000000000000000;;				case reflect.Struct:
0000000000000000000000000000000000000000;;					sinfo, err := getStructInfo(field.Type)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, finfo := range sinfo.FieldsList {
0000000000000000000000000000000000000000;;						if _, found := fieldsMap[finfo.Key]; found {
0000000000000000000000000000000000000000;;							msg := "Duplicated key '" + finfo.Key + "' in struct " + st.String()
0000000000000000000000000000000000000000;;							return nil, errors.New(msg)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if finfo.Inline == nil {
0000000000000000000000000000000000000000;;							finfo.Inline = []int{i, finfo.Num}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							finfo.Inline = append([]int{i}, finfo.Inline...)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						fieldsMap[finfo.Key] = finfo
0000000000000000000000000000000000000000;;						fieldsList = append(fieldsList, finfo)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					//return nil, errors.New("Option ,inline needs a struct value or map field")
0000000000000000000000000000000000000000;;					return nil, errors.New("Option ,inline needs a struct value field")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tag != "" {
0000000000000000000000000000000000000000;;				info.Key = tag
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				info.Key = strings.ToLower(field.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, found = fieldsMap[info.Key]; found {
0000000000000000000000000000000000000000;;				msg := "Duplicated key '" + info.Key + "' in struct " + st.String()
0000000000000000000000000000000000000000;;				return nil, errors.New(msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fieldsList = append(fieldsList, info)
0000000000000000000000000000000000000000;;			fieldsMap[info.Key] = info
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sinfo = &structInfo{fieldsMap, fieldsList, inlineMap}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldMapMutex.Lock()
0000000000000000000000000000000000000000;;		structMap[st] = sinfo
0000000000000000000000000000000000000000;;		fieldMapMutex.Unlock()
0000000000000000000000000000000000000000;;		return sinfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isZero(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return len(v.String()) == 0
0000000000000000000000000000000000000000;;		case reflect.Interface, reflect.Ptr:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			return v.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			return v.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return v.Int() == 0
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v.Float() == 0
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			return v.Uint() == 0
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return !v.Bool()
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			vt := v.Type()
0000000000000000000000000000000000000000;;			for i := v.NumField() - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;				if vt.Field(i).PkgPath != "" {
0000000000000000000000000000000000000000;;					continue // Private field
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !isZero(v.Field(i)) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
