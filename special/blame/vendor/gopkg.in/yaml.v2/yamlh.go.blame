0000000000000000000000000000000000000000;;	package yaml
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/gopkg.in/v2/yaml/yamlh.go[Godeps/_workspace/src/gopkg.in/v2/yaml/yamlh.go][vendor/gopkg.in/yaml.v2/yamlh.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The version directive data.
0000000000000000000000000000000000000000;;	type yaml_version_directive_t struct {
0000000000000000000000000000000000000000;;		major int8 // The major version number.
0000000000000000000000000000000000000000;;		minor int8 // The minor version number.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The tag directive data.
0000000000000000000000000000000000000000;;	type yaml_tag_directive_t struct {
0000000000000000000000000000000000000000;;		handle []byte // The tag handle.
0000000000000000000000000000000000000000;;		prefix []byte // The tag prefix.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_encoding_t int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The stream encoding.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Let the parser choose the encoding.
0000000000000000000000000000000000000000;;		yaml_ANY_ENCODING yaml_encoding_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_UTF8_ENCODING    // The default UTF-8 encoding.
0000000000000000000000000000000000000000;;		yaml_UTF16LE_ENCODING // The UTF-16-LE encoding with BOM.
0000000000000000000000000000000000000000;;		yaml_UTF16BE_ENCODING // The UTF-16-BE encoding with BOM.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_break_t int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Line break types.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Let the parser choose the break type.
0000000000000000000000000000000000000000;;		yaml_ANY_BREAK yaml_break_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_CR_BREAK   // Use CR for line breaks (Mac style).
0000000000000000000000000000000000000000;;		yaml_LN_BREAK   // Use LN for line breaks (Unix style).
0000000000000000000000000000000000000000;;		yaml_CRLN_BREAK // Use CR LN for line breaks (DOS style).
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_error_type_t int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Many bad things could happen with the parser and emitter.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// No error is produced.
0000000000000000000000000000000000000000;;		yaml_NO_ERROR yaml_error_type_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_MEMORY_ERROR   // Cannot allocate or reallocate a block of memory.
0000000000000000000000000000000000000000;;		yaml_READER_ERROR   // Cannot read or decode the input stream.
0000000000000000000000000000000000000000;;		yaml_SCANNER_ERROR  // Cannot scan the input stream.
0000000000000000000000000000000000000000;;		yaml_PARSER_ERROR   // Cannot parse the input stream.
0000000000000000000000000000000000000000;;		yaml_COMPOSER_ERROR // Cannot compose a YAML document.
0000000000000000000000000000000000000000;;		yaml_WRITER_ERROR   // Cannot write to the output stream.
0000000000000000000000000000000000000000;;		yaml_EMITTER_ERROR  // Cannot emit a YAML stream.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The pointer position.
0000000000000000000000000000000000000000;;	type yaml_mark_t struct {
0000000000000000000000000000000000000000;;		index  int // The position index.
0000000000000000000000000000000000000000;;		line   int // The position line.
0000000000000000000000000000000000000000;;		column int // The position column.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Node Styles
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_style_t int8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_scalar_style_t yaml_style_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scalar styles.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Let the emitter choose the style.
0000000000000000000000000000000000000000;;		yaml_ANY_SCALAR_STYLE yaml_scalar_style_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_PLAIN_SCALAR_STYLE         // The plain scalar style.
0000000000000000000000000000000000000000;;		yaml_SINGLE_QUOTED_SCALAR_STYLE // The single-quoted scalar style.
0000000000000000000000000000000000000000;;		yaml_DOUBLE_QUOTED_SCALAR_STYLE // The double-quoted scalar style.
0000000000000000000000000000000000000000;;		yaml_LITERAL_SCALAR_STYLE       // The literal scalar style.
0000000000000000000000000000000000000000;;		yaml_FOLDED_SCALAR_STYLE        // The folded scalar style.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_sequence_style_t yaml_style_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sequence styles.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Let the emitter choose the style.
0000000000000000000000000000000000000000;;		yaml_ANY_SEQUENCE_STYLE yaml_sequence_style_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_BLOCK_SEQUENCE_STYLE // The block sequence style.
0000000000000000000000000000000000000000;;		yaml_FLOW_SEQUENCE_STYLE  // The flow sequence style.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_mapping_style_t yaml_style_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mapping styles.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Let the emitter choose the style.
0000000000000000000000000000000000000000;;		yaml_ANY_MAPPING_STYLE yaml_mapping_style_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_BLOCK_MAPPING_STYLE // The block mapping style.
0000000000000000000000000000000000000000;;		yaml_FLOW_MAPPING_STYLE  // The flow mapping style.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tokens
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_token_type_t int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token types.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// An empty token.
0000000000000000000000000000000000000000;;		yaml_NO_TOKEN yaml_token_type_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_STREAM_START_TOKEN // A STREAM-START token.
0000000000000000000000000000000000000000;;		yaml_STREAM_END_TOKEN   // A STREAM-END token.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_VERSION_DIRECTIVE_TOKEN // A VERSION-DIRECTIVE token.
0000000000000000000000000000000000000000;;		yaml_TAG_DIRECTIVE_TOKEN     // A TAG-DIRECTIVE token.
0000000000000000000000000000000000000000;;		yaml_DOCUMENT_START_TOKEN    // A DOCUMENT-START token.
0000000000000000000000000000000000000000;;		yaml_DOCUMENT_END_TOKEN      // A DOCUMENT-END token.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_BLOCK_SEQUENCE_START_TOKEN // A BLOCK-SEQUENCE-START token.
0000000000000000000000000000000000000000;;		yaml_BLOCK_MAPPING_START_TOKEN  // A BLOCK-SEQUENCE-END token.
0000000000000000000000000000000000000000;;		yaml_BLOCK_END_TOKEN            // A BLOCK-END token.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_FLOW_SEQUENCE_START_TOKEN // A FLOW-SEQUENCE-START token.
0000000000000000000000000000000000000000;;		yaml_FLOW_SEQUENCE_END_TOKEN   // A FLOW-SEQUENCE-END token.
0000000000000000000000000000000000000000;;		yaml_FLOW_MAPPING_START_TOKEN  // A FLOW-MAPPING-START token.
0000000000000000000000000000000000000000;;		yaml_FLOW_MAPPING_END_TOKEN    // A FLOW-MAPPING-END token.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_BLOCK_ENTRY_TOKEN // A BLOCK-ENTRY token.
0000000000000000000000000000000000000000;;		yaml_FLOW_ENTRY_TOKEN  // A FLOW-ENTRY token.
0000000000000000000000000000000000000000;;		yaml_KEY_TOKEN         // A KEY token.
0000000000000000000000000000000000000000;;		yaml_VALUE_TOKEN       // A VALUE token.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_ALIAS_TOKEN  // An ALIAS token.
0000000000000000000000000000000000000000;;		yaml_ANCHOR_TOKEN // An ANCHOR token.
0000000000000000000000000000000000000000;;		yaml_TAG_TOKEN    // A TAG token.
0000000000000000000000000000000000000000;;		yaml_SCALAR_TOKEN // A SCALAR token.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tt yaml_token_type_t) String() string {
0000000000000000000000000000000000000000;;		switch tt {
0000000000000000000000000000000000000000;;		case yaml_NO_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_NO_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_STREAM_START_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_STREAM_START_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_STREAM_END_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_STREAM_END_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_VERSION_DIRECTIVE_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_VERSION_DIRECTIVE_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_TAG_DIRECTIVE_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_TAG_DIRECTIVE_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_DOCUMENT_START_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_DOCUMENT_START_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_DOCUMENT_END_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_DOCUMENT_END_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_BLOCK_SEQUENCE_START_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_BLOCK_SEQUENCE_START_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_BLOCK_MAPPING_START_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_BLOCK_MAPPING_START_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_BLOCK_END_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_BLOCK_END_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_FLOW_SEQUENCE_START_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_FLOW_SEQUENCE_START_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_FLOW_SEQUENCE_END_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_FLOW_SEQUENCE_END_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_FLOW_MAPPING_START_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_FLOW_MAPPING_START_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_FLOW_MAPPING_END_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_FLOW_MAPPING_END_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_BLOCK_ENTRY_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_BLOCK_ENTRY_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_FLOW_ENTRY_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_FLOW_ENTRY_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_KEY_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_KEY_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_VALUE_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_VALUE_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_ALIAS_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_ALIAS_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_ANCHOR_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_ANCHOR_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_TAG_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_TAG_TOKEN"
0000000000000000000000000000000000000000;;		case yaml_SCALAR_TOKEN:
0000000000000000000000000000000000000000;;			return "yaml_SCALAR_TOKEN"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "<unknown token>"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The token structure.
0000000000000000000000000000000000000000;;	type yaml_token_t struct {
0000000000000000000000000000000000000000;;		// The token type.
0000000000000000000000000000000000000000;;		typ yaml_token_type_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The start/end of the token.
0000000000000000000000000000000000000000;;		start_mark, end_mark yaml_mark_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The stream encoding (for yaml_STREAM_START_TOKEN).
0000000000000000000000000000000000000000;;		encoding yaml_encoding_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The alias/anchor/scalar value or tag/tag directive handle
0000000000000000000000000000000000000000;;		// (for yaml_ALIAS_TOKEN, yaml_ANCHOR_TOKEN, yaml_SCALAR_TOKEN, yaml_TAG_TOKEN, yaml_TAG_DIRECTIVE_TOKEN).
0000000000000000000000000000000000000000;;		value []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The tag suffix (for yaml_TAG_TOKEN).
0000000000000000000000000000000000000000;;		suffix []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The tag directive prefix (for yaml_TAG_DIRECTIVE_TOKEN).
0000000000000000000000000000000000000000;;		prefix []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The scalar style (for yaml_SCALAR_TOKEN).
0000000000000000000000000000000000000000;;		style yaml_scalar_style_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The version directive major/minor (for yaml_VERSION_DIRECTIVE_TOKEN).
0000000000000000000000000000000000000000;;		major, minor int8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Events
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_event_type_t int8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Event types.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// An empty event.
0000000000000000000000000000000000000000;;		yaml_NO_EVENT yaml_event_type_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_STREAM_START_EVENT   // A STREAM-START event.
0000000000000000000000000000000000000000;;		yaml_STREAM_END_EVENT     // A STREAM-END event.
0000000000000000000000000000000000000000;;		yaml_DOCUMENT_START_EVENT // A DOCUMENT-START event.
0000000000000000000000000000000000000000;;		yaml_DOCUMENT_END_EVENT   // A DOCUMENT-END event.
0000000000000000000000000000000000000000;;		yaml_ALIAS_EVENT          // An ALIAS event.
0000000000000000000000000000000000000000;;		yaml_SCALAR_EVENT         // A SCALAR event.
0000000000000000000000000000000000000000;;		yaml_SEQUENCE_START_EVENT // A SEQUENCE-START event.
0000000000000000000000000000000000000000;;		yaml_SEQUENCE_END_EVENT   // A SEQUENCE-END event.
0000000000000000000000000000000000000000;;		yaml_MAPPING_START_EVENT  // A MAPPING-START event.
0000000000000000000000000000000000000000;;		yaml_MAPPING_END_EVENT    // A MAPPING-END event.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The event structure.
0000000000000000000000000000000000000000;;	type yaml_event_t struct {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The event type.
0000000000000000000000000000000000000000;;		typ yaml_event_type_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The start and end of the event.
0000000000000000000000000000000000000000;;		start_mark, end_mark yaml_mark_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The document encoding (for yaml_STREAM_START_EVENT).
0000000000000000000000000000000000000000;;		encoding yaml_encoding_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The version directive (for yaml_DOCUMENT_START_EVENT).
0000000000000000000000000000000000000000;;		version_directive *yaml_version_directive_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The list of tag directives (for yaml_DOCUMENT_START_EVENT).
0000000000000000000000000000000000000000;;		tag_directives []yaml_tag_directive_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The anchor (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_ALIAS_EVENT).
0000000000000000000000000000000000000000;;		anchor []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The tag (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
0000000000000000000000000000000000000000;;		tag []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The scalar value (for yaml_SCALAR_EVENT).
0000000000000000000000000000000000000000;;		value []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is the document start/end indicator implicit, or the tag optional?
0000000000000000000000000000000000000000;;		// (for yaml_DOCUMENT_START_EVENT, yaml_DOCUMENT_END_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_SCALAR_EVENT).
0000000000000000000000000000000000000000;;		implicit bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is the tag optional for any non-plain style? (for yaml_SCALAR_EVENT).
0000000000000000000000000000000000000000;;		quoted_implicit bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The style (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
0000000000000000000000000000000000000000;;		style yaml_style_t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *yaml_event_t) scalar_style() yaml_scalar_style_t     { return yaml_scalar_style_t(e.style) }
0000000000000000000000000000000000000000;;	func (e *yaml_event_t) sequence_style() yaml_sequence_style_t { return yaml_sequence_style_t(e.style) }
0000000000000000000000000000000000000000;;	func (e *yaml_event_t) mapping_style() yaml_mapping_style_t   { return yaml_mapping_style_t(e.style) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nodes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		yaml_NULL_TAG      = "tag:yaml.org,2002:null"      // The tag !!null with the only possible value: null.
0000000000000000000000000000000000000000;;		yaml_BOOL_TAG      = "tag:yaml.org,2002:bool"      // The tag !!bool with the values: true and false.
0000000000000000000000000000000000000000;;		yaml_STR_TAG       = "tag:yaml.org,2002:str"       // The tag !!str for string values.
0000000000000000000000000000000000000000;;		yaml_INT_TAG       = "tag:yaml.org,2002:int"       // The tag !!int for integer values.
0000000000000000000000000000000000000000;;		yaml_FLOAT_TAG     = "tag:yaml.org,2002:float"     // The tag !!float for float values.
0000000000000000000000000000000000000000;;		yaml_TIMESTAMP_TAG = "tag:yaml.org,2002:timestamp" // The tag !!timestamp for date and time values.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_SEQ_TAG = "tag:yaml.org,2002:seq" // The tag !!seq is used to denote sequences.
0000000000000000000000000000000000000000;;		yaml_MAP_TAG = "tag:yaml.org,2002:map" // The tag !!map is used to denote mapping.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Not in original libyaml.
0000000000000000000000000000000000000000;;		yaml_BINARY_TAG = "tag:yaml.org,2002:binary"
0000000000000000000000000000000000000000;;		yaml_MERGE_TAG  = "tag:yaml.org,2002:merge"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_DEFAULT_SCALAR_TAG   = yaml_STR_TAG // The default scalar tag is !!str.
0000000000000000000000000000000000000000;;		yaml_DEFAULT_SEQUENCE_TAG = yaml_SEQ_TAG // The default sequence tag is !!seq.
0000000000000000000000000000000000000000;;		yaml_DEFAULT_MAPPING_TAG  = yaml_MAP_TAG // The default mapping tag is !!map.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_node_type_t int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Node types.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// An empty node.
0000000000000000000000000000000000000000;;		yaml_NO_NODE yaml_node_type_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_SCALAR_NODE   // A scalar node.
0000000000000000000000000000000000000000;;		yaml_SEQUENCE_NODE // A sequence node.
0000000000000000000000000000000000000000;;		yaml_MAPPING_NODE  // A mapping node.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An element of a sequence node.
0000000000000000000000000000000000000000;;	type yaml_node_item_t int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An element of a mapping node.
0000000000000000000000000000000000000000;;	type yaml_node_pair_t struct {
0000000000000000000000000000000000000000;;		key   int // The key of the element.
0000000000000000000000000000000000000000;;		value int // The value of the element.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The node structure.
0000000000000000000000000000000000000000;;	type yaml_node_t struct {
0000000000000000000000000000000000000000;;		typ yaml_node_type_t // The node type.
0000000000000000000000000000000000000000;;		tag []byte           // The node tag.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The node data.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The scalar parameters (for yaml_SCALAR_NODE).
0000000000000000000000000000000000000000;;		scalar struct {
0000000000000000000000000000000000000000;;			value  []byte              // The scalar value.
0000000000000000000000000000000000000000;;			length int                 // The length of the scalar value.
0000000000000000000000000000000000000000;;			style  yaml_scalar_style_t // The scalar style.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The sequence parameters (for YAML_SEQUENCE_NODE).
0000000000000000000000000000000000000000;;		sequence struct {
0000000000000000000000000000000000000000;;			items_data []yaml_node_item_t    // The stack of sequence items.
0000000000000000000000000000000000000000;;			style      yaml_sequence_style_t // The sequence style.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The mapping parameters (for yaml_MAPPING_NODE).
0000000000000000000000000000000000000000;;		mapping struct {
0000000000000000000000000000000000000000;;			pairs_data  []yaml_node_pair_t   // The stack of mapping pairs (key, value).
0000000000000000000000000000000000000000;;			pairs_start *yaml_node_pair_t    // The beginning of the stack.
0000000000000000000000000000000000000000;;			pairs_end   *yaml_node_pair_t    // The end of the stack.
0000000000000000000000000000000000000000;;			pairs_top   *yaml_node_pair_t    // The top of the stack.
0000000000000000000000000000000000000000;;			style       yaml_mapping_style_t // The mapping style.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start_mark yaml_mark_t // The beginning of the node.
0000000000000000000000000000000000000000;;		end_mark   yaml_mark_t // The end of the node.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The document structure.
0000000000000000000000000000000000000000;;	type yaml_document_t struct {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The document nodes.
0000000000000000000000000000000000000000;;		nodes []yaml_node_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The version directive.
0000000000000000000000000000000000000000;;		version_directive *yaml_version_directive_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The list of tag directives.
0000000000000000000000000000000000000000;;		tag_directives_data  []yaml_tag_directive_t
0000000000000000000000000000000000000000;;		tag_directives_start int // The beginning of the tag directives list.
0000000000000000000000000000000000000000;;		tag_directives_end   int // The end of the tag directives list.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start_implicit int // Is the document start indicator implicit?
0000000000000000000000000000000000000000;;		end_implicit   int // Is the document end indicator implicit?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The start/end of the document.
0000000000000000000000000000000000000000;;		start_mark, end_mark yaml_mark_t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The prototype of a read handler.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The read handler is called when the parser needs to read more bytes from the
0000000000000000000000000000000000000000;;	// source. The handler should write not more than size bytes to the buffer.
0000000000000000000000000000000000000000;;	// The number of written bytes should be set to the size_read variable.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// [in,out]   data        A pointer to an application data specified by
0000000000000000000000000000000000000000;;	//                        yaml_parser_set_input().
0000000000000000000000000000000000000000;;	// [out]      buffer      The buffer to write the data from the source.
0000000000000000000000000000000000000000;;	// [in]       size        The size of the buffer.
0000000000000000000000000000000000000000;;	// [out]      size_read   The actual number of bytes read from the source.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// On success, the handler should return 1.  If the handler failed,
0000000000000000000000000000000000000000;;	// the returned value should be 0. On EOF, the handler should set the
0000000000000000000000000000000000000000;;	// size_read to 0 and return 1.
0000000000000000000000000000000000000000;;	type yaml_read_handler_t func(parser *yaml_parser_t, buffer []byte) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This structure holds information about a potential simple key.
0000000000000000000000000000000000000000;;	type yaml_simple_key_t struct {
0000000000000000000000000000000000000000;;		possible     bool        // Is a simple key possible?
0000000000000000000000000000000000000000;;		required     bool        // Is a simple key required?
0000000000000000000000000000000000000000;;		token_number int         // The number of the token.
0000000000000000000000000000000000000000;;		mark         yaml_mark_t // The position mark.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The states of the parser.
0000000000000000000000000000000000000000;;	type yaml_parser_state_t int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		yaml_PARSE_STREAM_START_STATE yaml_parser_state_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE           // Expect the beginning of an implicit document.
0000000000000000000000000000000000000000;;		yaml_PARSE_DOCUMENT_START_STATE                    // Expect DOCUMENT-START.
0000000000000000000000000000000000000000;;		yaml_PARSE_DOCUMENT_CONTENT_STATE                  // Expect the content of a document.
0000000000000000000000000000000000000000;;		yaml_PARSE_DOCUMENT_END_STATE                      // Expect DOCUMENT-END.
0000000000000000000000000000000000000000;;		yaml_PARSE_BLOCK_NODE_STATE                        // Expect a block node.
0000000000000000000000000000000000000000;;		yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE // Expect a block node or indentless sequence.
0000000000000000000000000000000000000000;;		yaml_PARSE_FLOW_NODE_STATE                         // Expect a flow node.
0000000000000000000000000000000000000000;;		yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE        // Expect the first entry of a block sequence.
0000000000000000000000000000000000000000;;		yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE              // Expect an entry of a block sequence.
0000000000000000000000000000000000000000;;		yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE         // Expect an entry of an indentless sequence.
0000000000000000000000000000000000000000;;		yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE           // Expect the first key of a block mapping.
0000000000000000000000000000000000000000;;		yaml_PARSE_BLOCK_MAPPING_KEY_STATE                 // Expect a block mapping key.
0000000000000000000000000000000000000000;;		yaml_PARSE_BLOCK_MAPPING_VALUE_STATE               // Expect a block mapping value.
0000000000000000000000000000000000000000;;		yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE         // Expect the first entry of a flow sequence.
0000000000000000000000000000000000000000;;		yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE               // Expect an entry of a flow sequence.
0000000000000000000000000000000000000000;;		yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE   // Expect a key of an ordered mapping.
0000000000000000000000000000000000000000;;		yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE // Expect a value of an ordered mapping.
0000000000000000000000000000000000000000;;		yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE   // Expect the and of an ordered mapping entry.
0000000000000000000000000000000000000000;;		yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE            // Expect the first key of a flow mapping.
0000000000000000000000000000000000000000;;		yaml_PARSE_FLOW_MAPPING_KEY_STATE                  // Expect a key of a flow mapping.
0000000000000000000000000000000000000000;;		yaml_PARSE_FLOW_MAPPING_VALUE_STATE                // Expect a value of a flow mapping.
0000000000000000000000000000000000000000;;		yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE          // Expect an empty value of a flow mapping.
0000000000000000000000000000000000000000;;		yaml_PARSE_END_STATE                               // Expect nothing.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ps yaml_parser_state_t) String() string {
0000000000000000000000000000000000000000;;		switch ps {
0000000000000000000000000000000000000000;;		case yaml_PARSE_STREAM_START_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_STREAM_START_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_DOCUMENT_START_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_DOCUMENT_START_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_DOCUMENT_CONTENT_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_DOCUMENT_CONTENT_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_DOCUMENT_END_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_DOCUMENT_END_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_NODE_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_BLOCK_NODE_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_NODE_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_FLOW_NODE_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_MAPPING_KEY_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_BLOCK_MAPPING_KEY_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_MAPPING_VALUE_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_BLOCK_MAPPING_VALUE_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_MAPPING_KEY_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_FLOW_MAPPING_KEY_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_MAPPING_VALUE_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_FLOW_MAPPING_VALUE_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE"
0000000000000000000000000000000000000000;;		case yaml_PARSE_END_STATE:
0000000000000000000000000000000000000000;;			return "yaml_PARSE_END_STATE"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "<unknown parser state>"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This structure holds aliases data.
0000000000000000000000000000000000000000;;	type yaml_alias_data_t struct {
0000000000000000000000000000000000000000;;		anchor []byte      // The anchor.
0000000000000000000000000000000000000000;;		index  int         // The node id.
0000000000000000000000000000000000000000;;		mark   yaml_mark_t // The anchor mark.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The parser structure.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All members are internal. Manage the structure using the
0000000000000000000000000000000000000000;;	// yaml_parser_ family of functions.
0000000000000000000000000000000000000000;;	type yaml_parser_t struct {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Error handling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		error yaml_error_type_t // Error type.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		problem string // Error description.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The byte about which the problem occured.
0000000000000000000000000000000000000000;;		problem_offset int
0000000000000000000000000000000000000000;;		problem_value  int
0000000000000000000000000000000000000000;;		problem_mark   yaml_mark_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The error context.
0000000000000000000000000000000000000000;;		context      string
0000000000000000000000000000000000000000;;		context_mark yaml_mark_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reader stuff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		read_handler yaml_read_handler_t // Read handler.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		input_file io.Reader // File input data.
0000000000000000000000000000000000000000;;		input      []byte    // String input data.
0000000000000000000000000000000000000000;;		input_pos  int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eof bool // EOF flag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buffer     []byte // The working buffer.
0000000000000000000000000000000000000000;;		buffer_pos int    // The current position of the buffer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unread int // The number of unread characters in the buffer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raw_buffer     []byte // The raw buffer.
0000000000000000000000000000000000000000;;		raw_buffer_pos int    // The current position of the buffer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoding yaml_encoding_t // The input encoding.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		offset int         // The offset of the current position (in bytes).
0000000000000000000000000000000000000000;;		mark   yaml_mark_t // The mark of the current position.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scanner stuff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream_start_produced bool // Have we started to scan the input stream?
0000000000000000000000000000000000000000;;		stream_end_produced   bool // Have we reached the end of the input stream?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flow_level int // The number of unclosed '[' and '{' indicators.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokens          []yaml_token_t // The tokens queue.
0000000000000000000000000000000000000000;;		tokens_head     int            // The head of the tokens queue.
0000000000000000000000000000000000000000;;		tokens_parsed   int            // The number of tokens fetched from the queue.
0000000000000000000000000000000000000000;;		token_available bool           // Does the tokens queue contain a token ready for dequeueing.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indent  int   // The current indentation level.
0000000000000000000000000000000000000000;;		indents []int // The indentation levels stack.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple_key_allowed bool                // May a simple key occur at the current position?
0000000000000000000000000000000000000000;;		simple_keys        []yaml_simple_key_t // The stack of simple keys.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parser stuff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state          yaml_parser_state_t    // The current parser state.
0000000000000000000000000000000000000000;;		states         []yaml_parser_state_t  // The parser states stack.
0000000000000000000000000000000000000000;;		marks          []yaml_mark_t          // The stack of marks.
0000000000000000000000000000000000000000;;		tag_directives []yaml_tag_directive_t // The list of TAG directives.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dumper stuff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aliases []yaml_alias_data_t // The alias data.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		document *yaml_document_t // The currently parsed document.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Emitter Definitions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The prototype of a write handler.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The write handler is called when the emitter needs to flush the accumulated
0000000000000000000000000000000000000000;;	// characters to the output.  The handler should write @a size bytes of the
0000000000000000000000000000000000000000;;	// @a buffer to the output.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// @param[in,out]   data        A pointer to an application data specified by
0000000000000000000000000000000000000000;;	//                              yaml_emitter_set_output().
0000000000000000000000000000000000000000;;	// @param[in]       buffer      The buffer with bytes to be written.
0000000000000000000000000000000000000000;;	// @param[in]       size        The size of the buffer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// @returns On success, the handler should return @c 1.  If the handler failed,
0000000000000000000000000000000000000000;;	// the returned value should be @c 0.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type yaml_write_handler_t func(emitter *yaml_emitter_t, buffer []byte) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yaml_emitter_state_t int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The emitter states.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Expect STREAM-START.
0000000000000000000000000000000000000000;;		yaml_EMIT_STREAM_START_STATE yaml_emitter_state_t = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		yaml_EMIT_FIRST_DOCUMENT_START_STATE       // Expect the first DOCUMENT-START or STREAM-END.
0000000000000000000000000000000000000000;;		yaml_EMIT_DOCUMENT_START_STATE             // Expect DOCUMENT-START or STREAM-END.
0000000000000000000000000000000000000000;;		yaml_EMIT_DOCUMENT_CONTENT_STATE           // Expect the content of a document.
0000000000000000000000000000000000000000;;		yaml_EMIT_DOCUMENT_END_STATE               // Expect DOCUMENT-END.
0000000000000000000000000000000000000000;;		yaml_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE   // Expect the first item of a flow sequence.
0000000000000000000000000000000000000000;;		yaml_EMIT_FLOW_SEQUENCE_ITEM_STATE         // Expect an item of a flow sequence.
0000000000000000000000000000000000000000;;		yaml_EMIT_FLOW_MAPPING_FIRST_KEY_STATE     // Expect the first key of a flow mapping.
0000000000000000000000000000000000000000;;		yaml_EMIT_FLOW_MAPPING_KEY_STATE           // Expect a key of a flow mapping.
0000000000000000000000000000000000000000;;		yaml_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE  // Expect a value for a simple key of a flow mapping.
0000000000000000000000000000000000000000;;		yaml_EMIT_FLOW_MAPPING_VALUE_STATE         // Expect a value of a flow mapping.
0000000000000000000000000000000000000000;;		yaml_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE  // Expect the first item of a block sequence.
0000000000000000000000000000000000000000;;		yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE        // Expect an item of a block sequence.
0000000000000000000000000000000000000000;;		yaml_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE    // Expect the first key of a block mapping.
0000000000000000000000000000000000000000;;		yaml_EMIT_BLOCK_MAPPING_KEY_STATE          // Expect the key of a block mapping.
0000000000000000000000000000000000000000;;		yaml_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE // Expect a value for a simple key of a block mapping.
0000000000000000000000000000000000000000;;		yaml_EMIT_BLOCK_MAPPING_VALUE_STATE        // Expect a value of a block mapping.
0000000000000000000000000000000000000000;;		yaml_EMIT_END_STATE                        // Expect nothing.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The emitter structure.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All members are internal.  Manage the structure using the @c yaml_emitter_
0000000000000000000000000000000000000000;;	// family of functions.
0000000000000000000000000000000000000000;;	type yaml_emitter_t struct {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Error handling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		error   yaml_error_type_t // Error type.
0000000000000000000000000000000000000000;;		problem string            // Error description.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Writer stuff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		write_handler yaml_write_handler_t // Write handler.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output_buffer *[]byte   // String output data.
0000000000000000000000000000000000000000;;		output_file   io.Writer // File output data.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buffer     []byte // The working buffer.
0000000000000000000000000000000000000000;;		buffer_pos int    // The current position of the buffer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raw_buffer     []byte // The raw buffer.
0000000000000000000000000000000000000000;;		raw_buffer_pos int    // The current position of the buffer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoding yaml_encoding_t // The stream encoding.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Emitter stuff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		canonical   bool         // If the output is in the canonical style?
0000000000000000000000000000000000000000;;		best_indent int          // The number of indentation spaces.
0000000000000000000000000000000000000000;;		best_width  int          // The preferred width of the output lines.
0000000000000000000000000000000000000000;;		unicode     bool         // Allow unescaped non-ASCII characters?
0000000000000000000000000000000000000000;;		line_break  yaml_break_t // The preferred line break.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state  yaml_emitter_state_t   // The current emitter state.
0000000000000000000000000000000000000000;;		states []yaml_emitter_state_t // The stack of states.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		events      []yaml_event_t // The event queue.
0000000000000000000000000000000000000000;;		events_head int            // The head of the event queue.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indents []int // The stack of indentation levels.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tag_directives []yaml_tag_directive_t // The list of tag directives.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indent int // The current indentation level.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flow_level int // The current flow level.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		root_context       bool // Is it the document root context?
0000000000000000000000000000000000000000;;		sequence_context   bool // Is it a sequence context?
0000000000000000000000000000000000000000;;		mapping_context    bool // Is it a mapping context?
0000000000000000000000000000000000000000;;		simple_key_context bool // Is it a simple mapping key context?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		line       int  // The current line.
0000000000000000000000000000000000000000;;		column     int  // The current column.
0000000000000000000000000000000000000000;;		whitespace bool // If the last character was a whitespace?
0000000000000000000000000000000000000000;;		indention  bool // If the last character was an indentation character (' ', '-', '?', ':')?
0000000000000000000000000000000000000000;;		open_ended bool // If an explicit document end is required?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Anchor analysis.
0000000000000000000000000000000000000000;;		anchor_data struct {
0000000000000000000000000000000000000000;;			anchor []byte // The anchor value.
0000000000000000000000000000000000000000;;			alias  bool   // Is it an alias?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tag analysis.
0000000000000000000000000000000000000000;;		tag_data struct {
0000000000000000000000000000000000000000;;			handle []byte // The tag handle.
0000000000000000000000000000000000000000;;			suffix []byte // The tag suffix.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scalar analysis.
0000000000000000000000000000000000000000;;		scalar_data struct {
0000000000000000000000000000000000000000;;			value                 []byte              // The scalar value.
0000000000000000000000000000000000000000;;			multiline             bool                // Does the scalar contain line breaks?
0000000000000000000000000000000000000000;;			flow_plain_allowed    bool                // Can the scalar be expessed in the flow plain style?
0000000000000000000000000000000000000000;;			block_plain_allowed   bool                // Can the scalar be expressed in the block plain style?
0000000000000000000000000000000000000000;;			single_quoted_allowed bool                // Can the scalar be expressed in the single quoted style?
0000000000000000000000000000000000000000;;			block_allowed         bool                // Can the scalar be expressed in the literal or folded styles?
0000000000000000000000000000000000000000;;			style                 yaml_scalar_style_t // The output style.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dumper stuff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opened bool // If the stream was already opened?
0000000000000000000000000000000000000000;;		closed bool // If the stream was already closed?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The information associated with the document nodes.
0000000000000000000000000000000000000000;;		anchors *struct {
0000000000000000000000000000000000000000;;			references int  // The number of references.
0000000000000000000000000000000000000000;;			anchor     int  // The anchor id.
0000000000000000000000000000000000000000;;			serialized bool // If the node has been emitted?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		last_anchor_id int // The last assigned anchor id.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		document *yaml_document_t // The currently emitted document.
0000000000000000000000000000000000000000;;	}
