0000000000000000000000000000000000000000;;	package yaml
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/gopkg.in/v2/yaml/parserc.go[Godeps/_workspace/src/gopkg.in/v2/yaml/parserc.go][vendor/gopkg.in/yaml.v2/parserc.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The parser implements the following grammar:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// stream               ::= STREAM-START implicit_document? explicit_document* STREAM-END
0000000000000000000000000000000000000000;;	// implicit_document    ::= block_node DOCUMENT-END*
0000000000000000000000000000000000000000;;	// explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
0000000000000000000000000000000000000000;;	// block_node_or_indentless_sequence    ::=
0000000000000000000000000000000000000000;;	//                          ALIAS
0000000000000000000000000000000000000000;;	//                          | properties (block_content | indentless_block_sequence)?
0000000000000000000000000000000000000000;;	//                          | block_content
0000000000000000000000000000000000000000;;	//                          | indentless_block_sequence
0000000000000000000000000000000000000000;;	// block_node           ::= ALIAS
0000000000000000000000000000000000000000;;	//                          | properties block_content?
0000000000000000000000000000000000000000;;	//                          | block_content
0000000000000000000000000000000000000000;;	// flow_node            ::= ALIAS
0000000000000000000000000000000000000000;;	//                          | properties flow_content?
0000000000000000000000000000000000000000;;	//                          | flow_content
0000000000000000000000000000000000000000;;	// properties           ::= TAG ANCHOR? | ANCHOR TAG?
0000000000000000000000000000000000000000;;	// block_content        ::= block_collection | flow_collection | SCALAR
0000000000000000000000000000000000000000;;	// flow_content         ::= flow_collection | SCALAR
0000000000000000000000000000000000000000;;	// block_collection     ::= block_sequence | block_mapping
0000000000000000000000000000000000000000;;	// flow_collection      ::= flow_sequence | flow_mapping
0000000000000000000000000000000000000000;;	// block_sequence       ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
0000000000000000000000000000000000000000;;	// indentless_sequence  ::= (BLOCK-ENTRY block_node?)+
0000000000000000000000000000000000000000;;	// block_mapping        ::= BLOCK-MAPPING_START
0000000000000000000000000000000000000000;;	//                          ((KEY block_node_or_indentless_sequence?)?
0000000000000000000000000000000000000000;;	//                          (VALUE block_node_or_indentless_sequence?)?)*
0000000000000000000000000000000000000000;;	//                          BLOCK-END
0000000000000000000000000000000000000000;;	// flow_sequence        ::= FLOW-SEQUENCE-START
0000000000000000000000000000000000000000;;	//                          (flow_sequence_entry FLOW-ENTRY)*
0000000000000000000000000000000000000000;;	//                          flow_sequence_entry?
0000000000000000000000000000000000000000;;	//                          FLOW-SEQUENCE-END
0000000000000000000000000000000000000000;;	// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
0000000000000000000000000000000000000000;;	// flow_mapping         ::= FLOW-MAPPING-START
0000000000000000000000000000000000000000;;	//                          (flow_mapping_entry FLOW-ENTRY)*
0000000000000000000000000000000000000000;;	//                          flow_mapping_entry?
0000000000000000000000000000000000000000;;	//                          FLOW-MAPPING-END
0000000000000000000000000000000000000000;;	// flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Peek the next token in the token queue.
0000000000000000000000000000000000000000;;	func peek_token(parser *yaml_parser_t) *yaml_token_t {
0000000000000000000000000000000000000000;;		if parser.token_available || yaml_parser_fetch_more_tokens(parser) {
0000000000000000000000000000000000000000;;			return &parser.tokens[parser.tokens_head]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove the next token from the queue (must be called after peek_token).
0000000000000000000000000000000000000000;;	func skip_token(parser *yaml_parser_t) {
0000000000000000000000000000000000000000;;		parser.token_available = false
0000000000000000000000000000000000000000;;		parser.tokens_parsed++
0000000000000000000000000000000000000000;;		parser.stream_end_produced = parser.tokens[parser.tokens_head].typ == yaml_STREAM_END_TOKEN
0000000000000000000000000000000000000000;;		parser.tokens_head++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the next event.
0000000000000000000000000000000000000000;;	func yaml_parser_parse(parser *yaml_parser_t, event *yaml_event_t) bool {
0000000000000000000000000000000000000000;;		// Erase the event object.
0000000000000000000000000000000000000000;;		*event = yaml_event_t{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No events after the end of the stream or error.
0000000000000000000000000000000000000000;;		if parser.stream_end_produced || parser.error != yaml_NO_ERROR || parser.state == yaml_PARSE_END_STATE {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate the next event.
0000000000000000000000000000000000000000;;		return yaml_parser_state_machine(parser, event)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set parser error.
0000000000000000000000000000000000000000;;	func yaml_parser_set_parser_error(parser *yaml_parser_t, problem string, problem_mark yaml_mark_t) bool {
0000000000000000000000000000000000000000;;		parser.error = yaml_PARSER_ERROR
0000000000000000000000000000000000000000;;		parser.problem = problem
0000000000000000000000000000000000000000;;		parser.problem_mark = problem_mark
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func yaml_parser_set_parser_error_context(parser *yaml_parser_t, context string, context_mark yaml_mark_t, problem string, problem_mark yaml_mark_t) bool {
0000000000000000000000000000000000000000;;		parser.error = yaml_PARSER_ERROR
0000000000000000000000000000000000000000;;		parser.context = context
0000000000000000000000000000000000000000;;		parser.context_mark = context_mark
0000000000000000000000000000000000000000;;		parser.problem = problem
0000000000000000000000000000000000000000;;		parser.problem_mark = problem_mark
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// State dispatcher.
0000000000000000000000000000000000000000;;	func yaml_parser_state_machine(parser *yaml_parser_t, event *yaml_event_t) bool {
0000000000000000000000000000000000000000;;		//trace("yaml_parser_state_machine", "state:", parser.state.String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch parser.state {
0000000000000000000000000000000000000000;;		case yaml_PARSE_STREAM_START_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_stream_start(parser, event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_document_start(parser, event, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_DOCUMENT_START_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_document_start(parser, event, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_DOCUMENT_CONTENT_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_document_content(parser, event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_DOCUMENT_END_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_document_end(parser, event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_NODE_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_node(parser, event, true, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_node(parser, event, true, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_NODE_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_node(parser, event, false, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_block_sequence_entry(parser, event, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_block_sequence_entry(parser, event, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_indentless_sequence_entry(parser, event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_block_mapping_key(parser, event, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_MAPPING_KEY_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_block_mapping_key(parser, event, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_BLOCK_MAPPING_VALUE_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_block_mapping_value(parser, event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_flow_sequence_entry(parser, event, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_flow_sequence_entry(parser, event, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_flow_sequence_entry_mapping_key(parser, event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_flow_sequence_entry_mapping_value(parser, event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_flow_sequence_entry_mapping_end(parser, event)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_flow_mapping_key(parser, event, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_MAPPING_KEY_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_flow_mapping_key(parser, event, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_MAPPING_VALUE_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_flow_mapping_value(parser, event, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE:
0000000000000000000000000000000000000000;;			return yaml_parser_parse_flow_mapping_value(parser, event, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("invalid parser state")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the production:
0000000000000000000000000000000000000000;;	// stream   ::= STREAM-START implicit_document? explicit_document* STREAM-END
0000000000000000000000000000000000000000;;	//              ************
0000000000000000000000000000000000000000;;	func yaml_parser_parse_stream_start(parser *yaml_parser_t, event *yaml_event_t) bool {
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ != yaml_STREAM_START_TOKEN {
0000000000000000000000000000000000000000;;			return yaml_parser_set_parser_error(parser, "did not find expected <stream-start>", token.start_mark)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.state = yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE
0000000000000000000000000000000000000000;;		*event = yaml_event_t{
0000000000000000000000000000000000000000;;			typ:        yaml_STREAM_START_EVENT,
0000000000000000000000000000000000000000;;			start_mark: token.start_mark,
0000000000000000000000000000000000000000;;			end_mark:   token.end_mark,
0000000000000000000000000000000000000000;;			encoding:   token.encoding,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		skip_token(parser)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// implicit_document    ::= block_node DOCUMENT-END*
0000000000000000000000000000000000000000;;	//                          *
0000000000000000000000000000000000000000;;	// explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
0000000000000000000000000000000000000000;;	//                          *************************
0000000000000000000000000000000000000000;;	func yaml_parser_parse_document_start(parser *yaml_parser_t, event *yaml_event_t, implicit bool) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse extra document end indicators.
0000000000000000000000000000000000000000;;		if !implicit {
0000000000000000000000000000000000000000;;			for token.typ == yaml_DOCUMENT_END_TOKEN {
0000000000000000000000000000000000000000;;				skip_token(parser)
0000000000000000000000000000000000000000;;				token = peek_token(parser)
0000000000000000000000000000000000000000;;				if token == nil {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if implicit && token.typ != yaml_VERSION_DIRECTIVE_TOKEN &&
0000000000000000000000000000000000000000;;			token.typ != yaml_TAG_DIRECTIVE_TOKEN &&
0000000000000000000000000000000000000000;;			token.typ != yaml_DOCUMENT_START_TOKEN &&
0000000000000000000000000000000000000000;;			token.typ != yaml_STREAM_END_TOKEN {
0000000000000000000000000000000000000000;;			// Parse an implicit document.
0000000000000000000000000000000000000000;;			if !yaml_parser_process_directives(parser, nil, nil) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parser.states = append(parser.states, yaml_PARSE_DOCUMENT_END_STATE)
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_BLOCK_NODE_STATE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:        yaml_DOCUMENT_START_EVENT,
0000000000000000000000000000000000000000;;				start_mark: token.start_mark,
0000000000000000000000000000000000000000;;				end_mark:   token.end_mark,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else if token.typ != yaml_STREAM_END_TOKEN {
0000000000000000000000000000000000000000;;			// Parse an explicit document.
0000000000000000000000000000000000000000;;			var version_directive *yaml_version_directive_t
0000000000000000000000000000000000000000;;			var tag_directives []yaml_tag_directive_t
0000000000000000000000000000000000000000;;			start_mark := token.start_mark
0000000000000000000000000000000000000000;;			if !yaml_parser_process_directives(parser, &version_directive, &tag_directives) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			token = peek_token(parser)
0000000000000000000000000000000000000000;;			if token == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if token.typ != yaml_DOCUMENT_START_TOKEN {
0000000000000000000000000000000000000000;;				yaml_parser_set_parser_error(parser,
0000000000000000000000000000000000000000;;					"did not find expected <document start>", token.start_mark)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parser.states = append(parser.states, yaml_PARSE_DOCUMENT_END_STATE)
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_DOCUMENT_CONTENT_STATE
0000000000000000000000000000000000000000;;			end_mark := token.end_mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:               yaml_DOCUMENT_START_EVENT,
0000000000000000000000000000000000000000;;				start_mark:        start_mark,
0000000000000000000000000000000000000000;;				end_mark:          end_mark,
0000000000000000000000000000000000000000;;				version_directive: version_directive,
0000000000000000000000000000000000000000;;				tag_directives:    tag_directives,
0000000000000000000000000000000000000000;;				implicit:          false,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Parse the stream end.
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_END_STATE
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:        yaml_STREAM_END_EVENT,
0000000000000000000000000000000000000000;;				start_mark: token.start_mark,
0000000000000000000000000000000000000000;;				end_mark:   token.end_mark,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
0000000000000000000000000000000000000000;;	//                                                    ***********
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_document_content(parser *yaml_parser_t, event *yaml_event_t) bool {
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ == yaml_VERSION_DIRECTIVE_TOKEN ||
0000000000000000000000000000000000000000;;			token.typ == yaml_TAG_DIRECTIVE_TOKEN ||
0000000000000000000000000000000000000000;;			token.typ == yaml_DOCUMENT_START_TOKEN ||
0000000000000000000000000000000000000000;;			token.typ == yaml_DOCUMENT_END_TOKEN ||
0000000000000000000000000000000000000000;;			token.typ == yaml_STREAM_END_TOKEN {
0000000000000000000000000000000000000000;;			parser.state = parser.states[len(parser.states)-1]
0000000000000000000000000000000000000000;;			parser.states = parser.states[:len(parser.states)-1]
0000000000000000000000000000000000000000;;			return yaml_parser_process_empty_scalar(parser, event,
0000000000000000000000000000000000000000;;				token.start_mark)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return yaml_parser_parse_node(parser, event, true, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// implicit_document    ::= block_node DOCUMENT-END*
0000000000000000000000000000000000000000;;	//                                     *************
0000000000000000000000000000000000000000;;	// explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_document_end(parser *yaml_parser_t, event *yaml_event_t) bool {
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start_mark := token.start_mark
0000000000000000000000000000000000000000;;		end_mark := token.start_mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		implicit := true
0000000000000000000000000000000000000000;;		if token.typ == yaml_DOCUMENT_END_TOKEN {
0000000000000000000000000000000000000000;;			end_mark = token.end_mark
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			implicit = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parser.tag_directives = parser.tag_directives[:0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parser.state = yaml_PARSE_DOCUMENT_START_STATE
0000000000000000000000000000000000000000;;		*event = yaml_event_t{
0000000000000000000000000000000000000000;;			typ:        yaml_DOCUMENT_END_EVENT,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;			implicit:   implicit,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// block_node_or_indentless_sequence    ::=
0000000000000000000000000000000000000000;;	//                          ALIAS
0000000000000000000000000000000000000000;;	//                          *****
0000000000000000000000000000000000000000;;	//                          | properties (block_content | indentless_block_sequence)?
0000000000000000000000000000000000000000;;	//                            **********  *
0000000000000000000000000000000000000000;;	//                          | block_content | indentless_block_sequence
0000000000000000000000000000000000000000;;	//                            *
0000000000000000000000000000000000000000;;	// block_node           ::= ALIAS
0000000000000000000000000000000000000000;;	//                          *****
0000000000000000000000000000000000000000;;	//                          | properties block_content?
0000000000000000000000000000000000000000;;	//                            ********** *
0000000000000000000000000000000000000000;;	//                          | block_content
0000000000000000000000000000000000000000;;	//                            *
0000000000000000000000000000000000000000;;	// flow_node            ::= ALIAS
0000000000000000000000000000000000000000;;	//                          *****
0000000000000000000000000000000000000000;;	//                          | properties flow_content?
0000000000000000000000000000000000000000;;	//                            ********** *
0000000000000000000000000000000000000000;;	//                          | flow_content
0000000000000000000000000000000000000000;;	//                            *
0000000000000000000000000000000000000000;;	// properties           ::= TAG ANCHOR? | ANCHOR TAG?
0000000000000000000000000000000000000000;;	//                          *************************
0000000000000000000000000000000000000000;;	// block_content        ::= block_collection | flow_collection | SCALAR
0000000000000000000000000000000000000000;;	//                                                               ******
0000000000000000000000000000000000000000;;	// flow_content         ::= flow_collection | SCALAR
0000000000000000000000000000000000000000;;	//                                            ******
0000000000000000000000000000000000000000;;	func yaml_parser_parse_node(parser *yaml_parser_t, event *yaml_event_t, block, indentless_sequence bool) bool {
0000000000000000000000000000000000000000;;		//defer trace("yaml_parser_parse_node", "block:", block, "indentless_sequence:", indentless_sequence)()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if token.typ == yaml_ALIAS_TOKEN {
0000000000000000000000000000000000000000;;			parser.state = parser.states[len(parser.states)-1]
0000000000000000000000000000000000000000;;			parser.states = parser.states[:len(parser.states)-1]
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:        yaml_ALIAS_EVENT,
0000000000000000000000000000000000000000;;				start_mark: token.start_mark,
0000000000000000000000000000000000000000;;				end_mark:   token.end_mark,
0000000000000000000000000000000000000000;;				anchor:     token.value,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start_mark := token.start_mark
0000000000000000000000000000000000000000;;		end_mark := token.start_mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tag_token bool
0000000000000000000000000000000000000000;;		var tag_handle, tag_suffix, anchor []byte
0000000000000000000000000000000000000000;;		var tag_mark yaml_mark_t
0000000000000000000000000000000000000000;;		if token.typ == yaml_ANCHOR_TOKEN {
0000000000000000000000000000000000000000;;			anchor = token.value
0000000000000000000000000000000000000000;;			start_mark = token.start_mark
0000000000000000000000000000000000000000;;			end_mark = token.end_mark
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			token = peek_token(parser)
0000000000000000000000000000000000000000;;			if token == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if token.typ == yaml_TAG_TOKEN {
0000000000000000000000000000000000000000;;				tag_token = true
0000000000000000000000000000000000000000;;				tag_handle = token.value
0000000000000000000000000000000000000000;;				tag_suffix = token.suffix
0000000000000000000000000000000000000000;;				tag_mark = token.start_mark
0000000000000000000000000000000000000000;;				end_mark = token.end_mark
0000000000000000000000000000000000000000;;				skip_token(parser)
0000000000000000000000000000000000000000;;				token = peek_token(parser)
0000000000000000000000000000000000000000;;				if token == nil {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if token.typ == yaml_TAG_TOKEN {
0000000000000000000000000000000000000000;;			tag_token = true
0000000000000000000000000000000000000000;;			tag_handle = token.value
0000000000000000000000000000000000000000;;			tag_suffix = token.suffix
0000000000000000000000000000000000000000;;			start_mark = token.start_mark
0000000000000000000000000000000000000000;;			tag_mark = token.start_mark
0000000000000000000000000000000000000000;;			end_mark = token.end_mark
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			token = peek_token(parser)
0000000000000000000000000000000000000000;;			if token == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if token.typ == yaml_ANCHOR_TOKEN {
0000000000000000000000000000000000000000;;				anchor = token.value
0000000000000000000000000000000000000000;;				end_mark = token.end_mark
0000000000000000000000000000000000000000;;				skip_token(parser)
0000000000000000000000000000000000000000;;				token = peek_token(parser)
0000000000000000000000000000000000000000;;				if token == nil {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tag []byte
0000000000000000000000000000000000000000;;		if tag_token {
0000000000000000000000000000000000000000;;			if len(tag_handle) == 0 {
0000000000000000000000000000000000000000;;				tag = tag_suffix
0000000000000000000000000000000000000000;;				tag_suffix = nil
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for i := range parser.tag_directives {
0000000000000000000000000000000000000000;;					if bytes.Equal(parser.tag_directives[i].handle, tag_handle) {
0000000000000000000000000000000000000000;;						tag = append([]byte(nil), parser.tag_directives[i].prefix...)
0000000000000000000000000000000000000000;;						tag = append(tag, tag_suffix...)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(tag) == 0 {
0000000000000000000000000000000000000000;;					yaml_parser_set_parser_error_context(parser,
0000000000000000000000000000000000000000;;						"while parsing a node", start_mark,
0000000000000000000000000000000000000000;;						"found undefined tag handle", tag_mark)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		implicit := len(tag) == 0
0000000000000000000000000000000000000000;;		if indentless_sequence && token.typ == yaml_BLOCK_ENTRY_TOKEN {
0000000000000000000000000000000000000000;;			end_mark = token.end_mark
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:        yaml_SEQUENCE_START_EVENT,
0000000000000000000000000000000000000000;;				start_mark: start_mark,
0000000000000000000000000000000000000000;;				end_mark:   end_mark,
0000000000000000000000000000000000000000;;				anchor:     anchor,
0000000000000000000000000000000000000000;;				tag:        tag,
0000000000000000000000000000000000000000;;				implicit:   implicit,
0000000000000000000000000000000000000000;;				style:      yaml_style_t(yaml_BLOCK_SEQUENCE_STYLE),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ == yaml_SCALAR_TOKEN {
0000000000000000000000000000000000000000;;			var plain_implicit, quoted_implicit bool
0000000000000000000000000000000000000000;;			end_mark = token.end_mark
0000000000000000000000000000000000000000;;			if (len(tag) == 0 && token.style == yaml_PLAIN_SCALAR_STYLE) || (len(tag) == 1 && tag[0] == '!') {
0000000000000000000000000000000000000000;;				plain_implicit = true
0000000000000000000000000000000000000000;;			} else if len(tag) == 0 {
0000000000000000000000000000000000000000;;				quoted_implicit = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parser.state = parser.states[len(parser.states)-1]
0000000000000000000000000000000000000000;;			parser.states = parser.states[:len(parser.states)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:             yaml_SCALAR_EVENT,
0000000000000000000000000000000000000000;;				start_mark:      start_mark,
0000000000000000000000000000000000000000;;				end_mark:        end_mark,
0000000000000000000000000000000000000000;;				anchor:          anchor,
0000000000000000000000000000000000000000;;				tag:             tag,
0000000000000000000000000000000000000000;;				value:           token.value,
0000000000000000000000000000000000000000;;				implicit:        plain_implicit,
0000000000000000000000000000000000000000;;				quoted_implicit: quoted_implicit,
0000000000000000000000000000000000000000;;				style:           yaml_style_t(token.style),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ == yaml_FLOW_SEQUENCE_START_TOKEN {
0000000000000000000000000000000000000000;;			// [Go] Some of the events below can be merged as they differ only on style.
0000000000000000000000000000000000000000;;			end_mark = token.end_mark
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:        yaml_SEQUENCE_START_EVENT,
0000000000000000000000000000000000000000;;				start_mark: start_mark,
0000000000000000000000000000000000000000;;				end_mark:   end_mark,
0000000000000000000000000000000000000000;;				anchor:     anchor,
0000000000000000000000000000000000000000;;				tag:        tag,
0000000000000000000000000000000000000000;;				implicit:   implicit,
0000000000000000000000000000000000000000;;				style:      yaml_style_t(yaml_FLOW_SEQUENCE_STYLE),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ == yaml_FLOW_MAPPING_START_TOKEN {
0000000000000000000000000000000000000000;;			end_mark = token.end_mark
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:        yaml_MAPPING_START_EVENT,
0000000000000000000000000000000000000000;;				start_mark: start_mark,
0000000000000000000000000000000000000000;;				end_mark:   end_mark,
0000000000000000000000000000000000000000;;				anchor:     anchor,
0000000000000000000000000000000000000000;;				tag:        tag,
0000000000000000000000000000000000000000;;				implicit:   implicit,
0000000000000000000000000000000000000000;;				style:      yaml_style_t(yaml_FLOW_MAPPING_STYLE),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if block && token.typ == yaml_BLOCK_SEQUENCE_START_TOKEN {
0000000000000000000000000000000000000000;;			end_mark = token.end_mark
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:        yaml_SEQUENCE_START_EVENT,
0000000000000000000000000000000000000000;;				start_mark: start_mark,
0000000000000000000000000000000000000000;;				end_mark:   end_mark,
0000000000000000000000000000000000000000;;				anchor:     anchor,
0000000000000000000000000000000000000000;;				tag:        tag,
0000000000000000000000000000000000000000;;				implicit:   implicit,
0000000000000000000000000000000000000000;;				style:      yaml_style_t(yaml_BLOCK_SEQUENCE_STYLE),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if block && token.typ == yaml_BLOCK_MAPPING_START_TOKEN {
0000000000000000000000000000000000000000;;			end_mark = token.end_mark
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:        yaml_MAPPING_START_EVENT,
0000000000000000000000000000000000000000;;				start_mark: start_mark,
0000000000000000000000000000000000000000;;				end_mark:   end_mark,
0000000000000000000000000000000000000000;;				anchor:     anchor,
0000000000000000000000000000000000000000;;				tag:        tag,
0000000000000000000000000000000000000000;;				implicit:   implicit,
0000000000000000000000000000000000000000;;				style:      yaml_style_t(yaml_BLOCK_MAPPING_STYLE),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(anchor) > 0 || len(tag) > 0 {
0000000000000000000000000000000000000000;;			parser.state = parser.states[len(parser.states)-1]
0000000000000000000000000000000000000000;;			parser.states = parser.states[:len(parser.states)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:             yaml_SCALAR_EVENT,
0000000000000000000000000000000000000000;;				start_mark:      start_mark,
0000000000000000000000000000000000000000;;				end_mark:        end_mark,
0000000000000000000000000000000000000000;;				anchor:          anchor,
0000000000000000000000000000000000000000;;				tag:             tag,
0000000000000000000000000000000000000000;;				implicit:        implicit,
0000000000000000000000000000000000000000;;				quoted_implicit: false,
0000000000000000000000000000000000000000;;				style:           yaml_style_t(yaml_PLAIN_SCALAR_STYLE),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := "while parsing a flow node"
0000000000000000000000000000000000000000;;		if block {
0000000000000000000000000000000000000000;;			context = "while parsing a block node"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_parser_set_parser_error_context(parser, context, start_mark,
0000000000000000000000000000000000000000;;			"did not find expected node content", token.start_mark)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
0000000000000000000000000000000000000000;;	//                    ********************  *********** *             *********
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_block_sequence_entry(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
0000000000000000000000000000000000000000;;		if first {
0000000000000000000000000000000000000000;;			token := peek_token(parser)
0000000000000000000000000000000000000000;;			parser.marks = append(parser.marks, token.start_mark)
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if token.typ == yaml_BLOCK_ENTRY_TOKEN {
0000000000000000000000000000000000000000;;			mark := token.end_mark
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			token = peek_token(parser)
0000000000000000000000000000000000000000;;			if token == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if token.typ != yaml_BLOCK_ENTRY_TOKEN && token.typ != yaml_BLOCK_END_TOKEN {
0000000000000000000000000000000000000000;;				parser.states = append(parser.states, yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE)
0000000000000000000000000000000000000000;;				return yaml_parser_parse_node(parser, event, true, false)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				parser.state = yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE
0000000000000000000000000000000000000000;;				return yaml_parser_process_empty_scalar(parser, event, mark)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ == yaml_BLOCK_END_TOKEN {
0000000000000000000000000000000000000000;;			parser.state = parser.states[len(parser.states)-1]
0000000000000000000000000000000000000000;;			parser.states = parser.states[:len(parser.states)-1]
0000000000000000000000000000000000000000;;			parser.marks = parser.marks[:len(parser.marks)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:        yaml_SEQUENCE_END_EVENT,
0000000000000000000000000000000000000000;;				start_mark: token.start_mark,
0000000000000000000000000000000000000000;;				end_mark:   token.end_mark,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context_mark := parser.marks[len(parser.marks)-1]
0000000000000000000000000000000000000000;;		parser.marks = parser.marks[:len(parser.marks)-1]
0000000000000000000000000000000000000000;;		return yaml_parser_set_parser_error_context(parser,
0000000000000000000000000000000000000000;;			"while parsing a block collection", context_mark,
0000000000000000000000000000000000000000;;			"did not find expected '-' indicator", token.start_mark)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// indentless_sequence  ::= (BLOCK-ENTRY block_node?)+
0000000000000000000000000000000000000000;;	//                           *********** *
0000000000000000000000000000000000000000;;	func yaml_parser_parse_indentless_sequence_entry(parser *yaml_parser_t, event *yaml_event_t) bool {
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if token.typ == yaml_BLOCK_ENTRY_TOKEN {
0000000000000000000000000000000000000000;;			mark := token.end_mark
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			token = peek_token(parser)
0000000000000000000000000000000000000000;;			if token == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if token.typ != yaml_BLOCK_ENTRY_TOKEN &&
0000000000000000000000000000000000000000;;				token.typ != yaml_KEY_TOKEN &&
0000000000000000000000000000000000000000;;				token.typ != yaml_VALUE_TOKEN &&
0000000000000000000000000000000000000000;;				token.typ != yaml_BLOCK_END_TOKEN {
0000000000000000000000000000000000000000;;				parser.states = append(parser.states, yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE)
0000000000000000000000000000000000000000;;				return yaml_parser_parse_node(parser, event, true, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
0000000000000000000000000000000000000000;;			return yaml_parser_process_empty_scalar(parser, event, mark)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.state = parser.states[len(parser.states)-1]
0000000000000000000000000000000000000000;;		parser.states = parser.states[:len(parser.states)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*event = yaml_event_t{
0000000000000000000000000000000000000000;;			typ:        yaml_SEQUENCE_END_EVENT,
0000000000000000000000000000000000000000;;			start_mark: token.start_mark,
0000000000000000000000000000000000000000;;			end_mark:   token.start_mark, // [Go] Shouldn't this be token.end_mark?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// block_mapping        ::= BLOCK-MAPPING_START
0000000000000000000000000000000000000000;;	//                          *******************
0000000000000000000000000000000000000000;;	//                          ((KEY block_node_or_indentless_sequence?)?
0000000000000000000000000000000000000000;;	//                            *** *
0000000000000000000000000000000000000000;;	//                          (VALUE block_node_or_indentless_sequence?)?)*
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//                          BLOCK-END
0000000000000000000000000000000000000000;;	//                          *********
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_block_mapping_key(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
0000000000000000000000000000000000000000;;		if first {
0000000000000000000000000000000000000000;;			token := peek_token(parser)
0000000000000000000000000000000000000000;;			parser.marks = append(parser.marks, token.start_mark)
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if token.typ == yaml_KEY_TOKEN {
0000000000000000000000000000000000000000;;			mark := token.end_mark
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			token = peek_token(parser)
0000000000000000000000000000000000000000;;			if token == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if token.typ != yaml_KEY_TOKEN &&
0000000000000000000000000000000000000000;;				token.typ != yaml_VALUE_TOKEN &&
0000000000000000000000000000000000000000;;				token.typ != yaml_BLOCK_END_TOKEN {
0000000000000000000000000000000000000000;;				parser.states = append(parser.states, yaml_PARSE_BLOCK_MAPPING_VALUE_STATE)
0000000000000000000000000000000000000000;;				return yaml_parser_parse_node(parser, event, true, true)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				parser.state = yaml_PARSE_BLOCK_MAPPING_VALUE_STATE
0000000000000000000000000000000000000000;;				return yaml_parser_process_empty_scalar(parser, event, mark)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if token.typ == yaml_BLOCK_END_TOKEN {
0000000000000000000000000000000000000000;;			parser.state = parser.states[len(parser.states)-1]
0000000000000000000000000000000000000000;;			parser.states = parser.states[:len(parser.states)-1]
0000000000000000000000000000000000000000;;			parser.marks = parser.marks[:len(parser.marks)-1]
0000000000000000000000000000000000000000;;			*event = yaml_event_t{
0000000000000000000000000000000000000000;;				typ:        yaml_MAPPING_END_EVENT,
0000000000000000000000000000000000000000;;				start_mark: token.start_mark,
0000000000000000000000000000000000000000;;				end_mark:   token.end_mark,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context_mark := parser.marks[len(parser.marks)-1]
0000000000000000000000000000000000000000;;		parser.marks = parser.marks[:len(parser.marks)-1]
0000000000000000000000000000000000000000;;		return yaml_parser_set_parser_error_context(parser,
0000000000000000000000000000000000000000;;			"while parsing a block mapping", context_mark,
0000000000000000000000000000000000000000;;			"did not find expected key", token.start_mark)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// block_mapping        ::= BLOCK-MAPPING_START
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//                          ((KEY block_node_or_indentless_sequence?)?
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//                          (VALUE block_node_or_indentless_sequence?)?)*
0000000000000000000000000000000000000000;;	//                           ***** *
0000000000000000000000000000000000000000;;	//                          BLOCK-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_block_mapping_value(parser *yaml_parser_t, event *yaml_event_t) bool {
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ == yaml_VALUE_TOKEN {
0000000000000000000000000000000000000000;;			mark := token.end_mark
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			token = peek_token(parser)
0000000000000000000000000000000000000000;;			if token == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if token.typ != yaml_KEY_TOKEN &&
0000000000000000000000000000000000000000;;				token.typ != yaml_VALUE_TOKEN &&
0000000000000000000000000000000000000000;;				token.typ != yaml_BLOCK_END_TOKEN {
0000000000000000000000000000000000000000;;				parser.states = append(parser.states, yaml_PARSE_BLOCK_MAPPING_KEY_STATE)
0000000000000000000000000000000000000000;;				return yaml_parser_parse_node(parser, event, true, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_BLOCK_MAPPING_KEY_STATE
0000000000000000000000000000000000000000;;			return yaml_parser_process_empty_scalar(parser, event, mark)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.state = yaml_PARSE_BLOCK_MAPPING_KEY_STATE
0000000000000000000000000000000000000000;;		return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// flow_sequence        ::= FLOW-SEQUENCE-START
0000000000000000000000000000000000000000;;	//                          *******************
0000000000000000000000000000000000000000;;	//                          (flow_sequence_entry FLOW-ENTRY)*
0000000000000000000000000000000000000000;;	//                           *                   **********
0000000000000000000000000000000000000000;;	//                          flow_sequence_entry?
0000000000000000000000000000000000000000;;	//                          *
0000000000000000000000000000000000000000;;	//                          FLOW-SEQUENCE-END
0000000000000000000000000000000000000000;;	//                          *****************
0000000000000000000000000000000000000000;;	// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
0000000000000000000000000000000000000000;;	//                          *
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_flow_sequence_entry(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
0000000000000000000000000000000000000000;;		if first {
0000000000000000000000000000000000000000;;			token := peek_token(parser)
0000000000000000000000000000000000000000;;			parser.marks = append(parser.marks, token.start_mark)
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
0000000000000000000000000000000000000000;;			if !first {
0000000000000000000000000000000000000000;;				if token.typ == yaml_FLOW_ENTRY_TOKEN {
0000000000000000000000000000000000000000;;					skip_token(parser)
0000000000000000000000000000000000000000;;					token = peek_token(parser)
0000000000000000000000000000000000000000;;					if token == nil {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					context_mark := parser.marks[len(parser.marks)-1]
0000000000000000000000000000000000000000;;					parser.marks = parser.marks[:len(parser.marks)-1]
0000000000000000000000000000000000000000;;					return yaml_parser_set_parser_error_context(parser,
0000000000000000000000000000000000000000;;						"while parsing a flow sequence", context_mark,
0000000000000000000000000000000000000000;;						"did not find expected ',' or ']'", token.start_mark)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if token.typ == yaml_KEY_TOKEN {
0000000000000000000000000000000000000000;;				parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE
0000000000000000000000000000000000000000;;				*event = yaml_event_t{
0000000000000000000000000000000000000000;;					typ:        yaml_MAPPING_START_EVENT,
0000000000000000000000000000000000000000;;					start_mark: token.start_mark,
0000000000000000000000000000000000000000;;					end_mark:   token.end_mark,
0000000000000000000000000000000000000000;;					implicit:   true,
0000000000000000000000000000000000000000;;					style:      yaml_style_t(yaml_FLOW_MAPPING_STYLE),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				skip_token(parser)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			} else if token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
0000000000000000000000000000000000000000;;				parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE)
0000000000000000000000000000000000000000;;				return yaml_parser_parse_node(parser, event, false, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parser.state = parser.states[len(parser.states)-1]
0000000000000000000000000000000000000000;;		parser.states = parser.states[:len(parser.states)-1]
0000000000000000000000000000000000000000;;		parser.marks = parser.marks[:len(parser.marks)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*event = yaml_event_t{
0000000000000000000000000000000000000000;;			typ:        yaml_SEQUENCE_END_EVENT,
0000000000000000000000000000000000000000;;			start_mark: token.start_mark,
0000000000000000000000000000000000000000;;			end_mark:   token.end_mark,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		skip_token(parser)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
0000000000000000000000000000000000000000;;	//                                      *** *
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_flow_sequence_entry_mapping_key(parser *yaml_parser_t, event *yaml_event_t) bool {
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ != yaml_VALUE_TOKEN &&
0000000000000000000000000000000000000000;;			token.typ != yaml_FLOW_ENTRY_TOKEN &&
0000000000000000000000000000000000000000;;			token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
0000000000000000000000000000000000000000;;			parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE)
0000000000000000000000000000000000000000;;			return yaml_parser_parse_node(parser, event, false, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mark := token.end_mark
0000000000000000000000000000000000000000;;		skip_token(parser)
0000000000000000000000000000000000000000;;		parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE
0000000000000000000000000000000000000000;;		return yaml_parser_process_empty_scalar(parser, event, mark)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
0000000000000000000000000000000000000000;;	//                                                      ***** *
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_flow_sequence_entry_mapping_value(parser *yaml_parser_t, event *yaml_event_t) bool {
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ == yaml_VALUE_TOKEN {
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			token := peek_token(parser)
0000000000000000000000000000000000000000;;			if token == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if token.typ != yaml_FLOW_ENTRY_TOKEN && token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
0000000000000000000000000000000000000000;;				parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE)
0000000000000000000000000000000000000000;;				return yaml_parser_parse_node(parser, event, false, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE
0000000000000000000000000000000000000000;;		return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
0000000000000000000000000000000000000000;;	//                                                                      *
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_flow_sequence_entry_mapping_end(parser *yaml_parser_t, event *yaml_event_t) bool {
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE
0000000000000000000000000000000000000000;;		*event = yaml_event_t{
0000000000000000000000000000000000000000;;			typ:        yaml_MAPPING_END_EVENT,
0000000000000000000000000000000000000000;;			start_mark: token.start_mark,
0000000000000000000000000000000000000000;;			end_mark:   token.start_mark, // [Go] Shouldn't this be end_mark?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// flow_mapping         ::= FLOW-MAPPING-START
0000000000000000000000000000000000000000;;	//                          ******************
0000000000000000000000000000000000000000;;	//                          (flow_mapping_entry FLOW-ENTRY)*
0000000000000000000000000000000000000000;;	//                           *                  **********
0000000000000000000000000000000000000000;;	//                          flow_mapping_entry?
0000000000000000000000000000000000000000;;	//                          ******************
0000000000000000000000000000000000000000;;	//                          FLOW-MAPPING-END
0000000000000000000000000000000000000000;;	//                          ****************
0000000000000000000000000000000000000000;;	// flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
0000000000000000000000000000000000000000;;	//                          *           *** *
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_flow_mapping_key(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
0000000000000000000000000000000000000000;;		if first {
0000000000000000000000000000000000000000;;			token := peek_token(parser)
0000000000000000000000000000000000000000;;			parser.marks = append(parser.marks, token.start_mark)
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if token.typ != yaml_FLOW_MAPPING_END_TOKEN {
0000000000000000000000000000000000000000;;			if !first {
0000000000000000000000000000000000000000;;				if token.typ == yaml_FLOW_ENTRY_TOKEN {
0000000000000000000000000000000000000000;;					skip_token(parser)
0000000000000000000000000000000000000000;;					token = peek_token(parser)
0000000000000000000000000000000000000000;;					if token == nil {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					context_mark := parser.marks[len(parser.marks)-1]
0000000000000000000000000000000000000000;;					parser.marks = parser.marks[:len(parser.marks)-1]
0000000000000000000000000000000000000000;;					return yaml_parser_set_parser_error_context(parser,
0000000000000000000000000000000000000000;;						"while parsing a flow mapping", context_mark,
0000000000000000000000000000000000000000;;						"did not find expected ',' or '}'", token.start_mark)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if token.typ == yaml_KEY_TOKEN {
0000000000000000000000000000000000000000;;				skip_token(parser)
0000000000000000000000000000000000000000;;				token = peek_token(parser)
0000000000000000000000000000000000000000;;				if token == nil {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if token.typ != yaml_VALUE_TOKEN &&
0000000000000000000000000000000000000000;;					token.typ != yaml_FLOW_ENTRY_TOKEN &&
0000000000000000000000000000000000000000;;					token.typ != yaml_FLOW_MAPPING_END_TOKEN {
0000000000000000000000000000000000000000;;					parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_VALUE_STATE)
0000000000000000000000000000000000000000;;					return yaml_parser_parse_node(parser, event, false, false)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					parser.state = yaml_PARSE_FLOW_MAPPING_VALUE_STATE
0000000000000000000000000000000000000000;;					return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if token.typ != yaml_FLOW_MAPPING_END_TOKEN {
0000000000000000000000000000000000000000;;				parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE)
0000000000000000000000000000000000000000;;				return yaml_parser_parse_node(parser, event, false, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parser.state = parser.states[len(parser.states)-1]
0000000000000000000000000000000000000000;;		parser.states = parser.states[:len(parser.states)-1]
0000000000000000000000000000000000000000;;		parser.marks = parser.marks[:len(parser.marks)-1]
0000000000000000000000000000000000000000;;		*event = yaml_event_t{
0000000000000000000000000000000000000000;;			typ:        yaml_MAPPING_END_EVENT,
0000000000000000000000000000000000000000;;			start_mark: token.start_mark,
0000000000000000000000000000000000000000;;			end_mark:   token.end_mark,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		skip_token(parser)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the productions:
0000000000000000000000000000000000000000;;	// flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
0000000000000000000000000000000000000000;;	//                                   *                  ***** *
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_parse_flow_mapping_value(parser *yaml_parser_t, event *yaml_event_t, empty bool) bool {
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if empty {
0000000000000000000000000000000000000000;;			parser.state = yaml_PARSE_FLOW_MAPPING_KEY_STATE
0000000000000000000000000000000000000000;;			return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.typ == yaml_VALUE_TOKEN {
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			token = peek_token(parser)
0000000000000000000000000000000000000000;;			if token == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if token.typ != yaml_FLOW_ENTRY_TOKEN && token.typ != yaml_FLOW_MAPPING_END_TOKEN {
0000000000000000000000000000000000000000;;				parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_KEY_STATE)
0000000000000000000000000000000000000000;;				return yaml_parser_parse_node(parser, event, false, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.state = yaml_PARSE_FLOW_MAPPING_KEY_STATE
0000000000000000000000000000000000000000;;		return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate an empty scalar event.
0000000000000000000000000000000000000000;;	func yaml_parser_process_empty_scalar(parser *yaml_parser_t, event *yaml_event_t, mark yaml_mark_t) bool {
0000000000000000000000000000000000000000;;		*event = yaml_event_t{
0000000000000000000000000000000000000000;;			typ:        yaml_SCALAR_EVENT,
0000000000000000000000000000000000000000;;			start_mark: mark,
0000000000000000000000000000000000000000;;			end_mark:   mark,
0000000000000000000000000000000000000000;;			value:      nil, // Empty
0000000000000000000000000000000000000000;;			implicit:   true,
0000000000000000000000000000000000000000;;			style:      yaml_style_t(yaml_PLAIN_SCALAR_STYLE),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var default_tag_directives = []yaml_tag_directive_t{
0000000000000000000000000000000000000000;;		{[]byte("!"), []byte("!")},
0000000000000000000000000000000000000000;;		{[]byte("!!"), []byte("tag:yaml.org,2002:")},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse directives.
0000000000000000000000000000000000000000;;	func yaml_parser_process_directives(parser *yaml_parser_t,
0000000000000000000000000000000000000000;;		version_directive_ref **yaml_version_directive_t,
0000000000000000000000000000000000000000;;		tag_directives_ref *[]yaml_tag_directive_t) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var version_directive *yaml_version_directive_t
0000000000000000000000000000000000000000;;		var tag_directives []yaml_tag_directive_t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token := peek_token(parser)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for token.typ == yaml_VERSION_DIRECTIVE_TOKEN || token.typ == yaml_TAG_DIRECTIVE_TOKEN {
0000000000000000000000000000000000000000;;			if token.typ == yaml_VERSION_DIRECTIVE_TOKEN {
0000000000000000000000000000000000000000;;				if version_directive != nil {
0000000000000000000000000000000000000000;;					yaml_parser_set_parser_error(parser,
0000000000000000000000000000000000000000;;						"found duplicate %YAML directive", token.start_mark)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if token.major != 1 || token.minor != 1 {
0000000000000000000000000000000000000000;;					yaml_parser_set_parser_error(parser,
0000000000000000000000000000000000000000;;						"found incompatible YAML document", token.start_mark)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				version_directive = &yaml_version_directive_t{
0000000000000000000000000000000000000000;;					major: token.major,
0000000000000000000000000000000000000000;;					minor: token.minor,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if token.typ == yaml_TAG_DIRECTIVE_TOKEN {
0000000000000000000000000000000000000000;;				value := yaml_tag_directive_t{
0000000000000000000000000000000000000000;;					handle: token.value,
0000000000000000000000000000000000000000;;					prefix: token.prefix,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !yaml_parser_append_tag_directive(parser, value, false, token.start_mark) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tag_directives = append(tag_directives, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			skip_token(parser)
0000000000000000000000000000000000000000;;			token = peek_token(parser)
0000000000000000000000000000000000000000;;			if token == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range default_tag_directives {
0000000000000000000000000000000000000000;;			if !yaml_parser_append_tag_directive(parser, default_tag_directives[i], true, token.start_mark) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if version_directive_ref != nil {
0000000000000000000000000000000000000000;;			*version_directive_ref = version_directive
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tag_directives_ref != nil {
0000000000000000000000000000000000000000;;			*tag_directives_ref = tag_directives
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Append a tag directive to the directives stack.
0000000000000000000000000000000000000000;;	func yaml_parser_append_tag_directive(parser *yaml_parser_t, value yaml_tag_directive_t, allow_duplicates bool, mark yaml_mark_t) bool {
0000000000000000000000000000000000000000;;		for i := range parser.tag_directives {
0000000000000000000000000000000000000000;;			if bytes.Equal(value.handle, parser.tag_directives[i].handle) {
0000000000000000000000000000000000000000;;				if allow_duplicates {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return yaml_parser_set_parser_error(parser, "found duplicate %TAG directive", mark)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// [Go] I suspect the copy is unnecessary. This was likely done
0000000000000000000000000000000000000000;;		// because there was no way to track ownership of the data.
0000000000000000000000000000000000000000;;		value_copy := yaml_tag_directive_t{
0000000000000000000000000000000000000000;;			handle: make([]byte, len(value.handle)),
0000000000000000000000000000000000000000;;			prefix: make([]byte, len(value.prefix)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(value_copy.handle, value.handle)
0000000000000000000000000000000000000000;;		copy(value_copy.prefix, value.prefix)
0000000000000000000000000000000000000000;;		parser.tag_directives = append(parser.tag_directives, value_copy)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
