0000000000000000000000000000000000000000;;	package yaml
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/gopkg.in/v2/yaml/readerc.go[Godeps/_workspace/src/gopkg.in/v2/yaml/readerc.go][vendor/gopkg.in/yaml.v2/readerc.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the reader error and return 0.
0000000000000000000000000000000000000000;;	func yaml_parser_set_reader_error(parser *yaml_parser_t, problem string, offset int, value int) bool {
0000000000000000000000000000000000000000;;		parser.error = yaml_READER_ERROR
0000000000000000000000000000000000000000;;		parser.problem = problem
0000000000000000000000000000000000000000;;		parser.problem_offset = offset
0000000000000000000000000000000000000000;;		parser.problem_value = value
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Byte order marks.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bom_UTF8    = "\xef\xbb\xbf"
0000000000000000000000000000000000000000;;		bom_UTF16LE = "\xff\xfe"
0000000000000000000000000000000000000000;;		bom_UTF16BE = "\xfe\xff"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Determine the input stream encoding by checking the BOM symbol. If no BOM is
0000000000000000000000000000000000000000;;	// found, the UTF-8 encoding is assumed. Return 1 on success, 0 on failure.
0000000000000000000000000000000000000000;;	func yaml_parser_determine_encoding(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// Ensure that we had enough bytes in the raw buffer.
0000000000000000000000000000000000000000;;		for !parser.eof && len(parser.raw_buffer)-parser.raw_buffer_pos < 3 {
0000000000000000000000000000000000000000;;			if !yaml_parser_update_raw_buffer(parser) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine the encoding.
0000000000000000000000000000000000000000;;		buf := parser.raw_buffer
0000000000000000000000000000000000000000;;		pos := parser.raw_buffer_pos
0000000000000000000000000000000000000000;;		avail := len(buf) - pos
0000000000000000000000000000000000000000;;		if avail >= 2 && buf[pos] == bom_UTF16LE[0] && buf[pos+1] == bom_UTF16LE[1] {
0000000000000000000000000000000000000000;;			parser.encoding = yaml_UTF16LE_ENCODING
0000000000000000000000000000000000000000;;			parser.raw_buffer_pos += 2
0000000000000000000000000000000000000000;;			parser.offset += 2
0000000000000000000000000000000000000000;;		} else if avail >= 2 && buf[pos] == bom_UTF16BE[0] && buf[pos+1] == bom_UTF16BE[1] {
0000000000000000000000000000000000000000;;			parser.encoding = yaml_UTF16BE_ENCODING
0000000000000000000000000000000000000000;;			parser.raw_buffer_pos += 2
0000000000000000000000000000000000000000;;			parser.offset += 2
0000000000000000000000000000000000000000;;		} else if avail >= 3 && buf[pos] == bom_UTF8[0] && buf[pos+1] == bom_UTF8[1] && buf[pos+2] == bom_UTF8[2] {
0000000000000000000000000000000000000000;;			parser.encoding = yaml_UTF8_ENCODING
0000000000000000000000000000000000000000;;			parser.raw_buffer_pos += 3
0000000000000000000000000000000000000000;;			parser.offset += 3
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			parser.encoding = yaml_UTF8_ENCODING
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update the raw buffer.
0000000000000000000000000000000000000000;;	func yaml_parser_update_raw_buffer(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		size_read := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return if the raw buffer is full.
0000000000000000000000000000000000000000;;		if parser.raw_buffer_pos == 0 && len(parser.raw_buffer) == cap(parser.raw_buffer) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return on EOF.
0000000000000000000000000000000000000000;;		if parser.eof {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move the remaining bytes in the raw buffer to the beginning.
0000000000000000000000000000000000000000;;		if parser.raw_buffer_pos > 0 && parser.raw_buffer_pos < len(parser.raw_buffer) {
0000000000000000000000000000000000000000;;			copy(parser.raw_buffer, parser.raw_buffer[parser.raw_buffer_pos:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.raw_buffer = parser.raw_buffer[:len(parser.raw_buffer)-parser.raw_buffer_pos]
0000000000000000000000000000000000000000;;		parser.raw_buffer_pos = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call the read handler to fill the buffer.
0000000000000000000000000000000000000000;;		size_read, err := parser.read_handler(parser, parser.raw_buffer[len(parser.raw_buffer):cap(parser.raw_buffer)])
0000000000000000000000000000000000000000;;		parser.raw_buffer = parser.raw_buffer[:len(parser.raw_buffer)+size_read]
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			parser.eof = true
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return yaml_parser_set_reader_error(parser, "input error: "+err.Error(), parser.offset, -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure that the buffer contains at least `length` characters.
0000000000000000000000000000000000000000;;	// Return true on success, false on failure.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The length is supposed to be significantly less that the buffer size.
0000000000000000000000000000000000000000;;	func yaml_parser_update_buffer(parser *yaml_parser_t, length int) bool {
0000000000000000000000000000000000000000;;		if parser.read_handler == nil {
0000000000000000000000000000000000000000;;			panic("read handler must be set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the EOF flag is set and the raw buffer is empty, do nothing.
0000000000000000000000000000000000000000;;		if parser.eof && parser.raw_buffer_pos == len(parser.raw_buffer) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return if the buffer contains enough characters.
0000000000000000000000000000000000000000;;		if parser.unread >= length {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine the input encoding if it is not known yet.
0000000000000000000000000000000000000000;;		if parser.encoding == yaml_ANY_ENCODING {
0000000000000000000000000000000000000000;;			if !yaml_parser_determine_encoding(parser) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move the unread characters to the beginning of the buffer.
0000000000000000000000000000000000000000;;		buffer_len := len(parser.buffer)
0000000000000000000000000000000000000000;;		if parser.buffer_pos > 0 && parser.buffer_pos < buffer_len {
0000000000000000000000000000000000000000;;			copy(parser.buffer, parser.buffer[parser.buffer_pos:])
0000000000000000000000000000000000000000;;			buffer_len -= parser.buffer_pos
0000000000000000000000000000000000000000;;			parser.buffer_pos = 0
0000000000000000000000000000000000000000;;		} else if parser.buffer_pos == buffer_len {
0000000000000000000000000000000000000000;;			buffer_len = 0
0000000000000000000000000000000000000000;;			parser.buffer_pos = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Open the whole buffer for writing, and cut it before returning.
0000000000000000000000000000000000000000;;		parser.buffer = parser.buffer[:cap(parser.buffer)]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fill the buffer until it has enough characters.
0000000000000000000000000000000000000000;;		first := true
0000000000000000000000000000000000000000;;		for parser.unread < length {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Fill the raw buffer if necessary.
0000000000000000000000000000000000000000;;			if !first || parser.raw_buffer_pos == len(parser.raw_buffer) {
0000000000000000000000000000000000000000;;				if !yaml_parser_update_raw_buffer(parser) {
0000000000000000000000000000000000000000;;					parser.buffer = parser.buffer[:buffer_len]
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			first = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Decode the raw buffer.
0000000000000000000000000000000000000000;;		inner:
0000000000000000000000000000000000000000;;			for parser.raw_buffer_pos != len(parser.raw_buffer) {
0000000000000000000000000000000000000000;;				var value rune
0000000000000000000000000000000000000000;;				var width int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				raw_unread := len(parser.raw_buffer) - parser.raw_buffer_pos
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Decode the next character.
0000000000000000000000000000000000000000;;				switch parser.encoding {
0000000000000000000000000000000000000000;;				case yaml_UTF8_ENCODING:
0000000000000000000000000000000000000000;;					// Decode a UTF-8 character.  Check RFC 3629
0000000000000000000000000000000000000000;;					// (http://www.ietf.org/rfc/rfc3629.txt) for more details.
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// The following table (taken from the RFC) is used for
0000000000000000000000000000000000000000;;					// decoding.
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					//    Char. number range |        UTF-8 octet sequence
0000000000000000000000000000000000000000;;					//      (hexadecimal)    |              (binary)
0000000000000000000000000000000000000000;;					//   --------------------+------------------------------------
0000000000000000000000000000000000000000;;					//   0000 0000-0000 007F | 0xxxxxxx
0000000000000000000000000000000000000000;;					//   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000000000000000000000000000000000000000;;					//   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0000000000000000000000000000000000000000;;					//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// Additionally, the characters in the range 0xD800-0xDFFF
0000000000000000000000000000000000000000;;					// are prohibited as they are reserved for use with UTF-16
0000000000000000000000000000000000000000;;					// surrogate pairs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Determine the length of the UTF-8 sequence.
0000000000000000000000000000000000000000;;					octet := parser.raw_buffer[parser.raw_buffer_pos]
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case octet&0x80 == 0x00:
0000000000000000000000000000000000000000;;						width = 1
0000000000000000000000000000000000000000;;					case octet&0xE0 == 0xC0:
0000000000000000000000000000000000000000;;						width = 2
0000000000000000000000000000000000000000;;					case octet&0xF0 == 0xE0:
0000000000000000000000000000000000000000;;						width = 3
0000000000000000000000000000000000000000;;					case octet&0xF8 == 0xF0:
0000000000000000000000000000000000000000;;						width = 4
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						// The leading octet is invalid.
0000000000000000000000000000000000000000;;						return yaml_parser_set_reader_error(parser,
0000000000000000000000000000000000000000;;							"invalid leading UTF-8 octet",
0000000000000000000000000000000000000000;;							parser.offset, int(octet))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check if the raw buffer contains an incomplete character.
0000000000000000000000000000000000000000;;					if width > raw_unread {
0000000000000000000000000000000000000000;;						if parser.eof {
0000000000000000000000000000000000000000;;							return yaml_parser_set_reader_error(parser,
0000000000000000000000000000000000000000;;								"incomplete UTF-8 octet sequence",
0000000000000000000000000000000000000000;;								parser.offset, -1)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break inner
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Decode the leading octet.
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case octet&0x80 == 0x00:
0000000000000000000000000000000000000000;;						value = rune(octet & 0x7F)
0000000000000000000000000000000000000000;;					case octet&0xE0 == 0xC0:
0000000000000000000000000000000000000000;;						value = rune(octet & 0x1F)
0000000000000000000000000000000000000000;;					case octet&0xF0 == 0xE0:
0000000000000000000000000000000000000000;;						value = rune(octet & 0x0F)
0000000000000000000000000000000000000000;;					case octet&0xF8 == 0xF0:
0000000000000000000000000000000000000000;;						value = rune(octet & 0x07)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						value = 0
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check and decode the trailing octets.
0000000000000000000000000000000000000000;;					for k := 1; k < width; k++ {
0000000000000000000000000000000000000000;;						octet = parser.raw_buffer[parser.raw_buffer_pos+k]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Check if the octet is valid.
0000000000000000000000000000000000000000;;						if (octet & 0xC0) != 0x80 {
0000000000000000000000000000000000000000;;							return yaml_parser_set_reader_error(parser,
0000000000000000000000000000000000000000;;								"invalid trailing UTF-8 octet",
0000000000000000000000000000000000000000;;								parser.offset+k, int(octet))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Decode the octet.
0000000000000000000000000000000000000000;;						value = (value << 6) + rune(octet&0x3F)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check the length of the sequence against the value.
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case width == 1:
0000000000000000000000000000000000000000;;					case width == 2 && value >= 0x80:
0000000000000000000000000000000000000000;;					case width == 3 && value >= 0x800:
0000000000000000000000000000000000000000;;					case width == 4 && value >= 0x10000:
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						return yaml_parser_set_reader_error(parser,
0000000000000000000000000000000000000000;;							"invalid length of a UTF-8 sequence",
0000000000000000000000000000000000000000;;							parser.offset, -1)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check the range of the value.
0000000000000000000000000000000000000000;;					if value >= 0xD800 && value <= 0xDFFF || value > 0x10FFFF {
0000000000000000000000000000000000000000;;						return yaml_parser_set_reader_error(parser,
0000000000000000000000000000000000000000;;							"invalid Unicode character",
0000000000000000000000000000000000000000;;							parser.offset, int(value))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case yaml_UTF16LE_ENCODING, yaml_UTF16BE_ENCODING:
0000000000000000000000000000000000000000;;					var low, high int
0000000000000000000000000000000000000000;;					if parser.encoding == yaml_UTF16LE_ENCODING {
0000000000000000000000000000000000000000;;						low, high = 0, 1
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						high, low = 1, 0
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// The UTF-16 encoding is not as simple as one might
0000000000000000000000000000000000000000;;					// naively think.  Check RFC 2781
0000000000000000000000000000000000000000;;					// (http://www.ietf.org/rfc/rfc2781.txt).
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// Normally, two subsequent bytes describe a Unicode
0000000000000000000000000000000000000000;;					// character.  However a special technique (called a
0000000000000000000000000000000000000000;;					// surrogate pair) is used for specifying character
0000000000000000000000000000000000000000;;					// values larger than 0xFFFF.
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// A surrogate pair consists of two pseudo-characters:
0000000000000000000000000000000000000000;;					//      high surrogate area (0xD800-0xDBFF)
0000000000000000000000000000000000000000;;					//      low surrogate area (0xDC00-0xDFFF)
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// The following formulas are used for decoding
0000000000000000000000000000000000000000;;					// and encoding characters using surrogate pairs:
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					//  U  = U' + 0x10000   (0x01 00 00 <= U <= 0x10 FF FF)
0000000000000000000000000000000000000000;;					//  U' = yyyyyyyyyyxxxxxxxxxx   (0 <= U' <= 0x0F FF FF)
0000000000000000000000000000000000000000;;					//  W1 = 110110yyyyyyyyyy
0000000000000000000000000000000000000000;;					//  W2 = 110111xxxxxxxxxx
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// where U is the character value, W1 is the high surrogate
0000000000000000000000000000000000000000;;					// area, W2 is the low surrogate area.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check for incomplete UTF-16 character.
0000000000000000000000000000000000000000;;					if raw_unread < 2 {
0000000000000000000000000000000000000000;;						if parser.eof {
0000000000000000000000000000000000000000;;							return yaml_parser_set_reader_error(parser,
0000000000000000000000000000000000000000;;								"incomplete UTF-16 character",
0000000000000000000000000000000000000000;;								parser.offset, -1)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break inner
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Get the character.
0000000000000000000000000000000000000000;;					value = rune(parser.raw_buffer[parser.raw_buffer_pos+low]) +
0000000000000000000000000000000000000000;;						(rune(parser.raw_buffer[parser.raw_buffer_pos+high]) << 8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check for unexpected low surrogate area.
0000000000000000000000000000000000000000;;					if value&0xFC00 == 0xDC00 {
0000000000000000000000000000000000000000;;						return yaml_parser_set_reader_error(parser,
0000000000000000000000000000000000000000;;							"unexpected low surrogate area",
0000000000000000000000000000000000000000;;							parser.offset, int(value))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check for a high surrogate area.
0000000000000000000000000000000000000000;;					if value&0xFC00 == 0xD800 {
0000000000000000000000000000000000000000;;						width = 4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Check for incomplete surrogate pair.
0000000000000000000000000000000000000000;;						if raw_unread < 4 {
0000000000000000000000000000000000000000;;							if parser.eof {
0000000000000000000000000000000000000000;;								return yaml_parser_set_reader_error(parser,
0000000000000000000000000000000000000000;;									"incomplete UTF-16 surrogate pair",
0000000000000000000000000000000000000000;;									parser.offset, -1)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							break inner
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Get the next character.
0000000000000000000000000000000000000000;;						value2 := rune(parser.raw_buffer[parser.raw_buffer_pos+low+2]) +
0000000000000000000000000000000000000000;;							(rune(parser.raw_buffer[parser.raw_buffer_pos+high+2]) << 8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Check for a low surrogate area.
0000000000000000000000000000000000000000;;						if value2&0xFC00 != 0xDC00 {
0000000000000000000000000000000000000000;;							return yaml_parser_set_reader_error(parser,
0000000000000000000000000000000000000000;;								"expected low surrogate area",
0000000000000000000000000000000000000000;;								parser.offset+2, int(value2))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Generate the value of the surrogate pair.
0000000000000000000000000000000000000000;;						value = 0x10000 + ((value & 0x3FF) << 10) + (value2 & 0x3FF)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						width = 2
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					panic("impossible")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check if the character is in the allowed range:
0000000000000000000000000000000000000000;;				//      #x9 | #xA | #xD | [#x20-#x7E]               (8 bit)
0000000000000000000000000000000000000000;;				//      | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD]    (16 bit)
0000000000000000000000000000000000000000;;				//      | [#x10000-#x10FFFF]                        (32 bit)
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case value == 0x09:
0000000000000000000000000000000000000000;;				case value == 0x0A:
0000000000000000000000000000000000000000;;				case value == 0x0D:
0000000000000000000000000000000000000000;;				case value >= 0x20 && value <= 0x7E:
0000000000000000000000000000000000000000;;				case value == 0x85:
0000000000000000000000000000000000000000;;				case value >= 0xA0 && value <= 0xD7FF:
0000000000000000000000000000000000000000;;				case value >= 0xE000 && value <= 0xFFFD:
0000000000000000000000000000000000000000;;				case value >= 0x10000 && value <= 0x10FFFF:
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return yaml_parser_set_reader_error(parser,
0000000000000000000000000000000000000000;;						"control characters are not allowed",
0000000000000000000000000000000000000000;;						parser.offset, int(value))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Move the raw pointers.
0000000000000000000000000000000000000000;;				parser.raw_buffer_pos += width
0000000000000000000000000000000000000000;;				parser.offset += width
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Finally put the character into the buffer.
0000000000000000000000000000000000000000;;				if value <= 0x7F {
0000000000000000000000000000000000000000;;					// 0000 0000-0000 007F . 0xxxxxxx
0000000000000000000000000000000000000000;;					parser.buffer[buffer_len+0] = byte(value)
0000000000000000000000000000000000000000;;				} else if value <= 0x7FF {
0000000000000000000000000000000000000000;;					// 0000 0080-0000 07FF . 110xxxxx 10xxxxxx
0000000000000000000000000000000000000000;;					parser.buffer[buffer_len+0] = byte(0xC0 + (value >> 6))
0000000000000000000000000000000000000000;;					parser.buffer[buffer_len+1] = byte(0x80 + (value & 0x3F))
0000000000000000000000000000000000000000;;				} else if value <= 0xFFFF {
0000000000000000000000000000000000000000;;					// 0000 0800-0000 FFFF . 1110xxxx 10xxxxxx 10xxxxxx
0000000000000000000000000000000000000000;;					parser.buffer[buffer_len+0] = byte(0xE0 + (value >> 12))
0000000000000000000000000000000000000000;;					parser.buffer[buffer_len+1] = byte(0x80 + ((value >> 6) & 0x3F))
0000000000000000000000000000000000000000;;					parser.buffer[buffer_len+2] = byte(0x80 + (value & 0x3F))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// 0001 0000-0010 FFFF . 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
0000000000000000000000000000000000000000;;					parser.buffer[buffer_len+0] = byte(0xF0 + (value >> 18))
0000000000000000000000000000000000000000;;					parser.buffer[buffer_len+1] = byte(0x80 + ((value >> 12) & 0x3F))
0000000000000000000000000000000000000000;;					parser.buffer[buffer_len+2] = byte(0x80 + ((value >> 6) & 0x3F))
0000000000000000000000000000000000000000;;					parser.buffer[buffer_len+3] = byte(0x80 + (value & 0x3F))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buffer_len += width
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				parser.unread++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// On EOF, put NUL into the buffer and return.
0000000000000000000000000000000000000000;;			if parser.eof {
0000000000000000000000000000000000000000;;				parser.buffer[buffer_len] = 0
0000000000000000000000000000000000000000;;				buffer_len++
0000000000000000000000000000000000000000;;				parser.unread++
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.buffer = parser.buffer[:buffer_len]
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
