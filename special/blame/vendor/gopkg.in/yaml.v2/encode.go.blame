0000000000000000000000000000000000000000;;	package yaml
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/gopkg.in/v2/yaml/encode.go[Godeps/_workspace/src/gopkg.in/v2/yaml/encode.go][vendor/gopkg.in/yaml.v2/encode.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encoder struct {
0000000000000000000000000000000000000000;;		emitter yaml_emitter_t
0000000000000000000000000000000000000000;;		event   yaml_event_t
0000000000000000000000000000000000000000;;		out     []byte
0000000000000000000000000000000000000000;;		flow    bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEncoder() (e *encoder) {
0000000000000000000000000000000000000000;;		e = &encoder{}
0000000000000000000000000000000000000000;;		e.must(yaml_emitter_initialize(&e.emitter))
0000000000000000000000000000000000000000;;		yaml_emitter_set_output_string(&e.emitter, &e.out)
0000000000000000000000000000000000000000;;		yaml_emitter_set_unicode(&e.emitter, true)
0000000000000000000000000000000000000000;;		e.must(yaml_stream_start_event_initialize(&e.event, yaml_UTF8_ENCODING))
0000000000000000000000000000000000000000;;		e.emit()
0000000000000000000000000000000000000000;;		e.must(yaml_document_start_event_initialize(&e.event, nil, nil, true))
0000000000000000000000000000000000000000;;		e.emit()
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) finish() {
0000000000000000000000000000000000000000;;		e.must(yaml_document_end_event_initialize(&e.event, true))
0000000000000000000000000000000000000000;;		e.emit()
0000000000000000000000000000000000000000;;		e.emitter.open_ended = false
0000000000000000000000000000000000000000;;		e.must(yaml_stream_end_event_initialize(&e.event))
0000000000000000000000000000000000000000;;		e.emit()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) destroy() {
0000000000000000000000000000000000000000;;		yaml_emitter_delete(&e.emitter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) emit() {
0000000000000000000000000000000000000000;;		// This will internally delete the e.event value.
0000000000000000000000000000000000000000;;		if !yaml_emitter_emit(&e.emitter, &e.event) && e.event.typ != yaml_DOCUMENT_END_EVENT && e.event.typ != yaml_STREAM_END_EVENT {
0000000000000000000000000000000000000000;;			e.must(false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) must(ok bool) {
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			msg := e.emitter.problem
0000000000000000000000000000000000000000;;			if msg == "" {
0000000000000000000000000000000000000000;;				msg = "unknown problem generating YAML content"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			failf("%s", msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) marshal(tag string, in reflect.Value) {
0000000000000000000000000000000000000000;;		if !in.IsValid() {
0000000000000000000000000000000000000000;;			e.nilv()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		iface := in.Interface()
0000000000000000000000000000000000000000;;		if m, ok := iface.(Marshaler); ok {
0000000000000000000000000000000000000000;;			v, err := m.MarshalYAML()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fail(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v == nil {
0000000000000000000000000000000000000000;;				e.nilv()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			in = reflect.ValueOf(v)
0000000000000000000000000000000000000000;;		} else if m, ok := iface.(encoding.TextMarshaler); ok {
0000000000000000000000000000000000000000;;			text, err := m.MarshalText()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				fail(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			in = reflect.ValueOf(string(text))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch in.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if in.IsNil() {
0000000000000000000000000000000000000000;;				e.nilv()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.marshal(tag, in.Elem())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			e.mapv(tag, in)
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if in.IsNil() {
0000000000000000000000000000000000000000;;				e.nilv()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.marshal(tag, in.Elem())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			e.structv(tag, in)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if in.Type().Elem() == mapItemType {
0000000000000000000000000000000000000000;;				e.itemsv(tag, in)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.slicev(tag, in)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			e.stringv(tag, in)
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			if in.Type() == durationType {
0000000000000000000000000000000000000000;;				e.stringv(tag, reflect.ValueOf(iface.(time.Duration).String()))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.intv(tag, in)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			e.uintv(tag, in)
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			e.floatv(tag, in)
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			e.boolv(tag, in)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("cannot marshal type: " + in.Type().String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) mapv(tag string, in reflect.Value) {
0000000000000000000000000000000000000000;;		e.mappingv(tag, func() {
0000000000000000000000000000000000000000;;			keys := keyList(in.MapKeys())
0000000000000000000000000000000000000000;;			sort.Sort(keys)
0000000000000000000000000000000000000000;;			for _, k := range keys {
0000000000000000000000000000000000000000;;				e.marshal("", k)
0000000000000000000000000000000000000000;;				e.marshal("", in.MapIndex(k))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) itemsv(tag string, in reflect.Value) {
0000000000000000000000000000000000000000;;		e.mappingv(tag, func() {
0000000000000000000000000000000000000000;;			slice := in.Convert(reflect.TypeOf([]MapItem{})).Interface().([]MapItem)
0000000000000000000000000000000000000000;;			for _, item := range slice {
0000000000000000000000000000000000000000;;				e.marshal("", reflect.ValueOf(item.Key))
0000000000000000000000000000000000000000;;				e.marshal("", reflect.ValueOf(item.Value))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) structv(tag string, in reflect.Value) {
0000000000000000000000000000000000000000;;		sinfo, err := getStructInfo(in.Type())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.mappingv(tag, func() {
0000000000000000000000000000000000000000;;			for _, info := range sinfo.FieldsList {
0000000000000000000000000000000000000000;;				var value reflect.Value
0000000000000000000000000000000000000000;;				if info.Inline == nil {
0000000000000000000000000000000000000000;;					value = in.Field(info.Num)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					value = in.FieldByIndex(info.Inline)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if info.OmitEmpty && isZero(value) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.marshal("", reflect.ValueOf(info.Key))
0000000000000000000000000000000000000000;;				e.flow = info.Flow
0000000000000000000000000000000000000000;;				e.marshal("", value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sinfo.InlineMap >= 0 {
0000000000000000000000000000000000000000;;				m := in.Field(sinfo.InlineMap)
0000000000000000000000000000000000000000;;				if m.Len() > 0 {
0000000000000000000000000000000000000000;;					e.flow = false
0000000000000000000000000000000000000000;;					keys := keyList(m.MapKeys())
0000000000000000000000000000000000000000;;					sort.Sort(keys)
0000000000000000000000000000000000000000;;					for _, k := range keys {
0000000000000000000000000000000000000000;;						if _, found := sinfo.FieldsMap[k.String()]; found {
0000000000000000000000000000000000000000;;							panic(fmt.Sprintf("Can't have key %q in inlined map; conflicts with struct field", k.String()))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						e.marshal("", k)
0000000000000000000000000000000000000000;;						e.flow = false
0000000000000000000000000000000000000000;;						e.marshal("", m.MapIndex(k))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) mappingv(tag string, f func()) {
0000000000000000000000000000000000000000;;		implicit := tag == ""
0000000000000000000000000000000000000000;;		style := yaml_BLOCK_MAPPING_STYLE
0000000000000000000000000000000000000000;;		if e.flow {
0000000000000000000000000000000000000000;;			e.flow = false
0000000000000000000000000000000000000000;;			style = yaml_FLOW_MAPPING_STYLE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.must(yaml_mapping_start_event_initialize(&e.event, nil, []byte(tag), implicit, style))
0000000000000000000000000000000000000000;;		e.emit()
0000000000000000000000000000000000000000;;		f()
0000000000000000000000000000000000000000;;		e.must(yaml_mapping_end_event_initialize(&e.event))
0000000000000000000000000000000000000000;;		e.emit()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) slicev(tag string, in reflect.Value) {
0000000000000000000000000000000000000000;;		implicit := tag == ""
0000000000000000000000000000000000000000;;		style := yaml_BLOCK_SEQUENCE_STYLE
0000000000000000000000000000000000000000;;		if e.flow {
0000000000000000000000000000000000000000;;			e.flow = false
0000000000000000000000000000000000000000;;			style = yaml_FLOW_SEQUENCE_STYLE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.must(yaml_sequence_start_event_initialize(&e.event, nil, []byte(tag), implicit, style))
0000000000000000000000000000000000000000;;		e.emit()
0000000000000000000000000000000000000000;;		n := in.Len()
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			e.marshal("", in.Index(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.must(yaml_sequence_end_event_initialize(&e.event))
0000000000000000000000000000000000000000;;		e.emit()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isBase60 returns whether s is in base 60 notation as defined in YAML 1.1.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The base 60 float notation in YAML 1.1 is a terrible idea and is unsupported
0000000000000000000000000000000000000000;;	// in YAML 1.2 and by this package, but these should be marshalled quoted for
0000000000000000000000000000000000000000;;	// the time being for compatibility with other parsers.
0000000000000000000000000000000000000000;;	func isBase60Float(s string) (result bool) {
0000000000000000000000000000000000000000;;		// Fast path.
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := s[0]
0000000000000000000000000000000000000000;;		if !(c == '+' || c == '-' || c >= '0' && c <= '9') || strings.IndexByte(s, ':') < 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Do the full match.
0000000000000000000000000000000000000000;;		return base60float.MatchString(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// From http://yaml.org/type/float.html, except the regular expression there
0000000000000000000000000000000000000000;;	// is bogus. In practice parsers do not enforce the "\.[0-9_]*" suffix.
0000000000000000000000000000000000000000;;	var base60float = regexp.MustCompile(`^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+(?:\.[0-9_]*)?$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) stringv(tag string, in reflect.Value) {
0000000000000000000000000000000000000000;;		var style yaml_scalar_style_t
0000000000000000000000000000000000000000;;		s := in.String()
0000000000000000000000000000000000000000;;		rtag, rs := resolve("", s)
0000000000000000000000000000000000000000;;		if rtag == yaml_BINARY_TAG {
0000000000000000000000000000000000000000;;			if tag == "" || tag == yaml_STR_TAG {
0000000000000000000000000000000000000000;;				tag = rtag
0000000000000000000000000000000000000000;;				s = rs.(string)
0000000000000000000000000000000000000000;;			} else if tag == yaml_BINARY_TAG {
0000000000000000000000000000000000000000;;				failf("explicitly tagged !!binary data must be base64-encoded")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				failf("cannot marshal invalid UTF-8 data as %s", shortTag(tag))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tag == "" && (rtag != yaml_STR_TAG || isBase60Float(s)) {
0000000000000000000000000000000000000000;;			style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
0000000000000000000000000000000000000000;;		} else if strings.Contains(s, "\n") {
0000000000000000000000000000000000000000;;			style = yaml_LITERAL_SCALAR_STYLE
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			style = yaml_PLAIN_SCALAR_STYLE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.emitScalar(s, "", tag, style)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) boolv(tag string, in reflect.Value) {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if in.Bool() {
0000000000000000000000000000000000000000;;			s = "true"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s = "false"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) intv(tag string, in reflect.Value) {
0000000000000000000000000000000000000000;;		s := strconv.FormatInt(in.Int(), 10)
0000000000000000000000000000000000000000;;		e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) uintv(tag string, in reflect.Value) {
0000000000000000000000000000000000000000;;		s := strconv.FormatUint(in.Uint(), 10)
0000000000000000000000000000000000000000;;		e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) floatv(tag string, in reflect.Value) {
0000000000000000000000000000000000000000;;		// FIXME: Handle 64 bits here.
0000000000000000000000000000000000000000;;		s := strconv.FormatFloat(float64(in.Float()), 'g', -1, 32)
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case "+Inf":
0000000000000000000000000000000000000000;;			s = ".inf"
0000000000000000000000000000000000000000;;		case "-Inf":
0000000000000000000000000000000000000000;;			s = "-.inf"
0000000000000000000000000000000000000000;;		case "NaN":
0000000000000000000000000000000000000000;;			s = ".nan"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) nilv() {
0000000000000000000000000000000000000000;;		e.emitScalar("null", "", "", yaml_PLAIN_SCALAR_STYLE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *encoder) emitScalar(value, anchor, tag string, style yaml_scalar_style_t) {
0000000000000000000000000000000000000000;;		implicit := tag == ""
0000000000000000000000000000000000000000;;		e.must(yaml_scalar_event_initialize(&e.event, []byte(anchor), []byte(tag), []byte(value), implicit, implicit, style))
0000000000000000000000000000000000000000;;		e.emit()
0000000000000000000000000000000000000000;;	}
