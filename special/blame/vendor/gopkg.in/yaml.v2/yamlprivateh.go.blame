0000000000000000000000000000000000000000;;	package yaml
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/gopkg.in/v2/yaml/yamlprivateh.go[Godeps/_workspace/src/gopkg.in/v2/yaml/yamlprivateh.go][vendor/gopkg.in/yaml.v2/yamlprivateh.go];	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// The size of the input raw buffer.
0000000000000000000000000000000000000000;;		input_raw_buffer_size = 512
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The size of the input buffer.
0000000000000000000000000000000000000000;;		// It should be possible to decode the whole raw buffer.
0000000000000000000000000000000000000000;;		input_buffer_size = input_raw_buffer_size * 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The size of the output buffer.
0000000000000000000000000000000000000000;;		output_buffer_size = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The size of the output raw buffer.
0000000000000000000000000000000000000000;;		// It should be possible to encode the whole output buffer.
0000000000000000000000000000000000000000;;		output_raw_buffer_size = (output_buffer_size*2 + 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The size of other stacks and queues.
0000000000000000000000000000000000000000;;		initial_stack_size  = 16
0000000000000000000000000000000000000000;;		initial_queue_size  = 16
0000000000000000000000000000000000000000;;		initial_string_size = 16
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character at the specified position is an alphabetical
0000000000000000000000000000000000000000;;	// character, a digit, '_', or '-'.
0000000000000000000000000000000000000000;;	func is_alpha(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return b[i] >= '0' && b[i] <= '9' || b[i] >= 'A' && b[i] <= 'Z' || b[i] >= 'a' && b[i] <= 'z' || b[i] == '_' || b[i] == '-'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character at the specified position is a digit.
0000000000000000000000000000000000000000;;	func is_digit(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return b[i] >= '0' && b[i] <= '9'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the value of a digit.
0000000000000000000000000000000000000000;;	func as_digit(b []byte, i int) int {
0000000000000000000000000000000000000000;;		return int(b[i]) - '0'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character at the specified position is a hex-digit.
0000000000000000000000000000000000000000;;	func is_hex(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return b[i] >= '0' && b[i] <= '9' || b[i] >= 'A' && b[i] <= 'F' || b[i] >= 'a' && b[i] <= 'f'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the value of a hex-digit.
0000000000000000000000000000000000000000;;	func as_hex(b []byte, i int) int {
0000000000000000000000000000000000000000;;		bi := b[i]
0000000000000000000000000000000000000000;;		if bi >= 'A' && bi <= 'F' {
0000000000000000000000000000000000000000;;			return int(bi) - 'A' + 10
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bi >= 'a' && bi <= 'f' {
0000000000000000000000000000000000000000;;			return int(bi) - 'a' + 10
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(bi) - '0'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character is ASCII.
0000000000000000000000000000000000000000;;	func is_ascii(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return b[i] <= 0x7F
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character at the start of the buffer can be printed unescaped.
0000000000000000000000000000000000000000;;	func is_printable(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return ((b[i] == 0x0A) || // . == #x0A
0000000000000000000000000000000000000000;;			(b[i] >= 0x20 && b[i] <= 0x7E) || // #x20 <= . <= #x7E
0000000000000000000000000000000000000000;;			(b[i] == 0xC2 && b[i+1] >= 0xA0) || // #0xA0 <= . <= #xD7FF
0000000000000000000000000000000000000000;;			(b[i] > 0xC2 && b[i] < 0xED) ||
0000000000000000000000000000000000000000;;			(b[i] == 0xED && b[i+1] < 0xA0) ||
0000000000000000000000000000000000000000;;			(b[i] == 0xEE) ||
0000000000000000000000000000000000000000;;			(b[i] == 0xEF && // #xE000 <= . <= #xFFFD
0000000000000000000000000000000000000000;;				!(b[i+1] == 0xBB && b[i+2] == 0xBF) && // && . != #xFEFF
0000000000000000000000000000000000000000;;				!(b[i+1] == 0xBF && (b[i+2] == 0xBE || b[i+2] == 0xBF))))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character at the specified position is NUL.
0000000000000000000000000000000000000000;;	func is_z(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return b[i] == 0x00
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the beginning of the buffer is a BOM.
0000000000000000000000000000000000000000;;	func is_bom(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return b[0] == 0xEF && b[1] == 0xBB && b[2] == 0xBF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character at the specified position is space.
0000000000000000000000000000000000000000;;	func is_space(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return b[i] == ' '
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character at the specified position is tab.
0000000000000000000000000000000000000000;;	func is_tab(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return b[i] == '\t'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character at the specified position is blank (space or tab).
0000000000000000000000000000000000000000;;	func is_blank(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		//return is_space(b, i) || is_tab(b, i)
0000000000000000000000000000000000000000;;		return b[i] == ' ' || b[i] == '\t'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character at the specified position is a line break.
0000000000000000000000000000000000000000;;	func is_break(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return (b[i] == '\r' || // CR (#xD)
0000000000000000000000000000000000000000;;			b[i] == '\n' || // LF (#xA)
0000000000000000000000000000000000000000;;			b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
0000000000000000000000000000000000000000;;			b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
0000000000000000000000000000000000000000;;			b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9) // PS (#x2029)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func is_crlf(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		return b[i] == '\r' && b[i+1] == '\n'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character is a line break or NUL.
0000000000000000000000000000000000000000;;	func is_breakz(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		//return is_break(b, i) || is_z(b, i)
0000000000000000000000000000000000000000;;		return (        // is_break:
0000000000000000000000000000000000000000;;		b[i] == '\r' || // CR (#xD)
0000000000000000000000000000000000000000;;			b[i] == '\n' || // LF (#xA)
0000000000000000000000000000000000000000;;			b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
0000000000000000000000000000000000000000;;			b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
0000000000000000000000000000000000000000;;			b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
0000000000000000000000000000000000000000;;			// is_z:
0000000000000000000000000000000000000000;;			b[i] == 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character is a line break, space, or NUL.
0000000000000000000000000000000000000000;;	func is_spacez(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		//return is_space(b, i) || is_breakz(b, i)
0000000000000000000000000000000000000000;;		return ( // is_space:
0000000000000000000000000000000000000000;;		b[i] == ' ' ||
0000000000000000000000000000000000000000;;			// is_breakz:
0000000000000000000000000000000000000000;;			b[i] == '\r' || // CR (#xD)
0000000000000000000000000000000000000000;;			b[i] == '\n' || // LF (#xA)
0000000000000000000000000000000000000000;;			b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
0000000000000000000000000000000000000000;;			b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
0000000000000000000000000000000000000000;;			b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
0000000000000000000000000000000000000000;;			b[i] == 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if the character is a line break, space, tab, or NUL.
0000000000000000000000000000000000000000;;	func is_blankz(b []byte, i int) bool {
0000000000000000000000000000000000000000;;		//return is_blank(b, i) || is_breakz(b, i)
0000000000000000000000000000000000000000;;		return ( // is_blank:
0000000000000000000000000000000000000000;;		b[i] == ' ' || b[i] == '\t' ||
0000000000000000000000000000000000000000;;			// is_breakz:
0000000000000000000000000000000000000000;;			b[i] == '\r' || // CR (#xD)
0000000000000000000000000000000000000000;;			b[i] == '\n' || // LF (#xA)
0000000000000000000000000000000000000000;;			b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
0000000000000000000000000000000000000000;;			b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
0000000000000000000000000000000000000000;;			b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
0000000000000000000000000000000000000000;;			b[i] == 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Determine the width of the character.
0000000000000000000000000000000000000000;;	func width(b byte) int {
0000000000000000000000000000000000000000;;		// Don't replace these by a switch without first
0000000000000000000000000000000000000000;;		// confirming that it is being inlined.
0000000000000000000000000000000000000000;;		if b&0x80 == 0x00 {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b&0xE0 == 0xC0 {
0000000000000000000000000000000000000000;;			return 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b&0xF0 == 0xE0 {
0000000000000000000000000000000000000000;;			return 3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b&0xF8 == 0xF0 {
0000000000000000000000000000000000000000;;			return 4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
