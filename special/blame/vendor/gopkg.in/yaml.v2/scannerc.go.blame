0000000000000000000000000000000000000000;;	package yaml
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/gopkg.in/v2/yaml/scannerc.go[Godeps/_workspace/src/gopkg.in/v2/yaml/scannerc.go][vendor/gopkg.in/yaml.v2/scannerc.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Introduction
0000000000000000000000000000000000000000;;	// ************
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following notes assume that you are familiar with the YAML specification
0000000000000000000000000000000000000000;;	// (http://yaml.org/spec/cvs/current.html).  We mostly follow it, although in
0000000000000000000000000000000000000000;;	// some cases we are less restrictive that it requires.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The process of transforming a YAML stream into a sequence of events is
0000000000000000000000000000000000000000;;	// divided on two steps: Scanning and Parsing.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Scanner transforms the input stream into a sequence of tokens, while the
0000000000000000000000000000000000000000;;	// parser transform the sequence of tokens produced by the Scanner into a
0000000000000000000000000000000000000000;;	// sequence of parsing events.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Scanner is rather clever and complicated. The Parser, on the contrary,
0000000000000000000000000000000000000000;;	// is a straightforward implementation of a recursive-descendant parser (or,
0000000000000000000000000000000000000000;;	// LL(1) parser, as it is usually called).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Actually there are two issues of Scanning that might be called "clever", the
0000000000000000000000000000000000000000;;	// rest is quite straightforward.  The issues are "block collection start" and
0000000000000000000000000000000000000000;;	// "simple keys".  Both issues are explained below in details.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Here the Scanning step is explained and implemented.  We start with the list
0000000000000000000000000000000000000000;;	// of all the tokens produced by the Scanner together with short descriptions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Now, tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      STREAM-START(encoding)          # The stream start.
0000000000000000000000000000000000000000;;	//      STREAM-END                      # The stream end.
0000000000000000000000000000000000000000;;	//      VERSION-DIRECTIVE(major,minor)  # The '%YAML' directive.
0000000000000000000000000000000000000000;;	//      TAG-DIRECTIVE(handle,prefix)    # The '%TAG' directive.
0000000000000000000000000000000000000000;;	//      DOCUMENT-START                  # '---'
0000000000000000000000000000000000000000;;	//      DOCUMENT-END                    # '...'
0000000000000000000000000000000000000000;;	//      BLOCK-SEQUENCE-START            # Indentation increase denoting a block
0000000000000000000000000000000000000000;;	//      BLOCK-MAPPING-START             # sequence or a block mapping.
0000000000000000000000000000000000000000;;	//      BLOCK-END                       # Indentation decrease.
0000000000000000000000000000000000000000;;	//      FLOW-SEQUENCE-START             # '['
0000000000000000000000000000000000000000;;	//      FLOW-SEQUENCE-END               # ']'
0000000000000000000000000000000000000000;;	//      BLOCK-SEQUENCE-START            # '{'
0000000000000000000000000000000000000000;;	//      BLOCK-SEQUENCE-END              # '}'
0000000000000000000000000000000000000000;;	//      BLOCK-ENTRY                     # '-'
0000000000000000000000000000000000000000;;	//      FLOW-ENTRY                      # ','
0000000000000000000000000000000000000000;;	//      KEY                             # '?' or nothing (simple keys).
0000000000000000000000000000000000000000;;	//      VALUE                           # ':'
0000000000000000000000000000000000000000;;	//      ALIAS(anchor)                   # '*anchor'
0000000000000000000000000000000000000000;;	//      ANCHOR(anchor)                  # '&anchor'
0000000000000000000000000000000000000000;;	//      TAG(handle,suffix)              # '!handle!suffix'
0000000000000000000000000000000000000000;;	//      SCALAR(value,style)             # A scalar.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following two tokens are "virtual" tokens denoting the beginning and the
0000000000000000000000000000000000000000;;	// end of the stream:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      STREAM-START(encoding)
0000000000000000000000000000000000000000;;	//      STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// We pass the information about the input stream encoding with the
0000000000000000000000000000000000000000;;	// STREAM-START token.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The next two tokens are responsible for tags:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      VERSION-DIRECTIVE(major,minor)
0000000000000000000000000000000000000000;;	//      TAG-DIRECTIVE(handle,prefix)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      %YAML   1.1
0000000000000000000000000000000000000000;;	//      %TAG    !   !foo
0000000000000000000000000000000000000000;;	//      %TAG    !yaml!  tag:yaml.org,2002:
0000000000000000000000000000000000000000;;	//      ---
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The correspoding sequence of tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//      VERSION-DIRECTIVE(1,1)
0000000000000000000000000000000000000000;;	//      TAG-DIRECTIVE("!","!foo")
0000000000000000000000000000000000000000;;	//      TAG-DIRECTIVE("!yaml","tag:yaml.org,2002:")
0000000000000000000000000000000000000000;;	//      DOCUMENT-START
0000000000000000000000000000000000000000;;	//      STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that the VERSION-DIRECTIVE and TAG-DIRECTIVE tokens occupy a whole
0000000000000000000000000000000000000000;;	// line.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The document start and end indicators are represented by:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      DOCUMENT-START
0000000000000000000000000000000000000000;;	//      DOCUMENT-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that if a YAML stream contains an implicit document (without '---'
0000000000000000000000000000000000000000;;	// and '...' indicators), no DOCUMENT-START and DOCUMENT-END tokens will be
0000000000000000000000000000000000000000;;	// produced.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In the following examples, we present whole documents together with the
0000000000000000000000000000000000000000;;	// produced tokens.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      1. An implicit document:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          'a scalar'
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          SCALAR("a scalar",single-quoted)
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      2. An explicit document:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          ---
0000000000000000000000000000000000000000;;	//          'a scalar'
0000000000000000000000000000000000000000;;	//          ...
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          DOCUMENT-START
0000000000000000000000000000000000000000;;	//          SCALAR("a scalar",single-quoted)
0000000000000000000000000000000000000000;;	//          DOCUMENT-END
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      3. Several documents in a stream:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          'a scalar'
0000000000000000000000000000000000000000;;	//          ---
0000000000000000000000000000000000000000;;	//          'another scalar'
0000000000000000000000000000000000000000;;	//          ---
0000000000000000000000000000000000000000;;	//          'yet another scalar'
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          SCALAR("a scalar",single-quoted)
0000000000000000000000000000000000000000;;	//          DOCUMENT-START
0000000000000000000000000000000000000000;;	//          SCALAR("another scalar",single-quoted)
0000000000000000000000000000000000000000;;	//          DOCUMENT-START
0000000000000000000000000000000000000000;;	//          SCALAR("yet another scalar",single-quoted)
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// We have already introduced the SCALAR token above.  The following tokens are
0000000000000000000000000000000000000000;;	// used to describe aliases, anchors, tag, and scalars:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      ALIAS(anchor)
0000000000000000000000000000000000000000;;	//      ANCHOR(anchor)
0000000000000000000000000000000000000000;;	//      TAG(handle,suffix)
0000000000000000000000000000000000000000;;	//      SCALAR(value,style)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following series of examples illustrate the usage of these tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      1. A recursive sequence:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          &A [ *A ]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          ANCHOR("A")
0000000000000000000000000000000000000000;;	//          FLOW-SEQUENCE-START
0000000000000000000000000000000000000000;;	//          ALIAS("A")
0000000000000000000000000000000000000000;;	//          FLOW-SEQUENCE-END
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      2. A tagged scalar:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          !!float "3.14"  # A good approximation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          TAG("!!","float")
0000000000000000000000000000000000000000;;	//          SCALAR("3.14",double-quoted)
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      3. Various scalar styles:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          --- # Implicit empty plain scalars do not produce tokens.
0000000000000000000000000000000000000000;;	//          --- a plain scalar
0000000000000000000000000000000000000000;;	//          --- 'a single-quoted scalar'
0000000000000000000000000000000000000000;;	//          --- "a double-quoted scalar"
0000000000000000000000000000000000000000;;	//          --- |-
0000000000000000000000000000000000000000;;	//            a literal scalar
0000000000000000000000000000000000000000;;	//          --- >-
0000000000000000000000000000000000000000;;	//            a folded
0000000000000000000000000000000000000000;;	//            scalar
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          DOCUMENT-START
0000000000000000000000000000000000000000;;	//          DOCUMENT-START
0000000000000000000000000000000000000000;;	//          SCALAR("a plain scalar",plain)
0000000000000000000000000000000000000000;;	//          DOCUMENT-START
0000000000000000000000000000000000000000;;	//          SCALAR("a single-quoted scalar",single-quoted)
0000000000000000000000000000000000000000;;	//          DOCUMENT-START
0000000000000000000000000000000000000000;;	//          SCALAR("a double-quoted scalar",double-quoted)
0000000000000000000000000000000000000000;;	//          DOCUMENT-START
0000000000000000000000000000000000000000;;	//          SCALAR("a literal scalar",literal)
0000000000000000000000000000000000000000;;	//          DOCUMENT-START
0000000000000000000000000000000000000000;;	//          SCALAR("a folded scalar",folded)
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Now it's time to review collection-related tokens. We will start with
0000000000000000000000000000000000000000;;	// flow collections:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      FLOW-SEQUENCE-START
0000000000000000000000000000000000000000;;	//      FLOW-SEQUENCE-END
0000000000000000000000000000000000000000;;	//      FLOW-MAPPING-START
0000000000000000000000000000000000000000;;	//      FLOW-MAPPING-END
0000000000000000000000000000000000000000;;	//      FLOW-ENTRY
0000000000000000000000000000000000000000;;	//      KEY
0000000000000000000000000000000000000000;;	//      VALUE
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The tokens FLOW-SEQUENCE-START, FLOW-SEQUENCE-END, FLOW-MAPPING-START, and
0000000000000000000000000000000000000000;;	// FLOW-MAPPING-END represent the indicators '[', ']', '{', and '}'
0000000000000000000000000000000000000000;;	// correspondingly.  FLOW-ENTRY represent the ',' indicator.  Finally the
0000000000000000000000000000000000000000;;	// indicators '?' and ':', which are used for denoting mapping keys and values,
0000000000000000000000000000000000000000;;	// are represented by the KEY and VALUE tokens.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following examples show flow collections:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      1. A flow sequence:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          [item 1, item 2, item 3]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          FLOW-SEQUENCE-START
0000000000000000000000000000000000000000;;	//          SCALAR("item 1",plain)
0000000000000000000000000000000000000000;;	//          FLOW-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 2",plain)
0000000000000000000000000000000000000000;;	//          FLOW-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 3",plain)
0000000000000000000000000000000000000000;;	//          FLOW-SEQUENCE-END
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      2. A flow mapping:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          {
0000000000000000000000000000000000000000;;	//              a simple key: a value,  # Note that the KEY token is produced.
0000000000000000000000000000000000000000;;	//              ? a complex key: another value,
0000000000000000000000000000000000000000;;	//          }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          FLOW-MAPPING-START
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("a simple key",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("a value",plain)
0000000000000000000000000000000000000000;;	//          FLOW-ENTRY
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("a complex key",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("another value",plain)
0000000000000000000000000000000000000000;;	//          FLOW-ENTRY
0000000000000000000000000000000000000000;;	//          FLOW-MAPPING-END
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A simple key is a key which is not denoted by the '?' indicator.  Note that
0000000000000000000000000000000000000000;;	// the Scanner still produce the KEY token whenever it encounters a simple key.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For scanning block collections, the following tokens are used (note that we
0000000000000000000000000000000000000000;;	// repeat KEY and VALUE here):
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      BLOCK-SEQUENCE-START
0000000000000000000000000000000000000000;;	//      BLOCK-MAPPING-START
0000000000000000000000000000000000000000;;	//      BLOCK-END
0000000000000000000000000000000000000000;;	//      BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//      KEY
0000000000000000000000000000000000000000;;	//      VALUE
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The tokens BLOCK-SEQUENCE-START and BLOCK-MAPPING-START denote indentation
0000000000000000000000000000000000000000;;	// increase that precedes a block collection (cf. the INDENT token in Python).
0000000000000000000000000000000000000000;;	// The token BLOCK-END denote indentation decrease that ends a block collection
0000000000000000000000000000000000000000;;	// (cf. the DEDENT token in Python).  However YAML has some syntax pecularities
0000000000000000000000000000000000000000;;	// that makes detections of these tokens more complex.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The tokens BLOCK-ENTRY, KEY, and VALUE are used to represent the indicators
0000000000000000000000000000000000000000;;	// '-', '?', and ':' correspondingly.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following examples show how the tokens BLOCK-SEQUENCE-START,
0000000000000000000000000000000000000000;;	// BLOCK-MAPPING-START, and BLOCK-END are emitted by the Scanner:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      1. Block sequences:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          - item 1
0000000000000000000000000000000000000000;;	//          - item 2
0000000000000000000000000000000000000000;;	//          -
0000000000000000000000000000000000000000;;	//            - item 3.1
0000000000000000000000000000000000000000;;	//            - item 3.2
0000000000000000000000000000000000000000;;	//          -
0000000000000000000000000000000000000000;;	//            key 1: value 1
0000000000000000000000000000000000000000;;	//            key 2: value 2
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          BLOCK-SEQUENCE-START
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 1",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 2",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          BLOCK-SEQUENCE-START
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 3.1",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 3.2",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          BLOCK-MAPPING-START
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("key 1",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("value 1",plain)
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("key 2",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("value 2",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      2. Block mappings:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          a simple key: a value   # The KEY token is produced here.
0000000000000000000000000000000000000000;;	//          ? a complex key
0000000000000000000000000000000000000000;;	//          : another value
0000000000000000000000000000000000000000;;	//          a mapping:
0000000000000000000000000000000000000000;;	//            key 1: value 1
0000000000000000000000000000000000000000;;	//            key 2: value 2
0000000000000000000000000000000000000000;;	//          a sequence:
0000000000000000000000000000000000000000;;	//            - item 1
0000000000000000000000000000000000000000;;	//            - item 2
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          BLOCK-MAPPING-START
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("a simple key",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("a value",plain)
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("a complex key",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("another value",plain)
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("a mapping",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-MAPPING-START
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("key 1",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("value 1",plain)
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("key 2",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("value 2",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("a sequence",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          BLOCK-SEQUENCE-START
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 1",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 2",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// YAML does not always require to start a new block collection from a new
0000000000000000000000000000000000000000;;	// line.  If the current line contains only '-', '?', and ':' indicators, a new
0000000000000000000000000000000000000000;;	// block collection may start at the current line.  The following examples
0000000000000000000000000000000000000000;;	// illustrate this case:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      1. Collections in a sequence:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          - - item 1
0000000000000000000000000000000000000000;;	//            - item 2
0000000000000000000000000000000000000000;;	//          - key 1: value 1
0000000000000000000000000000000000000000;;	//            key 2: value 2
0000000000000000000000000000000000000000;;	//          - ? complex key
0000000000000000000000000000000000000000;;	//            : complex value
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          BLOCK-SEQUENCE-START
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          BLOCK-SEQUENCE-START
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 1",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 2",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          BLOCK-MAPPING-START
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("key 1",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("value 1",plain)
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("key 2",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("value 2",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          BLOCK-MAPPING-START
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("complex key")
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("complex value")
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      2. Collections in a mapping:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          ? a sequence
0000000000000000000000000000000000000000;;	//          : - item 1
0000000000000000000000000000000000000000;;	//            - item 2
0000000000000000000000000000000000000000;;	//          ? a mapping
0000000000000000000000000000000000000000;;	//          : key 1: value 1
0000000000000000000000000000000000000000;;	//            key 2: value 2
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//          STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//          BLOCK-MAPPING-START
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("a sequence",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          BLOCK-SEQUENCE-START
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 1",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//          SCALAR("item 2",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("a mapping",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          BLOCK-MAPPING-START
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("key 1",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("value 1",plain)
0000000000000000000000000000000000000000;;	//          KEY
0000000000000000000000000000000000000000;;	//          SCALAR("key 2",plain)
0000000000000000000000000000000000000000;;	//          VALUE
0000000000000000000000000000000000000000;;	//          SCALAR("value 2",plain)
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          BLOCK-END
0000000000000000000000000000000000000000;;	//          STREAM-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// YAML also permits non-indented sequences if they are included into a block
0000000000000000000000000000000000000000;;	// mapping.  In this case, the token BLOCK-SEQUENCE-START is not produced:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      key:
0000000000000000000000000000000000000000;;	//      - item 1    # BLOCK-SEQUENCE-START is NOT produced here.
0000000000000000000000000000000000000000;;	//      - item 2
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Tokens:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      STREAM-START(utf-8)
0000000000000000000000000000000000000000;;	//      BLOCK-MAPPING-START
0000000000000000000000000000000000000000;;	//      KEY
0000000000000000000000000000000000000000;;	//      SCALAR("key",plain)
0000000000000000000000000000000000000000;;	//      VALUE
0000000000000000000000000000000000000000;;	//      BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//      SCALAR("item 1",plain)
0000000000000000000000000000000000000000;;	//      BLOCK-ENTRY
0000000000000000000000000000000000000000;;	//      SCALAR("item 2",plain)
0000000000000000000000000000000000000000;;	//      BLOCK-END
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure that the buffer contains the required number of characters.
0000000000000000000000000000000000000000;;	// Return true on success, false on failure (reader error or memory error).
0000000000000000000000000000000000000000;;	func cache(parser *yaml_parser_t, length int) bool {
0000000000000000000000000000000000000000;;		// [Go] This was inlined: !cache(A, B) -> unread < B && !update(A, B)
0000000000000000000000000000000000000000;;		return parser.unread >= length || yaml_parser_update_buffer(parser, length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Advance the buffer pointer.
0000000000000000000000000000000000000000;;	func skip(parser *yaml_parser_t) {
0000000000000000000000000000000000000000;;		parser.mark.index++
0000000000000000000000000000000000000000;;		parser.mark.column++
0000000000000000000000000000000000000000;;		parser.unread--
0000000000000000000000000000000000000000;;		parser.buffer_pos += width(parser.buffer[parser.buffer_pos])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func skip_line(parser *yaml_parser_t) {
0000000000000000000000000000000000000000;;		if is_crlf(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			parser.mark.index += 2
0000000000000000000000000000000000000000;;			parser.mark.column = 0
0000000000000000000000000000000000000000;;			parser.mark.line++
0000000000000000000000000000000000000000;;			parser.unread -= 2
0000000000000000000000000000000000000000;;			parser.buffer_pos += 2
0000000000000000000000000000000000000000;;		} else if is_break(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			parser.mark.index++
0000000000000000000000000000000000000000;;			parser.mark.column = 0
0000000000000000000000000000000000000000;;			parser.mark.line++
0000000000000000000000000000000000000000;;			parser.unread--
0000000000000000000000000000000000000000;;			parser.buffer_pos += width(parser.buffer[parser.buffer_pos])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy a character to a string buffer and advance pointers.
0000000000000000000000000000000000000000;;	func read(parser *yaml_parser_t, s []byte) []byte {
0000000000000000000000000000000000000000;;		w := width(parser.buffer[parser.buffer_pos])
0000000000000000000000000000000000000000;;		if w == 0 {
0000000000000000000000000000000000000000;;			panic("invalid character sequence")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			s = make([]byte, 0, 32)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w == 1 && len(s)+w <= cap(s) {
0000000000000000000000000000000000000000;;			s = s[:len(s)+1]
0000000000000000000000000000000000000000;;			s[len(s)-1] = parser.buffer[parser.buffer_pos]
0000000000000000000000000000000000000000;;			parser.buffer_pos++
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s = append(s, parser.buffer[parser.buffer_pos:parser.buffer_pos+w]...)
0000000000000000000000000000000000000000;;			parser.buffer_pos += w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.mark.index++
0000000000000000000000000000000000000000;;		parser.mark.column++
0000000000000000000000000000000000000000;;		parser.unread--
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy a line break character to a string buffer and advance pointers.
0000000000000000000000000000000000000000;;	func read_line(parser *yaml_parser_t, s []byte) []byte {
0000000000000000000000000000000000000000;;		buf := parser.buffer
0000000000000000000000000000000000000000;;		pos := parser.buffer_pos
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case buf[pos] == '\r' && buf[pos+1] == '\n':
0000000000000000000000000000000000000000;;			// CR LF . LF
0000000000000000000000000000000000000000;;			s = append(s, '\n')
0000000000000000000000000000000000000000;;			parser.buffer_pos += 2
0000000000000000000000000000000000000000;;			parser.mark.index++
0000000000000000000000000000000000000000;;			parser.unread--
0000000000000000000000000000000000000000;;		case buf[pos] == '\r' || buf[pos] == '\n':
0000000000000000000000000000000000000000;;			// CR|LF . LF
0000000000000000000000000000000000000000;;			s = append(s, '\n')
0000000000000000000000000000000000000000;;			parser.buffer_pos += 1
0000000000000000000000000000000000000000;;		case buf[pos] == '\xC2' && buf[pos+1] == '\x85':
0000000000000000000000000000000000000000;;			// NEL . LF
0000000000000000000000000000000000000000;;			s = append(s, '\n')
0000000000000000000000000000000000000000;;			parser.buffer_pos += 2
0000000000000000000000000000000000000000;;		case buf[pos] == '\xE2' && buf[pos+1] == '\x80' && (buf[pos+2] == '\xA8' || buf[pos+2] == '\xA9'):
0000000000000000000000000000000000000000;;			// LS|PS . LS|PS
0000000000000000000000000000000000000000;;			s = append(s, buf[parser.buffer_pos:pos+3]...)
0000000000000000000000000000000000000000;;			parser.buffer_pos += 3
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.mark.index++
0000000000000000000000000000000000000000;;		parser.mark.column = 0
0000000000000000000000000000000000000000;;		parser.mark.line++
0000000000000000000000000000000000000000;;		parser.unread--
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the next token.
0000000000000000000000000000000000000000;;	func yaml_parser_scan(parser *yaml_parser_t, token *yaml_token_t) bool {
0000000000000000000000000000000000000000;;		// Erase the token object.
0000000000000000000000000000000000000000;;		*token = yaml_token_t{} // [Go] Is this necessary?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No tokens after STREAM-END or error.
0000000000000000000000000000000000000000;;		if parser.stream_end_produced || parser.error != yaml_NO_ERROR {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure that the tokens queue contains enough tokens.
0000000000000000000000000000000000000000;;		if !parser.token_available {
0000000000000000000000000000000000000000;;			if !yaml_parser_fetch_more_tokens(parser) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fetch the next token from the queue.
0000000000000000000000000000000000000000;;		*token = parser.tokens[parser.tokens_head]
0000000000000000000000000000000000000000;;		parser.tokens_head++
0000000000000000000000000000000000000000;;		parser.tokens_parsed++
0000000000000000000000000000000000000000;;		parser.token_available = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if token.typ == yaml_STREAM_END_TOKEN {
0000000000000000000000000000000000000000;;			parser.stream_end_produced = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the scanner error and return false.
0000000000000000000000000000000000000000;;	func yaml_parser_set_scanner_error(parser *yaml_parser_t, context string, context_mark yaml_mark_t, problem string) bool {
0000000000000000000000000000000000000000;;		parser.error = yaml_SCANNER_ERROR
0000000000000000000000000000000000000000;;		parser.context = context
0000000000000000000000000000000000000000;;		parser.context_mark = context_mark
0000000000000000000000000000000000000000;;		parser.problem = problem
0000000000000000000000000000000000000000;;		parser.problem_mark = parser.mark
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func yaml_parser_set_scanner_tag_error(parser *yaml_parser_t, directive bool, context_mark yaml_mark_t, problem string) bool {
0000000000000000000000000000000000000000;;		context := "while parsing a tag"
0000000000000000000000000000000000000000;;		if directive {
0000000000000000000000000000000000000000;;			context = "while parsing a %TAG directive"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return yaml_parser_set_scanner_error(parser, context, context_mark, "did not find URI escaped octet")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trace(args ...interface{}) func() {
0000000000000000000000000000000000000000;;		pargs := append([]interface{}{"+++"}, args...)
0000000000000000000000000000000000000000;;		fmt.Println(pargs...)
0000000000000000000000000000000000000000;;		pargs = append([]interface{}{"---"}, args...)
0000000000000000000000000000000000000000;;		return func() { fmt.Println(pargs...) }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ensure that the tokens queue contains at least one token which can be
0000000000000000000000000000000000000000;;	// returned to the Parser.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_more_tokens(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// While we need more tokens to fetch, do it.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Check if we really need to fetch more tokens.
0000000000000000000000000000000000000000;;			need_more_tokens := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if parser.tokens_head == len(parser.tokens) {
0000000000000000000000000000000000000000;;				// Queue is empty.
0000000000000000000000000000000000000000;;				need_more_tokens = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Check if any potential simple key may occupy the head position.
0000000000000000000000000000000000000000;;				if !yaml_parser_stale_simple_keys(parser) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := range parser.simple_keys {
0000000000000000000000000000000000000000;;					simple_key := &parser.simple_keys[i]
0000000000000000000000000000000000000000;;					if simple_key.possible && simple_key.token_number == parser.tokens_parsed {
0000000000000000000000000000000000000000;;						need_more_tokens = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We are finished.
0000000000000000000000000000000000000000;;			if !need_more_tokens {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Fetch the next token.
0000000000000000000000000000000000000000;;			if !yaml_parser_fetch_next_token(parser) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parser.token_available = true
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The dispatcher for token fetchers.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_next_token(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// Ensure that the buffer is initialized.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if we just started scanning.  Fetch STREAM-START then.
0000000000000000000000000000000000000000;;		if !parser.stream_start_produced {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_stream_start(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat whitespaces and comments until we reach the next token.
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_to_next_token(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove obsolete potential simple keys.
0000000000000000000000000000000000000000;;		if !yaml_parser_stale_simple_keys(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check the indentation level against the current column.
0000000000000000000000000000000000000000;;		if !yaml_parser_unroll_indent(parser, parser.mark.column) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure that the buffer contains at least 4 characters.  4 is the length
0000000000000000000000000000000000000000;;		// of the longest indicators ('--- ' and '... ').
0000000000000000000000000000000000000000;;		if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the end of the stream?
0000000000000000000000000000000000000000;;		if is_z(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_stream_end(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it a directive?
0000000000000000000000000000000000000000;;		if parser.mark.column == 0 && parser.buffer[parser.buffer_pos] == '%' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_directive(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := parser.buffer
0000000000000000000000000000000000000000;;		pos := parser.buffer_pos
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the document start indicator?
0000000000000000000000000000000000000000;;		if parser.mark.column == 0 && buf[pos] == '-' && buf[pos+1] == '-' && buf[pos+2] == '-' && is_blankz(buf, pos+3) {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_document_indicator(parser, yaml_DOCUMENT_START_TOKEN)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the document end indicator?
0000000000000000000000000000000000000000;;		if parser.mark.column == 0 && buf[pos] == '.' && buf[pos+1] == '.' && buf[pos+2] == '.' && is_blankz(buf, pos+3) {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_document_indicator(parser, yaml_DOCUMENT_END_TOKEN)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the flow sequence start indicator?
0000000000000000000000000000000000000000;;		if buf[pos] == '[' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_flow_collection_start(parser, yaml_FLOW_SEQUENCE_START_TOKEN)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the flow mapping start indicator?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '{' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_flow_collection_start(parser, yaml_FLOW_MAPPING_START_TOKEN)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the flow sequence end indicator?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == ']' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_flow_collection_end(parser,
0000000000000000000000000000000000000000;;				yaml_FLOW_SEQUENCE_END_TOKEN)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the flow mapping end indicator?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '}' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_flow_collection_end(parser,
0000000000000000000000000000000000000000;;				yaml_FLOW_MAPPING_END_TOKEN)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the flow entry indicator?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == ',' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_flow_entry(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the block entry indicator?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '-' && is_blankz(parser.buffer, parser.buffer_pos+1) {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_block_entry(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the key indicator?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '?' && (parser.flow_level > 0 || is_blankz(parser.buffer, parser.buffer_pos+1)) {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_key(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it the value indicator?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == ':' && (parser.flow_level > 0 || is_blankz(parser.buffer, parser.buffer_pos+1)) {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_value(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it an alias?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '*' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_anchor(parser, yaml_ALIAS_TOKEN)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it an anchor?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '&' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_anchor(parser, yaml_ANCHOR_TOKEN)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it a tag?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '!' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_tag(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it a literal scalar?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '|' && parser.flow_level == 0 {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_block_scalar(parser, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it a folded scalar?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '>' && parser.flow_level == 0 {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_block_scalar(parser, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it a single-quoted scalar?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '\'' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_flow_scalar(parser, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it a double-quoted scalar?
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '"' {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_flow_scalar(parser, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it a plain scalar?
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// A plain scalar may start with any non-blank characters except
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//      '-', '?', ':', ',', '[', ']', '{', '}',
0000000000000000000000000000000000000000;;		//      '#', '&', '*', '!', '|', '>', '\'', '\"',
0000000000000000000000000000000000000000;;		//      '%', '@', '`'.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// In the block context (and, for the '-' indicator, in the flow context
0000000000000000000000000000000000000000;;		// too), it may also start with the characters
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//      '-', '?', ':'
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// if it is followed by a non-space character.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The last rule is more restrictive than the specification requires.
0000000000000000000000000000000000000000;;		// [Go] Make this logic more reasonable.
0000000000000000000000000000000000000000;;		//switch parser.buffer[parser.buffer_pos] {
0000000000000000000000000000000000000000;;		//case '-', '?', ':', ',', '?', '-', ',', ':', ']', '[', '}', '{', '&', '#', '!', '*', '>', '|', '"', '\'', '@', '%', '-', '`':
0000000000000000000000000000000000000000;;		//}
0000000000000000000000000000000000000000;;		if !(is_blankz(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == '-' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == ':' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == ',' || parser.buffer[parser.buffer_pos] == '[' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '{' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '}' || parser.buffer[parser.buffer_pos] == '#' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '&' || parser.buffer[parser.buffer_pos] == '*' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '!' || parser.buffer[parser.buffer_pos] == '|' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '>' || parser.buffer[parser.buffer_pos] == '\'' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '"' || parser.buffer[parser.buffer_pos] == '%' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '@' || parser.buffer[parser.buffer_pos] == '`') ||
0000000000000000000000000000000000000000;;			(parser.buffer[parser.buffer_pos] == '-' && !is_blank(parser.buffer, parser.buffer_pos+1)) ||
0000000000000000000000000000000000000000;;			(parser.flow_level == 0 &&
0000000000000000000000000000000000000000;;				(parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == ':') &&
0000000000000000000000000000000000000000;;				!is_blankz(parser.buffer, parser.buffer_pos+1)) {
0000000000000000000000000000000000000000;;			return yaml_parser_fetch_plain_scalar(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we don't determine the token type so far, it is an error.
0000000000000000000000000000000000000000;;		return yaml_parser_set_scanner_error(parser,
0000000000000000000000000000000000000000;;			"while scanning for the next token", parser.mark,
0000000000000000000000000000000000000000;;			"found character that cannot start any token")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check the list of potential simple keys and remove the positions that
0000000000000000000000000000000000000000;;	// cannot contain simple keys anymore.
0000000000000000000000000000000000000000;;	func yaml_parser_stale_simple_keys(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// Check for a potential simple key for each flow level.
0000000000000000000000000000000000000000;;		for i := range parser.simple_keys {
0000000000000000000000000000000000000000;;			simple_key := &parser.simple_keys[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The specification requires that a simple key
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			//  - is limited to a single line,
0000000000000000000000000000000000000000;;			//  - is shorter than 1024 characters.
0000000000000000000000000000000000000000;;			if simple_key.possible && (simple_key.mark.line < parser.mark.line || simple_key.mark.index+1024 < parser.mark.index) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check if the potential simple key to be removed is required.
0000000000000000000000000000000000000000;;				if simple_key.required {
0000000000000000000000000000000000000000;;					return yaml_parser_set_scanner_error(parser,
0000000000000000000000000000000000000000;;						"while scanning a simple key", simple_key.mark,
0000000000000000000000000000000000000000;;						"could not find expected ':'")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				simple_key.possible = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a simple key may start at the current position and add it if
0000000000000000000000000000000000000000;;	// needed.
0000000000000000000000000000000000000000;;	func yaml_parser_save_simple_key(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// A simple key is required at the current position if the scanner is in
0000000000000000000000000000000000000000;;		// the block context and the current column coincides with the indentation
0000000000000000000000000000000000000000;;		// level.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		required := parser.flow_level == 0 && parser.indent == parser.mark.column
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A simple key is required only when it is the first token in the current
0000000000000000000000000000000000000000;;		// line.  Therefore it is always allowed.  But we add a check anyway.
0000000000000000000000000000000000000000;;		if required && !parser.simple_key_allowed {
0000000000000000000000000000000000000000;;			panic("should not happen")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the current position may start a simple key, save it.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		if parser.simple_key_allowed {
0000000000000000000000000000000000000000;;			simple_key := yaml_simple_key_t{
0000000000000000000000000000000000000000;;				possible:     true,
0000000000000000000000000000000000000000;;				required:     required,
0000000000000000000000000000000000000000;;				token_number: parser.tokens_parsed + (len(parser.tokens) - parser.tokens_head),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			simple_key.mark = parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !yaml_parser_remove_simple_key(parser) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parser.simple_keys[len(parser.simple_keys)-1] = simple_key
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove a potential simple key at the current flow level.
0000000000000000000000000000000000000000;;	func yaml_parser_remove_simple_key(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		i := len(parser.simple_keys) - 1
0000000000000000000000000000000000000000;;		if parser.simple_keys[i].possible {
0000000000000000000000000000000000000000;;			// If the key is required, it is an error.
0000000000000000000000000000000000000000;;			if parser.simple_keys[i].required {
0000000000000000000000000000000000000000;;				return yaml_parser_set_scanner_error(parser,
0000000000000000000000000000000000000000;;					"while scanning a simple key", parser.simple_keys[i].mark,
0000000000000000000000000000000000000000;;					"could not find expected ':'")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Remove the key from the stack.
0000000000000000000000000000000000000000;;		parser.simple_keys[i].possible = false
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Increase the flow level and resize the simple key list if needed.
0000000000000000000000000000000000000000;;	func yaml_parser_increase_flow_level(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// Reset the simple key on the next level.
0000000000000000000000000000000000000000;;		parser.simple_keys = append(parser.simple_keys, yaml_simple_key_t{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Increase the flow level.
0000000000000000000000000000000000000000;;		parser.flow_level++
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decrease the flow level.
0000000000000000000000000000000000000000;;	func yaml_parser_decrease_flow_level(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		if parser.flow_level > 0 {
0000000000000000000000000000000000000000;;			parser.flow_level--
0000000000000000000000000000000000000000;;			parser.simple_keys = parser.simple_keys[:len(parser.simple_keys)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Push the current indentation level to the stack and set the new level
0000000000000000000000000000000000000000;;	// the current column is greater than the indentation level.  In this case,
0000000000000000000000000000000000000000;;	// append or insert the specified token into the token queue.
0000000000000000000000000000000000000000;;	func yaml_parser_roll_indent(parser *yaml_parser_t, column, number int, typ yaml_token_type_t, mark yaml_mark_t) bool {
0000000000000000000000000000000000000000;;		// In the flow context, do nothing.
0000000000000000000000000000000000000000;;		if parser.flow_level > 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parser.indent < column {
0000000000000000000000000000000000000000;;			// Push the current indentation level to the stack and set the new
0000000000000000000000000000000000000000;;			// indentation level.
0000000000000000000000000000000000000000;;			parser.indents = append(parser.indents, parser.indent)
0000000000000000000000000000000000000000;;			parser.indent = column
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a token and insert it into the queue.
0000000000000000000000000000000000000000;;			token := yaml_token_t{
0000000000000000000000000000000000000000;;				typ:        typ,
0000000000000000000000000000000000000000;;				start_mark: mark,
0000000000000000000000000000000000000000;;				end_mark:   mark,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if number > -1 {
0000000000000000000000000000000000000000;;				number -= parser.tokens_parsed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			yaml_insert_token(parser, number, &token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pop indentation levels from the indents stack until the current level
0000000000000000000000000000000000000000;;	// becomes less or equal to the column.  For each indentation level, append
0000000000000000000000000000000000000000;;	// the BLOCK-END token.
0000000000000000000000000000000000000000;;	func yaml_parser_unroll_indent(parser *yaml_parser_t, column int) bool {
0000000000000000000000000000000000000000;;		// In the flow context, do nothing.
0000000000000000000000000000000000000000;;		if parser.flow_level > 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Loop through the indentation levels in the stack.
0000000000000000000000000000000000000000;;		for parser.indent > column {
0000000000000000000000000000000000000000;;			// Create a token and append it to the queue.
0000000000000000000000000000000000000000;;			token := yaml_token_t{
0000000000000000000000000000000000000000;;				typ:        yaml_BLOCK_END_TOKEN,
0000000000000000000000000000000000000000;;				start_mark: parser.mark,
0000000000000000000000000000000000000000;;				end_mark:   parser.mark,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Pop the indentation level.
0000000000000000000000000000000000000000;;			parser.indent = parser.indents[len(parser.indents)-1]
0000000000000000000000000000000000000000;;			parser.indents = parser.indents[:len(parser.indents)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize the scanner and produce the STREAM-START token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_stream_start(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the initial indentation.
0000000000000000000000000000000000000000;;		parser.indent = -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize the simple key stack.
0000000000000000000000000000000000000000;;		parser.simple_keys = append(parser.simple_keys, yaml_simple_key_t{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A simple key is allowed at the beginning of the stream.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We have started.
0000000000000000000000000000000000000000;;		parser.stream_start_produced = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the STREAM-START token and append it to the queue.
0000000000000000000000000000000000000000;;		token := yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        yaml_STREAM_START_TOKEN,
0000000000000000000000000000000000000000;;			start_mark: parser.mark,
0000000000000000000000000000000000000000;;			end_mark:   parser.mark,
0000000000000000000000000000000000000000;;			encoding:   parser.encoding,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the STREAM-END token and shut down the scanner.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_stream_end(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Force new line.
0000000000000000000000000000000000000000;;		if parser.mark.column != 0 {
0000000000000000000000000000000000000000;;			parser.mark.column = 0
0000000000000000000000000000000000000000;;			parser.mark.line++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset the indentation level.
0000000000000000000000000000000000000000;;		if !yaml_parser_unroll_indent(parser, -1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset simple keys.
0000000000000000000000000000000000000000;;		if !yaml_parser_remove_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the STREAM-END token and append it to the queue.
0000000000000000000000000000000000000000;;		token := yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        yaml_STREAM_END_TOKEN,
0000000000000000000000000000000000000000;;			start_mark: parser.mark,
0000000000000000000000000000000000000000;;			end_mark:   parser.mark,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce a VERSION-DIRECTIVE or TAG-DIRECTIVE token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_directive(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// Reset the indentation level.
0000000000000000000000000000000000000000;;		if !yaml_parser_unroll_indent(parser, -1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset simple keys.
0000000000000000000000000000000000000000;;		if !yaml_parser_remove_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the YAML-DIRECTIVE or TAG-DIRECTIVE token.
0000000000000000000000000000000000000000;;		token := yaml_token_t{}
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_directive(parser, &token) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Append the token to the queue.
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the DOCUMENT-START or DOCUMENT-END token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_document_indicator(parser *yaml_parser_t, typ yaml_token_type_t) bool {
0000000000000000000000000000000000000000;;		// Reset the indentation level.
0000000000000000000000000000000000000000;;		if !yaml_parser_unroll_indent(parser, -1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset simple keys.
0000000000000000000000000000000000000000;;		if !yaml_parser_remove_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the token.
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the DOCUMENT-START or DOCUMENT-END token.
0000000000000000000000000000000000000000;;		token := yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        typ,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Append the token to the queue.
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the FLOW-SEQUENCE-START or FLOW-MAPPING-START token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_flow_collection_start(parser *yaml_parser_t, typ yaml_token_type_t) bool {
0000000000000000000000000000000000000000;;		// The indicators '[' and '{' may start a simple key.
0000000000000000000000000000000000000000;;		if !yaml_parser_save_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Increase the flow level.
0000000000000000000000000000000000000000;;		if !yaml_parser_increase_flow_level(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A simple key may follow the indicators '[' and '{'.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the token.
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the FLOW-SEQUENCE-START of FLOW-MAPPING-START token.
0000000000000000000000000000000000000000;;		token := yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        typ,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Append the token to the queue.
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the FLOW-SEQUENCE-END or FLOW-MAPPING-END token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_flow_collection_end(parser *yaml_parser_t, typ yaml_token_type_t) bool {
0000000000000000000000000000000000000000;;		// Reset any potential simple key on the current flow level.
0000000000000000000000000000000000000000;;		if !yaml_parser_remove_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decrease the flow level.
0000000000000000000000000000000000000000;;		if !yaml_parser_decrease_flow_level(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No simple keys after the indicators ']' and '}'.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the token.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the FLOW-SEQUENCE-END of FLOW-MAPPING-END token.
0000000000000000000000000000000000000000;;		token := yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        typ,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Append the token to the queue.
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the FLOW-ENTRY token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_flow_entry(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// Reset any potential simple keys on the current flow level.
0000000000000000000000000000000000000000;;		if !yaml_parser_remove_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Simple keys are allowed after ','.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the token.
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the FLOW-ENTRY token and append it to the queue.
0000000000000000000000000000000000000000;;		token := yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        yaml_FLOW_ENTRY_TOKEN,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the BLOCK-ENTRY token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_block_entry(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// Check if the scanner is in the block context.
0000000000000000000000000000000000000000;;		if parser.flow_level == 0 {
0000000000000000000000000000000000000000;;			// Check if we are allowed to start a new entry.
0000000000000000000000000000000000000000;;			if !parser.simple_key_allowed {
0000000000000000000000000000000000000000;;				return yaml_parser_set_scanner_error(parser, "", parser.mark,
0000000000000000000000000000000000000000;;					"block sequence entries are not allowed in this context")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Add the BLOCK-SEQUENCE-START token if needed.
0000000000000000000000000000000000000000;;			if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_SEQUENCE_START_TOKEN, parser.mark) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// It is an error for the '-' indicator to occur in the flow context,
0000000000000000000000000000000000000000;;			// but we let the Parser detect and report about it because the Parser
0000000000000000000000000000000000000000;;			// is able to point to the context.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset any potential simple keys on the current flow level.
0000000000000000000000000000000000000000;;		if !yaml_parser_remove_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Simple keys are allowed after '-'.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the token.
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the BLOCK-ENTRY token and append it to the queue.
0000000000000000000000000000000000000000;;		token := yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        yaml_BLOCK_ENTRY_TOKEN,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the KEY token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_key(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In the block context, additional checks are required.
0000000000000000000000000000000000000000;;		if parser.flow_level == 0 {
0000000000000000000000000000000000000000;;			// Check if we are allowed to start a new key (not nessesary simple).
0000000000000000000000000000000000000000;;			if !parser.simple_key_allowed {
0000000000000000000000000000000000000000;;				return yaml_parser_set_scanner_error(parser, "", parser.mark,
0000000000000000000000000000000000000000;;					"mapping keys are not allowed in this context")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Add the BLOCK-MAPPING-START token if needed.
0000000000000000000000000000000000000000;;			if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_MAPPING_START_TOKEN, parser.mark) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset any potential simple keys on the current flow level.
0000000000000000000000000000000000000000;;		if !yaml_parser_remove_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Simple keys are allowed after '?' in the block context.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = parser.flow_level == 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the token.
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the KEY token and append it to the queue.
0000000000000000000000000000000000000000;;		token := yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        yaml_KEY_TOKEN,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the VALUE token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_value(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple_key := &parser.simple_keys[len(parser.simple_keys)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Have we found a simple key?
0000000000000000000000000000000000000000;;		if simple_key.possible {
0000000000000000000000000000000000000000;;			// Create the KEY token and insert it into the queue.
0000000000000000000000000000000000000000;;			token := yaml_token_t{
0000000000000000000000000000000000000000;;				typ:        yaml_KEY_TOKEN,
0000000000000000000000000000000000000000;;				start_mark: simple_key.mark,
0000000000000000000000000000000000000000;;				end_mark:   simple_key.mark,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			yaml_insert_token(parser, simple_key.token_number-parser.tokens_parsed, &token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// In the block context, we may need to add the BLOCK-MAPPING-START token.
0000000000000000000000000000000000000000;;			if !yaml_parser_roll_indent(parser, simple_key.mark.column,
0000000000000000000000000000000000000000;;				simple_key.token_number,
0000000000000000000000000000000000000000;;				yaml_BLOCK_MAPPING_START_TOKEN, simple_key.mark) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remove the simple key.
0000000000000000000000000000000000000000;;			simple_key.possible = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// A simple key cannot follow another simple key.
0000000000000000000000000000000000000000;;			parser.simple_key_allowed = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The ':' indicator follows a complex key.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// In the block context, extra checks are required.
0000000000000000000000000000000000000000;;			if parser.flow_level == 0 {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check if we are allowed to start a complex value.
0000000000000000000000000000000000000000;;				if !parser.simple_key_allowed {
0000000000000000000000000000000000000000;;					return yaml_parser_set_scanner_error(parser, "", parser.mark,
0000000000000000000000000000000000000000;;						"mapping values are not allowed in this context")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Add the BLOCK-MAPPING-START token if needed.
0000000000000000000000000000000000000000;;				if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_MAPPING_START_TOKEN, parser.mark) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Simple keys after ':' are allowed in the block context.
0000000000000000000000000000000000000000;;			parser.simple_key_allowed = parser.flow_level == 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the token.
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the VALUE token and append it to the queue.
0000000000000000000000000000000000000000;;		token := yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        yaml_VALUE_TOKEN,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the ALIAS or ANCHOR token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_anchor(parser *yaml_parser_t, typ yaml_token_type_t) bool {
0000000000000000000000000000000000000000;;		// An anchor or an alias could be a simple key.
0000000000000000000000000000000000000000;;		if !yaml_parser_save_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A simple key cannot follow an anchor or an alias.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the ALIAS or ANCHOR token and append it to the queue.
0000000000000000000000000000000000000000;;		var token yaml_token_t
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_anchor(parser, &token, typ) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the TAG token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_tag(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// A tag could be a simple key.
0000000000000000000000000000000000000000;;		if !yaml_parser_save_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A simple key cannot follow a tag.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the TAG token and append it to the queue.
0000000000000000000000000000000000000000;;		var token yaml_token_t
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_tag(parser, &token) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the SCALAR(...,literal) or SCALAR(...,folded) tokens.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_block_scalar(parser *yaml_parser_t, literal bool) bool {
0000000000000000000000000000000000000000;;		// Remove any potential simple keys.
0000000000000000000000000000000000000000;;		if !yaml_parser_remove_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A simple key may follow a block scalar.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the SCALAR token and append it to the queue.
0000000000000000000000000000000000000000;;		var token yaml_token_t
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_block_scalar(parser, &token, literal) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the SCALAR(...,single-quoted) or SCALAR(...,double-quoted) tokens.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_flow_scalar(parser *yaml_parser_t, single bool) bool {
0000000000000000000000000000000000000000;;		// A plain scalar could be a simple key.
0000000000000000000000000000000000000000;;		if !yaml_parser_save_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A simple key cannot follow a flow scalar.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the SCALAR token and append it to the queue.
0000000000000000000000000000000000000000;;		var token yaml_token_t
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_flow_scalar(parser, &token, single) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Produce the SCALAR(...,plain) token.
0000000000000000000000000000000000000000;;	func yaml_parser_fetch_plain_scalar(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;		// A plain scalar could be a simple key.
0000000000000000000000000000000000000000;;		if !yaml_parser_save_simple_key(parser) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A simple key cannot follow a flow scalar.
0000000000000000000000000000000000000000;;		parser.simple_key_allowed = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the SCALAR token and append it to the queue.
0000000000000000000000000000000000000000;;		var token yaml_token_t
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_plain_scalar(parser, &token) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		yaml_insert_token(parser, -1, &token)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Eat whitespaces and comments until the next token is found.
0000000000000000000000000000000000000000;;	func yaml_parser_scan_to_next_token(parser *yaml_parser_t) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Until the next token is not found.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Allow the BOM mark to start a line.
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parser.mark.column == 0 && is_bom(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				skip(parser)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Eat whitespaces.
0000000000000000000000000000000000000000;;			// Tabs are allowed:
0000000000000000000000000000000000000000;;			//  - in the flow context
0000000000000000000000000000000000000000;;			//  - in the block context, but not at the beginning of the line or
0000000000000000000000000000000000000000;;			//  after '-', '?', or ':' (complex value).
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for parser.buffer[parser.buffer_pos] == ' ' || ((parser.flow_level > 0 || !parser.simple_key_allowed) && parser.buffer[parser.buffer_pos] == '\t') {
0000000000000000000000000000000000000000;;				skip(parser)
0000000000000000000000000000000000000000;;				if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Eat a comment until a line break.
0000000000000000000000000000000000000000;;			if parser.buffer[parser.buffer_pos] == '#' {
0000000000000000000000000000000000000000;;				for !is_breakz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;					skip(parser)
0000000000000000000000000000000000000000;;					if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If it is a line break, eat it.
0000000000000000000000000000000000000000;;			if is_break(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				skip_line(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// In the block context, a new line may start a simple key.
0000000000000000000000000000000000000000;;				if parser.flow_level == 0 {
0000000000000000000000000000000000000000;;					parser.simple_key_allowed = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				break // We have found a token.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan a YAML-DIRECTIVE or TAG-DIRECTIVE token.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Scope:
0000000000000000000000000000000000000000;;	//      %YAML    1.1    # a comment \n
0000000000000000000000000000000000000000;;	//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
0000000000000000000000000000000000000000;;	//      %TAG    !yaml!  tag:yaml.org,2002:  \n
0000000000000000000000000000000000000000;;	//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_scan_directive(parser *yaml_parser_t, token *yaml_token_t) bool {
0000000000000000000000000000000000000000;;		// Eat '%'.
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan the directive name.
0000000000000000000000000000000000000000;;		var name []byte
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_directive_name(parser, start_mark, &name) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it a YAML directive?
0000000000000000000000000000000000000000;;		if bytes.Equal(name, []byte("YAML")) {
0000000000000000000000000000000000000000;;			// Scan the VERSION directive value.
0000000000000000000000000000000000000000;;			var major, minor int8
0000000000000000000000000000000000000000;;			if !yaml_parser_scan_version_directive_value(parser, start_mark, &major, &minor) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a VERSION-DIRECTIVE token.
0000000000000000000000000000000000000000;;			*token = yaml_token_t{
0000000000000000000000000000000000000000;;				typ:        yaml_VERSION_DIRECTIVE_TOKEN,
0000000000000000000000000000000000000000;;				start_mark: start_mark,
0000000000000000000000000000000000000000;;				end_mark:   end_mark,
0000000000000000000000000000000000000000;;				major:      major,
0000000000000000000000000000000000000000;;				minor:      minor,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Is it a TAG directive?
0000000000000000000000000000000000000000;;		} else if bytes.Equal(name, []byte("TAG")) {
0000000000000000000000000000000000000000;;			// Scan the TAG directive value.
0000000000000000000000000000000000000000;;			var handle, prefix []byte
0000000000000000000000000000000000000000;;			if !yaml_parser_scan_tag_directive_value(parser, start_mark, &handle, &prefix) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create a TAG-DIRECTIVE token.
0000000000000000000000000000000000000000;;			*token = yaml_token_t{
0000000000000000000000000000000000000000;;				typ:        yaml_TAG_DIRECTIVE_TOKEN,
0000000000000000000000000000000000000000;;				start_mark: start_mark,
0000000000000000000000000000000000000000;;				end_mark:   end_mark,
0000000000000000000000000000000000000000;;				value:      handle,
0000000000000000000000000000000000000000;;				prefix:     prefix,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Unknown directive.
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_error(parser, "while scanning a directive",
0000000000000000000000000000000000000000;;				start_mark, "found uknown directive name")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat the rest of the line including any comments.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for is_blank(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '#' {
0000000000000000000000000000000000000000;;			for !is_breakz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				skip(parser)
0000000000000000000000000000000000000000;;				if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if we are at the end of the line.
0000000000000000000000000000000000000000;;		if !is_breakz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_error(parser, "while scanning a directive",
0000000000000000000000000000000000000000;;				start_mark, "did not find expected comment or line break")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat a line break.
0000000000000000000000000000000000000000;;		if is_break(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			skip_line(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan the directive name.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Scope:
0000000000000000000000000000000000000000;;	//      %YAML   1.1     # a comment \n
0000000000000000000000000000000000000000;;	//       ^^^^
0000000000000000000000000000000000000000;;	//      %TAG    !yaml!  tag:yaml.org,2002:  \n
0000000000000000000000000000000000000000;;	//       ^^^
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_scan_directive_name(parser *yaml_parser_t, start_mark yaml_mark_t, name *[]byte) bool {
0000000000000000000000000000000000000000;;		// Consume the directive name.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var s []byte
0000000000000000000000000000000000000000;;		for is_alpha(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			s = read(parser, s)
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the name is empty.
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_error(parser, "while scanning a directive",
0000000000000000000000000000000000000000;;				start_mark, "could not find expected directive name")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for an blank character after the name.
0000000000000000000000000000000000000000;;		if !is_blankz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_error(parser, "while scanning a directive",
0000000000000000000000000000000000000000;;				start_mark, "found unexpected non-alphabetical character")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*name = s
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan the value of VERSION-DIRECTIVE.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Scope:
0000000000000000000000000000000000000000;;	//      %YAML   1.1     # a comment \n
0000000000000000000000000000000000000000;;	//           ^^^^^^
0000000000000000000000000000000000000000;;	func yaml_parser_scan_version_directive_value(parser *yaml_parser_t, start_mark yaml_mark_t, major, minor *int8) bool {
0000000000000000000000000000000000000000;;		// Eat whitespaces.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for is_blank(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the major version number.
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_version_directive_number(parser, start_mark, major) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat '.'.
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] != '.' {
0000000000000000000000000000000000000000;;			return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
0000000000000000000000000000000000000000;;				start_mark, "did not find expected digit or '.' character")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the minor version number.
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_version_directive_number(parser, start_mark, minor) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const max_number_length = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan the version number of VERSION-DIRECTIVE.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Scope:
0000000000000000000000000000000000000000;;	//      %YAML   1.1     # a comment \n
0000000000000000000000000000000000000000;;	//              ^
0000000000000000000000000000000000000000;;	//      %YAML   1.1     # a comment \n
0000000000000000000000000000000000000000;;	//                ^
0000000000000000000000000000000000000000;;	func yaml_parser_scan_version_directive_number(parser *yaml_parser_t, start_mark yaml_mark_t, number *int8) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Repeat while the next character is digit.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var value, length int8
0000000000000000000000000000000000000000;;		for is_digit(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			// Check if the number is too long.
0000000000000000000000000000000000000000;;			length++
0000000000000000000000000000000000000000;;			if length > max_number_length {
0000000000000000000000000000000000000000;;				return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
0000000000000000000000000000000000000000;;					start_mark, "found extremely long version number")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value = value*10 + int8(as_digit(parser.buffer, parser.buffer_pos))
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the number was present.
0000000000000000000000000000000000000000;;		if length == 0 {
0000000000000000000000000000000000000000;;			return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
0000000000000000000000000000000000000000;;				start_mark, "did not find expected version number")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*number = value
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan the value of a TAG-DIRECTIVE token.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Scope:
0000000000000000000000000000000000000000;;	//      %TAG    !yaml!  tag:yaml.org,2002:  \n
0000000000000000000000000000000000000000;;	//          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func yaml_parser_scan_tag_directive_value(parser *yaml_parser_t, start_mark yaml_mark_t, handle, prefix *[]byte) bool {
0000000000000000000000000000000000000000;;		var handle_value, prefix_value []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat whitespaces.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for is_blank(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan a handle.
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_tag_handle(parser, true, start_mark, &handle_value) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expect a whitespace.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !is_blank(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_error(parser, "while scanning a %TAG directive",
0000000000000000000000000000000000000000;;				start_mark, "did not find expected whitespace")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat whitespaces.
0000000000000000000000000000000000000000;;		for is_blank(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan a prefix.
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_tag_uri(parser, true, nil, start_mark, &prefix_value) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expect a whitespace or line break.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !is_blankz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_error(parser, "while scanning a %TAG directive",
0000000000000000000000000000000000000000;;				start_mark, "did not find expected whitespace or line break")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*handle = handle_value
0000000000000000000000000000000000000000;;		*prefix = prefix_value
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func yaml_parser_scan_anchor(parser *yaml_parser_t, token *yaml_token_t, typ yaml_token_type_t) bool {
0000000000000000000000000000000000000000;;		var s []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat the indicator character.
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the value.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for is_alpha(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			s = read(parser, s)
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;		 * Check if length of the anchor is greater than 0 and it is followed by
0000000000000000000000000000000000000000;;		 * a whitespace character or one of the indicators:
0000000000000000000000000000000000000000;;		 *
0000000000000000000000000000000000000000;;		 *      '?', ':', ',', ']', '}', '%', '@', '`'.
0000000000000000000000000000000000000000;;		 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(s) == 0 ||
0000000000000000000000000000000000000000;;			!(is_blankz(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == '?' ||
0000000000000000000000000000000000000000;;				parser.buffer[parser.buffer_pos] == ':' || parser.buffer[parser.buffer_pos] == ',' ||
0000000000000000000000000000000000000000;;				parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '}' ||
0000000000000000000000000000000000000000;;				parser.buffer[parser.buffer_pos] == '%' || parser.buffer[parser.buffer_pos] == '@' ||
0000000000000000000000000000000000000000;;				parser.buffer[parser.buffer_pos] == '`') {
0000000000000000000000000000000000000000;;			context := "while scanning an alias"
0000000000000000000000000000000000000000;;			if typ == yaml_ANCHOR_TOKEN {
0000000000000000000000000000000000000000;;				context = "while scanning an anchor"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_error(parser, context, start_mark,
0000000000000000000000000000000000000000;;				"did not find expected alphabetic or numeric character")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a token.
0000000000000000000000000000000000000000;;		*token = yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        typ,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;			value:      s,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Scan a TAG token.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func yaml_parser_scan_tag(parser *yaml_parser_t, token *yaml_token_t) bool {
0000000000000000000000000000000000000000;;		var handle, suffix []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the tag is in the canonical form.
0000000000000000000000000000000000000000;;		if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos+1] == '<' {
0000000000000000000000000000000000000000;;			// Keep the handle as ''
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Eat '!<'
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Consume the tag value.
0000000000000000000000000000000000000000;;			if !yaml_parser_scan_tag_uri(parser, false, nil, start_mark, &suffix) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for '>' and eat it.
0000000000000000000000000000000000000000;;			if parser.buffer[parser.buffer_pos] != '>' {
0000000000000000000000000000000000000000;;				yaml_parser_set_scanner_error(parser, "while scanning a tag",
0000000000000000000000000000000000000000;;					start_mark, "did not find the expected '>'")
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The tag has either the '!suffix' or the '!handle!suffix' form.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// First, try to scan a handle.
0000000000000000000000000000000000000000;;			if !yaml_parser_scan_tag_handle(parser, false, start_mark, &handle) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check if it is, indeed, handle.
0000000000000000000000000000000000000000;;			if handle[0] == '!' && len(handle) > 1 && handle[len(handle)-1] == '!' {
0000000000000000000000000000000000000000;;				// Scan the suffix now.
0000000000000000000000000000000000000000;;				if !yaml_parser_scan_tag_uri(parser, false, nil, start_mark, &suffix) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// It wasn't a handle after all.  Scan the rest of the tag.
0000000000000000000000000000000000000000;;				if !yaml_parser_scan_tag_uri(parser, false, handle, start_mark, &suffix) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Set the handle to '!'.
0000000000000000000000000000000000000000;;				handle = []byte{'!'}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// A special case: the '!' tag.  Set the handle to '' and the
0000000000000000000000000000000000000000;;				// suffix to '!'.
0000000000000000000000000000000000000000;;				if len(suffix) == 0 {
0000000000000000000000000000000000000000;;					handle, suffix = suffix, handle
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check the character which ends the tag.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !is_blankz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_error(parser, "while scanning a tag",
0000000000000000000000000000000000000000;;				start_mark, "did not find expected whitespace or line break")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a token.
0000000000000000000000000000000000000000;;		*token = yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        yaml_TAG_TOKEN,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;			value:      handle,
0000000000000000000000000000000000000000;;			suffix:     suffix,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan a tag handle.
0000000000000000000000000000000000000000;;	func yaml_parser_scan_tag_handle(parser *yaml_parser_t, directive bool, start_mark yaml_mark_t, handle *[]byte) bool {
0000000000000000000000000000000000000000;;		// Check the initial '!' character.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] != '!' {
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_tag_error(parser, directive,
0000000000000000000000000000000000000000;;				start_mark, "did not find expected '!'")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var s []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy the '!' character.
0000000000000000000000000000000000000000;;		s = read(parser, s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy all subsequent alphabetical and numerical characters.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for is_alpha(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			s = read(parser, s)
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the trailing character is '!' and copy it.
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '!' {
0000000000000000000000000000000000000000;;			s = read(parser, s)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// It's either the '!' tag or not really a tag handle.  If it's a %TAG
0000000000000000000000000000000000000000;;			// directive, it's an error.  If it's a tag token, it must be a part of URI.
0000000000000000000000000000000000000000;;			if directive && !(s[0] == '!' && s[1] == 0) {
0000000000000000000000000000000000000000;;				yaml_parser_set_scanner_tag_error(parser, directive,
0000000000000000000000000000000000000000;;					start_mark, "did not find expected '!'")
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*handle = s
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan a tag.
0000000000000000000000000000000000000000;;	func yaml_parser_scan_tag_uri(parser *yaml_parser_t, directive bool, head []byte, start_mark yaml_mark_t, uri *[]byte) bool {
0000000000000000000000000000000000000000;;		//size_t length = head ? strlen((char *)head) : 0
0000000000000000000000000000000000000000;;		var s []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy the head if needed.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note that we don't copy the leading '!' character.
0000000000000000000000000000000000000000;;		if len(head) > 1 {
0000000000000000000000000000000000000000;;			s = append(s, head[1:]...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan the tag.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The set of characters that may appear in URI is as follows:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//      '0'-'9', 'A'-'Z', 'a'-'z', '_', '-', ';', '/', '?', ':', '@', '&',
0000000000000000000000000000000000000000;;		//      '=', '+', '$', ',', '.', '!', '~', '*', '\'', '(', ')', '[', ']',
0000000000000000000000000000000000000000;;		//      '%'.
0000000000000000000000000000000000000000;;		// [Go] Convert this into more reasonable logic.
0000000000000000000000000000000000000000;;		for is_alpha(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == ';' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '/' || parser.buffer[parser.buffer_pos] == '?' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == ':' || parser.buffer[parser.buffer_pos] == '@' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '&' || parser.buffer[parser.buffer_pos] == '=' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '$' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == ',' || parser.buffer[parser.buffer_pos] == '.' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '!' || parser.buffer[parser.buffer_pos] == '~' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '*' || parser.buffer[parser.buffer_pos] == '\'' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '(' || parser.buffer[parser.buffer_pos] == ')' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '[' || parser.buffer[parser.buffer_pos] == ']' ||
0000000000000000000000000000000000000000;;			parser.buffer[parser.buffer_pos] == '%' {
0000000000000000000000000000000000000000;;			// Check if it is a URI-escape sequence.
0000000000000000000000000000000000000000;;			if parser.buffer[parser.buffer_pos] == '%' {
0000000000000000000000000000000000000000;;				if !yaml_parser_scan_uri_escapes(parser, directive, start_mark, &s) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s = read(parser, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the tag is non-empty.
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_tag_error(parser, directive,
0000000000000000000000000000000000000000;;				start_mark, "did not find expected tag URI")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*uri = s
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode an URI-escape sequence corresponding to a single UTF-8 character.
0000000000000000000000000000000000000000;;	func yaml_parser_scan_uri_escapes(parser *yaml_parser_t, directive bool, start_mark yaml_mark_t, s *[]byte) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decode the required number of characters.
0000000000000000000000000000000000000000;;		w := 1024
0000000000000000000000000000000000000000;;		for w > 0 {
0000000000000000000000000000000000000000;;			// Check for a URI-escaped octet.
0000000000000000000000000000000000000000;;			if parser.unread < 3 && !yaml_parser_update_buffer(parser, 3) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !(parser.buffer[parser.buffer_pos] == '%' &&
0000000000000000000000000000000000000000;;				is_hex(parser.buffer, parser.buffer_pos+1) &&
0000000000000000000000000000000000000000;;				is_hex(parser.buffer, parser.buffer_pos+2)) {
0000000000000000000000000000000000000000;;				return yaml_parser_set_scanner_tag_error(parser, directive,
0000000000000000000000000000000000000000;;					start_mark, "did not find URI escaped octet")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the octet.
0000000000000000000000000000000000000000;;			octet := byte((as_hex(parser.buffer, parser.buffer_pos+1) << 4) + as_hex(parser.buffer, parser.buffer_pos+2))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If it is the leading octet, determine the length of the UTF-8 sequence.
0000000000000000000000000000000000000000;;			if w == 1024 {
0000000000000000000000000000000000000000;;				w = width(octet)
0000000000000000000000000000000000000000;;				if w == 0 {
0000000000000000000000000000000000000000;;					return yaml_parser_set_scanner_tag_error(parser, directive,
0000000000000000000000000000000000000000;;						start_mark, "found an incorrect leading UTF-8 octet")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Check if the trailing octet is correct.
0000000000000000000000000000000000000000;;				if octet&0xC0 != 0x80 {
0000000000000000000000000000000000000000;;					return yaml_parser_set_scanner_tag_error(parser, directive,
0000000000000000000000000000000000000000;;						start_mark, "found an incorrect trailing UTF-8 octet")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Copy the octet and move the pointers.
0000000000000000000000000000000000000000;;			*s = append(*s, octet)
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;			w--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan a block scalar.
0000000000000000000000000000000000000000;;	func yaml_parser_scan_block_scalar(parser *yaml_parser_t, token *yaml_token_t, literal bool) bool {
0000000000000000000000000000000000000000;;		// Eat the indicator '|' or '>'.
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan the additional block scalar indicators.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for a chomping indicator.
0000000000000000000000000000000000000000;;		var chomping, increment int
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '-' {
0000000000000000000000000000000000000000;;			// Set the chomping method and eat the indicator.
0000000000000000000000000000000000000000;;			if parser.buffer[parser.buffer_pos] == '+' {
0000000000000000000000000000000000000000;;				chomping = +1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				chomping = -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for an indentation indicator.
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if is_digit(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				// Check that the indentation is greater than 0.
0000000000000000000000000000000000000000;;				if parser.buffer[parser.buffer_pos] == '0' {
0000000000000000000000000000000000000000;;					yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
0000000000000000000000000000000000000000;;						start_mark, "found an indentation indicator equal to 0")
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Get the indentation level and eat the indicator.
0000000000000000000000000000000000000000;;				increment = as_digit(parser.buffer, parser.buffer_pos)
0000000000000000000000000000000000000000;;				skip(parser)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else if is_digit(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			// Do the same as above, but in the opposite order.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if parser.buffer[parser.buffer_pos] == '0' {
0000000000000000000000000000000000000000;;				yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
0000000000000000000000000000000000000000;;					start_mark, "found an indentation indicator equal to 0")
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			increment = as_digit(parser.buffer, parser.buffer_pos)
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '-' {
0000000000000000000000000000000000000000;;				if parser.buffer[parser.buffer_pos] == '+' {
0000000000000000000000000000000000000000;;					chomping = +1
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					chomping = -1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				skip(parser)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat whitespaces and comments to the end of the line.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for is_blank(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			skip(parser)
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parser.buffer[parser.buffer_pos] == '#' {
0000000000000000000000000000000000000000;;			for !is_breakz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				skip(parser)
0000000000000000000000000000000000000000;;				if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if we are at the end of the line.
0000000000000000000000000000000000000000;;		if !is_breakz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
0000000000000000000000000000000000000000;;				start_mark, "did not find expected comment or line break")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat a line break.
0000000000000000000000000000000000000000;;		if is_break(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			skip_line(parser)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the indentation level if it was specified.
0000000000000000000000000000000000000000;;		var indent int
0000000000000000000000000000000000000000;;		if increment > 0 {
0000000000000000000000000000000000000000;;			if parser.indent >= 0 {
0000000000000000000000000000000000000000;;				indent = parser.indent + increment
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				indent = increment
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan the leading line breaks and determine the indentation level if needed.
0000000000000000000000000000000000000000;;		var s, leading_break, trailing_breaks []byte
0000000000000000000000000000000000000000;;		if !yaml_parser_scan_block_scalar_breaks(parser, &indent, &trailing_breaks, start_mark, &end_mark) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan the block scalar content.
0000000000000000000000000000000000000000;;		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var leading_blank, trailing_blank bool
0000000000000000000000000000000000000000;;		for parser.mark.column == indent && !is_z(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;			// We are at the beginning of a non-empty line.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Is it a trailing whitespace?
0000000000000000000000000000000000000000;;			trailing_blank = is_blank(parser.buffer, parser.buffer_pos)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check if we need to fold the leading line break.
0000000000000000000000000000000000000000;;			if !literal && !leading_blank && !trailing_blank && len(leading_break) > 0 && leading_break[0] == '\n' {
0000000000000000000000000000000000000000;;				// Do we need to join the lines by space?
0000000000000000000000000000000000000000;;				if len(trailing_breaks) == 0 {
0000000000000000000000000000000000000000;;					s = append(s, ' ')
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s = append(s, leading_break...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			leading_break = leading_break[:0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Append the remaining line breaks.
0000000000000000000000000000000000000000;;			s = append(s, trailing_breaks...)
0000000000000000000000000000000000000000;;			trailing_breaks = trailing_breaks[:0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Is it a leading whitespace?
0000000000000000000000000000000000000000;;			leading_blank = is_blank(parser.buffer, parser.buffer_pos)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Consume the current line.
0000000000000000000000000000000000000000;;			for !is_breakz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				s = read(parser, s)
0000000000000000000000000000000000000000;;				if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Consume the line break.
0000000000000000000000000000000000000000;;			if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			leading_break = read_line(parser, leading_break)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Eat the following indentation spaces and line breaks.
0000000000000000000000000000000000000000;;			if !yaml_parser_scan_block_scalar_breaks(parser, &indent, &trailing_breaks, start_mark, &end_mark) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Chomp the tail.
0000000000000000000000000000000000000000;;		if chomping != -1 {
0000000000000000000000000000000000000000;;			s = append(s, leading_break...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chomping == 1 {
0000000000000000000000000000000000000000;;			s = append(s, trailing_breaks...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a token.
0000000000000000000000000000000000000000;;		*token = yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        yaml_SCALAR_TOKEN,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;			value:      s,
0000000000000000000000000000000000000000;;			style:      yaml_LITERAL_SCALAR_STYLE,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !literal {
0000000000000000000000000000000000000000;;			token.style = yaml_FOLDED_SCALAR_STYLE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan indentation spaces and line breaks for a block scalar.  Determine the
0000000000000000000000000000000000000000;;	// indentation level if needed.
0000000000000000000000000000000000000000;;	func yaml_parser_scan_block_scalar_breaks(parser *yaml_parser_t, indent *int, breaks *[]byte, start_mark yaml_mark_t, end_mark *yaml_mark_t) bool {
0000000000000000000000000000000000000000;;		*end_mark = parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat the indentation spaces and line breaks.
0000000000000000000000000000000000000000;;		max_indent := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Eat the indentation spaces.
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for (*indent == 0 || parser.mark.column < *indent) && is_space(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				skip(parser)
0000000000000000000000000000000000000000;;				if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parser.mark.column > max_indent {
0000000000000000000000000000000000000000;;				max_indent = parser.mark.column
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for a tab character messing the indentation.
0000000000000000000000000000000000000000;;			if (*indent == 0 || parser.mark.column < *indent) && is_tab(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				return yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
0000000000000000000000000000000000000000;;					start_mark, "found a tab character where an indentation space is expected")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Have we found a non-empty line?
0000000000000000000000000000000000000000;;			if !is_break(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Consume the line break.
0000000000000000000000000000000000000000;;			if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// [Go] Should really be returning breaks instead.
0000000000000000000000000000000000000000;;			*breaks = read_line(parser, *breaks)
0000000000000000000000000000000000000000;;			*end_mark = parser.mark
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine the indentation level if needed.
0000000000000000000000000000000000000000;;		if *indent == 0 {
0000000000000000000000000000000000000000;;			*indent = max_indent
0000000000000000000000000000000000000000;;			if *indent < parser.indent+1 {
0000000000000000000000000000000000000000;;				*indent = parser.indent + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if *indent < 1 {
0000000000000000000000000000000000000000;;				*indent = 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan a quoted scalar.
0000000000000000000000000000000000000000;;	func yaml_parser_scan_flow_scalar(parser *yaml_parser_t, token *yaml_token_t, single bool) bool {
0000000000000000000000000000000000000000;;		// Eat the left quote.
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the content of the quoted scalar.
0000000000000000000000000000000000000000;;		var s, leading_break, trailing_breaks, whitespaces []byte
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Check that there are no document indicators at the beginning of the line.
0000000000000000000000000000000000000000;;			if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if parser.mark.column == 0 &&
0000000000000000000000000000000000000000;;				((parser.buffer[parser.buffer_pos+0] == '-' &&
0000000000000000000000000000000000000000;;					parser.buffer[parser.buffer_pos+1] == '-' &&
0000000000000000000000000000000000000000;;					parser.buffer[parser.buffer_pos+2] == '-') ||
0000000000000000000000000000000000000000;;					(parser.buffer[parser.buffer_pos+0] == '.' &&
0000000000000000000000000000000000000000;;						parser.buffer[parser.buffer_pos+1] == '.' &&
0000000000000000000000000000000000000000;;						parser.buffer[parser.buffer_pos+2] == '.')) &&
0000000000000000000000000000000000000000;;				is_blankz(parser.buffer, parser.buffer_pos+3) {
0000000000000000000000000000000000000000;;				yaml_parser_set_scanner_error(parser, "while scanning a quoted scalar",
0000000000000000000000000000000000000000;;					start_mark, "found unexpected document indicator")
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for EOF.
0000000000000000000000000000000000000000;;			if is_z(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				yaml_parser_set_scanner_error(parser, "while scanning a quoted scalar",
0000000000000000000000000000000000000000;;					start_mark, "found unexpected end of stream")
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Consume non-blank characters.
0000000000000000000000000000000000000000;;			leading_blanks := false
0000000000000000000000000000000000000000;;			for !is_blankz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				if single && parser.buffer[parser.buffer_pos] == '\'' && parser.buffer[parser.buffer_pos+1] == '\'' {
0000000000000000000000000000000000000000;;					// Is is an escaped single quote.
0000000000000000000000000000000000000000;;					s = append(s, '\'')
0000000000000000000000000000000000000000;;					skip(parser)
0000000000000000000000000000000000000000;;					skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				} else if single && parser.buffer[parser.buffer_pos] == '\'' {
0000000000000000000000000000000000000000;;					// It is a right single quote.
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				} else if !single && parser.buffer[parser.buffer_pos] == '"' {
0000000000000000000000000000000000000000;;					// It is a right double quote.
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				} else if !single && parser.buffer[parser.buffer_pos] == '\\' && is_break(parser.buffer, parser.buffer_pos+1) {
0000000000000000000000000000000000000000;;					// It is an escaped line break.
0000000000000000000000000000000000000000;;					if parser.unread < 3 && !yaml_parser_update_buffer(parser, 3) {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					skip(parser)
0000000000000000000000000000000000000000;;					skip_line(parser)
0000000000000000000000000000000000000000;;					leading_blanks = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				} else if !single && parser.buffer[parser.buffer_pos] == '\\' {
0000000000000000000000000000000000000000;;					// It is an escape sequence.
0000000000000000000000000000000000000000;;					code_length := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check the escape character.
0000000000000000000000000000000000000000;;					switch parser.buffer[parser.buffer_pos+1] {
0000000000000000000000000000000000000000;;					case '0':
0000000000000000000000000000000000000000;;						s = append(s, 0)
0000000000000000000000000000000000000000;;					case 'a':
0000000000000000000000000000000000000000;;						s = append(s, '\x07')
0000000000000000000000000000000000000000;;					case 'b':
0000000000000000000000000000000000000000;;						s = append(s, '\x08')
0000000000000000000000000000000000000000;;					case 't', '\t':
0000000000000000000000000000000000000000;;						s = append(s, '\x09')
0000000000000000000000000000000000000000;;					case 'n':
0000000000000000000000000000000000000000;;						s = append(s, '\x0A')
0000000000000000000000000000000000000000;;					case 'v':
0000000000000000000000000000000000000000;;						s = append(s, '\x0B')
0000000000000000000000000000000000000000;;					case 'f':
0000000000000000000000000000000000000000;;						s = append(s, '\x0C')
0000000000000000000000000000000000000000;;					case 'r':
0000000000000000000000000000000000000000;;						s = append(s, '\x0D')
0000000000000000000000000000000000000000;;					case 'e':
0000000000000000000000000000000000000000;;						s = append(s, '\x1B')
0000000000000000000000000000000000000000;;					case ' ':
0000000000000000000000000000000000000000;;						s = append(s, '\x20')
0000000000000000000000000000000000000000;;					case '"':
0000000000000000000000000000000000000000;;						s = append(s, '"')
0000000000000000000000000000000000000000;;					case '\'':
0000000000000000000000000000000000000000;;						s = append(s, '\'')
0000000000000000000000000000000000000000;;					case '\\':
0000000000000000000000000000000000000000;;						s = append(s, '\\')
0000000000000000000000000000000000000000;;					case 'N': // NEL (#x85)
0000000000000000000000000000000000000000;;						s = append(s, '\xC2')
0000000000000000000000000000000000000000;;						s = append(s, '\x85')
0000000000000000000000000000000000000000;;					case '_': // #xA0
0000000000000000000000000000000000000000;;						s = append(s, '\xC2')
0000000000000000000000000000000000000000;;						s = append(s, '\xA0')
0000000000000000000000000000000000000000;;					case 'L': // LS (#x2028)
0000000000000000000000000000000000000000;;						s = append(s, '\xE2')
0000000000000000000000000000000000000000;;						s = append(s, '\x80')
0000000000000000000000000000000000000000;;						s = append(s, '\xA8')
0000000000000000000000000000000000000000;;					case 'P': // PS (#x2029)
0000000000000000000000000000000000000000;;						s = append(s, '\xE2')
0000000000000000000000000000000000000000;;						s = append(s, '\x80')
0000000000000000000000000000000000000000;;						s = append(s, '\xA9')
0000000000000000000000000000000000000000;;					case 'x':
0000000000000000000000000000000000000000;;						code_length = 2
0000000000000000000000000000000000000000;;					case 'u':
0000000000000000000000000000000000000000;;						code_length = 4
0000000000000000000000000000000000000000;;					case 'U':
0000000000000000000000000000000000000000;;						code_length = 8
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
0000000000000000000000000000000000000000;;							start_mark, "found unknown escape character")
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					skip(parser)
0000000000000000000000000000000000000000;;					skip(parser)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Consume an arbitrary escape code.
0000000000000000000000000000000000000000;;					if code_length > 0 {
0000000000000000000000000000000000000000;;						var value int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Scan the character value.
0000000000000000000000000000000000000000;;						if parser.unread < code_length && !yaml_parser_update_buffer(parser, code_length) {
0000000000000000000000000000000000000000;;							return false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for k := 0; k < code_length; k++ {
0000000000000000000000000000000000000000;;							if !is_hex(parser.buffer, parser.buffer_pos+k) {
0000000000000000000000000000000000000000;;								yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
0000000000000000000000000000000000000000;;									start_mark, "did not find expected hexdecimal number")
0000000000000000000000000000000000000000;;								return false
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							value = (value << 4) + as_hex(parser.buffer, parser.buffer_pos+k)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Check the value and write the character.
0000000000000000000000000000000000000000;;						if (value >= 0xD800 && value <= 0xDFFF) || value > 0x10FFFF {
0000000000000000000000000000000000000000;;							yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
0000000000000000000000000000000000000000;;								start_mark, "found invalid Unicode character escape code")
0000000000000000000000000000000000000000;;							return false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if value <= 0x7F {
0000000000000000000000000000000000000000;;							s = append(s, byte(value))
0000000000000000000000000000000000000000;;						} else if value <= 0x7FF {
0000000000000000000000000000000000000000;;							s = append(s, byte(0xC0+(value>>6)))
0000000000000000000000000000000000000000;;							s = append(s, byte(0x80+(value&0x3F)))
0000000000000000000000000000000000000000;;						} else if value <= 0xFFFF {
0000000000000000000000000000000000000000;;							s = append(s, byte(0xE0+(value>>12)))
0000000000000000000000000000000000000000;;							s = append(s, byte(0x80+((value>>6)&0x3F)))
0000000000000000000000000000000000000000;;							s = append(s, byte(0x80+(value&0x3F)))
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							s = append(s, byte(0xF0+(value>>18)))
0000000000000000000000000000000000000000;;							s = append(s, byte(0x80+((value>>12)&0x3F)))
0000000000000000000000000000000000000000;;							s = append(s, byte(0x80+((value>>6)&0x3F)))
0000000000000000000000000000000000000000;;							s = append(s, byte(0x80+(value&0x3F)))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// Advance the pointer.
0000000000000000000000000000000000000000;;						for k := 0; k < code_length; k++ {
0000000000000000000000000000000000000000;;							skip(parser)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// It is a non-escaped non-blank character.
0000000000000000000000000000000000000000;;					s = read(parser, s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check if we are at the end of the scalar.
0000000000000000000000000000000000000000;;			if single {
0000000000000000000000000000000000000000;;				if parser.buffer[parser.buffer_pos] == '\'' {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if parser.buffer[parser.buffer_pos] == '"' {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Consume blank characters.
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				if is_blank(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;					// Consume a space or a tab character.
0000000000000000000000000000000000000000;;					if !leading_blanks {
0000000000000000000000000000000000000000;;						whitespaces = read(parser, whitespaces)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						skip(parser)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check if it is a first line break.
0000000000000000000000000000000000000000;;					if !leading_blanks {
0000000000000000000000000000000000000000;;						whitespaces = whitespaces[:0]
0000000000000000000000000000000000000000;;						leading_break = read_line(parser, leading_break)
0000000000000000000000000000000000000000;;						leading_blanks = true
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						trailing_breaks = read_line(parser, trailing_breaks)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Join the whitespaces or fold line breaks.
0000000000000000000000000000000000000000;;			if leading_blanks {
0000000000000000000000000000000000000000;;				// Do we need to fold line breaks?
0000000000000000000000000000000000000000;;				if len(leading_break) > 0 && leading_break[0] == '\n' {
0000000000000000000000000000000000000000;;					if len(trailing_breaks) == 0 {
0000000000000000000000000000000000000000;;						s = append(s, ' ')
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						s = append(s, trailing_breaks...)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					s = append(s, leading_break...)
0000000000000000000000000000000000000000;;					s = append(s, trailing_breaks...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				trailing_breaks = trailing_breaks[:0]
0000000000000000000000000000000000000000;;				leading_break = leading_break[:0]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s = append(s, whitespaces...)
0000000000000000000000000000000000000000;;				whitespaces = whitespaces[:0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eat the right quote.
0000000000000000000000000000000000000000;;		skip(parser)
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a token.
0000000000000000000000000000000000000000;;		*token = yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        yaml_SCALAR_TOKEN,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;			value:      s,
0000000000000000000000000000000000000000;;			style:      yaml_SINGLE_QUOTED_SCALAR_STYLE,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !single {
0000000000000000000000000000000000000000;;			token.style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan a plain scalar.
0000000000000000000000000000000000000000;;	func yaml_parser_scan_plain_scalar(parser *yaml_parser_t, token *yaml_token_t) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var s, leading_break, trailing_breaks, whitespaces []byte
0000000000000000000000000000000000000000;;		var leading_blanks bool
0000000000000000000000000000000000000000;;		var indent = parser.indent + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start_mark := parser.mark
0000000000000000000000000000000000000000;;		end_mark := parser.mark
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the content of the plain scalar.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Check for a document indicator.
0000000000000000000000000000000000000000;;			if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parser.mark.column == 0 &&
0000000000000000000000000000000000000000;;				((parser.buffer[parser.buffer_pos+0] == '-' &&
0000000000000000000000000000000000000000;;					parser.buffer[parser.buffer_pos+1] == '-' &&
0000000000000000000000000000000000000000;;					parser.buffer[parser.buffer_pos+2] == '-') ||
0000000000000000000000000000000000000000;;					(parser.buffer[parser.buffer_pos+0] == '.' &&
0000000000000000000000000000000000000000;;						parser.buffer[parser.buffer_pos+1] == '.' &&
0000000000000000000000000000000000000000;;						parser.buffer[parser.buffer_pos+2] == '.')) &&
0000000000000000000000000000000000000000;;				is_blankz(parser.buffer, parser.buffer_pos+3) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for a comment.
0000000000000000000000000000000000000000;;			if parser.buffer[parser.buffer_pos] == '#' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Consume non-blank characters.
0000000000000000000000000000000000000000;;			for !is_blankz(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check for 'x:x' in the flow context. TODO: Fix the test "spec-08-13".
0000000000000000000000000000000000000000;;				if parser.flow_level > 0 &&
0000000000000000000000000000000000000000;;					parser.buffer[parser.buffer_pos] == ':' &&
0000000000000000000000000000000000000000;;					!is_blankz(parser.buffer, parser.buffer_pos+1) {
0000000000000000000000000000000000000000;;					yaml_parser_set_scanner_error(parser, "while scanning a plain scalar",
0000000000000000000000000000000000000000;;						start_mark, "found unexpected ':'")
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check for indicators that may end a plain scalar.
0000000000000000000000000000000000000000;;				if (parser.buffer[parser.buffer_pos] == ':' && is_blankz(parser.buffer, parser.buffer_pos+1)) ||
0000000000000000000000000000000000000000;;					(parser.flow_level > 0 &&
0000000000000000000000000000000000000000;;						(parser.buffer[parser.buffer_pos] == ',' || parser.buffer[parser.buffer_pos] == ':' ||
0000000000000000000000000000000000000000;;							parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == '[' ||
0000000000000000000000000000000000000000;;							parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '{' ||
0000000000000000000000000000000000000000;;							parser.buffer[parser.buffer_pos] == '}')) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check if we need to join whitespaces and breaks.
0000000000000000000000000000000000000000;;				if leading_blanks || len(whitespaces) > 0 {
0000000000000000000000000000000000000000;;					if leading_blanks {
0000000000000000000000000000000000000000;;						// Do we need to fold line breaks?
0000000000000000000000000000000000000000;;						if leading_break[0] == '\n' {
0000000000000000000000000000000000000000;;							if len(trailing_breaks) == 0 {
0000000000000000000000000000000000000000;;								s = append(s, ' ')
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								s = append(s, trailing_breaks...)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							s = append(s, leading_break...)
0000000000000000000000000000000000000000;;							s = append(s, trailing_breaks...)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						trailing_breaks = trailing_breaks[:0]
0000000000000000000000000000000000000000;;						leading_break = leading_break[:0]
0000000000000000000000000000000000000000;;						leading_blanks = false
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						s = append(s, whitespaces...)
0000000000000000000000000000000000000000;;						whitespaces = whitespaces[:0]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Copy the character.
0000000000000000000000000000000000000000;;				s = read(parser, s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				end_mark = parser.mark
0000000000000000000000000000000000000000;;				if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Is it the end?
0000000000000000000000000000000000000000;;			if !(is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos)) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Consume blank characters.
0000000000000000000000000000000000000000;;			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;				if is_blank(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check for tab character that abuse indentation.
0000000000000000000000000000000000000000;;					if leading_blanks && parser.mark.column < indent && is_tab(parser.buffer, parser.buffer_pos) {
0000000000000000000000000000000000000000;;						yaml_parser_set_scanner_error(parser, "while scanning a plain scalar",
0000000000000000000000000000000000000000;;							start_mark, "found a tab character that violate indentation")
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Consume a space or a tab character.
0000000000000000000000000000000000000000;;					if !leading_blanks {
0000000000000000000000000000000000000000;;						whitespaces = read(parser, whitespaces)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						skip(parser)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Check if it is a first line break.
0000000000000000000000000000000000000000;;					if !leading_blanks {
0000000000000000000000000000000000000000;;						whitespaces = whitespaces[:0]
0000000000000000000000000000000000000000;;						leading_break = read_line(parser, leading_break)
0000000000000000000000000000000000000000;;						leading_blanks = true
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						trailing_breaks = read_line(parser, trailing_breaks)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check indentation level.
0000000000000000000000000000000000000000;;			if parser.flow_level == 0 && parser.mark.column < indent {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a token.
0000000000000000000000000000000000000000;;		*token = yaml_token_t{
0000000000000000000000000000000000000000;;			typ:        yaml_SCALAR_TOKEN,
0000000000000000000000000000000000000000;;			start_mark: start_mark,
0000000000000000000000000000000000000000;;			end_mark:   end_mark,
0000000000000000000000000000000000000000;;			value:      s,
0000000000000000000000000000000000000000;;			style:      yaml_PLAIN_SCALAR_STYLE,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note that we change the 'simple_key_allowed' flag.
0000000000000000000000000000000000000000;;		if leading_blanks {
0000000000000000000000000000000000000000;;			parser.simple_key_allowed = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
