0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
050f3b901a990524b87ff3fe91d0929dfb078c81;Godeps/_workspace/src/code.google.com/p/gcfg/token/serialize.go[Godeps/_workspace/src/code.google.com/p/gcfg/token/serialize.go][vendor/gopkg.in/gcfg.v1/token/serialize.go];	
0000000000000000000000000000000000000000;;	package token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serializedFile struct {
0000000000000000000000000000000000000000;;		// fields correspond 1:1 to fields with same (lower-case) name in File
0000000000000000000000000000000000000000;;		Name  string
0000000000000000000000000000000000000000;;		Base  int
0000000000000000000000000000000000000000;;		Size  int
0000000000000000000000000000000000000000;;		Lines []int
0000000000000000000000000000000000000000;;		Infos []lineInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serializedFileSet struct {
0000000000000000000000000000000000000000;;		Base  int
0000000000000000000000000000000000000000;;		Files []serializedFile
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read calls decode to deserialize a file set into s; s must not be nil.
0000000000000000000000000000000000000000;;	func (s *FileSet) Read(decode func(interface{}) error) error {
0000000000000000000000000000000000000000;;		var ss serializedFileSet
0000000000000000000000000000000000000000;;		if err := decode(&ss); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.mutex.Lock()
0000000000000000000000000000000000000000;;		s.base = ss.Base
0000000000000000000000000000000000000000;;		files := make([]*File, len(ss.Files))
0000000000000000000000000000000000000000;;		for i := 0; i < len(ss.Files); i++ {
0000000000000000000000000000000000000000;;			f := &ss.Files[i]
0000000000000000000000000000000000000000;;			files[i] = &File{s, f.Name, f.Base, f.Size, f.Lines, f.Infos}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.files = files
0000000000000000000000000000000000000000;;		s.last = nil
0000000000000000000000000000000000000000;;		s.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write calls encode to serialize the file set s.
0000000000000000000000000000000000000000;;	func (s *FileSet) Write(encode func(interface{}) error) error {
0000000000000000000000000000000000000000;;		var ss serializedFileSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.mutex.Lock()
0000000000000000000000000000000000000000;;		ss.Base = s.base
0000000000000000000000000000000000000000;;		files := make([]serializedFile, len(s.files))
0000000000000000000000000000000000000000;;		for i, f := range s.files {
0000000000000000000000000000000000000000;;			files[i] = serializedFile{f.name, f.base, f.size, f.lines, f.infos}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss.Files = files
0000000000000000000000000000000000000000;;		s.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return encode(ss)
0000000000000000000000000000000000000000;;	}
