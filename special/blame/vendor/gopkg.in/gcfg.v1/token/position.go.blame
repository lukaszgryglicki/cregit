0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
050f3b901a990524b87ff3fe91d0929dfb078c81;Godeps/_workspace/src/code.google.com/p/gcfg/token/position.go[Godeps/_workspace/src/code.google.com/p/gcfg/token/position.go][vendor/gopkg.in/gcfg.v1/token/position.go];	
0000000000000000000000000000000000000000;;	// TODO(gri) consider making this a separate package outside the go directory.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Positions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Position describes an arbitrary source position
0000000000000000000000000000000000000000;;	// including the file, line, and column location.
0000000000000000000000000000000000000000;;	// A Position is valid if the line number is > 0.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Position struct {
0000000000000000000000000000000000000000;;		Filename string // filename, if any
0000000000000000000000000000000000000000;;		Offset   int    // offset, starting at 0
0000000000000000000000000000000000000000;;		Line     int    // line number, starting at 1
0000000000000000000000000000000000000000;;		Column   int    // column number, starting at 1 (character count)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid returns true if the position is valid.
0000000000000000000000000000000000000000;;	func (pos *Position) IsValid() bool { return pos.Line > 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string in one of several forms:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	file:line:column    valid position with file name
0000000000000000000000000000000000000000;;	//	line:column         valid position without file name
0000000000000000000000000000000000000000;;	//	file                invalid position with file name
0000000000000000000000000000000000000000;;	//	-                   invalid position without file name
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (pos Position) String() string {
0000000000000000000000000000000000000000;;		s := pos.Filename
0000000000000000000000000000000000000000;;		if pos.IsValid() {
0000000000000000000000000000000000000000;;			if s != "" {
0000000000000000000000000000000000000000;;				s += ":"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s += fmt.Sprintf("%d:%d", pos.Line, pos.Column)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			s = "-"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pos is a compact encoding of a source position within a file set.
0000000000000000000000000000000000000000;;	// It can be converted into a Position for a more convenient, but much
0000000000000000000000000000000000000000;;	// larger, representation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Pos value for a given file is a number in the range [base, base+size],
0000000000000000000000000000000000000000;;	// where base and size are specified when adding the file to the file set via
0000000000000000000000000000000000000000;;	// AddFile.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To create the Pos value for a specific source offset, first add
0000000000000000000000000000000000000000;;	// the respective file to the current file set (via FileSet.AddFile)
0000000000000000000000000000000000000000;;	// and then call File.Pos(offset) for that file. Given a Pos value p
0000000000000000000000000000000000000000;;	// for a specific file set fset, the corresponding Position value is
0000000000000000000000000000000000000000;;	// obtained by calling fset.Position(p).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Pos values can be compared directly with the usual comparison operators:
0000000000000000000000000000000000000000;;	// If two Pos values p and q are in the same file, comparing p and q is
0000000000000000000000000000000000000000;;	// equivalent to comparing the respective source file offsets. If p and q
0000000000000000000000000000000000000000;;	// are in different files, p < q is true if the file implied by p was added
0000000000000000000000000000000000000000;;	// to the respective file set before the file implied by q.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Pos int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The zero value for Pos is NoPos; there is no file and line information
0000000000000000000000000000000000000000;;	// associated with it, and NoPos().IsValid() is false. NoPos is always
0000000000000000000000000000000000000000;;	// smaller than any other Pos value. The corresponding Position value
0000000000000000000000000000000000000000;;	// for NoPos is the zero value for Position.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	const NoPos Pos = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid returns true if the position is valid.
0000000000000000000000000000000000000000;;	func (p Pos) IsValid() bool {
0000000000000000000000000000000000000000;;		return p != NoPos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// File
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A File is a handle for a file belonging to a FileSet.
0000000000000000000000000000000000000000;;	// A File has a name, size, and line offset table.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type File struct {
0000000000000000000000000000000000000000;;		set  *FileSet
0000000000000000000000000000000000000000;;		name string // file name as provided to AddFile
0000000000000000000000000000000000000000;;		base int    // Pos value range for this file is [base...base+size]
0000000000000000000000000000000000000000;;		size int    // file size as provided to AddFile
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lines and infos are protected by set.mutex
0000000000000000000000000000000000000000;;		lines []int
0000000000000000000000000000000000000000;;		infos []lineInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns the file name of file f as registered with AddFile.
0000000000000000000000000000000000000000;;	func (f *File) Name() string {
0000000000000000000000000000000000000000;;		return f.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Base returns the base offset of file f as registered with AddFile.
0000000000000000000000000000000000000000;;	func (f *File) Base() int {
0000000000000000000000000000000000000000;;		return f.base
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size returns the size of file f as registered with AddFile.
0000000000000000000000000000000000000000;;	func (f *File) Size() int {
0000000000000000000000000000000000000000;;		return f.size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LineCount returns the number of lines in file f.
0000000000000000000000000000000000000000;;	func (f *File) LineCount() int {
0000000000000000000000000000000000000000;;		f.set.mutex.RLock()
0000000000000000000000000000000000000000;;		n := len(f.lines)
0000000000000000000000000000000000000000;;		f.set.mutex.RUnlock()
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddLine adds the line offset for a new line.
0000000000000000000000000000000000000000;;	// The line offset must be larger than the offset for the previous line
0000000000000000000000000000000000000000;;	// and smaller than the file size; otherwise the line offset is ignored.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (f *File) AddLine(offset int) {
0000000000000000000000000000000000000000;;		f.set.mutex.Lock()
0000000000000000000000000000000000000000;;		if i := len(f.lines); (i == 0 || f.lines[i-1] < offset) && offset < f.size {
0000000000000000000000000000000000000000;;			f.lines = append(f.lines, offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.set.mutex.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetLines sets the line offsets for a file and returns true if successful.
0000000000000000000000000000000000000000;;	// The line offsets are the offsets of the first character of each line;
0000000000000000000000000000000000000000;;	// for instance for the content "ab\nc\n" the line offsets are {0, 3}.
0000000000000000000000000000000000000000;;	// An empty file has an empty line offset table.
0000000000000000000000000000000000000000;;	// Each line offset must be larger than the offset for the previous line
0000000000000000000000000000000000000000;;	// and smaller than the file size; otherwise SetLines fails and returns
0000000000000000000000000000000000000000;;	// false.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (f *File) SetLines(lines []int) bool {
0000000000000000000000000000000000000000;;		// verify validity of lines table
0000000000000000000000000000000000000000;;		size := f.size
0000000000000000000000000000000000000000;;		for i, offset := range lines {
0000000000000000000000000000000000000000;;			if i > 0 && offset <= lines[i-1] || size <= offset {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set lines table
0000000000000000000000000000000000000000;;		f.set.mutex.Lock()
0000000000000000000000000000000000000000;;		f.lines = lines
0000000000000000000000000000000000000000;;		f.set.mutex.Unlock()
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetLinesForContent sets the line offsets for the given file content.
0000000000000000000000000000000000000000;;	func (f *File) SetLinesForContent(content []byte) {
0000000000000000000000000000000000000000;;		var lines []int
0000000000000000000000000000000000000000;;		line := 0
0000000000000000000000000000000000000000;;		for offset, b := range content {
0000000000000000000000000000000000000000;;			if line >= 0 {
0000000000000000000000000000000000000000;;				lines = append(lines, line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line = -1
0000000000000000000000000000000000000000;;			if b == '\n' {
0000000000000000000000000000000000000000;;				line = offset + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set lines table
0000000000000000000000000000000000000000;;		f.set.mutex.Lock()
0000000000000000000000000000000000000000;;		f.lines = lines
0000000000000000000000000000000000000000;;		f.set.mutex.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A lineInfo object describes alternative file and line number
0000000000000000000000000000000000000000;;	// information (such as provided via a //line comment in a .go
0000000000000000000000000000000000000000;;	// file) for a given file offset.
0000000000000000000000000000000000000000;;	type lineInfo struct {
0000000000000000000000000000000000000000;;		// fields are exported to make them accessible to gob
0000000000000000000000000000000000000000;;		Offset   int
0000000000000000000000000000000000000000;;		Filename string
0000000000000000000000000000000000000000;;		Line     int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddLineInfo adds alternative file and line number information for
0000000000000000000000000000000000000000;;	// a given file offset. The offset must be larger than the offset for
0000000000000000000000000000000000000000;;	// the previously added alternative line info and smaller than the
0000000000000000000000000000000000000000;;	// file size; otherwise the information is ignored.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// AddLineInfo is typically used to register alternative position
0000000000000000000000000000000000000000;;	// information for //line filename:line comments in source files.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (f *File) AddLineInfo(offset int, filename string, line int) {
0000000000000000000000000000000000000000;;		f.set.mutex.Lock()
0000000000000000000000000000000000000000;;		if i := len(f.infos); i == 0 || f.infos[i-1].Offset < offset && offset < f.size {
0000000000000000000000000000000000000000;;			f.infos = append(f.infos, lineInfo{offset, filename, line})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.set.mutex.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pos returns the Pos value for the given file offset;
0000000000000000000000000000000000000000;;	// the offset must be <= f.Size().
0000000000000000000000000000000000000000;;	// f.Pos(f.Offset(p)) == p.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (f *File) Pos(offset int) Pos {
0000000000000000000000000000000000000000;;		if offset > f.size {
0000000000000000000000000000000000000000;;			panic("illegal file offset")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Pos(f.base + offset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Offset returns the offset for the given file position p;
0000000000000000000000000000000000000000;;	// p must be a valid Pos value in that file.
0000000000000000000000000000000000000000;;	// f.Offset(f.Pos(offset)) == offset.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (f *File) Offset(p Pos) int {
0000000000000000000000000000000000000000;;		if int(p) < f.base || int(p) > f.base+f.size {
0000000000000000000000000000000000000000;;			panic("illegal Pos value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(p) - f.base
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Line returns the line number for the given file position p;
0000000000000000000000000000000000000000;;	// p must be a Pos value in that file or NoPos.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (f *File) Line(p Pos) int {
0000000000000000000000000000000000000000;;		// TODO(gri) this can be implemented much more efficiently
0000000000000000000000000000000000000000;;		return f.Position(p).Line
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func searchLineInfos(a []lineInfo, x int) int {
0000000000000000000000000000000000000000;;		return sort.Search(len(a), func(i int) bool { return a[i].Offset > x }) - 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// info returns the file name, line, and column number for a file offset.
0000000000000000000000000000000000000000;;	func (f *File) info(offset int) (filename string, line, column int) {
0000000000000000000000000000000000000000;;		filename = f.name
0000000000000000000000000000000000000000;;		if i := searchInts(f.lines, offset); i >= 0 {
0000000000000000000000000000000000000000;;			line, column = i+1, offset-f.lines[i]+1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(f.infos) > 0 {
0000000000000000000000000000000000000000;;			// almost no files have extra line infos
0000000000000000000000000000000000000000;;			if i := searchLineInfos(f.infos, offset); i >= 0 {
0000000000000000000000000000000000000000;;				alt := &f.infos[i]
0000000000000000000000000000000000000000;;				filename = alt.Filename
0000000000000000000000000000000000000000;;				if i := searchInts(f.lines, alt.Offset); i >= 0 {
0000000000000000000000000000000000000000;;					line += alt.Line - i - 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) position(p Pos) (pos Position) {
0000000000000000000000000000000000000000;;		offset := int(p) - f.base
0000000000000000000000000000000000000000;;		pos.Offset = offset
0000000000000000000000000000000000000000;;		pos.Filename, pos.Line, pos.Column = f.info(offset)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Position returns the Position value for the given file position p;
0000000000000000000000000000000000000000;;	// p must be a Pos value in that file or NoPos.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (f *File) Position(p Pos) (pos Position) {
0000000000000000000000000000000000000000;;		if p != NoPos {
0000000000000000000000000000000000000000;;			if int(p) < f.base || int(p) > f.base+f.size {
0000000000000000000000000000000000000000;;				panic("illegal Pos value")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pos = f.position(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// FileSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A FileSet represents a set of source files.
0000000000000000000000000000000000000000;;	// Methods of file sets are synchronized; multiple goroutines
0000000000000000000000000000000000000000;;	// may invoke them concurrently.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type FileSet struct {
0000000000000000000000000000000000000000;;		mutex sync.RWMutex // protects the file set
0000000000000000000000000000000000000000;;		base  int          // base offset for the next file
0000000000000000000000000000000000000000;;		files []*File      // list of files in the order added to the set
0000000000000000000000000000000000000000;;		last  *File        // cache of last file looked up
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFileSet creates a new file set.
0000000000000000000000000000000000000000;;	func NewFileSet() *FileSet {
0000000000000000000000000000000000000000;;		s := new(FileSet)
0000000000000000000000000000000000000000;;		s.base = 1 // 0 == NoPos
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Base returns the minimum base offset that must be provided to
0000000000000000000000000000000000000000;;	// AddFile when adding the next file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *FileSet) Base() int {
0000000000000000000000000000000000000000;;		s.mutex.RLock()
0000000000000000000000000000000000000000;;		b := s.base
0000000000000000000000000000000000000000;;		s.mutex.RUnlock()
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFile adds a new file with a given filename, base offset, and file size
0000000000000000000000000000000000000000;;	// to the file set s and returns the file. Multiple files may have the same
0000000000000000000000000000000000000000;;	// name. The base offset must not be smaller than the FileSet's Base(), and
0000000000000000000000000000000000000000;;	// size must not be negative.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Adding the file will set the file set's Base() value to base + size + 1
0000000000000000000000000000000000000000;;	// as the minimum base value for the next file. The following relationship
0000000000000000000000000000000000000000;;	// exists between a Pos value p for a given file offset offs:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	int(p) = base + offs
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// with offs in the range [0, size] and thus p in the range [base, base+size].
0000000000000000000000000000000000000000;;	// For convenience, File.Pos may be used to create file-specific position
0000000000000000000000000000000000000000;;	// values from a file offset.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *FileSet) AddFile(filename string, base, size int) *File {
0000000000000000000000000000000000000000;;		s.mutex.Lock()
0000000000000000000000000000000000000000;;		defer s.mutex.Unlock()
0000000000000000000000000000000000000000;;		if base < s.base || size < 0 {
0000000000000000000000000000000000000000;;			panic("illegal base or size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// base >= s.base && size >= 0
0000000000000000000000000000000000000000;;		f := &File{s, filename, base, size, []int{0}, nil}
0000000000000000000000000000000000000000;;		base += size + 1 // +1 because EOF also has a position
0000000000000000000000000000000000000000;;		if base < 0 {
0000000000000000000000000000000000000000;;			panic("token.Pos offset overflow (> 2G of source code in file set)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// add the file to the file set
0000000000000000000000000000000000000000;;		s.base = base
0000000000000000000000000000000000000000;;		s.files = append(s.files, f)
0000000000000000000000000000000000000000;;		s.last = f
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Iterate calls f for the files in the file set in the order they were added
0000000000000000000000000000000000000000;;	// until f returns false.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *FileSet) Iterate(f func(*File) bool) {
0000000000000000000000000000000000000000;;		for i := 0; ; i++ {
0000000000000000000000000000000000000000;;			var file *File
0000000000000000000000000000000000000000;;			s.mutex.RLock()
0000000000000000000000000000000000000000;;			if i < len(s.files) {
0000000000000000000000000000000000000000;;				file = s.files[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.mutex.RUnlock()
0000000000000000000000000000000000000000;;			if file == nil || !f(file) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func searchFiles(a []*File, x int) int {
0000000000000000000000000000000000000000;;		return sort.Search(len(a), func(i int) bool { return a[i].base > x }) - 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *FileSet) file(p Pos) *File {
0000000000000000000000000000000000000000;;		// common case: p is in last file
0000000000000000000000000000000000000000;;		if f := s.last; f != nil && f.base <= int(p) && int(p) <= f.base+f.size {
0000000000000000000000000000000000000000;;			return f
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// p is not in last file - search all files
0000000000000000000000000000000000000000;;		if i := searchFiles(s.files, int(p)); i >= 0 {
0000000000000000000000000000000000000000;;			f := s.files[i]
0000000000000000000000000000000000000000;;			// f.base <= int(p) by definition of searchFiles
0000000000000000000000000000000000000000;;			if int(p) <= f.base+f.size {
0000000000000000000000000000000000000000;;				s.last = f
0000000000000000000000000000000000000000;;				return f
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// File returns the file that contains the position p.
0000000000000000000000000000000000000000;;	// If no such file is found (for instance for p == NoPos),
0000000000000000000000000000000000000000;;	// the result is nil.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *FileSet) File(p Pos) (f *File) {
0000000000000000000000000000000000000000;;		if p != NoPos {
0000000000000000000000000000000000000000;;			s.mutex.RLock()
0000000000000000000000000000000000000000;;			f = s.file(p)
0000000000000000000000000000000000000000;;			s.mutex.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Position converts a Pos in the fileset into a general Position.
0000000000000000000000000000000000000000;;	func (s *FileSet) Position(p Pos) (pos Position) {
0000000000000000000000000000000000000000;;		if p != NoPos {
0000000000000000000000000000000000000000;;			s.mutex.RLock()
0000000000000000000000000000000000000000;;			if f := s.file(p); f != nil {
0000000000000000000000000000000000000000;;				pos = f.position(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.mutex.RUnlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Helper functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func searchInts(a []int, x int) int {
0000000000000000000000000000000000000000;;		// This function body is a manually inlined version of:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//   return sort.Search(len(a), func(i int) bool { return a[i] > x }) - 1
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// With better compiler optimizations, this may not be needed in the
0000000000000000000000000000000000000000;;		// future, but at the moment this change improves the go/printer
0000000000000000000000000000000000000000;;		// benchmark performance by ~30%. This has a direct impact on the
0000000000000000000000000000000000000000;;		// speed of gofmt and thus seems worthwhile (2011-04-29).
0000000000000000000000000000000000000000;;		// TODO(gri): Remove this when compilers have caught up.
0000000000000000000000000000000000000000;;		i, j := 0, len(a)
0000000000000000000000000000000000000000;;		for i < j {
0000000000000000000000000000000000000000;;			h := i + (j-i)/2 // avoid overflow when computing h
0000000000000000000000000000000000000000;;			// i ≤ h < j
0000000000000000000000000000000000000000;;			if a[h] <= x {
0000000000000000000000000000000000000000;;				i = h + 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				j = h
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i - 1
0000000000000000000000000000000000000000;;	}
