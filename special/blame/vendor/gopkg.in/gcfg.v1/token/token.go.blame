0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
050f3b901a990524b87ff3fe91d0929dfb078c81;Godeps/_workspace/src/code.google.com/p/gcfg/token/token.go[Godeps/_workspace/src/code.google.com/p/gcfg/token/token.go][vendor/gopkg.in/gcfg.v1/token/token.go];	
0000000000000000000000000000000000000000;;	// Package token defines constants representing the lexical tokens of the gcfg
0000000000000000000000000000000000000000;;	// configuration syntax and basic operations on tokens (printing, predicates).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that the API for the token package may change to accommodate new
0000000000000000000000000000000000000000;;	// features or implementation changes in gcfg.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token is the set of lexical tokens of the gcfg configuration syntax.
0000000000000000000000000000000000000000;;	type Token int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The list of tokens.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Special tokens
0000000000000000000000000000000000000000;;		ILLEGAL Token = iota
0000000000000000000000000000000000000000;;		EOF
0000000000000000000000000000000000000000;;		COMMENT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		literal_beg
0000000000000000000000000000000000000000;;		// Identifiers and basic type literals
0000000000000000000000000000000000000000;;		// (these tokens stand for classes of literals)
0000000000000000000000000000000000000000;;		IDENT  // section-name, variable-name
0000000000000000000000000000000000000000;;		STRING // "subsection-name", variable value
0000000000000000000000000000000000000000;;		literal_end
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operator_beg
0000000000000000000000000000000000000000;;		// Operators and delimiters
0000000000000000000000000000000000000000;;		ASSIGN // =
0000000000000000000000000000000000000000;;		LBRACK // [
0000000000000000000000000000000000000000;;		RBRACK // ]
0000000000000000000000000000000000000000;;		EOL    // \n
0000000000000000000000000000000000000000;;		operator_end
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var tokens = [...]string{
0000000000000000000000000000000000000000;;		ILLEGAL: "ILLEGAL",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		EOF:     "EOF",
0000000000000000000000000000000000000000;;		COMMENT: "COMMENT",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		IDENT:  "IDENT",
0000000000000000000000000000000000000000;;		STRING: "STRING",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ASSIGN: "=",
0000000000000000000000000000000000000000;;		LBRACK: "[",
0000000000000000000000000000000000000000;;		RBRACK: "]",
0000000000000000000000000000000000000000;;		EOL:    "\n",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string corresponding to the token tok.
0000000000000000000000000000000000000000;;	// For operators and delimiters, the string is the actual token character
0000000000000000000000000000000000000000;;	// sequence (e.g., for the token ASSIGN, the string is "="). For all other
0000000000000000000000000000000000000000;;	// tokens the string corresponds to the token constant name (e.g. for the
0000000000000000000000000000000000000000;;	// token IDENT, the string is "IDENT").
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (tok Token) String() string {
0000000000000000000000000000000000000000;;		s := ""
0000000000000000000000000000000000000000;;		if 0 <= tok && tok < Token(len(tokens)) {
0000000000000000000000000000000000000000;;			s = tokens[tok]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			s = "token(" + strconv.Itoa(int(tok)) + ")"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Predicates
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsLiteral returns true for tokens corresponding to identifiers
0000000000000000000000000000000000000000;;	// and basic type literals; it returns false otherwise.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (tok Token) IsLiteral() bool { return literal_beg < tok && tok < literal_end }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsOperator returns true for tokens corresponding to operators and
0000000000000000000000000000000000000000;;	// delimiters; it returns false otherwise.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (tok Token) IsOperator() bool { return operator_beg < tok && tok < operator_end }
