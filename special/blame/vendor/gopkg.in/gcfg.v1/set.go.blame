0000000000000000000000000000000000000000;;	package gcfg
050f3b901a990524b87ff3fe91d0929dfb078c81;Godeps/_workspace/src/code.google.com/p/gcfg/set.go[Godeps/_workspace/src/code.google.com/p/gcfg/set.go][vendor/gopkg.in/gcfg.v1/set.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tag struct {
0000000000000000000000000000000000000000;;		ident   string
0000000000000000000000000000000000000000;;		intMode string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTag(ts string) tag {
0000000000000000000000000000000000000000;;		t := tag{}
0000000000000000000000000000000000000000;;		s := strings.Split(ts, ",")
0000000000000000000000000000000000000000;;		t.ident = s[0]
0000000000000000000000000000000000000000;;		for _, tse := range s[1:] {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(tse, "int=") {
0000000000000000000000000000000000000000;;				t.intMode = tse[len("int="):]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fieldFold(v reflect.Value, name string) (reflect.Value, tag) {
0000000000000000000000000000000000000000;;		var n string
0000000000000000000000000000000000000000;;		r0, _ := utf8.DecodeRuneInString(name)
0000000000000000000000000000000000000000;;		if unicode.IsLetter(r0) && !unicode.IsLower(r0) && !unicode.IsUpper(r0) {
0000000000000000000000000000000000000000;;			n = "X"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n += strings.Replace(name, "-", "_", -1)
0000000000000000000000000000000000000000;;		f, ok := v.Type().FieldByNameFunc(func(fieldName string) bool {
0000000000000000000000000000000000000000;;			if !v.FieldByName(fieldName).CanSet() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f, _ := v.Type().FieldByName(fieldName)
0000000000000000000000000000000000000000;;			t := newTag(f.Tag.Get("gcfg"))
0000000000000000000000000000000000000000;;			if t.ident != "" {
0000000000000000000000000000000000000000;;				return strings.EqualFold(t.ident, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return strings.EqualFold(n, fieldName)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return reflect.Value{}, tag{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.FieldByName(f.Name), newTag(f.Tag.Get("gcfg"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type setter func(destp interface{}, blank bool, val string, t tag) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errUnsupportedType = fmt.Errorf("unsupported type")
0000000000000000000000000000000000000000;;	var errBlankUnsupported = fmt.Errorf("blank value not supported for type")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var setters = []setter{
0000000000000000000000000000000000000000;;		typeSetter, textUnmarshalerSetter, kindSetter, scanSetter,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func textUnmarshalerSetter(d interface{}, blank bool, val string, t tag) error {
0000000000000000000000000000000000000000;;		dtu, ok := d.(textUnmarshaler)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errUnsupportedType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if blank {
0000000000000000000000000000000000000000;;			return errBlankUnsupported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dtu.UnmarshalText([]byte(val))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func boolSetter(d interface{}, blank bool, val string, t tag) error {
0000000000000000000000000000000000000000;;		if blank {
0000000000000000000000000000000000000000;;			reflect.ValueOf(d).Elem().Set(reflect.ValueOf(true))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := types.ParseBool(val)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			reflect.ValueOf(d).Elem().Set(reflect.ValueOf(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func intMode(mode string) types.IntMode {
0000000000000000000000000000000000000000;;		var m types.IntMode
0000000000000000000000000000000000000000;;		if strings.ContainsAny(mode, "dD") {
0000000000000000000000000000000000000000;;			m |= types.Dec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.ContainsAny(mode, "hH") {
0000000000000000000000000000000000000000;;			m |= types.Hex
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.ContainsAny(mode, "oO") {
0000000000000000000000000000000000000000;;			m |= types.Oct
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeModes = map[reflect.Type]types.IntMode{
0000000000000000000000000000000000000000;;		reflect.TypeOf(int(0)):    types.Dec | types.Hex,
0000000000000000000000000000000000000000;;		reflect.TypeOf(int8(0)):   types.Dec | types.Hex,
0000000000000000000000000000000000000000;;		reflect.TypeOf(int16(0)):  types.Dec | types.Hex,
0000000000000000000000000000000000000000;;		reflect.TypeOf(int32(0)):  types.Dec | types.Hex,
0000000000000000000000000000000000000000;;		reflect.TypeOf(int64(0)):  types.Dec | types.Hex,
0000000000000000000000000000000000000000;;		reflect.TypeOf(uint(0)):   types.Dec | types.Hex,
0000000000000000000000000000000000000000;;		reflect.TypeOf(uint8(0)):  types.Dec | types.Hex,
0000000000000000000000000000000000000000;;		reflect.TypeOf(uint16(0)): types.Dec | types.Hex,
0000000000000000000000000000000000000000;;		reflect.TypeOf(uint32(0)): types.Dec | types.Hex,
0000000000000000000000000000000000000000;;		reflect.TypeOf(uint64(0)): types.Dec | types.Hex,
0000000000000000000000000000000000000000;;		// use default mode (allow dec/hex/oct) for uintptr type
0000000000000000000000000000000000000000;;		reflect.TypeOf(big.Int{}): types.Dec | types.Hex,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func intModeDefault(t reflect.Type) types.IntMode {
0000000000000000000000000000000000000000;;		m, ok := typeModes[t]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			m = types.Dec | types.Hex | types.Oct
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func intSetter(d interface{}, blank bool, val string, t tag) error {
0000000000000000000000000000000000000000;;		if blank {
0000000000000000000000000000000000000000;;			return errBlankUnsupported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mode := intMode(t.intMode)
0000000000000000000000000000000000000000;;		if mode == 0 {
0000000000000000000000000000000000000000;;			mode = intModeDefault(reflect.TypeOf(d).Elem())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return types.ParseInt(d, val, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stringSetter(d interface{}, blank bool, val string, t tag) error {
0000000000000000000000000000000000000000;;		if blank {
0000000000000000000000000000000000000000;;			return errBlankUnsupported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dsp, ok := d.(*string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errUnsupportedType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*dsp = val
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var kindSetters = map[reflect.Kind]setter{
0000000000000000000000000000000000000000;;		reflect.String:  stringSetter,
0000000000000000000000000000000000000000;;		reflect.Bool:    boolSetter,
0000000000000000000000000000000000000000;;		reflect.Int:     intSetter,
0000000000000000000000000000000000000000;;		reflect.Int8:    intSetter,
0000000000000000000000000000000000000000;;		reflect.Int16:   intSetter,
0000000000000000000000000000000000000000;;		reflect.Int32:   intSetter,
0000000000000000000000000000000000000000;;		reflect.Int64:   intSetter,
0000000000000000000000000000000000000000;;		reflect.Uint:    intSetter,
0000000000000000000000000000000000000000;;		reflect.Uint8:   intSetter,
0000000000000000000000000000000000000000;;		reflect.Uint16:  intSetter,
0000000000000000000000000000000000000000;;		reflect.Uint32:  intSetter,
0000000000000000000000000000000000000000;;		reflect.Uint64:  intSetter,
0000000000000000000000000000000000000000;;		reflect.Uintptr: intSetter,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeSetters = map[reflect.Type]setter{
0000000000000000000000000000000000000000;;		reflect.TypeOf(big.Int{}): intSetter,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func typeSetter(d interface{}, blank bool, val string, tt tag) error {
0000000000000000000000000000000000000000;;		t := reflect.ValueOf(d).Type().Elem()
0000000000000000000000000000000000000000;;		setter, ok := typeSetters[t]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errUnsupportedType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return setter(d, blank, val, tt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func kindSetter(d interface{}, blank bool, val string, tt tag) error {
0000000000000000000000000000000000000000;;		k := reflect.ValueOf(d).Type().Elem().Kind()
0000000000000000000000000000000000000000;;		setter, ok := kindSetters[k]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errUnsupportedType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return setter(d, blank, val, tt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scanSetter(d interface{}, blank bool, val string, tt tag) error {
0000000000000000000000000000000000000000;;		if blank {
0000000000000000000000000000000000000000;;			return errBlankUnsupported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return types.ScanFully(d, val, 'v')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func set(cfg interface{}, sect, sub, name string, blank bool, value string) error {
0000000000000000000000000000000000000000;;		vPCfg := reflect.ValueOf(cfg)
0000000000000000000000000000000000000000;;		if vPCfg.Kind() != reflect.Ptr || vPCfg.Elem().Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("config must be a pointer to a struct"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vCfg := vPCfg.Elem()
0000000000000000000000000000000000000000;;		vSect, _ := fieldFold(vCfg, sect)
0000000000000000000000000000000000000000;;		if !vSect.IsValid() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid section: section %q", sect)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vSect.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;			vst := vSect.Type()
0000000000000000000000000000000000000000;;			if vst.Key().Kind() != reflect.String ||
0000000000000000000000000000000000000000;;				vst.Elem().Kind() != reflect.Ptr ||
0000000000000000000000000000000000000000;;				vst.Elem().Elem().Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;				panic(fmt.Errorf("map field for section must have string keys and "+
0000000000000000000000000000000000000000;;					" pointer-to-struct values: section %q", sect))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if vSect.IsNil() {
0000000000000000000000000000000000000000;;				vSect.Set(reflect.MakeMap(vst))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			k := reflect.ValueOf(sub)
0000000000000000000000000000000000000000;;			pv := vSect.MapIndex(k)
0000000000000000000000000000000000000000;;			if !pv.IsValid() {
0000000000000000000000000000000000000000;;				vType := vSect.Type().Elem().Elem()
0000000000000000000000000000000000000000;;				pv = reflect.New(vType)
0000000000000000000000000000000000000000;;				vSect.SetMapIndex(k, pv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vSect = pv.Elem()
0000000000000000000000000000000000000000;;		} else if vSect.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("field for section must be a map or a struct: "+
0000000000000000000000000000000000000000;;				"section %q", sect))
0000000000000000000000000000000000000000;;		} else if sub != "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid subsection: "+
0000000000000000000000000000000000000000;;				"section %q subsection %q", sect, sub)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Empty name is a special value, meaning that only the
0000000000000000000000000000000000000000;;		// section/subsection object is to be created, with no values set.
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vVar, t := fieldFold(vSect, name)
0000000000000000000000000000000000000000;;		if !vVar.IsValid() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid variable: "+
0000000000000000000000000000000000000000;;				"section %q subsection %q variable %q", sect, sub, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// vVal is either single-valued var, or newly allocated value within multi-valued var
0000000000000000000000000000000000000000;;		var vVal reflect.Value
0000000000000000000000000000000000000000;;		// multi-value if unnamed slice type
0000000000000000000000000000000000000000;;		isMulti := vVar.Type().Name() == "" && vVar.Kind() == reflect.Slice ||
0000000000000000000000000000000000000000;;			vVar.Type().Name() == "" && vVar.Kind() == reflect.Ptr && vVar.Type().Elem().Name() == "" && vVar.Type().Elem().Kind() == reflect.Slice
0000000000000000000000000000000000000000;;		if isMulti && vVar.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if vVar.IsNil() {
0000000000000000000000000000000000000000;;				vVar.Set(reflect.New(vVar.Type().Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vVar = vVar.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isMulti && blank {
0000000000000000000000000000000000000000;;			vVar.Set(reflect.Zero(vVar.Type()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isMulti {
0000000000000000000000000000000000000000;;			vVal = reflect.New(vVar.Type().Elem()).Elem()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			vVal = vVar
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		isDeref := vVal.Type().Name() == "" && vVal.Type().Kind() == reflect.Ptr
0000000000000000000000000000000000000000;;		isNew := isDeref && vVal.IsNil()
0000000000000000000000000000000000000000;;		// vAddr is address of value to set (dereferenced & allocated as needed)
0000000000000000000000000000000000000000;;		var vAddr reflect.Value
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case isNew:
0000000000000000000000000000000000000000;;			vAddr = reflect.New(vVal.Type().Elem())
0000000000000000000000000000000000000000;;		case isDeref && !isNew:
0000000000000000000000000000000000000000;;			vAddr = vVal
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			vAddr = vVal.Addr()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vAddrI := vAddr.Interface()
0000000000000000000000000000000000000000;;		err, ok := error(nil), false
0000000000000000000000000000000000000000;;		for _, s := range setters {
0000000000000000000000000000000000000000;;			err = s(vAddrI, blank, value, t)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				ok = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != errUnsupportedType {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// in case all setters returned errUnsupportedType
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isNew { // set reference if it was dereferenced and newly allocated
0000000000000000000000000000000000000000;;			vVal.Set(vAddr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isMulti { // append if multi-valued
0000000000000000000000000000000000000000;;			vVar.Set(reflect.Append(vVar, vVal))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
