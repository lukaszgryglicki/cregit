0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
050f3b901a990524b87ff3fe91d0929dfb078c81;Godeps/_workspace/src/code.google.com/p/gcfg/scanner/scanner.go[Godeps/_workspace/src/code.google.com/p/gcfg/scanner/scanner.go][vendor/gopkg.in/gcfg.v1/scanner/scanner.go];	
0000000000000000000000000000000000000000;;	// Package scanner implements a scanner for gcfg configuration text.
0000000000000000000000000000000000000000;;	// It takes a []byte as source which can then be tokenized
0000000000000000000000000000000000000000;;	// through repeated calls to the Scan method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that the API for the scanner package may change to accommodate new
0000000000000000000000000000000000000000;;	// features or implementation changes in gcfg.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package scanner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1/token"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An ErrorHandler may be provided to Scanner.Init. If a syntax error is
0000000000000000000000000000000000000000;;	// encountered and a handler was installed, the handler is called with a
0000000000000000000000000000000000000000;;	// position and an error message. The position points to the beginning of
0000000000000000000000000000000000000000;;	// the offending token.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type ErrorHandler func(pos token.Position, msg string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Scanner holds the scanner's internal state while processing
0000000000000000000000000000000000000000;;	// a given text.  It can be allocated as part of another data
0000000000000000000000000000000000000000;;	// structure but must be initialized via Init before use.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Scanner struct {
0000000000000000000000000000000000000000;;		// immutable state
0000000000000000000000000000000000000000;;		file *token.File  // source file handle
0000000000000000000000000000000000000000;;		dir  string       // directory portion of file.Name()
0000000000000000000000000000000000000000;;		src  []byte       // source
0000000000000000000000000000000000000000;;		err  ErrorHandler // error reporting; or nil
0000000000000000000000000000000000000000;;		mode Mode         // scanning mode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// scanning state
0000000000000000000000000000000000000000;;		ch         rune // current character
0000000000000000000000000000000000000000;;		offset     int  // character offset
0000000000000000000000000000000000000000;;		rdOffset   int  // reading offset (position after current character)
0000000000000000000000000000000000000000;;		lineOffset int  // current line offset
0000000000000000000000000000000000000000;;		nextVal    bool // next token is expected to be a value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// public state - ok to modify
0000000000000000000000000000000000000000;;		ErrorCount int // number of errors encountered
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read the next Unicode char into s.ch.
0000000000000000000000000000000000000000;;	// s.ch < 0 means end-of-file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *Scanner) next() {
0000000000000000000000000000000000000000;;		if s.rdOffset < len(s.src) {
0000000000000000000000000000000000000000;;			s.offset = s.rdOffset
0000000000000000000000000000000000000000;;			if s.ch == '\n' {
0000000000000000000000000000000000000000;;				s.lineOffset = s.offset
0000000000000000000000000000000000000000;;				s.file.AddLine(s.offset)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r, w := rune(s.src[s.rdOffset]), 1
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case r == 0:
0000000000000000000000000000000000000000;;				s.error(s.offset, "illegal character NUL")
0000000000000000000000000000000000000000;;			case r >= 0x80:
0000000000000000000000000000000000000000;;				// not ASCII
0000000000000000000000000000000000000000;;				r, w = utf8.DecodeRune(s.src[s.rdOffset:])
0000000000000000000000000000000000000000;;				if r == utf8.RuneError && w == 1 {
0000000000000000000000000000000000000000;;					s.error(s.offset, "illegal UTF-8 encoding")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.rdOffset += w
0000000000000000000000000000000000000000;;			s.ch = r
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.offset = len(s.src)
0000000000000000000000000000000000000000;;			if s.ch == '\n' {
0000000000000000000000000000000000000000;;				s.lineOffset = s.offset
0000000000000000000000000000000000000000;;				s.file.AddLine(s.offset)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.ch = -1 // eof
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A mode value is a set of flags (or 0).
0000000000000000000000000000000000000000;;	// They control scanner behavior.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Mode uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ScanComments Mode = 1 << iota // return comments as COMMENT tokens
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init prepares the scanner s to tokenize the text src by setting the
0000000000000000000000000000000000000000;;	// scanner at the beginning of src. The scanner uses the file set file
0000000000000000000000000000000000000000;;	// for position information and it adds line information for each line.
0000000000000000000000000000000000000000;;	// It is ok to re-use the same file when re-scanning the same file as
0000000000000000000000000000000000000000;;	// line information which is already present is ignored. Init causes a
0000000000000000000000000000000000000000;;	// panic if the file size does not match the src size.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Calls to Scan will invoke the error handler err if they encounter a
0000000000000000000000000000000000000000;;	// syntax error and err is not nil. Also, for each error encountered,
0000000000000000000000000000000000000000;;	// the Scanner field ErrorCount is incremented by one. The mode parameter
0000000000000000000000000000000000000000;;	// determines how comments are handled.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that Init may call err if there is an error in the first character
0000000000000000000000000000000000000000;;	// of the file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode Mode) {
0000000000000000000000000000000000000000;;		// Explicitly initialize all fields since a scanner may be reused.
0000000000000000000000000000000000000000;;		if file.Size() != len(src) {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("file size (%d) does not match src len (%d)", file.Size(), len(src)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.file = file
0000000000000000000000000000000000000000;;		s.dir, _ = filepath.Split(file.Name())
0000000000000000000000000000000000000000;;		s.src = src
0000000000000000000000000000000000000000;;		s.err = err
0000000000000000000000000000000000000000;;		s.mode = mode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.ch = ' '
0000000000000000000000000000000000000000;;		s.offset = 0
0000000000000000000000000000000000000000;;		s.rdOffset = 0
0000000000000000000000000000000000000000;;		s.lineOffset = 0
0000000000000000000000000000000000000000;;		s.ErrorCount = 0
0000000000000000000000000000000000000000;;		s.nextVal = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.next()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Scanner) error(offs int, msg string) {
0000000000000000000000000000000000000000;;		if s.err != nil {
0000000000000000000000000000000000000000;;			s.err(s.file.Position(s.file.Pos(offs)), msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.ErrorCount++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Scanner) scanComment() string {
0000000000000000000000000000000000000000;;		// initial [;#] already consumed
0000000000000000000000000000000000000000;;		offs := s.offset - 1 // position of initial [;#]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.ch != '\n' && s.ch >= 0 {
0000000000000000000000000000000000000000;;			s.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(s.src[offs:s.offset])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isLetter(ch rune) bool {
0000000000000000000000000000000000000000;;		return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch >= 0x80 && unicode.IsLetter(ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isDigit(ch rune) bool {
0000000000000000000000000000000000000000;;		return '0' <= ch && ch <= '9' || ch >= 0x80 && unicode.IsDigit(ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Scanner) scanIdentifier() string {
0000000000000000000000000000000000000000;;		offs := s.offset
0000000000000000000000000000000000000000;;		for isLetter(s.ch) || isDigit(s.ch) || s.ch == '-' {
0000000000000000000000000000000000000000;;			s.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(s.src[offs:s.offset])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Scanner) scanEscape(val bool) {
0000000000000000000000000000000000000000;;		offs := s.offset
0000000000000000000000000000000000000000;;		ch := s.ch
0000000000000000000000000000000000000000;;		s.next() // always make progress
0000000000000000000000000000000000000000;;		switch ch {
0000000000000000000000000000000000000000;;		case '\\', '"':
0000000000000000000000000000000000000000;;			// ok
0000000000000000000000000000000000000000;;		case 'n', 't':
0000000000000000000000000000000000000000;;			if val {
0000000000000000000000000000000000000000;;				break // ok
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			s.error(offs, "unknown escape sequence")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Scanner) scanString() string {
0000000000000000000000000000000000000000;;		// '"' opening already consumed
0000000000000000000000000000000000000000;;		offs := s.offset - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.ch != '"' {
0000000000000000000000000000000000000000;;			ch := s.ch
0000000000000000000000000000000000000000;;			s.next()
0000000000000000000000000000000000000000;;			if ch == '\n' || ch < 0 {
0000000000000000000000000000000000000000;;				s.error(offs, "string not terminated")
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ch == '\\' {
0000000000000000000000000000000000000000;;				s.scanEscape(false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.next()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(s.src[offs:s.offset])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stripCR(b []byte) []byte {
0000000000000000000000000000000000000000;;		c := make([]byte, len(b))
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for _, ch := range b {
0000000000000000000000000000000000000000;;			if ch != '\r' {
0000000000000000000000000000000000000000;;				c[i] = ch
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c[:i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Scanner) scanValString() string {
0000000000000000000000000000000000000000;;		offs := s.offset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasCR := false
0000000000000000000000000000000000000000;;		end := offs
0000000000000000000000000000000000000000;;		inQuote := false
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for inQuote || s.ch >= 0 && s.ch != '\n' && s.ch != ';' && s.ch != '#' {
0000000000000000000000000000000000000000;;			ch := s.ch
0000000000000000000000000000000000000000;;			s.next()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case inQuote && ch == '\\':
0000000000000000000000000000000000000000;;				s.scanEscape(true)
0000000000000000000000000000000000000000;;			case !inQuote && ch == '\\':
0000000000000000000000000000000000000000;;				if s.ch == '\r' {
0000000000000000000000000000000000000000;;					hasCR = true
0000000000000000000000000000000000000000;;					s.next()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if s.ch != '\n' {
0000000000000000000000000000000000000000;;					s.error(offs, "unquoted '\\' must be followed by new line")
0000000000000000000000000000000000000000;;					break loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s.next()
0000000000000000000000000000000000000000;;			case ch == '"':
0000000000000000000000000000000000000000;;				inQuote = !inQuote
0000000000000000000000000000000000000000;;			case ch == '\r':
0000000000000000000000000000000000000000;;				hasCR = true
0000000000000000000000000000000000000000;;			case ch < 0 || inQuote && ch == '\n':
0000000000000000000000000000000000000000;;				s.error(offs, "string not terminated")
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if inQuote || !isWhiteSpace(ch) {
0000000000000000000000000000000000000000;;				end = s.offset
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lit := s.src[offs:end]
0000000000000000000000000000000000000000;;		if hasCR {
0000000000000000000000000000000000000000;;			lit = stripCR(lit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(lit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isWhiteSpace(ch rune) bool {
0000000000000000000000000000000000000000;;		return ch == ' ' || ch == '\t' || ch == '\r'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Scanner) skipWhitespace() {
0000000000000000000000000000000000000000;;		for isWhiteSpace(s.ch) {
0000000000000000000000000000000000000000;;			s.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan scans the next token and returns the token position, the token,
0000000000000000000000000000000000000000;;	// and its literal string if applicable. The source end is indicated by
0000000000000000000000000000000000000000;;	// token.EOF.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the returned token is a literal (token.IDENT, token.STRING) or
0000000000000000000000000000000000000000;;	// token.COMMENT, the literal string has the corresponding value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the returned token is token.ILLEGAL, the literal string is the
0000000000000000000000000000000000000000;;	// offending character.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In all other cases, Scan returns an empty literal string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more tolerant parsing, Scan will return a valid token if
0000000000000000000000000000000000000000;;	// possible even if a syntax error was encountered. Thus, even
0000000000000000000000000000000000000000;;	// if the resulting token sequence contains no illegal tokens,
0000000000000000000000000000000000000000;;	// a client may not assume that no error occurred. Instead it
0000000000000000000000000000000000000000;;	// must check the scanner's ErrorCount or the number of calls
0000000000000000000000000000000000000000;;	// of the error handler, if there was one installed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Scan adds line information to the file added to the file
0000000000000000000000000000000000000000;;	// set with Init. Token positions are relative to that file
0000000000000000000000000000000000000000;;	// and thus relative to the file set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *Scanner) Scan() (pos token.Pos, tok token.Token, lit string) {
0000000000000000000000000000000000000000;;	scanAgain:
0000000000000000000000000000000000000000;;		s.skipWhitespace()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// current token start
0000000000000000000000000000000000000000;;		pos = s.file.Pos(s.offset)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// determine token value
0000000000000000000000000000000000000000;;		switch ch := s.ch; {
0000000000000000000000000000000000000000;;		case s.nextVal:
0000000000000000000000000000000000000000;;			lit = s.scanValString()
0000000000000000000000000000000000000000;;			tok = token.STRING
0000000000000000000000000000000000000000;;			s.nextVal = false
0000000000000000000000000000000000000000;;		case isLetter(ch):
0000000000000000000000000000000000000000;;			lit = s.scanIdentifier()
0000000000000000000000000000000000000000;;			tok = token.IDENT
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			s.next() // always make progress
0000000000000000000000000000000000000000;;			switch ch {
0000000000000000000000000000000000000000;;			case -1:
0000000000000000000000000000000000000000;;				tok = token.EOF
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				tok = token.EOL
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				tok = token.STRING
0000000000000000000000000000000000000000;;				lit = s.scanString()
0000000000000000000000000000000000000000;;			case '[':
0000000000000000000000000000000000000000;;				tok = token.LBRACK
0000000000000000000000000000000000000000;;			case ']':
0000000000000000000000000000000000000000;;				tok = token.RBRACK
0000000000000000000000000000000000000000;;			case ';', '#':
0000000000000000000000000000000000000000;;				// comment
0000000000000000000000000000000000000000;;				lit = s.scanComment()
0000000000000000000000000000000000000000;;				if s.mode&ScanComments == 0 {
0000000000000000000000000000000000000000;;					// skip comment
0000000000000000000000000000000000000000;;					goto scanAgain
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tok = token.COMMENT
0000000000000000000000000000000000000000;;			case '=':
0000000000000000000000000000000000000000;;				tok = token.ASSIGN
0000000000000000000000000000000000000000;;				s.nextVal = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				s.error(s.file.Offset(pos), fmt.Sprintf("illegal character %#U", ch))
0000000000000000000000000000000000000000;;				tok = token.ILLEGAL
0000000000000000000000000000000000000000;;				lit = string(ch)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
