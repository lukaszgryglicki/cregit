0000000000000000000000000000000000000000;;	package types
050f3b901a990524b87ff3fe91d0929dfb078c81;Godeps/_workspace/src/code.google.com/p/gcfg/types/int.go[Godeps/_workspace/src/code.google.com/p/gcfg/types/int.go][vendor/gopkg.in/gcfg.v1/types/int.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An IntMode is a mode for parsing integer values, representing a set of
0000000000000000000000000000000000000000;;	// accepted bases.
0000000000000000000000000000000000000000;;	type IntMode uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntMode values for ParseInt; can be combined using binary or.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Dec IntMode = 1 << iota
0000000000000000000000000000000000000000;;		Hex
0000000000000000000000000000000000000000;;		Oct
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string representation of IntMode; e.g. `IntMode(Dec|Hex)`.
0000000000000000000000000000000000000000;;	func (m IntMode) String() string {
0000000000000000000000000000000000000000;;		var modes []string
0000000000000000000000000000000000000000;;		if m&Dec != 0 {
0000000000000000000000000000000000000000;;			modes = append(modes, "Dec")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m&Hex != 0 {
0000000000000000000000000000000000000000;;			modes = append(modes, "Hex")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m&Oct != 0 {
0000000000000000000000000000000000000000;;			modes = append(modes, "Oct")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "IntMode(" + strings.Join(modes, "|") + ")"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errIntAmbig = fmt.Errorf("ambiguous integer value; must include '0' prefix")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prefix0(val string) bool {
0000000000000000000000000000000000000000;;		return strings.HasPrefix(val, "0") || strings.HasPrefix(val, "-0")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prefix0x(val string) bool {
0000000000000000000000000000000000000000;;		return strings.HasPrefix(val, "0x") || strings.HasPrefix(val, "-0x")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseInt parses val using mode into intptr, which must be a pointer to an
0000000000000000000000000000000000000000;;	// integer kind type. Non-decimal value require prefix `0` or `0x` in the cases
0000000000000000000000000000000000000000;;	// when mode permits ambiguity of base; otherwise the prefix can be omitted.
0000000000000000000000000000000000000000;;	func ParseInt(intptr interface{}, val string, mode IntMode) error {
0000000000000000000000000000000000000000;;		val = strings.TrimSpace(val)
0000000000000000000000000000000000000000;;		verb := byte(0)
0000000000000000000000000000000000000000;;		switch mode {
0000000000000000000000000000000000000000;;		case Dec:
0000000000000000000000000000000000000000;;			verb = 'd'
0000000000000000000000000000000000000000;;		case Dec + Hex:
0000000000000000000000000000000000000000;;			if prefix0x(val) {
0000000000000000000000000000000000000000;;				verb = 'v'
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				verb = 'd'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case Dec + Oct:
0000000000000000000000000000000000000000;;			if prefix0(val) && !prefix0x(val) {
0000000000000000000000000000000000000000;;				verb = 'v'
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				verb = 'd'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case Dec + Hex + Oct:
0000000000000000000000000000000000000000;;			verb = 'v'
0000000000000000000000000000000000000000;;		case Hex:
0000000000000000000000000000000000000000;;			if prefix0x(val) {
0000000000000000000000000000000000000000;;				verb = 'v'
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				verb = 'x'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case Oct:
0000000000000000000000000000000000000000;;			verb = 'o'
0000000000000000000000000000000000000000;;		case Hex + Oct:
0000000000000000000000000000000000000000;;			if prefix0(val) {
0000000000000000000000000000000000000000;;				verb = 'v'
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return errIntAmbig
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if verb == 0 {
0000000000000000000000000000000000000000;;			panic("unsupported mode")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ScanFully(intptr, val, verb)
0000000000000000000000000000000000000000;;	}
