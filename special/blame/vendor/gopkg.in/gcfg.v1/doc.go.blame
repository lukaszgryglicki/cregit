0000000000000000000000000000000000000000;;	// Package gcfg reads "INI-style" text-based configuration files with
0000000000000000000000000000000000000000;;	// "name=value" pairs grouped into sections (gcfg files).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This package is still a work in progress; see the sections below for planned
0000000000000000000000000000000000000000;;	// changes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Syntax
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The syntax is based on that used by git config:
0000000000000000000000000000000000000000;;	// http://git-scm.com/docs/git-config#_syntax .
0000000000000000000000000000000000000000;;	// There are some (planned) differences compared to the git config format:
0000000000000000000000000000000000000000;;	//  - improve data portability:
0000000000000000000000000000000000000000;;	//    - must be encoded in UTF-8 (for now) and must not contain the 0 byte
0000000000000000000000000000000000000000;;	//    - include and "path" type is not supported
0000000000000000000000000000000000000000;;	//      (path type may be implementable as a user-defined type)
0000000000000000000000000000000000000000;;	//  - internationalization
0000000000000000000000000000000000000000;;	//    - section and variable names can contain unicode letters, unicode digits
0000000000000000000000000000000000000000;;	//      (as defined in http://golang.org/ref/spec#Characters ) and hyphens
0000000000000000000000000000000000000000;;	//      (U+002D), starting with a unicode letter
0000000000000000000000000000000000000000;;	//  - disallow potentially ambiguous or misleading definitions:
0000000000000000000000000000000000000000;;	//    - `[sec.sub]` format is not allowed (deprecated in gitconfig)
0000000000000000000000000000000000000000;;	//    - `[sec ""]` is not allowed
0000000000000000000000000000000000000000;;	//      - use `[sec]` for section name "sec" and empty subsection name
0000000000000000000000000000000000000000;;	//    - (planned) within a single file, definitions must be contiguous for each:
0000000000000000000000000000000000000000;;	//      - section: '[secA]' -> '[secB]' -> '[secA]' is an error
0000000000000000000000000000000000000000;;	//      - subsection: '[sec "A"]' -> '[sec "B"]' -> '[sec "A"]' is an error
0000000000000000000000000000000000000000;;	//      - multivalued variable: 'multi=a' -> 'other=x' -> 'multi=b' is an error
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Data structure
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The functions in this package read values into a user-defined struct.
0000000000000000000000000000000000000000;;	// Each section corresponds to a struct field in the config struct, and each
0000000000000000000000000000000000000000;;	// variable in a section corresponds to a data field in the section struct.
0000000000000000000000000000000000000000;;	// The mapping of each section or variable name to fields is done either based
0000000000000000000000000000000000000000;;	// on the "gcfg" struct tag or by matching the name of the section or variable,
0000000000000000000000000000000000000000;;	// ignoring case. In the latter case, hyphens '-' in section and variable names
0000000000000000000000000000000000000000;;	// correspond to underscores '_' in field names.
0000000000000000000000000000000000000000;;	// Fields must be exported; to use a section or variable name starting with a
0000000000000000000000000000000000000000;;	// letter that is neither upper- or lower-case, prefix the field name with 'X'.
0000000000000000000000000000000000000000;;	// (See https://code.google.com/p/go/issues/detail?id=5763#c4 .)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For sections with subsections, the corresponding field in config must be a
0000000000000000000000000000000000000000;;	// map, rather than a struct, with string keys and pointer-to-struct values.
0000000000000000000000000000000000000000;;	// Values for subsection variables are stored in the map with the subsection
0000000000000000000000000000000000000000;;	// name used as the map key.
0000000000000000000000000000000000000000;;	// (Note that unlike section and variable names, subsection names are case
0000000000000000000000000000000000000000;;	// sensitive.)
0000000000000000000000000000000000000000;;	// When using a map, and there is a section with the same section name but
0000000000000000000000000000000000000000;;	// without a subsection name, its values are stored with the empty string used
0000000000000000000000000000000000000000;;	// as the key.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The functions in this package panic if config is not a pointer to a struct,
0000000000000000000000000000000000000000;;	// or when a field is not of a suitable type (either a struct or a map with
0000000000000000000000000000000000000000;;	// string keys and pointer-to-struct values).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Parsing of values
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The section structs in the config struct may contain single-valued or
0000000000000000000000000000000000000000;;	// multi-valued variables. Variables of unnamed slice type (that is, a type
0000000000000000000000000000000000000000;;	// starting with `[]`) are treated as multi-value; all others (including named
0000000000000000000000000000000000000000;;	// slice types) are treated as single-valued variables.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Single-valued variables are handled based on the type as follows.
0000000000000000000000000000000000000000;;	// Unnamed pointer types (that is, types starting with `*`) are dereferenced,
0000000000000000000000000000000000000000;;	// and if necessary, a new instance is allocated.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For types implementing the encoding.TextUnmarshaler interface, the
0000000000000000000000000000000000000000;;	// UnmarshalText method is used to set the value. Implementing this method is
0000000000000000000000000000000000000000;;	// the recommended way for parsing user-defined types.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For fields of string kind, the value string is assigned to the field, after
0000000000000000000000000000000000000000;;	// unquoting and unescaping as needed.
0000000000000000000000000000000000000000;;	// For fields of bool kind, the field is set to true if the value is "true",
0000000000000000000000000000000000000000;;	// "yes", "on" or "1", and set to false if the value is "false", "no", "off" or
0000000000000000000000000000000000000000;;	// "0", ignoring case. In addition, single-valued bool fields can be specified
0000000000000000000000000000000000000000;;	// with a "blank" value (variable name without equals sign and value); in such
0000000000000000000000000000000000000000;;	// case the value is set to true.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Predefined integer types [u]int(|8|16|32|64) and big.Int are parsed as
0000000000000000000000000000000000000000;;	// decimal or hexadecimal (if having '0x' prefix). (This is to prevent
0000000000000000000000000000000000000000;;	// unintuitively handling zero-padded numbers as octal.) Other types having
0000000000000000000000000000000000000000;;	// [u]int* as the underlying type, such as os.FileMode and uintptr allow
0000000000000000000000000000000000000000;;	// decimal, hexadecimal, or octal values.
0000000000000000000000000000000000000000;;	// Parsing mode for integer types can be overridden using the struct tag option
0000000000000000000000000000000000000000;;	// ",int=mode" where mode is a combination of the 'd', 'h', and 'o' characters
0000000000000000000000000000000000000000;;	// (each standing for decimal, hexadecimal, and octal, respectively.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All other types are parsed using fmt.Sscanf with the "%v" verb.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For multi-valued variables, each individual value is parsed as above and
0000000000000000000000000000000000000000;;	// appended to the slice. If the first value is specified as a "blank" value
0000000000000000000000000000000000000000;;	// (variable name without equals sign and value), a new slice is allocated;
0000000000000000000000000000000000000000;;	// that is any values previously set in the slice will be ignored.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The types subpackage for provides helpers for parsing "enum-like" and integer
0000000000000000000000000000000000000000;;	// types.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following is a list of changes under consideration:
0000000000000000000000000000000000000000;;	//  - documentation
0000000000000000000000000000000000000000;;	//    - self-contained syntax documentation
0000000000000000000000000000000000000000;;	//    - more practical examples
0000000000000000000000000000000000000000;;	//    - move TODOs to issue tracker (eventually)
0000000000000000000000000000000000000000;;	//  - syntax
0000000000000000000000000000000000000000;;	//    - reconsider valid escape sequences
0000000000000000000000000000000000000000;;	//      (gitconfig doesn't support \r in value, \t in subsection name, etc.)
0000000000000000000000000000000000000000;;	//  - reading / parsing gcfg files
0000000000000000000000000000000000000000;;	//    - define internal representation structure
0000000000000000000000000000000000000000;;	//    - support multiple inputs (readers, strings, files)
0000000000000000000000000000000000000000;;	//    - support declaring encoding (?)
0000000000000000000000000000000000000000;;	//    - support varying fields sets for subsections (?)
0000000000000000000000000000000000000000;;	//  - writing gcfg files
0000000000000000000000000000000000000000;;	//  - error handling
0000000000000000000000000000000000000000;;	//    - make error context accessible programmatically?
0000000000000000000000000000000000000000;;	//    - limit input size?
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package gcfg
