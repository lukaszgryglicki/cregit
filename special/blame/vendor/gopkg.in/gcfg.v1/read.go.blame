0000000000000000000000000000000000000000;;	package gcfg
050f3b901a990524b87ff3fe91d0929dfb078c81;Godeps/_workspace/src/code.google.com/p/gcfg/read.go[Godeps/_workspace/src/code.google.com/p/gcfg/read.go][vendor/gopkg.in/gcfg.v1/read.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1/scanner"
0000000000000000000000000000000000000000;;		"gopkg.in/gcfg.v1/token"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var unescape = map[rune]rune{'\\': '\\', '"': '"', 'n': '\n', 't': '\t'}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// no error: invalid literals should be caught by scanner
0000000000000000000000000000000000000000;;	func unquote(s string) string {
0000000000000000000000000000000000000000;;		u, q, esc := make([]rune, 0, len(s)), false, false
0000000000000000000000000000000000000000;;		for _, c := range s {
0000000000000000000000000000000000000000;;			if esc {
0000000000000000000000000000000000000000;;				uc, ok := unescape[c]
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case ok:
0000000000000000000000000000000000000000;;					u = append(u, uc)
0000000000000000000000000000000000000000;;					fallthrough
0000000000000000000000000000000000000000;;				case !q && c == '\n':
0000000000000000000000000000000000000000;;					esc = false
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				panic("invalid escape sequence")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				q = !q
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				esc = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				u = append(u, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if q {
0000000000000000000000000000000000000000;;			panic("missing end quote")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if esc {
0000000000000000000000000000000000000000;;			panic("invalid escape sequence")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(u)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readInto(config interface{}, fset *token.FileSet, file *token.File, src []byte) error {
0000000000000000000000000000000000000000;;		var s scanner.Scanner
0000000000000000000000000000000000000000;;		var errs scanner.ErrorList
0000000000000000000000000000000000000000;;		s.Init(file, src, func(p token.Position, m string) { errs.Add(p, m) }, 0)
0000000000000000000000000000000000000000;;		sect, sectsub := "", ""
0000000000000000000000000000000000000000;;		pos, tok, lit := s.Scan()
0000000000000000000000000000000000000000;;		errfn := func(msg string) error {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s: %s", fset.Position(pos), msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if errs.Len() > 0 {
0000000000000000000000000000000000000000;;				return errs.Err()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch tok {
0000000000000000000000000000000000000000;;			case token.EOF:
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case token.EOL, token.COMMENT:
0000000000000000000000000000000000000000;;				pos, tok, lit = s.Scan()
0000000000000000000000000000000000000000;;			case token.LBRACK:
0000000000000000000000000000000000000000;;				pos, tok, lit = s.Scan()
0000000000000000000000000000000000000000;;				if errs.Len() > 0 {
0000000000000000000000000000000000000000;;					return errs.Err()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tok != token.IDENT {
0000000000000000000000000000000000000000;;					return errfn("expected section name")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sect, sectsub = lit, ""
0000000000000000000000000000000000000000;;				pos, tok, lit = s.Scan()
0000000000000000000000000000000000000000;;				if errs.Len() > 0 {
0000000000000000000000000000000000000000;;					return errs.Err()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tok == token.STRING {
0000000000000000000000000000000000000000;;					sectsub = unquote(lit)
0000000000000000000000000000000000000000;;					if sectsub == "" {
0000000000000000000000000000000000000000;;						return errfn("empty subsection name")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pos, tok, lit = s.Scan()
0000000000000000000000000000000000000000;;					if errs.Len() > 0 {
0000000000000000000000000000000000000000;;						return errs.Err()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tok != token.RBRACK {
0000000000000000000000000000000000000000;;					if sectsub == "" {
0000000000000000000000000000000000000000;;						return errfn("expected subsection name or right bracket")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return errfn("expected right bracket")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pos, tok, lit = s.Scan()
0000000000000000000000000000000000000000;;				if tok != token.EOL && tok != token.EOF && tok != token.COMMENT {
0000000000000000000000000000000000000000;;					return errfn("expected EOL, EOF, or comment")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If a section/subsection header was found, ensure a
0000000000000000000000000000000000000000;;				// container object is created, even if there are no
0000000000000000000000000000000000000000;;				// variables further down.
0000000000000000000000000000000000000000;;				err := set(config, sect, sectsub, "", true, "")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case token.IDENT:
0000000000000000000000000000000000000000;;				if sect == "" {
0000000000000000000000000000000000000000;;					return errfn("expected section header")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n := lit
0000000000000000000000000000000000000000;;				pos, tok, lit = s.Scan()
0000000000000000000000000000000000000000;;				if errs.Len() > 0 {
0000000000000000000000000000000000000000;;					return errs.Err()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				blank, v := tok == token.EOF || tok == token.EOL || tok == token.COMMENT, ""
0000000000000000000000000000000000000000;;				if !blank {
0000000000000000000000000000000000000000;;					if tok != token.ASSIGN {
0000000000000000000000000000000000000000;;						return errfn("expected '='")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pos, tok, lit = s.Scan()
0000000000000000000000000000000000000000;;					if errs.Len() > 0 {
0000000000000000000000000000000000000000;;						return errs.Err()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if tok != token.STRING {
0000000000000000000000000000000000000000;;						return errfn("expected value")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					v = unquote(lit)
0000000000000000000000000000000000000000;;					pos, tok, lit = s.Scan()
0000000000000000000000000000000000000000;;					if errs.Len() > 0 {
0000000000000000000000000000000000000000;;						return errs.Err()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if tok != token.EOL && tok != token.EOF && tok != token.COMMENT {
0000000000000000000000000000000000000000;;						return errfn("expected EOL, EOF, or comment")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err := set(config, sect, sectsub, n, blank, v)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if sect == "" {
0000000000000000000000000000000000000000;;					return errfn("expected section header")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return errfn("expected section header or variable declaration")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("never reached")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadInto reads gcfg formatted data from reader and sets the values into the
0000000000000000000000000000000000000000;;	// corresponding fields in config.
0000000000000000000000000000000000000000;;	func ReadInto(config interface{}, reader io.Reader) error {
0000000000000000000000000000000000000000;;		src, err := ioutil.ReadAll(reader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fset := token.NewFileSet()
0000000000000000000000000000000000000000;;		file := fset.AddFile("", fset.Base(), len(src))
0000000000000000000000000000000000000000;;		return readInto(config, fset, file, src)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadStringInto reads gcfg formatted data from str and sets the values into
0000000000000000000000000000000000000000;;	// the corresponding fields in config.
0000000000000000000000000000000000000000;;	func ReadStringInto(config interface{}, str string) error {
0000000000000000000000000000000000000000;;		r := strings.NewReader(str)
0000000000000000000000000000000000000000;;		return ReadInto(config, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadFileInto reads gcfg formatted data from the file filename and sets the
0000000000000000000000000000000000000000;;	// values into the corresponding fields in config.
0000000000000000000000000000000000000000;;	func ReadFileInto(config interface{}, filename string) error {
0000000000000000000000000000000000000000;;		f, err := os.Open(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		src, err := ioutil.ReadAll(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fset := token.NewFileSet()
0000000000000000000000000000000000000000;;		file := fset.AddFile(filename, fset.Base(), len(src))
0000000000000000000000000000000000000000;;		return readInto(config, fset, file, src)
0000000000000000000000000000000000000000;;	}
