0000000000000000000000000000000000000000;;	// Package inf (type inf.Dec) implements "infinite-precision" decimal
0000000000000000000000000000000000000000;;	// arithmetic.
0000000000000000000000000000000000000000;;	// "Infinite precision" describes two characteristics: practically unlimited
0000000000000000000000000000000000000000;;	// precision for decimal number representation and no support for calculating
0000000000000000000000000000000000000000;;	// with any specific fixed precision.
0000000000000000000000000000000000000000;;	// (Although there is no practical limit on precision, inf.Dec can only
0000000000000000000000000000000000000000;;	// represent finite decimals.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This package is currently in experimental stage and the API may change.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This package does NOT support:
0000000000000000000000000000000000000000;;	//  - rounding to specific precisions (as opposed to specific decimal positions)
0000000000000000000000000000000000000000;;	//  - the notion of context (each rounding must be explicit)
0000000000000000000000000000000000000000;;	//  - NaN and Inf values, and distinguishing between positive and negative zero
0000000000000000000000000000000000000000;;	//  - conversions to and from float32/64 types
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Features considered for possible addition:
0000000000000000000000000000000000000000;;	//  + formatting options
0000000000000000000000000000000000000000;;	//  + Exp method
0000000000000000000000000000000000000000;;	//  + combined operations such as AddRound/MulAdd etc
0000000000000000000000000000000000000000;;	//  + exchanging data in decimal32/64/128 formats
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package inf
c65f4b2b9fe9d6f0f225f927e573b7fac93507a1;Godeps/_workspace/src/speter.net/go/exp/math/dec/inf/dec.go[Godeps/_workspace/src/speter.net/go/exp/math/dec/inf/dec.go][vendor/gopkg.in/inf.v0/dec.go];	
0000000000000000000000000000000000000000;;	// TODO:
0000000000000000000000000000000000000000;;	//  - avoid excessive deep copying (quo and rounders)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Dec represents a signed arbitrary-precision decimal.
0000000000000000000000000000000000000000;;	// It is a combination of a sign, an arbitrary-precision integer coefficient
0000000000000000000000000000000000000000;;	// value, and a signed fixed-precision exponent value.
0000000000000000000000000000000000000000;;	// The sign and the coefficient value are handled together as a signed value
0000000000000000000000000000000000000000;;	// and referred to as the unscaled value.
0000000000000000000000000000000000000000;;	// (Positive and negative zero values are not distinguished.)
0000000000000000000000000000000000000000;;	// Since the exponent is most commonly non-positive, it is handled in negated
0000000000000000000000000000000000000000;;	// form and referred to as scale.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The mathematical value of a Dec equals:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  unscaled * 10**(-scale)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that different Dec representations may have equal mathematical values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  unscaled  scale  String()
0000000000000000000000000000000000000000;;	//  -------------------------
0000000000000000000000000000000000000000;;	//         0      0    "0"
0000000000000000000000000000000000000000;;	//         0      2    "0.00"
0000000000000000000000000000000000000000;;	//         0     -2    "0"
0000000000000000000000000000000000000000;;	//         1      0    "1"
0000000000000000000000000000000000000000;;	//       100      2    "1.00"
0000000000000000000000000000000000000000;;	//        10      0   "10"
0000000000000000000000000000000000000000;;	//         1     -1   "10"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The zero value for a Dec represents the value 0 with scale 0.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Operations are typically performed through the *Dec type.
0000000000000000000000000000000000000000;;	// The semantics of the assignment operation "=" for "bare" Dec values is
0000000000000000000000000000000000000000;;	// undefined and should not be relied on.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Methods are typically of the form:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	func (z *Dec) Op(x, y *Dec) *Dec
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// and implement operations z = x Op y with the result as receiver; if it
0000000000000000000000000000000000000000;;	// is one of the operands it may be overwritten (and its memory reused).
0000000000000000000000000000000000000000;;	// To enable chaining of operations, the result is also returned. Methods
0000000000000000000000000000000000000000;;	// returning a result other than *Dec take one of the operands as the receiver.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A "bare" Quo method (quotient / division operation) is not provided, as the
0000000000000000000000000000000000000000;;	// result is not always a finite decimal and thus in general cannot be
0000000000000000000000000000000000000000;;	// represented as a Dec.
0000000000000000000000000000000000000000;;	// Instead, in the common case when rounding is (potentially) necessary,
0000000000000000000000000000000000000000;;	// QuoRound should be used with a Scale and a Rounder.
0000000000000000000000000000000000000000;;	// QuoExact or QuoRound with RoundExact can be used in the special cases when it
0000000000000000000000000000000000000000;;	// is known that the result is always a finite decimal.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Dec struct {
0000000000000000000000000000000000000000;;		unscaled big.Int
0000000000000000000000000000000000000000;;		scale    Scale
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scale represents the type used for the scale of a Dec.
0000000000000000000000000000000000000000;;	type Scale int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const scaleSize = 4 // bytes in a Scale value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scaler represents a method for obtaining the scale to use for the result of
0000000000000000000000000000000000000000;;	// an operation on x and y.
0000000000000000000000000000000000000000;;	type scaler interface {
0000000000000000000000000000000000000000;;		Scale(x *Dec, y *Dec) Scale
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bigInt = [...]*big.Int{
0000000000000000000000000000000000000000;;		big.NewInt(0), big.NewInt(1), big.NewInt(2), big.NewInt(3), big.NewInt(4),
0000000000000000000000000000000000000000;;		big.NewInt(5), big.NewInt(6), big.NewInt(7), big.NewInt(8), big.NewInt(9),
0000000000000000000000000000000000000000;;		big.NewInt(10),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var exp10cache [64]big.Int = func() [64]big.Int {
0000000000000000000000000000000000000000;;		e10, e10i := [64]big.Int{}, bigInt[1]
0000000000000000000000000000000000000000;;		for i, _ := range e10 {
0000000000000000000000000000000000000000;;			e10[i].Set(e10i)
0000000000000000000000000000000000000000;;			e10i = new(big.Int).Mul(e10i, bigInt[10])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e10
0000000000000000000000000000000000000000;;	}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDec allocates and returns a new Dec set to the given int64 unscaled value
0000000000000000000000000000000000000000;;	// and scale.
0000000000000000000000000000000000000000;;	func NewDec(unscaled int64, scale Scale) *Dec {
0000000000000000000000000000000000000000;;		return new(Dec).SetUnscaled(unscaled).SetScale(scale)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecBig allocates and returns a new Dec set to the given *big.Int unscaled
0000000000000000000000000000000000000000;;	// value and scale.
0000000000000000000000000000000000000000;;	func NewDecBig(unscaled *big.Int, scale Scale) *Dec {
0000000000000000000000000000000000000000;;		return new(Dec).SetUnscaledBig(unscaled).SetScale(scale)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scale returns the scale of x.
0000000000000000000000000000000000000000;;	func (x *Dec) Scale() Scale {
0000000000000000000000000000000000000000;;		return x.scale
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unscaled returns the unscaled value of x for u and true for ok when the
0000000000000000000000000000000000000000;;	// unscaled value can be represented as int64; otherwise it returns an undefined
0000000000000000000000000000000000000000;;	// int64 value for u and false for ok. Use x.UnscaledBig().Int64() to avoid
0000000000000000000000000000000000000000;;	// checking the validity of the value when the check is known to be redundant.
0000000000000000000000000000000000000000;;	func (x *Dec) Unscaled() (u int64, ok bool) {
0000000000000000000000000000000000000000;;		u = x.unscaled.Int64()
0000000000000000000000000000000000000000;;		var i big.Int
0000000000000000000000000000000000000000;;		ok = i.SetInt64(u).Cmp(&x.unscaled) == 0
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnscaledBig returns the unscaled value of x as *big.Int.
0000000000000000000000000000000000000000;;	func (x *Dec) UnscaledBig() *big.Int {
0000000000000000000000000000000000000000;;		return &x.unscaled
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetScale sets the scale of z, with the unscaled value unchanged, and returns
0000000000000000000000000000000000000000;;	// z.
0000000000000000000000000000000000000000;;	// The mathematical value of the Dec changes as if it was multiplied by
0000000000000000000000000000000000000000;;	// 10**(oldscale-scale).
0000000000000000000000000000000000000000;;	func (z *Dec) SetScale(scale Scale) *Dec {
0000000000000000000000000000000000000000;;		z.scale = scale
0000000000000000000000000000000000000000;;		return z
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUnscaled sets the unscaled value of z, with the scale unchanged, and
0000000000000000000000000000000000000000;;	// returns z.
0000000000000000000000000000000000000000;;	func (z *Dec) SetUnscaled(unscaled int64) *Dec {
0000000000000000000000000000000000000000;;		z.unscaled.SetInt64(unscaled)
0000000000000000000000000000000000000000;;		return z
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUnscaledBig sets the unscaled value of z, with the scale unchanged, and
0000000000000000000000000000000000000000;;	// returns z.
0000000000000000000000000000000000000000;;	func (z *Dec) SetUnscaledBig(unscaled *big.Int) *Dec {
0000000000000000000000000000000000000000;;		z.unscaled.Set(unscaled)
0000000000000000000000000000000000000000;;		return z
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets z to the value of x and returns z.
0000000000000000000000000000000000000000;;	// It does nothing if z == x.
0000000000000000000000000000000000000000;;	func (z *Dec) Set(x *Dec) *Dec {
0000000000000000000000000000000000000000;;		if z != x {
0000000000000000000000000000000000000000;;			z.SetUnscaledBig(x.UnscaledBig())
0000000000000000000000000000000000000000;;			z.SetScale(x.Scale())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return z
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign returns:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	-1 if x <  0
0000000000000000000000000000000000000000;;	//	 0 if x == 0
0000000000000000000000000000000000000000;;	//	+1 if x >  0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (x *Dec) Sign() int {
0000000000000000000000000000000000000000;;		return x.UnscaledBig().Sign()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Neg sets z to -x and returns z.
0000000000000000000000000000000000000000;;	func (z *Dec) Neg(x *Dec) *Dec {
0000000000000000000000000000000000000000;;		z.SetScale(x.Scale())
0000000000000000000000000000000000000000;;		z.UnscaledBig().Neg(x.UnscaledBig())
0000000000000000000000000000000000000000;;		return z
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cmp compares x and y and returns:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   -1 if x <  y
0000000000000000000000000000000000000000;;	//    0 if x == y
0000000000000000000000000000000000000000;;	//   +1 if x >  y
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (x *Dec) Cmp(y *Dec) int {
0000000000000000000000000000000000000000;;		xx, yy := upscale(x, y)
0000000000000000000000000000000000000000;;		return xx.UnscaledBig().Cmp(yy.UnscaledBig())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Abs sets z to |x| (the absolute value of x) and returns z.
0000000000000000000000000000000000000000;;	func (z *Dec) Abs(x *Dec) *Dec {
0000000000000000000000000000000000000000;;		z.SetScale(x.Scale())
0000000000000000000000000000000000000000;;		z.UnscaledBig().Abs(x.UnscaledBig())
0000000000000000000000000000000000000000;;		return z
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add sets z to the sum x+y and returns z.
0000000000000000000000000000000000000000;;	// The scale of z is the greater of the scales of x and y.
0000000000000000000000000000000000000000;;	func (z *Dec) Add(x, y *Dec) *Dec {
0000000000000000000000000000000000000000;;		xx, yy := upscale(x, y)
0000000000000000000000000000000000000000;;		z.SetScale(xx.Scale())
0000000000000000000000000000000000000000;;		z.UnscaledBig().Add(xx.UnscaledBig(), yy.UnscaledBig())
0000000000000000000000000000000000000000;;		return z
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sub sets z to the difference x-y and returns z.
0000000000000000000000000000000000000000;;	// The scale of z is the greater of the scales of x and y.
0000000000000000000000000000000000000000;;	func (z *Dec) Sub(x, y *Dec) *Dec {
0000000000000000000000000000000000000000;;		xx, yy := upscale(x, y)
0000000000000000000000000000000000000000;;		z.SetScale(xx.Scale())
0000000000000000000000000000000000000000;;		z.UnscaledBig().Sub(xx.UnscaledBig(), yy.UnscaledBig())
0000000000000000000000000000000000000000;;		return z
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mul sets z to the product x*y and returns z.
0000000000000000000000000000000000000000;;	// The scale of z is the sum of the scales of x and y.
0000000000000000000000000000000000000000;;	func (z *Dec) Mul(x, y *Dec) *Dec {
0000000000000000000000000000000000000000;;		z.SetScale(x.Scale() + y.Scale())
0000000000000000000000000000000000000000;;		z.UnscaledBig().Mul(x.UnscaledBig(), y.UnscaledBig())
0000000000000000000000000000000000000000;;		return z
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Round sets z to the value of x rounded to Scale s using Rounder r, and
0000000000000000000000000000000000000000;;	// returns z.
0000000000000000000000000000000000000000;;	func (z *Dec) Round(x *Dec, s Scale, r Rounder) *Dec {
0000000000000000000000000000000000000000;;		return z.QuoRound(x, NewDec(1, 0), s, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QuoRound sets z to the quotient x/y, rounded using the given Rounder to the
0000000000000000000000000000000000000000;;	// specified scale.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the rounder is RoundExact but the result can not be expressed exactly at
0000000000000000000000000000000000000000;;	// the specified scale, QuoRound returns nil, and the value of z is undefined.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There is no corresponding Div method; the equivalent can be achieved through
0000000000000000000000000000000000000000;;	// the choice of Rounder used.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (z *Dec) QuoRound(x, y *Dec, s Scale, r Rounder) *Dec {
0000000000000000000000000000000000000000;;		return z.quo(x, y, sclr{s}, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *Dec) quo(x, y *Dec, s scaler, r Rounder) *Dec {
0000000000000000000000000000000000000000;;		scl := s.Scale(x, y)
0000000000000000000000000000000000000000;;		var zzz *Dec
0000000000000000000000000000000000000000;;		if r.UseRemainder() {
0000000000000000000000000000000000000000;;			zz, rA, rB := new(Dec).quoRem(x, y, scl, true, new(big.Int), new(big.Int))
0000000000000000000000000000000000000000;;			zzz = r.Round(new(Dec), zz, rA, rB)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			zz, _, _ := new(Dec).quoRem(x, y, scl, false, nil, nil)
0000000000000000000000000000000000000000;;			zzz = r.Round(new(Dec), zz, nil, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if zzz == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return z.Set(zzz)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QuoExact sets z to the quotient x/y and returns z when x/y is a finite
0000000000000000000000000000000000000000;;	// decimal. Otherwise it returns nil and the value of z is undefined.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The scale of a non-nil result is "x.Scale() - y.Scale()" or greater; it is
0000000000000000000000000000000000000000;;	// calculated so that the remainder will be zero whenever x/y is a finite
0000000000000000000000000000000000000000;;	// decimal.
0000000000000000000000000000000000000000;;	func (z *Dec) QuoExact(x, y *Dec) *Dec {
0000000000000000000000000000000000000000;;		return z.quo(x, y, scaleQuoExact{}, RoundExact)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// quoRem sets z to the quotient x/y with the scale s, and if useRem is true,
0000000000000000000000000000000000000000;;	// it sets remNum and remDen to the numerator and denominator of the remainder.
0000000000000000000000000000000000000000;;	// It returns z, remNum and remDen.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The remainder is normalized to the range -1 < r < 1 to simplify rounding;
0000000000000000000000000000000000000000;;	// that is, the results satisfy the following equation:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  x / y = z + (remNum/remDen) * 10**(-z.Scale())
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See Rounder for more details about rounding.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (z *Dec) quoRem(x, y *Dec, s Scale, useRem bool,
0000000000000000000000000000000000000000;;		remNum, remDen *big.Int) (*Dec, *big.Int, *big.Int) {
0000000000000000000000000000000000000000;;		// difference (required adjustment) compared to "canonical" result scale
0000000000000000000000000000000000000000;;		shift := s - (x.Scale() - y.Scale())
0000000000000000000000000000000000000000;;		// pointers to adjusted unscaled dividend and divisor
0000000000000000000000000000000000000000;;		var ix, iy *big.Int
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case shift > 0:
0000000000000000000000000000000000000000;;			// increased scale: decimal-shift dividend left
0000000000000000000000000000000000000000;;			ix = new(big.Int).Mul(x.UnscaledBig(), exp10(shift))
0000000000000000000000000000000000000000;;			iy = y.UnscaledBig()
0000000000000000000000000000000000000000;;		case shift < 0:
0000000000000000000000000000000000000000;;			// decreased scale: decimal-shift divisor left
0000000000000000000000000000000000000000;;			ix = x.UnscaledBig()
0000000000000000000000000000000000000000;;			iy = new(big.Int).Mul(y.UnscaledBig(), exp10(-shift))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			ix = x.UnscaledBig()
0000000000000000000000000000000000000000;;			iy = y.UnscaledBig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// save a copy of iy in case it to be overwritten with the result
0000000000000000000000000000000000000000;;		iy2 := iy
0000000000000000000000000000000000000000;;		if iy == z.UnscaledBig() {
0000000000000000000000000000000000000000;;			iy2 = new(big.Int).Set(iy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// set scale
0000000000000000000000000000000000000000;;		z.SetScale(s)
0000000000000000000000000000000000000000;;		// set unscaled
0000000000000000000000000000000000000000;;		if useRem {
0000000000000000000000000000000000000000;;			// Int division
0000000000000000000000000000000000000000;;			_, intr := z.UnscaledBig().QuoRem(ix, iy, new(big.Int))
0000000000000000000000000000000000000000;;			// set remainder
0000000000000000000000000000000000000000;;			remNum.Set(intr)
0000000000000000000000000000000000000000;;			remDen.Set(iy2)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			z.UnscaledBig().Quo(ix, iy)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return z, remNum, remDen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sclr struct{ s Scale }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sclr) Scale(x, y *Dec) Scale {
0000000000000000000000000000000000000000;;		return s.s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type scaleQuoExact struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sqe scaleQuoExact) Scale(x, y *Dec) Scale {
0000000000000000000000000000000000000000;;		rem := new(big.Rat).SetFrac(x.UnscaledBig(), y.UnscaledBig())
0000000000000000000000000000000000000000;;		f2, f5 := factor2(rem.Denom()), factor(rem.Denom(), bigInt[5])
0000000000000000000000000000000000000000;;		var f10 Scale
0000000000000000000000000000000000000000;;		if f2 > f5 {
0000000000000000000000000000000000000000;;			f10 = Scale(f2)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f10 = Scale(f5)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x.Scale() - y.Scale() + f10
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func factor(n *big.Int, p *big.Int) int {
0000000000000000000000000000000000000000;;		// could be improved for large factors
0000000000000000000000000000000000000000;;		d, f := n, 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			dd, dm := new(big.Int).DivMod(d, p, new(big.Int))
0000000000000000000000000000000000000000;;			if dm.Sign() == 0 {
0000000000000000000000000000000000000000;;				f++
0000000000000000000000000000000000000000;;				d = dd
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func factor2(n *big.Int) int {
0000000000000000000000000000000000000000;;		// could be improved for large factors
0000000000000000000000000000000000000000;;		f := 0
0000000000000000000000000000000000000000;;		for ; n.Bit(f) == 0; f++ {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func upscale(a, b *Dec) (*Dec, *Dec) {
0000000000000000000000000000000000000000;;		if a.Scale() == b.Scale() {
0000000000000000000000000000000000000000;;			return a, b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.Scale() > b.Scale() {
0000000000000000000000000000000000000000;;			bb := b.rescale(a.Scale())
0000000000000000000000000000000000000000;;			return a, bb
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		aa := a.rescale(b.Scale())
0000000000000000000000000000000000000000;;		return aa, b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func exp10(x Scale) *big.Int {
0000000000000000000000000000000000000000;;		if int(x) < len(exp10cache) {
0000000000000000000000000000000000000000;;			return &exp10cache[int(x)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return new(big.Int).Exp(bigInt[10], big.NewInt(int64(x)), nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *Dec) rescale(newScale Scale) *Dec {
0000000000000000000000000000000000000000;;		shift := newScale - x.Scale()
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case shift < 0:
0000000000000000000000000000000000000000;;			e := exp10(-shift)
0000000000000000000000000000000000000000;;			return NewDecBig(new(big.Int).Quo(x.UnscaledBig(), e), newScale)
0000000000000000000000000000000000000000;;		case shift > 0:
0000000000000000000000000000000000000000;;			e := exp10(shift)
0000000000000000000000000000000000000000;;			return NewDecBig(new(big.Int).Mul(x.UnscaledBig(), e), newScale)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var zeros = []byte("00000000000000000000000000000000" +
0000000000000000000000000000000000000000;;		"00000000000000000000000000000000")
0000000000000000000000000000000000000000;;	var lzeros = Scale(len(zeros))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendZeros(s []byte, n Scale) []byte {
0000000000000000000000000000000000000000;;		for i := Scale(0); i < n; i += lzeros {
0000000000000000000000000000000000000000;;			if n > i+lzeros {
0000000000000000000000000000000000000000;;				s = append(s, zeros...)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s = append(s, zeros[0:n-i]...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *Dec) String() string {
0000000000000000000000000000000000000000;;		if x == nil {
0000000000000000000000000000000000000000;;			return "<nil>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scale := x.Scale()
0000000000000000000000000000000000000000;;		s := []byte(x.UnscaledBig().String())
0000000000000000000000000000000000000000;;		if scale <= 0 {
0000000000000000000000000000000000000000;;			if scale != 0 && x.unscaled.Sign() != 0 {
0000000000000000000000000000000000000000;;				s = appendZeros(s, -scale)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return string(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		negbit := Scale(-((x.Sign() - 1) / 2))
0000000000000000000000000000000000000000;;		// scale > 0
0000000000000000000000000000000000000000;;		lens := Scale(len(s))
0000000000000000000000000000000000000000;;		if lens-negbit <= scale {
0000000000000000000000000000000000000000;;			ss := make([]byte, 0, scale+2)
0000000000000000000000000000000000000000;;			if negbit == 1 {
0000000000000000000000000000000000000000;;				ss = append(ss, '-')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ss = append(ss, '0', '.')
0000000000000000000000000000000000000000;;			ss = appendZeros(ss, scale-lens+negbit)
0000000000000000000000000000000000000000;;			ss = append(ss, s[negbit:]...)
0000000000000000000000000000000000000000;;			return string(ss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// lens > scale
0000000000000000000000000000000000000000;;		ss := make([]byte, 0, lens+1)
0000000000000000000000000000000000000000;;		ss = append(ss, s[:lens-scale]...)
0000000000000000000000000000000000000000;;		ss = append(ss, '.')
0000000000000000000000000000000000000000;;		ss = append(ss, s[lens-scale:]...)
0000000000000000000000000000000000000000;;		return string(ss)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Format is a support routine for fmt.Formatter. It accepts the decimal
0000000000000000000000000000000000000000;;	// formats 'd' and 'f', and handles both equivalently.
0000000000000000000000000000000000000000;;	// Width, precision, flags and bases 2, 8, 16 are not supported.
0000000000000000000000000000000000000000;;	func (x *Dec) Format(s fmt.State, ch rune) {
0000000000000000000000000000000000000000;;		if ch != 'd' && ch != 'f' && ch != 'v' && ch != 's' {
0000000000000000000000000000000000000000;;			fmt.Fprintf(s, "%%!%c(dec.Dec=%s)", ch, x.String())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(s, x.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *Dec) scan(r io.RuneScanner) (*Dec, error) {
0000000000000000000000000000000000000000;;		unscaled := make([]byte, 0, 256) // collects chars of unscaled as bytes
0000000000000000000000000000000000000000;;		dp, dg := -1, -1                 // indexes of decimal point, first digit
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			ch, _, err := r.ReadRune()
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case ch == '+' || ch == '-':
0000000000000000000000000000000000000000;;				if len(unscaled) > 0 || dp >= 0 { // must be first character
0000000000000000000000000000000000000000;;					r.UnreadRune()
0000000000000000000000000000000000000000;;					break loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case ch == '.':
0000000000000000000000000000000000000000;;				if dp >= 0 {
0000000000000000000000000000000000000000;;					r.UnreadRune()
0000000000000000000000000000000000000000;;					break loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dp = len(unscaled)
0000000000000000000000000000000000000000;;				continue // don't add to unscaled
0000000000000000000000000000000000000000;;			case ch >= '0' && ch <= '9':
0000000000000000000000000000000000000000;;				if dg == -1 {
0000000000000000000000000000000000000000;;					dg = len(unscaled)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				r.UnreadRune()
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unscaled = append(unscaled, byte(ch))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dg == -1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no digits read")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dp >= 0 {
0000000000000000000000000000000000000000;;			z.SetScale(Scale(len(unscaled) - dp))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			z.SetScale(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := z.UnscaledBig().SetString(string(unscaled), 10)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid decimal: %s", string(unscaled))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return z, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetString sets z to the value of s, interpreted as a decimal (base 10),
0000000000000000000000000000000000000000;;	// and returns z and a boolean indicating success. The scale of z is the
0000000000000000000000000000000000000000;;	// number of digits after the decimal point (including any trailing 0s),
0000000000000000000000000000000000000000;;	// or 0 if there is no decimal point. If SetString fails, the value of z
0000000000000000000000000000000000000000;;	// is undefined but the returned value is nil.
0000000000000000000000000000000000000000;;	func (z *Dec) SetString(s string) (*Dec, bool) {
0000000000000000000000000000000000000000;;		r := strings.NewReader(s)
0000000000000000000000000000000000000000;;		_, err := z.scan(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, err = r.ReadRune()
0000000000000000000000000000000000000000;;		if err != io.EOF {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// err == io.EOF => scan consumed all of s
0000000000000000000000000000000000000000;;		return z, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan is a support routine for fmt.Scanner; it sets z to the value of
0000000000000000000000000000000000000000;;	// the scanned number. It accepts the decimal formats 'd' and 'f', and
0000000000000000000000000000000000000000;;	// handles both equivalently. Bases 2, 8, 16 are not supported.
0000000000000000000000000000000000000000;;	// The scale of z is the number of digits after the decimal point
0000000000000000000000000000000000000000;;	// (including any trailing 0s), or 0 if there is no decimal point.
0000000000000000000000000000000000000000;;	func (z *Dec) Scan(s fmt.ScanState, ch rune) error {
0000000000000000000000000000000000000000;;		if ch != 'd' && ch != 'f' && ch != 's' && ch != 'v' {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Dec.Scan: invalid verb '%c'", ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.SkipSpace()
0000000000000000000000000000000000000000;;		_, err := z.scan(s)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gob encoding version
0000000000000000000000000000000000000000;;	const decGobVersion byte = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scaleBytes(s Scale) []byte {
0000000000000000000000000000000000000000;;		buf := make([]byte, scaleSize)
0000000000000000000000000000000000000000;;		i := scaleSize
0000000000000000000000000000000000000000;;		for j := 0; j < scaleSize; j++ {
0000000000000000000000000000000000000000;;			i--
0000000000000000000000000000000000000000;;			buf[i] = byte(s)
0000000000000000000000000000000000000000;;			s >>= 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scale(b []byte) (s Scale) {
0000000000000000000000000000000000000000;;		for j := 0; j < scaleSize; j++ {
0000000000000000000000000000000000000000;;			s <<= 8
0000000000000000000000000000000000000000;;			s |= Scale(b[j])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GobEncode implements the gob.GobEncoder interface.
0000000000000000000000000000000000000000;;	func (x *Dec) GobEncode() ([]byte, error) {
0000000000000000000000000000000000000000;;		buf, err := x.UnscaledBig().GobEncode()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf = append(append(buf, scaleBytes(x.Scale())...), decGobVersion)
0000000000000000000000000000000000000000;;		return buf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GobDecode implements the gob.GobDecoder interface.
0000000000000000000000000000000000000000;;	func (z *Dec) GobDecode(buf []byte) error {
0000000000000000000000000000000000000000;;		if len(buf) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Dec.GobDecode: no data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b := buf[len(buf)-1]
0000000000000000000000000000000000000000;;		if b != decGobVersion {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Dec.GobDecode: encoding version %d not supported", b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := len(buf) - scaleSize - 1
0000000000000000000000000000000000000000;;		err := z.UnscaledBig().GobDecode(buf[:l])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.SetScale(scale(buf[l : l+scaleSize]))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalText implements the encoding.TextMarshaler interface.
0000000000000000000000000000000000000000;;	func (x *Dec) MarshalText() ([]byte, error) {
0000000000000000000000000000000000000000;;		return []byte(x.String()), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalText implements the encoding.TextUnmarshaler interface.
0000000000000000000000000000000000000000;;	func (z *Dec) UnmarshalText(data []byte) error {
0000000000000000000000000000000000000000;;		_, ok := z.SetString(string(data))
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid inf.Dec")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
