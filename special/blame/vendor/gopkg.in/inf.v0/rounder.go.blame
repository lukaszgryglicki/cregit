0000000000000000000000000000000000000000;;	package inf
c65f4b2b9fe9d6f0f225f927e573b7fac93507a1;Godeps/_workspace/src/speter.net/go/exp/math/dec/inf/rounder.go[Godeps/_workspace/src/speter.net/go/exp/math/dec/inf/rounder.go][vendor/gopkg.in/inf.v0/rounder.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rounder represents a method for rounding the (possibly infinite decimal)
0000000000000000000000000000000000000000;;	// result of a division to a finite Dec. It is used by Dec.Round() and
0000000000000000000000000000000000000000;;	// Dec.Quo().
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the Example for results of using each Rounder with some sample values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Rounder rounder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See http://speleotrove.com/decimal/damodel.html#refround for more detailed
0000000000000000000000000000000000000000;;	// definitions of these rounding modes.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		RoundDown     Rounder // towards 0
0000000000000000000000000000000000000000;;		RoundUp       Rounder // away from 0
0000000000000000000000000000000000000000;;		RoundFloor    Rounder // towards -infinity
0000000000000000000000000000000000000000;;		RoundCeil     Rounder // towards +infinity
0000000000000000000000000000000000000000;;		RoundHalfDown Rounder // to nearest; towards 0 if same distance
0000000000000000000000000000000000000000;;		RoundHalfUp   Rounder // to nearest; away from 0 if same distance
0000000000000000000000000000000000000000;;		RoundHalfEven Rounder // to nearest; even last digit if same distance
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundExact is to be used in the case when rounding is not necessary.
0000000000000000000000000000000000000000;;	// When used with Quo or Round, it returns the result verbatim when it can be
0000000000000000000000000000000000000000;;	// expressed exactly with the given precision, and it returns nil otherwise.
0000000000000000000000000000000000000000;;	// QuoExact is a shorthand for using Quo with RoundExact.
0000000000000000000000000000000000000000;;	var RoundExact Rounder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rounder interface {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When UseRemainder() returns true, the Round() method is passed the
0000000000000000000000000000000000000000;;		// remainder of the division, expressed as the numerator and denominator of
0000000000000000000000000000000000000000;;		// a rational.
0000000000000000000000000000000000000000;;		UseRemainder() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Round sets the rounded value of a quotient to z, and returns z.
0000000000000000000000000000000000000000;;		// quo is rounded down (truncated towards zero) to the scale obtained from
0000000000000000000000000000000000000000;;		// the Scaler in Quo().
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// When the remainder is not used, remNum and remDen are nil.
0000000000000000000000000000000000000000;;		// When used, the remainder is normalized between -1 and 1; that is:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//  -|remDen| < remNum < |remDen|
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// remDen has the same sign as y, and remNum is zero or has the same sign
0000000000000000000000000000000000000000;;		// as x.
0000000000000000000000000000000000000000;;		Round(z, quo *Dec, remNum, remDen *big.Int) *Dec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rndr struct {
0000000000000000000000000000000000000000;;		useRem bool
0000000000000000000000000000000000000000;;		round  func(z, quo *Dec, remNum, remDen *big.Int) *Dec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r rndr) UseRemainder() bool {
0000000000000000000000000000000000000000;;		return r.useRem
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r rndr) Round(z, quo *Dec, remNum, remDen *big.Int) *Dec {
0000000000000000000000000000000000000000;;		return r.round(z, quo, remNum, remDen)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var intSign = []*big.Int{big.NewInt(-1), big.NewInt(0), big.NewInt(1)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func roundHalf(f func(c int, odd uint) (roundUp bool)) func(z, q *Dec, rA, rB *big.Int) *Dec {
0000000000000000000000000000000000000000;;		return func(z, q *Dec, rA, rB *big.Int) *Dec {
0000000000000000000000000000000000000000;;			z.Set(q)
0000000000000000000000000000000000000000;;			brA, brB := rA.BitLen(), rB.BitLen()
0000000000000000000000000000000000000000;;			if brA < brB-1 {
0000000000000000000000000000000000000000;;				// brA < brB-1 => |rA| < |rB/2|
0000000000000000000000000000000000000000;;				return z
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			roundUp := false
0000000000000000000000000000000000000000;;			srA, srB := rA.Sign(), rB.Sign()
0000000000000000000000000000000000000000;;			s := srA * srB
0000000000000000000000000000000000000000;;			if brA == brB-1 {
0000000000000000000000000000000000000000;;				rA2 := new(big.Int).Lsh(rA, 1)
0000000000000000000000000000000000000000;;				if s < 0 {
0000000000000000000000000000000000000000;;					rA2.Neg(rA2)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				roundUp = f(rA2.Cmp(rB)*srB, z.UnscaledBig().Bit(0))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// brA > brB-1 => |rA| > |rB/2|
0000000000000000000000000000000000000000;;				roundUp = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if roundUp {
0000000000000000000000000000000000000000;;				z.UnscaledBig().Add(z.UnscaledBig(), intSign[s+1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return z
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		RoundExact = rndr{true,
0000000000000000000000000000000000000000;;			func(z, q *Dec, rA, rB *big.Int) *Dec {
0000000000000000000000000000000000000000;;				if rA.Sign() != 0 {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return z.Set(q)
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		RoundDown = rndr{false,
0000000000000000000000000000000000000000;;			func(z, q *Dec, rA, rB *big.Int) *Dec {
0000000000000000000000000000000000000000;;				return z.Set(q)
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		RoundUp = rndr{true,
0000000000000000000000000000000000000000;;			func(z, q *Dec, rA, rB *big.Int) *Dec {
0000000000000000000000000000000000000000;;				z.Set(q)
0000000000000000000000000000000000000000;;				if rA.Sign() != 0 {
0000000000000000000000000000000000000000;;					z.UnscaledBig().Add(z.UnscaledBig(), intSign[rA.Sign()*rB.Sign()+1])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return z
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		RoundFloor = rndr{true,
0000000000000000000000000000000000000000;;			func(z, q *Dec, rA, rB *big.Int) *Dec {
0000000000000000000000000000000000000000;;				z.Set(q)
0000000000000000000000000000000000000000;;				if rA.Sign()*rB.Sign() < 0 {
0000000000000000000000000000000000000000;;					z.UnscaledBig().Add(z.UnscaledBig(), intSign[0])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return z
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		RoundCeil = rndr{true,
0000000000000000000000000000000000000000;;			func(z, q *Dec, rA, rB *big.Int) *Dec {
0000000000000000000000000000000000000000;;				z.Set(q)
0000000000000000000000000000000000000000;;				if rA.Sign()*rB.Sign() > 0 {
0000000000000000000000000000000000000000;;					z.UnscaledBig().Add(z.UnscaledBig(), intSign[2])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return z
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		RoundHalfDown = rndr{true, roundHalf(
0000000000000000000000000000000000000000;;			func(c int, odd uint) bool {
0000000000000000000000000000000000000000;;				return c > 0
0000000000000000000000000000000000000000;;			})}
0000000000000000000000000000000000000000;;		RoundHalfUp = rndr{true, roundHalf(
0000000000000000000000000000000000000000;;			func(c int, odd uint) bool {
0000000000000000000000000000000000000000;;				return c >= 0
0000000000000000000000000000000000000000;;			})}
0000000000000000000000000000000000000000;;		RoundHalfEven = rndr{true, roundHalf(
0000000000000000000000000000000000000000;;			func(c int, odd uint) bool {
0000000000000000000000000000000000000000;;				return c > 0 || c == 0 && odd == 1
0000000000000000000000000000000000000000;;			})}
0000000000000000000000000000000000000000;;	}
