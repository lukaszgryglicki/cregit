0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
ea5ce496739655bc10dc42138f80f7e34ba4dc2e;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package secretbox encrypts and authenticates small messages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Secretbox uses XSalsa20 and Poly1305 to encrypt and authenticate messages with
0000000000000000000000000000000000000000;;	secret-key cryptography. The length of messages is not hidden.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It is the caller's responsibility to ensure the uniqueness of noncesâ€”for
0000000000000000000000000000000000000000;;	example, by using nonce 1 for the first message, nonce 2 for the second
0000000000000000000000000000000000000000;;	message, etc. Nonces are long enough that randomly generated nonces have
0000000000000000000000000000000000000000;;	negligible risk of collision.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This package is interoperable with NaCl: https://nacl.cr.yp.to/secretbox.html.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package secretbox
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/poly1305"
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/salsa20/salsa"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Overhead is the number of bytes of overhead when boxing a message.
0000000000000000000000000000000000000000;;	const Overhead = poly1305.TagSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setup produces a sub-key and Salsa20 counter given a nonce and key.
0000000000000000000000000000000000000000;;	func setup(subKey *[32]byte, counter *[16]byte, nonce *[24]byte, key *[32]byte) {
0000000000000000000000000000000000000000;;		// We use XSalsa20 for encryption so first we need to generate a
0000000000000000000000000000000000000000;;		// key and nonce with HSalsa20.
0000000000000000000000000000000000000000;;		var hNonce [16]byte
0000000000000000000000000000000000000000;;		copy(hNonce[:], nonce[:])
0000000000000000000000000000000000000000;;		salsa.HSalsa20(subKey, &hNonce, key, &salsa.Sigma)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The final 8 bytes of the original nonce form the new nonce.
0000000000000000000000000000000000000000;;		copy(counter[:], nonce[16:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sliceForAppend takes a slice and a requested number of bytes. It returns a
0000000000000000000000000000000000000000;;	// slice with the contents of the given slice followed by that many bytes and a
0000000000000000000000000000000000000000;;	// second slice that aliases into it and contains only the extra bytes. If the
0000000000000000000000000000000000000000;;	// original slice has sufficient capacity then no allocation is performed.
0000000000000000000000000000000000000000;;	func sliceForAppend(in []byte, n int) (head, tail []byte) {
0000000000000000000000000000000000000000;;		if total := len(in) + n; cap(in) >= total {
0000000000000000000000000000000000000000;;			head = in[:total]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			head = make([]byte, total)
0000000000000000000000000000000000000000;;			copy(head, in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tail = head[len(in):]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Seal appends an encrypted and authenticated copy of message to out, which
0000000000000000000000000000000000000000;;	// must not overlap message. The key and nonce pair must be unique for each
0000000000000000000000000000000000000000;;	// distinct message and the output will be Overhead bytes longer than message.
0000000000000000000000000000000000000000;;	func Seal(out, message []byte, nonce *[24]byte, key *[32]byte) []byte {
0000000000000000000000000000000000000000;;		var subKey [32]byte
0000000000000000000000000000000000000000;;		var counter [16]byte
0000000000000000000000000000000000000000;;		setup(&subKey, &counter, nonce, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The Poly1305 key is generated by encrypting 32 bytes of zeros. Since
0000000000000000000000000000000000000000;;		// Salsa20 works with 64-byte blocks, we also generate 32 bytes of
0000000000000000000000000000000000000000;;		// keystream as a side effect.
0000000000000000000000000000000000000000;;		var firstBlock [64]byte
0000000000000000000000000000000000000000;;		salsa.XORKeyStream(firstBlock[:], firstBlock[:], &counter, &subKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var poly1305Key [32]byte
0000000000000000000000000000000000000000;;		copy(poly1305Key[:], firstBlock[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, out := sliceForAppend(out, len(message)+poly1305.TagSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We XOR up to 32 bytes of message with the keystream generated from
0000000000000000000000000000000000000000;;		// the first block.
0000000000000000000000000000000000000000;;		firstMessageBlock := message
0000000000000000000000000000000000000000;;		if len(firstMessageBlock) > 32 {
0000000000000000000000000000000000000000;;			firstMessageBlock = firstMessageBlock[:32]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tagOut := out
0000000000000000000000000000000000000000;;		out = out[poly1305.TagSize:]
0000000000000000000000000000000000000000;;		for i, x := range firstMessageBlock {
0000000000000000000000000000000000000000;;			out[i] = firstBlock[32+i] ^ x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		message = message[len(firstMessageBlock):]
0000000000000000000000000000000000000000;;		ciphertext := out
0000000000000000000000000000000000000000;;		out = out[len(firstMessageBlock):]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now encrypt the rest.
0000000000000000000000000000000000000000;;		counter[8] = 1
0000000000000000000000000000000000000000;;		salsa.XORKeyStream(out, message, &counter, &subKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tag [poly1305.TagSize]byte
0000000000000000000000000000000000000000;;		poly1305.Sum(&tag, ciphertext, &poly1305Key)
0000000000000000000000000000000000000000;;		copy(tagOut, tag[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Open authenticates and decrypts a box produced by Seal and appends the
0000000000000000000000000000000000000000;;	// message to out, which must not overlap box. The output will be Overhead
0000000000000000000000000000000000000000;;	// bytes smaller than box.
0000000000000000000000000000000000000000;;	func Open(out []byte, box []byte, nonce *[24]byte, key *[32]byte) ([]byte, bool) {
0000000000000000000000000000000000000000;;		if len(box) < Overhead {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var subKey [32]byte
0000000000000000000000000000000000000000;;		var counter [16]byte
0000000000000000000000000000000000000000;;		setup(&subKey, &counter, nonce, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The Poly1305 key is generated by encrypting 32 bytes of zeros. Since
0000000000000000000000000000000000000000;;		// Salsa20 works with 64-byte blocks, we also generate 32 bytes of
0000000000000000000000000000000000000000;;		// keystream as a side effect.
0000000000000000000000000000000000000000;;		var firstBlock [64]byte
0000000000000000000000000000000000000000;;		salsa.XORKeyStream(firstBlock[:], firstBlock[:], &counter, &subKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var poly1305Key [32]byte
0000000000000000000000000000000000000000;;		copy(poly1305Key[:], firstBlock[:])
0000000000000000000000000000000000000000;;		var tag [poly1305.TagSize]byte
0000000000000000000000000000000000000000;;		copy(tag[:], box)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !poly1305.Verify(&tag, box[poly1305.TagSize:], &poly1305Key) {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, out := sliceForAppend(out, len(box)-Overhead)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We XOR up to 32 bytes of box with the keystream generated from
0000000000000000000000000000000000000000;;		// the first block.
0000000000000000000000000000000000000000;;		box = box[Overhead:]
0000000000000000000000000000000000000000;;		firstMessageBlock := box
0000000000000000000000000000000000000000;;		if len(firstMessageBlock) > 32 {
0000000000000000000000000000000000000000;;			firstMessageBlock = firstMessageBlock[:32]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, x := range firstMessageBlock {
0000000000000000000000000000000000000000;;			out[i] = firstBlock[32+i] ^ x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		box = box[len(firstMessageBlock):]
0000000000000000000000000000000000000000;;		out = out[len(firstMessageBlock):]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now decrypt the rest.
0000000000000000000000000000000000000000;;		counter[8] = 1
0000000000000000000000000000000000000000;;		salsa.XORKeyStream(out, box, &counter, &subKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret, true
0000000000000000000000000000000000000000;;	}
