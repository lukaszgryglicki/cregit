0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/golang.org/x/crypto/bcrypt/bcrypt.go[Godeps/_workspace/src/golang.org/x/crypto/bcrypt/bcrypt.go][vendor/golang.org/x/crypto/bcrypt/bcrypt.go];	
0000000000000000000000000000000000000000;;	// Package bcrypt implements Provos and Mazières's bcrypt adaptive hashing
0000000000000000000000000000000000000000;;	// algorithm. See http://www.usenix.org/event/usenix99/provos/provos.pdf
0000000000000000000000000000000000000000;;	package bcrypt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The code is a port of Provos and Mazières's C implementation.
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/subtle"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/blowfish"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MinCost     int = 4  // the minimum allowable cost as passed in to GenerateFromPassword
0000000000000000000000000000000000000000;;		MaxCost     int = 31 // the maximum allowable cost as passed in to GenerateFromPassword
0000000000000000000000000000000000000000;;		DefaultCost int = 10 // the cost that will actually be set if a cost below MinCost is passed into GenerateFromPassword
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The error returned from CompareHashAndPassword when a password and hash do
0000000000000000000000000000000000000000;;	// not match.
0000000000000000000000000000000000000000;;	var ErrMismatchedHashAndPassword = errors.New("crypto/bcrypt: hashedPassword is not the hash of the given password")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The error returned from CompareHashAndPassword when a hash is too short to
0000000000000000000000000000000000000000;;	// be a bcrypt hash.
0000000000000000000000000000000000000000;;	var ErrHashTooShort = errors.New("crypto/bcrypt: hashedSecret too short to be a bcrypted password")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The error returned from CompareHashAndPassword when a hash was created with
0000000000000000000000000000000000000000;;	// a bcrypt algorithm newer than this implementation.
0000000000000000000000000000000000000000;;	type HashVersionTooNewError byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hv HashVersionTooNewError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("crypto/bcrypt: bcrypt algorithm version '%c' requested is newer than current version '%c'", byte(hv), majorVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The error returned from CompareHashAndPassword when a hash starts with something other than '$'
0000000000000000000000000000000000000000;;	type InvalidHashPrefixError byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ih InvalidHashPrefixError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("crypto/bcrypt: bcrypt hashes must start with '$', but hashedSecret started with '%c'", byte(ih))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InvalidCostError int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ic InvalidCostError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("crypto/bcrypt: cost %d is outside allowed range (%d,%d)", int(ic), int(MinCost), int(MaxCost))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		majorVersion       = '2'
0000000000000000000000000000000000000000;;		minorVersion       = 'a'
0000000000000000000000000000000000000000;;		maxSaltSize        = 16
0000000000000000000000000000000000000000;;		maxCryptedHashSize = 23
0000000000000000000000000000000000000000;;		encodedSaltSize    = 22
0000000000000000000000000000000000000000;;		encodedHashSize    = 31
0000000000000000000000000000000000000000;;		minHashSize        = 59
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// magicCipherData is an IV for the 64 Blowfish encryption calls in
0000000000000000000000000000000000000000;;	// bcrypt(). It's the string "OrpheanBeholderScryDoubt" in big-endian bytes.
0000000000000000000000000000000000000000;;	var magicCipherData = []byte{
0000000000000000000000000000000000000000;;		0x4f, 0x72, 0x70, 0x68,
0000000000000000000000000000000000000000;;		0x65, 0x61, 0x6e, 0x42,
0000000000000000000000000000000000000000;;		0x65, 0x68, 0x6f, 0x6c,
0000000000000000000000000000000000000000;;		0x64, 0x65, 0x72, 0x53,
0000000000000000000000000000000000000000;;		0x63, 0x72, 0x79, 0x44,
0000000000000000000000000000000000000000;;		0x6f, 0x75, 0x62, 0x74,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hashed struct {
0000000000000000000000000000000000000000;;		hash  []byte
0000000000000000000000000000000000000000;;		salt  []byte
0000000000000000000000000000000000000000;;		cost  int // allowed range is MinCost to MaxCost
0000000000000000000000000000000000000000;;		major byte
0000000000000000000000000000000000000000;;		minor byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateFromPassword returns the bcrypt hash of the password at the given
0000000000000000000000000000000000000000;;	// cost. If the cost given is less than MinCost, the cost will be set to
0000000000000000000000000000000000000000;;	// DefaultCost, instead. Use CompareHashAndPassword, as defined in this package,
0000000000000000000000000000000000000000;;	// to compare the returned hashed password with its cleartext version.
0000000000000000000000000000000000000000;;	func GenerateFromPassword(password []byte, cost int) ([]byte, error) {
0000000000000000000000000000000000000000;;		p, err := newFromPassword(password, cost)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.Hash(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompareHashAndPassword compares a bcrypt hashed password with its possible
0000000000000000000000000000000000000000;;	// plaintext equivalent. Returns nil on success, or an error on failure.
0000000000000000000000000000000000000000;;	func CompareHashAndPassword(hashedPassword, password []byte) error {
0000000000000000000000000000000000000000;;		p, err := newFromHash(hashedPassword)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		otherHash, err := bcrypt(password, p.cost, p.salt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		otherP := &hashed{otherHash, p.salt, p.cost, p.major, p.minor}
0000000000000000000000000000000000000000;;		if subtle.ConstantTimeCompare(p.Hash(), otherP.Hash()) == 1 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ErrMismatchedHashAndPassword
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cost returns the hashing cost used to create the given hashed
0000000000000000000000000000000000000000;;	// password. When, in the future, the hashing cost of a password system needs
0000000000000000000000000000000000000000;;	// to be increased in order to adjust for greater computational power, this
0000000000000000000000000000000000000000;;	// function allows one to establish which passwords need to be updated.
0000000000000000000000000000000000000000;;	func Cost(hashedPassword []byte) (int, error) {
0000000000000000000000000000000000000000;;		p, err := newFromHash(hashedPassword)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.cost, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFromPassword(password []byte, cost int) (*hashed, error) {
0000000000000000000000000000000000000000;;		if cost < MinCost {
0000000000000000000000000000000000000000;;			cost = DefaultCost
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := new(hashed)
0000000000000000000000000000000000000000;;		p.major = majorVersion
0000000000000000000000000000000000000000;;		p.minor = minorVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := checkCost(cost)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.cost = cost
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unencodedSalt := make([]byte, maxSaltSize)
0000000000000000000000000000000000000000;;		_, err = io.ReadFull(rand.Reader, unencodedSalt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.salt = base64Encode(unencodedSalt)
0000000000000000000000000000000000000000;;		hash, err := bcrypt(password, p.cost, p.salt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.hash = hash
0000000000000000000000000000000000000000;;		return p, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFromHash(hashedSecret []byte) (*hashed, error) {
0000000000000000000000000000000000000000;;		if len(hashedSecret) < minHashSize {
0000000000000000000000000000000000000000;;			return nil, ErrHashTooShort
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := new(hashed)
0000000000000000000000000000000000000000;;		n, err := p.decodeVersion(hashedSecret)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hashedSecret = hashedSecret[n:]
0000000000000000000000000000000000000000;;		n, err = p.decodeCost(hashedSecret)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hashedSecret = hashedSecret[n:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The "+2" is here because we'll have to append at most 2 '=' to the salt
0000000000000000000000000000000000000000;;		// when base64 decoding it in expensiveBlowfishSetup().
0000000000000000000000000000000000000000;;		p.salt = make([]byte, encodedSaltSize, encodedSaltSize+2)
0000000000000000000000000000000000000000;;		copy(p.salt, hashedSecret[:encodedSaltSize])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hashedSecret = hashedSecret[encodedSaltSize:]
0000000000000000000000000000000000000000;;		p.hash = make([]byte, len(hashedSecret))
0000000000000000000000000000000000000000;;		copy(p.hash, hashedSecret)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bcrypt(password []byte, cost int, salt []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		cipherData := make([]byte, len(magicCipherData))
0000000000000000000000000000000000000000;;		copy(cipherData, magicCipherData)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := expensiveBlowfishSetup(password, uint32(cost), salt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 24; i += 8 {
0000000000000000000000000000000000000000;;			for j := 0; j < 64; j++ {
0000000000000000000000000000000000000000;;				c.Encrypt(cipherData[i:i+8], cipherData[i:i+8])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bug compatibility with C bcrypt implementations. We only encode 23 of
0000000000000000000000000000000000000000;;		// the 24 bytes encrypted.
0000000000000000000000000000000000000000;;		hsh := base64Encode(cipherData[:maxCryptedHashSize])
0000000000000000000000000000000000000000;;		return hsh, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expensiveBlowfishSetup(key []byte, cost uint32, salt []byte) (*blowfish.Cipher, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		csalt, err := base64Decode(salt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bug compatibility with C bcrypt implementations. They use the trailing
0000000000000000000000000000000000000000;;		// NULL in the key string during expansion.
0000000000000000000000000000000000000000;;		ckey := append(key, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, err := blowfish.NewSaltedCipher(ckey, csalt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var i, rounds uint64
0000000000000000000000000000000000000000;;		rounds = 1 << cost
0000000000000000000000000000000000000000;;		for i = 0; i < rounds; i++ {
0000000000000000000000000000000000000000;;			blowfish.ExpandKey(ckey, c)
0000000000000000000000000000000000000000;;			blowfish.ExpandKey(csalt, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hashed) Hash() []byte {
0000000000000000000000000000000000000000;;		arr := make([]byte, 60)
0000000000000000000000000000000000000000;;		arr[0] = '$'
0000000000000000000000000000000000000000;;		arr[1] = p.major
0000000000000000000000000000000000000000;;		n := 2
0000000000000000000000000000000000000000;;		if p.minor != 0 {
0000000000000000000000000000000000000000;;			arr[2] = p.minor
0000000000000000000000000000000000000000;;			n = 3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		arr[n] = '$'
0000000000000000000000000000000000000000;;		n += 1
0000000000000000000000000000000000000000;;		copy(arr[n:], []byte(fmt.Sprintf("%02d", p.cost)))
0000000000000000000000000000000000000000;;		n += 2
0000000000000000000000000000000000000000;;		arr[n] = '$'
0000000000000000000000000000000000000000;;		n += 1
0000000000000000000000000000000000000000;;		copy(arr[n:], p.salt)
0000000000000000000000000000000000000000;;		n += encodedSaltSize
0000000000000000000000000000000000000000;;		copy(arr[n:], p.hash)
0000000000000000000000000000000000000000;;		n += encodedHashSize
0000000000000000000000000000000000000000;;		return arr[:n]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hashed) decodeVersion(sbytes []byte) (int, error) {
0000000000000000000000000000000000000000;;		if sbytes[0] != '$' {
0000000000000000000000000000000000000000;;			return -1, InvalidHashPrefixError(sbytes[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sbytes[1] > majorVersion {
0000000000000000000000000000000000000000;;			return -1, HashVersionTooNewError(sbytes[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.major = sbytes[1]
0000000000000000000000000000000000000000;;		n := 3
0000000000000000000000000000000000000000;;		if sbytes[2] != '$' {
0000000000000000000000000000000000000000;;			p.minor = sbytes[2]
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sbytes should begin where decodeVersion left off.
0000000000000000000000000000000000000000;;	func (p *hashed) decodeCost(sbytes []byte) (int, error) {
0000000000000000000000000000000000000000;;		cost, err := strconv.Atoi(string(sbytes[0:2]))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = checkCost(cost)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.cost = cost
0000000000000000000000000000000000000000;;		return 3, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *hashed) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("&{hash: %#v, salt: %#v, cost: %d, major: %c, minor: %c}", string(p.hash), p.salt, p.cost, p.major, p.minor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkCost(cost int) error {
0000000000000000000000000000000000000000;;		if cost < MinCost || cost > MaxCost {
0000000000000000000000000000000000000000;;			return InvalidCostError(cost)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
