0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/golang.org/x/crypto/bcrypt/base64.go[Godeps/_workspace/src/golang.org/x/crypto/bcrypt/base64.go][vendor/golang.org/x/crypto/bcrypt/base64.go];	
0000000000000000000000000000000000000000;;	package bcrypt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "encoding/base64"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const alphabet = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bcEncoding = base64.NewEncoding(alphabet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func base64Encode(src []byte) []byte {
0000000000000000000000000000000000000000;;		n := bcEncoding.EncodedLen(len(src))
0000000000000000000000000000000000000000;;		dst := make([]byte, n)
0000000000000000000000000000000000000000;;		bcEncoding.Encode(dst, src)
0000000000000000000000000000000000000000;;		for dst[n-1] == '=' {
0000000000000000000000000000000000000000;;			n--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dst[:n]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func base64Decode(src []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		numOfEquals := 4 - (len(src) % 4)
0000000000000000000000000000000000000000;;		for i := 0; i < numOfEquals; i++ {
0000000000000000000000000000000000000000;;			src = append(src, '=')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dst := make([]byte, bcEncoding.DecodedLen(len(src)))
0000000000000000000000000000000000000000;;		n, err := bcEncoding.Decode(dst, src)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dst[:n], nil
0000000000000000000000000000000000000000;;	}
