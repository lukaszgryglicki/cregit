0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	// +build amd64,!gccgo,!appengine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package curve25519
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These functions are implemented in the .s files. The names of the functions
0000000000000000000000000000000000000000;;	// in the rest of the file are also taken from the SUPERCOP sources to help
0000000000000000000000000000000000000000;;	// people following along.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:noescape
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cswap(inout *[5]uint64, v uint64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:noescape
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ladderstep(inout *[5][5]uint64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:noescape
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func freeze(inout *[5]uint64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:noescape
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mul(dest, a, b *[5]uint64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:noescape
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func square(out, in *[5]uint64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mladder uses a Montgomery ladder to calculate (xr/zr) *= s.
0000000000000000000000000000000000000000;;	func mladder(xr, zr *[5]uint64, s *[32]byte) {
0000000000000000000000000000000000000000;;		var work [5][5]uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		work[0] = *xr
0000000000000000000000000000000000000000;;		setint(&work[1], 1)
0000000000000000000000000000000000000000;;		setint(&work[2], 0)
0000000000000000000000000000000000000000;;		work[3] = *xr
0000000000000000000000000000000000000000;;		setint(&work[4], 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j := uint(6)
0000000000000000000000000000000000000000;;		var prevbit byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 31; i >= 0; i-- {
0000000000000000000000000000000000000000;;			for j < 8 {
0000000000000000000000000000000000000000;;				bit := ((*s)[i] >> j) & 1
0000000000000000000000000000000000000000;;				swap := bit ^ prevbit
0000000000000000000000000000000000000000;;				prevbit = bit
0000000000000000000000000000000000000000;;				cswap(&work[1], uint64(swap))
0000000000000000000000000000000000000000;;				ladderstep(&work)
0000000000000000000000000000000000000000;;				j--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			j = 7
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*xr = work[1]
0000000000000000000000000000000000000000;;		*zr = work[2]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scalarMult(out, in, base *[32]byte) {
0000000000000000000000000000000000000000;;		var e [32]byte
0000000000000000000000000000000000000000;;		copy(e[:], (*in)[:])
0000000000000000000000000000000000000000;;		e[0] &= 248
0000000000000000000000000000000000000000;;		e[31] &= 127
0000000000000000000000000000000000000000;;		e[31] |= 64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var t, z [5]uint64
0000000000000000000000000000000000000000;;		unpack(&t, base)
0000000000000000000000000000000000000000;;		mladder(&t, &z, &e)
0000000000000000000000000000000000000000;;		invert(&z, &z)
0000000000000000000000000000000000000000;;		mul(&t, &t, &z)
0000000000000000000000000000000000000000;;		pack(out, &t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setint(r *[5]uint64, v uint64) {
0000000000000000000000000000000000000000;;		r[0] = v
0000000000000000000000000000000000000000;;		r[1] = 0
0000000000000000000000000000000000000000;;		r[2] = 0
0000000000000000000000000000000000000000;;		r[3] = 0
0000000000000000000000000000000000000000;;		r[4] = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unpack sets r = x where r consists of 5, 51-bit limbs in little-endian
0000000000000000000000000000000000000000;;	// order.
0000000000000000000000000000000000000000;;	func unpack(r *[5]uint64, x *[32]byte) {
0000000000000000000000000000000000000000;;		r[0] = uint64(x[0]) |
0000000000000000000000000000000000000000;;			uint64(x[1])<<8 |
0000000000000000000000000000000000000000;;			uint64(x[2])<<16 |
0000000000000000000000000000000000000000;;			uint64(x[3])<<24 |
0000000000000000000000000000000000000000;;			uint64(x[4])<<32 |
0000000000000000000000000000000000000000;;			uint64(x[5])<<40 |
0000000000000000000000000000000000000000;;			uint64(x[6]&7)<<48
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r[1] = uint64(x[6])>>3 |
0000000000000000000000000000000000000000;;			uint64(x[7])<<5 |
0000000000000000000000000000000000000000;;			uint64(x[8])<<13 |
0000000000000000000000000000000000000000;;			uint64(x[9])<<21 |
0000000000000000000000000000000000000000;;			uint64(x[10])<<29 |
0000000000000000000000000000000000000000;;			uint64(x[11])<<37 |
0000000000000000000000000000000000000000;;			uint64(x[12]&63)<<45
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r[2] = uint64(x[12])>>6 |
0000000000000000000000000000000000000000;;			uint64(x[13])<<2 |
0000000000000000000000000000000000000000;;			uint64(x[14])<<10 |
0000000000000000000000000000000000000000;;			uint64(x[15])<<18 |
0000000000000000000000000000000000000000;;			uint64(x[16])<<26 |
0000000000000000000000000000000000000000;;			uint64(x[17])<<34 |
0000000000000000000000000000000000000000;;			uint64(x[18])<<42 |
0000000000000000000000000000000000000000;;			uint64(x[19]&1)<<50
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r[3] = uint64(x[19])>>1 |
0000000000000000000000000000000000000000;;			uint64(x[20])<<7 |
0000000000000000000000000000000000000000;;			uint64(x[21])<<15 |
0000000000000000000000000000000000000000;;			uint64(x[22])<<23 |
0000000000000000000000000000000000000000;;			uint64(x[23])<<31 |
0000000000000000000000000000000000000000;;			uint64(x[24])<<39 |
0000000000000000000000000000000000000000;;			uint64(x[25]&15)<<47
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r[4] = uint64(x[25])>>4 |
0000000000000000000000000000000000000000;;			uint64(x[26])<<4 |
0000000000000000000000000000000000000000;;			uint64(x[27])<<12 |
0000000000000000000000000000000000000000;;			uint64(x[28])<<20 |
0000000000000000000000000000000000000000;;			uint64(x[29])<<28 |
0000000000000000000000000000000000000000;;			uint64(x[30])<<36 |
0000000000000000000000000000000000000000;;			uint64(x[31]&127)<<44
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pack sets out = x where out is the usual, little-endian form of the 5,
0000000000000000000000000000000000000000;;	// 51-bit limbs in x.
0000000000000000000000000000000000000000;;	func pack(out *[32]byte, x *[5]uint64) {
0000000000000000000000000000000000000000;;		t := *x
0000000000000000000000000000000000000000;;		freeze(&t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out[0] = byte(t[0])
0000000000000000000000000000000000000000;;		out[1] = byte(t[0] >> 8)
0000000000000000000000000000000000000000;;		out[2] = byte(t[0] >> 16)
0000000000000000000000000000000000000000;;		out[3] = byte(t[0] >> 24)
0000000000000000000000000000000000000000;;		out[4] = byte(t[0] >> 32)
0000000000000000000000000000000000000000;;		out[5] = byte(t[0] >> 40)
0000000000000000000000000000000000000000;;		out[6] = byte(t[0] >> 48)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out[6] ^= byte(t[1]<<3) & 0xf8
0000000000000000000000000000000000000000;;		out[7] = byte(t[1] >> 5)
0000000000000000000000000000000000000000;;		out[8] = byte(t[1] >> 13)
0000000000000000000000000000000000000000;;		out[9] = byte(t[1] >> 21)
0000000000000000000000000000000000000000;;		out[10] = byte(t[1] >> 29)
0000000000000000000000000000000000000000;;		out[11] = byte(t[1] >> 37)
0000000000000000000000000000000000000000;;		out[12] = byte(t[1] >> 45)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out[12] ^= byte(t[2]<<6) & 0xc0
0000000000000000000000000000000000000000;;		out[13] = byte(t[2] >> 2)
0000000000000000000000000000000000000000;;		out[14] = byte(t[2] >> 10)
0000000000000000000000000000000000000000;;		out[15] = byte(t[2] >> 18)
0000000000000000000000000000000000000000;;		out[16] = byte(t[2] >> 26)
0000000000000000000000000000000000000000;;		out[17] = byte(t[2] >> 34)
0000000000000000000000000000000000000000;;		out[18] = byte(t[2] >> 42)
0000000000000000000000000000000000000000;;		out[19] = byte(t[2] >> 50)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out[19] ^= byte(t[3]<<1) & 0xfe
0000000000000000000000000000000000000000;;		out[20] = byte(t[3] >> 7)
0000000000000000000000000000000000000000;;		out[21] = byte(t[3] >> 15)
0000000000000000000000000000000000000000;;		out[22] = byte(t[3] >> 23)
0000000000000000000000000000000000000000;;		out[23] = byte(t[3] >> 31)
0000000000000000000000000000000000000000;;		out[24] = byte(t[3] >> 39)
0000000000000000000000000000000000000000;;		out[25] = byte(t[3] >> 47)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out[25] ^= byte(t[4]<<4) & 0xf0
0000000000000000000000000000000000000000;;		out[26] = byte(t[4] >> 4)
0000000000000000000000000000000000000000;;		out[27] = byte(t[4] >> 12)
0000000000000000000000000000000000000000;;		out[28] = byte(t[4] >> 20)
0000000000000000000000000000000000000000;;		out[29] = byte(t[4] >> 28)
0000000000000000000000000000000000000000;;		out[30] = byte(t[4] >> 36)
0000000000000000000000000000000000000000;;		out[31] = byte(t[4] >> 44)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// invert calculates r = x^-1 mod p using Fermat's little theorem.
0000000000000000000000000000000000000000;;	func invert(r *[5]uint64, x *[5]uint64) {
0000000000000000000000000000000000000000;;		var z2, z9, z11, z2_5_0, z2_10_0, z2_20_0, z2_50_0, z2_100_0, t [5]uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&z2, x)        /* 2 */
0000000000000000000000000000000000000000;;		square(&t, &z2)       /* 4 */
0000000000000000000000000000000000000000;;		square(&t, &t)        /* 8 */
0000000000000000000000000000000000000000;;		mul(&z9, &t, x)       /* 9 */
0000000000000000000000000000000000000000;;		mul(&z11, &z9, &z2)   /* 11 */
0000000000000000000000000000000000000000;;		square(&t, &z11)      /* 22 */
0000000000000000000000000000000000000000;;		mul(&z2_5_0, &t, &z9) /* 2^5 - 2^0 = 31 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&t, &z2_5_0)      /* 2^6 - 2^1 */
0000000000000000000000000000000000000000;;		for i := 1; i < 5; i++ { /* 2^20 - 2^10 */
0000000000000000000000000000000000000000;;			square(&t, &t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mul(&z2_10_0, &t, &z2_5_0) /* 2^10 - 2^0 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&t, &z2_10_0)      /* 2^11 - 2^1 */
0000000000000000000000000000000000000000;;		for i := 1; i < 10; i++ { /* 2^20 - 2^10 */
0000000000000000000000000000000000000000;;			square(&t, &t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mul(&z2_20_0, &t, &z2_10_0) /* 2^20 - 2^0 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&t, &z2_20_0)      /* 2^21 - 2^1 */
0000000000000000000000000000000000000000;;		for i := 1; i < 20; i++ { /* 2^40 - 2^20 */
0000000000000000000000000000000000000000;;			square(&t, &t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mul(&t, &t, &z2_20_0) /* 2^40 - 2^0 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&t, &t)            /* 2^41 - 2^1 */
0000000000000000000000000000000000000000;;		for i := 1; i < 10; i++ { /* 2^50 - 2^10 */
0000000000000000000000000000000000000000;;			square(&t, &t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mul(&z2_50_0, &t, &z2_10_0) /* 2^50 - 2^0 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&t, &z2_50_0)      /* 2^51 - 2^1 */
0000000000000000000000000000000000000000;;		for i := 1; i < 50; i++ { /* 2^100 - 2^50 */
0000000000000000000000000000000000000000;;			square(&t, &t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mul(&z2_100_0, &t, &z2_50_0) /* 2^100 - 2^0 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&t, &z2_100_0)      /* 2^101 - 2^1 */
0000000000000000000000000000000000000000;;		for i := 1; i < 100; i++ { /* 2^200 - 2^100 */
0000000000000000000000000000000000000000;;			square(&t, &t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mul(&t, &t, &z2_100_0) /* 2^200 - 2^0 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&t, &t)            /* 2^201 - 2^1 */
0000000000000000000000000000000000000000;;		for i := 1; i < 50; i++ { /* 2^250 - 2^50 */
0000000000000000000000000000000000000000;;			square(&t, &t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mul(&t, &t, &z2_50_0) /* 2^250 - 2^0 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&t, &t) /* 2^251 - 2^1 */
0000000000000000000000000000000000000000;;		square(&t, &t) /* 2^252 - 2^2 */
0000000000000000000000000000000000000000;;		square(&t, &t) /* 2^253 - 2^3 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&t, &t) /* 2^254 - 2^4 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		square(&t, &t)   /* 2^255 - 2^5 */
0000000000000000000000000000000000000000;;		mul(r, &t, &z11) /* 2^255 - 21 */
0000000000000000000000000000000000000000;;	}
