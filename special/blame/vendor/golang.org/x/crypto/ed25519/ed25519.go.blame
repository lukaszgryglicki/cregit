0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
9f682346087cfbb4ef0ef809569eecf5e61c29e8;;	
0000000000000000000000000000000000000000;;	// Package ed25519 implements the Ed25519 signature algorithm. See
0000000000000000000000000000000000000000;;	// http://ed25519.cr.yp.to/.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// These functions are also compatible with the “Ed25519” function defined in
0000000000000000000000000000000000000000;;	// https://tools.ietf.org/html/draft-irtf-cfrg-eddsa-05.
0000000000000000000000000000000000000000;;	package ed25519
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This code is a port of the public domain, “ref10” implementation of ed25519
0000000000000000000000000000000000000000;;	// from SUPERCOP.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		cryptorand "crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/sha512"
0000000000000000000000000000000000000000;;		"crypto/subtle"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/ed25519/internal/edwards25519"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PublicKeySize is the size, in bytes, of public keys as used in this package.
0000000000000000000000000000000000000000;;		PublicKeySize = 32
0000000000000000000000000000000000000000;;		// PrivateKeySize is the size, in bytes, of private keys as used in this package.
0000000000000000000000000000000000000000;;		PrivateKeySize = 64
0000000000000000000000000000000000000000;;		// SignatureSize is the size, in bytes, of signatures generated and verified by this package.
0000000000000000000000000000000000000000;;		SignatureSize = 64
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PublicKey is the type of Ed25519 public keys.
0000000000000000000000000000000000000000;;	type PublicKey []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer.
0000000000000000000000000000000000000000;;	type PrivateKey []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Public returns the PublicKey corresponding to priv.
0000000000000000000000000000000000000000;;	func (priv PrivateKey) Public() crypto.PublicKey {
0000000000000000000000000000000000000000;;		publicKey := make([]byte, PublicKeySize)
0000000000000000000000000000000000000000;;		copy(publicKey, priv[32:])
0000000000000000000000000000000000000000;;		return PublicKey(publicKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign signs the given message with priv.
0000000000000000000000000000000000000000;;	// Ed25519 performs two passes over messages to be signed and therefore cannot
0000000000000000000000000000000000000000;;	// handle pre-hashed messages. Thus opts.HashFunc() must return zero to
0000000000000000000000000000000000000000;;	// indicate the message hasn't been hashed. This can be achieved by passing
0000000000000000000000000000000000000000;;	// crypto.Hash(0) as the value for opts.
0000000000000000000000000000000000000000;;	func (priv PrivateKey) Sign(rand io.Reader, message []byte, opts crypto.SignerOpts) (signature []byte, err error) {
0000000000000000000000000000000000000000;;		if opts.HashFunc() != crypto.Hash(0) {
0000000000000000000000000000000000000000;;			return nil, errors.New("ed25519: cannot sign hashed message")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Sign(priv, message), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateKey generates a public/private key pair using entropy from rand.
0000000000000000000000000000000000000000;;	// If rand is nil, crypto/rand.Reader will be used.
0000000000000000000000000000000000000000;;	func GenerateKey(rand io.Reader) (publicKey PublicKey, privateKey PrivateKey, err error) {
0000000000000000000000000000000000000000;;		if rand == nil {
0000000000000000000000000000000000000000;;			rand = cryptorand.Reader
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		privateKey = make([]byte, PrivateKeySize)
0000000000000000000000000000000000000000;;		publicKey = make([]byte, PublicKeySize)
0000000000000000000000000000000000000000;;		_, err = io.ReadFull(rand, privateKey[:32])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		digest := sha512.Sum512(privateKey[:32])
0000000000000000000000000000000000000000;;		digest[0] &= 248
0000000000000000000000000000000000000000;;		digest[31] &= 127
0000000000000000000000000000000000000000;;		digest[31] |= 64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var A edwards25519.ExtendedGroupElement
0000000000000000000000000000000000000000;;		var hBytes [32]byte
0000000000000000000000000000000000000000;;		copy(hBytes[:], digest[:])
0000000000000000000000000000000000000000;;		edwards25519.GeScalarMultBase(&A, &hBytes)
0000000000000000000000000000000000000000;;		var publicKeyBytes [32]byte
0000000000000000000000000000000000000000;;		A.ToBytes(&publicKeyBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(privateKey[32:], publicKeyBytes[:])
0000000000000000000000000000000000000000;;		copy(publicKey, publicKeyBytes[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return publicKey, privateKey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign signs the message with privateKey and returns a signature. It will
0000000000000000000000000000000000000000;;	// panic if len(privateKey) is not PrivateKeySize.
0000000000000000000000000000000000000000;;	func Sign(privateKey PrivateKey, message []byte) []byte {
0000000000000000000000000000000000000000;;		if l := len(privateKey); l != PrivateKeySize {
0000000000000000000000000000000000000000;;			panic("ed25519: bad private key length: " + strconv.Itoa(l))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := sha512.New()
0000000000000000000000000000000000000000;;		h.Write(privateKey[:32])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var digest1, messageDigest, hramDigest [64]byte
0000000000000000000000000000000000000000;;		var expandedSecretKey [32]byte
0000000000000000000000000000000000000000;;		h.Sum(digest1[:0])
0000000000000000000000000000000000000000;;		copy(expandedSecretKey[:], digest1[:])
0000000000000000000000000000000000000000;;		expandedSecretKey[0] &= 248
0000000000000000000000000000000000000000;;		expandedSecretKey[31] &= 63
0000000000000000000000000000000000000000;;		expandedSecretKey[31] |= 64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h.Reset()
0000000000000000000000000000000000000000;;		h.Write(digest1[32:])
0000000000000000000000000000000000000000;;		h.Write(message)
0000000000000000000000000000000000000000;;		h.Sum(messageDigest[:0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var messageDigestReduced [32]byte
0000000000000000000000000000000000000000;;		edwards25519.ScReduce(&messageDigestReduced, &messageDigest)
0000000000000000000000000000000000000000;;		var R edwards25519.ExtendedGroupElement
0000000000000000000000000000000000000000;;		edwards25519.GeScalarMultBase(&R, &messageDigestReduced)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var encodedR [32]byte
0000000000000000000000000000000000000000;;		R.ToBytes(&encodedR)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h.Reset()
0000000000000000000000000000000000000000;;		h.Write(encodedR[:])
0000000000000000000000000000000000000000;;		h.Write(privateKey[32:])
0000000000000000000000000000000000000000;;		h.Write(message)
0000000000000000000000000000000000000000;;		h.Sum(hramDigest[:0])
0000000000000000000000000000000000000000;;		var hramDigestReduced [32]byte
0000000000000000000000000000000000000000;;		edwards25519.ScReduce(&hramDigestReduced, &hramDigest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var s [32]byte
0000000000000000000000000000000000000000;;		edwards25519.ScMulAdd(&s, &hramDigestReduced, &expandedSecretKey, &messageDigestReduced)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signature := make([]byte, SignatureSize)
0000000000000000000000000000000000000000;;		copy(signature[:], encodedR[:])
0000000000000000000000000000000000000000;;		copy(signature[32:], s[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return signature
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify reports whether sig is a valid signature of message by publicKey. It
0000000000000000000000000000000000000000;;	// will panic if len(publicKey) is not PublicKeySize.
0000000000000000000000000000000000000000;;	func Verify(publicKey PublicKey, message, sig []byte) bool {
0000000000000000000000000000000000000000;;		if l := len(publicKey); l != PublicKeySize {
0000000000000000000000000000000000000000;;			panic("ed25519: bad public key length: " + strconv.Itoa(l))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(sig) != SignatureSize || sig[63]&224 != 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var A edwards25519.ExtendedGroupElement
0000000000000000000000000000000000000000;;		var publicKeyBytes [32]byte
0000000000000000000000000000000000000000;;		copy(publicKeyBytes[:], publicKey)
0000000000000000000000000000000000000000;;		if !A.FromBytes(&publicKeyBytes) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		edwards25519.FeNeg(&A.X, &A.X)
0000000000000000000000000000000000000000;;		edwards25519.FeNeg(&A.T, &A.T)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := sha512.New()
0000000000000000000000000000000000000000;;		h.Write(sig[:32])
0000000000000000000000000000000000000000;;		h.Write(publicKey[:])
0000000000000000000000000000000000000000;;		h.Write(message)
0000000000000000000000000000000000000000;;		var digest [64]byte
0000000000000000000000000000000000000000;;		h.Sum(digest[:0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hReduced [32]byte
0000000000000000000000000000000000000000;;		edwards25519.ScReduce(&hReduced, &digest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var R edwards25519.ProjectiveGroupElement
0000000000000000000000000000000000000000;;		var b [32]byte
0000000000000000000000000000000000000000;;		copy(b[:], sig[32:])
0000000000000000000000000000000000000000;;		edwards25519.GeDoubleScalarMultVartime(&R, &hReduced, &A, &b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var checkR [32]byte
0000000000000000000000000000000000000000;;		R.ToBytes(&checkR)
0000000000000000000000000000000000000000;;		return subtle.ConstantTimeCompare(sig[:32], checkR[:]) == 1
0000000000000000000000000000000000000000;;	}
