0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
ea5ce496739655bc10dc42138f80f7e34ba4dc2e;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package poly1305 implements Poly1305 one-time message authentication code as specified in http://cr.yp.to/mac/poly1305-20050329.pdf.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Poly1305 is a fast, one-time authentication function. It is infeasible for an
0000000000000000000000000000000000000000;;	attacker to generate an authenticator for a message without the key. However, a
0000000000000000000000000000000000000000;;	key must only be used for a single message. Authenticating two different
0000000000000000000000000000000000000000;;	messages with the same key allows an attacker to forge authenticators for other
0000000000000000000000000000000000000000;;	messages with the same key.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Poly1305 was originally coupled with AES in order to make Poly1305-AES. AES was
0000000000000000000000000000000000000000;;	used with a fixed key in order to generate one-time keys from an nonce.
0000000000000000000000000000000000000000;;	However, in this package AES isn't used and the one-time key is specified
0000000000000000000000000000000000000000;;	directly.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package poly1305
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "crypto/subtle"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TagSize is the size, in bytes, of a poly1305 authenticator.
0000000000000000000000000000000000000000;;	const TagSize = 16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify returns true if mac is a valid authenticator for m with the given
0000000000000000000000000000000000000000;;	// key.
0000000000000000000000000000000000000000;;	func Verify(mac *[16]byte, m []byte, key *[32]byte) bool {
0000000000000000000000000000000000000000;;		var tmp [16]byte
0000000000000000000000000000000000000000;;		Sum(&tmp, m, key)
0000000000000000000000000000000000000000;;		return subtle.ConstantTimeCompare(tmp[:], mac[:]) == 1
0000000000000000000000000000000000000000;;	}
