0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	package pkcs12
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"unicode/utf16"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bmpString returns s encoded in UCS-2 with a zero terminator.
0000000000000000000000000000000000000000;;	func bmpString(s string) ([]byte, error) {
0000000000000000000000000000000000000000;;		// References:
0000000000000000000000000000000000000000;;		// https://tools.ietf.org/html/rfc7292#appendix-B.1
0000000000000000000000000000000000000000;;		// http://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane
0000000000000000000000000000000000000000;;		//  - non-BMP characters are encoded in UTF 16 by using a surrogate pair of 16-bit codes
0000000000000000000000000000000000000000;;		//	  EncodeRune returns 0xfffd if the rune does not need special encoding
0000000000000000000000000000000000000000;;		//  - the above RFC provides the info that BMPStrings are NULL terminated.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := make([]byte, 0, 2*len(s)+2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range s {
0000000000000000000000000000000000000000;;			if t, _ := utf16.EncodeRune(r); t != 0xfffd {
0000000000000000000000000000000000000000;;				return nil, errors.New("pkcs12: string contains characters that cannot be encoded in UCS-2")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret = append(ret, byte(r/256), byte(r%256))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return append(ret, 0, 0), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeBMPString(bmpString []byte) (string, error) {
0000000000000000000000000000000000000000;;		if len(bmpString)%2 != 0 {
0000000000000000000000000000000000000000;;			return "", errors.New("pkcs12: odd-length BMP string")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// strip terminator if present
0000000000000000000000000000000000000000;;		if l := len(bmpString); l >= 2 && bmpString[l-1] == 0 && bmpString[l-2] == 0 {
0000000000000000000000000000000000000000;;			bmpString = bmpString[:l-2]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := make([]uint16, 0, len(bmpString)/2)
0000000000000000000000000000000000000000;;		for len(bmpString) > 0 {
0000000000000000000000000000000000000000;;			s = append(s, uint16(bmpString[0])<<8+uint16(bmpString[1]))
0000000000000000000000000000000000000000;;			bmpString = bmpString[2:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(utf16.Decode(s)), nil
0000000000000000000000000000000000000000;;	}
