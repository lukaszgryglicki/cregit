0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	package pkcs12
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/cipher"
0000000000000000000000000000000000000000;;		"crypto/des"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/pkcs12/internal/rc2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		oidPBEWithSHAAnd3KeyTripleDESCBC = asn1.ObjectIdentifier([]int{1, 2, 840, 113549, 1, 12, 1, 3})
0000000000000000000000000000000000000000;;		oidPBEWithSHAAnd40BitRC2CBC      = asn1.ObjectIdentifier([]int{1, 2, 840, 113549, 1, 12, 1, 6})
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pbeCipher is an abstraction of a PKCS#12 cipher.
0000000000000000000000000000000000000000;;	type pbeCipher interface {
0000000000000000000000000000000000000000;;		// create returns a cipher.Block given a key.
0000000000000000000000000000000000000000;;		create(key []byte) (cipher.Block, error)
0000000000000000000000000000000000000000;;		// deriveKey returns a key derived from the given password and salt.
0000000000000000000000000000000000000000;;		deriveKey(salt, password []byte, iterations int) []byte
0000000000000000000000000000000000000000;;		// deriveKey returns an IV derived from the given password and salt.
0000000000000000000000000000000000000000;;		deriveIV(salt, password []byte, iterations int) []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type shaWithTripleDESCBC struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (shaWithTripleDESCBC) create(key []byte) (cipher.Block, error) {
0000000000000000000000000000000000000000;;		return des.NewTripleDESCipher(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (shaWithTripleDESCBC) deriveKey(salt, password []byte, iterations int) []byte {
0000000000000000000000000000000000000000;;		return pbkdf(sha1Sum, 20, 64, salt, password, iterations, 1, 24)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (shaWithTripleDESCBC) deriveIV(salt, password []byte, iterations int) []byte {
0000000000000000000000000000000000000000;;		return pbkdf(sha1Sum, 20, 64, salt, password, iterations, 2, 8)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type shaWith40BitRC2CBC struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (shaWith40BitRC2CBC) create(key []byte) (cipher.Block, error) {
0000000000000000000000000000000000000000;;		return rc2.New(key, len(key)*8)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (shaWith40BitRC2CBC) deriveKey(salt, password []byte, iterations int) []byte {
0000000000000000000000000000000000000000;;		return pbkdf(sha1Sum, 20, 64, salt, password, iterations, 1, 5)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (shaWith40BitRC2CBC) deriveIV(salt, password []byte, iterations int) []byte {
0000000000000000000000000000000000000000;;		return pbkdf(sha1Sum, 20, 64, salt, password, iterations, 2, 8)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pbeParams struct {
0000000000000000000000000000000000000000;;		Salt       []byte
0000000000000000000000000000000000000000;;		Iterations int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pbDecrypterFor(algorithm pkix.AlgorithmIdentifier, password []byte) (cipher.BlockMode, int, error) {
0000000000000000000000000000000000000000;;		var cipherType pbeCipher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case algorithm.Algorithm.Equal(oidPBEWithSHAAnd3KeyTripleDESCBC):
0000000000000000000000000000000000000000;;			cipherType = shaWithTripleDESCBC{}
0000000000000000000000000000000000000000;;		case algorithm.Algorithm.Equal(oidPBEWithSHAAnd40BitRC2CBC):
0000000000000000000000000000000000000000;;			cipherType = shaWith40BitRC2CBC{}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, 0, NotImplementedError("algorithm " + algorithm.Algorithm.String() + " is not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var params pbeParams
0000000000000000000000000000000000000000;;		if err := unmarshal(algorithm.Parameters.FullBytes, &params); err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := cipherType.deriveKey(params.Salt, password, params.Iterations)
0000000000000000000000000000000000000000;;		iv := cipherType.deriveIV(params.Salt, password, params.Iterations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		block, err := cipherType.create(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cipher.NewCBCDecrypter(block, iv), block.BlockSize(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pbDecrypt(info decryptable, password []byte) (decrypted []byte, err error) {
0000000000000000000000000000000000000000;;		cbc, blockSize, err := pbDecrypterFor(info.Algorithm(), password)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encrypted := info.Data()
0000000000000000000000000000000000000000;;		if len(encrypted) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("pkcs12: empty encrypted data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(encrypted)%blockSize != 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("pkcs12: input is not a multiple of the block size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decrypted = make([]byte, len(encrypted))
0000000000000000000000000000000000000000;;		cbc.CryptBlocks(decrypted, encrypted)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		psLen := int(decrypted[len(decrypted)-1])
0000000000000000000000000000000000000000;;		if psLen == 0 || psLen > blockSize {
0000000000000000000000000000000000000000;;			return nil, ErrDecryption
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(decrypted) < psLen {
0000000000000000000000000000000000000000;;			return nil, ErrDecryption
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ps := decrypted[len(decrypted)-psLen:]
0000000000000000000000000000000000000000;;		decrypted = decrypted[:len(decrypted)-psLen]
0000000000000000000000000000000000000000;;		if bytes.Compare(ps, bytes.Repeat([]byte{byte(psLen)}, psLen)) != 0 {
0000000000000000000000000000000000000000;;			return nil, ErrDecryption
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decryptable abstracts a object that contains ciphertext.
0000000000000000000000000000000000000000;;	type decryptable interface {
0000000000000000000000000000000000000000;;		Algorithm() pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		Data() []byte
0000000000000000000000000000000000000000;;	}
