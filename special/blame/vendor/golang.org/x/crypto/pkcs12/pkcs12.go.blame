0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	// Package pkcs12 implements some of PKCS#12.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This implementation is distilled from https://tools.ietf.org/html/rfc7292
0000000000000000000000000000000000000000;;	// and referenced documents. It is intended for decoding P12/PFX-stored
0000000000000000000000000000000000000000;;	// certificates and keys for use with the crypto/tls package.
0000000000000000000000000000000000000000;;	package pkcs12
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		oidDataContentType          = asn1.ObjectIdentifier([]int{1, 2, 840, 113549, 1, 7, 1})
0000000000000000000000000000000000000000;;		oidEncryptedDataContentType = asn1.ObjectIdentifier([]int{1, 2, 840, 113549, 1, 7, 6})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oidFriendlyName     = asn1.ObjectIdentifier([]int{1, 2, 840, 113549, 1, 9, 20})
0000000000000000000000000000000000000000;;		oidLocalKeyID       = asn1.ObjectIdentifier([]int{1, 2, 840, 113549, 1, 9, 21})
0000000000000000000000000000000000000000;;		oidMicrosoftCSPName = asn1.ObjectIdentifier([]int{1, 3, 6, 1, 4, 1, 311, 17, 1})
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pfxPdu struct {
0000000000000000000000000000000000000000;;		Version  int
0000000000000000000000000000000000000000;;		AuthSafe contentInfo
0000000000000000000000000000000000000000;;		MacData  macData `asn1:"optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type contentInfo struct {
0000000000000000000000000000000000000000;;		ContentType asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Content     asn1.RawValue `asn1:"tag:0,explicit,optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encryptedData struct {
0000000000000000000000000000000000000000;;		Version              int
0000000000000000000000000000000000000000;;		EncryptedContentInfo encryptedContentInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encryptedContentInfo struct {
0000000000000000000000000000000000000000;;		ContentType                asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		ContentEncryptionAlgorithm pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		EncryptedContent           []byte `asn1:"tag:0,optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i encryptedContentInfo) Algorithm() pkix.AlgorithmIdentifier {
0000000000000000000000000000000000000000;;		return i.ContentEncryptionAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i encryptedContentInfo) Data() []byte { return i.EncryptedContent }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type safeBag struct {
0000000000000000000000000000000000000000;;		Id         asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Value      asn1.RawValue     `asn1:"tag:0,explicit"`
0000000000000000000000000000000000000000;;		Attributes []pkcs12Attribute `asn1:"set,optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pkcs12Attribute struct {
0000000000000000000000000000000000000000;;		Id    asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Value asn1.RawValue `asn1:"set"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encryptedPrivateKeyInfo struct {
0000000000000000000000000000000000000000;;		AlgorithmIdentifier pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		EncryptedData       []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i encryptedPrivateKeyInfo) Algorithm() pkix.AlgorithmIdentifier {
0000000000000000000000000000000000000000;;		return i.AlgorithmIdentifier
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i encryptedPrivateKeyInfo) Data() []byte {
0000000000000000000000000000000000000000;;		return i.EncryptedData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PEM block types
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		certificateType = "CERTIFICATE"
0000000000000000000000000000000000000000;;		privateKeyType  = "PRIVATE KEY"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unmarshal calls asn1.Unmarshal, but also returns an error if there is any
0000000000000000000000000000000000000000;;	// trailing data after unmarshaling.
0000000000000000000000000000000000000000;;	func unmarshal(in []byte, out interface{}) error {
0000000000000000000000000000000000000000;;		trailing, err := asn1.Unmarshal(in, out)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(trailing) != 0 {
0000000000000000000000000000000000000000;;			return errors.New("pkcs12: trailing data found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertToPEM converts all "safe bags" contained in pfxData to PEM blocks.
0000000000000000000000000000000000000000;;	func ToPEM(pfxData []byte, password string) ([]*pem.Block, error) {
0000000000000000000000000000000000000000;;		encodedPassword, err := bmpString(password)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, ErrIncorrectPassword
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bags, encodedPassword, err := getSafeContents(pfxData, encodedPassword)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		blocks := make([]*pem.Block, 0, len(bags))
0000000000000000000000000000000000000000;;		for _, bag := range bags {
0000000000000000000000000000000000000000;;			block, err := convertBag(&bag, encodedPassword)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			blocks = append(blocks, block)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return blocks, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertBag(bag *safeBag, password []byte) (*pem.Block, error) {
0000000000000000000000000000000000000000;;		block := &pem.Block{
0000000000000000000000000000000000000000;;			Headers: make(map[string]string),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, attribute := range bag.Attributes {
0000000000000000000000000000000000000000;;			k, v, err := convertAttribute(&attribute)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			block.Headers[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case bag.Id.Equal(oidCertBag):
0000000000000000000000000000000000000000;;			block.Type = certificateType
0000000000000000000000000000000000000000;;			certsData, err := decodeCertBag(bag.Value.Bytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			block.Bytes = certsData
0000000000000000000000000000000000000000;;		case bag.Id.Equal(oidPKCS8ShroundedKeyBag):
0000000000000000000000000000000000000000;;			block.Type = privateKeyType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			key, err := decodePkcs8ShroudedKeyBag(bag.Value.Bytes, password)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch key := key.(type) {
0000000000000000000000000000000000000000;;			case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;				block.Bytes = x509.MarshalPKCS1PrivateKey(key)
0000000000000000000000000000000000000000;;			case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;				block.Bytes, err = x509.MarshalECPrivateKey(key)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, errors.New("found unknown private key type in PKCS#8 wrapping")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, errors.New("don't know how to convert a safe bag of type " + bag.Id.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return block, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertAttribute(attribute *pkcs12Attribute) (key, value string, err error) {
0000000000000000000000000000000000000000;;		isString := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case attribute.Id.Equal(oidFriendlyName):
0000000000000000000000000000000000000000;;			key = "friendlyName"
0000000000000000000000000000000000000000;;			isString = true
0000000000000000000000000000000000000000;;		case attribute.Id.Equal(oidLocalKeyID):
0000000000000000000000000000000000000000;;			key = "localKeyId"
0000000000000000000000000000000000000000;;		case attribute.Id.Equal(oidMicrosoftCSPName):
0000000000000000000000000000000000000000;;			// This key is chosen to match OpenSSL.
0000000000000000000000000000000000000000;;			key = "Microsoft CSP Name"
0000000000000000000000000000000000000000;;			isString = true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", "", errors.New("pkcs12: unknown attribute with OID " + attribute.Id.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isString {
0000000000000000000000000000000000000000;;			if err := unmarshal(attribute.Value.Bytes, &attribute.Value); err != nil {
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if value, err = decodeBMPString(attribute.Value.Bytes); err != nil {
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var id []byte
0000000000000000000000000000000000000000;;			if err := unmarshal(attribute.Value.Bytes, &id); err != nil {
0000000000000000000000000000000000000000;;				return "", "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value = hex.EncodeToString(id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return key, value, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode extracts a certificate and private key from pfxData. This function
0000000000000000000000000000000000000000;;	// assumes that there is only one certificate and only one private key in the
0000000000000000000000000000000000000000;;	// pfxData.
0000000000000000000000000000000000000000;;	func Decode(pfxData []byte, password string) (privateKey interface{}, certificate *x509.Certificate, err error) {
0000000000000000000000000000000000000000;;		encodedPassword, err := bmpString(password)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bags, encodedPassword, err := getSafeContents(pfxData, encodedPassword)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(bags) != 2 {
0000000000000000000000000000000000000000;;			err = errors.New("pkcs12: expected exactly two safe bags in the PFX PDU")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, bag := range bags {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case bag.Id.Equal(oidCertBag):
0000000000000000000000000000000000000000;;				if certificate != nil {
0000000000000000000000000000000000000000;;					err = errors.New("pkcs12: expected exactly one certificate bag")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				certsData, err := decodeCertBag(bag.Value.Bytes)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				certs, err := x509.ParseCertificates(certsData)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(certs) != 1 {
0000000000000000000000000000000000000000;;					err = errors.New("pkcs12: expected exactly one certificate in the certBag")
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				certificate = certs[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case bag.Id.Equal(oidPKCS8ShroundedKeyBag):
0000000000000000000000000000000000000000;;				if privateKey != nil {
0000000000000000000000000000000000000000;;					err = errors.New("pkcs12: expected exactly one key bag")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if privateKey, err = decodePkcs8ShroudedKeyBag(bag.Value.Bytes, encodedPassword); err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if certificate == nil {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("pkcs12: certificate missing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if privateKey == nil {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("pkcs12: private key missing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSafeContents(p12Data, password []byte) (bags []safeBag, updatedPassword []byte, err error) {
0000000000000000000000000000000000000000;;		pfx := new(pfxPdu)
0000000000000000000000000000000000000000;;		if err := unmarshal(p12Data, pfx); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("pkcs12: error reading P12 data: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pfx.Version != 3 {
0000000000000000000000000000000000000000;;			return nil, nil, NotImplementedError("can only decode v3 PFX PDU's")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !pfx.AuthSafe.ContentType.Equal(oidDataContentType) {
0000000000000000000000000000000000000000;;			return nil, nil, NotImplementedError("only password-protected PFX is implemented")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unmarshal the explicit bytes in the content for type 'data'
0000000000000000000000000000000000000000;;		if err := unmarshal(pfx.AuthSafe.Content.Bytes, &pfx.AuthSafe.Content); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(pfx.MacData.Mac.Algorithm.Algorithm) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("pkcs12: no MAC in data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := verifyMac(&pfx.MacData, pfx.AuthSafe.Content.Bytes, password); err != nil {
0000000000000000000000000000000000000000;;			if err == ErrIncorrectPassword && len(password) == 2 && password[0] == 0 && password[1] == 0 {
0000000000000000000000000000000000000000;;				// some implementations use an empty byte array
0000000000000000000000000000000000000000;;				// for the empty string password try one more
0000000000000000000000000000000000000000;;				// time with empty-empty password
0000000000000000000000000000000000000000;;				password = nil
0000000000000000000000000000000000000000;;				err = verifyMac(&pfx.MacData, pfx.AuthSafe.Content.Bytes, password)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var authenticatedSafe []contentInfo
0000000000000000000000000000000000000000;;		if err := unmarshal(pfx.AuthSafe.Content.Bytes, &authenticatedSafe); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(authenticatedSafe) != 2 {
0000000000000000000000000000000000000000;;			return nil, nil, NotImplementedError("expected exactly two items in the authenticated safe")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ci := range authenticatedSafe {
0000000000000000000000000000000000000000;;			var data []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case ci.ContentType.Equal(oidDataContentType):
0000000000000000000000000000000000000000;;				if err := unmarshal(ci.Content.Bytes, &data); err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case ci.ContentType.Equal(oidEncryptedDataContentType):
0000000000000000000000000000000000000000;;				var encryptedData encryptedData
0000000000000000000000000000000000000000;;				if err := unmarshal(ci.Content.Bytes, &encryptedData); err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if encryptedData.Version != 0 {
0000000000000000000000000000000000000000;;					return nil, nil, NotImplementedError("only version 0 of EncryptedData is supported")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if data, err = pbDecrypt(encryptedData.EncryptedContentInfo, password); err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, nil, NotImplementedError("only data and encryptedData content types are supported in authenticated safe")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var safeContents []safeBag
0000000000000000000000000000000000000000;;			if err := unmarshal(data, &safeContents); err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bags = append(bags, safeContents...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return bags, password, nil
0000000000000000000000000000000000000000;;	}
