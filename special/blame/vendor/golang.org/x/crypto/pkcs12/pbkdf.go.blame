0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	package pkcs12
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		one = big.NewInt(1)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sha1Sum returns the SHA-1 hash of in.
0000000000000000000000000000000000000000;;	func sha1Sum(in []byte) []byte {
0000000000000000000000000000000000000000;;		sum := sha1.Sum(in)
0000000000000000000000000000000000000000;;		return sum[:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fillWithRepeats returns v*ceiling(len(pattern) / v) bytes consisting of
0000000000000000000000000000000000000000;;	// repeats of pattern.
0000000000000000000000000000000000000000;;	func fillWithRepeats(pattern []byte, v int) []byte {
0000000000000000000000000000000000000000;;		if len(pattern) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		outputLen := v * ((len(pattern) + v - 1) / v)
0000000000000000000000000000000000000000;;		return bytes.Repeat(pattern, (outputLen+len(pattern)-1)/len(pattern))[:outputLen]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pbkdf(hash func([]byte) []byte, u, v int, salt, password []byte, r int, ID byte, size int) (key []byte) {
0000000000000000000000000000000000000000;;		// implementation of https://tools.ietf.org/html/rfc7292#appendix-B.2 , RFC text verbatim in comments
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    Let H be a hash function built around a compression function f:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//       Z_2^u x Z_2^v -> Z_2^u
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    (that is, H has a chaining variable and output of length u bits, and
0000000000000000000000000000000000000000;;		//    the message input to the compression function of H is v bits).  The
0000000000000000000000000000000000000000;;		//    values for u and v are as follows:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//            HASH FUNCTION     VALUE u        VALUE v
0000000000000000000000000000000000000000;;		//              MD2, MD5          128            512
0000000000000000000000000000000000000000;;		//                SHA-1           160            512
0000000000000000000000000000000000000000;;		//               SHA-224          224            512
0000000000000000000000000000000000000000;;		//               SHA-256          256            512
0000000000000000000000000000000000000000;;		//               SHA-384          384            1024
0000000000000000000000000000000000000000;;		//               SHA-512          512            1024
0000000000000000000000000000000000000000;;		//             SHA-512/224        224            1024
0000000000000000000000000000000000000000;;		//             SHA-512/256        256            1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    Furthermore, let r be the iteration count.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    We assume here that u and v are both multiples of 8, as are the
0000000000000000000000000000000000000000;;		//    lengths of the password and salt strings (which we denote by p and s,
0000000000000000000000000000000000000000;;		//    respectively) and the number n of pseudorandom bits required.  In
0000000000000000000000000000000000000000;;		//    addition, u and v are of course non-zero.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    For information on security considerations for MD5 [19], see [25] and
0000000000000000000000000000000000000000;;		//    [1], and on those for MD2, see [18].
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    The following procedure can be used to produce pseudorandom bits for
0000000000000000000000000000000000000000;;		//    a particular "purpose" that is identified by a byte called "ID".
0000000000000000000000000000000000000000;;		//    This standard specifies 3 different values for the ID byte:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    1.  If ID=1, then the pseudorandom bits being produced are to be used
0000000000000000000000000000000000000000;;		//        as key material for performing encryption or decryption.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    2.  If ID=2, then the pseudorandom bits being produced are to be used
0000000000000000000000000000000000000000;;		//        as an IV (Initial Value) for encryption or decryption.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    3.  If ID=3, then the pseudorandom bits being produced are to be used
0000000000000000000000000000000000000000;;		//        as an integrity key for MACing.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    1.  Construct a string, D (the "diversifier"), by concatenating v/8
0000000000000000000000000000000000000000;;		//        copies of ID.
0000000000000000000000000000000000000000;;		var D []byte
0000000000000000000000000000000000000000;;		for i := 0; i < v; i++ {
0000000000000000000000000000000000000000;;			D = append(D, ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    2.  Concatenate copies of the salt together to create a string S of
0000000000000000000000000000000000000000;;		//        length v(ceiling(s/v)) bits (the final copy of the salt may be
0000000000000000000000000000000000000000;;		//        truncated to create S).  Note that if the salt is the empty
0000000000000000000000000000000000000000;;		//        string, then so is S.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		S := fillWithRepeats(salt, v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    3.  Concatenate copies of the password together to create a string P
0000000000000000000000000000000000000000;;		//        of length v(ceiling(p/v)) bits (the final copy of the password
0000000000000000000000000000000000000000;;		//        may be truncated to create P).  Note that if the password is the
0000000000000000000000000000000000000000;;		//        empty string, then so is P.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		P := fillWithRepeats(password, v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    4.  Set I=S||P to be the concatenation of S and P.
0000000000000000000000000000000000000000;;		I := append(S, P...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    5.  Set c=ceiling(n/u).
0000000000000000000000000000000000000000;;		c := (size + u - 1) / u
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    6.  For i=1, 2, ..., c, do the following:
0000000000000000000000000000000000000000;;		A := make([]byte, c*20)
0000000000000000000000000000000000000000;;		var IjBuf []byte
0000000000000000000000000000000000000000;;		for i := 0; i < c; i++ {
0000000000000000000000000000000000000000;;			//        A.  Set A2=H^r(D||I). (i.e., the r-th hash of D||1,
0000000000000000000000000000000000000000;;			//            H(H(H(... H(D||I))))
0000000000000000000000000000000000000000;;			Ai := hash(append(D, I...))
0000000000000000000000000000000000000000;;			for j := 1; j < r; j++ {
0000000000000000000000000000000000000000;;				Ai = hash(Ai)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy(A[i*20:], Ai[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i < c-1 { // skip on last iteration
0000000000000000000000000000000000000000;;				// B.  Concatenate copies of Ai to create a string B of length v
0000000000000000000000000000000000000000;;				//     bits (the final copy of Ai may be truncated to create B).
0000000000000000000000000000000000000000;;				var B []byte
0000000000000000000000000000000000000000;;				for len(B) < v {
0000000000000000000000000000000000000000;;					B = append(B, Ai[:]...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				B = B[:v]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// C.  Treating I as a concatenation I_0, I_1, ..., I_(k-1) of v-bit
0000000000000000000000000000000000000000;;				//     blocks, where k=ceiling(s/v)+ceiling(p/v), modify I by
0000000000000000000000000000000000000000;;				//     setting I_j=(I_j+B+1) mod 2^v for each j.
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Bbi := new(big.Int).SetBytes(B)
0000000000000000000000000000000000000000;;					Ij := new(big.Int)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for j := 0; j < len(I)/v; j++ {
0000000000000000000000000000000000000000;;						Ij.SetBytes(I[j*v : (j+1)*v])
0000000000000000000000000000000000000000;;						Ij.Add(Ij, Bbi)
0000000000000000000000000000000000000000;;						Ij.Add(Ij, one)
0000000000000000000000000000000000000000;;						Ijb := Ij.Bytes()
0000000000000000000000000000000000000000;;						// We expect Ijb to be exactly v bytes,
0000000000000000000000000000000000000000;;						// if it is longer or shorter we must
0000000000000000000000000000000000000000;;						// adjust it accordingly.
0000000000000000000000000000000000000000;;						if len(Ijb) > v {
0000000000000000000000000000000000000000;;							Ijb = Ijb[len(Ijb)-v:]
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if len(Ijb) < v {
0000000000000000000000000000000000000000;;							if IjBuf == nil {
0000000000000000000000000000000000000000;;								IjBuf = make([]byte, v)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							bytesShort := v - len(Ijb)
0000000000000000000000000000000000000000;;							for i := 0; i < bytesShort; i++ {
0000000000000000000000000000000000000000;;								IjBuf[i] = 0
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							copy(IjBuf[bytesShort:], Ijb)
0000000000000000000000000000000000000000;;							Ijb = IjBuf
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						copy(I[j*v:(j+1)*v], Ijb)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		//    7.  Concatenate A_1, A_2, ..., A_c together to form a pseudorandom
0000000000000000000000000000000000000000;;		//        bit string, A.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    8.  Use the first n bits of A as the output of this entire process.
0000000000000000000000000000000000000000;;		return A[:size]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//    If the above process is being used to generate a DES key, the process
0000000000000000000000000000000000000000;;		//    should be used to create 64 random bits, and the key's parity bits
0000000000000000000000000000000000000000;;		//    should be set after the 64 bits have been produced.  Similar concerns
0000000000000000000000000000000000000000;;		//    hold for 2-key and 3-key triple-DES keys, for CDMF keys, and for any
0000000000000000000000000000000000000000;;		//    similar keys with parity bits "built into them".
0000000000000000000000000000000000000000;;	}
