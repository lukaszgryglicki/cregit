0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/buffer.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/buffer.go][vendor/golang.org/x/crypto/ssh/buffer.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buffer provides a linked list buffer for data exchange
0000000000000000000000000000000000000000;;	// between producer and consumer. Theoretically the buffer is
0000000000000000000000000000000000000000;;	// of unlimited capacity as it does no allocation of its own.
0000000000000000000000000000000000000000;;	type buffer struct {
0000000000000000000000000000000000000000;;		// protects concurrent access to head, tail and closed
0000000000000000000000000000000000000000;;		*sync.Cond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		head *element // the buffer that will be read first
0000000000000000000000000000000000000000;;		tail *element // the buffer that will be read last
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An element represents a single link in a linked list.
0000000000000000000000000000000000000000;;	type element struct {
0000000000000000000000000000000000000000;;		buf  []byte
0000000000000000000000000000000000000000;;		next *element
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newBuffer returns an empty buffer that is not closed.
0000000000000000000000000000000000000000;;	func newBuffer() *buffer {
0000000000000000000000000000000000000000;;		e := new(element)
0000000000000000000000000000000000000000;;		b := &buffer{
0000000000000000000000000000000000000000;;			Cond: newCond(),
0000000000000000000000000000000000000000;;			head: e,
0000000000000000000000000000000000000000;;			tail: e,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// write makes buf available for Read to receive.
0000000000000000000000000000000000000000;;	// buf must not be modified after the call to write.
0000000000000000000000000000000000000000;;	func (b *buffer) write(buf []byte) {
0000000000000000000000000000000000000000;;		b.Cond.L.Lock()
0000000000000000000000000000000000000000;;		e := &element{buf: buf}
0000000000000000000000000000000000000000;;		b.tail.next = e
0000000000000000000000000000000000000000;;		b.tail = e
0000000000000000000000000000000000000000;;		b.Cond.Signal()
0000000000000000000000000000000000000000;;		b.Cond.L.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// eof closes the buffer. Reads from the buffer once all
0000000000000000000000000000000000000000;;	// the data has been consumed will receive os.EOF.
0000000000000000000000000000000000000000;;	func (b *buffer) eof() error {
0000000000000000000000000000000000000000;;		b.Cond.L.Lock()
0000000000000000000000000000000000000000;;		b.closed = true
0000000000000000000000000000000000000000;;		b.Cond.Signal()
0000000000000000000000000000000000000000;;		b.Cond.L.Unlock()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads data from the internal buffer in buf.  Reads will block
0000000000000000000000000000000000000000;;	// if no data is available, or until the buffer is closed.
0000000000000000000000000000000000000000;;	func (b *buffer) Read(buf []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		b.Cond.L.Lock()
0000000000000000000000000000000000000000;;		defer b.Cond.L.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(buf) > 0 {
0000000000000000000000000000000000000000;;			// if there is data in b.head, copy it
0000000000000000000000000000000000000000;;			if len(b.head.buf) > 0 {
0000000000000000000000000000000000000000;;				r := copy(buf, b.head.buf)
0000000000000000000000000000000000000000;;				buf, b.head.buf = buf[r:], b.head.buf[r:]
0000000000000000000000000000000000000000;;				n += r
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if there is a next buffer, make it the head
0000000000000000000000000000000000000000;;			if len(b.head.buf) == 0 && b.head != b.tail {
0000000000000000000000000000000000000000;;				b.head = b.head.next
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if at least one byte has been copied, return
0000000000000000000000000000000000000000;;			if n > 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if nothing was read, and there is nothing outstanding
0000000000000000000000000000000000000000;;			// check to see if the buffer is closed.
0000000000000000000000000000000000000000;;			if b.closed {
0000000000000000000000000000000000000000;;				err = io.EOF
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// out of buffers, wait for producer
0000000000000000000000000000000000000000;;			b.Cond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
