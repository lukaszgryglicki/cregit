0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/mux.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/mux.go][vendor/golang.org/x/crypto/ssh/mux.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// debugMux, if set, causes messages in the connection protocol to be
0000000000000000000000000000000000000000;;	// logged.
0000000000000000000000000000000000000000;;	const debugMux = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// chanList is a thread safe channel list.
0000000000000000000000000000000000000000;;	type chanList struct {
0000000000000000000000000000000000000000;;		// protects concurrent access to chans
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// chans are indexed by the local id of the channel, which the
0000000000000000000000000000000000000000;;		// other side should send in the PeersId field.
0000000000000000000000000000000000000000;;		chans []*channel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is a debugging aid: it offsets all IDs by this
0000000000000000000000000000000000000000;;		// amount. This helps distinguish otherwise identical
0000000000000000000000000000000000000000;;		// server/client muxes
0000000000000000000000000000000000000000;;		offset uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assigns a channel ID to the given channel.
0000000000000000000000000000000000000000;;	func (c *chanList) add(ch *channel) uint32 {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		for i := range c.chans {
0000000000000000000000000000000000000000;;			if c.chans[i] == nil {
0000000000000000000000000000000000000000;;				c.chans[i] = ch
0000000000000000000000000000000000000000;;				return uint32(i) + c.offset
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.chans = append(c.chans, ch)
0000000000000000000000000000000000000000;;		return uint32(len(c.chans)-1) + c.offset
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getChan returns the channel for the given ID.
0000000000000000000000000000000000000000;;	func (c *chanList) getChan(id uint32) *channel {
0000000000000000000000000000000000000000;;		id -= c.offset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		if id < uint32(len(c.chans)) {
0000000000000000000000000000000000000000;;			return c.chans[id]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *chanList) remove(id uint32) {
0000000000000000000000000000000000000000;;		id -= c.offset
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		if id < uint32(len(c.chans)) {
0000000000000000000000000000000000000000;;			c.chans[id] = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dropAll forgets all channels it knows, returning them in a slice.
0000000000000000000000000000000000000000;;	func (c *chanList) dropAll() []*channel {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		var r []*channel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ch := range c.chans {
0000000000000000000000000000000000000000;;			if ch == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r = append(r, ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.chans = nil
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mux represents the state for the SSH connection protocol, which
0000000000000000000000000000000000000000;;	// multiplexes many channels onto a single packet transport.
0000000000000000000000000000000000000000;;	type mux struct {
0000000000000000000000000000000000000000;;		conn     packetConn
0000000000000000000000000000000000000000;;		chanList chanList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		incomingChannels chan NewChannel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		globalSentMu     sync.Mutex
0000000000000000000000000000000000000000;;		globalResponses  chan interface{}
0000000000000000000000000000000000000000;;		incomingRequests chan *Request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errCond *sync.Cond
0000000000000000000000000000000000000000;;		err     error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// When debugging, each new chanList instantiation has a different
0000000000000000000000000000000000000000;;	// offset.
0000000000000000000000000000000000000000;;	var globalOff uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mux) Wait() error {
0000000000000000000000000000000000000000;;		m.errCond.L.Lock()
0000000000000000000000000000000000000000;;		defer m.errCond.L.Unlock()
0000000000000000000000000000000000000000;;		for m.err == nil {
0000000000000000000000000000000000000000;;			m.errCond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newMux returns a mux that runs over the given connection.
0000000000000000000000000000000000000000;;	func newMux(p packetConn) *mux {
0000000000000000000000000000000000000000;;		m := &mux{
0000000000000000000000000000000000000000;;			conn:             p,
0000000000000000000000000000000000000000;;			incomingChannels: make(chan NewChannel, 16),
0000000000000000000000000000000000000000;;			globalResponses:  make(chan interface{}, 1),
0000000000000000000000000000000000000000;;			incomingRequests: make(chan *Request, 16),
0000000000000000000000000000000000000000;;			errCond:          newCond(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if debugMux {
0000000000000000000000000000000000000000;;			m.chanList.offset = atomic.AddUint32(&globalOff, 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go m.loop()
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mux) sendMessage(msg interface{}) error {
0000000000000000000000000000000000000000;;		p := Marshal(msg)
0000000000000000000000000000000000000000;;		if debugMux {
0000000000000000000000000000000000000000;;			log.Printf("send global(%d): %#v", m.chanList.offset, msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m.conn.writePacket(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mux) SendRequest(name string, wantReply bool, payload []byte) (bool, []byte, error) {
0000000000000000000000000000000000000000;;		if wantReply {
0000000000000000000000000000000000000000;;			m.globalSentMu.Lock()
0000000000000000000000000000000000000000;;			defer m.globalSentMu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := m.sendMessage(globalRequestMsg{
0000000000000000000000000000000000000000;;			Type:      name,
0000000000000000000000000000000000000000;;			WantReply: wantReply,
0000000000000000000000000000000000000000;;			Data:      payload,
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !wantReply {
0000000000000000000000000000000000000000;;			return false, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg, ok := <-m.globalResponses
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false, nil, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch msg := msg.(type) {
0000000000000000000000000000000000000000;;		case *globalRequestFailureMsg:
0000000000000000000000000000000000000000;;			return false, msg.Data, nil
0000000000000000000000000000000000000000;;		case *globalRequestSuccessMsg:
0000000000000000000000000000000000000000;;			return true, msg.Data, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false, nil, fmt.Errorf("ssh: unexpected response to request: %#v", msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ackRequest must be called after processing a global request that
0000000000000000000000000000000000000000;;	// has WantReply set.
0000000000000000000000000000000000000000;;	func (m *mux) ackRequest(ok bool, data []byte) error {
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return m.sendMessage(globalRequestSuccessMsg{Data: data})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m.sendMessage(globalRequestFailureMsg{Data: data})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mux) Close() error {
0000000000000000000000000000000000000000;;		return m.conn.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loop runs the connection machine. It will process packets until an
0000000000000000000000000000000000000000;;	// error is encountered. To synchronize on loop exit, use mux.Wait.
0000000000000000000000000000000000000000;;	func (m *mux) loop() {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for err == nil {
0000000000000000000000000000000000000000;;			err = m.onePacket()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ch := range m.chanList.dropAll() {
0000000000000000000000000000000000000000;;			ch.close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(m.incomingChannels)
0000000000000000000000000000000000000000;;		close(m.incomingRequests)
0000000000000000000000000000000000000000;;		close(m.globalResponses)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.errCond.L.Lock()
0000000000000000000000000000000000000000;;		m.err = err
0000000000000000000000000000000000000000;;		m.errCond.Broadcast()
0000000000000000000000000000000000000000;;		m.errCond.L.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if debugMux {
0000000000000000000000000000000000000000;;			log.Println("loop exit", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// onePacket reads and processes one packet.
0000000000000000000000000000000000000000;;	func (m *mux) onePacket() error {
0000000000000000000000000000000000000000;;		packet, err := m.conn.readPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if debugMux {
0000000000000000000000000000000000000000;;			if packet[0] == msgChannelData || packet[0] == msgChannelExtendedData {
0000000000000000000000000000000000000000;;				log.Printf("decoding(%d): data packet - %d bytes", m.chanList.offset, len(packet))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p, _ := decode(packet)
0000000000000000000000000000000000000000;;				log.Printf("decoding(%d): %d %#v - %d bytes", m.chanList.offset, packet[0], p, len(packet))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch packet[0] {
0000000000000000000000000000000000000000;;		case msgChannelOpen:
0000000000000000000000000000000000000000;;			return m.handleChannelOpen(packet)
0000000000000000000000000000000000000000;;		case msgGlobalRequest, msgRequestSuccess, msgRequestFailure:
0000000000000000000000000000000000000000;;			return m.handleGlobalPacket(packet)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// assume a channel packet.
0000000000000000000000000000000000000000;;		if len(packet) < 5 {
0000000000000000000000000000000000000000;;			return parseError(packet[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		id := binary.BigEndian.Uint32(packet[1:])
0000000000000000000000000000000000000000;;		ch := m.chanList.getChan(id)
0000000000000000000000000000000000000000;;		if ch == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: invalid channel %d", id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ch.handlePacket(packet)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mux) handleGlobalPacket(packet []byte) error {
0000000000000000000000000000000000000000;;		msg, err := decode(packet)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch msg := msg.(type) {
0000000000000000000000000000000000000000;;		case *globalRequestMsg:
0000000000000000000000000000000000000000;;			m.incomingRequests <- &Request{
0000000000000000000000000000000000000000;;				Type:      msg.Type,
0000000000000000000000000000000000000000;;				WantReply: msg.WantReply,
0000000000000000000000000000000000000000;;				Payload:   msg.Data,
0000000000000000000000000000000000000000;;				mux:       m,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *globalRequestSuccessMsg, *globalRequestFailureMsg:
0000000000000000000000000000000000000000;;			m.globalResponses <- msg
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("not a global message %#v", msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleChannelOpen schedules a channel to be Accept()ed.
0000000000000000000000000000000000000000;;	func (m *mux) handleChannelOpen(packet []byte) error {
0000000000000000000000000000000000000000;;		var msg channelOpenMsg
0000000000000000000000000000000000000000;;		if err := Unmarshal(packet, &msg); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if msg.MaxPacketSize < minPacketLength || msg.MaxPacketSize > 1<<31 {
0000000000000000000000000000000000000000;;			failMsg := channelOpenFailureMsg{
0000000000000000000000000000000000000000;;				PeersId:  msg.PeersId,
0000000000000000000000000000000000000000;;				Reason:   ConnectionFailed,
0000000000000000000000000000000000000000;;				Message:  "invalid request",
0000000000000000000000000000000000000000;;				Language: "en_US.UTF-8",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return m.sendMessage(failMsg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := m.newChannel(msg.ChanType, channelInbound, msg.TypeSpecificData)
0000000000000000000000000000000000000000;;		c.remoteId = msg.PeersId
0000000000000000000000000000000000000000;;		c.maxRemotePayload = msg.MaxPacketSize
0000000000000000000000000000000000000000;;		c.remoteWin.add(msg.PeersWindow)
0000000000000000000000000000000000000000;;		m.incomingChannels <- c
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mux) OpenChannel(chanType string, extra []byte) (Channel, <-chan *Request, error) {
0000000000000000000000000000000000000000;;		ch, err := m.openChannel(chanType, extra)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ch, ch.incomingRequests, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mux) openChannel(chanType string, extra []byte) (*channel, error) {
0000000000000000000000000000000000000000;;		ch := m.newChannel(chanType, channelOutbound, extra)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch.maxIncomingPayload = channelMaxPacket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		open := channelOpenMsg{
0000000000000000000000000000000000000000;;			ChanType:         chanType,
0000000000000000000000000000000000000000;;			PeersWindow:      ch.myWindow,
0000000000000000000000000000000000000000;;			MaxPacketSize:    ch.maxIncomingPayload,
0000000000000000000000000000000000000000;;			TypeSpecificData: extra,
0000000000000000000000000000000000000000;;			PeersId:          ch.localId,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := m.sendMessage(open); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch msg := (<-ch.msg).(type) {
0000000000000000000000000000000000000000;;		case *channelOpenConfirmMsg:
0000000000000000000000000000000000000000;;			return ch, nil
0000000000000000000000000000000000000000;;		case *channelOpenFailureMsg:
0000000000000000000000000000000000000000;;			return nil, &OpenChannelError{msg.Reason, msg.Message}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ssh: unexpected packet in response to channel open: %T", msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
