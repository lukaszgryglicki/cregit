0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/cipher.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/cipher.go][vendor/golang.org/x/crypto/ssh/cipher.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/aes"
0000000000000000000000000000000000000000;;		"crypto/cipher"
0000000000000000000000000000000000000000;;		"crypto/des"
0000000000000000000000000000000000000000;;		"crypto/rc4"
0000000000000000000000000000000000000000;;		"crypto/subtle"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		packetSizeMultiple = 16 // TODO(huin) this should be determined by the cipher.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RFC 4253 section 6.1 defines a minimum packet size of 32768 that implementations
0000000000000000000000000000000000000000;;		// MUST be able to process (plus a few more kilobytes for padding and mac). The RFC
0000000000000000000000000000000000000000;;		// indicates implementations SHOULD be able to handle larger packet sizes, but then
0000000000000000000000000000000000000000;;		// waffles on about reasonable limits.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// OpenSSH caps their maxPacket at 256kB so we choose to do
0000000000000000000000000000000000000000;;		// the same. maxPacket is also used to ensure that uint32
0000000000000000000000000000000000000000;;		// length fields do not overflow, so it should remain well
0000000000000000000000000000000000000000;;		// below 4G.
0000000000000000000000000000000000000000;;		maxPacket = 256 * 1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// noneCipher implements cipher.Stream and provides no encryption. It is used
0000000000000000000000000000000000000000;;	// by the transport before the first key-exchange.
0000000000000000000000000000000000000000;;	type noneCipher struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c noneCipher) XORKeyStream(dst, src []byte) {
0000000000000000000000000000000000000000;;		copy(dst, src)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAESCTR(key, iv []byte) (cipher.Stream, error) {
0000000000000000000000000000000000000000;;		c, err := aes.NewCipher(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cipher.NewCTR(c, iv), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRC4(key, iv []byte) (cipher.Stream, error) {
0000000000000000000000000000000000000000;;		return rc4.NewCipher(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type streamCipherMode struct {
0000000000000000000000000000000000000000;;		keySize    int
0000000000000000000000000000000000000000;;		ivSize     int
0000000000000000000000000000000000000000;;		skip       int
0000000000000000000000000000000000000000;;		createFunc func(key, iv []byte) (cipher.Stream, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *streamCipherMode) createStream(key, iv []byte) (cipher.Stream, error) {
0000000000000000000000000000000000000000;;		if len(key) < c.keySize {
0000000000000000000000000000000000000000;;			panic("ssh: key length too small for cipher")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(iv) < c.ivSize {
0000000000000000000000000000000000000000;;			panic("ssh: iv too small for cipher")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream, err := c.createFunc(key[:c.keySize], iv[:c.ivSize])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var streamDump []byte
0000000000000000000000000000000000000000;;		if c.skip > 0 {
0000000000000000000000000000000000000000;;			streamDump = make([]byte, 512)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for remainingToDump := c.skip; remainingToDump > 0; {
0000000000000000000000000000000000000000;;			dumpThisTime := remainingToDump
0000000000000000000000000000000000000000;;			if dumpThisTime > len(streamDump) {
0000000000000000000000000000000000000000;;				dumpThisTime = len(streamDump)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stream.XORKeyStream(streamDump[:dumpThisTime], streamDump[:dumpThisTime])
0000000000000000000000000000000000000000;;			remainingToDump -= dumpThisTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stream, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cipherModes documents properties of supported ciphers. Ciphers not included
0000000000000000000000000000000000000000;;	// are not supported and will not be negotiated, even if explicitly requested in
0000000000000000000000000000000000000000;;	// ClientConfig.Crypto.Ciphers.
0000000000000000000000000000000000000000;;	var cipherModes = map[string]*streamCipherMode{
0000000000000000000000000000000000000000;;		// Ciphers from RFC4344, which introduced many CTR-based ciphers. Algorithms
0000000000000000000000000000000000000000;;		// are defined in the order specified in the RFC.
0000000000000000000000000000000000000000;;		"aes128-ctr": {16, aes.BlockSize, 0, newAESCTR},
0000000000000000000000000000000000000000;;		"aes192-ctr": {24, aes.BlockSize, 0, newAESCTR},
0000000000000000000000000000000000000000;;		"aes256-ctr": {32, aes.BlockSize, 0, newAESCTR},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ciphers from RFC4345, which introduces security-improved arcfour ciphers.
0000000000000000000000000000000000000000;;		// They are defined in the order specified in the RFC.
0000000000000000000000000000000000000000;;		"arcfour128": {16, 0, 1536, newRC4},
0000000000000000000000000000000000000000;;		"arcfour256": {32, 0, 1536, newRC4},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cipher defined in RFC 4253, which describes SSH Transport Layer Protocol.
0000000000000000000000000000000000000000;;		// Note that this cipher is not safe, as stated in RFC 4253: "Arcfour (and
0000000000000000000000000000000000000000;;		// RC4) has problems with weak keys, and should be used with caution."
0000000000000000000000000000000000000000;;		// RFC4345 introduces improved versions of Arcfour.
0000000000000000000000000000000000000000;;		"arcfour": {16, 0, 0, newRC4},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AES-GCM is not a stream cipher, so it is constructed with a
0000000000000000000000000000000000000000;;		// special case. If we add any more non-stream ciphers, we
0000000000000000000000000000000000000000;;		// should invest a cleaner way to do this.
0000000000000000000000000000000000000000;;		gcmCipherID: {16, 12, 0, nil},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CBC mode is insecure and so is not included in the default config.
0000000000000000000000000000000000000000;;		// (See http://www.isg.rhul.ac.uk/~kp/SandPfinal.pdf). If absolutely
0000000000000000000000000000000000000000;;		// needed, it's possible to specify a custom Config to enable it.
0000000000000000000000000000000000000000;;		// You should expect that an active attacker can recover plaintext if
0000000000000000000000000000000000000000;;		// you do.
0000000000000000000000000000000000000000;;		aes128cbcID: {16, aes.BlockSize, 0, nil},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 3des-cbc is insecure and is disabled by default.
0000000000000000000000000000000000000000;;		tripledescbcID: {24, des.BlockSize, 0, nil},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prefixLen is the length of the packet prefix that contains the packet length
0000000000000000000000000000000000000000;;	// and number of padding bytes.
0000000000000000000000000000000000000000;;	const prefixLen = 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamPacketCipher is a packetCipher using a stream cipher.
0000000000000000000000000000000000000000;;	type streamPacketCipher struct {
0000000000000000000000000000000000000000;;		mac    hash.Hash
0000000000000000000000000000000000000000;;		cipher cipher.Stream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The following members are to avoid per-packet allocations.
0000000000000000000000000000000000000000;;		prefix      [prefixLen]byte
0000000000000000000000000000000000000000;;		seqNumBytes [4]byte
0000000000000000000000000000000000000000;;		padding     [2 * packetSizeMultiple]byte
0000000000000000000000000000000000000000;;		packetData  []byte
0000000000000000000000000000000000000000;;		macResult   []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readPacket reads and decrypt a single packet from the reader argument.
0000000000000000000000000000000000000000;;	func (s *streamPacketCipher) readPacket(seqNum uint32, r io.Reader) ([]byte, error) {
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(r, s.prefix[:]); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.cipher.XORKeyStream(s.prefix[:], s.prefix[:])
0000000000000000000000000000000000000000;;		length := binary.BigEndian.Uint32(s.prefix[0:4])
0000000000000000000000000000000000000000;;		paddingLength := uint32(s.prefix[4])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var macSize uint32
0000000000000000000000000000000000000000;;		if s.mac != nil {
0000000000000000000000000000000000000000;;			s.mac.Reset()
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(s.seqNumBytes[:], seqNum)
0000000000000000000000000000000000000000;;			s.mac.Write(s.seqNumBytes[:])
0000000000000000000000000000000000000000;;			s.mac.Write(s.prefix[:])
0000000000000000000000000000000000000000;;			macSize = uint32(s.mac.Size())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if length <= paddingLength+1 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: invalid packet length, packet too small")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if length > maxPacket {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: invalid packet length, packet too large")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the maxPacket check above ensures that length-1+macSize
0000000000000000000000000000000000000000;;		// does not overflow.
0000000000000000000000000000000000000000;;		if uint32(cap(s.packetData)) < length-1+macSize {
0000000000000000000000000000000000000000;;			s.packetData = make([]byte, length-1+macSize)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.packetData = s.packetData[:length-1+macSize]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(r, s.packetData); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mac := s.packetData[length-1:]
0000000000000000000000000000000000000000;;		data := s.packetData[:length-1]
0000000000000000000000000000000000000000;;		s.cipher.XORKeyStream(data, data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.mac != nil {
0000000000000000000000000000000000000000;;			s.mac.Write(data)
0000000000000000000000000000000000000000;;			s.macResult = s.mac.Sum(s.macResult[:0])
0000000000000000000000000000000000000000;;			if subtle.ConstantTimeCompare(s.macResult, mac) != 1 {
0000000000000000000000000000000000000000;;				return nil, errors.New("ssh: MAC failure")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.packetData[:length-paddingLength-1], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writePacket encrypts and sends a packet of data to the writer argument
0000000000000000000000000000000000000000;;	func (s *streamPacketCipher) writePacket(seqNum uint32, w io.Writer, rand io.Reader, packet []byte) error {
0000000000000000000000000000000000000000;;		if len(packet) > maxPacket {
0000000000000000000000000000000000000000;;			return errors.New("ssh: packet too large")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		paddingLength := packetSizeMultiple - (prefixLen+len(packet))%packetSizeMultiple
0000000000000000000000000000000000000000;;		if paddingLength < 4 {
0000000000000000000000000000000000000000;;			paddingLength += packetSizeMultiple
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		length := len(packet) + 1 + paddingLength
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(s.prefix[:], uint32(length))
0000000000000000000000000000000000000000;;		s.prefix[4] = byte(paddingLength)
0000000000000000000000000000000000000000;;		padding := s.padding[:paddingLength]
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rand, padding); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.mac != nil {
0000000000000000000000000000000000000000;;			s.mac.Reset()
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(s.seqNumBytes[:], seqNum)
0000000000000000000000000000000000000000;;			s.mac.Write(s.seqNumBytes[:])
0000000000000000000000000000000000000000;;			s.mac.Write(s.prefix[:])
0000000000000000000000000000000000000000;;			s.mac.Write(packet)
0000000000000000000000000000000000000000;;			s.mac.Write(padding)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.cipher.XORKeyStream(s.prefix[:], s.prefix[:])
0000000000000000000000000000000000000000;;		s.cipher.XORKeyStream(packet, packet)
0000000000000000000000000000000000000000;;		s.cipher.XORKeyStream(padding, padding)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := w.Write(s.prefix[:]); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := w.Write(packet); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := w.Write(padding); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.mac != nil {
0000000000000000000000000000000000000000;;			s.macResult = s.mac.Sum(s.macResult[:0])
0000000000000000000000000000000000000000;;			if _, err := w.Write(s.macResult); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type gcmCipher struct {
0000000000000000000000000000000000000000;;		aead   cipher.AEAD
0000000000000000000000000000000000000000;;		prefix [4]byte
0000000000000000000000000000000000000000;;		iv     []byte
0000000000000000000000000000000000000000;;		buf    []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newGCMCipher(iv, key, macKey []byte) (packetCipher, error) {
0000000000000000000000000000000000000000;;		c, err := aes.NewCipher(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aead, err := cipher.NewGCM(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &gcmCipher{
0000000000000000000000000000000000000000;;			aead: aead,
0000000000000000000000000000000000000000;;			iv:   iv,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const gcmTagSize = 16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *gcmCipher) writePacket(seqNum uint32, w io.Writer, rand io.Reader, packet []byte) error {
0000000000000000000000000000000000000000;;		// Pad out to multiple of 16 bytes. This is different from the
0000000000000000000000000000000000000000;;		// stream cipher because that encrypts the length too.
0000000000000000000000000000000000000000;;		padding := byte(packetSizeMultiple - (1+len(packet))%packetSizeMultiple)
0000000000000000000000000000000000000000;;		if padding < 4 {
0000000000000000000000000000000000000000;;			padding += packetSizeMultiple
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		length := uint32(len(packet) + int(padding) + 1)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(c.prefix[:], length)
0000000000000000000000000000000000000000;;		if _, err := w.Write(c.prefix[:]); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cap(c.buf) < int(length) {
0000000000000000000000000000000000000000;;			c.buf = make([]byte, length)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.buf = c.buf[:length]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.buf[0] = padding
0000000000000000000000000000000000000000;;		copy(c.buf[1:], packet)
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rand, c.buf[1+len(packet):]); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.buf = c.aead.Seal(c.buf[:0], c.iv, c.buf, c.prefix[:])
0000000000000000000000000000000000000000;;		if _, err := w.Write(c.buf); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.incIV()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *gcmCipher) incIV() {
0000000000000000000000000000000000000000;;		for i := 4 + 7; i >= 4; i-- {
0000000000000000000000000000000000000000;;			c.iv[i]++
0000000000000000000000000000000000000000;;			if c.iv[i] != 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *gcmCipher) readPacket(seqNum uint32, r io.Reader) ([]byte, error) {
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(r, c.prefix[:]); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		length := binary.BigEndian.Uint32(c.prefix[:])
0000000000000000000000000000000000000000;;		if length > maxPacket {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: max packet length exceeded.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cap(c.buf) < int(length+gcmTagSize) {
0000000000000000000000000000000000000000;;			c.buf = make([]byte, length+gcmTagSize)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.buf = c.buf[:length+gcmTagSize]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(r, c.buf); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plain, err := c.aead.Open(c.buf[:0], c.iv, c.buf, c.prefix[:])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.incIV()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		padding := plain[0]
0000000000000000000000000000000000000000;;		if padding < 4 || padding >= 20 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ssh: illegal padding %d", padding)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if int(padding+1) >= len(plain) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ssh: padding %d too large", padding)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plain = plain[1 : length-uint32(padding)]
0000000000000000000000000000000000000000;;		return plain, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cbcCipher implements aes128-cbc cipher defined in RFC 4253 section 6.1
0000000000000000000000000000000000000000;;	type cbcCipher struct {
0000000000000000000000000000000000000000;;		mac       hash.Hash
0000000000000000000000000000000000000000;;		macSize   uint32
0000000000000000000000000000000000000000;;		decrypter cipher.BlockMode
0000000000000000000000000000000000000000;;		encrypter cipher.BlockMode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The following members are to avoid per-packet allocations.
0000000000000000000000000000000000000000;;		seqNumBytes [4]byte
0000000000000000000000000000000000000000;;		packetData  []byte
0000000000000000000000000000000000000000;;		macResult   []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Amount of data we should still read to hide which
0000000000000000000000000000000000000000;;		// verification error triggered.
0000000000000000000000000000000000000000;;		oracleCamouflage uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCBCCipher(c cipher.Block, iv, key, macKey []byte, algs directionAlgorithms) (packetCipher, error) {
0000000000000000000000000000000000000000;;		cbc := &cbcCipher{
0000000000000000000000000000000000000000;;			mac:        macModes[algs.MAC].new(macKey),
0000000000000000000000000000000000000000;;			decrypter:  cipher.NewCBCDecrypter(c, iv),
0000000000000000000000000000000000000000;;			encrypter:  cipher.NewCBCEncrypter(c, iv),
0000000000000000000000000000000000000000;;			packetData: make([]byte, 1024),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cbc.mac != nil {
0000000000000000000000000000000000000000;;			cbc.macSize = uint32(cbc.mac.Size())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cbc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAESCBCCipher(iv, key, macKey []byte, algs directionAlgorithms) (packetCipher, error) {
0000000000000000000000000000000000000000;;		c, err := aes.NewCipher(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cbc, err := newCBCCipher(c, iv, key, macKey, algs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cbc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTripleDESCBCCipher(iv, key, macKey []byte, algs directionAlgorithms) (packetCipher, error) {
0000000000000000000000000000000000000000;;		c, err := des.NewTripleDESCipher(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cbc, err := newCBCCipher(c, iv, key, macKey, algs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cbc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func maxUInt32(a, b int) uint32 {
0000000000000000000000000000000000000000;;		if a > b {
0000000000000000000000000000000000000000;;			return uint32(a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint32(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cbcMinPacketSizeMultiple = 8
0000000000000000000000000000000000000000;;		cbcMinPacketSize         = 16
0000000000000000000000000000000000000000;;		cbcMinPaddingSize        = 4
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cbcError represents a verification error that may leak information.
0000000000000000000000000000000000000000;;	type cbcError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e cbcError) Error() string { return string(e) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cbcCipher) readPacket(seqNum uint32, r io.Reader) ([]byte, error) {
0000000000000000000000000000000000000000;;		p, err := c.readPacketLeaky(seqNum, r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, ok := err.(cbcError); ok {
0000000000000000000000000000000000000000;;				// Verification error: read a fixed amount of
0000000000000000000000000000000000000000;;				// data, to make distinguishing between
0000000000000000000000000000000000000000;;				// failing MAC and failing length check more
0000000000000000000000000000000000000000;;				// difficult.
0000000000000000000000000000000000000000;;				io.CopyN(ioutil.Discard, r, int64(c.oracleCamouflage))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cbcCipher) readPacketLeaky(seqNum uint32, r io.Reader) ([]byte, error) {
0000000000000000000000000000000000000000;;		blockSize := c.decrypter.BlockSize()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read the header, which will include some of the subsequent data in the
0000000000000000000000000000000000000000;;		// case of block ciphers - this is copied back to the payload later.
0000000000000000000000000000000000000000;;		// How many bytes of payload/padding will be read with this first read.
0000000000000000000000000000000000000000;;		firstBlockLength := uint32((prefixLen + blockSize - 1) / blockSize * blockSize)
0000000000000000000000000000000000000000;;		firstBlock := c.packetData[:firstBlockLength]
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(r, firstBlock); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.oracleCamouflage = maxPacket + 4 + c.macSize - firstBlockLength
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.decrypter.CryptBlocks(firstBlock, firstBlock)
0000000000000000000000000000000000000000;;		length := binary.BigEndian.Uint32(firstBlock[:4])
0000000000000000000000000000000000000000;;		if length > maxPacket {
0000000000000000000000000000000000000000;;			return nil, cbcError("ssh: packet too large")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if length+4 < maxUInt32(cbcMinPacketSize, blockSize) {
0000000000000000000000000000000000000000;;			// The minimum size of a packet is 16 (or the cipher block size, whichever
0000000000000000000000000000000000000000;;			// is larger) bytes.
0000000000000000000000000000000000000000;;			return nil, cbcError("ssh: packet too small")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The length of the packet (including the length field but not the MAC) must
0000000000000000000000000000000000000000;;		// be a multiple of the block size or 8, whichever is larger.
0000000000000000000000000000000000000000;;		if (length+4)%maxUInt32(cbcMinPacketSizeMultiple, blockSize) != 0 {
0000000000000000000000000000000000000000;;			return nil, cbcError("ssh: invalid packet length multiple")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		paddingLength := uint32(firstBlock[4])
0000000000000000000000000000000000000000;;		if paddingLength < cbcMinPaddingSize || length <= paddingLength+1 {
0000000000000000000000000000000000000000;;			return nil, cbcError("ssh: invalid packet length")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Positions within the c.packetData buffer:
0000000000000000000000000000000000000000;;		macStart := 4 + length
0000000000000000000000000000000000000000;;		paddingStart := macStart - paddingLength
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Entire packet size, starting before length, ending at end of mac.
0000000000000000000000000000000000000000;;		entirePacketSize := macStart + c.macSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure c.packetData is large enough for the entire packet data.
0000000000000000000000000000000000000000;;		if uint32(cap(c.packetData)) < entirePacketSize {
0000000000000000000000000000000000000000;;			// Still need to upsize and copy, but this should be rare at runtime, only
0000000000000000000000000000000000000000;;			// on upsizing the packetData buffer.
0000000000000000000000000000000000000000;;			c.packetData = make([]byte, entirePacketSize)
0000000000000000000000000000000000000000;;			copy(c.packetData, firstBlock)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.packetData = c.packetData[:entirePacketSize]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n, err := io.ReadFull(r, c.packetData[firstBlockLength:]); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.oracleCamouflage -= uint32(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remainingCrypted := c.packetData[firstBlockLength:macStart]
0000000000000000000000000000000000000000;;		c.decrypter.CryptBlocks(remainingCrypted, remainingCrypted)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mac := c.packetData[macStart:]
0000000000000000000000000000000000000000;;		if c.mac != nil {
0000000000000000000000000000000000000000;;			c.mac.Reset()
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(c.seqNumBytes[:], seqNum)
0000000000000000000000000000000000000000;;			c.mac.Write(c.seqNumBytes[:])
0000000000000000000000000000000000000000;;			c.mac.Write(c.packetData[:macStart])
0000000000000000000000000000000000000000;;			c.macResult = c.mac.Sum(c.macResult[:0])
0000000000000000000000000000000000000000;;			if subtle.ConstantTimeCompare(c.macResult, mac) != 1 {
0000000000000000000000000000000000000000;;				return nil, cbcError("ssh: MAC failure")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.packetData[prefixLen:paddingStart], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cbcCipher) writePacket(seqNum uint32, w io.Writer, rand io.Reader, packet []byte) error {
0000000000000000000000000000000000000000;;		effectiveBlockSize := maxUInt32(cbcMinPacketSizeMultiple, c.encrypter.BlockSize())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Length of encrypted portion of the packet (header, payload, padding).
0000000000000000000000000000000000000000;;		// Enforce minimum padding and packet size.
0000000000000000000000000000000000000000;;		encLength := maxUInt32(prefixLen+len(packet)+cbcMinPaddingSize, cbcMinPaddingSize)
0000000000000000000000000000000000000000;;		// Enforce block size.
0000000000000000000000000000000000000000;;		encLength = (encLength + effectiveBlockSize - 1) / effectiveBlockSize * effectiveBlockSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		length := encLength - 4
0000000000000000000000000000000000000000;;		paddingLength := int(length) - (1 + len(packet))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Overall buffer contains: header, payload, padding, mac.
0000000000000000000000000000000000000000;;		// Space for the MAC is reserved in the capacity but not the slice length.
0000000000000000000000000000000000000000;;		bufferSize := encLength + c.macSize
0000000000000000000000000000000000000000;;		if uint32(cap(c.packetData)) < bufferSize {
0000000000000000000000000000000000000000;;			c.packetData = make([]byte, encLength, bufferSize)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.packetData = c.packetData[:encLength]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := c.packetData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Packet header.
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(p, length)
0000000000000000000000000000000000000000;;		p = p[4:]
0000000000000000000000000000000000000000;;		p[0] = byte(paddingLength)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Payload.
0000000000000000000000000000000000000000;;		p = p[1:]
0000000000000000000000000000000000000000;;		copy(p, packet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Padding.
0000000000000000000000000000000000000000;;		p = p[len(packet):]
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rand, p); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.mac != nil {
0000000000000000000000000000000000000000;;			c.mac.Reset()
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(c.seqNumBytes[:], seqNum)
0000000000000000000000000000000000000000;;			c.mac.Write(c.seqNumBytes[:])
0000000000000000000000000000000000000000;;			c.mac.Write(c.packetData)
0000000000000000000000000000000000000000;;			// The MAC is now appended into the capacity reserved for it earlier.
0000000000000000000000000000000000000000;;			c.packetData = c.mac.Sum(c.packetData)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.encrypter.CryptBlocks(c.packetData[:encLength], c.packetData[:encLength])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := w.Write(c.packetData); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
