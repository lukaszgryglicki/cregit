0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/handshake.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/handshake.go][vendor/golang.org/x/crypto/ssh/handshake.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// debugHandshake, if set, prints messages sent and received.  Key
0000000000000000000000000000000000000000;;	// exchange messages are printed as if DH were used, so the debug
0000000000000000000000000000000000000000;;	// messages are wrong when using ECDH.
0000000000000000000000000000000000000000;;	const debugHandshake = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keyingTransport is a packet based transport that supports key
0000000000000000000000000000000000000000;;	// changes. It need not be thread-safe. It should pass through
0000000000000000000000000000000000000000;;	// msgNewKeys in both directions.
0000000000000000000000000000000000000000;;	type keyingTransport interface {
0000000000000000000000000000000000000000;;		packetConn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// prepareKeyChange sets up a key change. The key change for a
0000000000000000000000000000000000000000;;		// direction will be effected if a msgNewKeys message is sent
0000000000000000000000000000000000000000;;		// or received.
0000000000000000000000000000000000000000;;		prepareKeyChange(*algorithms, *kexResult) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handshakeTransport implements rekeying on top of a keyingTransport
0000000000000000000000000000000000000000;;	// and offers a thread-safe writePacket() interface.
0000000000000000000000000000000000000000;;	type handshakeTransport struct {
0000000000000000000000000000000000000000;;		conn   keyingTransport
0000000000000000000000000000000000000000;;		config *Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverVersion []byte
0000000000000000000000000000000000000000;;		clientVersion []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// hostKeys is non-empty if we are the server. In that case,
0000000000000000000000000000000000000000;;		// it contains all host keys that can be used to sign the
0000000000000000000000000000000000000000;;		// connection.
0000000000000000000000000000000000000000;;		hostKeys []Signer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// hostKeyAlgorithms is non-empty if we are the client. In that case,
0000000000000000000000000000000000000000;;		// we accept these key types from the server as host key.
0000000000000000000000000000000000000000;;		hostKeyAlgorithms []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// On read error, incoming is closed, and readError is set.
0000000000000000000000000000000000000000;;		incoming  chan []byte
0000000000000000000000000000000000000000;;		readError error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// data for host key checking
0000000000000000000000000000000000000000;;		hostKeyCallback func(hostname string, remote net.Addr, key PublicKey) error
0000000000000000000000000000000000000000;;		dialAddress     string
0000000000000000000000000000000000000000;;		remoteAddr      net.Addr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readSinceKex uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Protects the writing side of the connection
0000000000000000000000000000000000000000;;		mu              sync.Mutex
0000000000000000000000000000000000000000;;		cond            *sync.Cond
0000000000000000000000000000000000000000;;		sentInitPacket  []byte
0000000000000000000000000000000000000000;;		sentInitMsg     *kexInitMsg
0000000000000000000000000000000000000000;;		writtenSinceKex uint64
0000000000000000000000000000000000000000;;		writeError      error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The session ID or nil if first kex did not complete yet.
0000000000000000000000000000000000000000;;		sessionID []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newHandshakeTransport(conn keyingTransport, config *Config, clientVersion, serverVersion []byte) *handshakeTransport {
0000000000000000000000000000000000000000;;		t := &handshakeTransport{
0000000000000000000000000000000000000000;;			conn:          conn,
0000000000000000000000000000000000000000;;			serverVersion: serverVersion,
0000000000000000000000000000000000000000;;			clientVersion: clientVersion,
0000000000000000000000000000000000000000;;			incoming:      make(chan []byte, 16),
0000000000000000000000000000000000000000;;			config:        config,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.cond = sync.NewCond(&t.mu)
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newClientTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ClientConfig, dialAddr string, addr net.Addr) *handshakeTransport {
0000000000000000000000000000000000000000;;		t := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)
0000000000000000000000000000000000000000;;		t.dialAddress = dialAddr
0000000000000000000000000000000000000000;;		t.remoteAddr = addr
0000000000000000000000000000000000000000;;		t.hostKeyCallback = config.HostKeyCallback
0000000000000000000000000000000000000000;;		if config.HostKeyAlgorithms != nil {
0000000000000000000000000000000000000000;;			t.hostKeyAlgorithms = config.HostKeyAlgorithms
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.hostKeyAlgorithms = supportedHostKeyAlgos
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go t.readLoop()
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newServerTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ServerConfig) *handshakeTransport {
0000000000000000000000000000000000000000;;		t := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)
0000000000000000000000000000000000000000;;		t.hostKeys = config.hostKeys
0000000000000000000000000000000000000000;;		go t.readLoop()
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) getSessionID() []byte {
0000000000000000000000000000000000000000;;		return t.sessionID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) id() string {
0000000000000000000000000000000000000000;;		if len(t.hostKeys) > 0 {
0000000000000000000000000000000000000000;;			return "server"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "client"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) readPacket() ([]byte, error) {
0000000000000000000000000000000000000000;;		p, ok := <-t.incoming
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, t.readError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) readLoop() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			p, err := t.readOnePacket()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.readError = err
0000000000000000000000000000000000000000;;				close(t.incoming)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p[0] == msgIgnore || p[0] == msgDebug {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.incoming <- p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we can't read, declare the writing part dead too.
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		if t.writeError == nil {
0000000000000000000000000000000000000000;;			t.writeError = t.readError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.cond.Broadcast()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) readOnePacket() ([]byte, error) {
0000000000000000000000000000000000000000;;		if t.readSinceKex > t.config.RekeyThreshold {
0000000000000000000000000000000000000000;;			if err := t.requestKeyChange(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p, err := t.conn.readPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.readSinceKex += uint64(len(p))
0000000000000000000000000000000000000000;;		if debugHandshake {
0000000000000000000000000000000000000000;;			if p[0] == msgChannelData || p[0] == msgChannelExtendedData {
0000000000000000000000000000000000000000;;				log.Printf("%s got data (packet %d bytes)", t.id(), len(p))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				msg, err := decode(p)
0000000000000000000000000000000000000000;;				log.Printf("%s got %T %v (%v)", t.id(), msg, msg, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p[0] != msgKexInit {
0000000000000000000000000000000000000000;;			return p, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		firstKex := t.sessionID == nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = t.enterKeyExchangeLocked(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// drop connection
0000000000000000000000000000000000000000;;			t.conn.Close()
0000000000000000000000000000000000000000;;			t.writeError = err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if debugHandshake {
0000000000000000000000000000000000000000;;			log.Printf("%s exited key exchange (first %v), err %v", t.id(), firstKex, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unblock writers.
0000000000000000000000000000000000000000;;		t.sentInitMsg = nil
0000000000000000000000000000000000000000;;		t.sentInitPacket = nil
0000000000000000000000000000000000000000;;		t.cond.Broadcast()
0000000000000000000000000000000000000000;;		t.writtenSinceKex = 0
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.readSinceKex = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// By default, a key exchange is hidden from higher layers by
0000000000000000000000000000000000000000;;		// translating it into msgIgnore.
0000000000000000000000000000000000000000;;		successPacket := []byte{msgIgnore}
0000000000000000000000000000000000000000;;		if firstKex {
0000000000000000000000000000000000000000;;			// sendKexInit() for the first kex waits for
0000000000000000000000000000000000000000;;			// msgNewKeys so the authentication process is
0000000000000000000000000000000000000000;;			// guaranteed to happen over an encrypted transport.
0000000000000000000000000000000000000000;;			successPacket = []byte{msgNewKeys}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return successPacket, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keyChangeCategory describes whether a key exchange is the first on a
0000000000000000000000000000000000000000;;	// connection, or a subsequent one.
0000000000000000000000000000000000000000;;	type keyChangeCategory bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		firstKeyExchange      keyChangeCategory = true
0000000000000000000000000000000000000000;;		subsequentKeyExchange keyChangeCategory = false
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendKexInit sends a key change message, and returns the message
0000000000000000000000000000000000000000;;	// that was sent. After initiating the key change, all writes will be
0000000000000000000000000000000000000000;;	// blocked until the change is done, and a failed key change will
0000000000000000000000000000000000000000;;	// close the underlying transport. This function is safe for
0000000000000000000000000000000000000000;;	// concurrent use by multiple goroutines.
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) sendKexInit(isFirst keyChangeCategory) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		// If this is the initial key change, but we already have a sessionID,
0000000000000000000000000000000000000000;;		// then do nothing because the key exchange has already completed
0000000000000000000000000000000000000000;;		// asynchronously.
0000000000000000000000000000000000000000;;		if !isFirst || t.sessionID == nil {
0000000000000000000000000000000000000000;;			_, _, err = t.sendKexInitLocked(isFirst)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.mu.Unlock()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isFirst {
0000000000000000000000000000000000000000;;			if packet, err := t.readPacket(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			} else if packet[0] != msgNewKeys {
0000000000000000000000000000000000000000;;				return unexpectedMessageError(msgNewKeys, packet[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) requestInitialKeyChange() error {
0000000000000000000000000000000000000000;;		return t.sendKexInit(firstKeyExchange)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) requestKeyChange() error {
0000000000000000000000000000000000000000;;		return t.sendKexInit(subsequentKeyExchange)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendKexInitLocked sends a key change message. t.mu must be locked
0000000000000000000000000000000000000000;;	// while this happens.
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) sendKexInitLocked(isFirst keyChangeCategory) (*kexInitMsg, []byte, error) {
0000000000000000000000000000000000000000;;		// kexInits may be sent either in response to the other side,
0000000000000000000000000000000000000000;;		// or because our side wants to initiate a key change, so we
0000000000000000000000000000000000000000;;		// may have already sent a kexInit. In that case, don't send a
0000000000000000000000000000000000000000;;		// second kexInit.
0000000000000000000000000000000000000000;;		if t.sentInitMsg != nil {
0000000000000000000000000000000000000000;;			return t.sentInitMsg, t.sentInitPacket, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := &kexInitMsg{
0000000000000000000000000000000000000000;;			KexAlgos:                t.config.KeyExchanges,
0000000000000000000000000000000000000000;;			CiphersClientServer:     t.config.Ciphers,
0000000000000000000000000000000000000000;;			CiphersServerClient:     t.config.Ciphers,
0000000000000000000000000000000000000000;;			MACsClientServer:        t.config.MACs,
0000000000000000000000000000000000000000;;			MACsServerClient:        t.config.MACs,
0000000000000000000000000000000000000000;;			CompressionClientServer: supportedCompressions,
0000000000000000000000000000000000000000;;			CompressionServerClient: supportedCompressions,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		io.ReadFull(rand.Reader, msg.Cookie[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(t.hostKeys) > 0 {
0000000000000000000000000000000000000000;;			for _, k := range t.hostKeys {
0000000000000000000000000000000000000000;;				msg.ServerHostKeyAlgos = append(
0000000000000000000000000000000000000000;;					msg.ServerHostKeyAlgos, k.PublicKey().Type())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			msg.ServerHostKeyAlgos = t.hostKeyAlgorithms
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		packet := Marshal(msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// writePacket destroys the contents, so save a copy.
0000000000000000000000000000000000000000;;		packetCopy := make([]byte, len(packet))
0000000000000000000000000000000000000000;;		copy(packetCopy, packet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := t.conn.writePacket(packetCopy); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.sentInitMsg = msg
0000000000000000000000000000000000000000;;		t.sentInitPacket = packet
0000000000000000000000000000000000000000;;		return msg, packet, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) writePacket(p []byte) error {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.writtenSinceKex > t.config.RekeyThreshold {
0000000000000000000000000000000000000000;;			t.sendKexInitLocked(subsequentKeyExchange)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for t.sentInitMsg != nil && t.writeError == nil {
0000000000000000000000000000000000000000;;			t.cond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.writeError != nil {
0000000000000000000000000000000000000000;;			return t.writeError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.writtenSinceKex += uint64(len(p))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch p[0] {
0000000000000000000000000000000000000000;;		case msgKexInit:
0000000000000000000000000000000000000000;;			return errors.New("ssh: only handshakeTransport can send kexInit")
0000000000000000000000000000000000000000;;		case msgNewKeys:
0000000000000000000000000000000000000000;;			return errors.New("ssh: only handshakeTransport can send newKeys")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return t.conn.writePacket(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) Close() error {
0000000000000000000000000000000000000000;;		return t.conn.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// enterKeyExchange runs the key exchange. t.mu must be held while running this.
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) enterKeyExchangeLocked(otherInitPacket []byte) error {
0000000000000000000000000000000000000000;;		if debugHandshake {
0000000000000000000000000000000000000000;;			log.Printf("%s entered key exchange", t.id())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		myInit, myInitPacket, err := t.sendKexInitLocked(subsequentKeyExchange)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		otherInit := &kexInitMsg{}
0000000000000000000000000000000000000000;;		if err := Unmarshal(otherInitPacket, otherInit); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		magics := handshakeMagics{
0000000000000000000000000000000000000000;;			clientVersion: t.clientVersion,
0000000000000000000000000000000000000000;;			serverVersion: t.serverVersion,
0000000000000000000000000000000000000000;;			clientKexInit: otherInitPacket,
0000000000000000000000000000000000000000;;			serverKexInit: myInitPacket,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientInit := otherInit
0000000000000000000000000000000000000000;;		serverInit := myInit
0000000000000000000000000000000000000000;;		if len(t.hostKeys) == 0 {
0000000000000000000000000000000000000000;;			clientInit = myInit
0000000000000000000000000000000000000000;;			serverInit = otherInit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			magics.clientKexInit = myInitPacket
0000000000000000000000000000000000000000;;			magics.serverKexInit = otherInitPacket
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		algs, err := findAgreedAlgorithms(clientInit, serverInit)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We don't send FirstKexFollows, but we handle receiving it.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// RFC 4253 section 7 defines the kex and the agreement method for
0000000000000000000000000000000000000000;;		// first_kex_packet_follows. It states that the guessed packet
0000000000000000000000000000000000000000;;		// should be ignored if the "kex algorithm and/or the host
0000000000000000000000000000000000000000;;		// key algorithm is guessed wrong (server and client have
0000000000000000000000000000000000000000;;		// different preferred algorithm), or if any of the other
0000000000000000000000000000000000000000;;		// algorithms cannot be agreed upon". The other algorithms have
0000000000000000000000000000000000000000;;		// already been checked above so the kex algorithm and host key
0000000000000000000000000000000000000000;;		// algorithm are checked here.
0000000000000000000000000000000000000000;;		if otherInit.FirstKexFollows && (clientInit.KexAlgos[0] != serverInit.KexAlgos[0] || clientInit.ServerHostKeyAlgos[0] != serverInit.ServerHostKeyAlgos[0]) {
0000000000000000000000000000000000000000;;			// other side sent a kex message for the wrong algorithm,
0000000000000000000000000000000000000000;;			// which we have to ignore.
0000000000000000000000000000000000000000;;			if _, err := t.conn.readPacket(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kex, ok := kexAlgoMap[algs.kex]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: unexpected key exchange algorithm %v", algs.kex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result *kexResult
0000000000000000000000000000000000000000;;		if len(t.hostKeys) > 0 {
0000000000000000000000000000000000000000;;			result, err = t.server(kex, algs, &magics)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			result, err = t.client(kex, algs, &magics)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.sessionID == nil {
0000000000000000000000000000000000000000;;			t.sessionID = result.H
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.SessionID = t.sessionID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.conn.prepareKeyChange(algs, result)
0000000000000000000000000000000000000000;;		if err = t.conn.writePacket([]byte{msgNewKeys}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if packet, err := t.conn.readPacket(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if packet[0] != msgNewKeys {
0000000000000000000000000000000000000000;;			return unexpectedMessageError(msgNewKeys, packet[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) server(kex kexAlgorithm, algs *algorithms, magics *handshakeMagics) (*kexResult, error) {
0000000000000000000000000000000000000000;;		var hostKey Signer
0000000000000000000000000000000000000000;;		for _, k := range t.hostKeys {
0000000000000000000000000000000000000000;;			if algs.hostKey == k.PublicKey().Type() {
0000000000000000000000000000000000000000;;				hostKey = k
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r, err := kex.Server(t.conn, t.config.Rand, magics, hostKey)
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *handshakeTransport) client(kex kexAlgorithm, algs *algorithms, magics *handshakeMagics) (*kexResult, error) {
0000000000000000000000000000000000000000;;		result, err := kex.Client(t.conn, t.config.Rand, magics)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostKey, err := ParsePublicKey(result.HostKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := verifyHostKeySignature(hostKey, result); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.hostKeyCallback != nil {
0000000000000000000000000000000000000000;;			err = t.hostKeyCallback(t.dialAddress, t.remoteAddr, hostKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
