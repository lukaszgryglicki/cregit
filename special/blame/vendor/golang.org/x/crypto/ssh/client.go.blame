0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/client.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/client.go][vendor/golang.org/x/crypto/ssh/client.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client implements a traditional SSH client that supports shells,
0000000000000000000000000000000000000000;;	// subprocesses, port forwarding and tunneled dialing.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		Conn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		forwards        forwardList // forwarded tcpip connections from the remote side
0000000000000000000000000000000000000000;;		mu              sync.Mutex
0000000000000000000000000000000000000000;;		channelHandlers map[string]chan NewChannel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleChannelOpen returns a channel on which NewChannel requests
0000000000000000000000000000000000000000;;	// for the given type are sent. If the type already is being handled,
0000000000000000000000000000000000000000;;	// nil is returned. The channel is closed when the connection is closed.
0000000000000000000000000000000000000000;;	func (c *Client) HandleChannelOpen(channelType string) <-chan NewChannel {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		defer c.mu.Unlock()
0000000000000000000000000000000000000000;;		if c.channelHandlers == nil {
0000000000000000000000000000000000000000;;			// The SSH channel has been closed.
0000000000000000000000000000000000000000;;			c := make(chan NewChannel)
0000000000000000000000000000000000000000;;			close(c)
0000000000000000000000000000000000000000;;			return c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := c.channelHandlers[channelType]
0000000000000000000000000000000000000000;;		if ch != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch = make(chan NewChannel, 16)
0000000000000000000000000000000000000000;;		c.channelHandlers[channelType] = ch
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient creates a Client on top of the given connection.
0000000000000000000000000000000000000000;;	func NewClient(c Conn, chans <-chan NewChannel, reqs <-chan *Request) *Client {
0000000000000000000000000000000000000000;;		conn := &Client{
0000000000000000000000000000000000000000;;			Conn:            c,
0000000000000000000000000000000000000000;;			channelHandlers: make(map[string]chan NewChannel, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go conn.handleGlobalRequests(reqs)
0000000000000000000000000000000000000000;;		go conn.handleChannelOpens(chans)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			conn.Wait()
0000000000000000000000000000000000000000;;			conn.forwards.closeAll()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		go conn.forwards.handleChannels(conn.HandleChannelOpen("forwarded-tcpip"))
0000000000000000000000000000000000000000;;		return conn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientConn establishes an authenticated SSH connection using c
0000000000000000000000000000000000000000;;	// as the underlying transport.  The Request and NewChannel channels
0000000000000000000000000000000000000000;;	// must be serviced or the connection will hang.
0000000000000000000000000000000000000000;;	func NewClientConn(c net.Conn, addr string, config *ClientConfig) (Conn, <-chan NewChannel, <-chan *Request, error) {
0000000000000000000000000000000000000000;;		fullConf := *config
0000000000000000000000000000000000000000;;		fullConf.SetDefaults()
0000000000000000000000000000000000000000;;		conn := &connection{
0000000000000000000000000000000000000000;;			sshConn: sshConn{conn: c},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := conn.clientHandshake(addr, &fullConf); err != nil {
0000000000000000000000000000000000000000;;			c.Close()
0000000000000000000000000000000000000000;;			return nil, nil, nil, fmt.Errorf("ssh: handshake failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conn.mux = newMux(conn.transport)
0000000000000000000000000000000000000000;;		return conn, conn.mux.incomingChannels, conn.mux.incomingRequests, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientHandshake performs the client side key exchange. See RFC 4253 Section
0000000000000000000000000000000000000000;;	// 7.
0000000000000000000000000000000000000000;;	func (c *connection) clientHandshake(dialAddress string, config *ClientConfig) error {
0000000000000000000000000000000000000000;;		if config.ClientVersion != "" {
0000000000000000000000000000000000000000;;			c.clientVersion = []byte(config.ClientVersion)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.clientVersion = []byte(packageVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		c.serverVersion, err = exchangeVersions(c.sshConn.conn, c.clientVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.transport = newClientTransport(
0000000000000000000000000000000000000000;;			newTransport(c.sshConn.conn, config.Rand, true /* is client */),
0000000000000000000000000000000000000000;;			c.clientVersion, c.serverVersion, config, dialAddress, c.sshConn.RemoteAddr())
0000000000000000000000000000000000000000;;		if err := c.transport.requestInitialKeyChange(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We just did the key change, so the session ID is established.
0000000000000000000000000000000000000000;;		c.sessionID = c.transport.getSessionID()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.clientAuthenticate(config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyHostKeySignature verifies the host key obtained in the key
0000000000000000000000000000000000000000;;	// exchange.
0000000000000000000000000000000000000000;;	func verifyHostKeySignature(hostKey PublicKey, result *kexResult) error {
0000000000000000000000000000000000000000;;		sig, rest, ok := parseSignatureBody(result.Signature)
0000000000000000000000000000000000000000;;		if len(rest) > 0 || !ok {
0000000000000000000000000000000000000000;;			return errors.New("ssh: signature parse error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hostKey.Verify(result.H, sig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSession opens a new Session for this client. (A session is a remote
0000000000000000000000000000000000000000;;	// execution of a program.)
0000000000000000000000000000000000000000;;	func (c *Client) NewSession() (*Session, error) {
0000000000000000000000000000000000000000;;		ch, in, err := c.OpenChannel("session", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newSession(ch, in)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) handleGlobalRequests(incoming <-chan *Request) {
0000000000000000000000000000000000000000;;		for r := range incoming {
0000000000000000000000000000000000000000;;			// This handles keepalive messages and matches
0000000000000000000000000000000000000000;;			// the behaviour of OpenSSH.
0000000000000000000000000000000000000000;;			r.Reply(false, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleChannelOpens channel open messages from the remote side.
0000000000000000000000000000000000000000;;	func (c *Client) handleChannelOpens(in <-chan NewChannel) {
0000000000000000000000000000000000000000;;		for ch := range in {
0000000000000000000000000000000000000000;;			c.mu.Lock()
0000000000000000000000000000000000000000;;			handler := c.channelHandlers[ch.ChannelType()]
0000000000000000000000000000000000000000;;			c.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if handler != nil {
0000000000000000000000000000000000000000;;				handler <- ch
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ch.Reject(UnknownChannelType, fmt.Sprintf("unknown channel type: %v", ch.ChannelType()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		for _, ch := range c.channelHandlers {
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.channelHandlers = nil
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial starts a client connection to the given SSH server. It is a
0000000000000000000000000000000000000000;;	// convenience function that connects to the given network address,
0000000000000000000000000000000000000000;;	// initiates the SSH handshake, and then sets up a Client.  For access
0000000000000000000000000000000000000000;;	// to incoming channels and requests, use net.Dial with NewClientConn
0000000000000000000000000000000000000000;;	// instead.
0000000000000000000000000000000000000000;;	func Dial(network, addr string, config *ClientConfig) (*Client, error) {
0000000000000000000000000000000000000000;;		conn, err := net.DialTimeout(network, addr, config.Timeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c, chans, reqs, err := NewClientConn(conn, addr, config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewClient(c, chans, reqs), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ClientConfig structure is used to configure a Client. It must not be
0000000000000000000000000000000000000000;;	// modified after having been passed to an SSH function.
0000000000000000000000000000000000000000;;	type ClientConfig struct {
0000000000000000000000000000000000000000;;		// Config contains configuration that is shared between clients and
0000000000000000000000000000000000000000;;		// servers.
0000000000000000000000000000000000000000;;		Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// User contains the username to authenticate as.
0000000000000000000000000000000000000000;;		User string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Auth contains possible authentication methods to use with the
0000000000000000000000000000000000000000;;		// server. Only the first instance of a particular RFC 4252 method will
0000000000000000000000000000000000000000;;		// be used during authentication.
0000000000000000000000000000000000000000;;		Auth []AuthMethod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HostKeyCallback, if not nil, is called during the cryptographic
0000000000000000000000000000000000000000;;		// handshake to validate the server's host key. A nil HostKeyCallback
0000000000000000000000000000000000000000;;		// implies that all host keys are accepted.
0000000000000000000000000000000000000000;;		HostKeyCallback func(hostname string, remote net.Addr, key PublicKey) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClientVersion contains the version identification string that will
0000000000000000000000000000000000000000;;		// be used for the connection. If empty, a reasonable default is used.
0000000000000000000000000000000000000000;;		ClientVersion string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HostKeyAlgorithms lists the key types that the client will
0000000000000000000000000000000000000000;;		// accept from the server as host key, in order of
0000000000000000000000000000000000000000;;		// preference. If empty, a reasonable default is used. Any
0000000000000000000000000000000000000000;;		// string returned from PublicKey.Type method may be used, or
0000000000000000000000000000000000000000;;		// any of the CertAlgoXxxx and KeyAlgoXxxx constants.
0000000000000000000000000000000000000000;;		HostKeyAlgorithms []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Timeout is the maximum amount of time for the TCP connection to establish.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// A Timeout of zero means no timeout.
0000000000000000000000000000000000000000;;		Timeout time.Duration
0000000000000000000000000000000000000000;;	}
