0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/tcpip.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/tcpip.go][vendor/golang.org/x/crypto/ssh/tcpip.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Listen requests the remote peer open a listening socket on
0000000000000000000000000000000000000000;;	// addr. Incoming connections will be available by calling Accept on
0000000000000000000000000000000000000000;;	// the returned net.Listener. The listener must be serviced, or the
0000000000000000000000000000000000000000;;	// SSH connection may hang.
0000000000000000000000000000000000000000;;	func (c *Client) Listen(n, addr string) (net.Listener, error) {
0000000000000000000000000000000000000000;;		laddr, err := net.ResolveTCPAddr(n, addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.ListenTCP(laddr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Automatic port allocation is broken with OpenSSH before 6.0. See
0000000000000000000000000000000000000000;;	// also https://bugzilla.mindrot.org/show_bug.cgi?id=2017.  In
0000000000000000000000000000000000000000;;	// particular, OpenSSH 5.9 sends a channelOpenMsg with port number 0,
0000000000000000000000000000000000000000;;	// rather than the actual port number. This means you can never open
0000000000000000000000000000000000000000;;	// two different listeners with auto allocated ports. We work around
0000000000000000000000000000000000000000;;	// this by trying explicit ports until we succeed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const openSSHPrefix = "OpenSSH_"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var portRandomizer = rand.New(rand.NewSource(time.Now().UnixNano()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isBrokenOpenSSHVersion returns true if the given version string
0000000000000000000000000000000000000000;;	// specifies a version of OpenSSH that is known to have a bug in port
0000000000000000000000000000000000000000;;	// forwarding.
0000000000000000000000000000000000000000;;	func isBrokenOpenSSHVersion(versionStr string) bool {
0000000000000000000000000000000000000000;;		i := strings.Index(versionStr, openSSHPrefix)
0000000000000000000000000000000000000000;;		if i < 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i += len(openSSHPrefix)
0000000000000000000000000000000000000000;;		j := i
0000000000000000000000000000000000000000;;		for ; j < len(versionStr); j++ {
0000000000000000000000000000000000000000;;			if versionStr[j] < '0' || versionStr[j] > '9' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version, _ := strconv.Atoi(versionStr[i:j])
0000000000000000000000000000000000000000;;		return version < 6
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// autoPortListenWorkaround simulates automatic port allocation by
0000000000000000000000000000000000000000;;	// trying random ports repeatedly.
0000000000000000000000000000000000000000;;	func (c *Client) autoPortListenWorkaround(laddr *net.TCPAddr) (net.Listener, error) {
0000000000000000000000000000000000000000;;		var sshListener net.Listener
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		const tries = 10
0000000000000000000000000000000000000000;;		for i := 0; i < tries; i++ {
0000000000000000000000000000000000000000;;			addr := *laddr
0000000000000000000000000000000000000000;;			addr.Port = 1024 + portRandomizer.Intn(60000)
0000000000000000000000000000000000000000;;			sshListener, err = c.ListenTCP(&addr)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				laddr.Port = addr.Port
0000000000000000000000000000000000000000;;				return sshListener, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("ssh: listen on random port failed after %d tries: %v", tries, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 4254 7.1
0000000000000000000000000000000000000000;;	type channelForwardMsg struct {
0000000000000000000000000000000000000000;;		addr  string
0000000000000000000000000000000000000000;;		rport uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListenTCP requests the remote peer open a listening socket
0000000000000000000000000000000000000000;;	// on laddr. Incoming connections will be available by calling
0000000000000000000000000000000000000000;;	// Accept on the returned net.Listener.
0000000000000000000000000000000000000000;;	func (c *Client) ListenTCP(laddr *net.TCPAddr) (net.Listener, error) {
0000000000000000000000000000000000000000;;		if laddr.Port == 0 && isBrokenOpenSSHVersion(string(c.ServerVersion())) {
0000000000000000000000000000000000000000;;			return c.autoPortListenWorkaround(laddr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := channelForwardMsg{
0000000000000000000000000000000000000000;;			laddr.IP.String(),
0000000000000000000000000000000000000000;;			uint32(laddr.Port),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// send message
0000000000000000000000000000000000000000;;		ok, resp, err := c.SendRequest("tcpip-forward", true, Marshal(&m))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: tcpip-forward request denied by peer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the original port was 0, then the remote side will
0000000000000000000000000000000000000000;;		// supply a real port number in the response.
0000000000000000000000000000000000000000;;		if laddr.Port == 0 {
0000000000000000000000000000000000000000;;			var p struct {
0000000000000000000000000000000000000000;;				Port uint32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := Unmarshal(resp, &p); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			laddr.Port = int(p.Port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register this forward, using the port number we obtained.
0000000000000000000000000000000000000000;;		ch := c.forwards.add(*laddr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &tcpListener{laddr, c, ch}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// forwardList stores a mapping between remote
0000000000000000000000000000000000000000;;	// forward requests and the tcpListeners.
0000000000000000000000000000000000000000;;	type forwardList struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		entries []forwardEntry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// forwardEntry represents an established mapping of a laddr on a
0000000000000000000000000000000000000000;;	// remote ssh server to a channel connected to a tcpListener.
0000000000000000000000000000000000000000;;	type forwardEntry struct {
0000000000000000000000000000000000000000;;		laddr net.TCPAddr
0000000000000000000000000000000000000000;;		c     chan forward
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// forward represents an incoming forwarded tcpip connection. The
0000000000000000000000000000000000000000;;	// arguments to add/remove/lookup should be address as specified in
0000000000000000000000000000000000000000;;	// the original forward-request.
0000000000000000000000000000000000000000;;	type forward struct {
0000000000000000000000000000000000000000;;		newCh NewChannel   // the ssh client channel underlying this forward
0000000000000000000000000000000000000000;;		raddr *net.TCPAddr // the raddr of the incoming connection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *forwardList) add(addr net.TCPAddr) chan forward {
0000000000000000000000000000000000000000;;		l.Lock()
0000000000000000000000000000000000000000;;		defer l.Unlock()
0000000000000000000000000000000000000000;;		f := forwardEntry{
0000000000000000000000000000000000000000;;			addr,
0000000000000000000000000000000000000000;;			make(chan forward, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.entries = append(l.entries, f)
0000000000000000000000000000000000000000;;		return f.c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 7.2
0000000000000000000000000000000000000000;;	type forwardedTCPPayload struct {
0000000000000000000000000000000000000000;;		Addr       string
0000000000000000000000000000000000000000;;		Port       uint32
0000000000000000000000000000000000000000;;		OriginAddr string
0000000000000000000000000000000000000000;;		OriginPort uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseTCPAddr parses the originating address from the remote into a *net.TCPAddr.
0000000000000000000000000000000000000000;;	func parseTCPAddr(addr string, port uint32) (*net.TCPAddr, error) {
0000000000000000000000000000000000000000;;		if port == 0 || port > 65535 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ssh: port number out of range: %d", port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ip := net.ParseIP(string(addr))
0000000000000000000000000000000000000000;;		if ip == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ssh: cannot parse IP address %q", addr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &net.TCPAddr{IP: ip, Port: int(port)}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *forwardList) handleChannels(in <-chan NewChannel) {
0000000000000000000000000000000000000000;;		for ch := range in {
0000000000000000000000000000000000000000;;			var payload forwardedTCPPayload
0000000000000000000000000000000000000000;;			if err := Unmarshal(ch.ExtraData(), &payload); err != nil {
0000000000000000000000000000000000000000;;				ch.Reject(ConnectionFailed, "could not parse forwarded-tcpip payload: "+err.Error())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// RFC 4254 section 7.2 specifies that incoming
0000000000000000000000000000000000000000;;			// addresses should list the address, in string
0000000000000000000000000000000000000000;;			// format. It is implied that this should be an IP
0000000000000000000000000000000000000000;;			// address, as it would be impossible to connect to it
0000000000000000000000000000000000000000;;			// otherwise.
0000000000000000000000000000000000000000;;			laddr, err := parseTCPAddr(payload.Addr, payload.Port)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				ch.Reject(ConnectionFailed, err.Error())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			raddr, err := parseTCPAddr(payload.OriginAddr, payload.OriginPort)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				ch.Reject(ConnectionFailed, err.Error())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ok := l.forward(*laddr, *raddr, ch); !ok {
0000000000000000000000000000000000000000;;				// Section 7.2, implementations MUST reject spurious incoming
0000000000000000000000000000000000000000;;				// connections.
0000000000000000000000000000000000000000;;				ch.Reject(Prohibited, "no forward for address")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// remove removes the forward entry, and the channel feeding its
0000000000000000000000000000000000000000;;	// listener.
0000000000000000000000000000000000000000;;	func (l *forwardList) remove(addr net.TCPAddr) {
0000000000000000000000000000000000000000;;		l.Lock()
0000000000000000000000000000000000000000;;		defer l.Unlock()
0000000000000000000000000000000000000000;;		for i, f := range l.entries {
0000000000000000000000000000000000000000;;			if addr.IP.Equal(f.laddr.IP) && addr.Port == f.laddr.Port {
0000000000000000000000000000000000000000;;				l.entries = append(l.entries[:i], l.entries[i+1:]...)
0000000000000000000000000000000000000000;;				close(f.c)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// closeAll closes and clears all forwards.
0000000000000000000000000000000000000000;;	func (l *forwardList) closeAll() {
0000000000000000000000000000000000000000;;		l.Lock()
0000000000000000000000000000000000000000;;		defer l.Unlock()
0000000000000000000000000000000000000000;;		for _, f := range l.entries {
0000000000000000000000000000000000000000;;			close(f.c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.entries = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *forwardList) forward(laddr, raddr net.TCPAddr, ch NewChannel) bool {
0000000000000000000000000000000000000000;;		l.Lock()
0000000000000000000000000000000000000000;;		defer l.Unlock()
0000000000000000000000000000000000000000;;		for _, f := range l.entries {
0000000000000000000000000000000000000000;;			if laddr.IP.Equal(f.laddr.IP) && laddr.Port == f.laddr.Port {
0000000000000000000000000000000000000000;;				f.c <- forward{ch, &raddr}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tcpListener struct {
0000000000000000000000000000000000000000;;		laddr *net.TCPAddr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn *Client
0000000000000000000000000000000000000000;;		in   <-chan forward
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Accept waits for and returns the next connection to the listener.
0000000000000000000000000000000000000000;;	func (l *tcpListener) Accept() (net.Conn, error) {
0000000000000000000000000000000000000000;;		s, ok := <-l.in
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ch, incoming, err := s.newCh.Accept()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go DiscardRequests(incoming)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &tcpChanConn{
0000000000000000000000000000000000000000;;			Channel: ch,
0000000000000000000000000000000000000000;;			laddr:   l.laddr,
0000000000000000000000000000000000000000;;			raddr:   s.raddr,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the listener.
0000000000000000000000000000000000000000;;	func (l *tcpListener) Close() error {
0000000000000000000000000000000000000000;;		m := channelForwardMsg{
0000000000000000000000000000000000000000;;			l.laddr.IP.String(),
0000000000000000000000000000000000000000;;			uint32(l.laddr.Port),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this also closes the listener.
0000000000000000000000000000000000000000;;		l.conn.forwards.remove(*l.laddr)
0000000000000000000000000000000000000000;;		ok, _, err := l.conn.SendRequest("cancel-tcpip-forward", true, Marshal(&m))
0000000000000000000000000000000000000000;;		if err == nil && !ok {
0000000000000000000000000000000000000000;;			err = errors.New("ssh: cancel-tcpip-forward failed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Addr returns the listener's network address.
0000000000000000000000000000000000000000;;	func (l *tcpListener) Addr() net.Addr {
0000000000000000000000000000000000000000;;		return l.laddr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial initiates a connection to the addr from the remote host.
0000000000000000000000000000000000000000;;	// The resulting connection has a zero LocalAddr() and RemoteAddr().
0000000000000000000000000000000000000000;;	func (c *Client) Dial(n, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		// Parse the address into host and numeric port.
0000000000000000000000000000000000000000;;		host, portString, err := net.SplitHostPort(addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		port, err := strconv.ParseUint(portString, 10, 16)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Use a zero address for local and remote address.
0000000000000000000000000000000000000000;;		zeroAddr := &net.TCPAddr{
0000000000000000000000000000000000000000;;			IP:   net.IPv4zero,
0000000000000000000000000000000000000000;;			Port: 0,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ch, err := c.dial(net.IPv4zero.String(), 0, host, int(port))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &tcpChanConn{
0000000000000000000000000000000000000000;;			Channel: ch,
0000000000000000000000000000000000000000;;			laddr:   zeroAddr,
0000000000000000000000000000000000000000;;			raddr:   zeroAddr,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialTCP connects to the remote address raddr on the network net,
0000000000000000000000000000000000000000;;	// which must be "tcp", "tcp4", or "tcp6".  If laddr is not nil, it is used
0000000000000000000000000000000000000000;;	// as the local address for the connection.
0000000000000000000000000000000000000000;;	func (c *Client) DialTCP(n string, laddr, raddr *net.TCPAddr) (net.Conn, error) {
0000000000000000000000000000000000000000;;		if laddr == nil {
0000000000000000000000000000000000000000;;			laddr = &net.TCPAddr{
0000000000000000000000000000000000000000;;				IP:   net.IPv4zero,
0000000000000000000000000000000000000000;;				Port: 0,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ch, err := c.dial(laddr.IP.String(), laddr.Port, raddr.IP.String(), raddr.Port)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &tcpChanConn{
0000000000000000000000000000000000000000;;			Channel: ch,
0000000000000000000000000000000000000000;;			laddr:   laddr,
0000000000000000000000000000000000000000;;			raddr:   raddr,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 4254 7.2
0000000000000000000000000000000000000000;;	type channelOpenDirectMsg struct {
0000000000000000000000000000000000000000;;		raddr string
0000000000000000000000000000000000000000;;		rport uint32
0000000000000000000000000000000000000000;;		laddr string
0000000000000000000000000000000000000000;;		lport uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) dial(laddr string, lport int, raddr string, rport int) (Channel, error) {
0000000000000000000000000000000000000000;;		msg := channelOpenDirectMsg{
0000000000000000000000000000000000000000;;			raddr: raddr,
0000000000000000000000000000000000000000;;			rport: uint32(rport),
0000000000000000000000000000000000000000;;			laddr: laddr,
0000000000000000000000000000000000000000;;			lport: uint32(lport),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ch, in, err := c.OpenChannel("direct-tcpip", Marshal(&msg))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go DiscardRequests(in)
0000000000000000000000000000000000000000;;		return ch, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tcpChan struct {
0000000000000000000000000000000000000000;;		Channel // the backing channel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tcpChanConn fulfills the net.Conn interface without
0000000000000000000000000000000000000000;;	// the tcpChan having to hold laddr or raddr directly.
0000000000000000000000000000000000000000;;	type tcpChanConn struct {
0000000000000000000000000000000000000000;;		Channel
0000000000000000000000000000000000000000;;		laddr, raddr net.Addr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LocalAddr returns the local network address.
0000000000000000000000000000000000000000;;	func (t *tcpChanConn) LocalAddr() net.Addr {
0000000000000000000000000000000000000000;;		return t.laddr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteAddr returns the remote network address.
0000000000000000000000000000000000000000;;	func (t *tcpChanConn) RemoteAddr() net.Addr {
0000000000000000000000000000000000000000;;		return t.raddr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetDeadline sets the read and write deadlines associated
0000000000000000000000000000000000000000;;	// with the connection.
0000000000000000000000000000000000000000;;	func (t *tcpChanConn) SetDeadline(deadline time.Time) error {
0000000000000000000000000000000000000000;;		if err := t.SetReadDeadline(deadline); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.SetWriteDeadline(deadline)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetReadDeadline sets the read deadline.
0000000000000000000000000000000000000000;;	// A zero value for t means Read will not time out.
0000000000000000000000000000000000000000;;	// After the deadline, the error from Read will implement net.Error
0000000000000000000000000000000000000000;;	// with Timeout() == true.
0000000000000000000000000000000000000000;;	func (t *tcpChanConn) SetReadDeadline(deadline time.Time) error {
0000000000000000000000000000000000000000;;		return errors.New("ssh: tcpChan: deadline not supported")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetWriteDeadline exists to satisfy the net.Conn interface
0000000000000000000000000000000000000000;;	// but is not implemented by this type.  It always returns an error.
0000000000000000000000000000000000000000;;	func (t *tcpChanConn) SetWriteDeadline(deadline time.Time) error {
0000000000000000000000000000000000000000;;		return errors.New("ssh: tcpChan: deadline not supported")
0000000000000000000000000000000000000000;;	}
