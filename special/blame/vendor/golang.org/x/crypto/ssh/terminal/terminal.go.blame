0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
fd67f7b54069fd4e3fd5dcc2238cb8c3266f5202;;	
0000000000000000000000000000000000000000;;	package terminal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EscapeCodes contains escape sequences that can be written to the terminal in
0000000000000000000000000000000000000000;;	// order to achieve different styles of text.
0000000000000000000000000000000000000000;;	type EscapeCodes struct {
0000000000000000000000000000000000000000;;		// Foreground colors
0000000000000000000000000000000000000000;;		Black, Red, Green, Yellow, Blue, Magenta, Cyan, White []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset all attributes
0000000000000000000000000000000000000000;;		Reset []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var vt100EscapeCodes = EscapeCodes{
0000000000000000000000000000000000000000;;		Black:   []byte{keyEscape, '[', '3', '0', 'm'},
0000000000000000000000000000000000000000;;		Red:     []byte{keyEscape, '[', '3', '1', 'm'},
0000000000000000000000000000000000000000;;		Green:   []byte{keyEscape, '[', '3', '2', 'm'},
0000000000000000000000000000000000000000;;		Yellow:  []byte{keyEscape, '[', '3', '3', 'm'},
0000000000000000000000000000000000000000;;		Blue:    []byte{keyEscape, '[', '3', '4', 'm'},
0000000000000000000000000000000000000000;;		Magenta: []byte{keyEscape, '[', '3', '5', 'm'},
0000000000000000000000000000000000000000;;		Cyan:    []byte{keyEscape, '[', '3', '6', 'm'},
0000000000000000000000000000000000000000;;		White:   []byte{keyEscape, '[', '3', '7', 'm'},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Reset: []byte{keyEscape, '[', '0', 'm'},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Terminal contains the state for running a VT100 terminal that is capable of
0000000000000000000000000000000000000000;;	// reading lines of input.
0000000000000000000000000000000000000000;;	type Terminal struct {
0000000000000000000000000000000000000000;;		// AutoCompleteCallback, if non-null, is called for each keypress with
0000000000000000000000000000000000000000;;		// the full input line and the current position of the cursor (in
0000000000000000000000000000000000000000;;		// bytes, as an index into |line|). If it returns ok=false, the key
0000000000000000000000000000000000000000;;		// press is processed normally. Otherwise it returns a replacement line
0000000000000000000000000000000000000000;;		// and the new cursor position.
0000000000000000000000000000000000000000;;		AutoCompleteCallback func(line string, pos int, key rune) (newLine string, newPos int, ok bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Escape contains a pointer to the escape codes for this terminal.
0000000000000000000000000000000000000000;;		// It's always a valid pointer, although the escape codes themselves
0000000000000000000000000000000000000000;;		// may be empty if the terminal doesn't support them.
0000000000000000000000000000000000000000;;		Escape *EscapeCodes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lock protects the terminal and the state in this object from
0000000000000000000000000000000000000000;;		// concurrent processing of a key press and a Write() call.
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c      io.ReadWriter
0000000000000000000000000000000000000000;;		prompt []rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// line is the current line being entered.
0000000000000000000000000000000000000000;;		line []rune
0000000000000000000000000000000000000000;;		// pos is the logical position of the cursor in line
0000000000000000000000000000000000000000;;		pos int
0000000000000000000000000000000000000000;;		// echo is true if local echo is enabled
0000000000000000000000000000000000000000;;		echo bool
0000000000000000000000000000000000000000;;		// pasteActive is true iff there is a bracketed paste operation in
0000000000000000000000000000000000000000;;		// progress.
0000000000000000000000000000000000000000;;		pasteActive bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cursorX contains the current X value of the cursor where the left
0000000000000000000000000000000000000000;;		// edge is 0. cursorY contains the row number where the first row of
0000000000000000000000000000000000000000;;		// the current line is 0.
0000000000000000000000000000000000000000;;		cursorX, cursorY int
0000000000000000000000000000000000000000;;		// maxLine is the greatest value of cursorY so far.
0000000000000000000000000000000000000000;;		maxLine int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		termWidth, termHeight int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// outBuf contains the terminal data to be sent.
0000000000000000000000000000000000000000;;		outBuf []byte
0000000000000000000000000000000000000000;;		// remainder contains the remainder of any partial key sequences after
0000000000000000000000000000000000000000;;		// a read. It aliases into inBuf.
0000000000000000000000000000000000000000;;		remainder []byte
0000000000000000000000000000000000000000;;		inBuf     [256]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// history contains previously entered commands so that they can be
0000000000000000000000000000000000000000;;		// accessed with the up and down keys.
0000000000000000000000000000000000000000;;		history stRingBuffer
0000000000000000000000000000000000000000;;		// historyIndex stores the currently accessed history entry, where zero
0000000000000000000000000000000000000000;;		// means the immediately previous entry.
0000000000000000000000000000000000000000;;		historyIndex int
0000000000000000000000000000000000000000;;		// When navigating up and down the history it's possible to return to
0000000000000000000000000000000000000000;;		// the incomplete, initial line. That value is stored in
0000000000000000000000000000000000000000;;		// historyPending.
0000000000000000000000000000000000000000;;		historyPending string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTerminal runs a VT100 terminal on the given ReadWriter. If the ReadWriter is
0000000000000000000000000000000000000000;;	// a local terminal, that terminal must first have been put into raw mode.
0000000000000000000000000000000000000000;;	// prompt is a string that is written at the start of each input line (i.e.
0000000000000000000000000000000000000000;;	// "> ").
0000000000000000000000000000000000000000;;	func NewTerminal(c io.ReadWriter, prompt string) *Terminal {
0000000000000000000000000000000000000000;;		return &Terminal{
0000000000000000000000000000000000000000;;			Escape:       &vt100EscapeCodes,
0000000000000000000000000000000000000000;;			c:            c,
0000000000000000000000000000000000000000;;			prompt:       []rune(prompt),
0000000000000000000000000000000000000000;;			termWidth:    80,
0000000000000000000000000000000000000000;;			termHeight:   24,
0000000000000000000000000000000000000000;;			echo:         true,
0000000000000000000000000000000000000000;;			historyIndex: -1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		keyCtrlD     = 4
0000000000000000000000000000000000000000;;		keyCtrlU     = 21
0000000000000000000000000000000000000000;;		keyEnter     = '\r'
0000000000000000000000000000000000000000;;		keyEscape    = 27
0000000000000000000000000000000000000000;;		keyBackspace = 127
0000000000000000000000000000000000000000;;		keyUnknown   = 0xd800 /* UTF-16 surrogate area */ + iota
0000000000000000000000000000000000000000;;		keyUp
0000000000000000000000000000000000000000;;		keyDown
0000000000000000000000000000000000000000;;		keyLeft
0000000000000000000000000000000000000000;;		keyRight
0000000000000000000000000000000000000000;;		keyAltLeft
0000000000000000000000000000000000000000;;		keyAltRight
0000000000000000000000000000000000000000;;		keyHome
0000000000000000000000000000000000000000;;		keyEnd
0000000000000000000000000000000000000000;;		keyDeleteWord
0000000000000000000000000000000000000000;;		keyDeleteLine
0000000000000000000000000000000000000000;;		keyClearScreen
0000000000000000000000000000000000000000;;		keyPasteStart
0000000000000000000000000000000000000000;;		keyPasteEnd
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var pasteStart = []byte{keyEscape, '[', '2', '0', '0', '~'}
0000000000000000000000000000000000000000;;	var pasteEnd = []byte{keyEscape, '[', '2', '0', '1', '~'}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bytesToKey tries to parse a key sequence from b. If successful, it returns
0000000000000000000000000000000000000000;;	// the key and the remainder of the input. Otherwise it returns utf8.RuneError.
0000000000000000000000000000000000000000;;	func bytesToKey(b []byte, pasteActive bool) (rune, []byte) {
0000000000000000000000000000000000000000;;		if len(b) == 0 {
0000000000000000000000000000000000000000;;			return utf8.RuneError, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !pasteActive {
0000000000000000000000000000000000000000;;			switch b[0] {
0000000000000000000000000000000000000000;;			case 1: // ^A
0000000000000000000000000000000000000000;;				return keyHome, b[1:]
0000000000000000000000000000000000000000;;			case 5: // ^E
0000000000000000000000000000000000000000;;				return keyEnd, b[1:]
0000000000000000000000000000000000000000;;			case 8: // ^H
0000000000000000000000000000000000000000;;				return keyBackspace, b[1:]
0000000000000000000000000000000000000000;;			case 11: // ^K
0000000000000000000000000000000000000000;;				return keyDeleteLine, b[1:]
0000000000000000000000000000000000000000;;			case 12: // ^L
0000000000000000000000000000000000000000;;				return keyClearScreen, b[1:]
0000000000000000000000000000000000000000;;			case 23: // ^W
0000000000000000000000000000000000000000;;				return keyDeleteWord, b[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if b[0] != keyEscape {
0000000000000000000000000000000000000000;;			if !utf8.FullRune(b) {
0000000000000000000000000000000000000000;;				return utf8.RuneError, b
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r, l := utf8.DecodeRune(b)
0000000000000000000000000000000000000000;;			return r, b[l:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !pasteActive && len(b) >= 3 && b[0] == keyEscape && b[1] == '[' {
0000000000000000000000000000000000000000;;			switch b[2] {
0000000000000000000000000000000000000000;;			case 'A':
0000000000000000000000000000000000000000;;				return keyUp, b[3:]
0000000000000000000000000000000000000000;;			case 'B':
0000000000000000000000000000000000000000;;				return keyDown, b[3:]
0000000000000000000000000000000000000000;;			case 'C':
0000000000000000000000000000000000000000;;				return keyRight, b[3:]
0000000000000000000000000000000000000000;;			case 'D':
0000000000000000000000000000000000000000;;				return keyLeft, b[3:]
0000000000000000000000000000000000000000;;			case 'H':
0000000000000000000000000000000000000000;;				return keyHome, b[3:]
0000000000000000000000000000000000000000;;			case 'F':
0000000000000000000000000000000000000000;;				return keyEnd, b[3:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !pasteActive && len(b) >= 6 && b[0] == keyEscape && b[1] == '[' && b[2] == '1' && b[3] == ';' && b[4] == '3' {
0000000000000000000000000000000000000000;;			switch b[5] {
0000000000000000000000000000000000000000;;			case 'C':
0000000000000000000000000000000000000000;;				return keyAltRight, b[6:]
0000000000000000000000000000000000000000;;			case 'D':
0000000000000000000000000000000000000000;;				return keyAltLeft, b[6:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !pasteActive && len(b) >= 6 && bytes.Equal(b[:6], pasteStart) {
0000000000000000000000000000000000000000;;			return keyPasteStart, b[6:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pasteActive && len(b) >= 6 && bytes.Equal(b[:6], pasteEnd) {
0000000000000000000000000000000000000000;;			return keyPasteEnd, b[6:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we get here then we have a key that we don't recognise, or a
0000000000000000000000000000000000000000;;		// partial sequence. It's not clear how one should find the end of a
0000000000000000000000000000000000000000;;		// sequence without knowing them all, but it seems that [a-zA-Z~] only
0000000000000000000000000000000000000000;;		// appears at the end of a sequence.
0000000000000000000000000000000000000000;;		for i, c := range b[0:] {
0000000000000000000000000000000000000000;;			if c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '~' {
0000000000000000000000000000000000000000;;				return keyUnknown, b[i+1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return utf8.RuneError, b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// queue appends data to the end of t.outBuf
0000000000000000000000000000000000000000;;	func (t *Terminal) queue(data []rune) {
0000000000000000000000000000000000000000;;		t.outBuf = append(t.outBuf, []byte(string(data))...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var eraseUnderCursor = []rune{' ', keyEscape, '[', 'D'}
0000000000000000000000000000000000000000;;	var space = []rune{' '}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isPrintable(key rune) bool {
0000000000000000000000000000000000000000;;		isInSurrogateArea := key >= 0xd800 && key <= 0xdbff
0000000000000000000000000000000000000000;;		return key >= 32 && !isInSurrogateArea
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// moveCursorToPos appends data to t.outBuf which will move the cursor to the
0000000000000000000000000000000000000000;;	// given, logical position in the text.
0000000000000000000000000000000000000000;;	func (t *Terminal) moveCursorToPos(pos int) {
0000000000000000000000000000000000000000;;		if !t.echo {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := visualLength(t.prompt) + pos
0000000000000000000000000000000000000000;;		y := x / t.termWidth
0000000000000000000000000000000000000000;;		x = x % t.termWidth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		up := 0
0000000000000000000000000000000000000000;;		if y < t.cursorY {
0000000000000000000000000000000000000000;;			up = t.cursorY - y
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		down := 0
0000000000000000000000000000000000000000;;		if y > t.cursorY {
0000000000000000000000000000000000000000;;			down = y - t.cursorY
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		left := 0
0000000000000000000000000000000000000000;;		if x < t.cursorX {
0000000000000000000000000000000000000000;;			left = t.cursorX - x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		right := 0
0000000000000000000000000000000000000000;;		if x > t.cursorX {
0000000000000000000000000000000000000000;;			right = x - t.cursorX
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.cursorX = x
0000000000000000000000000000000000000000;;		t.cursorY = y
0000000000000000000000000000000000000000;;		t.move(up, down, left, right)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Terminal) move(up, down, left, right int) {
0000000000000000000000000000000000000000;;		movement := make([]rune, 3*(up+down+left+right))
0000000000000000000000000000000000000000;;		m := movement
0000000000000000000000000000000000000000;;		for i := 0; i < up; i++ {
0000000000000000000000000000000000000000;;			m[0] = keyEscape
0000000000000000000000000000000000000000;;			m[1] = '['
0000000000000000000000000000000000000000;;			m[2] = 'A'
0000000000000000000000000000000000000000;;			m = m[3:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < down; i++ {
0000000000000000000000000000000000000000;;			m[0] = keyEscape
0000000000000000000000000000000000000000;;			m[1] = '['
0000000000000000000000000000000000000000;;			m[2] = 'B'
0000000000000000000000000000000000000000;;			m = m[3:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < left; i++ {
0000000000000000000000000000000000000000;;			m[0] = keyEscape
0000000000000000000000000000000000000000;;			m[1] = '['
0000000000000000000000000000000000000000;;			m[2] = 'D'
0000000000000000000000000000000000000000;;			m = m[3:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < right; i++ {
0000000000000000000000000000000000000000;;			m[0] = keyEscape
0000000000000000000000000000000000000000;;			m[1] = '['
0000000000000000000000000000000000000000;;			m[2] = 'C'
0000000000000000000000000000000000000000;;			m = m[3:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.queue(movement)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Terminal) clearLineToRight() {
0000000000000000000000000000000000000000;;		op := []rune{keyEscape, '[', 'K'}
0000000000000000000000000000000000000000;;		t.queue(op)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxLineLength = 4096
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Terminal) setLine(newLine []rune, newPos int) {
0000000000000000000000000000000000000000;;		if t.echo {
0000000000000000000000000000000000000000;;			t.moveCursorToPos(0)
0000000000000000000000000000000000000000;;			t.writeLine(newLine)
0000000000000000000000000000000000000000;;			for i := len(newLine); i < len(t.line); i++ {
0000000000000000000000000000000000000000;;				t.writeLine(space)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.moveCursorToPos(newPos)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.line = newLine
0000000000000000000000000000000000000000;;		t.pos = newPos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Terminal) advanceCursor(places int) {
0000000000000000000000000000000000000000;;		t.cursorX += places
0000000000000000000000000000000000000000;;		t.cursorY += t.cursorX / t.termWidth
0000000000000000000000000000000000000000;;		if t.cursorY > t.maxLine {
0000000000000000000000000000000000000000;;			t.maxLine = t.cursorY
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.cursorX = t.cursorX % t.termWidth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if places > 0 && t.cursorX == 0 {
0000000000000000000000000000000000000000;;			// Normally terminals will advance the current position
0000000000000000000000000000000000000000;;			// when writing a character. But that doesn't happen
0000000000000000000000000000000000000000;;			// for the last character in a line. However, when
0000000000000000000000000000000000000000;;			// writing a character (except a new line) that causes
0000000000000000000000000000000000000000;;			// a line wrap, the position will be advanced two
0000000000000000000000000000000000000000;;			// places.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// So, if we are stopping at the end of a line, we
0000000000000000000000000000000000000000;;			// need to write a newline so that our cursor can be
0000000000000000000000000000000000000000;;			// advanced to the next line.
0000000000000000000000000000000000000000;;			t.outBuf = append(t.outBuf, '\n')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Terminal) eraseNPreviousChars(n int) {
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.pos < n {
0000000000000000000000000000000000000000;;			n = t.pos
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.pos -= n
0000000000000000000000000000000000000000;;		t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(t.line[t.pos:], t.line[n+t.pos:])
0000000000000000000000000000000000000000;;		t.line = t.line[:len(t.line)-n]
0000000000000000000000000000000000000000;;		if t.echo {
0000000000000000000000000000000000000000;;			t.writeLine(t.line[t.pos:])
0000000000000000000000000000000000000000;;			for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;				t.queue(space)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.advanceCursor(n)
0000000000000000000000000000000000000000;;			t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// countToLeftWord returns then number of characters from the cursor to the
0000000000000000000000000000000000000000;;	// start of the previous word.
0000000000000000000000000000000000000000;;	func (t *Terminal) countToLeftWord() int {
0000000000000000000000000000000000000000;;		if t.pos == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pos := t.pos - 1
0000000000000000000000000000000000000000;;		for pos > 0 {
0000000000000000000000000000000000000000;;			if t.line[pos] != ' ' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pos--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for pos > 0 {
0000000000000000000000000000000000000000;;			if t.line[pos] == ' ' {
0000000000000000000000000000000000000000;;				pos++
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pos--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t.pos - pos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// countToRightWord returns then number of characters from the cursor to the
0000000000000000000000000000000000000000;;	// start of the next word.
0000000000000000000000000000000000000000;;	func (t *Terminal) countToRightWord() int {
0000000000000000000000000000000000000000;;		pos := t.pos
0000000000000000000000000000000000000000;;		for pos < len(t.line) {
0000000000000000000000000000000000000000;;			if t.line[pos] == ' ' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pos++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for pos < len(t.line) {
0000000000000000000000000000000000000000;;			if t.line[pos] != ' ' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pos++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pos - t.pos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// visualLength returns the number of visible glyphs in s.
0000000000000000000000000000000000000000;;	func visualLength(runes []rune) int {
0000000000000000000000000000000000000000;;		inEscapeSeq := false
0000000000000000000000000000000000000000;;		length := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range runes {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case inEscapeSeq:
0000000000000000000000000000000000000000;;				if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') {
0000000000000000000000000000000000000000;;					inEscapeSeq = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case r == '\x1b':
0000000000000000000000000000000000000000;;				inEscapeSeq = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				length++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return length
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleKey processes the given key and, optionally, returns a line of text
0000000000000000000000000000000000000000;;	// that the user has entered.
0000000000000000000000000000000000000000;;	func (t *Terminal) handleKey(key rune) (line string, ok bool) {
0000000000000000000000000000000000000000;;		if t.pasteActive && key != keyEnter {
0000000000000000000000000000000000000000;;			t.addKeyToLine(key)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch key {
0000000000000000000000000000000000000000;;		case keyBackspace:
0000000000000000000000000000000000000000;;			if t.pos == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.eraseNPreviousChars(1)
0000000000000000000000000000000000000000;;		case keyAltLeft:
0000000000000000000000000000000000000000;;			// move left by a word.
0000000000000000000000000000000000000000;;			t.pos -= t.countToLeftWord()
0000000000000000000000000000000000000000;;			t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;		case keyAltRight:
0000000000000000000000000000000000000000;;			// move right by a word.
0000000000000000000000000000000000000000;;			t.pos += t.countToRightWord()
0000000000000000000000000000000000000000;;			t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;		case keyLeft:
0000000000000000000000000000000000000000;;			if t.pos == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.pos--
0000000000000000000000000000000000000000;;			t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;		case keyRight:
0000000000000000000000000000000000000000;;			if t.pos == len(t.line) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.pos++
0000000000000000000000000000000000000000;;			t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;		case keyHome:
0000000000000000000000000000000000000000;;			if t.pos == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.pos = 0
0000000000000000000000000000000000000000;;			t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;		case keyEnd:
0000000000000000000000000000000000000000;;			if t.pos == len(t.line) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.pos = len(t.line)
0000000000000000000000000000000000000000;;			t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;		case keyUp:
0000000000000000000000000000000000000000;;			entry, ok := t.history.NthPreviousEntry(t.historyIndex + 1)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return "", false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.historyIndex == -1 {
0000000000000000000000000000000000000000;;				t.historyPending = string(t.line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.historyIndex++
0000000000000000000000000000000000000000;;			runes := []rune(entry)
0000000000000000000000000000000000000000;;			t.setLine(runes, len(runes))
0000000000000000000000000000000000000000;;		case keyDown:
0000000000000000000000000000000000000000;;			switch t.historyIndex {
0000000000000000000000000000000000000000;;			case -1:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				runes := []rune(t.historyPending)
0000000000000000000000000000000000000000;;				t.setLine(runes, len(runes))
0000000000000000000000000000000000000000;;				t.historyIndex--
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				entry, ok := t.history.NthPreviousEntry(t.historyIndex - 1)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					t.historyIndex--
0000000000000000000000000000000000000000;;					runes := []rune(entry)
0000000000000000000000000000000000000000;;					t.setLine(runes, len(runes))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case keyEnter:
0000000000000000000000000000000000000000;;			t.moveCursorToPos(len(t.line))
0000000000000000000000000000000000000000;;			t.queue([]rune("\r\n"))
0000000000000000000000000000000000000000;;			line = string(t.line)
0000000000000000000000000000000000000000;;			ok = true
0000000000000000000000000000000000000000;;			t.line = t.line[:0]
0000000000000000000000000000000000000000;;			t.pos = 0
0000000000000000000000000000000000000000;;			t.cursorX = 0
0000000000000000000000000000000000000000;;			t.cursorY = 0
0000000000000000000000000000000000000000;;			t.maxLine = 0
0000000000000000000000000000000000000000;;		case keyDeleteWord:
0000000000000000000000000000000000000000;;			// Delete zero or more spaces and then one or more characters.
0000000000000000000000000000000000000000;;			t.eraseNPreviousChars(t.countToLeftWord())
0000000000000000000000000000000000000000;;		case keyDeleteLine:
0000000000000000000000000000000000000000;;			// Delete everything from the current cursor position to the
0000000000000000000000000000000000000000;;			// end of line.
0000000000000000000000000000000000000000;;			for i := t.pos; i < len(t.line); i++ {
0000000000000000000000000000000000000000;;				t.queue(space)
0000000000000000000000000000000000000000;;				t.advanceCursor(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.line = t.line[:t.pos]
0000000000000000000000000000000000000000;;			t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;		case keyCtrlD:
0000000000000000000000000000000000000000;;			// Erase the character under the current position.
0000000000000000000000000000000000000000;;			// The EOF case when the line is empty is handled in
0000000000000000000000000000000000000000;;			// readLine().
0000000000000000000000000000000000000000;;			if t.pos < len(t.line) {
0000000000000000000000000000000000000000;;				t.pos++
0000000000000000000000000000000000000000;;				t.eraseNPreviousChars(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case keyCtrlU:
0000000000000000000000000000000000000000;;			t.eraseNPreviousChars(t.pos)
0000000000000000000000000000000000000000;;		case keyClearScreen:
0000000000000000000000000000000000000000;;			// Erases the screen and moves the cursor to the home position.
0000000000000000000000000000000000000000;;			t.queue([]rune("\x1b[2J\x1b[H"))
0000000000000000000000000000000000000000;;			t.queue(t.prompt)
0000000000000000000000000000000000000000;;			t.cursorX, t.cursorY = 0, 0
0000000000000000000000000000000000000000;;			t.advanceCursor(visualLength(t.prompt))
0000000000000000000000000000000000000000;;			t.setLine(t.line, t.pos)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if t.AutoCompleteCallback != nil {
0000000000000000000000000000000000000000;;				prefix := string(t.line[:t.pos])
0000000000000000000000000000000000000000;;				suffix := string(t.line[t.pos:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				t.lock.Unlock()
0000000000000000000000000000000000000000;;				newLine, newPos, completeOk := t.AutoCompleteCallback(prefix+suffix, len(prefix), key)
0000000000000000000000000000000000000000;;				t.lock.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if completeOk {
0000000000000000000000000000000000000000;;					t.setLine([]rune(newLine), utf8.RuneCount([]byte(newLine)[:newPos]))
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !isPrintable(key) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(t.line) == maxLineLength {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.addKeyToLine(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addKeyToLine inserts the given key at the current position in the current
0000000000000000000000000000000000000000;;	// line.
0000000000000000000000000000000000000000;;	func (t *Terminal) addKeyToLine(key rune) {
0000000000000000000000000000000000000000;;		if len(t.line) == cap(t.line) {
0000000000000000000000000000000000000000;;			newLine := make([]rune, len(t.line), 2*(1+len(t.line)))
0000000000000000000000000000000000000000;;			copy(newLine, t.line)
0000000000000000000000000000000000000000;;			t.line = newLine
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.line = t.line[:len(t.line)+1]
0000000000000000000000000000000000000000;;		copy(t.line[t.pos+1:], t.line[t.pos:])
0000000000000000000000000000000000000000;;		t.line[t.pos] = key
0000000000000000000000000000000000000000;;		if t.echo {
0000000000000000000000000000000000000000;;			t.writeLine(t.line[t.pos:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.pos++
0000000000000000000000000000000000000000;;		t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Terminal) writeLine(line []rune) {
0000000000000000000000000000000000000000;;		for len(line) != 0 {
0000000000000000000000000000000000000000;;			remainingOnLine := t.termWidth - t.cursorX
0000000000000000000000000000000000000000;;			todo := len(line)
0000000000000000000000000000000000000000;;			if todo > remainingOnLine {
0000000000000000000000000000000000000000;;				todo = remainingOnLine
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.queue(line[:todo])
0000000000000000000000000000000000000000;;			t.advanceCursor(visualLength(line[:todo]))
0000000000000000000000000000000000000000;;			line = line[todo:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Terminal) Write(buf []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		t.lock.Lock()
0000000000000000000000000000000000000000;;		defer t.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.cursorX == 0 && t.cursorY == 0 {
0000000000000000000000000000000000000000;;			// This is the easy case: there's nothing on the screen that we
0000000000000000000000000000000000000000;;			// have to move out of the way.
0000000000000000000000000000000000000000;;			return t.c.Write(buf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We have a prompt and possibly user input on the screen. We
0000000000000000000000000000000000000000;;		// have to clear it first.
0000000000000000000000000000000000000000;;		t.move(0 /* up */, 0 /* down */, t.cursorX /* left */, 0 /* right */)
0000000000000000000000000000000000000000;;		t.cursorX = 0
0000000000000000000000000000000000000000;;		t.clearLineToRight()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for t.cursorY > 0 {
0000000000000000000000000000000000000000;;			t.move(1 /* up */, 0, 0, 0)
0000000000000000000000000000000000000000;;			t.cursorY--
0000000000000000000000000000000000000000;;			t.clearLineToRight()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err = t.c.Write(t.outBuf); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.outBuf = t.outBuf[:0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n, err = t.c.Write(buf); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.writeLine(t.prompt)
0000000000000000000000000000000000000000;;		if t.echo {
0000000000000000000000000000000000000000;;			t.writeLine(t.line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err = t.c.Write(t.outBuf); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.outBuf = t.outBuf[:0]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadPassword temporarily changes the prompt and reads a password, without
0000000000000000000000000000000000000000;;	// echo, from the terminal.
0000000000000000000000000000000000000000;;	func (t *Terminal) ReadPassword(prompt string) (line string, err error) {
0000000000000000000000000000000000000000;;		t.lock.Lock()
0000000000000000000000000000000000000000;;		defer t.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldPrompt := t.prompt
0000000000000000000000000000000000000000;;		t.prompt = []rune(prompt)
0000000000000000000000000000000000000000;;		t.echo = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		line, err = t.readLine()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.prompt = oldPrompt
0000000000000000000000000000000000000000;;		t.echo = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadLine returns a line of input from the terminal.
0000000000000000000000000000000000000000;;	func (t *Terminal) ReadLine() (line string, err error) {
0000000000000000000000000000000000000000;;		t.lock.Lock()
0000000000000000000000000000000000000000;;		defer t.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t.readLine()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Terminal) readLine() (line string, err error) {
0000000000000000000000000000000000000000;;		// t.lock must be held at this point
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.cursorX == 0 && t.cursorY == 0 {
0000000000000000000000000000000000000000;;			t.writeLine(t.prompt)
0000000000000000000000000000000000000000;;			t.c.Write(t.outBuf)
0000000000000000000000000000000000000000;;			t.outBuf = t.outBuf[:0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lineIsPasted := t.pasteActive
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			rest := t.remainder
0000000000000000000000000000000000000000;;			lineOk := false
0000000000000000000000000000000000000000;;			for !lineOk {
0000000000000000000000000000000000000000;;				var key rune
0000000000000000000000000000000000000000;;				key, rest = bytesToKey(rest, t.pasteActive)
0000000000000000000000000000000000000000;;				if key == utf8.RuneError {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !t.pasteActive {
0000000000000000000000000000000000000000;;					if key == keyCtrlD {
0000000000000000000000000000000000000000;;						if len(t.line) == 0 {
0000000000000000000000000000000000000000;;							return "", io.EOF
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if key == keyPasteStart {
0000000000000000000000000000000000000000;;						t.pasteActive = true
0000000000000000000000000000000000000000;;						if len(t.line) == 0 {
0000000000000000000000000000000000000000;;							lineIsPasted = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if key == keyPasteEnd {
0000000000000000000000000000000000000000;;					t.pasteActive = false
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !t.pasteActive {
0000000000000000000000000000000000000000;;					lineIsPasted = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				line, lineOk = t.handleKey(key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(rest) > 0 {
0000000000000000000000000000000000000000;;				n := copy(t.inBuf[:], rest)
0000000000000000000000000000000000000000;;				t.remainder = t.inBuf[:n]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.remainder = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.c.Write(t.outBuf)
0000000000000000000000000000000000000000;;			t.outBuf = t.outBuf[:0]
0000000000000000000000000000000000000000;;			if lineOk {
0000000000000000000000000000000000000000;;				if t.echo {
0000000000000000000000000000000000000000;;					t.historyIndex = -1
0000000000000000000000000000000000000000;;					t.history.Add(line)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if lineIsPasted {
0000000000000000000000000000000000000000;;					err = ErrPasteIndicator
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// t.remainder is a slice at the beginning of t.inBuf
0000000000000000000000000000000000000000;;			// containing a partial key sequence
0000000000000000000000000000000000000000;;			readBuf := t.inBuf[len(t.remainder):]
0000000000000000000000000000000000000000;;			var n int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t.lock.Unlock()
0000000000000000000000000000000000000000;;			n, err = t.c.Read(readBuf)
0000000000000000000000000000000000000000;;			t.lock.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t.remainder = t.inBuf[:n+len(t.remainder)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		panic("unreachable") // for Go 1.0.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPrompt sets the prompt to be used when reading subsequent lines.
0000000000000000000000000000000000000000;;	func (t *Terminal) SetPrompt(prompt string) {
0000000000000000000000000000000000000000;;		t.lock.Lock()
0000000000000000000000000000000000000000;;		defer t.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.prompt = []rune(prompt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Terminal) clearAndRepaintLinePlusNPrevious(numPrevLines int) {
0000000000000000000000000000000000000000;;		// Move cursor to column zero at the start of the line.
0000000000000000000000000000000000000000;;		t.move(t.cursorY, 0, t.cursorX, 0)
0000000000000000000000000000000000000000;;		t.cursorX, t.cursorY = 0, 0
0000000000000000000000000000000000000000;;		t.clearLineToRight()
0000000000000000000000000000000000000000;;		for t.cursorY < numPrevLines {
0000000000000000000000000000000000000000;;			// Move down a line
0000000000000000000000000000000000000000;;			t.move(0, 1, 0, 0)
0000000000000000000000000000000000000000;;			t.cursorY++
0000000000000000000000000000000000000000;;			t.clearLineToRight()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Move back to beginning.
0000000000000000000000000000000000000000;;		t.move(t.cursorY, 0, 0, 0)
0000000000000000000000000000000000000000;;		t.cursorX, t.cursorY = 0, 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.queue(t.prompt)
0000000000000000000000000000000000000000;;		t.advanceCursor(visualLength(t.prompt))
0000000000000000000000000000000000000000;;		t.writeLine(t.line)
0000000000000000000000000000000000000000;;		t.moveCursorToPos(t.pos)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Terminal) SetSize(width, height int) error {
0000000000000000000000000000000000000000;;		t.lock.Lock()
0000000000000000000000000000000000000000;;		defer t.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if width == 0 {
0000000000000000000000000000000000000000;;			width = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldWidth := t.termWidth
0000000000000000000000000000000000000000;;		t.termWidth, t.termHeight = width, height
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case width == oldWidth:
0000000000000000000000000000000000000000;;			// If the width didn't change then nothing else needs to be
0000000000000000000000000000000000000000;;			// done.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case len(t.line) == 0 && t.cursorX == 0 && t.cursorY == 0:
0000000000000000000000000000000000000000;;			// If there is nothing on current line and no prompt printed,
0000000000000000000000000000000000000000;;			// just do nothing
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case width < oldWidth:
0000000000000000000000000000000000000000;;			// Some terminals (e.g. xterm) will truncate lines that were
0000000000000000000000000000000000000000;;			// too long when shinking. Others, (e.g. gnome-terminal) will
0000000000000000000000000000000000000000;;			// attempt to wrap them. For the former, repainting t.maxLine
0000000000000000000000000000000000000000;;			// works great, but that behaviour goes badly wrong in the case
0000000000000000000000000000000000000000;;			// of the latter because they have doubled every full line.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We assume that we are working on a terminal that wraps lines
0000000000000000000000000000000000000000;;			// and adjust the cursor position based on every previous line
0000000000000000000000000000000000000000;;			// wrapping and turning into two. This causes the prompt on
0000000000000000000000000000000000000000;;			// xterms to move upwards, which isn't great, but it avoids a
0000000000000000000000000000000000000000;;			// huge mess with gnome-terminal.
0000000000000000000000000000000000000000;;			if t.cursorX >= t.termWidth {
0000000000000000000000000000000000000000;;				t.cursorX = t.termWidth - 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.cursorY *= 2
0000000000000000000000000000000000000000;;			t.clearAndRepaintLinePlusNPrevious(t.maxLine * 2)
0000000000000000000000000000000000000000;;		case width > oldWidth:
0000000000000000000000000000000000000000;;			// If the terminal expands then our position calculations will
0000000000000000000000000000000000000000;;			// be wrong in the future because we think the cursor is
0000000000000000000000000000000000000000;;			// |t.pos| chars into the string, but there will be a gap at
0000000000000000000000000000000000000000;;			// the end of any wrapped line.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// But the position will actually be correct until we move, so
0000000000000000000000000000000000000000;;			// we can move back to the beginning and repaint everything.
0000000000000000000000000000000000000000;;			t.clearAndRepaintLinePlusNPrevious(t.maxLine)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := t.c.Write(t.outBuf)
0000000000000000000000000000000000000000;;		t.outBuf = t.outBuf[:0]
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pasteIndicatorError struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pasteIndicatorError) Error() string {
0000000000000000000000000000000000000000;;		return "terminal: ErrPasteIndicator not correctly handled"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrPasteIndicator may be returned from ReadLine as the error, in addition
0000000000000000000000000000000000000000;;	// to valid line data. It indicates that bracketed paste mode is enabled and
0000000000000000000000000000000000000000;;	// that the returned line consists only of pasted data. Programs may wish to
0000000000000000000000000000000000000000;;	// interpret pasted data more literally than typed data.
0000000000000000000000000000000000000000;;	var ErrPasteIndicator = pasteIndicatorError{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetBracketedPasteMode requests that the terminal bracket paste operations
0000000000000000000000000000000000000000;;	// with markers. Not all terminals support this but, if it is supported, then
0000000000000000000000000000000000000000;;	// enabling this mode will stop any autocomplete callback from running due to
0000000000000000000000000000000000000000;;	// pastes. Additionally, any lines that are completely pasted will be returned
0000000000000000000000000000000000000000;;	// from ReadLine with the error set to ErrPasteIndicator.
0000000000000000000000000000000000000000;;	func (t *Terminal) SetBracketedPasteMode(on bool) {
0000000000000000000000000000000000000000;;		if on {
0000000000000000000000000000000000000000;;			io.WriteString(t.c, "\x1b[?2004h")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			io.WriteString(t.c, "\x1b[?2004l")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stRingBuffer is a ring buffer of strings.
0000000000000000000000000000000000000000;;	type stRingBuffer struct {
0000000000000000000000000000000000000000;;		// entries contains max elements.
0000000000000000000000000000000000000000;;		entries []string
0000000000000000000000000000000000000000;;		max     int
0000000000000000000000000000000000000000;;		// head contains the index of the element most recently added to the ring.
0000000000000000000000000000000000000000;;		head int
0000000000000000000000000000000000000000;;		// size contains the number of elements in the ring.
0000000000000000000000000000000000000000;;		size int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stRingBuffer) Add(a string) {
0000000000000000000000000000000000000000;;		if s.entries == nil {
0000000000000000000000000000000000000000;;			const defaultNumEntries = 100
0000000000000000000000000000000000000000;;			s.entries = make([]string, defaultNumEntries)
0000000000000000000000000000000000000000;;			s.max = defaultNumEntries
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.head = (s.head + 1) % s.max
0000000000000000000000000000000000000000;;		s.entries[s.head] = a
0000000000000000000000000000000000000000;;		if s.size < s.max {
0000000000000000000000000000000000000000;;			s.size++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NthPreviousEntry returns the value passed to the nth previous call to Add.
0000000000000000000000000000000000000000;;	// If n is zero then the immediately prior value is returned, if one, then the
0000000000000000000000000000000000000000;;	// next most recent, and so on. If such an element doesn't exist then ok is
0000000000000000000000000000000000000000;;	// false.
0000000000000000000000000000000000000000;;	func (s *stRingBuffer) NthPreviousEntry(n int) (value string, ok bool) {
0000000000000000000000000000000000000000;;		if n >= s.size {
0000000000000000000000000000000000000000;;			return "", false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		index := s.head - n
0000000000000000000000000000000000000000;;		if index < 0 {
0000000000000000000000000000000000000000;;			index += s.max
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.entries[index], true
0000000000000000000000000000000000000000;;	}
