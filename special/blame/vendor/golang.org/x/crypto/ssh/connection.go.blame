0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/connection.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/connection.go][vendor/golang.org/x/crypto/ssh/connection.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenChannelError is returned if the other side rejects an
0000000000000000000000000000000000000000;;	// OpenChannel request.
0000000000000000000000000000000000000000;;	type OpenChannelError struct {
0000000000000000000000000000000000000000;;		Reason  RejectionReason
0000000000000000000000000000000000000000;;		Message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *OpenChannelError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("ssh: rejected: %s (%s)", e.Reason, e.Message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnMetadata holds metadata for the connection.
0000000000000000000000000000000000000000;;	type ConnMetadata interface {
0000000000000000000000000000000000000000;;		// User returns the user ID for this connection.
0000000000000000000000000000000000000000;;		User() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SessionID returns the sesson hash, also denoted by H.
0000000000000000000000000000000000000000;;		SessionID() []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClientVersion returns the client's version string as hashed
0000000000000000000000000000000000000000;;		// into the session ID.
0000000000000000000000000000000000000000;;		ClientVersion() []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServerVersion returns the server's version string as hashed
0000000000000000000000000000000000000000;;		// into the session ID.
0000000000000000000000000000000000000000;;		ServerVersion() []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RemoteAddr returns the remote address for this connection.
0000000000000000000000000000000000000000;;		RemoteAddr() net.Addr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LocalAddr returns the local address for this connection.
0000000000000000000000000000000000000000;;		LocalAddr() net.Addr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Conn represents an SSH connection for both server and client roles.
0000000000000000000000000000000000000000;;	// Conn is the basis for implementing an application layer, such
0000000000000000000000000000000000000000;;	// as ClientConn, which implements the traditional shell access for
0000000000000000000000000000000000000000;;	// clients.
0000000000000000000000000000000000000000;;	type Conn interface {
0000000000000000000000000000000000000000;;		ConnMetadata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SendRequest sends a global request, and returns the
0000000000000000000000000000000000000000;;		// reply. If wantReply is true, it returns the response status
0000000000000000000000000000000000000000;;		// and payload. See also RFC4254, section 4.
0000000000000000000000000000000000000000;;		SendRequest(name string, wantReply bool, payload []byte) (bool, []byte, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// OpenChannel tries to open an channel. If the request is
0000000000000000000000000000000000000000;;		// rejected, it returns *OpenChannelError. On success it returns
0000000000000000000000000000000000000000;;		// the SSH Channel and a Go channel for incoming, out-of-band
0000000000000000000000000000000000000000;;		// requests. The Go channel must be serviced, or the
0000000000000000000000000000000000000000;;		// connection will hang.
0000000000000000000000000000000000000000;;		OpenChannel(name string, data []byte) (Channel, <-chan *Request, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close closes the underlying network connection
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait blocks until the connection has shut down, and returns the
0000000000000000000000000000000000000000;;		// error causing the shutdown.
0000000000000000000000000000000000000000;;		Wait() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(hanwen): consider exposing:
0000000000000000000000000000000000000000;;		//   RequestKeyChange
0000000000000000000000000000000000000000;;		//   Disconnect
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DiscardRequests consumes and rejects all requests from the
0000000000000000000000000000000000000000;;	// passed-in channel.
0000000000000000000000000000000000000000;;	func DiscardRequests(in <-chan *Request) {
0000000000000000000000000000000000000000;;		for req := range in {
0000000000000000000000000000000000000000;;			if req.WantReply {
0000000000000000000000000000000000000000;;				req.Reply(false, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A connection represents an incoming connection.
0000000000000000000000000000000000000000;;	type connection struct {
0000000000000000000000000000000000000000;;		transport *handshakeTransport
0000000000000000000000000000000000000000;;		sshConn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The connection protocol.
0000000000000000000000000000000000000000;;		*mux
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *connection) Close() error {
0000000000000000000000000000000000000000;;		return c.sshConn.conn.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sshconn provides net.Conn metadata, but disallows direct reads and
0000000000000000000000000000000000000000;;	// writes.
0000000000000000000000000000000000000000;;	type sshConn struct {
0000000000000000000000000000000000000000;;		conn net.Conn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		user          string
0000000000000000000000000000000000000000;;		sessionID     []byte
0000000000000000000000000000000000000000;;		clientVersion []byte
0000000000000000000000000000000000000000;;		serverVersion []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dup(src []byte) []byte {
0000000000000000000000000000000000000000;;		dst := make([]byte, len(src))
0000000000000000000000000000000000000000;;		copy(dst, src)
0000000000000000000000000000000000000000;;		return dst
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sshConn) User() string {
0000000000000000000000000000000000000000;;		return c.user
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sshConn) RemoteAddr() net.Addr {
0000000000000000000000000000000000000000;;		return c.conn.RemoteAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sshConn) Close() error {
0000000000000000000000000000000000000000;;		return c.conn.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sshConn) LocalAddr() net.Addr {
0000000000000000000000000000000000000000;;		return c.conn.LocalAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sshConn) SessionID() []byte {
0000000000000000000000000000000000000000;;		return dup(c.sessionID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sshConn) ClientVersion() []byte {
0000000000000000000000000000000000000000;;		return dup(c.clientVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sshConn) ServerVersion() []byte {
0000000000000000000000000000000000000000;;		return dup(c.serverVersion)
0000000000000000000000000000000000000000;;	}
