0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/kex.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/kex.go][vendor/golang.org/x/crypto/ssh/kex.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/subtle"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/curve25519"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		kexAlgoDH1SHA1          = "diffie-hellman-group1-sha1"
0000000000000000000000000000000000000000;;		kexAlgoDH14SHA1         = "diffie-hellman-group14-sha1"
0000000000000000000000000000000000000000;;		kexAlgoECDH256          = "ecdh-sha2-nistp256"
0000000000000000000000000000000000000000;;		kexAlgoECDH384          = "ecdh-sha2-nistp384"
0000000000000000000000000000000000000000;;		kexAlgoECDH521          = "ecdh-sha2-nistp521"
0000000000000000000000000000000000000000;;		kexAlgoCurve25519SHA256 = "curve25519-sha256@libssh.org"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kexResult captures the outcome of a key exchange.
0000000000000000000000000000000000000000;;	type kexResult struct {
0000000000000000000000000000000000000000;;		// Session hash. See also RFC 4253, section 8.
0000000000000000000000000000000000000000;;		H []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Shared secret. See also RFC 4253, section 8.
0000000000000000000000000000000000000000;;		K []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Host key as hashed into H.
0000000000000000000000000000000000000000;;		HostKey []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Signature of H.
0000000000000000000000000000000000000000;;		Signature []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A cryptographic hash function that matches the security
0000000000000000000000000000000000000000;;		// level of the key exchange algorithm. It is used for
0000000000000000000000000000000000000000;;		// calculating H, and for deriving keys from H and K.
0000000000000000000000000000000000000000;;		Hash crypto.Hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The session ID, which is the first H computed. This is used
0000000000000000000000000000000000000000;;		// to derive key material inside the transport.
0000000000000000000000000000000000000000;;		SessionID []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handshakeMagics contains data that is always included in the
0000000000000000000000000000000000000000;;	// session hash.
0000000000000000000000000000000000000000;;	type handshakeMagics struct {
0000000000000000000000000000000000000000;;		clientVersion, serverVersion []byte
0000000000000000000000000000000000000000;;		clientKexInit, serverKexInit []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *handshakeMagics) write(w io.Writer) {
0000000000000000000000000000000000000000;;		writeString(w, m.clientVersion)
0000000000000000000000000000000000000000;;		writeString(w, m.serverVersion)
0000000000000000000000000000000000000000;;		writeString(w, m.clientKexInit)
0000000000000000000000000000000000000000;;		writeString(w, m.serverKexInit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kexAlgorithm abstracts different key exchange algorithms.
0000000000000000000000000000000000000000;;	type kexAlgorithm interface {
0000000000000000000000000000000000000000;;		// Server runs server-side key agreement, signing the result
0000000000000000000000000000000000000000;;		// with a hostkey.
0000000000000000000000000000000000000000;;		Server(p packetConn, rand io.Reader, magics *handshakeMagics, s Signer) (*kexResult, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Client runs the client-side key agreement. Caller is
0000000000000000000000000000000000000000;;		// responsible for verifying the host key signature.
0000000000000000000000000000000000000000;;		Client(p packetConn, rand io.Reader, magics *handshakeMagics) (*kexResult, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dhGroup is a multiplicative group suitable for implementing Diffie-Hellman key agreement.
0000000000000000000000000000000000000000;;	type dhGroup struct {
0000000000000000000000000000000000000000;;		g, p *big.Int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (group *dhGroup) diffieHellman(theirPublic, myPrivate *big.Int) (*big.Int, error) {
0000000000000000000000000000000000000000;;		if theirPublic.Sign() <= 0 || theirPublic.Cmp(group.p) >= 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: DH parameter out of bounds")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return new(big.Int).Exp(theirPublic, myPrivate, group.p), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (group *dhGroup) Client(c packetConn, randSource io.Reader, magics *handshakeMagics) (*kexResult, error) {
0000000000000000000000000000000000000000;;		hashFunc := crypto.SHA1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x, err := rand.Int(randSource, group.p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		X := new(big.Int).Exp(group.g, x, group.p)
0000000000000000000000000000000000000000;;		kexDHInit := kexDHInitMsg{
0000000000000000000000000000000000000000;;			X: X,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.writePacket(Marshal(&kexDHInit)); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		packet, err := c.readPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var kexDHReply kexDHReplyMsg
0000000000000000000000000000000000000000;;		if err = Unmarshal(packet, &kexDHReply); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kInt, err := group.diffieHellman(kexDHReply.Y, x)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := hashFunc.New()
0000000000000000000000000000000000000000;;		magics.write(h)
0000000000000000000000000000000000000000;;		writeString(h, kexDHReply.HostKey)
0000000000000000000000000000000000000000;;		writeInt(h, X)
0000000000000000000000000000000000000000;;		writeInt(h, kexDHReply.Y)
0000000000000000000000000000000000000000;;		K := make([]byte, intLength(kInt))
0000000000000000000000000000000000000000;;		marshalInt(K, kInt)
0000000000000000000000000000000000000000;;		h.Write(K)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &kexResult{
0000000000000000000000000000000000000000;;			H:         h.Sum(nil),
0000000000000000000000000000000000000000;;			K:         K,
0000000000000000000000000000000000000000;;			HostKey:   kexDHReply.HostKey,
0000000000000000000000000000000000000000;;			Signature: kexDHReply.Signature,
0000000000000000000000000000000000000000;;			Hash:      crypto.SHA1,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (group *dhGroup) Server(c packetConn, randSource io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
0000000000000000000000000000000000000000;;		hashFunc := crypto.SHA1
0000000000000000000000000000000000000000;;		packet, err := c.readPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var kexDHInit kexDHInitMsg
0000000000000000000000000000000000000000;;		if err = Unmarshal(packet, &kexDHInit); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		y, err := rand.Int(randSource, group.p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Y := new(big.Int).Exp(group.g, y, group.p)
0000000000000000000000000000000000000000;;		kInt, err := group.diffieHellman(kexDHInit.X, y)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostKeyBytes := priv.PublicKey().Marshal()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := hashFunc.New()
0000000000000000000000000000000000000000;;		magics.write(h)
0000000000000000000000000000000000000000;;		writeString(h, hostKeyBytes)
0000000000000000000000000000000000000000;;		writeInt(h, kexDHInit.X)
0000000000000000000000000000000000000000;;		writeInt(h, Y)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		K := make([]byte, intLength(kInt))
0000000000000000000000000000000000000000;;		marshalInt(K, kInt)
0000000000000000000000000000000000000000;;		h.Write(K)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		H := h.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// H is already a hash, but the hostkey signing will apply its
0000000000000000000000000000000000000000;;		// own key-specific hash algorithm.
0000000000000000000000000000000000000000;;		sig, err := signAndMarshal(priv, randSource, H)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kexDHReply := kexDHReplyMsg{
0000000000000000000000000000000000000000;;			HostKey:   hostKeyBytes,
0000000000000000000000000000000000000000;;			Y:         Y,
0000000000000000000000000000000000000000;;			Signature: sig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		packet = Marshal(&kexDHReply)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.writePacket(packet)
0000000000000000000000000000000000000000;;		return &kexResult{
0000000000000000000000000000000000000000;;			H:         H,
0000000000000000000000000000000000000000;;			K:         K,
0000000000000000000000000000000000000000;;			HostKey:   hostKeyBytes,
0000000000000000000000000000000000000000;;			Signature: sig,
0000000000000000000000000000000000000000;;			Hash:      crypto.SHA1,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ecdh performs Elliptic Curve Diffie-Hellman key exchange as
0000000000000000000000000000000000000000;;	// described in RFC 5656, section 4.
0000000000000000000000000000000000000000;;	type ecdh struct {
0000000000000000000000000000000000000000;;		curve elliptic.Curve
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (kex *ecdh) Client(c packetConn, rand io.Reader, magics *handshakeMagics) (*kexResult, error) {
0000000000000000000000000000000000000000;;		ephKey, err := ecdsa.GenerateKey(kex.curve, rand)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kexInit := kexECDHInitMsg{
0000000000000000000000000000000000000000;;			ClientPubKey: elliptic.Marshal(kex.curve, ephKey.PublicKey.X, ephKey.PublicKey.Y),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serialized := Marshal(&kexInit)
0000000000000000000000000000000000000000;;		if err := c.writePacket(serialized); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		packet, err := c.readPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var reply kexECDHReplyMsg
0000000000000000000000000000000000000000;;		if err = Unmarshal(packet, &reply); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x, y, err := unmarshalECKey(kex.curve, reply.EphemeralPubKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// generate shared secret
0000000000000000000000000000000000000000;;		secret, _ := kex.curve.ScalarMult(x, y, ephKey.D.Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := ecHash(kex.curve).New()
0000000000000000000000000000000000000000;;		magics.write(h)
0000000000000000000000000000000000000000;;		writeString(h, reply.HostKey)
0000000000000000000000000000000000000000;;		writeString(h, kexInit.ClientPubKey)
0000000000000000000000000000000000000000;;		writeString(h, reply.EphemeralPubKey)
0000000000000000000000000000000000000000;;		K := make([]byte, intLength(secret))
0000000000000000000000000000000000000000;;		marshalInt(K, secret)
0000000000000000000000000000000000000000;;		h.Write(K)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &kexResult{
0000000000000000000000000000000000000000;;			H:         h.Sum(nil),
0000000000000000000000000000000000000000;;			K:         K,
0000000000000000000000000000000000000000;;			HostKey:   reply.HostKey,
0000000000000000000000000000000000000000;;			Signature: reply.Signature,
0000000000000000000000000000000000000000;;			Hash:      ecHash(kex.curve),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unmarshalECKey parses and checks an EC key.
0000000000000000000000000000000000000000;;	func unmarshalECKey(curve elliptic.Curve, pubkey []byte) (x, y *big.Int, err error) {
0000000000000000000000000000000000000000;;		x, y = elliptic.Unmarshal(curve, pubkey)
0000000000000000000000000000000000000000;;		if x == nil {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("ssh: elliptic.Unmarshal failure")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !validateECPublicKey(curve, x, y) {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("ssh: public key not on curve")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x, y, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateECPublicKey checks that the point is a valid public key for
0000000000000000000000000000000000000000;;	// the given curve. See [SEC1], 3.2.2
0000000000000000000000000000000000000000;;	func validateECPublicKey(curve elliptic.Curve, x, y *big.Int) bool {
0000000000000000000000000000000000000000;;		if x.Sign() == 0 && y.Sign() == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if x.Cmp(curve.Params().P) >= 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if y.Cmp(curve.Params().P) >= 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !curve.IsOnCurve(x, y) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We don't check if N * PubKey == 0, since
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// - the NIST curves have cofactor = 1, so this is implicit.
0000000000000000000000000000000000000000;;		// (We don't foresee an implementation that supports non NIST
0000000000000000000000000000000000000000;;		// curves)
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// - for ephemeral keys, we don't need to worry about small
0000000000000000000000000000000000000000;;		// subgroup attacks.
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (kex *ecdh) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
0000000000000000000000000000000000000000;;		packet, err := c.readPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var kexECDHInit kexECDHInitMsg
0000000000000000000000000000000000000000;;		if err = Unmarshal(packet, &kexECDHInit); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientX, clientY, err := unmarshalECKey(kex.curve, kexECDHInit.ClientPubKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We could cache this key across multiple users/multiple
0000000000000000000000000000000000000000;;		// connection attempts, but the benefit is small. OpenSSH
0000000000000000000000000000000000000000;;		// generates a new key for each incoming connection.
0000000000000000000000000000000000000000;;		ephKey, err := ecdsa.GenerateKey(kex.curve, rand)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostKeyBytes := priv.PublicKey().Marshal()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serializedEphKey := elliptic.Marshal(kex.curve, ephKey.PublicKey.X, ephKey.PublicKey.Y)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// generate shared secret
0000000000000000000000000000000000000000;;		secret, _ := kex.curve.ScalarMult(clientX, clientY, ephKey.D.Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := ecHash(kex.curve).New()
0000000000000000000000000000000000000000;;		magics.write(h)
0000000000000000000000000000000000000000;;		writeString(h, hostKeyBytes)
0000000000000000000000000000000000000000;;		writeString(h, kexECDHInit.ClientPubKey)
0000000000000000000000000000000000000000;;		writeString(h, serializedEphKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		K := make([]byte, intLength(secret))
0000000000000000000000000000000000000000;;		marshalInt(K, secret)
0000000000000000000000000000000000000000;;		h.Write(K)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		H := h.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// H is already a hash, but the hostkey signing will apply its
0000000000000000000000000000000000000000;;		// own key-specific hash algorithm.
0000000000000000000000000000000000000000;;		sig, err := signAndMarshal(priv, rand, H)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reply := kexECDHReplyMsg{
0000000000000000000000000000000000000000;;			EphemeralPubKey: serializedEphKey,
0000000000000000000000000000000000000000;;			HostKey:         hostKeyBytes,
0000000000000000000000000000000000000000;;			Signature:       sig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serialized := Marshal(&reply)
0000000000000000000000000000000000000000;;		if err := c.writePacket(serialized); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &kexResult{
0000000000000000000000000000000000000000;;			H:         H,
0000000000000000000000000000000000000000;;			K:         K,
0000000000000000000000000000000000000000;;			HostKey:   reply.HostKey,
0000000000000000000000000000000000000000;;			Signature: sig,
0000000000000000000000000000000000000000;;			Hash:      ecHash(kex.curve),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var kexAlgoMap = map[string]kexAlgorithm{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// This is the group called diffie-hellman-group1-sha1 in RFC
0000000000000000000000000000000000000000;;		// 4253 and Oakley Group 2 in RFC 2409.
0000000000000000000000000000000000000000;;		p, _ := new(big.Int).SetString("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF", 16)
0000000000000000000000000000000000000000;;		kexAlgoMap[kexAlgoDH1SHA1] = &dhGroup{
0000000000000000000000000000000000000000;;			g: new(big.Int).SetInt64(2),
0000000000000000000000000000000000000000;;			p: p,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is the group called diffie-hellman-group14-sha1 in RFC
0000000000000000000000000000000000000000;;		// 4253 and Oakley Group 14 in RFC 3526.
0000000000000000000000000000000000000000;;		p, _ = new(big.Int).SetString("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF", 16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kexAlgoMap[kexAlgoDH14SHA1] = &dhGroup{
0000000000000000000000000000000000000000;;			g: new(big.Int).SetInt64(2),
0000000000000000000000000000000000000000;;			p: p,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kexAlgoMap[kexAlgoECDH521] = &ecdh{elliptic.P521()}
0000000000000000000000000000000000000000;;		kexAlgoMap[kexAlgoECDH384] = &ecdh{elliptic.P384()}
0000000000000000000000000000000000000000;;		kexAlgoMap[kexAlgoECDH256] = &ecdh{elliptic.P256()}
0000000000000000000000000000000000000000;;		kexAlgoMap[kexAlgoCurve25519SHA256] = &curve25519sha256{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// curve25519sha256 implements the curve25519-sha256@libssh.org key
0000000000000000000000000000000000000000;;	// agreement protocol, as described in
0000000000000000000000000000000000000000;;	// https://git.libssh.org/projects/libssh.git/tree/doc/curve25519-sha256@libssh.org.txt
0000000000000000000000000000000000000000;;	type curve25519sha256 struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type curve25519KeyPair struct {
0000000000000000000000000000000000000000;;		priv [32]byte
0000000000000000000000000000000000000000;;		pub  [32]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (kp *curve25519KeyPair) generate(rand io.Reader) error {
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rand, kp.priv[:]); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		curve25519.ScalarBaseMult(&kp.pub, &kp.priv)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// curve25519Zeros is just an array of 32 zero bytes so that we have something
0000000000000000000000000000000000000000;;	// convenient to compare against in order to reject curve25519 points with the
0000000000000000000000000000000000000000;;	// wrong order.
0000000000000000000000000000000000000000;;	var curve25519Zeros [32]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (kex *curve25519sha256) Client(c packetConn, rand io.Reader, magics *handshakeMagics) (*kexResult, error) {
0000000000000000000000000000000000000000;;		var kp curve25519KeyPair
0000000000000000000000000000000000000000;;		if err := kp.generate(rand); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.writePacket(Marshal(&kexECDHInitMsg{kp.pub[:]})); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		packet, err := c.readPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var reply kexECDHReplyMsg
0000000000000000000000000000000000000000;;		if err = Unmarshal(packet, &reply); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(reply.EphemeralPubKey) != 32 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: peer's curve25519 public value has wrong length")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var servPub, secret [32]byte
0000000000000000000000000000000000000000;;		copy(servPub[:], reply.EphemeralPubKey)
0000000000000000000000000000000000000000;;		curve25519.ScalarMult(&secret, &kp.priv, &servPub)
0000000000000000000000000000000000000000;;		if subtle.ConstantTimeCompare(secret[:], curve25519Zeros[:]) == 1 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: peer's curve25519 public value has wrong order")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := crypto.SHA256.New()
0000000000000000000000000000000000000000;;		magics.write(h)
0000000000000000000000000000000000000000;;		writeString(h, reply.HostKey)
0000000000000000000000000000000000000000;;		writeString(h, kp.pub[:])
0000000000000000000000000000000000000000;;		writeString(h, reply.EphemeralPubKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kInt := new(big.Int).SetBytes(secret[:])
0000000000000000000000000000000000000000;;		K := make([]byte, intLength(kInt))
0000000000000000000000000000000000000000;;		marshalInt(K, kInt)
0000000000000000000000000000000000000000;;		h.Write(K)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &kexResult{
0000000000000000000000000000000000000000;;			H:         h.Sum(nil),
0000000000000000000000000000000000000000;;			K:         K,
0000000000000000000000000000000000000000;;			HostKey:   reply.HostKey,
0000000000000000000000000000000000000000;;			Signature: reply.Signature,
0000000000000000000000000000000000000000;;			Hash:      crypto.SHA256,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (kex *curve25519sha256) Server(c packetConn, rand io.Reader, magics *handshakeMagics, priv Signer) (result *kexResult, err error) {
0000000000000000000000000000000000000000;;		packet, err := c.readPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var kexInit kexECDHInitMsg
0000000000000000000000000000000000000000;;		if err = Unmarshal(packet, &kexInit); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(kexInit.ClientPubKey) != 32 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: peer's curve25519 public value has wrong length")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var kp curve25519KeyPair
0000000000000000000000000000000000000000;;		if err := kp.generate(rand); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var clientPub, secret [32]byte
0000000000000000000000000000000000000000;;		copy(clientPub[:], kexInit.ClientPubKey)
0000000000000000000000000000000000000000;;		curve25519.ScalarMult(&secret, &kp.priv, &clientPub)
0000000000000000000000000000000000000000;;		if subtle.ConstantTimeCompare(secret[:], curve25519Zeros[:]) == 1 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: peer's curve25519 public value has wrong order")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostKeyBytes := priv.PublicKey().Marshal()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := crypto.SHA256.New()
0000000000000000000000000000000000000000;;		magics.write(h)
0000000000000000000000000000000000000000;;		writeString(h, hostKeyBytes)
0000000000000000000000000000000000000000;;		writeString(h, kexInit.ClientPubKey)
0000000000000000000000000000000000000000;;		writeString(h, kp.pub[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kInt := new(big.Int).SetBytes(secret[:])
0000000000000000000000000000000000000000;;		K := make([]byte, intLength(kInt))
0000000000000000000000000000000000000000;;		marshalInt(K, kInt)
0000000000000000000000000000000000000000;;		h.Write(K)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		H := h.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sig, err := signAndMarshal(priv, rand, H)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reply := kexECDHReplyMsg{
0000000000000000000000000000000000000000;;			EphemeralPubKey: kp.pub[:],
0000000000000000000000000000000000000000;;			HostKey:         hostKeyBytes,
0000000000000000000000000000000000000000;;			Signature:       sig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.writePacket(Marshal(&reply)); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &kexResult{
0000000000000000000000000000000000000000;;			H:         H,
0000000000000000000000000000000000000000;;			K:         K,
0000000000000000000000000000000000000000;;			HostKey:   hostKeyBytes,
0000000000000000000000000000000000000000;;			Signature: sig,
0000000000000000000000000000000000000000;;			Hash:      crypto.SHA256,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
