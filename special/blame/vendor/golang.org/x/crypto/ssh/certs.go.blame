0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/certs.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/certs.go][vendor/golang.org/x/crypto/ssh/certs.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These constants from [PROTOCOL.certkeys] represent the algorithm names
0000000000000000000000000000000000000000;;	// for certificate types supported by this package.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		CertAlgoRSAv01      = "ssh-rsa-cert-v01@openssh.com"
0000000000000000000000000000000000000000;;		CertAlgoDSAv01      = "ssh-dss-cert-v01@openssh.com"
0000000000000000000000000000000000000000;;		CertAlgoECDSA256v01 = "ecdsa-sha2-nistp256-cert-v01@openssh.com"
0000000000000000000000000000000000000000;;		CertAlgoECDSA384v01 = "ecdsa-sha2-nistp384-cert-v01@openssh.com"
0000000000000000000000000000000000000000;;		CertAlgoECDSA521v01 = "ecdsa-sha2-nistp521-cert-v01@openssh.com"
0000000000000000000000000000000000000000;;		CertAlgoED25519v01  = "ssh-ed25519-cert-v01@openssh.com"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Certificate types distinguish between host and user
0000000000000000000000000000000000000000;;	// certificates. The values can be set in the CertType field of
0000000000000000000000000000000000000000;;	// Certificate.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		UserCert = 1
0000000000000000000000000000000000000000;;		HostCert = 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signature represents a cryptographic signature.
0000000000000000000000000000000000000000;;	type Signature struct {
0000000000000000000000000000000000000000;;		Format string
0000000000000000000000000000000000000000;;		Blob   []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertTimeInfinity can be used for OpenSSHCertV01.ValidBefore to indicate that
0000000000000000000000000000000000000000;;	// a certificate does not expire.
0000000000000000000000000000000000000000;;	const CertTimeInfinity = 1<<64 - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Certificate represents an OpenSSH certificate as defined in
0000000000000000000000000000000000000000;;	// [PROTOCOL.certkeys]?rev=1.8.
0000000000000000000000000000000000000000;;	type Certificate struct {
0000000000000000000000000000000000000000;;		Nonce           []byte
0000000000000000000000000000000000000000;;		Key             PublicKey
0000000000000000000000000000000000000000;;		Serial          uint64
0000000000000000000000000000000000000000;;		CertType        uint32
0000000000000000000000000000000000000000;;		KeyId           string
0000000000000000000000000000000000000000;;		ValidPrincipals []string
0000000000000000000000000000000000000000;;		ValidAfter      uint64
0000000000000000000000000000000000000000;;		ValidBefore     uint64
0000000000000000000000000000000000000000;;		Permissions
0000000000000000000000000000000000000000;;		Reserved     []byte
0000000000000000000000000000000000000000;;		SignatureKey PublicKey
0000000000000000000000000000000000000000;;		Signature    *Signature
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genericCertData holds the key-independent part of the certificate data.
0000000000000000000000000000000000000000;;	// Overall, certificates contain an nonce, public key fields and
0000000000000000000000000000000000000000;;	// key-independent fields.
0000000000000000000000000000000000000000;;	type genericCertData struct {
0000000000000000000000000000000000000000;;		Serial          uint64
0000000000000000000000000000000000000000;;		CertType        uint32
0000000000000000000000000000000000000000;;		KeyId           string
0000000000000000000000000000000000000000;;		ValidPrincipals []byte
0000000000000000000000000000000000000000;;		ValidAfter      uint64
0000000000000000000000000000000000000000;;		ValidBefore     uint64
0000000000000000000000000000000000000000;;		CriticalOptions []byte
0000000000000000000000000000000000000000;;		Extensions      []byte
0000000000000000000000000000000000000000;;		Reserved        []byte
0000000000000000000000000000000000000000;;		SignatureKey    []byte
0000000000000000000000000000000000000000;;		Signature       []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshalStringList(namelist []string) []byte {
0000000000000000000000000000000000000000;;		var to []byte
0000000000000000000000000000000000000000;;		for _, name := range namelist {
0000000000000000000000000000000000000000;;			s := struct{ N string }{name}
0000000000000000000000000000000000000000;;			to = append(to, Marshal(&s)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return to
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type optionsTuple struct {
0000000000000000000000000000000000000000;;		Key   string
0000000000000000000000000000000000000000;;		Value []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type optionsTupleValue struct {
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serialize a map of critical options or extensions
0000000000000000000000000000000000000000;;	// issue #10569 - per [PROTOCOL.certkeys] and SSH implementation,
0000000000000000000000000000000000000000;;	// we need two length prefixes for a non-empty string value
0000000000000000000000000000000000000000;;	func marshalTuples(tups map[string]string) []byte {
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(tups))
0000000000000000000000000000000000000000;;		for key := range tups {
0000000000000000000000000000000000000000;;			keys = append(keys, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ret []byte
0000000000000000000000000000000000000000;;		for _, key := range keys {
0000000000000000000000000000000000000000;;			s := optionsTuple{Key: key}
0000000000000000000000000000000000000000;;			if value := tups[key]; len(value) > 0 {
0000000000000000000000000000000000000000;;				s.Value = Marshal(&optionsTupleValue{value})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret = append(ret, Marshal(&s)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// issue #10569 - per [PROTOCOL.certkeys] and SSH implementation,
0000000000000000000000000000000000000000;;	// we need two length prefixes for a non-empty option value
0000000000000000000000000000000000000000;;	func parseTuples(in []byte) (map[string]string, error) {
0000000000000000000000000000000000000000;;		tups := map[string]string{}
0000000000000000000000000000000000000000;;		var lastKey string
0000000000000000000000000000000000000000;;		var haveLastKey bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(in) > 0 {
0000000000000000000000000000000000000000;;			var key, val, extra []byte
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if key, in, ok = parseString(in); !ok {
0000000000000000000000000000000000000000;;				return nil, errShortRead
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keyStr := string(key)
0000000000000000000000000000000000000000;;			// according to [PROTOCOL.certkeys], the names must be in
0000000000000000000000000000000000000000;;			// lexical order.
0000000000000000000000000000000000000000;;			if haveLastKey && keyStr <= lastKey {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("ssh: certificate options are not in lexical order")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastKey, haveLastKey = keyStr, true
0000000000000000000000000000000000000000;;			// the next field is a data field, which if non-empty has a string embedded
0000000000000000000000000000000000000000;;			if val, in, ok = parseString(in); !ok {
0000000000000000000000000000000000000000;;				return nil, errShortRead
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(val) > 0 {
0000000000000000000000000000000000000000;;				val, extra, ok = parseString(val)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, errShortRead
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(extra) > 0 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("ssh: unexpected trailing data after certificate option value")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tups[keyStr] = string(val)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				tups[keyStr] = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tups, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseCert(in []byte, privAlgo string) (*Certificate, error) {
0000000000000000000000000000000000000000;;		nonce, rest, ok := parseString(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errShortRead
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key, rest, err := parsePubKey(rest, privAlgo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var g genericCertData
0000000000000000000000000000000000000000;;		if err := Unmarshal(rest, &g); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &Certificate{
0000000000000000000000000000000000000000;;			Nonce:       nonce,
0000000000000000000000000000000000000000;;			Key:         key,
0000000000000000000000000000000000000000;;			Serial:      g.Serial,
0000000000000000000000000000000000000000;;			CertType:    g.CertType,
0000000000000000000000000000000000000000;;			KeyId:       g.KeyId,
0000000000000000000000000000000000000000;;			ValidAfter:  g.ValidAfter,
0000000000000000000000000000000000000000;;			ValidBefore: g.ValidBefore,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for principals := g.ValidPrincipals; len(principals) > 0; {
0000000000000000000000000000000000000000;;			principal, rest, ok := parseString(principals)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, errShortRead
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.ValidPrincipals = append(c.ValidPrincipals, string(principal))
0000000000000000000000000000000000000000;;			principals = rest
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.CriticalOptions, err = parseTuples(g.CriticalOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Extensions, err = parseTuples(g.Extensions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Reserved = g.Reserved
0000000000000000000000000000000000000000;;		k, err := ParsePublicKey(g.SignatureKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.SignatureKey = k
0000000000000000000000000000000000000000;;		c.Signature, rest, ok = parseSignatureBody(g.Signature)
0000000000000000000000000000000000000000;;		if !ok || len(rest) > 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: signature parse error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type openSSHCertSigner struct {
0000000000000000000000000000000000000000;;		pub    *Certificate
0000000000000000000000000000000000000000;;		signer Signer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCertSigner returns a Signer that signs with the given Certificate, whose
0000000000000000000000000000000000000000;;	// private key is held by signer. It returns an error if the public key in cert
0000000000000000000000000000000000000000;;	// doesn't match the key used by signer.
0000000000000000000000000000000000000000;;	func NewCertSigner(cert *Certificate, signer Signer) (Signer, error) {
0000000000000000000000000000000000000000;;		if bytes.Compare(cert.Key.Marshal(), signer.PublicKey().Marshal()) != 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: signer and cert have different public key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &openSSHCertSigner{cert, signer}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *openSSHCertSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {
0000000000000000000000000000000000000000;;		return s.signer.Sign(rand, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *openSSHCertSigner) PublicKey() PublicKey {
0000000000000000000000000000000000000000;;		return s.pub
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const sourceAddressCriticalOption = "source-address"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertChecker does the work of verifying a certificate. Its methods
0000000000000000000000000000000000000000;;	// can be plugged into ClientConfig.HostKeyCallback and
0000000000000000000000000000000000000000;;	// ServerConfig.PublicKeyCallback. For the CertChecker to work,
0000000000000000000000000000000000000000;;	// minimally, the IsAuthority callback should be set.
0000000000000000000000000000000000000000;;	type CertChecker struct {
0000000000000000000000000000000000000000;;		// SupportedCriticalOptions lists the CriticalOptions that the
0000000000000000000000000000000000000000;;		// server application layer understands. These are only used
0000000000000000000000000000000000000000;;		// for user certificates.
0000000000000000000000000000000000000000;;		SupportedCriticalOptions []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsAuthority should return true if the key is recognized as
0000000000000000000000000000000000000000;;		// an authority. This allows for certificates to be signed by other
0000000000000000000000000000000000000000;;		// certificates.
0000000000000000000000000000000000000000;;		IsAuthority func(auth PublicKey) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clock is used for verifying time stamps. If nil, time.Now
0000000000000000000000000000000000000000;;		// is used.
0000000000000000000000000000000000000000;;		Clock func() time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserKeyFallback is called when CertChecker.Authenticate encounters a
0000000000000000000000000000000000000000;;		// public key that is not a certificate. It must implement validation
0000000000000000000000000000000000000000;;		// of user keys or else, if nil, all such keys are rejected.
0000000000000000000000000000000000000000;;		UserKeyFallback func(conn ConnMetadata, key PublicKey) (*Permissions, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HostKeyFallback is called when CertChecker.CheckHostKey encounters a
0000000000000000000000000000000000000000;;		// public key that is not a certificate. It must implement host key
0000000000000000000000000000000000000000;;		// validation or else, if nil, all such keys are rejected.
0000000000000000000000000000000000000000;;		HostKeyFallback func(addr string, remote net.Addr, key PublicKey) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsRevoked is called for each certificate so that revocation checking
0000000000000000000000000000000000000000;;		// can be implemented. It should return true if the given certificate
0000000000000000000000000000000000000000;;		// is revoked and false otherwise. If nil, no certificates are
0000000000000000000000000000000000000000;;		// considered to have been revoked.
0000000000000000000000000000000000000000;;		IsRevoked func(cert *Certificate) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckHostKey checks a host key certificate. This method can be
0000000000000000000000000000000000000000;;	// plugged into ClientConfig.HostKeyCallback.
0000000000000000000000000000000000000000;;	func (c *CertChecker) CheckHostKey(addr string, remote net.Addr, key PublicKey) error {
0000000000000000000000000000000000000000;;		cert, ok := key.(*Certificate)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			if c.HostKeyFallback != nil {
0000000000000000000000000000000000000000;;				return c.HostKeyFallback(addr, remote, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return errors.New("ssh: non-certificate host key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cert.CertType != HostCert {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: certificate presented as a host key has type %d", cert.CertType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.CheckCert(addr, cert)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Authenticate checks a user certificate. Authenticate can be used as
0000000000000000000000000000000000000000;;	// a value for ServerConfig.PublicKeyCallback.
0000000000000000000000000000000000000000;;	func (c *CertChecker) Authenticate(conn ConnMetadata, pubKey PublicKey) (*Permissions, error) {
0000000000000000000000000000000000000000;;		cert, ok := pubKey.(*Certificate)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			if c.UserKeyFallback != nil {
0000000000000000000000000000000000000000;;				return c.UserKeyFallback(conn, pubKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: normal key pairs not accepted")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cert.CertType != UserCert {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ssh: cert has type %d", cert.CertType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.CheckCert(conn.User(), cert); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &cert.Permissions, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckCert checks CriticalOptions, ValidPrincipals, revocation, timestamp and
0000000000000000000000000000000000000000;;	// the signature of the certificate.
0000000000000000000000000000000000000000;;	func (c *CertChecker) CheckCert(principal string, cert *Certificate) error {
0000000000000000000000000000000000000000;;		if c.IsRevoked != nil && c.IsRevoked(cert) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: certicate serial %d revoked", cert.Serial)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for opt, _ := range cert.CriticalOptions {
0000000000000000000000000000000000000000;;			// sourceAddressCriticalOption will be enforced by
0000000000000000000000000000000000000000;;			// serverAuthenticate
0000000000000000000000000000000000000000;;			if opt == sourceAddressCriticalOption {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, supp := range c.SupportedCriticalOptions {
0000000000000000000000000000000000000000;;				if supp == opt {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ssh: unsupported critical option %q in certificate", opt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cert.ValidPrincipals) > 0 {
0000000000000000000000000000000000000000;;			// By default, certs are valid for all users/hosts.
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;			for _, p := range cert.ValidPrincipals {
0000000000000000000000000000000000000000;;				if p == principal {
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ssh: principal %q not in the set of valid principals for given certificate: %q", principal, cert.ValidPrincipals)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !c.IsAuthority(cert.SignatureKey) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: certificate signed by unrecognized authority")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clock := c.Clock
0000000000000000000000000000000000000000;;		if clock == nil {
0000000000000000000000000000000000000000;;			clock = time.Now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unixNow := clock().Unix()
0000000000000000000000000000000000000000;;		if after := int64(cert.ValidAfter); after < 0 || unixNow < int64(cert.ValidAfter) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: cert is not yet valid")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if before := int64(cert.ValidBefore); cert.ValidBefore != uint64(CertTimeInfinity) && (unixNow >= before || before < 0) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: cert has expired")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := cert.SignatureKey.Verify(cert.bytesForSigning(), cert.Signature); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: certificate signature does not verify")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignCert sets c.SignatureKey to the authority's public key and stores a
0000000000000000000000000000000000000000;;	// Signature, by authority, in the certificate.
0000000000000000000000000000000000000000;;	func (c *Certificate) SignCert(rand io.Reader, authority Signer) error {
0000000000000000000000000000000000000000;;		c.Nonce = make([]byte, 32)
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rand, c.Nonce); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.SignatureKey = authority.PublicKey()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sig, err := authority.Sign(rand, c.bytesForSigning())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Signature = sig
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var certAlgoNames = map[string]string{
0000000000000000000000000000000000000000;;		KeyAlgoRSA:      CertAlgoRSAv01,
0000000000000000000000000000000000000000;;		KeyAlgoDSA:      CertAlgoDSAv01,
0000000000000000000000000000000000000000;;		KeyAlgoECDSA256: CertAlgoECDSA256v01,
0000000000000000000000000000000000000000;;		KeyAlgoECDSA384: CertAlgoECDSA384v01,
0000000000000000000000000000000000000000;;		KeyAlgoECDSA521: CertAlgoECDSA521v01,
0000000000000000000000000000000000000000;;		KeyAlgoED25519:  CertAlgoED25519v01,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// certToPrivAlgo returns the underlying algorithm for a certificate algorithm.
0000000000000000000000000000000000000000;;	// Panics if a non-certificate algorithm is passed.
0000000000000000000000000000000000000000;;	func certToPrivAlgo(algo string) string {
0000000000000000000000000000000000000000;;		for privAlgo, pubAlgo := range certAlgoNames {
0000000000000000000000000000000000000000;;			if pubAlgo == algo {
0000000000000000000000000000000000000000;;				return privAlgo
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unknown cert algorithm")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cert *Certificate) bytesForSigning() []byte {
0000000000000000000000000000000000000000;;		c2 := *cert
0000000000000000000000000000000000000000;;		c2.Signature = nil
0000000000000000000000000000000000000000;;		out := c2.Marshal()
0000000000000000000000000000000000000000;;		// Drop trailing signature length.
0000000000000000000000000000000000000000;;		return out[:len(out)-4]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal serializes c into OpenSSH's wire format. It is part of the
0000000000000000000000000000000000000000;;	// PublicKey interface.
0000000000000000000000000000000000000000;;	func (c *Certificate) Marshal() []byte {
0000000000000000000000000000000000000000;;		generic := genericCertData{
0000000000000000000000000000000000000000;;			Serial:          c.Serial,
0000000000000000000000000000000000000000;;			CertType:        c.CertType,
0000000000000000000000000000000000000000;;			KeyId:           c.KeyId,
0000000000000000000000000000000000000000;;			ValidPrincipals: marshalStringList(c.ValidPrincipals),
0000000000000000000000000000000000000000;;			ValidAfter:      uint64(c.ValidAfter),
0000000000000000000000000000000000000000;;			ValidBefore:     uint64(c.ValidBefore),
0000000000000000000000000000000000000000;;			CriticalOptions: marshalTuples(c.CriticalOptions),
0000000000000000000000000000000000000000;;			Extensions:      marshalTuples(c.Extensions),
0000000000000000000000000000000000000000;;			Reserved:        c.Reserved,
0000000000000000000000000000000000000000;;			SignatureKey:    c.SignatureKey.Marshal(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.Signature != nil {
0000000000000000000000000000000000000000;;			generic.Signature = Marshal(c.Signature)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		genericBytes := Marshal(&generic)
0000000000000000000000000000000000000000;;		keyBytes := c.Key.Marshal()
0000000000000000000000000000000000000000;;		_, keyBytes, _ = parseString(keyBytes)
0000000000000000000000000000000000000000;;		prefix := Marshal(&struct {
0000000000000000000000000000000000000000;;			Name  string
0000000000000000000000000000000000000000;;			Nonce []byte
0000000000000000000000000000000000000000;;			Key   []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;		}{c.Type(), c.Nonce, keyBytes})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make([]byte, 0, len(prefix)+len(genericBytes))
0000000000000000000000000000000000000000;;		result = append(result, prefix...)
0000000000000000000000000000000000000000;;		result = append(result, genericBytes...)
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type returns the key name. It is part of the PublicKey interface.
0000000000000000000000000000000000000000;;	func (c *Certificate) Type() string {
0000000000000000000000000000000000000000;;		algo, ok := certAlgoNames[c.Key.Type()]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			panic("unknown cert key type " + c.Key.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return algo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify verifies a signature against the certificate's public
0000000000000000000000000000000000000000;;	// key. It is part of the PublicKey interface.
0000000000000000000000000000000000000000;;	func (c *Certificate) Verify(data []byte, sig *Signature) error {
0000000000000000000000000000000000000000;;		return c.Key.Verify(data, sig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseSignatureBody(in []byte) (out *Signature, rest []byte, ok bool) {
0000000000000000000000000000000000000000;;		format, in, ok := parseString(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out = &Signature{
0000000000000000000000000000000000000000;;			Format: string(format),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if out.Blob, in, ok = parseString(in); !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, in, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseSignature(in []byte) (out *Signature, rest []byte, ok bool) {
0000000000000000000000000000000000000000;;		sigBytes, rest, ok := parseString(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, trailing, ok := parseSignatureBody(sigBytes)
0000000000000000000000000000000000000000;;		if !ok || len(trailing) > 0 {
0000000000000000000000000000000000000000;;			return nil, nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
