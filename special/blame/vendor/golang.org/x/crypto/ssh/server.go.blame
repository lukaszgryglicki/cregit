0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/server.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/server.go][vendor/golang.org/x/crypto/ssh/server.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Permissions type holds fine-grained permissions that are
0000000000000000000000000000000000000000;;	// specific to a user or a specific authentication method for a
0000000000000000000000000000000000000000;;	// user. Permissions, except for "source-address", must be enforced in
0000000000000000000000000000000000000000;;	// the server application layer, after successful authentication. The
0000000000000000000000000000000000000000;;	// Permissions are passed on in ServerConn so a server implementation
0000000000000000000000000000000000000000;;	// can honor them.
0000000000000000000000000000000000000000;;	type Permissions struct {
0000000000000000000000000000000000000000;;		// Critical options restrict default permissions. Common
0000000000000000000000000000000000000000;;		// restrictions are "source-address" and "force-command". If
0000000000000000000000000000000000000000;;		// the server cannot enforce the restriction, or does not
0000000000000000000000000000000000000000;;		// recognize it, the user should not authenticate.
0000000000000000000000000000000000000000;;		CriticalOptions map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extensions are extra functionality that the server may
0000000000000000000000000000000000000000;;		// offer on authenticated connections. Common extensions are
0000000000000000000000000000000000000000;;		// "permit-agent-forwarding", "permit-X11-forwarding". Lack of
0000000000000000000000000000000000000000;;		// support for an extension does not preclude authenticating a
0000000000000000000000000000000000000000;;		// user.
0000000000000000000000000000000000000000;;		Extensions map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerConfig holds server specific configuration data.
0000000000000000000000000000000000000000;;	type ServerConfig struct {
0000000000000000000000000000000000000000;;		// Config contains configuration shared between client and server.
0000000000000000000000000000000000000000;;		Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostKeys []Signer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NoClientAuth is true if clients are allowed to connect without
0000000000000000000000000000000000000000;;		// authenticating.
0000000000000000000000000000000000000000;;		NoClientAuth bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PasswordCallback, if non-nil, is called when a user
0000000000000000000000000000000000000000;;		// attempts to authenticate using a password.
0000000000000000000000000000000000000000;;		PasswordCallback func(conn ConnMetadata, password []byte) (*Permissions, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PublicKeyCallback, if non-nil, is called when a client attempts public
0000000000000000000000000000000000000000;;		// key authentication. It must return true if the given public key is
0000000000000000000000000000000000000000;;		// valid for the given user. For example, see CertChecker.Authenticate.
0000000000000000000000000000000000000000;;		PublicKeyCallback func(conn ConnMetadata, key PublicKey) (*Permissions, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeyboardInteractiveCallback, if non-nil, is called when
0000000000000000000000000000000000000000;;		// keyboard-interactive authentication is selected (RFC
0000000000000000000000000000000000000000;;		// 4256). The client object's Challenge function should be
0000000000000000000000000000000000000000;;		// used to query the user. The callback may offer multiple
0000000000000000000000000000000000000000;;		// Challenge rounds. To avoid information leaks, the client
0000000000000000000000000000000000000000;;		// should be presented a challenge even if the user is
0000000000000000000000000000000000000000;;		// unknown.
0000000000000000000000000000000000000000;;		KeyboardInteractiveCallback func(conn ConnMetadata, client KeyboardInteractiveChallenge) (*Permissions, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AuthLogCallback, if non-nil, is called to log all authentication
0000000000000000000000000000000000000000;;		// attempts.
0000000000000000000000000000000000000000;;		AuthLogCallback func(conn ConnMetadata, method string, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServerVersion is the version identification string to announce in
0000000000000000000000000000000000000000;;		// the public handshake.
0000000000000000000000000000000000000000;;		// If empty, a reasonable default is used.
0000000000000000000000000000000000000000;;		// Note that RFC 4253 section 4.2 requires that this string start with
0000000000000000000000000000000000000000;;		// "SSH-2.0-".
0000000000000000000000000000000000000000;;		ServerVersion string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddHostKey adds a private key as a host key. If an existing host
0000000000000000000000000000000000000000;;	// key exists with the same algorithm, it is overwritten. Each server
0000000000000000000000000000000000000000;;	// config must have at least one host key.
0000000000000000000000000000000000000000;;	func (s *ServerConfig) AddHostKey(key Signer) {
0000000000000000000000000000000000000000;;		for i, k := range s.hostKeys {
0000000000000000000000000000000000000000;;			if k.PublicKey().Type() == key.PublicKey().Type() {
0000000000000000000000000000000000000000;;				s.hostKeys[i] = key
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.hostKeys = append(s.hostKeys, key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cachedPubKey contains the results of querying whether a public key is
0000000000000000000000000000000000000000;;	// acceptable for a user.
0000000000000000000000000000000000000000;;	type cachedPubKey struct {
0000000000000000000000000000000000000000;;		user       string
0000000000000000000000000000000000000000;;		pubKeyData []byte
0000000000000000000000000000000000000000;;		result     error
0000000000000000000000000000000000000000;;		perms      *Permissions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxCachedPubKeys = 16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pubKeyCache caches tests for public keys.  Since SSH clients
0000000000000000000000000000000000000000;;	// will query whether a public key is acceptable before attempting to
0000000000000000000000000000000000000000;;	// authenticate with it, we end up with duplicate queries for public
0000000000000000000000000000000000000000;;	// key validity.  The cache only applies to a single ServerConn.
0000000000000000000000000000000000000000;;	type pubKeyCache struct {
0000000000000000000000000000000000000000;;		keys []cachedPubKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get returns the result for a given user/algo/key tuple.
0000000000000000000000000000000000000000;;	func (c *pubKeyCache) get(user string, pubKeyData []byte) (cachedPubKey, bool) {
0000000000000000000000000000000000000000;;		for _, k := range c.keys {
0000000000000000000000000000000000000000;;			if k.user == user && bytes.Equal(k.pubKeyData, pubKeyData) {
0000000000000000000000000000000000000000;;				return k, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cachedPubKey{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// add adds the given tuple to the cache.
0000000000000000000000000000000000000000;;	func (c *pubKeyCache) add(candidate cachedPubKey) {
0000000000000000000000000000000000000000;;		if len(c.keys) < maxCachedPubKeys {
0000000000000000000000000000000000000000;;			c.keys = append(c.keys, candidate)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerConn is an authenticated SSH connection, as seen from the
0000000000000000000000000000000000000000;;	// server
0000000000000000000000000000000000000000;;	type ServerConn struct {
0000000000000000000000000000000000000000;;		Conn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the succeeding authentication callback returned a
0000000000000000000000000000000000000000;;		// non-nil Permissions pointer, it is stored here.
0000000000000000000000000000000000000000;;		Permissions *Permissions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServerConn starts a new SSH server with c as the underlying
0000000000000000000000000000000000000000;;	// transport.  It starts with a handshake and, if the handshake is
0000000000000000000000000000000000000000;;	// unsuccessful, it closes the connection and returns an error.  The
0000000000000000000000000000000000000000;;	// Request and NewChannel channels must be serviced, or the connection
0000000000000000000000000000000000000000;;	// will hang.
0000000000000000000000000000000000000000;;	func NewServerConn(c net.Conn, config *ServerConfig) (*ServerConn, <-chan NewChannel, <-chan *Request, error) {
0000000000000000000000000000000000000000;;		fullConf := *config
0000000000000000000000000000000000000000;;		fullConf.SetDefaults()
0000000000000000000000000000000000000000;;		s := &connection{
0000000000000000000000000000000000000000;;			sshConn: sshConn{conn: c},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		perms, err := s.serverHandshake(&fullConf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			c.Close()
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ServerConn{s, perms}, s.mux.incomingChannels, s.mux.incomingRequests, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// signAndMarshal signs the data with the appropriate algorithm,
0000000000000000000000000000000000000000;;	// and serializes the result in SSH wire format.
0000000000000000000000000000000000000000;;	func signAndMarshal(k Signer, rand io.Reader, data []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		sig, err := k.Sign(rand, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Marshal(sig), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handshake performs key exchange and user authentication.
0000000000000000000000000000000000000000;;	func (s *connection) serverHandshake(config *ServerConfig) (*Permissions, error) {
0000000000000000000000000000000000000000;;		if len(config.hostKeys) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: server has no host keys")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !config.NoClientAuth && config.PasswordCallback == nil && config.PublicKeyCallback == nil && config.KeyboardInteractiveCallback == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: no authentication methods configured but NoClientAuth is also false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.ServerVersion != "" {
0000000000000000000000000000000000000000;;			s.serverVersion = []byte(config.ServerVersion)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.serverVersion = []byte(packageVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		s.clientVersion, err = exchangeVersions(s.sshConn.conn, s.serverVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tr := newTransport(s.sshConn.conn, config.Rand, false /* not client */)
0000000000000000000000000000000000000000;;		s.transport = newServerTransport(tr, s.clientVersion, s.serverVersion, config)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.transport.requestInitialKeyChange(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We just did the key change, so the session ID is established.
0000000000000000000000000000000000000000;;		s.sessionID = s.transport.getSessionID()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var packet []byte
0000000000000000000000000000000000000000;;		if packet, err = s.transport.readPacket(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var serviceRequest serviceRequestMsg
0000000000000000000000000000000000000000;;		if err = Unmarshal(packet, &serviceRequest); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if serviceRequest.Service != serviceUserAuth {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: requested service '" + serviceRequest.Service + "' before authenticating")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serviceAccept := serviceAcceptMsg{
0000000000000000000000000000000000000000;;			Service: serviceUserAuth,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.transport.writePacket(Marshal(&serviceAccept)); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		perms, err := s.serverAuthenticate(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.mux = newMux(s.transport)
0000000000000000000000000000000000000000;;		return perms, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isAcceptableAlgo(algo string) bool {
0000000000000000000000000000000000000000;;		switch algo {
0000000000000000000000000000000000000000;;		case KeyAlgoRSA, KeyAlgoDSA, KeyAlgoECDSA256, KeyAlgoECDSA384, KeyAlgoECDSA521, KeyAlgoED25519,
0000000000000000000000000000000000000000;;			CertAlgoRSAv01, CertAlgoDSAv01, CertAlgoECDSA256v01, CertAlgoECDSA384v01, CertAlgoECDSA521v01:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkSourceAddress(addr net.Addr, sourceAddr string) error {
0000000000000000000000000000000000000000;;		if addr == nil {
0000000000000000000000000000000000000000;;			return errors.New("ssh: no address known for client, but source-address match required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tcpAddr, ok := addr.(*net.TCPAddr)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: remote address %v is not an TCP address when checking source-address match", addr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if allowedIP := net.ParseIP(sourceAddr); allowedIP != nil {
0000000000000000000000000000000000000000;;			if bytes.Equal(allowedIP, tcpAddr.IP) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, ipNet, err := net.ParseCIDR(sourceAddr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ssh: error parsing source-address restriction %q: %v", sourceAddr, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ipNet.Contains(tcpAddr.IP) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("ssh: remote address %v is not allowed because of source-address restriction", addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *connection) serverAuthenticate(config *ServerConfig) (*Permissions, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var cache pubKeyCache
0000000000000000000000000000000000000000;;		var perms *Permissions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	userAuthLoop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var userAuthReq userAuthRequestMsg
0000000000000000000000000000000000000000;;			if packet, err := s.transport.readPacket(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			} else if err = Unmarshal(packet, &userAuthReq); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if userAuthReq.Service != serviceSSH {
0000000000000000000000000000000000000000;;				return nil, errors.New("ssh: client attempted to negotiate for unknown service: " + userAuthReq.Service)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.user = userAuthReq.User
0000000000000000000000000000000000000000;;			perms = nil
0000000000000000000000000000000000000000;;			authErr := errors.New("no auth passed yet")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch userAuthReq.Method {
0000000000000000000000000000000000000000;;			case "none":
0000000000000000000000000000000000000000;;				if config.NoClientAuth {
0000000000000000000000000000000000000000;;					authErr = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case "password":
0000000000000000000000000000000000000000;;				if config.PasswordCallback == nil {
0000000000000000000000000000000000000000;;					authErr = errors.New("ssh: password auth not configured")
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				payload := userAuthReq.Payload
0000000000000000000000000000000000000000;;				if len(payload) < 1 || payload[0] != 0 {
0000000000000000000000000000000000000000;;					return nil, parseError(msgUserAuthRequest)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				payload = payload[1:]
0000000000000000000000000000000000000000;;				password, payload, ok := parseString(payload)
0000000000000000000000000000000000000000;;				if !ok || len(payload) > 0 {
0000000000000000000000000000000000000000;;					return nil, parseError(msgUserAuthRequest)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				perms, authErr = config.PasswordCallback(s, password)
0000000000000000000000000000000000000000;;			case "keyboard-interactive":
0000000000000000000000000000000000000000;;				if config.KeyboardInteractiveCallback == nil {
0000000000000000000000000000000000000000;;					authErr = errors.New("ssh: keyboard-interactive auth not configubred")
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				prompter := &sshClientKeyboardInteractive{s}
0000000000000000000000000000000000000000;;				perms, authErr = config.KeyboardInteractiveCallback(s, prompter.Challenge)
0000000000000000000000000000000000000000;;			case "publickey":
0000000000000000000000000000000000000000;;				if config.PublicKeyCallback == nil {
0000000000000000000000000000000000000000;;					authErr = errors.New("ssh: publickey auth not configured")
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				payload := userAuthReq.Payload
0000000000000000000000000000000000000000;;				if len(payload) < 1 {
0000000000000000000000000000000000000000;;					return nil, parseError(msgUserAuthRequest)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				isQuery := payload[0] == 0
0000000000000000000000000000000000000000;;				payload = payload[1:]
0000000000000000000000000000000000000000;;				algoBytes, payload, ok := parseString(payload)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, parseError(msgUserAuthRequest)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				algo := string(algoBytes)
0000000000000000000000000000000000000000;;				if !isAcceptableAlgo(algo) {
0000000000000000000000000000000000000000;;					authErr = fmt.Errorf("ssh: algorithm %q not accepted", algo)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pubKeyData, payload, ok := parseString(payload)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, parseError(msgUserAuthRequest)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pubKey, err := ParsePublicKey(pubKeyData)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				candidate, ok := cache.get(s.user, pubKeyData)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					candidate.user = s.user
0000000000000000000000000000000000000000;;					candidate.pubKeyData = pubKeyData
0000000000000000000000000000000000000000;;					candidate.perms, candidate.result = config.PublicKeyCallback(s, pubKey)
0000000000000000000000000000000000000000;;					if candidate.result == nil && candidate.perms != nil && candidate.perms.CriticalOptions != nil && candidate.perms.CriticalOptions[sourceAddressCriticalOption] != "" {
0000000000000000000000000000000000000000;;						candidate.result = checkSourceAddress(
0000000000000000000000000000000000000000;;							s.RemoteAddr(),
0000000000000000000000000000000000000000;;							candidate.perms.CriticalOptions[sourceAddressCriticalOption])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					cache.add(candidate)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if isQuery {
0000000000000000000000000000000000000000;;					// The client can query if the given public key
0000000000000000000000000000000000000000;;					// would be okay.
0000000000000000000000000000000000000000;;					if len(payload) > 0 {
0000000000000000000000000000000000000000;;						return nil, parseError(msgUserAuthRequest)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if candidate.result == nil {
0000000000000000000000000000000000000000;;						okMsg := userAuthPubKeyOkMsg{
0000000000000000000000000000000000000000;;							Algo:   algo,
0000000000000000000000000000000000000000;;							PubKey: pubKeyData,
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err = s.transport.writePacket(Marshal(&okMsg)); err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue userAuthLoop
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					authErr = candidate.result
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sig, payload, ok := parseSignature(payload)
0000000000000000000000000000000000000000;;					if !ok || len(payload) > 0 {
0000000000000000000000000000000000000000;;						return nil, parseError(msgUserAuthRequest)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Ensure the public key algo and signature algo
0000000000000000000000000000000000000000;;					// are supported.  Compare the private key
0000000000000000000000000000000000000000;;					// algorithm name that corresponds to algo with
0000000000000000000000000000000000000000;;					// sig.Format.  This is usually the same, but
0000000000000000000000000000000000000000;;					// for certs, the names differ.
0000000000000000000000000000000000000000;;					if !isAcceptableAlgo(sig.Format) {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					signedData := buildDataSignedForAuth(s.transport.getSessionID(), userAuthReq, algoBytes, pubKeyData)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if err := pubKey.Verify(signedData, sig); err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					authErr = candidate.result
0000000000000000000000000000000000000000;;					perms = candidate.perms
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				authErr = fmt.Errorf("ssh: unknown method %q", userAuthReq.Method)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if config.AuthLogCallback != nil {
0000000000000000000000000000000000000000;;				config.AuthLogCallback(s, userAuthReq.Method, authErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if authErr == nil {
0000000000000000000000000000000000000000;;				break userAuthLoop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var failureMsg userAuthFailureMsg
0000000000000000000000000000000000000000;;			if config.PasswordCallback != nil {
0000000000000000000000000000000000000000;;				failureMsg.Methods = append(failureMsg.Methods, "password")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if config.PublicKeyCallback != nil {
0000000000000000000000000000000000000000;;				failureMsg.Methods = append(failureMsg.Methods, "publickey")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if config.KeyboardInteractiveCallback != nil {
0000000000000000000000000000000000000000;;				failureMsg.Methods = append(failureMsg.Methods, "keyboard-interactive")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(failureMsg.Methods) == 0 {
0000000000000000000000000000000000000000;;				return nil, errors.New("ssh: no authentication methods configured but NoClientAuth is also false")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err = s.transport.writePacket(Marshal(&failureMsg)); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = s.transport.writePacket([]byte{msgUserAuthSuccess}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return perms, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sshClientKeyboardInteractive implements a ClientKeyboardInteractive by
0000000000000000000000000000000000000000;;	// asking the client on the other side of a ServerConn.
0000000000000000000000000000000000000000;;	type sshClientKeyboardInteractive struct {
0000000000000000000000000000000000000000;;		*connection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *sshClientKeyboardInteractive) Challenge(user, instruction string, questions []string, echos []bool) (answers []string, err error) {
0000000000000000000000000000000000000000;;		if len(questions) != len(echos) {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: echos and questions must have equal length")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var prompts []byte
0000000000000000000000000000000000000000;;		for i := range questions {
0000000000000000000000000000000000000000;;			prompts = appendString(prompts, questions[i])
0000000000000000000000000000000000000000;;			prompts = appendBool(prompts, echos[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.transport.writePacket(Marshal(&userAuthInfoRequestMsg{
0000000000000000000000000000000000000000;;			Instruction: instruction,
0000000000000000000000000000000000000000;;			NumPrompts:  uint32(len(questions)),
0000000000000000000000000000000000000000;;			Prompts:     prompts,
0000000000000000000000000000000000000000;;		})); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		packet, err := c.transport.readPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if packet[0] != msgUserAuthInfoResponse {
0000000000000000000000000000000000000000;;			return nil, unexpectedMessageError(msgUserAuthInfoResponse, packet[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		packet = packet[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, packet, ok := parseUint32(packet)
0000000000000000000000000000000000000000;;		if !ok || int(n) != len(questions) {
0000000000000000000000000000000000000000;;			return nil, parseError(msgUserAuthInfoResponse)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := uint32(0); i < n; i++ {
0000000000000000000000000000000000000000;;			ans, rest, ok := parseString(packet)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, parseError(msgUserAuthInfoResponse)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			answers = append(answers, string(ans))
0000000000000000000000000000000000000000;;			packet = rest
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(packet) != 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: junk at end of message")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return answers, nil
0000000000000000000000000000000000000000;;	}
