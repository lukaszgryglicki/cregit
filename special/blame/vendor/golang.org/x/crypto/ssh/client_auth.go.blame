0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/client_auth.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/client_auth.go][vendor/golang.org/x/crypto/ssh/client_auth.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientAuthenticate authenticates with the remote server. See RFC 4252.
0000000000000000000000000000000000000000;;	func (c *connection) clientAuthenticate(config *ClientConfig) error {
0000000000000000000000000000000000000000;;		// initiate user auth session
0000000000000000000000000000000000000000;;		if err := c.transport.writePacket(Marshal(&serviceRequestMsg{serviceUserAuth})); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		packet, err := c.transport.readPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var serviceAccept serviceAcceptMsg
0000000000000000000000000000000000000000;;		if err := Unmarshal(packet, &serviceAccept); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// during the authentication phase the client first attempts the "none" method
0000000000000000000000000000000000000000;;		// then any untried methods suggested by the server.
0000000000000000000000000000000000000000;;		tried := make(map[string]bool)
0000000000000000000000000000000000000000;;		var lastMethods []string
0000000000000000000000000000000000000000;;		for auth := AuthMethod(new(noneAuth)); auth != nil; {
0000000000000000000000000000000000000000;;			ok, methods, err := auth.auth(c.transport.getSessionID(), config.User, c.transport, config.Rand)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				// success
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tried[auth.method()] = true
0000000000000000000000000000000000000000;;			if methods == nil {
0000000000000000000000000000000000000000;;				methods = lastMethods
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastMethods = methods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			auth = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		findNext:
0000000000000000000000000000000000000000;;			for _, a := range config.Auth {
0000000000000000000000000000000000000000;;				candidateMethod := a.method()
0000000000000000000000000000000000000000;;				if tried[candidateMethod] {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, meth := range methods {
0000000000000000000000000000000000000000;;					if meth == candidateMethod {
0000000000000000000000000000000000000000;;						auth = a
0000000000000000000000000000000000000000;;						break findNext
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("ssh: unable to authenticate, attempted methods %v, no supported methods remain", keys(tried))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func keys(m map[string]bool) []string {
0000000000000000000000000000000000000000;;		s := make([]string, 0, len(m))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key := range m {
0000000000000000000000000000000000000000;;			s = append(s, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An AuthMethod represents an instance of an RFC 4252 authentication method.
0000000000000000000000000000000000000000;;	type AuthMethod interface {
0000000000000000000000000000000000000000;;		// auth authenticates user over transport t.
0000000000000000000000000000000000000000;;		// Returns true if authentication is successful.
0000000000000000000000000000000000000000;;		// If authentication is not successful, a []string of alternative
0000000000000000000000000000000000000000;;		// method names is returned. If the slice is nil, it will be ignored
0000000000000000000000000000000000000000;;		// and the previous set of possible methods will be reused.
0000000000000000000000000000000000000000;;		auth(session []byte, user string, p packetConn, rand io.Reader) (bool, []string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// method returns the RFC 4252 method name.
0000000000000000000000000000000000000000;;		method() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// "none" authentication, RFC 4252 section 5.2.
0000000000000000000000000000000000000000;;	type noneAuth int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *noneAuth) auth(session []byte, user string, c packetConn, rand io.Reader) (bool, []string, error) {
0000000000000000000000000000000000000000;;		if err := c.writePacket(Marshal(&userAuthRequestMsg{
0000000000000000000000000000000000000000;;			User:    user,
0000000000000000000000000000000000000000;;			Service: serviceSSH,
0000000000000000000000000000000000000000;;			Method:  "none",
0000000000000000000000000000000000000000;;		})); err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return handleAuthResponse(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *noneAuth) method() string {
0000000000000000000000000000000000000000;;		return "none"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// passwordCallback is an AuthMethod that fetches the password through
0000000000000000000000000000000000000000;;	// a function call, e.g. by prompting the user.
0000000000000000000000000000000000000000;;	type passwordCallback func() (password string, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cb passwordCallback) auth(session []byte, user string, c packetConn, rand io.Reader) (bool, []string, error) {
0000000000000000000000000000000000000000;;		type passwordAuthMsg struct {
0000000000000000000000000000000000000000;;			User     string `sshtype:"50"`
0000000000000000000000000000000000000000;;			Service  string
0000000000000000000000000000000000000000;;			Method   string
0000000000000000000000000000000000000000;;			Reply    bool
0000000000000000000000000000000000000000;;			Password string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pw, err := cb()
0000000000000000000000000000000000000000;;		// REVIEW NOTE: is there a need to support skipping a password attempt?
0000000000000000000000000000000000000000;;		// The program may only find out that the user doesn't have a password
0000000000000000000000000000000000000000;;		// when prompting.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.writePacket(Marshal(&passwordAuthMsg{
0000000000000000000000000000000000000000;;			User:     user,
0000000000000000000000000000000000000000;;			Service:  serviceSSH,
0000000000000000000000000000000000000000;;			Method:   cb.method(),
0000000000000000000000000000000000000000;;			Reply:    false,
0000000000000000000000000000000000000000;;			Password: pw,
0000000000000000000000000000000000000000;;		})); err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return handleAuthResponse(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cb passwordCallback) method() string {
0000000000000000000000000000000000000000;;		return "password"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Password returns an AuthMethod using the given password.
0000000000000000000000000000000000000000;;	func Password(secret string) AuthMethod {
0000000000000000000000000000000000000000;;		return passwordCallback(func() (string, error) { return secret, nil })
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PasswordCallback returns an AuthMethod that uses a callback for
0000000000000000000000000000000000000000;;	// fetching a password.
0000000000000000000000000000000000000000;;	func PasswordCallback(prompt func() (secret string, err error)) AuthMethod {
0000000000000000000000000000000000000000;;		return passwordCallback(prompt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type publickeyAuthMsg struct {
0000000000000000000000000000000000000000;;		User    string `sshtype:"50"`
0000000000000000000000000000000000000000;;		Service string
0000000000000000000000000000000000000000;;		Method  string
0000000000000000000000000000000000000000;;		// HasSig indicates to the receiver packet that the auth request is signed and
0000000000000000000000000000000000000000;;		// should be used for authentication of the request.
0000000000000000000000000000000000000000;;		HasSig   bool
0000000000000000000000000000000000000000;;		Algoname string
0000000000000000000000000000000000000000;;		PubKey   []byte
0000000000000000000000000000000000000000;;		// Sig is tagged with "rest" so Marshal will exclude it during
0000000000000000000000000000000000000000;;		// validateKey
0000000000000000000000000000000000000000;;		Sig []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// publicKeyCallback is an AuthMethod that uses a set of key
0000000000000000000000000000000000000000;;	// pairs for authentication.
0000000000000000000000000000000000000000;;	type publicKeyCallback func() ([]Signer, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cb publicKeyCallback) method() string {
0000000000000000000000000000000000000000;;		return "publickey"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cb publicKeyCallback) auth(session []byte, user string, c packetConn, rand io.Reader) (bool, []string, error) {
0000000000000000000000000000000000000000;;		// Authentication is performed in two stages. The first stage sends an
0000000000000000000000000000000000000000;;		// enquiry to test if each key is acceptable to the remote. The second
0000000000000000000000000000000000000000;;		// stage attempts to authenticate with the valid keys obtained in the
0000000000000000000000000000000000000000;;		// first stage.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signers, err := cb()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var validKeys []Signer
0000000000000000000000000000000000000000;;		for _, signer := range signers {
0000000000000000000000000000000000000000;;			if ok, err := validateKey(signer.PublicKey(), user, c); ok {
0000000000000000000000000000000000000000;;				validKeys = append(validKeys, signer)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// methods that may continue if this auth is not successful.
0000000000000000000000000000000000000000;;		var methods []string
0000000000000000000000000000000000000000;;		for _, signer := range validKeys {
0000000000000000000000000000000000000000;;			pub := signer.PublicKey()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pubKey := pub.Marshal()
0000000000000000000000000000000000000000;;			sign, err := signer.Sign(rand, buildDataSignedForAuth(session, userAuthRequestMsg{
0000000000000000000000000000000000000000;;				User:    user,
0000000000000000000000000000000000000000;;				Service: serviceSSH,
0000000000000000000000000000000000000000;;				Method:  cb.method(),
0000000000000000000000000000000000000000;;			}, []byte(pub.Type()), pubKey))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// manually wrap the serialized signature in a string
0000000000000000000000000000000000000000;;			s := Marshal(sign)
0000000000000000000000000000000000000000;;			sig := make([]byte, stringLength(len(s)))
0000000000000000000000000000000000000000;;			marshalString(sig, s)
0000000000000000000000000000000000000000;;			msg := publickeyAuthMsg{
0000000000000000000000000000000000000000;;				User:     user,
0000000000000000000000000000000000000000;;				Service:  serviceSSH,
0000000000000000000000000000000000000000;;				Method:   cb.method(),
0000000000000000000000000000000000000000;;				HasSig:   true,
0000000000000000000000000000000000000000;;				Algoname: pub.Type(),
0000000000000000000000000000000000000000;;				PubKey:   pubKey,
0000000000000000000000000000000000000000;;				Sig:      sig,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p := Marshal(&msg)
0000000000000000000000000000000000000000;;			if err := c.writePacket(p); err != nil {
0000000000000000000000000000000000000000;;				return false, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var success bool
0000000000000000000000000000000000000000;;			success, methods, err = handleAuthResponse(c)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if success {
0000000000000000000000000000000000000000;;				return success, methods, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, methods, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateKey validates the key provided is acceptable to the server.
0000000000000000000000000000000000000000;;	func validateKey(key PublicKey, user string, c packetConn) (bool, error) {
0000000000000000000000000000000000000000;;		pubKey := key.Marshal()
0000000000000000000000000000000000000000;;		msg := publickeyAuthMsg{
0000000000000000000000000000000000000000;;			User:     user,
0000000000000000000000000000000000000000;;			Service:  serviceSSH,
0000000000000000000000000000000000000000;;			Method:   "publickey",
0000000000000000000000000000000000000000;;			HasSig:   false,
0000000000000000000000000000000000000000;;			Algoname: key.Type(),
0000000000000000000000000000000000000000;;			PubKey:   pubKey,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.writePacket(Marshal(&msg)); err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return confirmKeyAck(key, c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func confirmKeyAck(key PublicKey, c packetConn) (bool, error) {
0000000000000000000000000000000000000000;;		pubKey := key.Marshal()
0000000000000000000000000000000000000000;;		algoname := key.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			packet, err := c.readPacket()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch packet[0] {
0000000000000000000000000000000000000000;;			case msgUserAuthBanner:
0000000000000000000000000000000000000000;;				// TODO(gpaul): add callback to present the banner to the user
0000000000000000000000000000000000000000;;			case msgUserAuthPubKeyOk:
0000000000000000000000000000000000000000;;				var msg userAuthPubKeyOkMsg
0000000000000000000000000000000000000000;;				if err := Unmarshal(packet, &msg); err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if msg.Algo != algoname || !bytes.Equal(msg.PubKey, pubKey) {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			case msgUserAuthFailure:
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, unexpectedMessageError(msgUserAuthSuccess, packet[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PublicKeys returns an AuthMethod that uses the given key
0000000000000000000000000000000000000000;;	// pairs.
0000000000000000000000000000000000000000;;	func PublicKeys(signers ...Signer) AuthMethod {
0000000000000000000000000000000000000000;;		return publicKeyCallback(func() ([]Signer, error) { return signers, nil })
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PublicKeysCallback returns an AuthMethod that runs the given
0000000000000000000000000000000000000000;;	// function to obtain a list of key pairs.
0000000000000000000000000000000000000000;;	func PublicKeysCallback(getSigners func() (signers []Signer, err error)) AuthMethod {
0000000000000000000000000000000000000000;;		return publicKeyCallback(getSigners)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleAuthResponse returns whether the preceding authentication request succeeded
0000000000000000000000000000000000000000;;	// along with a list of remaining authentication methods to try next and
0000000000000000000000000000000000000000;;	// an error if an unexpected response was received.
0000000000000000000000000000000000000000;;	func handleAuthResponse(c packetConn) (bool, []string, error) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			packet, err := c.readPacket()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch packet[0] {
0000000000000000000000000000000000000000;;			case msgUserAuthBanner:
0000000000000000000000000000000000000000;;				// TODO: add callback to present the banner to the user
0000000000000000000000000000000000000000;;			case msgUserAuthFailure:
0000000000000000000000000000000000000000;;				var msg userAuthFailureMsg
0000000000000000000000000000000000000000;;				if err := Unmarshal(packet, &msg); err != nil {
0000000000000000000000000000000000000000;;					return false, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, msg.Methods, nil
0000000000000000000000000000000000000000;;			case msgUserAuthSuccess:
0000000000000000000000000000000000000000;;				return true, nil, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, nil, unexpectedMessageError(msgUserAuthSuccess, packet[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyboardInteractiveChallenge should print questions, optionally
0000000000000000000000000000000000000000;;	// disabling echoing (e.g. for passwords), and return all the answers.
0000000000000000000000000000000000000000;;	// Challenge may be called multiple times in a single session. After
0000000000000000000000000000000000000000;;	// successful authentication, the server may send a challenge with no
0000000000000000000000000000000000000000;;	// questions, for which the user and instruction messages should be
0000000000000000000000000000000000000000;;	// printed.  RFC 4256 section 3.3 details how the UI should behave for
0000000000000000000000000000000000000000;;	// both CLI and GUI environments.
0000000000000000000000000000000000000000;;	type KeyboardInteractiveChallenge func(user, instruction string, questions []string, echos []bool) (answers []string, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyboardInteractive returns a AuthMethod using a prompt/response
0000000000000000000000000000000000000000;;	// sequence controlled by the server.
0000000000000000000000000000000000000000;;	func KeyboardInteractive(challenge KeyboardInteractiveChallenge) AuthMethod {
0000000000000000000000000000000000000000;;		return challenge
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cb KeyboardInteractiveChallenge) method() string {
0000000000000000000000000000000000000000;;		return "keyboard-interactive"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cb KeyboardInteractiveChallenge) auth(session []byte, user string, c packetConn, rand io.Reader) (bool, []string, error) {
0000000000000000000000000000000000000000;;		type initiateMsg struct {
0000000000000000000000000000000000000000;;			User       string `sshtype:"50"`
0000000000000000000000000000000000000000;;			Service    string
0000000000000000000000000000000000000000;;			Method     string
0000000000000000000000000000000000000000;;			Language   string
0000000000000000000000000000000000000000;;			Submethods string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.writePacket(Marshal(&initiateMsg{
0000000000000000000000000000000000000000;;			User:    user,
0000000000000000000000000000000000000000;;			Service: serviceSSH,
0000000000000000000000000000000000000000;;			Method:  "keyboard-interactive",
0000000000000000000000000000000000000000;;		})); err != nil {
0000000000000000000000000000000000000000;;			return false, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			packet, err := c.readPacket()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// like handleAuthResponse, but with less options.
0000000000000000000000000000000000000000;;			switch packet[0] {
0000000000000000000000000000000000000000;;			case msgUserAuthBanner:
0000000000000000000000000000000000000000;;				// TODO: Print banners during userauth.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case msgUserAuthInfoRequest:
0000000000000000000000000000000000000000;;				// OK
0000000000000000000000000000000000000000;;			case msgUserAuthFailure:
0000000000000000000000000000000000000000;;				var msg userAuthFailureMsg
0000000000000000000000000000000000000000;;				if err := Unmarshal(packet, &msg); err != nil {
0000000000000000000000000000000000000000;;					return false, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, msg.Methods, nil
0000000000000000000000000000000000000000;;			case msgUserAuthSuccess:
0000000000000000000000000000000000000000;;				return true, nil, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, nil, unexpectedMessageError(msgUserAuthInfoRequest, packet[0])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var msg userAuthInfoRequestMsg
0000000000000000000000000000000000000000;;			if err := Unmarshal(packet, &msg); err != nil {
0000000000000000000000000000000000000000;;				return false, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Manually unpack the prompt/echo pairs.
0000000000000000000000000000000000000000;;			rest := msg.Prompts
0000000000000000000000000000000000000000;;			var prompts []string
0000000000000000000000000000000000000000;;			var echos []bool
0000000000000000000000000000000000000000;;			for i := 0; i < int(msg.NumPrompts); i++ {
0000000000000000000000000000000000000000;;				prompt, r, ok := parseString(rest)
0000000000000000000000000000000000000000;;				if !ok || len(r) == 0 {
0000000000000000000000000000000000000000;;					return false, nil, errors.New("ssh: prompt format error")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				prompts = append(prompts, string(prompt))
0000000000000000000000000000000000000000;;				echos = append(echos, r[0] != 0)
0000000000000000000000000000000000000000;;				rest = r[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(rest) != 0 {
0000000000000000000000000000000000000000;;				return false, nil, errors.New("ssh: extra data following keyboard-interactive pairs")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			answers, err := cb(msg.User, msg.Instruction, prompts, echos)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(answers) != len(prompts) {
0000000000000000000000000000000000000000;;				return false, nil, errors.New("ssh: not enough answers from keyboard-interactive callback")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			responseLength := 1 + 4
0000000000000000000000000000000000000000;;			for _, a := range answers {
0000000000000000000000000000000000000000;;				responseLength += stringLength(len(a))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			serialized := make([]byte, responseLength)
0000000000000000000000000000000000000000;;			p := serialized
0000000000000000000000000000000000000000;;			p[0] = msgUserAuthInfoResponse
0000000000000000000000000000000000000000;;			p = p[1:]
0000000000000000000000000000000000000000;;			p = marshalUint32(p, uint32(len(answers)))
0000000000000000000000000000000000000000;;			for _, a := range answers {
0000000000000000000000000000000000000000;;				p = marshalString(p, []byte(a))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := c.writePacket(serialized); err != nil {
0000000000000000000000000000000000000000;;				return false, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type retryableAuthMethod struct {
0000000000000000000000000000000000000000;;		authMethod AuthMethod
0000000000000000000000000000000000000000;;		maxTries   int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *retryableAuthMethod) auth(session []byte, user string, c packetConn, rand io.Reader) (ok bool, methods []string, err error) {
0000000000000000000000000000000000000000;;		for i := 0; r.maxTries <= 0 || i < r.maxTries; i++ {
0000000000000000000000000000000000000000;;			ok, methods, err = r.authMethod.auth(session, user, c, rand)
0000000000000000000000000000000000000000;;			if ok || err != nil { // either success or error terminate
0000000000000000000000000000000000000000;;				return ok, methods, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ok, methods, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *retryableAuthMethod) method() string {
0000000000000000000000000000000000000000;;		return r.authMethod.method()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetryableAuthMethod is a decorator for other auth methods enabling them to
0000000000000000000000000000000000000000;;	// be retried up to maxTries before considering that AuthMethod itself failed.
0000000000000000000000000000000000000000;;	// If maxTries is <= 0, will retry indefinitely
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is useful for interactive clients using challenge/response type
0000000000000000000000000000000000000000;;	// authentication (e.g. Keyboard-Interactive, Password, etc) where the user
0000000000000000000000000000000000000000;;	// could mistype their response resulting in the server issuing a
0000000000000000000000000000000000000000;;	// SSH_MSG_USERAUTH_FAILURE (rfc4252 #8 [password] and rfc4256 #3.4
0000000000000000000000000000000000000000;;	// [keyboard-interactive]); Without this decorator, the non-retryable
0000000000000000000000000000000000000000;;	// AuthMethod would be removed from future consideration, and never tried again
0000000000000000000000000000000000000000;;	// (and so the user would never be able to retry their entry).
0000000000000000000000000000000000000000;;	func RetryableAuthMethod(auth AuthMethod, maxTries int) AuthMethod {
0000000000000000000000000000000000000000;;		return &retryableAuthMethod{authMethod: auth, maxTries: maxTries}
0000000000000000000000000000000000000000;;	}
