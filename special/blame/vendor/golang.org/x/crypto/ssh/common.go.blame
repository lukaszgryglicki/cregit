0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/common.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/common.go][vendor/golang.org/x/crypto/ssh/common.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ "crypto/sha1"
0000000000000000000000000000000000000000;;		_ "crypto/sha256"
0000000000000000000000000000000000000000;;		_ "crypto/sha512"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are string constants in the SSH protocol.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		compressionNone = "none"
0000000000000000000000000000000000000000;;		serviceUserAuth = "ssh-userauth"
0000000000000000000000000000000000000000;;		serviceSSH      = "ssh-connection"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supportedCiphers specifies the supported ciphers in preference order.
0000000000000000000000000000000000000000;;	var supportedCiphers = []string{
0000000000000000000000000000000000000000;;		"aes128-ctr", "aes192-ctr", "aes256-ctr",
0000000000000000000000000000000000000000;;		"aes128-gcm@openssh.com",
0000000000000000000000000000000000000000;;		"arcfour256", "arcfour128",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supportedKexAlgos specifies the supported key-exchange algorithms in
0000000000000000000000000000000000000000;;	// preference order.
0000000000000000000000000000000000000000;;	var supportedKexAlgos = []string{
0000000000000000000000000000000000000000;;		kexAlgoCurve25519SHA256,
0000000000000000000000000000000000000000;;		// P384 and P521 are not constant-time yet, but since we don't
0000000000000000000000000000000000000000;;		// reuse ephemeral keys, using them for ECDH should be OK.
0000000000000000000000000000000000000000;;		kexAlgoECDH256, kexAlgoECDH384, kexAlgoECDH521,
0000000000000000000000000000000000000000;;		kexAlgoDH14SHA1, kexAlgoDH1SHA1,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supportedKexAlgos specifies the supported host-key algorithms (i.e. methods
0000000000000000000000000000000000000000;;	// of authenticating servers) in preference order.
0000000000000000000000000000000000000000;;	var supportedHostKeyAlgos = []string{
0000000000000000000000000000000000000000;;		CertAlgoRSAv01, CertAlgoDSAv01, CertAlgoECDSA256v01,
0000000000000000000000000000000000000000;;		CertAlgoECDSA384v01, CertAlgoECDSA521v01, CertAlgoED25519v01,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		KeyAlgoECDSA256, KeyAlgoECDSA384, KeyAlgoECDSA521,
0000000000000000000000000000000000000000;;		KeyAlgoRSA, KeyAlgoDSA,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		KeyAlgoED25519,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supportedMACs specifies a default set of MAC algorithms in preference order.
0000000000000000000000000000000000000000;;	// This is based on RFC 4253, section 6.4, but with hmac-md5 variants removed
0000000000000000000000000000000000000000;;	// because they have reached the end of their useful life.
0000000000000000000000000000000000000000;;	var supportedMACs = []string{
0000000000000000000000000000000000000000;;		"hmac-sha2-256", "hmac-sha1", "hmac-sha1-96",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var supportedCompressions = []string{compressionNone}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hashFuncs keeps the mapping of supported algorithms to their respective
0000000000000000000000000000000000000000;;	// hashes needed for signature verification.
0000000000000000000000000000000000000000;;	var hashFuncs = map[string]crypto.Hash{
0000000000000000000000000000000000000000;;		KeyAlgoRSA:          crypto.SHA1,
0000000000000000000000000000000000000000;;		KeyAlgoDSA:          crypto.SHA1,
0000000000000000000000000000000000000000;;		KeyAlgoECDSA256:     crypto.SHA256,
0000000000000000000000000000000000000000;;		KeyAlgoECDSA384:     crypto.SHA384,
0000000000000000000000000000000000000000;;		KeyAlgoECDSA521:     crypto.SHA512,
0000000000000000000000000000000000000000;;		CertAlgoRSAv01:      crypto.SHA1,
0000000000000000000000000000000000000000;;		CertAlgoDSAv01:      crypto.SHA1,
0000000000000000000000000000000000000000;;		CertAlgoECDSA256v01: crypto.SHA256,
0000000000000000000000000000000000000000;;		CertAlgoECDSA384v01: crypto.SHA384,
0000000000000000000000000000000000000000;;		CertAlgoECDSA521v01: crypto.SHA512,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unexpectedMessageError results when the SSH message that we received didn't
0000000000000000000000000000000000000000;;	// match what we wanted.
0000000000000000000000000000000000000000;;	func unexpectedMessageError(expected, got uint8) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("ssh: unexpected message type %d (expected %d)", got, expected)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseError results from a malformed SSH message.
0000000000000000000000000000000000000000;;	func parseError(tag uint8) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("ssh: parse error in message type %d", tag)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findCommon(what string, client []string, server []string) (common string, err error) {
0000000000000000000000000000000000000000;;		for _, c := range client {
0000000000000000000000000000000000000000;;			for _, s := range server {
0000000000000000000000000000000000000000;;				if c == s {
0000000000000000000000000000000000000000;;					return c, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("ssh: no common algorithm for %s; client offered: %v, server offered: %v", what, client, server)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type directionAlgorithms struct {
0000000000000000000000000000000000000000;;		Cipher      string
0000000000000000000000000000000000000000;;		MAC         string
0000000000000000000000000000000000000000;;		Compression string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type algorithms struct {
0000000000000000000000000000000000000000;;		kex     string
0000000000000000000000000000000000000000;;		hostKey string
0000000000000000000000000000000000000000;;		w       directionAlgorithms
0000000000000000000000000000000000000000;;		r       directionAlgorithms
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findAgreedAlgorithms(clientKexInit, serverKexInit *kexInitMsg) (algs *algorithms, err error) {
0000000000000000000000000000000000000000;;		result := &algorithms{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.kex, err = findCommon("key exchange", clientKexInit.KexAlgos, serverKexInit.KexAlgos)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.hostKey, err = findCommon("host key", clientKexInit.ServerHostKeyAlgos, serverKexInit.ServerHostKeyAlgos)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.w.Cipher, err = findCommon("client to server cipher", clientKexInit.CiphersClientServer, serverKexInit.CiphersClientServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.r.Cipher, err = findCommon("server to client cipher", clientKexInit.CiphersServerClient, serverKexInit.CiphersServerClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.w.MAC, err = findCommon("client to server MAC", clientKexInit.MACsClientServer, serverKexInit.MACsClientServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.r.MAC, err = findCommon("server to client MAC", clientKexInit.MACsServerClient, serverKexInit.MACsServerClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.w.Compression, err = findCommon("client to server compression", clientKexInit.CompressionClientServer, serverKexInit.CompressionClientServer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.r.Compression, err = findCommon("server to client compression", clientKexInit.CompressionServerClient, serverKexInit.CompressionServerClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If rekeythreshold is too small, we can't make any progress sending
0000000000000000000000000000000000000000;;	// stuff.
0000000000000000000000000000000000000000;;	const minRekeyThreshold uint64 = 256
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config contains configuration data common to both ServerConfig and
0000000000000000000000000000000000000000;;	// ClientConfig.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// Rand provides the source of entropy for cryptographic
0000000000000000000000000000000000000000;;		// primitives. If Rand is nil, the cryptographic random reader
0000000000000000000000000000000000000000;;		// in package crypto/rand will be used.
0000000000000000000000000000000000000000;;		Rand io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The maximum number of bytes sent or received after which a
0000000000000000000000000000000000000000;;		// new key is negotiated. It must be at least 256. If
0000000000000000000000000000000000000000;;		// unspecified, 1 gigabyte is used.
0000000000000000000000000000000000000000;;		RekeyThreshold uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The allowed key exchanges algorithms. If unspecified then a
0000000000000000000000000000000000000000;;		// default set of algorithms is used.
0000000000000000000000000000000000000000;;		KeyExchanges []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The allowed cipher algorithms. If unspecified then a sensible
0000000000000000000000000000000000000000;;		// default is used.
0000000000000000000000000000000000000000;;		Ciphers []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The allowed MAC algorithms. If unspecified then a sensible default
0000000000000000000000000000000000000000;;		// is used.
0000000000000000000000000000000000000000;;		MACs []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetDefaults sets sensible values for unset fields in config. This is
0000000000000000000000000000000000000000;;	// exported for testing: Configs passed to SSH functions are copied and have
0000000000000000000000000000000000000000;;	// default values set automatically.
0000000000000000000000000000000000000000;;	func (c *Config) SetDefaults() {
0000000000000000000000000000000000000000;;		if c.Rand == nil {
0000000000000000000000000000000000000000;;			c.Rand = rand.Reader
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.Ciphers == nil {
0000000000000000000000000000000000000000;;			c.Ciphers = supportedCiphers
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ciphers []string
0000000000000000000000000000000000000000;;		for _, c := range c.Ciphers {
0000000000000000000000000000000000000000;;			if cipherModes[c] != nil {
0000000000000000000000000000000000000000;;				// reject the cipher if we have no cipherModes definition
0000000000000000000000000000000000000000;;				ciphers = append(ciphers, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Ciphers = ciphers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.KeyExchanges == nil {
0000000000000000000000000000000000000000;;			c.KeyExchanges = supportedKexAlgos
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.MACs == nil {
0000000000000000000000000000000000000000;;			c.MACs = supportedMACs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.RekeyThreshold == 0 {
0000000000000000000000000000000000000000;;			// RFC 4253, section 9 suggests rekeying after 1G.
0000000000000000000000000000000000000000;;			c.RekeyThreshold = 1 << 30
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.RekeyThreshold < minRekeyThreshold {
0000000000000000000000000000000000000000;;			c.RekeyThreshold = minRekeyThreshold
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildDataSignedForAuth returns the data that is signed in order to prove
0000000000000000000000000000000000000000;;	// possession of a private key. See RFC 4252, section 7.
0000000000000000000000000000000000000000;;	func buildDataSignedForAuth(sessionId []byte, req userAuthRequestMsg, algo, pubKey []byte) []byte {
0000000000000000000000000000000000000000;;		data := struct {
0000000000000000000000000000000000000000;;			Session []byte
0000000000000000000000000000000000000000;;			Type    byte
0000000000000000000000000000000000000000;;			User    string
0000000000000000000000000000000000000000;;			Service string
0000000000000000000000000000000000000000;;			Method  string
0000000000000000000000000000000000000000;;			Sign    bool
0000000000000000000000000000000000000000;;			Algo    []byte
0000000000000000000000000000000000000000;;			PubKey  []byte
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			sessionId,
0000000000000000000000000000000000000000;;			msgUserAuthRequest,
0000000000000000000000000000000000000000;;			req.User,
0000000000000000000000000000000000000000;;			req.Service,
0000000000000000000000000000000000000000;;			req.Method,
0000000000000000000000000000000000000000;;			true,
0000000000000000000000000000000000000000;;			algo,
0000000000000000000000000000000000000000;;			pubKey,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Marshal(data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendU16(buf []byte, n uint16) []byte {
0000000000000000000000000000000000000000;;		return append(buf, byte(n>>8), byte(n))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendU32(buf []byte, n uint32) []byte {
0000000000000000000000000000000000000000;;		return append(buf, byte(n>>24), byte(n>>16), byte(n>>8), byte(n))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendU64(buf []byte, n uint64) []byte {
0000000000000000000000000000000000000000;;		return append(buf,
0000000000000000000000000000000000000000;;			byte(n>>56), byte(n>>48), byte(n>>40), byte(n>>32),
0000000000000000000000000000000000000000;;			byte(n>>24), byte(n>>16), byte(n>>8), byte(n))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendInt(buf []byte, n int) []byte {
0000000000000000000000000000000000000000;;		return appendU32(buf, uint32(n))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendString(buf []byte, s string) []byte {
0000000000000000000000000000000000000000;;		buf = appendU32(buf, uint32(len(s)))
0000000000000000000000000000000000000000;;		buf = append(buf, s...)
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendBool(buf []byte, b bool) []byte {
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			return append(buf, 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(buf, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newCond is a helper to hide the fact that there is no usable zero
0000000000000000000000000000000000000000;;	// value for sync.Cond.
0000000000000000000000000000000000000000;;	func newCond() *sync.Cond { return sync.NewCond(new(sync.Mutex)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// window represents the buffer available to clients
0000000000000000000000000000000000000000;;	// wishing to write to a channel.
0000000000000000000000000000000000000000;;	type window struct {
0000000000000000000000000000000000000000;;		*sync.Cond
0000000000000000000000000000000000000000;;		win          uint32 // RFC 4254 5.2 says the window size can grow to 2^32-1
0000000000000000000000000000000000000000;;		writeWaiters int
0000000000000000000000000000000000000000;;		closed       bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// add adds win to the amount of window available
0000000000000000000000000000000000000000;;	// for consumers.
0000000000000000000000000000000000000000;;	func (w *window) add(win uint32) bool {
0000000000000000000000000000000000000000;;		// a zero sized window adjust is a noop.
0000000000000000000000000000000000000000;;		if win == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.L.Lock()
0000000000000000000000000000000000000000;;		if w.win+win < win {
0000000000000000000000000000000000000000;;			w.L.Unlock()
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.win += win
0000000000000000000000000000000000000000;;		// It is unusual that multiple goroutines would be attempting to reserve
0000000000000000000000000000000000000000;;		// window space, but not guaranteed. Use broadcast to notify all waiters
0000000000000000000000000000000000000000;;		// that additional window is available.
0000000000000000000000000000000000000000;;		w.Broadcast()
0000000000000000000000000000000000000000;;		w.L.Unlock()
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// close sets the window to closed, so all reservations fail
0000000000000000000000000000000000000000;;	// immediately.
0000000000000000000000000000000000000000;;	func (w *window) close() {
0000000000000000000000000000000000000000;;		w.L.Lock()
0000000000000000000000000000000000000000;;		w.closed = true
0000000000000000000000000000000000000000;;		w.Broadcast()
0000000000000000000000000000000000000000;;		w.L.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reserve reserves win from the available window capacity.
0000000000000000000000000000000000000000;;	// If no capacity remains, reserve will block. reserve may
0000000000000000000000000000000000000000;;	// return less than requested.
0000000000000000000000000000000000000000;;	func (w *window) reserve(win uint32) (uint32, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		w.L.Lock()
0000000000000000000000000000000000000000;;		w.writeWaiters++
0000000000000000000000000000000000000000;;		w.Broadcast()
0000000000000000000000000000000000000000;;		for w.win == 0 && !w.closed {
0000000000000000000000000000000000000000;;			w.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.writeWaiters--
0000000000000000000000000000000000000000;;		if w.win < win {
0000000000000000000000000000000000000000;;			win = w.win
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.win -= win
0000000000000000000000000000000000000000;;		if w.closed {
0000000000000000000000000000000000000000;;			err = io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.L.Unlock()
0000000000000000000000000000000000000000;;		return win, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitWriterBlocked waits until some goroutine is blocked for further
0000000000000000000000000000000000000000;;	// writes. It is used in tests only.
0000000000000000000000000000000000000000;;	func (w *window) waitWriterBlocked() {
0000000000000000000000000000000000000000;;		w.Cond.L.Lock()
0000000000000000000000000000000000000000;;		for w.writeWaiters == 0 {
0000000000000000000000000000000000000000;;			w.Cond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Cond.L.Unlock()
0000000000000000000000000000000000000000;;	}
