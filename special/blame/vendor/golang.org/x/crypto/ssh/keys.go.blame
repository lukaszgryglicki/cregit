0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/keys.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/keys.go][vendor/golang.org/x/crypto/ssh/keys.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/dsa"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/ed25519"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These constants represent the algorithm names for key types supported by this
0000000000000000000000000000000000000000;;	// package.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		KeyAlgoRSA      = "ssh-rsa"
0000000000000000000000000000000000000000;;		KeyAlgoDSA      = "ssh-dss"
0000000000000000000000000000000000000000;;		KeyAlgoECDSA256 = "ecdsa-sha2-nistp256"
0000000000000000000000000000000000000000;;		KeyAlgoECDSA384 = "ecdsa-sha2-nistp384"
0000000000000000000000000000000000000000;;		KeyAlgoECDSA521 = "ecdsa-sha2-nistp521"
0000000000000000000000000000000000000000;;		KeyAlgoED25519  = "ssh-ed25519"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parsePubKey parses a public key of the given algorithm.
0000000000000000000000000000000000000000;;	// Use ParsePublicKey for keys with prepended algorithm.
0000000000000000000000000000000000000000;;	func parsePubKey(in []byte, algo string) (pubKey PublicKey, rest []byte, err error) {
0000000000000000000000000000000000000000;;		switch algo {
0000000000000000000000000000000000000000;;		case KeyAlgoRSA:
0000000000000000000000000000000000000000;;			return parseRSA(in)
0000000000000000000000000000000000000000;;		case KeyAlgoDSA:
0000000000000000000000000000000000000000;;			return parseDSA(in)
0000000000000000000000000000000000000000;;		case KeyAlgoECDSA256, KeyAlgoECDSA384, KeyAlgoECDSA521:
0000000000000000000000000000000000000000;;			return parseECDSA(in)
0000000000000000000000000000000000000000;;		case KeyAlgoED25519:
0000000000000000000000000000000000000000;;			return parseED25519(in)
0000000000000000000000000000000000000000;;		case CertAlgoRSAv01, CertAlgoDSAv01, CertAlgoECDSA256v01, CertAlgoECDSA384v01, CertAlgoECDSA521v01, CertAlgoED25519v01:
0000000000000000000000000000000000000000;;			cert, err := parseCert(in, certToPrivAlgo(algo))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cert, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil, fmt.Errorf("ssh: unknown key algorithm: %v", algo)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseAuthorizedKey parses a public key in OpenSSH authorized_keys format
0000000000000000000000000000000000000000;;	// (see sshd(8) manual page) once the options and key type fields have been
0000000000000000000000000000000000000000;;	// removed.
0000000000000000000000000000000000000000;;	func parseAuthorizedKey(in []byte) (out PublicKey, comment string, err error) {
0000000000000000000000000000000000000000;;		in = bytes.TrimSpace(in)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := bytes.IndexAny(in, " \t")
0000000000000000000000000000000000000000;;		if i == -1 {
0000000000000000000000000000000000000000;;			i = len(in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		base64Key := in[:i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := make([]byte, base64.StdEncoding.DecodedLen(len(base64Key)))
0000000000000000000000000000000000000000;;		n, err := base64.StdEncoding.Decode(key, base64Key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key = key[:n]
0000000000000000000000000000000000000000;;		out, err = ParsePublicKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		comment = string(bytes.TrimSpace(in[i:]))
0000000000000000000000000000000000000000;;		return out, comment, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseKnownHosts parses an entry in the format of the known_hosts file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The known_hosts format is documented in the sshd(8) manual page. This
0000000000000000000000000000000000000000;;	// function will parse a single entry from in. On successful return, marker
0000000000000000000000000000000000000000;;	// will contain the optional marker value (i.e. "cert-authority" or "revoked")
0000000000000000000000000000000000000000;;	// or else be empty, hosts will contain the hosts that this entry matches,
0000000000000000000000000000000000000000;;	// pubKey will contain the public key and comment will contain any trailing
0000000000000000000000000000000000000000;;	// comment at the end of the line. See the sshd(8) manual page for the various
0000000000000000000000000000000000000000;;	// forms that a host string can take.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The unparsed remainder of the input will be returned in rest. This function
0000000000000000000000000000000000000000;;	// can be called repeatedly to parse multiple entries.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If no entries were found in the input then err will be io.EOF. Otherwise a
0000000000000000000000000000000000000000;;	// non-nil err value indicates a parse error.
0000000000000000000000000000000000000000;;	func ParseKnownHosts(in []byte) (marker string, hosts []string, pubKey PublicKey, comment string, rest []byte, err error) {
0000000000000000000000000000000000000000;;		for len(in) > 0 {
0000000000000000000000000000000000000000;;			end := bytes.IndexByte(in, '\n')
0000000000000000000000000000000000000000;;			if end != -1 {
0000000000000000000000000000000000000000;;				rest = in[end+1:]
0000000000000000000000000000000000000000;;				in = in[:end]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rest = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			end = bytes.IndexByte(in, '\r')
0000000000000000000000000000000000000000;;			if end != -1 {
0000000000000000000000000000000000000000;;				in = in[:end]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			in = bytes.TrimSpace(in)
0000000000000000000000000000000000000000;;			if len(in) == 0 || in[0] == '#' {
0000000000000000000000000000000000000000;;				in = rest
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i := bytes.IndexAny(in, " \t")
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				in = rest
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Strip out the beginning of the known_host key.
0000000000000000000000000000000000000000;;			// This is either an optional marker or a (set of) hostname(s).
0000000000000000000000000000000000000000;;			keyFields := bytes.Fields(in)
0000000000000000000000000000000000000000;;			if len(keyFields) < 3 || len(keyFields) > 5 {
0000000000000000000000000000000000000000;;				return "", nil, nil, "", nil, errors.New("ssh: invalid entry in known_hosts data")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// keyFields[0] is either "@cert-authority", "@revoked" or a comma separated
0000000000000000000000000000000000000000;;			// list of hosts
0000000000000000000000000000000000000000;;			marker := ""
0000000000000000000000000000000000000000;;			if keyFields[0][0] == '@' {
0000000000000000000000000000000000000000;;				marker = string(keyFields[0][1:])
0000000000000000000000000000000000000000;;				keyFields = keyFields[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hosts := string(keyFields[0])
0000000000000000000000000000000000000000;;			// keyFields[1] contains the key type (e.g. “ssh-rsa”).
0000000000000000000000000000000000000000;;			// However, that information is duplicated inside the
0000000000000000000000000000000000000000;;			// base64-encoded key and so is ignored here.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			key := bytes.Join(keyFields[2:], []byte(" "))
0000000000000000000000000000000000000000;;			if pubKey, comment, err = parseAuthorizedKey(key); err != nil {
0000000000000000000000000000000000000000;;				return "", nil, nil, "", nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return marker, strings.Split(hosts, ","), pubKey, comment, rest, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", nil, nil, "", nil, io.EOF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseAuthorizedKeys parses a public key from an authorized_keys
0000000000000000000000000000000000000000;;	// file used in OpenSSH according to the sshd(8) manual page.
0000000000000000000000000000000000000000;;	func ParseAuthorizedKey(in []byte) (out PublicKey, comment string, options []string, rest []byte, err error) {
0000000000000000000000000000000000000000;;		for len(in) > 0 {
0000000000000000000000000000000000000000;;			end := bytes.IndexByte(in, '\n')
0000000000000000000000000000000000000000;;			if end != -1 {
0000000000000000000000000000000000000000;;				rest = in[end+1:]
0000000000000000000000000000000000000000;;				in = in[:end]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rest = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			end = bytes.IndexByte(in, '\r')
0000000000000000000000000000000000000000;;			if end != -1 {
0000000000000000000000000000000000000000;;				in = in[:end]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			in = bytes.TrimSpace(in)
0000000000000000000000000000000000000000;;			if len(in) == 0 || in[0] == '#' {
0000000000000000000000000000000000000000;;				in = rest
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i := bytes.IndexAny(in, " \t")
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				in = rest
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if out, comment, err = parseAuthorizedKey(in[i:]); err == nil {
0000000000000000000000000000000000000000;;				return out, comment, options, rest, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// No key type recognised. Maybe there's an options field at
0000000000000000000000000000000000000000;;			// the beginning.
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			inQuote := false
0000000000000000000000000000000000000000;;			var candidateOptions []string
0000000000000000000000000000000000000000;;			optionStart := 0
0000000000000000000000000000000000000000;;			for i, b = range in {
0000000000000000000000000000000000000000;;				isEnd := !inQuote && (b == ' ' || b == '\t')
0000000000000000000000000000000000000000;;				if (b == ',' && !inQuote) || isEnd {
0000000000000000000000000000000000000000;;					if i-optionStart > 0 {
0000000000000000000000000000000000000000;;						candidateOptions = append(candidateOptions, string(in[optionStart:i]))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					optionStart = i + 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isEnd {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b == '"' && (i == 0 || (i > 0 && in[i-1] != '\\')) {
0000000000000000000000000000000000000000;;					inQuote = !inQuote
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i < len(in) && (in[i] == ' ' || in[i] == '\t') {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i == len(in) {
0000000000000000000000000000000000000000;;				// Invalid line: unmatched quote
0000000000000000000000000000000000000000;;				in = rest
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			in = in[i:]
0000000000000000000000000000000000000000;;			i = bytes.IndexAny(in, " \t")
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				in = rest
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if out, comment, err = parseAuthorizedKey(in[i:]); err == nil {
0000000000000000000000000000000000000000;;				options = candidateOptions
0000000000000000000000000000000000000000;;				return out, comment, options, rest, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			in = rest
0000000000000000000000000000000000000000;;			continue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, "", nil, nil, errors.New("ssh: no key found")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePublicKey parses an SSH public key formatted for use in
0000000000000000000000000000000000000000;;	// the SSH wire protocol according to RFC 4253, section 6.6.
0000000000000000000000000000000000000000;;	func ParsePublicKey(in []byte) (out PublicKey, err error) {
0000000000000000000000000000000000000000;;		algo, in, ok := parseString(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errShortRead
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var rest []byte
0000000000000000000000000000000000000000;;		out, rest, err = parsePubKey(in, string(algo))
0000000000000000000000000000000000000000;;		if len(rest) > 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: trailing junk in public key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalAuthorizedKey serializes key for inclusion in an OpenSSH
0000000000000000000000000000000000000000;;	// authorized_keys file. The return value ends with newline.
0000000000000000000000000000000000000000;;	func MarshalAuthorizedKey(key PublicKey) []byte {
0000000000000000000000000000000000000000;;		b := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		b.WriteString(key.Type())
0000000000000000000000000000000000000000;;		b.WriteByte(' ')
0000000000000000000000000000000000000000;;		e := base64.NewEncoder(base64.StdEncoding, b)
0000000000000000000000000000000000000000;;		e.Write(key.Marshal())
0000000000000000000000000000000000000000;;		e.Close()
0000000000000000000000000000000000000000;;		b.WriteByte('\n')
0000000000000000000000000000000000000000;;		return b.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PublicKey is an abstraction of different types of public keys.
0000000000000000000000000000000000000000;;	type PublicKey interface {
0000000000000000000000000000000000000000;;		// Type returns the key's type, e.g. "ssh-rsa".
0000000000000000000000000000000000000000;;		Type() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Marshal returns the serialized key data in SSH wire format,
0000000000000000000000000000000000000000;;		// with the name prefix.
0000000000000000000000000000000000000000;;		Marshal() []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that sig is a signature on the given data using this
0000000000000000000000000000000000000000;;		// key. This function will hash the data appropriately first.
0000000000000000000000000000000000000000;;		Verify(data []byte, sig *Signature) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CryptoPublicKey, if implemented by a PublicKey,
0000000000000000000000000000000000000000;;	// returns the underlying crypto.PublicKey form of the key.
0000000000000000000000000000000000000000;;	type CryptoPublicKey interface {
0000000000000000000000000000000000000000;;		CryptoPublicKey() crypto.PublicKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Signer can create signatures that verify against a public key.
0000000000000000000000000000000000000000;;	type Signer interface {
0000000000000000000000000000000000000000;;		// PublicKey returns an associated PublicKey instance.
0000000000000000000000000000000000000000;;		PublicKey() PublicKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sign returns raw signature for the given data. This method
0000000000000000000000000000000000000000;;		// will apply the hash specified for the keytype to the data.
0000000000000000000000000000000000000000;;		Sign(rand io.Reader, data []byte) (*Signature, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rsaPublicKey rsa.PublicKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *rsaPublicKey) Type() string {
0000000000000000000000000000000000000000;;		return "ssh-rsa"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseRSA parses an RSA key according to RFC 4253, section 6.6.
0000000000000000000000000000000000000000;;	func parseRSA(in []byte) (out PublicKey, rest []byte, err error) {
0000000000000000000000000000000000000000;;		var w struct {
0000000000000000000000000000000000000000;;			E    *big.Int
0000000000000000000000000000000000000000;;			N    *big.Int
0000000000000000000000000000000000000000;;			Rest []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := Unmarshal(in, &w); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.E.BitLen() > 24 {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("ssh: exponent too large")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e := w.E.Int64()
0000000000000000000000000000000000000000;;		if e < 3 || e&1 == 0 {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("ssh: incorrect exponent")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var key rsa.PublicKey
0000000000000000000000000000000000000000;;		key.E = int(e)
0000000000000000000000000000000000000000;;		key.N = w.N
0000000000000000000000000000000000000000;;		return (*rsaPublicKey)(&key), w.Rest, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *rsaPublicKey) Marshal() []byte {
0000000000000000000000000000000000000000;;		e := new(big.Int).SetInt64(int64(r.E))
0000000000000000000000000000000000000000;;		// RSA publickey struct layout should match the struct used by
0000000000000000000000000000000000000000;;		// parseRSACert in the x/crypto/ssh/agent package.
0000000000000000000000000000000000000000;;		wirekey := struct {
0000000000000000000000000000000000000000;;			Name string
0000000000000000000000000000000000000000;;			E    *big.Int
0000000000000000000000000000000000000000;;			N    *big.Int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			KeyAlgoRSA,
0000000000000000000000000000000000000000;;			e,
0000000000000000000000000000000000000000;;			r.N,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Marshal(&wirekey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *rsaPublicKey) Verify(data []byte, sig *Signature) error {
0000000000000000000000000000000000000000;;		if sig.Format != r.Type() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: signature type %s for key type %s", sig.Format, r.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := crypto.SHA1.New()
0000000000000000000000000000000000000000;;		h.Write(data)
0000000000000000000000000000000000000000;;		digest := h.Sum(nil)
0000000000000000000000000000000000000000;;		return rsa.VerifyPKCS1v15((*rsa.PublicKey)(r), crypto.SHA1, digest, sig.Blob)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *rsaPublicKey) CryptoPublicKey() crypto.PublicKey {
0000000000000000000000000000000000000000;;		return (*rsa.PublicKey)(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dsaPublicKey dsa.PublicKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *dsaPublicKey) Type() string {
0000000000000000000000000000000000000000;;		return "ssh-dss"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseDSA parses an DSA key according to RFC 4253, section 6.6.
0000000000000000000000000000000000000000;;	func parseDSA(in []byte) (out PublicKey, rest []byte, err error) {
0000000000000000000000000000000000000000;;		var w struct {
0000000000000000000000000000000000000000;;			P, Q, G, Y *big.Int
0000000000000000000000000000000000000000;;			Rest       []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := Unmarshal(in, &w); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := &dsaPublicKey{
0000000000000000000000000000000000000000;;			Parameters: dsa.Parameters{
0000000000000000000000000000000000000000;;				P: w.P,
0000000000000000000000000000000000000000;;				Q: w.Q,
0000000000000000000000000000000000000000;;				G: w.G,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Y: w.Y,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key, w.Rest, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *dsaPublicKey) Marshal() []byte {
0000000000000000000000000000000000000000;;		// DSA publickey struct layout should match the struct used by
0000000000000000000000000000000000000000;;		// parseDSACert in the x/crypto/ssh/agent package.
0000000000000000000000000000000000000000;;		w := struct {
0000000000000000000000000000000000000000;;			Name       string
0000000000000000000000000000000000000000;;			P, Q, G, Y *big.Int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			k.Type(),
0000000000000000000000000000000000000000;;			k.P,
0000000000000000000000000000000000000000;;			k.Q,
0000000000000000000000000000000000000000;;			k.G,
0000000000000000000000000000000000000000;;			k.Y,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Marshal(&w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *dsaPublicKey) Verify(data []byte, sig *Signature) error {
0000000000000000000000000000000000000000;;		if sig.Format != k.Type() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: signature type %s for key type %s", sig.Format, k.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := crypto.SHA1.New()
0000000000000000000000000000000000000000;;		h.Write(data)
0000000000000000000000000000000000000000;;		digest := h.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Per RFC 4253, section 6.6,
0000000000000000000000000000000000000000;;		// The value for 'dss_signature_blob' is encoded as a string containing
0000000000000000000000000000000000000000;;		// r, followed by s (which are 160-bit integers, without lengths or
0000000000000000000000000000000000000000;;		// padding, unsigned, and in network byte order).
0000000000000000000000000000000000000000;;		// For DSS purposes, sig.Blob should be exactly 40 bytes in length.
0000000000000000000000000000000000000000;;		if len(sig.Blob) != 40 {
0000000000000000000000000000000000000000;;			return errors.New("ssh: DSA signature parse error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := new(big.Int).SetBytes(sig.Blob[:20])
0000000000000000000000000000000000000000;;		s := new(big.Int).SetBytes(sig.Blob[20:])
0000000000000000000000000000000000000000;;		if dsa.Verify((*dsa.PublicKey)(k), digest, r, s) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors.New("ssh: signature did not verify")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *dsaPublicKey) CryptoPublicKey() crypto.PublicKey {
0000000000000000000000000000000000000000;;		return (*dsa.PublicKey)(k)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dsaPrivateKey struct {
0000000000000000000000000000000000000000;;		*dsa.PrivateKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *dsaPrivateKey) PublicKey() PublicKey {
0000000000000000000000000000000000000000;;		return (*dsaPublicKey)(&k.PrivateKey.PublicKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *dsaPrivateKey) Sign(rand io.Reader, data []byte) (*Signature, error) {
0000000000000000000000000000000000000000;;		h := crypto.SHA1.New()
0000000000000000000000000000000000000000;;		h.Write(data)
0000000000000000000000000000000000000000;;		digest := h.Sum(nil)
0000000000000000000000000000000000000000;;		r, s, err := dsa.Sign(rand, k.PrivateKey, digest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sig := make([]byte, 40)
0000000000000000000000000000000000000000;;		rb := r.Bytes()
0000000000000000000000000000000000000000;;		sb := s.Bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(sig[20-len(rb):20], rb)
0000000000000000000000000000000000000000;;		copy(sig[40-len(sb):], sb)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Signature{
0000000000000000000000000000000000000000;;			Format: k.PublicKey().Type(),
0000000000000000000000000000000000000000;;			Blob:   sig,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ecdsaPublicKey ecdsa.PublicKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key *ecdsaPublicKey) Type() string {
0000000000000000000000000000000000000000;;		return "ecdsa-sha2-" + key.nistID()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key *ecdsaPublicKey) nistID() string {
0000000000000000000000000000000000000000;;		switch key.Params().BitSize {
0000000000000000000000000000000000000000;;		case 256:
0000000000000000000000000000000000000000;;			return "nistp256"
0000000000000000000000000000000000000000;;		case 384:
0000000000000000000000000000000000000000;;			return "nistp384"
0000000000000000000000000000000000000000;;		case 521:
0000000000000000000000000000000000000000;;			return "nistp521"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("ssh: unsupported ecdsa key size")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ed25519PublicKey ed25519.PublicKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key ed25519PublicKey) Type() string {
0000000000000000000000000000000000000000;;		return KeyAlgoED25519
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseED25519(in []byte) (out PublicKey, rest []byte, err error) {
0000000000000000000000000000000000000000;;		var w struct {
0000000000000000000000000000000000000000;;			KeyBytes []byte
0000000000000000000000000000000000000000;;			Rest     []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := Unmarshal(in, &w); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := ed25519.PublicKey(w.KeyBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return (ed25519PublicKey)(key), w.Rest, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key ed25519PublicKey) Marshal() []byte {
0000000000000000000000000000000000000000;;		w := struct {
0000000000000000000000000000000000000000;;			Name     string
0000000000000000000000000000000000000000;;			KeyBytes []byte
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			KeyAlgoED25519,
0000000000000000000000000000000000000000;;			[]byte(key),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Marshal(&w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key ed25519PublicKey) Verify(b []byte, sig *Signature) error {
0000000000000000000000000000000000000000;;		if sig.Format != key.Type() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: signature type %s for key type %s", sig.Format, key.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		edKey := (ed25519.PublicKey)(key)
0000000000000000000000000000000000000000;;		if ok := ed25519.Verify(edKey, b, sig.Blob); !ok {
0000000000000000000000000000000000000000;;			return errors.New("ssh: signature did not verify")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k ed25519PublicKey) CryptoPublicKey() crypto.PublicKey {
0000000000000000000000000000000000000000;;		return ed25519.PublicKey(k)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func supportedEllipticCurve(curve elliptic.Curve) bool {
0000000000000000000000000000000000000000;;		return curve == elliptic.P256() || curve == elliptic.P384() || curve == elliptic.P521()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ecHash returns the hash to match the given elliptic curve, see RFC
0000000000000000000000000000000000000000;;	// 5656, section 6.2.1
0000000000000000000000000000000000000000;;	func ecHash(curve elliptic.Curve) crypto.Hash {
0000000000000000000000000000000000000000;;		bitSize := curve.Params().BitSize
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case bitSize <= 256:
0000000000000000000000000000000000000000;;			return crypto.SHA256
0000000000000000000000000000000000000000;;		case bitSize <= 384:
0000000000000000000000000000000000000000;;			return crypto.SHA384
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return crypto.SHA512
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseECDSA parses an ECDSA key according to RFC 5656, section 3.1.
0000000000000000000000000000000000000000;;	func parseECDSA(in []byte) (out PublicKey, rest []byte, err error) {
0000000000000000000000000000000000000000;;		var w struct {
0000000000000000000000000000000000000000;;			Curve    string
0000000000000000000000000000000000000000;;			KeyBytes []byte
0000000000000000000000000000000000000000;;			Rest     []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := Unmarshal(in, &w); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := new(ecdsa.PublicKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch w.Curve {
0000000000000000000000000000000000000000;;		case "nistp256":
0000000000000000000000000000000000000000;;			key.Curve = elliptic.P256()
0000000000000000000000000000000000000000;;		case "nistp384":
0000000000000000000000000000000000000000;;			key.Curve = elliptic.P384()
0000000000000000000000000000000000000000;;		case "nistp521":
0000000000000000000000000000000000000000;;			key.Curve = elliptic.P521()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("ssh: unsupported curve")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key.X, key.Y = elliptic.Unmarshal(key.Curve, w.KeyBytes)
0000000000000000000000000000000000000000;;		if key.X == nil || key.Y == nil {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("ssh: invalid curve point")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (*ecdsaPublicKey)(key), w.Rest, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key *ecdsaPublicKey) Marshal() []byte {
0000000000000000000000000000000000000000;;		// See RFC 5656, section 3.1.
0000000000000000000000000000000000000000;;		keyBytes := elliptic.Marshal(key.Curve, key.X, key.Y)
0000000000000000000000000000000000000000;;		// ECDSA publickey struct layout should match the struct used by
0000000000000000000000000000000000000000;;		// parseECDSACert in the x/crypto/ssh/agent package.
0000000000000000000000000000000000000000;;		w := struct {
0000000000000000000000000000000000000000;;			Name string
0000000000000000000000000000000000000000;;			ID   string
0000000000000000000000000000000000000000;;			Key  []byte
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			key.Type(),
0000000000000000000000000000000000000000;;			key.nistID(),
0000000000000000000000000000000000000000;;			keyBytes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Marshal(&w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key *ecdsaPublicKey) Verify(data []byte, sig *Signature) error {
0000000000000000000000000000000000000000;;		if sig.Format != key.Type() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ssh: signature type %s for key type %s", sig.Format, key.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := ecHash(key.Curve).New()
0000000000000000000000000000000000000000;;		h.Write(data)
0000000000000000000000000000000000000000;;		digest := h.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Per RFC 5656, section 3.1.2,
0000000000000000000000000000000000000000;;		// The ecdsa_signature_blob value has the following specific encoding:
0000000000000000000000000000000000000000;;		//    mpint    r
0000000000000000000000000000000000000000;;		//    mpint    s
0000000000000000000000000000000000000000;;		var ecSig struct {
0000000000000000000000000000000000000000;;			R *big.Int
0000000000000000000000000000000000000000;;			S *big.Int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := Unmarshal(sig.Blob, &ecSig); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ecdsa.Verify((*ecdsa.PublicKey)(key), digest, ecSig.R, ecSig.S) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors.New("ssh: signature did not verify")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *ecdsaPublicKey) CryptoPublicKey() crypto.PublicKey {
0000000000000000000000000000000000000000;;		return (*ecdsa.PublicKey)(k)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSignerFromKey takes an *rsa.PrivateKey, *dsa.PrivateKey,
0000000000000000000000000000000000000000;;	// *ecdsa.PrivateKey or any other crypto.Signer and returns a corresponding
0000000000000000000000000000000000000000;;	// Signer instance. ECDSA keys must use P-256, P-384 or P-521.
0000000000000000000000000000000000000000;;	func NewSignerFromKey(key interface{}) (Signer, error) {
0000000000000000000000000000000000000000;;		switch key := key.(type) {
0000000000000000000000000000000000000000;;		case crypto.Signer:
0000000000000000000000000000000000000000;;			return NewSignerFromSigner(key)
0000000000000000000000000000000000000000;;		case *dsa.PrivateKey:
0000000000000000000000000000000000000000;;			return &dsaPrivateKey{key}, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ssh: unsupported key type %T", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type wrappedSigner struct {
0000000000000000000000000000000000000000;;		signer crypto.Signer
0000000000000000000000000000000000000000;;		pubKey PublicKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSignerFromSigner takes any crypto.Signer implementation and
0000000000000000000000000000000000000000;;	// returns a corresponding Signer interface. This can be used, for
0000000000000000000000000000000000000000;;	// example, with keys kept in hardware modules.
0000000000000000000000000000000000000000;;	func NewSignerFromSigner(signer crypto.Signer) (Signer, error) {
0000000000000000000000000000000000000000;;		pubKey, err := NewPublicKey(signer.Public())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &wrappedSigner{signer, pubKey}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *wrappedSigner) PublicKey() PublicKey {
0000000000000000000000000000000000000000;;		return s.pubKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *wrappedSigner) Sign(rand io.Reader, data []byte) (*Signature, error) {
0000000000000000000000000000000000000000;;		var hashFunc crypto.Hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch key := s.pubKey.(type) {
0000000000000000000000000000000000000000;;		case *rsaPublicKey, *dsaPublicKey:
0000000000000000000000000000000000000000;;			hashFunc = crypto.SHA1
0000000000000000000000000000000000000000;;		case *ecdsaPublicKey:
0000000000000000000000000000000000000000;;			hashFunc = ecHash(key.Curve)
0000000000000000000000000000000000000000;;		case ed25519PublicKey:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ssh: unsupported key type %T", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var digest []byte
0000000000000000000000000000000000000000;;		if hashFunc != 0 {
0000000000000000000000000000000000000000;;			h := hashFunc.New()
0000000000000000000000000000000000000000;;			h.Write(data)
0000000000000000000000000000000000000000;;			digest = h.Sum(nil)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			digest = data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signature, err := s.signer.Sign(rand, digest, hashFunc)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// crypto.Signer.Sign is expected to return an ASN.1-encoded signature
0000000000000000000000000000000000000000;;		// for ECDSA and DSA, but that's not the encoding expected by SSH, so
0000000000000000000000000000000000000000;;		// re-encode.
0000000000000000000000000000000000000000;;		switch s.pubKey.(type) {
0000000000000000000000000000000000000000;;		case *ecdsaPublicKey, *dsaPublicKey:
0000000000000000000000000000000000000000;;			type asn1Signature struct {
0000000000000000000000000000000000000000;;				R, S *big.Int
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			asn1Sig := new(asn1Signature)
0000000000000000000000000000000000000000;;			_, err := asn1.Unmarshal(signature, asn1Sig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch s.pubKey.(type) {
0000000000000000000000000000000000000000;;			case *ecdsaPublicKey:
0000000000000000000000000000000000000000;;				signature = Marshal(asn1Sig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case *dsaPublicKey:
0000000000000000000000000000000000000000;;				signature = make([]byte, 40)
0000000000000000000000000000000000000000;;				r := asn1Sig.R.Bytes()
0000000000000000000000000000000000000000;;				s := asn1Sig.S.Bytes()
0000000000000000000000000000000000000000;;				copy(signature[20-len(r):20], r)
0000000000000000000000000000000000000000;;				copy(signature[40-len(s):40], s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Signature{
0000000000000000000000000000000000000000;;			Format: s.pubKey.Type(),
0000000000000000000000000000000000000000;;			Blob:   signature,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPublicKey takes an *rsa.PublicKey, *dsa.PublicKey, *ecdsa.PublicKey,
0000000000000000000000000000000000000000;;	// ed25519.PublicKey, or any other crypto.Signer and returns a corresponding
0000000000000000000000000000000000000000;;	// Signer instance. ECDSA keys must use P-256, P-384 or P-521.
0000000000000000000000000000000000000000;;	func NewPublicKey(key interface{}) (PublicKey, error) {
0000000000000000000000000000000000000000;;		switch key := key.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			return (*rsaPublicKey)(key), nil
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			if !supportedEllipticCurve(key.Curve) {
0000000000000000000000000000000000000000;;				return nil, errors.New("ssh: only P-256, P-384 and P-521 EC keys are supported.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return (*ecdsaPublicKey)(key), nil
0000000000000000000000000000000000000000;;		case *dsa.PublicKey:
0000000000000000000000000000000000000000;;			return (*dsaPublicKey)(key), nil
0000000000000000000000000000000000000000;;		case ed25519.PublicKey:
0000000000000000000000000000000000000000;;			return (ed25519PublicKey)(key), nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ssh: unsupported key type %T", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePrivateKey returns a Signer from a PEM encoded private key. It supports
0000000000000000000000000000000000000000;;	// the same keys as ParseRawPrivateKey.
0000000000000000000000000000000000000000;;	func ParsePrivateKey(pemBytes []byte) (Signer, error) {
0000000000000000000000000000000000000000;;		key, err := ParseRawPrivateKey(pemBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewSignerFromKey(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encryptedBlock tells whether a private key is
0000000000000000000000000000000000000000;;	// encrypted by examining its Proc-Type header
0000000000000000000000000000000000000000;;	// for a mention of ENCRYPTED
0000000000000000000000000000000000000000;;	// according to RFC 1421 Section 4.6.1.1.
0000000000000000000000000000000000000000;;	func encryptedBlock(block *pem.Block) bool {
0000000000000000000000000000000000000000;;		return strings.Contains(block.Headers["Proc-Type"], "ENCRYPTED")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseRawPrivateKey returns a private key from a PEM encoded private key. It
0000000000000000000000000000000000000000;;	// supports RSA (PKCS#1), DSA (OpenSSL), and ECDSA private keys.
0000000000000000000000000000000000000000;;	func ParseRawPrivateKey(pemBytes []byte) (interface{}, error) {
0000000000000000000000000000000000000000;;		block, _ := pem.Decode(pemBytes)
0000000000000000000000000000000000000000;;		if block == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: no key found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if encryptedBlock(block) {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: cannot decode encrypted private keys")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch block.Type {
0000000000000000000000000000000000000000;;		case "RSA PRIVATE KEY":
0000000000000000000000000000000000000000;;			return x509.ParsePKCS1PrivateKey(block.Bytes)
0000000000000000000000000000000000000000;;		case "EC PRIVATE KEY":
0000000000000000000000000000000000000000;;			return x509.ParseECPrivateKey(block.Bytes)
0000000000000000000000000000000000000000;;		case "DSA PRIVATE KEY":
0000000000000000000000000000000000000000;;			return ParseDSAPrivateKey(block.Bytes)
0000000000000000000000000000000000000000;;		case "OPENSSH PRIVATE KEY":
0000000000000000000000000000000000000000;;			return parseOpenSSHPrivateKey(block.Bytes)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ssh: unsupported key type %q", block.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseDSAPrivateKey returns a DSA private key from its ASN.1 DER encoding, as
0000000000000000000000000000000000000000;;	// specified by the OpenSSL DSA man page.
0000000000000000000000000000000000000000;;	func ParseDSAPrivateKey(der []byte) (*dsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		var k struct {
0000000000000000000000000000000000000000;;			Version int
0000000000000000000000000000000000000000;;			P       *big.Int
0000000000000000000000000000000000000000;;			Q       *big.Int
0000000000000000000000000000000000000000;;			G       *big.Int
0000000000000000000000000000000000000000;;			Priv    *big.Int
0000000000000000000000000000000000000000;;			Pub     *big.Int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rest, err := asn1.Unmarshal(der, &k)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: failed to parse DSA key: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rest) > 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: garbage after DSA key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &dsa.PrivateKey{
0000000000000000000000000000000000000000;;			PublicKey: dsa.PublicKey{
0000000000000000000000000000000000000000;;				Parameters: dsa.Parameters{
0000000000000000000000000000000000000000;;					P: k.P,
0000000000000000000000000000000000000000;;					Q: k.Q,
0000000000000000000000000000000000000000;;					G: k.G,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Y: k.Priv,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			X: k.Pub,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implemented based on the documentation at
0000000000000000000000000000000000000000;;	// https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key
0000000000000000000000000000000000000000;;	func parseOpenSSHPrivateKey(key []byte) (*ed25519.PrivateKey, error) {
0000000000000000000000000000000000000000;;		magic := append([]byte("openssh-key-v1"), 0)
0000000000000000000000000000000000000000;;		if !bytes.Equal(magic, key[0:len(magic)]) {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: invalid openssh private key format")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		remaining := key[len(magic):]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var w struct {
0000000000000000000000000000000000000000;;			CipherName   string
0000000000000000000000000000000000000000;;			KdfName      string
0000000000000000000000000000000000000000;;			KdfOpts      string
0000000000000000000000000000000000000000;;			NumKeys      uint32
0000000000000000000000000000000000000000;;			PubKey       []byte
0000000000000000000000000000000000000000;;			PrivKeyBlock []byte
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := Unmarshal(remaining, &w); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pk1 := struct {
0000000000000000000000000000000000000000;;			Check1  uint32
0000000000000000000000000000000000000000;;			Check2  uint32
0000000000000000000000000000000000000000;;			Keytype string
0000000000000000000000000000000000000000;;			Pub     []byte
0000000000000000000000000000000000000000;;			Priv    []byte
0000000000000000000000000000000000000000;;			Comment string
0000000000000000000000000000000000000000;;			Pad     []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;		}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := Unmarshal(w.PrivKeyBlock, &pk1); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pk1.Check1 != pk1.Check2 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: checkint mismatch")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we only handle ed25519 keys currently
0000000000000000000000000000000000000000;;		if pk1.Keytype != KeyAlgoED25519 {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: unhandled key type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, b := range pk1.Pad {
0000000000000000000000000000000000000000;;			if int(b) != i+1 {
0000000000000000000000000000000000000000;;				return nil, errors.New("ssh: padding not as expected")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(pk1.Priv) != ed25519.PrivateKeySize {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: private key unexpected length")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pk := ed25519.PrivateKey(make([]byte, ed25519.PrivateKeySize))
0000000000000000000000000000000000000000;;		copy(pk, pk1.Priv)
0000000000000000000000000000000000000000;;		return &pk, nil
0000000000000000000000000000000000000000;;	}
