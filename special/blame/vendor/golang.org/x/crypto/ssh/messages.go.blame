0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/messages.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/messages.go][vendor/golang.org/x/crypto/ssh/messages.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are SSH message type numbers. They are scattered around several
0000000000000000000000000000000000000000;;	// documents but many were taken from [SSH-PARAMETERS].
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		msgIgnore        = 2
0000000000000000000000000000000000000000;;		msgUnimplemented = 3
0000000000000000000000000000000000000000;;		msgDebug         = 4
0000000000000000000000000000000000000000;;		msgNewKeys       = 21
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Standard authentication messages
0000000000000000000000000000000000000000;;		msgUserAuthSuccess = 52
0000000000000000000000000000000000000000;;		msgUserAuthBanner  = 53
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SSH messages:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// These structures mirror the wire format of the corresponding SSH messages.
0000000000000000000000000000000000000000;;	// They are marshaled using reflection with the marshal and unmarshal functions
0000000000000000000000000000000000000000;;	// in this file. The only wrinkle is that a final member of type []byte with a
0000000000000000000000000000000000000000;;	// ssh tag of "rest" receives the remainder of a packet when unmarshaling.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4253, section 11.1.
0000000000000000000000000000000000000000;;	const msgDisconnect = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// disconnectMsg is the message that signals a disconnect. It is also
0000000000000000000000000000000000000000;;	// the error type returned from mux.Wait()
0000000000000000000000000000000000000000;;	type disconnectMsg struct {
0000000000000000000000000000000000000000;;		Reason   uint32 `sshtype:"1"`
0000000000000000000000000000000000000000;;		Message  string
0000000000000000000000000000000000000000;;		Language string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *disconnectMsg) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("ssh: disconnect, reason %d: %s", d.Reason, d.Message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4253, section 7.1.
0000000000000000000000000000000000000000;;	const msgKexInit = 20
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type kexInitMsg struct {
0000000000000000000000000000000000000000;;		Cookie                  [16]byte `sshtype:"20"`
0000000000000000000000000000000000000000;;		KexAlgos                []string
0000000000000000000000000000000000000000;;		ServerHostKeyAlgos      []string
0000000000000000000000000000000000000000;;		CiphersClientServer     []string
0000000000000000000000000000000000000000;;		CiphersServerClient     []string
0000000000000000000000000000000000000000;;		MACsClientServer        []string
0000000000000000000000000000000000000000;;		MACsServerClient        []string
0000000000000000000000000000000000000000;;		CompressionClientServer []string
0000000000000000000000000000000000000000;;		CompressionServerClient []string
0000000000000000000000000000000000000000;;		LanguagesClientServer   []string
0000000000000000000000000000000000000000;;		LanguagesServerClient   []string
0000000000000000000000000000000000000000;;		FirstKexFollows         bool
0000000000000000000000000000000000000000;;		Reserved                uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4253, section 8.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Diffie-Helman
0000000000000000000000000000000000000000;;	const msgKexDHInit = 30
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type kexDHInitMsg struct {
0000000000000000000000000000000000000000;;		X *big.Int `sshtype:"30"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const msgKexECDHInit = 30
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type kexECDHInitMsg struct {
0000000000000000000000000000000000000000;;		ClientPubKey []byte `sshtype:"30"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const msgKexECDHReply = 31
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type kexECDHReplyMsg struct {
0000000000000000000000000000000000000000;;		HostKey         []byte `sshtype:"31"`
0000000000000000000000000000000000000000;;		EphemeralPubKey []byte
0000000000000000000000000000000000000000;;		Signature       []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const msgKexDHReply = 31
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type kexDHReplyMsg struct {
0000000000000000000000000000000000000000;;		HostKey   []byte `sshtype:"31"`
0000000000000000000000000000000000000000;;		Y         *big.Int
0000000000000000000000000000000000000000;;		Signature []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4253, section 10.
0000000000000000000000000000000000000000;;	const msgServiceRequest = 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serviceRequestMsg struct {
0000000000000000000000000000000000000000;;		Service string `sshtype:"5"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4253, section 10.
0000000000000000000000000000000000000000;;	const msgServiceAccept = 6
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serviceAcceptMsg struct {
0000000000000000000000000000000000000000;;		Service string `sshtype:"6"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4252, section 5.
0000000000000000000000000000000000000000;;	const msgUserAuthRequest = 50
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type userAuthRequestMsg struct {
0000000000000000000000000000000000000000;;		User    string `sshtype:"50"`
0000000000000000000000000000000000000000;;		Service string
0000000000000000000000000000000000000000;;		Method  string
0000000000000000000000000000000000000000;;		Payload []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used for debug printouts of packets.
0000000000000000000000000000000000000000;;	type userAuthSuccessMsg struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4252, section 5.1
0000000000000000000000000000000000000000;;	const msgUserAuthFailure = 51
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type userAuthFailureMsg struct {
0000000000000000000000000000000000000000;;		Methods        []string `sshtype:"51"`
0000000000000000000000000000000000000000;;		PartialSuccess bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4256, section 3.2
0000000000000000000000000000000000000000;;	const msgUserAuthInfoRequest = 60
0000000000000000000000000000000000000000;;	const msgUserAuthInfoResponse = 61
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type userAuthInfoRequestMsg struct {
0000000000000000000000000000000000000000;;		User               string `sshtype:"60"`
0000000000000000000000000000000000000000;;		Instruction        string
0000000000000000000000000000000000000000;;		DeprecatedLanguage string
0000000000000000000000000000000000000000;;		NumPrompts         uint32
0000000000000000000000000000000000000000;;		Prompts            []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 5.1.
0000000000000000000000000000000000000000;;	const msgChannelOpen = 90
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type channelOpenMsg struct {
0000000000000000000000000000000000000000;;		ChanType         string `sshtype:"90"`
0000000000000000000000000000000000000000;;		PeersId          uint32
0000000000000000000000000000000000000000;;		PeersWindow      uint32
0000000000000000000000000000000000000000;;		MaxPacketSize    uint32
0000000000000000000000000000000000000000;;		TypeSpecificData []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const msgChannelExtendedData = 95
0000000000000000000000000000000000000000;;	const msgChannelData = 94
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used for debug print outs of packets.
0000000000000000000000000000000000000000;;	type channelDataMsg struct {
0000000000000000000000000000000000000000;;		PeersId uint32 `sshtype:"94"`
0000000000000000000000000000000000000000;;		Length  uint32
0000000000000000000000000000000000000000;;		Rest    []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 5.1.
0000000000000000000000000000000000000000;;	const msgChannelOpenConfirm = 91
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type channelOpenConfirmMsg struct {
0000000000000000000000000000000000000000;;		PeersId          uint32 `sshtype:"91"`
0000000000000000000000000000000000000000;;		MyId             uint32
0000000000000000000000000000000000000000;;		MyWindow         uint32
0000000000000000000000000000000000000000;;		MaxPacketSize    uint32
0000000000000000000000000000000000000000;;		TypeSpecificData []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 5.1.
0000000000000000000000000000000000000000;;	const msgChannelOpenFailure = 92
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type channelOpenFailureMsg struct {
0000000000000000000000000000000000000000;;		PeersId  uint32 `sshtype:"92"`
0000000000000000000000000000000000000000;;		Reason   RejectionReason
0000000000000000000000000000000000000000;;		Message  string
0000000000000000000000000000000000000000;;		Language string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const msgChannelRequest = 98
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type channelRequestMsg struct {
0000000000000000000000000000000000000000;;		PeersId             uint32 `sshtype:"98"`
0000000000000000000000000000000000000000;;		Request             string
0000000000000000000000000000000000000000;;		WantReply           bool
0000000000000000000000000000000000000000;;		RequestSpecificData []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 5.4.
0000000000000000000000000000000000000000;;	const msgChannelSuccess = 99
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type channelRequestSuccessMsg struct {
0000000000000000000000000000000000000000;;		PeersId uint32 `sshtype:"99"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 5.4.
0000000000000000000000000000000000000000;;	const msgChannelFailure = 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type channelRequestFailureMsg struct {
0000000000000000000000000000000000000000;;		PeersId uint32 `sshtype:"100"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 5.3
0000000000000000000000000000000000000000;;	const msgChannelClose = 97
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type channelCloseMsg struct {
0000000000000000000000000000000000000000;;		PeersId uint32 `sshtype:"97"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 5.3
0000000000000000000000000000000000000000;;	const msgChannelEOF = 96
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type channelEOFMsg struct {
0000000000000000000000000000000000000000;;		PeersId uint32 `sshtype:"96"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 4
0000000000000000000000000000000000000000;;	const msgGlobalRequest = 80
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type globalRequestMsg struct {
0000000000000000000000000000000000000000;;		Type      string `sshtype:"80"`
0000000000000000000000000000000000000000;;		WantReply bool
0000000000000000000000000000000000000000;;		Data      []byte `ssh:"rest"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 4
0000000000000000000000000000000000000000;;	const msgRequestSuccess = 81
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type globalRequestSuccessMsg struct {
0000000000000000000000000000000000000000;;		Data []byte `ssh:"rest" sshtype:"81"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 4
0000000000000000000000000000000000000000;;	const msgRequestFailure = 82
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type globalRequestFailureMsg struct {
0000000000000000000000000000000000000000;;		Data []byte `ssh:"rest" sshtype:"82"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4254, section 5.2
0000000000000000000000000000000000000000;;	const msgChannelWindowAdjust = 93
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type windowAdjustMsg struct {
0000000000000000000000000000000000000000;;		PeersId         uint32 `sshtype:"93"`
0000000000000000000000000000000000000000;;		AdditionalBytes uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See RFC 4252, section 7
0000000000000000000000000000000000000000;;	const msgUserAuthPubKeyOk = 60
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type userAuthPubKeyOkMsg struct {
0000000000000000000000000000000000000000;;		Algo   string `sshtype:"60"`
0000000000000000000000000000000000000000;;		PubKey []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// typeTags returns the possible type bytes for the given reflect.Type, which
0000000000000000000000000000000000000000;;	// should be a struct. The possible values are separated by a '|' character.
0000000000000000000000000000000000000000;;	func typeTags(structType reflect.Type) (tags []byte) {
0000000000000000000000000000000000000000;;		tagStr := structType.Field(0).Tag.Get("sshtype")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tag := range strings.Split(tagStr, "|") {
0000000000000000000000000000000000000000;;			i, err := strconv.Atoi(tag)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				tags = append(tags, byte(i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fieldError(t reflect.Type, field int, problem string) error {
0000000000000000000000000000000000000000;;		if problem != "" {
0000000000000000000000000000000000000000;;			problem = ": " + problem
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("ssh: unmarshal error for field %s of type %s%s", t.Field(field).Name, t.Name(), problem)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errShortRead = errors.New("ssh: short read")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal parses data in SSH wire format into a structure. The out
0000000000000000000000000000000000000000;;	// argument should be a pointer to struct. If the first member of the
0000000000000000000000000000000000000000;;	// struct has the "sshtype" tag set to a '|'-separated set of numbers
0000000000000000000000000000000000000000;;	// in decimal, the packet must start with one of those numbers. In
0000000000000000000000000000000000000000;;	// case of error, Unmarshal returns a ParseError or
0000000000000000000000000000000000000000;;	// UnexpectedMessageError.
0000000000000000000000000000000000000000;;	func Unmarshal(data []byte, out interface{}) error {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(out).Elem()
0000000000000000000000000000000000000000;;		structType := v.Type()
0000000000000000000000000000000000000000;;		expectedTypes := typeTags(structType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var expectedType byte
0000000000000000000000000000000000000000;;		if len(expectedTypes) > 0 {
0000000000000000000000000000000000000000;;			expectedType = expectedTypes[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data) == 0 {
0000000000000000000000000000000000000000;;			return parseError(expectedType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(expectedTypes) > 0 {
0000000000000000000000000000000000000000;;			goodType := false
0000000000000000000000000000000000000000;;			for _, e := range expectedTypes {
0000000000000000000000000000000000000000;;				if e > 0 && data[0] == e {
0000000000000000000000000000000000000000;;					goodType = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !goodType {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ssh: unexpected message type %d (expected one of %v)", data[0], expectedTypes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data = data[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		for i := 0; i < v.NumField(); i++ {
0000000000000000000000000000000000000000;;			field := v.Field(i)
0000000000000000000000000000000000000000;;			t := field.Type()
0000000000000000000000000000000000000000;;			switch t.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Bool:
0000000000000000000000000000000000000000;;				if len(data) < 1 {
0000000000000000000000000000000000000000;;					return errShortRead
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				field.SetBool(data[0] != 0)
0000000000000000000000000000000000000000;;				data = data[1:]
0000000000000000000000000000000000000000;;			case reflect.Array:
0000000000000000000000000000000000000000;;				if t.Elem().Kind() != reflect.Uint8 {
0000000000000000000000000000000000000000;;					return fieldError(structType, i, "array of unsupported type")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(data) < t.Len() {
0000000000000000000000000000000000000000;;					return errShortRead
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for j, n := 0, t.Len(); j < n; j++ {
0000000000000000000000000000000000000000;;					field.Index(j).Set(reflect.ValueOf(data[j]))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				data = data[t.Len():]
0000000000000000000000000000000000000000;;			case reflect.Uint64:
0000000000000000000000000000000000000000;;				var u64 uint64
0000000000000000000000000000000000000000;;				if u64, data, ok = parseUint64(data); !ok {
0000000000000000000000000000000000000000;;					return errShortRead
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				field.SetUint(u64)
0000000000000000000000000000000000000000;;			case reflect.Uint32:
0000000000000000000000000000000000000000;;				var u32 uint32
0000000000000000000000000000000000000000;;				if u32, data, ok = parseUint32(data); !ok {
0000000000000000000000000000000000000000;;					return errShortRead
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				field.SetUint(uint64(u32))
0000000000000000000000000000000000000000;;			case reflect.Uint8:
0000000000000000000000000000000000000000;;				if len(data) < 1 {
0000000000000000000000000000000000000000;;					return errShortRead
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				field.SetUint(uint64(data[0]))
0000000000000000000000000000000000000000;;				data = data[1:]
0000000000000000000000000000000000000000;;			case reflect.String:
0000000000000000000000000000000000000000;;				var s []byte
0000000000000000000000000000000000000000;;				if s, data, ok = parseString(data); !ok {
0000000000000000000000000000000000000000;;					return fieldError(structType, i, "")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				field.SetString(string(s))
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				switch t.Elem().Kind() {
0000000000000000000000000000000000000000;;				case reflect.Uint8:
0000000000000000000000000000000000000000;;					if structType.Field(i).Tag.Get("ssh") == "rest" {
0000000000000000000000000000000000000000;;						field.Set(reflect.ValueOf(data))
0000000000000000000000000000000000000000;;						data = nil
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						var s []byte
0000000000000000000000000000000000000000;;						if s, data, ok = parseString(data); !ok {
0000000000000000000000000000000000000000;;							return errShortRead
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						field.Set(reflect.ValueOf(s))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case reflect.String:
0000000000000000000000000000000000000000;;					var nl []string
0000000000000000000000000000000000000000;;					if nl, data, ok = parseNameList(data); !ok {
0000000000000000000000000000000000000000;;						return errShortRead
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					field.Set(reflect.ValueOf(nl))
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return fieldError(structType, i, "slice of unsupported type")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Ptr:
0000000000000000000000000000000000000000;;				if t == bigIntType {
0000000000000000000000000000000000000000;;					var n *big.Int
0000000000000000000000000000000000000000;;					if n, data, ok = parseInt(data); !ok {
0000000000000000000000000000000000000000;;						return errShortRead
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					field.Set(reflect.ValueOf(n))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return fieldError(structType, i, "pointer to unsupported type")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return fieldError(structType, i, fmt.Sprintf("unsupported type: %v", t))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data) != 0 {
0000000000000000000000000000000000000000;;			return parseError(expectedType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal serializes the message in msg to SSH wire format.  The msg
0000000000000000000000000000000000000000;;	// argument should be a struct or pointer to struct. If the first
0000000000000000000000000000000000000000;;	// member has the "sshtype" tag set to a number in decimal, that
0000000000000000000000000000000000000000;;	// number is prepended to the result. If the last of member has the
0000000000000000000000000000000000000000;;	// "ssh" tag set to "rest", its contents are appended to the output.
0000000000000000000000000000000000000000;;	func Marshal(msg interface{}) []byte {
0000000000000000000000000000000000000000;;		out := make([]byte, 0, 64)
0000000000000000000000000000000000000000;;		return marshalStruct(out, msg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshalStruct(out []byte, msg interface{}) []byte {
0000000000000000000000000000000000000000;;		v := reflect.Indirect(reflect.ValueOf(msg))
0000000000000000000000000000000000000000;;		msgTypes := typeTags(v.Type())
0000000000000000000000000000000000000000;;		if len(msgTypes) > 0 {
0000000000000000000000000000000000000000;;			out = append(out, msgTypes[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, n := 0, v.NumField(); i < n; i++ {
0000000000000000000000000000000000000000;;			field := v.Field(i)
0000000000000000000000000000000000000000;;			switch t := field.Type(); t.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Bool:
0000000000000000000000000000000000000000;;				var v uint8
0000000000000000000000000000000000000000;;				if field.Bool() {
0000000000000000000000000000000000000000;;					v = 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out = append(out, v)
0000000000000000000000000000000000000000;;			case reflect.Array:
0000000000000000000000000000000000000000;;				if t.Elem().Kind() != reflect.Uint8 {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("array of non-uint8 in field %d: %T", i, field.Interface()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for j, l := 0, t.Len(); j < l; j++ {
0000000000000000000000000000000000000000;;					out = append(out, uint8(field.Index(j).Uint()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Uint32:
0000000000000000000000000000000000000000;;				out = appendU32(out, uint32(field.Uint()))
0000000000000000000000000000000000000000;;			case reflect.Uint64:
0000000000000000000000000000000000000000;;				out = appendU64(out, uint64(field.Uint()))
0000000000000000000000000000000000000000;;			case reflect.Uint8:
0000000000000000000000000000000000000000;;				out = append(out, uint8(field.Uint()))
0000000000000000000000000000000000000000;;			case reflect.String:
0000000000000000000000000000000000000000;;				s := field.String()
0000000000000000000000000000000000000000;;				out = appendInt(out, len(s))
0000000000000000000000000000000000000000;;				out = append(out, s...)
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				switch t.Elem().Kind() {
0000000000000000000000000000000000000000;;				case reflect.Uint8:
0000000000000000000000000000000000000000;;					if v.Type().Field(i).Tag.Get("ssh") != "rest" {
0000000000000000000000000000000000000000;;						out = appendInt(out, field.Len())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					out = append(out, field.Bytes()...)
0000000000000000000000000000000000000000;;				case reflect.String:
0000000000000000000000000000000000000000;;					offset := len(out)
0000000000000000000000000000000000000000;;					out = appendU32(out, 0)
0000000000000000000000000000000000000000;;					if n := field.Len(); n > 0 {
0000000000000000000000000000000000000000;;						for j := 0; j < n; j++ {
0000000000000000000000000000000000000000;;							f := field.Index(j)
0000000000000000000000000000000000000000;;							if j != 0 {
0000000000000000000000000000000000000000;;								out = append(out, ',')
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							out = append(out, f.String()...)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// overwrite length value
0000000000000000000000000000000000000000;;						binary.BigEndian.PutUint32(out[offset:], uint32(len(out)-offset-4))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("slice of unknown type in field %d: %T", i, field.Interface()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Ptr:
0000000000000000000000000000000000000000;;				if t == bigIntType {
0000000000000000000000000000000000000000;;					var n *big.Int
0000000000000000000000000000000000000000;;					nValue := reflect.ValueOf(&n)
0000000000000000000000000000000000000000;;					nValue.Elem().Set(field)
0000000000000000000000000000000000000000;;					needed := intLength(n)
0000000000000000000000000000000000000000;;					oldLength := len(out)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if cap(out)-len(out) < needed {
0000000000000000000000000000000000000000;;						newOut := make([]byte, len(out), 2*(len(out)+needed))
0000000000000000000000000000000000000000;;						copy(newOut, out)
0000000000000000000000000000000000000000;;						out = newOut
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					out = out[:oldLength+needed]
0000000000000000000000000000000000000000;;					marshalInt(out[oldLength:], n)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("pointer to unknown type in field %d: %T", i, field.Interface()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bigOne = big.NewInt(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseString(in []byte) (out, rest []byte, ok bool) {
0000000000000000000000000000000000000000;;		if len(in) < 4 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		length := binary.BigEndian.Uint32(in)
0000000000000000000000000000000000000000;;		in = in[4:]
0000000000000000000000000000000000000000;;		if uint32(len(in)) < length {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out = in[:length]
0000000000000000000000000000000000000000;;		rest = in[length:]
0000000000000000000000000000000000000000;;		ok = true
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		comma         = []byte{','}
0000000000000000000000000000000000000000;;		emptyNameList = []string{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseNameList(in []byte) (out []string, rest []byte, ok bool) {
0000000000000000000000000000000000000000;;		contents, rest, ok := parseString(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(contents) == 0 {
0000000000000000000000000000000000000000;;			out = emptyNameList
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := bytes.Split(contents, comma)
0000000000000000000000000000000000000000;;		out = make([]string, len(parts))
0000000000000000000000000000000000000000;;		for i, part := range parts {
0000000000000000000000000000000000000000;;			out[i] = string(part)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseInt(in []byte) (out *big.Int, rest []byte, ok bool) {
0000000000000000000000000000000000000000;;		contents, rest, ok := parseString(in)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out = new(big.Int)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(contents) > 0 && contents[0]&0x80 == 0x80 {
0000000000000000000000000000000000000000;;			// This is a negative number
0000000000000000000000000000000000000000;;			notBytes := make([]byte, len(contents))
0000000000000000000000000000000000000000;;			for i := range notBytes {
0000000000000000000000000000000000000000;;				notBytes[i] = ^contents[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.SetBytes(notBytes)
0000000000000000000000000000000000000000;;			out.Add(out, bigOne)
0000000000000000000000000000000000000000;;			out.Neg(out)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Positive number
0000000000000000000000000000000000000000;;			out.SetBytes(contents)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ok = true
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseUint32(in []byte) (uint32, []byte, bool) {
0000000000000000000000000000000000000000;;		if len(in) < 4 {
0000000000000000000000000000000000000000;;			return 0, nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return binary.BigEndian.Uint32(in), in[4:], true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseUint64(in []byte) (uint64, []byte, bool) {
0000000000000000000000000000000000000000;;		if len(in) < 8 {
0000000000000000000000000000000000000000;;			return 0, nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return binary.BigEndian.Uint64(in), in[8:], true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func intLength(n *big.Int) int {
0000000000000000000000000000000000000000;;		length := 4 /* length bytes */
0000000000000000000000000000000000000000;;		if n.Sign() < 0 {
0000000000000000000000000000000000000000;;			nMinus1 := new(big.Int).Neg(n)
0000000000000000000000000000000000000000;;			nMinus1.Sub(nMinus1, bigOne)
0000000000000000000000000000000000000000;;			bitLen := nMinus1.BitLen()
0000000000000000000000000000000000000000;;			if bitLen%8 == 0 {
0000000000000000000000000000000000000000;;				// The number will need 0xff padding
0000000000000000000000000000000000000000;;				length++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			length += (bitLen + 7) / 8
0000000000000000000000000000000000000000;;		} else if n.Sign() == 0 {
0000000000000000000000000000000000000000;;			// A zero is the zero length string
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			bitLen := n.BitLen()
0000000000000000000000000000000000000000;;			if bitLen%8 == 0 {
0000000000000000000000000000000000000000;;				// The number will need 0x00 padding
0000000000000000000000000000000000000000;;				length++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			length += (bitLen + 7) / 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return length
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshalUint32(to []byte, n uint32) []byte {
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(to, n)
0000000000000000000000000000000000000000;;		return to[4:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshalUint64(to []byte, n uint64) []byte {
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(to, n)
0000000000000000000000000000000000000000;;		return to[8:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshalInt(to []byte, n *big.Int) []byte {
0000000000000000000000000000000000000000;;		lengthBytes := to
0000000000000000000000000000000000000000;;		to = to[4:]
0000000000000000000000000000000000000000;;		length := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n.Sign() < 0 {
0000000000000000000000000000000000000000;;			// A negative number has to be converted to two's-complement
0000000000000000000000000000000000000000;;			// form. So we'll subtract 1 and invert. If the
0000000000000000000000000000000000000000;;			// most-significant-bit isn't set then we'll need to pad the
0000000000000000000000000000000000000000;;			// beginning with 0xff in order to keep the number negative.
0000000000000000000000000000000000000000;;			nMinus1 := new(big.Int).Neg(n)
0000000000000000000000000000000000000000;;			nMinus1.Sub(nMinus1, bigOne)
0000000000000000000000000000000000000000;;			bytes := nMinus1.Bytes()
0000000000000000000000000000000000000000;;			for i := range bytes {
0000000000000000000000000000000000000000;;				bytes[i] ^= 0xff
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(bytes) == 0 || bytes[0]&0x80 == 0 {
0000000000000000000000000000000000000000;;				to[0] = 0xff
0000000000000000000000000000000000000000;;				to = to[1:]
0000000000000000000000000000000000000000;;				length++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nBytes := copy(to, bytes)
0000000000000000000000000000000000000000;;			to = to[nBytes:]
0000000000000000000000000000000000000000;;			length += nBytes
0000000000000000000000000000000000000000;;		} else if n.Sign() == 0 {
0000000000000000000000000000000000000000;;			// A zero is the zero length string
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			bytes := n.Bytes()
0000000000000000000000000000000000000000;;			if len(bytes) > 0 && bytes[0]&0x80 != 0 {
0000000000000000000000000000000000000000;;				// We'll have to pad this with a 0x00 in order to
0000000000000000000000000000000000000000;;				// stop it looking like a negative number.
0000000000000000000000000000000000000000;;				to[0] = 0
0000000000000000000000000000000000000000;;				to = to[1:]
0000000000000000000000000000000000000000;;				length++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nBytes := copy(to, bytes)
0000000000000000000000000000000000000000;;			to = to[nBytes:]
0000000000000000000000000000000000000000;;			length += nBytes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lengthBytes[0] = byte(length >> 24)
0000000000000000000000000000000000000000;;		lengthBytes[1] = byte(length >> 16)
0000000000000000000000000000000000000000;;		lengthBytes[2] = byte(length >> 8)
0000000000000000000000000000000000000000;;		lengthBytes[3] = byte(length)
0000000000000000000000000000000000000000;;		return to
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeInt(w io.Writer, n *big.Int) {
0000000000000000000000000000000000000000;;		length := intLength(n)
0000000000000000000000000000000000000000;;		buf := make([]byte, length)
0000000000000000000000000000000000000000;;		marshalInt(buf, n)
0000000000000000000000000000000000000000;;		w.Write(buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeString(w io.Writer, s []byte) {
0000000000000000000000000000000000000000;;		var lengthBytes [4]byte
0000000000000000000000000000000000000000;;		lengthBytes[0] = byte(len(s) >> 24)
0000000000000000000000000000000000000000;;		lengthBytes[1] = byte(len(s) >> 16)
0000000000000000000000000000000000000000;;		lengthBytes[2] = byte(len(s) >> 8)
0000000000000000000000000000000000000000;;		lengthBytes[3] = byte(len(s))
0000000000000000000000000000000000000000;;		w.Write(lengthBytes[:])
0000000000000000000000000000000000000000;;		w.Write(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stringLength(n int) int {
0000000000000000000000000000000000000000;;		return 4 + n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshalString(to []byte, s []byte) []byte {
0000000000000000000000000000000000000000;;		to[0] = byte(len(s) >> 24)
0000000000000000000000000000000000000000;;		to[1] = byte(len(s) >> 16)
0000000000000000000000000000000000000000;;		to[2] = byte(len(s) >> 8)
0000000000000000000000000000000000000000;;		to[3] = byte(len(s))
0000000000000000000000000000000000000000;;		to = to[4:]
0000000000000000000000000000000000000000;;		copy(to, s)
0000000000000000000000000000000000000000;;		return to[len(s):]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bigIntType = reflect.TypeOf((*big.Int)(nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a packet into its corresponding message.
0000000000000000000000000000000000000000;;	func decode(packet []byte) (interface{}, error) {
0000000000000000000000000000000000000000;;		var msg interface{}
0000000000000000000000000000000000000000;;		switch packet[0] {
0000000000000000000000000000000000000000;;		case msgDisconnect:
0000000000000000000000000000000000000000;;			msg = new(disconnectMsg)
0000000000000000000000000000000000000000;;		case msgServiceRequest:
0000000000000000000000000000000000000000;;			msg = new(serviceRequestMsg)
0000000000000000000000000000000000000000;;		case msgServiceAccept:
0000000000000000000000000000000000000000;;			msg = new(serviceAcceptMsg)
0000000000000000000000000000000000000000;;		case msgKexInit:
0000000000000000000000000000000000000000;;			msg = new(kexInitMsg)
0000000000000000000000000000000000000000;;		case msgKexDHInit:
0000000000000000000000000000000000000000;;			msg = new(kexDHInitMsg)
0000000000000000000000000000000000000000;;		case msgKexDHReply:
0000000000000000000000000000000000000000;;			msg = new(kexDHReplyMsg)
0000000000000000000000000000000000000000;;		case msgUserAuthRequest:
0000000000000000000000000000000000000000;;			msg = new(userAuthRequestMsg)
0000000000000000000000000000000000000000;;		case msgUserAuthSuccess:
0000000000000000000000000000000000000000;;			return new(userAuthSuccessMsg), nil
0000000000000000000000000000000000000000;;		case msgUserAuthFailure:
0000000000000000000000000000000000000000;;			msg = new(userAuthFailureMsg)
0000000000000000000000000000000000000000;;		case msgUserAuthPubKeyOk:
0000000000000000000000000000000000000000;;			msg = new(userAuthPubKeyOkMsg)
0000000000000000000000000000000000000000;;		case msgGlobalRequest:
0000000000000000000000000000000000000000;;			msg = new(globalRequestMsg)
0000000000000000000000000000000000000000;;		case msgRequestSuccess:
0000000000000000000000000000000000000000;;			msg = new(globalRequestSuccessMsg)
0000000000000000000000000000000000000000;;		case msgRequestFailure:
0000000000000000000000000000000000000000;;			msg = new(globalRequestFailureMsg)
0000000000000000000000000000000000000000;;		case msgChannelOpen:
0000000000000000000000000000000000000000;;			msg = new(channelOpenMsg)
0000000000000000000000000000000000000000;;		case msgChannelData:
0000000000000000000000000000000000000000;;			msg = new(channelDataMsg)
0000000000000000000000000000000000000000;;		case msgChannelOpenConfirm:
0000000000000000000000000000000000000000;;			msg = new(channelOpenConfirmMsg)
0000000000000000000000000000000000000000;;		case msgChannelOpenFailure:
0000000000000000000000000000000000000000;;			msg = new(channelOpenFailureMsg)
0000000000000000000000000000000000000000;;		case msgChannelWindowAdjust:
0000000000000000000000000000000000000000;;			msg = new(windowAdjustMsg)
0000000000000000000000000000000000000000;;		case msgChannelEOF:
0000000000000000000000000000000000000000;;			msg = new(channelEOFMsg)
0000000000000000000000000000000000000000;;		case msgChannelClose:
0000000000000000000000000000000000000000;;			msg = new(channelCloseMsg)
0000000000000000000000000000000000000000;;		case msgChannelRequest:
0000000000000000000000000000000000000000;;			msg = new(channelRequestMsg)
0000000000000000000000000000000000000000;;		case msgChannelSuccess:
0000000000000000000000000000000000000000;;			msg = new(channelRequestSuccessMsg)
0000000000000000000000000000000000000000;;		case msgChannelFailure:
0000000000000000000000000000000000000000;;			msg = new(channelRequestFailureMsg)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, unexpectedMessageError(0, packet[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := Unmarshal(packet, msg); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg, nil
0000000000000000000000000000000000000000;;	}
