0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/session.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/session.go][vendor/golang.org/x/crypto/ssh/session.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Session implements an interactive session described in
0000000000000000000000000000000000000000;;	// "RFC 4254, section 6".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Signal string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// POSIX signals as listed in RFC 4254 Section 6.10.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SIGABRT Signal = "ABRT"
0000000000000000000000000000000000000000;;		SIGALRM Signal = "ALRM"
0000000000000000000000000000000000000000;;		SIGFPE  Signal = "FPE"
0000000000000000000000000000000000000000;;		SIGHUP  Signal = "HUP"
0000000000000000000000000000000000000000;;		SIGILL  Signal = "ILL"
0000000000000000000000000000000000000000;;		SIGINT  Signal = "INT"
0000000000000000000000000000000000000000;;		SIGKILL Signal = "KILL"
0000000000000000000000000000000000000000;;		SIGPIPE Signal = "PIPE"
0000000000000000000000000000000000000000;;		SIGQUIT Signal = "QUIT"
0000000000000000000000000000000000000000;;		SIGSEGV Signal = "SEGV"
0000000000000000000000000000000000000000;;		SIGTERM Signal = "TERM"
0000000000000000000000000000000000000000;;		SIGUSR1 Signal = "USR1"
0000000000000000000000000000000000000000;;		SIGUSR2 Signal = "USR2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var signals = map[Signal]int{
0000000000000000000000000000000000000000;;		SIGABRT: 6,
0000000000000000000000000000000000000000;;		SIGALRM: 14,
0000000000000000000000000000000000000000;;		SIGFPE:  8,
0000000000000000000000000000000000000000;;		SIGHUP:  1,
0000000000000000000000000000000000000000;;		SIGILL:  4,
0000000000000000000000000000000000000000;;		SIGINT:  2,
0000000000000000000000000000000000000000;;		SIGKILL: 9,
0000000000000000000000000000000000000000;;		SIGPIPE: 13,
0000000000000000000000000000000000000000;;		SIGQUIT: 3,
0000000000000000000000000000000000000000;;		SIGSEGV: 11,
0000000000000000000000000000000000000000;;		SIGTERM: 15,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TerminalModes map[uint8]uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// POSIX terminal mode flags as listed in RFC 4254 Section 8.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		tty_OP_END    = 0
0000000000000000000000000000000000000000;;		VINTR         = 1
0000000000000000000000000000000000000000;;		VQUIT         = 2
0000000000000000000000000000000000000000;;		VERASE        = 3
0000000000000000000000000000000000000000;;		VKILL         = 4
0000000000000000000000000000000000000000;;		VEOF          = 5
0000000000000000000000000000000000000000;;		VEOL          = 6
0000000000000000000000000000000000000000;;		VEOL2         = 7
0000000000000000000000000000000000000000;;		VSTART        = 8
0000000000000000000000000000000000000000;;		VSTOP         = 9
0000000000000000000000000000000000000000;;		VSUSP         = 10
0000000000000000000000000000000000000000;;		VDSUSP        = 11
0000000000000000000000000000000000000000;;		VREPRINT      = 12
0000000000000000000000000000000000000000;;		VWERASE       = 13
0000000000000000000000000000000000000000;;		VLNEXT        = 14
0000000000000000000000000000000000000000;;		VFLUSH        = 15
0000000000000000000000000000000000000000;;		VSWTCH        = 16
0000000000000000000000000000000000000000;;		VSTATUS       = 17
0000000000000000000000000000000000000000;;		VDISCARD      = 18
0000000000000000000000000000000000000000;;		IGNPAR        = 30
0000000000000000000000000000000000000000;;		PARMRK        = 31
0000000000000000000000000000000000000000;;		INPCK         = 32
0000000000000000000000000000000000000000;;		ISTRIP        = 33
0000000000000000000000000000000000000000;;		INLCR         = 34
0000000000000000000000000000000000000000;;		IGNCR         = 35
0000000000000000000000000000000000000000;;		ICRNL         = 36
0000000000000000000000000000000000000000;;		IUCLC         = 37
0000000000000000000000000000000000000000;;		IXON          = 38
0000000000000000000000000000000000000000;;		IXANY         = 39
0000000000000000000000000000000000000000;;		IXOFF         = 40
0000000000000000000000000000000000000000;;		IMAXBEL       = 41
0000000000000000000000000000000000000000;;		ISIG          = 50
0000000000000000000000000000000000000000;;		ICANON        = 51
0000000000000000000000000000000000000000;;		XCASE         = 52
0000000000000000000000000000000000000000;;		ECHO          = 53
0000000000000000000000000000000000000000;;		ECHOE         = 54
0000000000000000000000000000000000000000;;		ECHOK         = 55
0000000000000000000000000000000000000000;;		ECHONL        = 56
0000000000000000000000000000000000000000;;		NOFLSH        = 57
0000000000000000000000000000000000000000;;		TOSTOP        = 58
0000000000000000000000000000000000000000;;		IEXTEN        = 59
0000000000000000000000000000000000000000;;		ECHOCTL       = 60
0000000000000000000000000000000000000000;;		ECHOKE        = 61
0000000000000000000000000000000000000000;;		PENDIN        = 62
0000000000000000000000000000000000000000;;		OPOST         = 70
0000000000000000000000000000000000000000;;		OLCUC         = 71
0000000000000000000000000000000000000000;;		ONLCR         = 72
0000000000000000000000000000000000000000;;		OCRNL         = 73
0000000000000000000000000000000000000000;;		ONOCR         = 74
0000000000000000000000000000000000000000;;		ONLRET        = 75
0000000000000000000000000000000000000000;;		CS7           = 90
0000000000000000000000000000000000000000;;		CS8           = 91
0000000000000000000000000000000000000000;;		PARENB        = 92
0000000000000000000000000000000000000000;;		PARODD        = 93
0000000000000000000000000000000000000000;;		TTY_OP_ISPEED = 128
0000000000000000000000000000000000000000;;		TTY_OP_OSPEED = 129
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Session represents a connection to a remote command or shell.
0000000000000000000000000000000000000000;;	type Session struct {
0000000000000000000000000000000000000000;;		// Stdin specifies the remote process's standard input.
0000000000000000000000000000000000000000;;		// If Stdin is nil, the remote process reads from an empty
0000000000000000000000000000000000000000;;		// bytes.Buffer.
0000000000000000000000000000000000000000;;		Stdin io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stdout and Stderr specify the remote process's standard
0000000000000000000000000000000000000000;;		// output and error.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If either is nil, Run connects the corresponding file
0000000000000000000000000000000000000000;;		// descriptor to an instance of ioutil.Discard. There is a
0000000000000000000000000000000000000000;;		// fixed amount of buffering that is shared for the two streams.
0000000000000000000000000000000000000000;;		// If either blocks it may eventually cause the remote
0000000000000000000000000000000000000000;;		// command to block.
0000000000000000000000000000000000000000;;		Stdout io.Writer
0000000000000000000000000000000000000000;;		Stderr io.Writer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch        Channel // the channel backing this session
0000000000000000000000000000000000000000;;		started   bool    // true once Start, Run or Shell is invoked.
0000000000000000000000000000000000000000;;		copyFuncs []func() error
0000000000000000000000000000000000000000;;		errors    chan error // one send per copyFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// true if pipe method is active
0000000000000000000000000000000000000000;;		stdinpipe, stdoutpipe, stderrpipe bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// stdinPipeWriter is non-nil if StdinPipe has not been called
0000000000000000000000000000000000000000;;		// and Stdin was specified by the user; it is the write end of
0000000000000000000000000000000000000000;;		// a pipe connecting Session.Stdin to the stdin channel.
0000000000000000000000000000000000000000;;		stdinPipeWriter io.WriteCloser
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exitStatus chan error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SendRequest sends an out-of-band channel request on the SSH channel
0000000000000000000000000000000000000000;;	// underlying the session.
0000000000000000000000000000000000000000;;	func (s *Session) SendRequest(name string, wantReply bool, payload []byte) (bool, error) {
0000000000000000000000000000000000000000;;		return s.ch.SendRequest(name, wantReply, payload)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Session) Close() error {
0000000000000000000000000000000000000000;;		return s.ch.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 4254 Section 6.4.
0000000000000000000000000000000000000000;;	type setenvRequest struct {
0000000000000000000000000000000000000000;;		Name  string
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setenv sets an environment variable that will be applied to any
0000000000000000000000000000000000000000;;	// command executed by Shell or Run.
0000000000000000000000000000000000000000;;	func (s *Session) Setenv(name, value string) error {
0000000000000000000000000000000000000000;;		msg := setenvRequest{
0000000000000000000000000000000000000000;;			Name:  name,
0000000000000000000000000000000000000000;;			Value: value,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ok, err := s.ch.SendRequest("env", true, Marshal(&msg))
0000000000000000000000000000000000000000;;		if err == nil && !ok {
0000000000000000000000000000000000000000;;			err = errors.New("ssh: setenv failed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 4254 Section 6.2.
0000000000000000000000000000000000000000;;	type ptyRequestMsg struct {
0000000000000000000000000000000000000000;;		Term     string
0000000000000000000000000000000000000000;;		Columns  uint32
0000000000000000000000000000000000000000;;		Rows     uint32
0000000000000000000000000000000000000000;;		Width    uint32
0000000000000000000000000000000000000000;;		Height   uint32
0000000000000000000000000000000000000000;;		Modelist string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestPty requests the association of a pty with the session on the remote host.
0000000000000000000000000000000000000000;;	func (s *Session) RequestPty(term string, h, w int, termmodes TerminalModes) error {
0000000000000000000000000000000000000000;;		var tm []byte
0000000000000000000000000000000000000000;;		for k, v := range termmodes {
0000000000000000000000000000000000000000;;			kv := struct {
0000000000000000000000000000000000000000;;				Key byte
0000000000000000000000000000000000000000;;				Val uint32
0000000000000000000000000000000000000000;;			}{k, v}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tm = append(tm, Marshal(&kv)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tm = append(tm, tty_OP_END)
0000000000000000000000000000000000000000;;		req := ptyRequestMsg{
0000000000000000000000000000000000000000;;			Term:     term,
0000000000000000000000000000000000000000;;			Columns:  uint32(w),
0000000000000000000000000000000000000000;;			Rows:     uint32(h),
0000000000000000000000000000000000000000;;			Width:    uint32(w * 8),
0000000000000000000000000000000000000000;;			Height:   uint32(h * 8),
0000000000000000000000000000000000000000;;			Modelist: string(tm),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ok, err := s.ch.SendRequest("pty-req", true, Marshal(&req))
0000000000000000000000000000000000000000;;		if err == nil && !ok {
0000000000000000000000000000000000000000;;			err = errors.New("ssh: pty-req failed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 4254 Section 6.5.
0000000000000000000000000000000000000000;;	type subsystemRequestMsg struct {
0000000000000000000000000000000000000000;;		Subsystem string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestSubsystem requests the association of a subsystem with the session on the remote host.
0000000000000000000000000000000000000000;;	// A subsystem is a predefined command that runs in the background when the ssh session is initiated
0000000000000000000000000000000000000000;;	func (s *Session) RequestSubsystem(subsystem string) error {
0000000000000000000000000000000000000000;;		msg := subsystemRequestMsg{
0000000000000000000000000000000000000000;;			Subsystem: subsystem,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ok, err := s.ch.SendRequest("subsystem", true, Marshal(&msg))
0000000000000000000000000000000000000000;;		if err == nil && !ok {
0000000000000000000000000000000000000000;;			err = errors.New("ssh: subsystem request failed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 4254 Section 6.9.
0000000000000000000000000000000000000000;;	type signalMsg struct {
0000000000000000000000000000000000000000;;		Signal string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signal sends the given signal to the remote process.
0000000000000000000000000000000000000000;;	// sig is one of the SIG* constants.
0000000000000000000000000000000000000000;;	func (s *Session) Signal(sig Signal) error {
0000000000000000000000000000000000000000;;		msg := signalMsg{
0000000000000000000000000000000000000000;;			Signal: string(sig),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := s.ch.SendRequest("signal", false, Marshal(&msg))
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 4254 Section 6.5.
0000000000000000000000000000000000000000;;	type execMsg struct {
0000000000000000000000000000000000000000;;		Command string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start runs cmd on the remote host. Typically, the remote
0000000000000000000000000000000000000000;;	// server passes cmd to the shell for interpretation.
0000000000000000000000000000000000000000;;	// A Session only accepts one call to Run, Start or Shell.
0000000000000000000000000000000000000000;;	func (s *Session) Start(cmd string) error {
0000000000000000000000000000000000000000;;		if s.started {
0000000000000000000000000000000000000000;;			return errors.New("ssh: session already started")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req := execMsg{
0000000000000000000000000000000000000000;;			Command: cmd,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := s.ch.SendRequest("exec", true, Marshal(&req))
0000000000000000000000000000000000000000;;		if err == nil && !ok {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("ssh: command %v failed", cmd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run runs cmd on the remote host. Typically, the remote
0000000000000000000000000000000000000000;;	// server passes cmd to the shell for interpretation.
0000000000000000000000000000000000000000;;	// A Session only accepts one call to Run, Start, Shell, Output,
0000000000000000000000000000000000000000;;	// or CombinedOutput.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The returned error is nil if the command runs, has no problems
0000000000000000000000000000000000000000;;	// copying stdin, stdout, and stderr, and exits with a zero exit
0000000000000000000000000000000000000000;;	// status.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the remote server does not send an exit status, an error of type
0000000000000000000000000000000000000000;;	// *ExitMissingError is returned. If the command completes
0000000000000000000000000000000000000000;;	// unsuccessfully or is interrupted by a signal, the error is of type
0000000000000000000000000000000000000000;;	// *ExitError. Other error types may be returned for I/O problems.
0000000000000000000000000000000000000000;;	func (s *Session) Run(cmd string) error {
0000000000000000000000000000000000000000;;		err := s.Start(cmd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Output runs cmd on the remote host and returns its standard output.
0000000000000000000000000000000000000000;;	func (s *Session) Output(cmd string) ([]byte, error) {
0000000000000000000000000000000000000000;;		if s.Stdout != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: Stdout already set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		s.Stdout = &b
0000000000000000000000000000000000000000;;		err := s.Run(cmd)
0000000000000000000000000000000000000000;;		return b.Bytes(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type singleWriter struct {
0000000000000000000000000000000000000000;;		b  bytes.Buffer
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *singleWriter) Write(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		defer w.mu.Unlock()
0000000000000000000000000000000000000000;;		return w.b.Write(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CombinedOutput runs cmd on the remote host and returns its combined
0000000000000000000000000000000000000000;;	// standard output and standard error.
0000000000000000000000000000000000000000;;	func (s *Session) CombinedOutput(cmd string) ([]byte, error) {
0000000000000000000000000000000000000000;;		if s.Stdout != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: Stdout already set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Stderr != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: Stderr already set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var b singleWriter
0000000000000000000000000000000000000000;;		s.Stdout = &b
0000000000000000000000000000000000000000;;		s.Stderr = &b
0000000000000000000000000000000000000000;;		err := s.Run(cmd)
0000000000000000000000000000000000000000;;		return b.b.Bytes(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Shell starts a login shell on the remote host. A Session only
0000000000000000000000000000000000000000;;	// accepts one call to Run, Start, Shell, Output, or CombinedOutput.
0000000000000000000000000000000000000000;;	func (s *Session) Shell() error {
0000000000000000000000000000000000000000;;		if s.started {
0000000000000000000000000000000000000000;;			return errors.New("ssh: session already started")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := s.ch.SendRequest("shell", true, nil)
0000000000000000000000000000000000000000;;		if err == nil && !ok {
0000000000000000000000000000000000000000;;			return errors.New("ssh: could not start shell")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Session) start() error {
0000000000000000000000000000000000000000;;		s.started = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type F func(*Session)
0000000000000000000000000000000000000000;;		for _, setupFd := range []F{(*Session).stdin, (*Session).stdout, (*Session).stderr} {
0000000000000000000000000000000000000000;;			setupFd(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.errors = make(chan error, len(s.copyFuncs))
0000000000000000000000000000000000000000;;		for _, fn := range s.copyFuncs {
0000000000000000000000000000000000000000;;			go func(fn func() error) {
0000000000000000000000000000000000000000;;				s.errors <- fn()
0000000000000000000000000000000000000000;;			}(fn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait waits for the remote command to exit.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The returned error is nil if the command runs, has no problems
0000000000000000000000000000000000000000;;	// copying stdin, stdout, and stderr, and exits with a zero exit
0000000000000000000000000000000000000000;;	// status.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the remote server does not send an exit status, an error of type
0000000000000000000000000000000000000000;;	// *ExitMissingError is returned. If the command completes
0000000000000000000000000000000000000000;;	// unsuccessfully or is interrupted by a signal, the error is of type
0000000000000000000000000000000000000000;;	// *ExitError. Other error types may be returned for I/O problems.
0000000000000000000000000000000000000000;;	func (s *Session) Wait() error {
0000000000000000000000000000000000000000;;		if !s.started {
0000000000000000000000000000000000000000;;			return errors.New("ssh: session not started")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		waitErr := <-s.exitStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.stdinPipeWriter != nil {
0000000000000000000000000000000000000000;;			s.stdinPipeWriter.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var copyError error
0000000000000000000000000000000000000000;;		for _ = range s.copyFuncs {
0000000000000000000000000000000000000000;;			if err := <-s.errors; err != nil && copyError == nil {
0000000000000000000000000000000000000000;;				copyError = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if waitErr != nil {
0000000000000000000000000000000000000000;;			return waitErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copyError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Session) wait(reqs <-chan *Request) error {
0000000000000000000000000000000000000000;;		wm := Waitmsg{status: -1}
0000000000000000000000000000000000000000;;		// Wait for msg channel to be closed before returning.
0000000000000000000000000000000000000000;;		for msg := range reqs {
0000000000000000000000000000000000000000;;			switch msg.Type {
0000000000000000000000000000000000000000;;			case "exit-status":
0000000000000000000000000000000000000000;;				wm.status = int(binary.BigEndian.Uint32(msg.Payload))
0000000000000000000000000000000000000000;;			case "exit-signal":
0000000000000000000000000000000000000000;;				var sigval struct {
0000000000000000000000000000000000000000;;					Signal     string
0000000000000000000000000000000000000000;;					CoreDumped bool
0000000000000000000000000000000000000000;;					Error      string
0000000000000000000000000000000000000000;;					Lang       string
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := Unmarshal(msg.Payload, &sigval); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Must sanitize strings?
0000000000000000000000000000000000000000;;				wm.signal = sigval.Signal
0000000000000000000000000000000000000000;;				wm.msg = sigval.Error
0000000000000000000000000000000000000000;;				wm.lang = sigval.Lang
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// This handles keepalives and matches
0000000000000000000000000000000000000000;;				// OpenSSH's behaviour.
0000000000000000000000000000000000000000;;				if msg.WantReply {
0000000000000000000000000000000000000000;;					msg.Reply(false, nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wm.status == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wm.status == -1 {
0000000000000000000000000000000000000000;;			// exit-status was never sent from server
0000000000000000000000000000000000000000;;			if wm.signal == "" {
0000000000000000000000000000000000000000;;				// signal was not sent either.  RFC 4254
0000000000000000000000000000000000000000;;				// section 6.10 recommends against this
0000000000000000000000000000000000000000;;				// behavior, but it is allowed, so we let
0000000000000000000000000000000000000000;;				// clients handle it.
0000000000000000000000000000000000000000;;				return &ExitMissingError{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wm.status = 128
0000000000000000000000000000000000000000;;			if _, ok := signals[Signal(wm.signal)]; ok {
0000000000000000000000000000000000000000;;				wm.status += signals[Signal(wm.signal)]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ExitError{wm}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExitMissingError is returned if a session is torn down cleanly, but
0000000000000000000000000000000000000000;;	// the server sends no confirmation of the exit status.
0000000000000000000000000000000000000000;;	type ExitMissingError struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *ExitMissingError) Error() string {
0000000000000000000000000000000000000000;;		return "wait: remote command exited without exit status or exit signal"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Session) stdin() {
0000000000000000000000000000000000000000;;		if s.stdinpipe {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var stdin io.Reader
0000000000000000000000000000000000000000;;		if s.Stdin == nil {
0000000000000000000000000000000000000000;;			stdin = new(bytes.Buffer)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r, w := io.Pipe()
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				_, err := io.Copy(w, s.Stdin)
0000000000000000000000000000000000000000;;				w.CloseWithError(err)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			stdin, s.stdinPipeWriter = r, w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.copyFuncs = append(s.copyFuncs, func() error {
0000000000000000000000000000000000000000;;			_, err := io.Copy(s.ch, stdin)
0000000000000000000000000000000000000000;;			if err1 := s.ch.CloseWrite(); err == nil && err1 != io.EOF {
0000000000000000000000000000000000000000;;				err = err1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Session) stdout() {
0000000000000000000000000000000000000000;;		if s.stdoutpipe {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Stdout == nil {
0000000000000000000000000000000000000000;;			s.Stdout = ioutil.Discard
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.copyFuncs = append(s.copyFuncs, func() error {
0000000000000000000000000000000000000000;;			_, err := io.Copy(s.Stdout, s.ch)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Session) stderr() {
0000000000000000000000000000000000000000;;		if s.stderrpipe {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Stderr == nil {
0000000000000000000000000000000000000000;;			s.Stderr = ioutil.Discard
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.copyFuncs = append(s.copyFuncs, func() error {
0000000000000000000000000000000000000000;;			_, err := io.Copy(s.Stderr, s.ch.Stderr())
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sessionStdin reroutes Close to CloseWrite.
0000000000000000000000000000000000000000;;	type sessionStdin struct {
0000000000000000000000000000000000000000;;		io.Writer
0000000000000000000000000000000000000000;;		ch Channel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sessionStdin) Close() error {
0000000000000000000000000000000000000000;;		return s.ch.CloseWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StdinPipe returns a pipe that will be connected to the
0000000000000000000000000000000000000000;;	// remote command's standard input when the command starts.
0000000000000000000000000000000000000000;;	func (s *Session) StdinPipe() (io.WriteCloser, error) {
0000000000000000000000000000000000000000;;		if s.Stdin != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: Stdin already set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.started {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: StdinPipe after process started")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.stdinpipe = true
0000000000000000000000000000000000000000;;		return &sessionStdin{s.ch, s.ch}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StdoutPipe returns a pipe that will be connected to the
0000000000000000000000000000000000000000;;	// remote command's standard output when the command starts.
0000000000000000000000000000000000000000;;	// There is a fixed amount of buffering that is shared between
0000000000000000000000000000000000000000;;	// stdout and stderr streams. If the StdoutPipe reader is
0000000000000000000000000000000000000000;;	// not serviced fast enough it may eventually cause the
0000000000000000000000000000000000000000;;	// remote command to block.
0000000000000000000000000000000000000000;;	func (s *Session) StdoutPipe() (io.Reader, error) {
0000000000000000000000000000000000000000;;		if s.Stdout != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: Stdout already set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.started {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: StdoutPipe after process started")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.stdoutpipe = true
0000000000000000000000000000000000000000;;		return s.ch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StderrPipe returns a pipe that will be connected to the
0000000000000000000000000000000000000000;;	// remote command's standard error when the command starts.
0000000000000000000000000000000000000000;;	// There is a fixed amount of buffering that is shared between
0000000000000000000000000000000000000000;;	// stdout and stderr streams. If the StderrPipe reader is
0000000000000000000000000000000000000000;;	// not serviced fast enough it may eventually cause the
0000000000000000000000000000000000000000;;	// remote command to block.
0000000000000000000000000000000000000000;;	func (s *Session) StderrPipe() (io.Reader, error) {
0000000000000000000000000000000000000000;;		if s.Stderr != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: Stderr already set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.started {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: StderrPipe after process started")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.stderrpipe = true
0000000000000000000000000000000000000000;;		return s.ch.Stderr(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newSession returns a new interactive session on the remote host.
0000000000000000000000000000000000000000;;	func newSession(ch Channel, reqs <-chan *Request) (*Session, error) {
0000000000000000000000000000000000000000;;		s := &Session{
0000000000000000000000000000000000000000;;			ch: ch,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.exitStatus = make(chan error, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			s.exitStatus <- s.wait(reqs)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An ExitError reports unsuccessful completion of a remote command.
0000000000000000000000000000000000000000;;	type ExitError struct {
0000000000000000000000000000000000000000;;		Waitmsg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *ExitError) Error() string {
0000000000000000000000000000000000000000;;		return e.Waitmsg.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Waitmsg stores the information about an exited remote command
0000000000000000000000000000000000000000;;	// as reported by Wait.
0000000000000000000000000000000000000000;;	type Waitmsg struct {
0000000000000000000000000000000000000000;;		status int
0000000000000000000000000000000000000000;;		signal string
0000000000000000000000000000000000000000;;		msg    string
0000000000000000000000000000000000000000;;		lang   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExitStatus returns the exit status of the remote command.
0000000000000000000000000000000000000000;;	func (w Waitmsg) ExitStatus() int {
0000000000000000000000000000000000000000;;		return w.status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signal returns the exit signal of the remote command if
0000000000000000000000000000000000000000;;	// it was terminated violently.
0000000000000000000000000000000000000000;;	func (w Waitmsg) Signal() string {
0000000000000000000000000000000000000000;;		return w.signal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Msg returns the exit message given by the remote command
0000000000000000000000000000000000000000;;	func (w Waitmsg) Msg() string {
0000000000000000000000000000000000000000;;		return w.msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lang returns the language tag. See RFC 3066
0000000000000000000000000000000000000000;;	func (w Waitmsg) Lang() string {
0000000000000000000000000000000000000000;;		return w.lang
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w Waitmsg) String() string {
0000000000000000000000000000000000000000;;		str := fmt.Sprintf("Process exited with status %v", w.status)
0000000000000000000000000000000000000000;;		if w.signal != "" {
0000000000000000000000000000000000000000;;			str += fmt.Sprintf(" from signal %v", w.signal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w.msg != "" {
0000000000000000000000000000000000000000;;			str += fmt.Sprintf(". Reason was: %v", w.msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return str
0000000000000000000000000000000000000000;;	}
