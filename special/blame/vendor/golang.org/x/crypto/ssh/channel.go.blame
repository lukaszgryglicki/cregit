0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/channel.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/channel.go][vendor/golang.org/x/crypto/ssh/channel.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		minPacketLength = 9
0000000000000000000000000000000000000000;;		// channelMaxPacket contains the maximum number of bytes that will be
0000000000000000000000000000000000000000;;		// sent in a single packet. As per RFC 4253, section 6.1, 32k is also
0000000000000000000000000000000000000000;;		// the minimum.
0000000000000000000000000000000000000000;;		channelMaxPacket = 1 << 15
0000000000000000000000000000000000000000;;		// We follow OpenSSH here.
0000000000000000000000000000000000000000;;		channelWindowSize = 64 * channelMaxPacket
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewChannel represents an incoming request to a channel. It must either be
0000000000000000000000000000000000000000;;	// accepted for use by calling Accept, or rejected by calling Reject.
0000000000000000000000000000000000000000;;	type NewChannel interface {
0000000000000000000000000000000000000000;;		// Accept accepts the channel creation request. It returns the Channel
0000000000000000000000000000000000000000;;		// and a Go channel containing SSH requests. The Go channel must be
0000000000000000000000000000000000000000;;		// serviced otherwise the Channel will hang.
0000000000000000000000000000000000000000;;		Accept() (Channel, <-chan *Request, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reject rejects the channel creation request. After calling
0000000000000000000000000000000000000000;;		// this, no other methods on the Channel may be called.
0000000000000000000000000000000000000000;;		Reject(reason RejectionReason, message string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ChannelType returns the type of the channel, as supplied by the
0000000000000000000000000000000000000000;;		// client.
0000000000000000000000000000000000000000;;		ChannelType() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExtraData returns the arbitrary payload for this channel, as supplied
0000000000000000000000000000000000000000;;		// by the client. This data is specific to the channel type.
0000000000000000000000000000000000000000;;		ExtraData() []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Channel is an ordered, reliable, flow-controlled, duplex stream
0000000000000000000000000000000000000000;;	// that is multiplexed over an SSH connection.
0000000000000000000000000000000000000000;;	type Channel interface {
0000000000000000000000000000000000000000;;		// Read reads up to len(data) bytes from the channel.
0000000000000000000000000000000000000000;;		Read(data []byte) (int, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write writes len(data) bytes to the channel.
0000000000000000000000000000000000000000;;		Write(data []byte) (int, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close signals end of channel use. No data may be sent after this
0000000000000000000000000000000000000000;;		// call.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CloseWrite signals the end of sending in-band
0000000000000000000000000000000000000000;;		// data. Requests may still be sent, and the other side may
0000000000000000000000000000000000000000;;		// still send data
0000000000000000000000000000000000000000;;		CloseWrite() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SendRequest sends a channel request.  If wantReply is true,
0000000000000000000000000000000000000000;;		// it will wait for a reply and return the result as a
0000000000000000000000000000000000000000;;		// boolean, otherwise the return value will be false. Channel
0000000000000000000000000000000000000000;;		// requests are out-of-band messages so they may be sent even
0000000000000000000000000000000000000000;;		// if the data stream is closed or blocked by flow control.
0000000000000000000000000000000000000000;;		// If the channel is closed before a reply is returned, io.EOF
0000000000000000000000000000000000000000;;		// is returned.
0000000000000000000000000000000000000000;;		SendRequest(name string, wantReply bool, payload []byte) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stderr returns an io.ReadWriter that writes to this channel
0000000000000000000000000000000000000000;;		// with the extended data type set to stderr. Stderr may
0000000000000000000000000000000000000000;;		// safely be read and written from a different goroutine than
0000000000000000000000000000000000000000;;		// Read and Write respectively.
0000000000000000000000000000000000000000;;		Stderr() io.ReadWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Request is a request sent outside of the normal stream of
0000000000000000000000000000000000000000;;	// data. Requests can either be specific to an SSH channel, or they
0000000000000000000000000000000000000000;;	// can be global.
0000000000000000000000000000000000000000;;	type Request struct {
0000000000000000000000000000000000000000;;		Type      string
0000000000000000000000000000000000000000;;		WantReply bool
0000000000000000000000000000000000000000;;		Payload   []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch  *channel
0000000000000000000000000000000000000000;;		mux *mux
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reply sends a response to a request. It must be called for all requests
0000000000000000000000000000000000000000;;	// where WantReply is true and is a no-op otherwise. The payload argument is
0000000000000000000000000000000000000000;;	// ignored for replies to channel-specific requests.
0000000000000000000000000000000000000000;;	func (r *Request) Reply(ok bool, payload []byte) error {
0000000000000000000000000000000000000000;;		if !r.WantReply {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.ch == nil {
0000000000000000000000000000000000000000;;			return r.mux.ackRequest(ok, payload)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.ch.ackRequest(ok)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RejectionReason is an enumeration used when rejecting channel creation
0000000000000000000000000000000000000000;;	// requests. See RFC 4254, section 5.1.
0000000000000000000000000000000000000000;;	type RejectionReason uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Prohibited RejectionReason = iota + 1
0000000000000000000000000000000000000000;;		ConnectionFailed
0000000000000000000000000000000000000000;;		UnknownChannelType
0000000000000000000000000000000000000000;;		ResourceShortage
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String converts the rejection reason to human readable form.
0000000000000000000000000000000000000000;;	func (r RejectionReason) String() string {
0000000000000000000000000000000000000000;;		switch r {
0000000000000000000000000000000000000000;;		case Prohibited:
0000000000000000000000000000000000000000;;			return "administratively prohibited"
0000000000000000000000000000000000000000;;		case ConnectionFailed:
0000000000000000000000000000000000000000;;			return "connect failed"
0000000000000000000000000000000000000000;;		case UnknownChannelType:
0000000000000000000000000000000000000000;;			return "unknown channel type"
0000000000000000000000000000000000000000;;		case ResourceShortage:
0000000000000000000000000000000000000000;;			return "resource shortage"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("unknown reason %d", int(r))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func min(a uint32, b int) uint32 {
0000000000000000000000000000000000000000;;		if a < uint32(b) {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint32(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type channelDirection uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		channelInbound channelDirection = iota
0000000000000000000000000000000000000000;;		channelOutbound
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// channel is an implementation of the Channel interface that works
0000000000000000000000000000000000000000;;	// with the mux class.
0000000000000000000000000000000000000000;;	type channel struct {
0000000000000000000000000000000000000000;;		// R/O after creation
0000000000000000000000000000000000000000;;		chanType          string
0000000000000000000000000000000000000000;;		extraData         []byte
0000000000000000000000000000000000000000;;		localId, remoteId uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// maxIncomingPayload and maxRemotePayload are the maximum
0000000000000000000000000000000000000000;;		// payload sizes of normal and extended data packets for
0000000000000000000000000000000000000000;;		// receiving and sending, respectively. The wire packet will
0000000000000000000000000000000000000000;;		// be 9 or 13 bytes larger (excluding encryption overhead).
0000000000000000000000000000000000000000;;		maxIncomingPayload uint32
0000000000000000000000000000000000000000;;		maxRemotePayload   uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mux *mux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// decided is set to true if an accept or reject message has been sent
0000000000000000000000000000000000000000;;		// (for outbound channels) or received (for inbound channels).
0000000000000000000000000000000000000000;;		decided bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// direction contains either channelOutbound, for channels created
0000000000000000000000000000000000000000;;		// locally, or channelInbound, for channels created by the peer.
0000000000000000000000000000000000000000;;		direction channelDirection
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pending internal channel messages.
0000000000000000000000000000000000000000;;		msg chan interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Since requests have no ID, there can be only one request
0000000000000000000000000000000000000000;;		// with WantReply=true outstanding.  This lock is held by a
0000000000000000000000000000000000000000;;		// goroutine that has such an outgoing request pending.
0000000000000000000000000000000000000000;;		sentRequestMu sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		incomingRequests chan *Request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sentEOF bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// thread-safe data
0000000000000000000000000000000000000000;;		remoteWin  window
0000000000000000000000000000000000000000;;		pending    *buffer
0000000000000000000000000000000000000000;;		extPending *buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// windowMu protects myWindow, the flow-control window.
0000000000000000000000000000000000000000;;		windowMu sync.Mutex
0000000000000000000000000000000000000000;;		myWindow uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// writeMu serializes calls to mux.conn.writePacket() and
0000000000000000000000000000000000000000;;		// protects sentClose and packetPool. This mutex must be
0000000000000000000000000000000000000000;;		// different from windowMu, as writePacket can block if there
0000000000000000000000000000000000000000;;		// is a key exchange pending.
0000000000000000000000000000000000000000;;		writeMu   sync.Mutex
0000000000000000000000000000000000000000;;		sentClose bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// packetPool has a buffer for each extended channel ID to
0000000000000000000000000000000000000000;;		// save allocations during writes.
0000000000000000000000000000000000000000;;		packetPool map[uint32][]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writePacket sends a packet. If the packet is a channel close, it updates
0000000000000000000000000000000000000000;;	// sentClose. This method takes the lock c.writeMu.
0000000000000000000000000000000000000000;;	func (c *channel) writePacket(packet []byte) error {
0000000000000000000000000000000000000000;;		c.writeMu.Lock()
0000000000000000000000000000000000000000;;		if c.sentClose {
0000000000000000000000000000000000000000;;			c.writeMu.Unlock()
0000000000000000000000000000000000000000;;			return io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.sentClose = (packet[0] == msgChannelClose)
0000000000000000000000000000000000000000;;		err := c.mux.conn.writePacket(packet)
0000000000000000000000000000000000000000;;		c.writeMu.Unlock()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *channel) sendMessage(msg interface{}) error {
0000000000000000000000000000000000000000;;		if debugMux {
0000000000000000000000000000000000000000;;			log.Printf("send(%d): %#v", c.mux.chanList.offset, msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := Marshal(msg)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(p[1:], c.remoteId)
0000000000000000000000000000000000000000;;		return c.writePacket(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteExtended writes data to a specific extended stream. These streams are
0000000000000000000000000000000000000000;;	// used, for example, for stderr.
0000000000000000000000000000000000000000;;	func (c *channel) WriteExtended(data []byte, extendedCode uint32) (n int, err error) {
0000000000000000000000000000000000000000;;		if c.sentEOF {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// 1 byte message type, 4 bytes remoteId, 4 bytes data length
0000000000000000000000000000000000000000;;		opCode := byte(msgChannelData)
0000000000000000000000000000000000000000;;		headerLength := uint32(9)
0000000000000000000000000000000000000000;;		if extendedCode > 0 {
0000000000000000000000000000000000000000;;			headerLength += 4
0000000000000000000000000000000000000000;;			opCode = msgChannelExtendedData
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.writeMu.Lock()
0000000000000000000000000000000000000000;;		packet := c.packetPool[extendedCode]
0000000000000000000000000000000000000000;;		// We don't remove the buffer from packetPool, so
0000000000000000000000000000000000000000;;		// WriteExtended calls from different goroutines will be
0000000000000000000000000000000000000000;;		// flagged as errors by the race detector.
0000000000000000000000000000000000000000;;		c.writeMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(data) > 0 {
0000000000000000000000000000000000000000;;			space := min(c.maxRemotePayload, len(data))
0000000000000000000000000000000000000000;;			if space, err = c.remoteWin.reserve(space); err != nil {
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if want := headerLength + space; uint32(cap(packet)) < want {
0000000000000000000000000000000000000000;;				packet = make([]byte, want)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				packet = packet[:want]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			todo := data[:space]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			packet[0] = opCode
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(packet[1:], c.remoteId)
0000000000000000000000000000000000000000;;			if extendedCode > 0 {
0000000000000000000000000000000000000000;;				binary.BigEndian.PutUint32(packet[5:], uint32(extendedCode))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(packet[headerLength-4:], uint32(len(todo)))
0000000000000000000000000000000000000000;;			copy(packet[headerLength:], todo)
0000000000000000000000000000000000000000;;			if err = c.writePacket(packet); err != nil {
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n += len(todo)
0000000000000000000000000000000000000000;;			data = data[len(todo):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.writeMu.Lock()
0000000000000000000000000000000000000000;;		c.packetPool[extendedCode] = packet
0000000000000000000000000000000000000000;;		c.writeMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *channel) handleData(packet []byte) error {
0000000000000000000000000000000000000000;;		headerLen := 9
0000000000000000000000000000000000000000;;		isExtendedData := packet[0] == msgChannelExtendedData
0000000000000000000000000000000000000000;;		if isExtendedData {
0000000000000000000000000000000000000000;;			headerLen = 13
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(packet) < headerLen {
0000000000000000000000000000000000000000;;			// malformed data packet
0000000000000000000000000000000000000000;;			return parseError(packet[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var extended uint32
0000000000000000000000000000000000000000;;		if isExtendedData {
0000000000000000000000000000000000000000;;			extended = binary.BigEndian.Uint32(packet[5:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		length := binary.BigEndian.Uint32(packet[headerLen-4 : headerLen])
0000000000000000000000000000000000000000;;		if length == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if length > c.maxIncomingPayload {
0000000000000000000000000000000000000000;;			// TODO(hanwen): should send Disconnect?
0000000000000000000000000000000000000000;;			return errors.New("ssh: incoming packet exceeds maximum payload size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := packet[headerLen:]
0000000000000000000000000000000000000000;;		if length != uint32(len(data)) {
0000000000000000000000000000000000000000;;			return errors.New("ssh: wrong packet length")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.windowMu.Lock()
0000000000000000000000000000000000000000;;		if c.myWindow < length {
0000000000000000000000000000000000000000;;			c.windowMu.Unlock()
0000000000000000000000000000000000000000;;			// TODO(hanwen): should send Disconnect with reason?
0000000000000000000000000000000000000000;;			return errors.New("ssh: remote side wrote too much")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.myWindow -= length
0000000000000000000000000000000000000000;;		c.windowMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if extended == 1 {
0000000000000000000000000000000000000000;;			c.extPending.write(data)
0000000000000000000000000000000000000000;;		} else if extended > 0 {
0000000000000000000000000000000000000000;;			// discard other extended data.
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.pending.write(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *channel) adjustWindow(n uint32) error {
0000000000000000000000000000000000000000;;		c.windowMu.Lock()
0000000000000000000000000000000000000000;;		// Since myWindow is managed on our side, and can never exceed
0000000000000000000000000000000000000000;;		// the initial window setting, we don't worry about overflow.
0000000000000000000000000000000000000000;;		c.myWindow += uint32(n)
0000000000000000000000000000000000000000;;		c.windowMu.Unlock()
0000000000000000000000000000000000000000;;		return c.sendMessage(windowAdjustMsg{
0000000000000000000000000000000000000000;;			AdditionalBytes: uint32(n),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *channel) ReadExtended(data []byte, extended uint32) (n int, err error) {
0000000000000000000000000000000000000000;;		switch extended {
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			n, err = c.extPending.Read(data)
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			n, err = c.pending.Read(data)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("ssh: extended code %d unimplemented", extended)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n > 0 {
0000000000000000000000000000000000000000;;			err = c.adjustWindow(uint32(n))
0000000000000000000000000000000000000000;;			// sendWindowAdjust can return io.EOF if the remote
0000000000000000000000000000000000000000;;			// peer has closed the connection, however we want to
0000000000000000000000000000000000000000;;			// defer forwarding io.EOF to the caller of Read until
0000000000000000000000000000000000000000;;			// the buffer has been drained.
0000000000000000000000000000000000000000;;			if n > 0 && err == io.EOF {
0000000000000000000000000000000000000000;;				err = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *channel) close() {
0000000000000000000000000000000000000000;;		c.pending.eof()
0000000000000000000000000000000000000000;;		c.extPending.eof()
0000000000000000000000000000000000000000;;		close(c.msg)
0000000000000000000000000000000000000000;;		close(c.incomingRequests)
0000000000000000000000000000000000000000;;		c.writeMu.Lock()
0000000000000000000000000000000000000000;;		// This is not necessary for a normal channel teardown, but if
0000000000000000000000000000000000000000;;		// there was another error, it is.
0000000000000000000000000000000000000000;;		c.sentClose = true
0000000000000000000000000000000000000000;;		c.writeMu.Unlock()
0000000000000000000000000000000000000000;;		// Unblock writers.
0000000000000000000000000000000000000000;;		c.remoteWin.close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// responseMessageReceived is called when a success or failure message is
0000000000000000000000000000000000000000;;	// received on a channel to check that such a message is reasonable for the
0000000000000000000000000000000000000000;;	// given channel.
0000000000000000000000000000000000000000;;	func (c *channel) responseMessageReceived() error {
0000000000000000000000000000000000000000;;		if c.direction == channelInbound {
0000000000000000000000000000000000000000;;			return errors.New("ssh: channel response message received on inbound channel")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.decided {
0000000000000000000000000000000000000000;;			return errors.New("ssh: duplicate response received for channel")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.decided = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *channel) handlePacket(packet []byte) error {
0000000000000000000000000000000000000000;;		switch packet[0] {
0000000000000000000000000000000000000000;;		case msgChannelData, msgChannelExtendedData:
0000000000000000000000000000000000000000;;			return c.handleData(packet)
0000000000000000000000000000000000000000;;		case msgChannelClose:
0000000000000000000000000000000000000000;;			c.sendMessage(channelCloseMsg{PeersId: c.remoteId})
0000000000000000000000000000000000000000;;			c.mux.chanList.remove(c.localId)
0000000000000000000000000000000000000000;;			c.close()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case msgChannelEOF:
0000000000000000000000000000000000000000;;			// RFC 4254 is mute on how EOF affects dataExt messages but
0000000000000000000000000000000000000000;;			// it is logical to signal EOF at the same time.
0000000000000000000000000000000000000000;;			c.extPending.eof()
0000000000000000000000000000000000000000;;			c.pending.eof()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoded, err := decode(packet)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch msg := decoded.(type) {
0000000000000000000000000000000000000000;;		case *channelOpenFailureMsg:
0000000000000000000000000000000000000000;;			if err := c.responseMessageReceived(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.mux.chanList.remove(msg.PeersId)
0000000000000000000000000000000000000000;;			c.msg <- msg
0000000000000000000000000000000000000000;;		case *channelOpenConfirmMsg:
0000000000000000000000000000000000000000;;			if err := c.responseMessageReceived(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if msg.MaxPacketSize < minPacketLength || msg.MaxPacketSize > 1<<31 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ssh: invalid MaxPacketSize %d from peer", msg.MaxPacketSize)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.remoteId = msg.MyId
0000000000000000000000000000000000000000;;			c.maxRemotePayload = msg.MaxPacketSize
0000000000000000000000000000000000000000;;			c.remoteWin.add(msg.MyWindow)
0000000000000000000000000000000000000000;;			c.msg <- msg
0000000000000000000000000000000000000000;;		case *windowAdjustMsg:
0000000000000000000000000000000000000000;;			if !c.remoteWin.add(msg.AdditionalBytes) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ssh: invalid window update for %d bytes", msg.AdditionalBytes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *channelRequestMsg:
0000000000000000000000000000000000000000;;			req := Request{
0000000000000000000000000000000000000000;;				Type:      msg.Request,
0000000000000000000000000000000000000000;;				WantReply: msg.WantReply,
0000000000000000000000000000000000000000;;				Payload:   msg.RequestSpecificData,
0000000000000000000000000000000000000000;;				ch:        c,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c.incomingRequests <- &req
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			c.msg <- msg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mux) newChannel(chanType string, direction channelDirection, extraData []byte) *channel {
0000000000000000000000000000000000000000;;		ch := &channel{
0000000000000000000000000000000000000000;;			remoteWin:        window{Cond: newCond()},
0000000000000000000000000000000000000000;;			myWindow:         channelWindowSize,
0000000000000000000000000000000000000000;;			pending:          newBuffer(),
0000000000000000000000000000000000000000;;			extPending:       newBuffer(),
0000000000000000000000000000000000000000;;			direction:        direction,
0000000000000000000000000000000000000000;;			incomingRequests: make(chan *Request, 16),
0000000000000000000000000000000000000000;;			msg:              make(chan interface{}, 16),
0000000000000000000000000000000000000000;;			chanType:         chanType,
0000000000000000000000000000000000000000;;			extraData:        extraData,
0000000000000000000000000000000000000000;;			mux:              m,
0000000000000000000000000000000000000000;;			packetPool:       make(map[uint32][]byte),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ch.localId = m.chanList.add(ch)
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errUndecided = errors.New("ssh: must Accept or Reject channel")
0000000000000000000000000000000000000000;;	var errDecidedAlready = errors.New("ssh: can call Accept or Reject only once")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type extChannel struct {
0000000000000000000000000000000000000000;;		code uint32
0000000000000000000000000000000000000000;;		ch   *channel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *extChannel) Write(data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		return e.ch.WriteExtended(data, e.code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *extChannel) Read(data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		return e.ch.ReadExtended(data, e.code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *channel) Accept() (Channel, <-chan *Request, error) {
0000000000000000000000000000000000000000;;		if c.decided {
0000000000000000000000000000000000000000;;			return nil, nil, errDecidedAlready
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.maxIncomingPayload = channelMaxPacket
0000000000000000000000000000000000000000;;		confirm := channelOpenConfirmMsg{
0000000000000000000000000000000000000000;;			PeersId:       c.remoteId,
0000000000000000000000000000000000000000;;			MyId:          c.localId,
0000000000000000000000000000000000000000;;			MyWindow:      c.myWindow,
0000000000000000000000000000000000000000;;			MaxPacketSize: c.maxIncomingPayload,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.decided = true
0000000000000000000000000000000000000000;;		if err := c.sendMessage(confirm); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, c.incomingRequests, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ch *channel) Reject(reason RejectionReason, message string) error {
0000000000000000000000000000000000000000;;		if ch.decided {
0000000000000000000000000000000000000000;;			return errDecidedAlready
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reject := channelOpenFailureMsg{
0000000000000000000000000000000000000000;;			PeersId:  ch.remoteId,
0000000000000000000000000000000000000000;;			Reason:   reason,
0000000000000000000000000000000000000000;;			Message:  message,
0000000000000000000000000000000000000000;;			Language: "en",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ch.decided = true
0000000000000000000000000000000000000000;;		return ch.sendMessage(reject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ch *channel) Read(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		if !ch.decided {
0000000000000000000000000000000000000000;;			return 0, errUndecided
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ch.ReadExtended(data, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ch *channel) Write(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		if !ch.decided {
0000000000000000000000000000000000000000;;			return 0, errUndecided
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ch.WriteExtended(data, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ch *channel) CloseWrite() error {
0000000000000000000000000000000000000000;;		if !ch.decided {
0000000000000000000000000000000000000000;;			return errUndecided
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ch.sentEOF = true
0000000000000000000000000000000000000000;;		return ch.sendMessage(channelEOFMsg{
0000000000000000000000000000000000000000;;			PeersId: ch.remoteId})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ch *channel) Close() error {
0000000000000000000000000000000000000000;;		if !ch.decided {
0000000000000000000000000000000000000000;;			return errUndecided
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ch.sendMessage(channelCloseMsg{
0000000000000000000000000000000000000000;;			PeersId: ch.remoteId})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extended returns an io.ReadWriter that sends and receives data on the given,
0000000000000000000000000000000000000000;;	// SSH extended stream. Such streams are used, for example, for stderr.
0000000000000000000000000000000000000000;;	func (ch *channel) Extended(code uint32) io.ReadWriter {
0000000000000000000000000000000000000000;;		if !ch.decided {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &extChannel{code, ch}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ch *channel) Stderr() io.ReadWriter {
0000000000000000000000000000000000000000;;		return ch.Extended(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ch *channel) SendRequest(name string, wantReply bool, payload []byte) (bool, error) {
0000000000000000000000000000000000000000;;		if !ch.decided {
0000000000000000000000000000000000000000;;			return false, errUndecided
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if wantReply {
0000000000000000000000000000000000000000;;			ch.sentRequestMu.Lock()
0000000000000000000000000000000000000000;;			defer ch.sentRequestMu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := channelRequestMsg{
0000000000000000000000000000000000000000;;			PeersId:             ch.remoteId,
0000000000000000000000000000000000000000;;			Request:             name,
0000000000000000000000000000000000000000;;			WantReply:           wantReply,
0000000000000000000000000000000000000000;;			RequestSpecificData: payload,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ch.sendMessage(msg); err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if wantReply {
0000000000000000000000000000000000000000;;			m, ok := (<-ch.msg)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false, io.EOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch m.(type) {
0000000000000000000000000000000000000000;;			case *channelRequestFailureMsg:
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			case *channelRequestSuccessMsg:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("ssh: unexpected response to channel request: %#v", m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ackRequest either sends an ack or nack to the channel request.
0000000000000000000000000000000000000000;;	func (ch *channel) ackRequest(ok bool) error {
0000000000000000000000000000000000000000;;		if !ch.decided {
0000000000000000000000000000000000000000;;			return errUndecided
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var msg interface{}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			msg = channelRequestFailureMsg{
0000000000000000000000000000000000000000;;				PeersId: ch.remoteId,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			msg = channelRequestSuccessMsg{
0000000000000000000000000000000000000000;;				PeersId: ch.remoteId,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ch.sendMessage(msg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ch *channel) ChannelType() string {
0000000000000000000000000000000000000000;;		return ch.chanType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ch *channel) ExtraData() []byte {
0000000000000000000000000000000000000000;;		return ch.extraData
0000000000000000000000000000000000000000;;	}
