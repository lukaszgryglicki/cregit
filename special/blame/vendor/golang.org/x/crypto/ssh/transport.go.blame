0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d05faf3fd63586437e38382c48fa03d7bd30de0c;Godeps/_workspace/src/golang.org/x/crypto/ssh/transport.go[Godeps/_workspace/src/golang.org/x/crypto/ssh/transport.go][vendor/golang.org/x/crypto/ssh/transport.go];	
0000000000000000000000000000000000000000;;	package ssh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		gcmCipherID    = "aes128-gcm@openssh.com"
0000000000000000000000000000000000000000;;		aes128cbcID    = "aes128-cbc"
0000000000000000000000000000000000000000;;		tripledescbcID = "3des-cbc"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// packetConn represents a transport that implements packet based
0000000000000000000000000000000000000000;;	// operations.
0000000000000000000000000000000000000000;;	type packetConn interface {
0000000000000000000000000000000000000000;;		// Encrypt and send a packet of data to the remote peer.
0000000000000000000000000000000000000000;;		writePacket(packet []byte) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read a packet from the connection
0000000000000000000000000000000000000000;;		readPacket() ([]byte, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close closes the write-side of the connection.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transport is the keyingTransport that implements the SSH packet
0000000000000000000000000000000000000000;;	// protocol.
0000000000000000000000000000000000000000;;	type transport struct {
0000000000000000000000000000000000000000;;		reader connectionState
0000000000000000000000000000000000000000;;		writer connectionState
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bufReader *bufio.Reader
0000000000000000000000000000000000000000;;		bufWriter *bufio.Writer
0000000000000000000000000000000000000000;;		rand      io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		io.Closer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// packetCipher represents a combination of SSH encryption/MAC
0000000000000000000000000000000000000000;;	// protocol.  A single instance should be used for one direction only.
0000000000000000000000000000000000000000;;	type packetCipher interface {
0000000000000000000000000000000000000000;;		// writePacket encrypts the packet and writes it to w. The
0000000000000000000000000000000000000000;;		// contents of the packet are generally scrambled.
0000000000000000000000000000000000000000;;		writePacket(seqnum uint32, w io.Writer, rand io.Reader, packet []byte) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readPacket reads and decrypts a packet of data. The
0000000000000000000000000000000000000000;;		// returned packet may be overwritten by future calls of
0000000000000000000000000000000000000000;;		// readPacket.
0000000000000000000000000000000000000000;;		readPacket(seqnum uint32, r io.Reader) ([]byte, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// connectionState represents one side (read or write) of the
0000000000000000000000000000000000000000;;	// connection. This is necessary because each direction has its own
0000000000000000000000000000000000000000;;	// keys, and can even have its own algorithms
0000000000000000000000000000000000000000;;	type connectionState struct {
0000000000000000000000000000000000000000;;		packetCipher
0000000000000000000000000000000000000000;;		seqNum           uint32
0000000000000000000000000000000000000000;;		dir              direction
0000000000000000000000000000000000000000;;		pendingKeyChange chan packetCipher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prepareKeyChange sets up key material for a keychange. The key changes in
0000000000000000000000000000000000000000;;	// both directions are triggered by reading and writing a msgNewKey packet
0000000000000000000000000000000000000000;;	// respectively.
0000000000000000000000000000000000000000;;	func (t *transport) prepareKeyChange(algs *algorithms, kexResult *kexResult) error {
0000000000000000000000000000000000000000;;		if ciph, err := newPacketCipher(t.reader.dir, algs.r, kexResult); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.reader.pendingKeyChange <- ciph
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ciph, err := newPacketCipher(t.writer.dir, algs.w, kexResult); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.writer.pendingKeyChange <- ciph
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read and decrypt next packet.
0000000000000000000000000000000000000000;;	func (t *transport) readPacket() ([]byte, error) {
0000000000000000000000000000000000000000;;		return t.reader.readPacket(t.bufReader)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *connectionState) readPacket(r *bufio.Reader) ([]byte, error) {
0000000000000000000000000000000000000000;;		packet, err := s.packetCipher.readPacket(s.seqNum, r)
0000000000000000000000000000000000000000;;		s.seqNum++
0000000000000000000000000000000000000000;;		if err == nil && len(packet) == 0 {
0000000000000000000000000000000000000000;;			err = errors.New("ssh: zero length packet")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(packet) > 0 {
0000000000000000000000000000000000000000;;			switch packet[0] {
0000000000000000000000000000000000000000;;			case msgNewKeys:
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case cipher := <-s.pendingKeyChange:
0000000000000000000000000000000000000000;;					s.packetCipher = cipher
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, errors.New("ssh: got bogus newkeys message.")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case msgDisconnect:
0000000000000000000000000000000000000000;;				// Transform a disconnect message into an
0000000000000000000000000000000000000000;;				// error. Since this is lowest level at which
0000000000000000000000000000000000000000;;				// we interpret message types, doing it here
0000000000000000000000000000000000000000;;				// ensures that we don't have to handle it
0000000000000000000000000000000000000000;;				// elsewhere.
0000000000000000000000000000000000000000;;				var msg disconnectMsg
0000000000000000000000000000000000000000;;				if err := Unmarshal(packet, &msg); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, &msg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The packet may point to an internal buffer, so copy the
0000000000000000000000000000000000000000;;		// packet out here.
0000000000000000000000000000000000000000;;		fresh := make([]byte, len(packet))
0000000000000000000000000000000000000000;;		copy(fresh, packet)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fresh, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *transport) writePacket(packet []byte) error {
0000000000000000000000000000000000000000;;		return t.writer.writePacket(t.bufWriter, t.rand, packet)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *connectionState) writePacket(w *bufio.Writer, rand io.Reader, packet []byte) error {
0000000000000000000000000000000000000000;;		changeKeys := len(packet) > 0 && packet[0] == msgNewKeys
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := s.packetCipher.writePacket(s.seqNum, w, rand, packet)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = w.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.seqNum++
0000000000000000000000000000000000000000;;		if changeKeys {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case cipher := <-s.pendingKeyChange:
0000000000000000000000000000000000000000;;				s.packetCipher = cipher
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("ssh: no key material for msgNewKeys")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTransport(rwc io.ReadWriteCloser, rand io.Reader, isClient bool) *transport {
0000000000000000000000000000000000000000;;		t := &transport{
0000000000000000000000000000000000000000;;			bufReader: bufio.NewReader(rwc),
0000000000000000000000000000000000000000;;			bufWriter: bufio.NewWriter(rwc),
0000000000000000000000000000000000000000;;			rand:      rand,
0000000000000000000000000000000000000000;;			reader: connectionState{
0000000000000000000000000000000000000000;;				packetCipher:     &streamPacketCipher{cipher: noneCipher{}},
0000000000000000000000000000000000000000;;				pendingKeyChange: make(chan packetCipher, 1),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			writer: connectionState{
0000000000000000000000000000000000000000;;				packetCipher:     &streamPacketCipher{cipher: noneCipher{}},
0000000000000000000000000000000000000000;;				pendingKeyChange: make(chan packetCipher, 1),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Closer: rwc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isClient {
0000000000000000000000000000000000000000;;			t.reader.dir = serverKeys
0000000000000000000000000000000000000000;;			t.writer.dir = clientKeys
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.reader.dir = clientKeys
0000000000000000000000000000000000000000;;			t.writer.dir = serverKeys
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type direction struct {
0000000000000000000000000000000000000000;;		ivTag     []byte
0000000000000000000000000000000000000000;;		keyTag    []byte
0000000000000000000000000000000000000000;;		macKeyTag []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		serverKeys = direction{[]byte{'B'}, []byte{'D'}, []byte{'F'}}
0000000000000000000000000000000000000000;;		clientKeys = direction{[]byte{'A'}, []byte{'C'}, []byte{'E'}}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateKeys generates key material for IV, MAC and encryption.
0000000000000000000000000000000000000000;;	func generateKeys(d direction, algs directionAlgorithms, kex *kexResult) (iv, key, macKey []byte) {
0000000000000000000000000000000000000000;;		cipherMode := cipherModes[algs.Cipher]
0000000000000000000000000000000000000000;;		macMode := macModes[algs.MAC]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iv = make([]byte, cipherMode.ivSize)
0000000000000000000000000000000000000000;;		key = make([]byte, cipherMode.keySize)
0000000000000000000000000000000000000000;;		macKey = make([]byte, macMode.keySize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generateKeyMaterial(iv, d.ivTag, kex)
0000000000000000000000000000000000000000;;		generateKeyMaterial(key, d.keyTag, kex)
0000000000000000000000000000000000000000;;		generateKeyMaterial(macKey, d.macKeyTag, kex)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setupKeys sets the cipher and MAC keys from kex.K, kex.H and sessionId, as
0000000000000000000000000000000000000000;;	// described in RFC 4253, section 6.4. direction should either be serverKeys
0000000000000000000000000000000000000000;;	// (to setup server->client keys) or clientKeys (for client->server keys).
0000000000000000000000000000000000000000;;	func newPacketCipher(d direction, algs directionAlgorithms, kex *kexResult) (packetCipher, error) {
0000000000000000000000000000000000000000;;		iv, key, macKey := generateKeys(d, algs, kex)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if algs.Cipher == gcmCipherID {
0000000000000000000000000000000000000000;;			return newGCMCipher(iv, key, macKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if algs.Cipher == aes128cbcID {
0000000000000000000000000000000000000000;;			return newAESCBCCipher(iv, key, macKey, algs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if algs.Cipher == tripledescbcID {
0000000000000000000000000000000000000000;;			return newTripleDESCBCCipher(iv, key, macKey, algs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &streamPacketCipher{
0000000000000000000000000000000000000000;;			mac: macModes[algs.MAC].new(macKey),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.macResult = make([]byte, c.mac.Size())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		c.cipher, err = cipherModes[algs.Cipher].createStream(key, iv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateKeyMaterial fills out with key material generated from tag, K, H
0000000000000000000000000000000000000000;;	// and sessionId, as specified in RFC 4253, section 7.2.
0000000000000000000000000000000000000000;;	func generateKeyMaterial(out, tag []byte, r *kexResult) {
0000000000000000000000000000000000000000;;		var digestsSoFar []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := r.Hash.New()
0000000000000000000000000000000000000000;;		for len(out) > 0 {
0000000000000000000000000000000000000000;;			h.Reset()
0000000000000000000000000000000000000000;;			h.Write(r.K)
0000000000000000000000000000000000000000;;			h.Write(r.H)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(digestsSoFar) == 0 {
0000000000000000000000000000000000000000;;				h.Write(tag)
0000000000000000000000000000000000000000;;				h.Write(r.SessionID)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				h.Write(digestsSoFar)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			digest := h.Sum(nil)
0000000000000000000000000000000000000000;;			n := copy(out, digest)
0000000000000000000000000000000000000000;;			out = out[n:]
0000000000000000000000000000000000000000;;			if len(out) > 0 {
0000000000000000000000000000000000000000;;				digestsSoFar = append(digestsSoFar, digest...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const packageVersion = "SSH-2.0-Go"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sends and receives a version line.  The versionLine string should
0000000000000000000000000000000000000000;;	// be US ASCII, start with "SSH-2.0-", and should not include a
0000000000000000000000000000000000000000;;	// newline. exchangeVersions returns the other side's version line.
0000000000000000000000000000000000000000;;	func exchangeVersions(rw io.ReadWriter, versionLine []byte) (them []byte, err error) {
0000000000000000000000000000000000000000;;		// Contrary to the RFC, we do not ignore lines that don't
0000000000000000000000000000000000000000;;		// start with "SSH-2.0-" to make the library usable with
0000000000000000000000000000000000000000;;		// nonconforming servers.
0000000000000000000000000000000000000000;;		for _, c := range versionLine {
0000000000000000000000000000000000000000;;			// The spec disallows non US-ASCII chars, and
0000000000000000000000000000000000000000;;			// specifically forbids null chars.
0000000000000000000000000000000000000000;;			if c < 32 {
0000000000000000000000000000000000000000;;				return nil, errors.New("ssh: junk character in version line")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err = rw.Write(append(versionLine, '\r', '\n')); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		them, err = readVersion(rw)
0000000000000000000000000000000000000000;;		return them, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxVersionStringBytes is the maximum number of bytes that we'll
0000000000000000000000000000000000000000;;	// accept as a version string. RFC 4253 section 4.2 limits this at 255
0000000000000000000000000000000000000000;;	// chars
0000000000000000000000000000000000000000;;	const maxVersionStringBytes = 255
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read version string as specified by RFC 4253, section 4.2.
0000000000000000000000000000000000000000;;	func readVersion(r io.Reader) ([]byte, error) {
0000000000000000000000000000000000000000;;		versionString := make([]byte, 0, 64)
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		var buf [1]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(versionString) < maxVersionStringBytes {
0000000000000000000000000000000000000000;;			_, err := io.ReadFull(r, buf[:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// The RFC says that the version should be terminated with \r\n
0000000000000000000000000000000000000000;;			// but several SSH servers actually only send a \n.
0000000000000000000000000000000000000000;;			if buf[0] == '\n' {
0000000000000000000000000000000000000000;;				ok = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// non ASCII chars are disallowed, but we are lenient,
0000000000000000000000000000000000000000;;			// since Go doesn't use null-terminated strings.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The RFC allows a comment after a space, however,
0000000000000000000000000000000000000000;;			// all of it (version and comments) goes into the
0000000000000000000000000000000000000000;;			// session hash.
0000000000000000000000000000000000000000;;			versionString = append(versionString, buf[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("ssh: overflow reading version string")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There might be a '\r' on the end which we should remove.
0000000000000000000000000000000000000000;;		if len(versionString) > 0 && versionString[len(versionString)-1] == '\r' {
0000000000000000000000000000000000000000;;			versionString = versionString[:len(versionString)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return versionString, nil
0000000000000000000000000000000000000000;;	}
