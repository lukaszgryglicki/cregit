0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/golang.org/x/crypto/blowfish/block.go[Godeps/_workspace/src/golang.org/x/crypto/blowfish/block.go][vendor/golang.org/x/crypto/blowfish/block.go];	
0000000000000000000000000000000000000000;;	package blowfish
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNextWord returns the next big-endian uint32 value from the byte slice
0000000000000000000000000000000000000000;;	// at the given position in a circular manner, updating the position.
0000000000000000000000000000000000000000;;	func getNextWord(b []byte, pos *int) uint32 {
0000000000000000000000000000000000000000;;		var w uint32
0000000000000000000000000000000000000000;;		j := *pos
0000000000000000000000000000000000000000;;		for i := 0; i < 4; i++ {
0000000000000000000000000000000000000000;;			w = w<<8 | uint32(b[j])
0000000000000000000000000000000000000000;;			j++
0000000000000000000000000000000000000000;;			if j >= len(b) {
0000000000000000000000000000000000000000;;				j = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*pos = j
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpandKey performs a key expansion on the given *Cipher. Specifically, it
0000000000000000000000000000000000000000;;	// performs the Blowfish algorithm's key schedule which sets up the *Cipher's
0000000000000000000000000000000000000000;;	// pi and substitution tables for calls to Encrypt. This is used, primarily,
0000000000000000000000000000000000000000;;	// by the bcrypt package to reuse the Blowfish key schedule during its
0000000000000000000000000000000000000000;;	// set up. It's unlikely that you need to use this directly.
0000000000000000000000000000000000000000;;	func ExpandKey(key []byte, c *Cipher) {
0000000000000000000000000000000000000000;;		j := 0
0000000000000000000000000000000000000000;;		for i := 0; i < 18; i++ {
0000000000000000000000000000000000000000;;			// Using inlined getNextWord for performance.
0000000000000000000000000000000000000000;;			var d uint32
0000000000000000000000000000000000000000;;			for k := 0; k < 4; k++ {
0000000000000000000000000000000000000000;;				d = d<<8 | uint32(key[j])
0000000000000000000000000000000000000000;;				j++
0000000000000000000000000000000000000000;;				if j >= len(key) {
0000000000000000000000000000000000000000;;					j = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.p[i] ^= d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var l, r uint32
0000000000000000000000000000000000000000;;		for i := 0; i < 18; i += 2 {
0000000000000000000000000000000000000000;;			l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;			c.p[i], c.p[i+1] = l, r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i += 2 {
0000000000000000000000000000000000000000;;			l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;			c.s0[i], c.s0[i+1] = l, r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i += 2 {
0000000000000000000000000000000000000000;;			l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;			c.s1[i], c.s1[i+1] = l, r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i += 2 {
0000000000000000000000000000000000000000;;			l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;			c.s2[i], c.s2[i+1] = l, r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i += 2 {
0000000000000000000000000000000000000000;;			l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;			c.s3[i], c.s3[i+1] = l, r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is similar to ExpandKey, but folds the salt during the key
0000000000000000000000000000000000000000;;	// schedule. While ExpandKey is essentially expandKeyWithSalt with an all-zero
0000000000000000000000000000000000000000;;	// salt passed in, reusing ExpandKey turns out to be a place of inefficiency
0000000000000000000000000000000000000000;;	// and specializing it here is useful.
0000000000000000000000000000000000000000;;	func expandKeyWithSalt(key []byte, salt []byte, c *Cipher) {
0000000000000000000000000000000000000000;;		j := 0
0000000000000000000000000000000000000000;;		for i := 0; i < 18; i++ {
0000000000000000000000000000000000000000;;			c.p[i] ^= getNextWord(key, &j)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j = 0
0000000000000000000000000000000000000000;;		var l, r uint32
0000000000000000000000000000000000000000;;		for i := 0; i < 18; i += 2 {
0000000000000000000000000000000000000000;;			l ^= getNextWord(salt, &j)
0000000000000000000000000000000000000000;;			r ^= getNextWord(salt, &j)
0000000000000000000000000000000000000000;;			l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;			c.p[i], c.p[i+1] = l, r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i += 2 {
0000000000000000000000000000000000000000;;			l ^= getNextWord(salt, &j)
0000000000000000000000000000000000000000;;			r ^= getNextWord(salt, &j)
0000000000000000000000000000000000000000;;			l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;			c.s0[i], c.s0[i+1] = l, r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i += 2 {
0000000000000000000000000000000000000000;;			l ^= getNextWord(salt, &j)
0000000000000000000000000000000000000000;;			r ^= getNextWord(salt, &j)
0000000000000000000000000000000000000000;;			l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;			c.s1[i], c.s1[i+1] = l, r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i += 2 {
0000000000000000000000000000000000000000;;			l ^= getNextWord(salt, &j)
0000000000000000000000000000000000000000;;			r ^= getNextWord(salt, &j)
0000000000000000000000000000000000000000;;			l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;			c.s2[i], c.s2[i+1] = l, r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < 256; i += 2 {
0000000000000000000000000000000000000000;;			l ^= getNextWord(salt, &j)
0000000000000000000000000000000000000000;;			r ^= getNextWord(salt, &j)
0000000000000000000000000000000000000000;;			l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;			c.s3[i], c.s3[i+1] = l, r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encryptBlock(l, r uint32, c *Cipher) (uint32, uint32) {
0000000000000000000000000000000000000000;;		xl, xr := l, r
0000000000000000000000000000000000000000;;		xl ^= c.p[0]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[1]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[2]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[3]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[4]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[5]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[6]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[7]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[8]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[9]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[10]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[11]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[12]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[13]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[14]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[15]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[16]
0000000000000000000000000000000000000000;;		xr ^= c.p[17]
0000000000000000000000000000000000000000;;		return xr, xl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decryptBlock(l, r uint32, c *Cipher) (uint32, uint32) {
0000000000000000000000000000000000000000;;		xl, xr := l, r
0000000000000000000000000000000000000000;;		xl ^= c.p[17]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[16]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[15]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[14]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[13]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[12]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[11]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[10]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[9]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[8]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[7]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[6]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[5]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[4]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[3]
0000000000000000000000000000000000000000;;		xr ^= ((c.s0[byte(xl>>24)] + c.s1[byte(xl>>16)]) ^ c.s2[byte(xl>>8)]) + c.s3[byte(xl)] ^ c.p[2]
0000000000000000000000000000000000000000;;		xl ^= ((c.s0[byte(xr>>24)] + c.s1[byte(xr>>16)]) ^ c.s2[byte(xr>>8)]) + c.s3[byte(xr)] ^ c.p[1]
0000000000000000000000000000000000000000;;		xr ^= c.p[0]
0000000000000000000000000000000000000000;;		return xr, xl
0000000000000000000000000000000000000000;;	}
