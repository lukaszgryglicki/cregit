0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/golang.org/x/crypto/blowfish/cipher.go[Godeps/_workspace/src/golang.org/x/crypto/blowfish/cipher.go][vendor/golang.org/x/crypto/blowfish/cipher.go];	
0000000000000000000000000000000000000000;;	// Package blowfish implements Bruce Schneier's Blowfish encryption algorithm.
0000000000000000000000000000000000000000;;	package blowfish
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The code is a port of Bruce Schneier's C implementation.
0000000000000000000000000000000000000000;;	// See http://www.schneier.com/blowfish.html.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Blowfish block size in bytes.
0000000000000000000000000000000000000000;;	const BlockSize = 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Cipher is an instance of Blowfish encryption using a particular key.
0000000000000000000000000000000000000000;;	type Cipher struct {
0000000000000000000000000000000000000000;;		p              [18]uint32
0000000000000000000000000000000000000000;;		s0, s1, s2, s3 [256]uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KeySizeError int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k KeySizeError) Error() string {
0000000000000000000000000000000000000000;;		return "crypto/blowfish: invalid key size " + strconv.Itoa(int(k))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCipher creates and returns a Cipher.
0000000000000000000000000000000000000000;;	// The key argument should be the Blowfish key, from 1 to 56 bytes.
0000000000000000000000000000000000000000;;	func NewCipher(key []byte) (*Cipher, error) {
0000000000000000000000000000000000000000;;		var result Cipher
0000000000000000000000000000000000000000;;		if k := len(key); k < 1 || k > 56 {
0000000000000000000000000000000000000000;;			return nil, KeySizeError(k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		initCipher(&result)
0000000000000000000000000000000000000000;;		ExpandKey(key, &result)
0000000000000000000000000000000000000000;;		return &result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSaltedCipher creates a returns a Cipher that folds a salt into its key
0000000000000000000000000000000000000000;;	// schedule. For most purposes, NewCipher, instead of NewSaltedCipher, is
0000000000000000000000000000000000000000;;	// sufficient and desirable. For bcrypt compatibility, the key can be over 56
0000000000000000000000000000000000000000;;	// bytes.
0000000000000000000000000000000000000000;;	func NewSaltedCipher(key, salt []byte) (*Cipher, error) {
0000000000000000000000000000000000000000;;		if len(salt) == 0 {
0000000000000000000000000000000000000000;;			return NewCipher(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var result Cipher
0000000000000000000000000000000000000000;;		if k := len(key); k < 1 {
0000000000000000000000000000000000000000;;			return nil, KeySizeError(k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		initCipher(&result)
0000000000000000000000000000000000000000;;		expandKeyWithSalt(key, salt, &result)
0000000000000000000000000000000000000000;;		return &result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BlockSize returns the Blowfish block size, 8 bytes.
0000000000000000000000000000000000000000;;	// It is necessary to satisfy the Block interface in the
0000000000000000000000000000000000000000;;	// package "crypto/cipher".
0000000000000000000000000000000000000000;;	func (c *Cipher) BlockSize() int { return BlockSize }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encrypt encrypts the 8-byte buffer src using the key k
0000000000000000000000000000000000000000;;	// and stores the result in dst.
0000000000000000000000000000000000000000;;	// Note that for amounts of data larger than a block,
0000000000000000000000000000000000000000;;	// it is not safe to just call Encrypt on successive blocks;
0000000000000000000000000000000000000000;;	// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).
0000000000000000000000000000000000000000;;	func (c *Cipher) Encrypt(dst, src []byte) {
0000000000000000000000000000000000000000;;		l := uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])
0000000000000000000000000000000000000000;;		r := uint32(src[4])<<24 | uint32(src[5])<<16 | uint32(src[6])<<8 | uint32(src[7])
0000000000000000000000000000000000000000;;		l, r = encryptBlock(l, r, c)
0000000000000000000000000000000000000000;;		dst[0], dst[1], dst[2], dst[3] = byte(l>>24), byte(l>>16), byte(l>>8), byte(l)
0000000000000000000000000000000000000000;;		dst[4], dst[5], dst[6], dst[7] = byte(r>>24), byte(r>>16), byte(r>>8), byte(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decrypt decrypts the 8-byte buffer src using the key k
0000000000000000000000000000000000000000;;	// and stores the result in dst.
0000000000000000000000000000000000000000;;	func (c *Cipher) Decrypt(dst, src []byte) {
0000000000000000000000000000000000000000;;		l := uint32(src[0])<<24 | uint32(src[1])<<16 | uint32(src[2])<<8 | uint32(src[3])
0000000000000000000000000000000000000000;;		r := uint32(src[4])<<24 | uint32(src[5])<<16 | uint32(src[6])<<8 | uint32(src[7])
0000000000000000000000000000000000000000;;		l, r = decryptBlock(l, r, c)
0000000000000000000000000000000000000000;;		dst[0], dst[1], dst[2], dst[3] = byte(l>>24), byte(l>>16), byte(l>>8), byte(l)
0000000000000000000000000000000000000000;;		dst[4], dst[5], dst[6], dst[7] = byte(r>>24), byte(r>>16), byte(r>>8), byte(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initCipher(c *Cipher) {
0000000000000000000000000000000000000000;;		copy(c.p[0:], p[0:])
0000000000000000000000000000000000000000;;		copy(c.s0[0:], s0[0:])
0000000000000000000000000000000000000000;;		copy(c.s1[0:], s1[0:])
0000000000000000000000000000000000000000;;		copy(c.s2[0:], s2[0:])
0000000000000000000000000000000000000000;;		copy(c.s3[0:], s3[0:])
0000000000000000000000000000000000000000;;	}
