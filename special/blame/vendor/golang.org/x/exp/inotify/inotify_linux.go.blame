0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/code.google.com/p/go.exp/inotify/inotify_linux.go[Godeps/_workspace/src/code.google.com/p/go.exp/inotify/inotify_linux.go][vendor/golang.org/x/exp/inotify/inotify_linux.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package inotify implements a wrapper for the Linux inotify system.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example:
0000000000000000000000000000000000000000;;	    watcher, err := inotify.NewWatcher()
0000000000000000000000000000000000000000;;	    if err != nil {
0000000000000000000000000000000000000000;;	        log.Fatal(err)
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	    err = watcher.Watch("/tmp")
0000000000000000000000000000000000000000;;	    if err != nil {
0000000000000000000000000000000000000000;;	        log.Fatal(err)
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	    for {
0000000000000000000000000000000000000000;;	        select {
0000000000000000000000000000000000000000;;	        case ev := <-watcher.Event:
0000000000000000000000000000000000000000;;	            log.Println("event:", ev)
0000000000000000000000000000000000000000;;	        case err := <-watcher.Error:
0000000000000000000000000000000000000000;;	            log.Println("error:", err)
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package inotify
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Event struct {
0000000000000000000000000000000000000000;;		Mask   uint32 // Mask of events
0000000000000000000000000000000000000000;;		Cookie uint32 // Unique cookie associating related events (for rename(2))
0000000000000000000000000000000000000000;;		Name   string // File name (optional)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watch struct {
0000000000000000000000000000000000000000;;		wd    uint32 // Watch descriptor (as returned by the inotify_add_watch() syscall)
0000000000000000000000000000000000000000;;		flags uint32 // inotify flags of this watch (see inotify(7) for the list of valid flags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Watcher struct {
0000000000000000000000000000000000000000;;		mu       sync.Mutex
0000000000000000000000000000000000000000;;		fd       int               // File descriptor (as returned by the inotify_init() syscall)
0000000000000000000000000000000000000000;;		watches  map[string]*watch // Map of inotify watches (key: path)
0000000000000000000000000000000000000000;;		paths    map[int]string    // Map of watched paths (key: watch descriptor)
0000000000000000000000000000000000000000;;		Error    chan error        // Errors are sent on this channel
0000000000000000000000000000000000000000;;		Event    chan *Event       // Events are returned on this channel
0000000000000000000000000000000000000000;;		done     chan bool         // Channel for sending a "quit message" to the reader goroutine
0000000000000000000000000000000000000000;;		isClosed bool              // Set to true when Close() is first called
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWatcher creates and returns a new inotify instance using inotify_init(2)
0000000000000000000000000000000000000000;;	func NewWatcher() (*Watcher, error) {
0000000000000000000000000000000000000000;;		fd, errno := syscall.InotifyInit()
0000000000000000000000000000000000000000;;		if fd == -1 {
0000000000000000000000000000000000000000;;			return nil, os.NewSyscallError("inotify_init", errno)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w := &Watcher{
0000000000000000000000000000000000000000;;			fd:      fd,
0000000000000000000000000000000000000000;;			watches: make(map[string]*watch),
0000000000000000000000000000000000000000;;			paths:   make(map[int]string),
0000000000000000000000000000000000000000;;			Event:   make(chan *Event),
0000000000000000000000000000000000000000;;			Error:   make(chan error),
0000000000000000000000000000000000000000;;			done:    make(chan bool, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go w.readEvents()
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes an inotify watcher instance
0000000000000000000000000000000000000000;;	// It sends a message to the reader goroutine to quit and removes all watches
0000000000000000000000000000000000000000;;	// associated with the inotify instance
0000000000000000000000000000000000000000;;	func (w *Watcher) Close() error {
0000000000000000000000000000000000000000;;		if w.isClosed {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.isClosed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send "quit" message to the reader goroutine
0000000000000000000000000000000000000000;;		w.done <- true
0000000000000000000000000000000000000000;;		for path := range w.watches {
0000000000000000000000000000000000000000;;			w.RemoveWatch(path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddWatch adds path to the watched file set.
0000000000000000000000000000000000000000;;	// The flags are interpreted as described in inotify_add_watch(2).
0000000000000000000000000000000000000000;;	func (w *Watcher) AddWatch(path string, flags uint32) error {
0000000000000000000000000000000000000000;;		if w.isClosed {
0000000000000000000000000000000000000000;;			return errors.New("inotify instance already closed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watchEntry, found := w.watches[path]
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			watchEntry.flags |= flags
0000000000000000000000000000000000000000;;			flags |= syscall.IN_MASK_ADD
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.mu.Lock() // synchronize with readEvents goroutine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wd, err := syscall.InotifyAddWatch(w.fd, path, flags)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;			return &os.PathError{
0000000000000000000000000000000000000000;;				Op:   "inotify_add_watch",
0000000000000000000000000000000000000000;;				Path: path,
0000000000000000000000000000000000000000;;				Err:  err,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			w.watches[path] = &watch{wd: uint32(wd), flags: flags}
0000000000000000000000000000000000000000;;			w.paths[wd] = path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch adds path to the watched file set, watching all events.
0000000000000000000000000000000000000000;;	func (w *Watcher) Watch(path string) error {
0000000000000000000000000000000000000000;;		return w.AddWatch(path, IN_ALL_EVENTS)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveWatch removes path from the watched file set.
0000000000000000000000000000000000000000;;	func (w *Watcher) RemoveWatch(path string) error {
0000000000000000000000000000000000000000;;		watch, ok := w.watches[path]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New(fmt.Sprintf("can't remove non-existent inotify watch for: %s", path))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		success, errno := syscall.InotifyRmWatch(w.fd, watch.wd)
0000000000000000000000000000000000000000;;		if success == -1 {
0000000000000000000000000000000000000000;;			return os.NewSyscallError("inotify_rm_watch", errno)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(w.watches, path)
0000000000000000000000000000000000000000;;		// Locking here to protect the read from paths in readEvents.
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		delete(w.paths, int(watch.wd))
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readEvents reads from the inotify file descriptor, converts the
0000000000000000000000000000000000000000;;	// received events into Event objects and sends them via the Event channel
0000000000000000000000000000000000000000;;	func (w *Watcher) readEvents() {
0000000000000000000000000000000000000000;;		var buf [syscall.SizeofInotifyEvent * 4096]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n, err := syscall.Read(w.fd, buf[:])
0000000000000000000000000000000000000000;;			// See if there is a message on the "done" channel
0000000000000000000000000000000000000000;;			var done bool
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case done = <-w.done:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If EOF or a "done" message is received
0000000000000000000000000000000000000000;;			if n == 0 || done {
0000000000000000000000000000000000000000;;				// The syscall.Close can be slow.  Close
0000000000000000000000000000000000000000;;				// w.Event first.
0000000000000000000000000000000000000000;;				close(w.Event)
0000000000000000000000000000000000000000;;				err := syscall.Close(w.fd)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					w.Error <- os.NewSyscallError("close", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				close(w.Error)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n < 0 {
0000000000000000000000000000000000000000;;				w.Error <- os.NewSyscallError("read", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n < syscall.SizeofInotifyEvent {
0000000000000000000000000000000000000000;;				w.Error <- errors.New("inotify: short read in readEvents()")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var offset uint32 = 0
0000000000000000000000000000000000000000;;			// We don't know how many events we just read into the buffer
0000000000000000000000000000000000000000;;			// While the offset points to at least one whole event...
0000000000000000000000000000000000000000;;			for offset <= uint32(n-syscall.SizeofInotifyEvent) {
0000000000000000000000000000000000000000;;				// Point "raw" to the event in the buffer
0000000000000000000000000000000000000000;;				raw := (*syscall.InotifyEvent)(unsafe.Pointer(&buf[offset]))
0000000000000000000000000000000000000000;;				event := new(Event)
0000000000000000000000000000000000000000;;				event.Mask = uint32(raw.Mask)
0000000000000000000000000000000000000000;;				event.Cookie = uint32(raw.Cookie)
0000000000000000000000000000000000000000;;				nameLen := uint32(raw.Len)
0000000000000000000000000000000000000000;;				// If the event happened to the watched directory or the watched file, the kernel
0000000000000000000000000000000000000000;;				// doesn't append the filename to the event, but we would like to always fill the
0000000000000000000000000000000000000000;;				// the "Name" field with a valid filename. We retrieve the path of the watch from
0000000000000000000000000000000000000000;;				// the "paths" map.
0000000000000000000000000000000000000000;;				w.mu.Lock()
0000000000000000000000000000000000000000;;				name, ok := w.paths[int(raw.Wd)]
0000000000000000000000000000000000000000;;				w.mu.Unlock()
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					event.Name = name
0000000000000000000000000000000000000000;;					if nameLen > 0 {
0000000000000000000000000000000000000000;;						// Point "bytes" at the first byte of the filename
0000000000000000000000000000000000000000;;						bytes := (*[syscall.PathMax]byte)(unsafe.Pointer(&buf[offset+syscall.SizeofInotifyEvent]))
0000000000000000000000000000000000000000;;						// The filename is padded with NUL bytes. TrimRight() gets rid of those.
0000000000000000000000000000000000000000;;						event.Name += "/" + strings.TrimRight(string(bytes[0:nameLen]), "\000")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Send the event on the events channel
0000000000000000000000000000000000000000;;					w.Event <- event
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Move to the next event in the buffer
0000000000000000000000000000000000000000;;				offset += syscall.SizeofInotifyEvent + nameLen
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String formats the event e in the form
0000000000000000000000000000000000000000;;	// "filename: 0xEventMask = IN_ACCESS|IN_ATTRIB_|..."
0000000000000000000000000000000000000000;;	func (e *Event) String() string {
0000000000000000000000000000000000000000;;		var events string = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := e.Mask
0000000000000000000000000000000000000000;;		for _, b := range eventBits {
0000000000000000000000000000000000000000;;			if m&b.Value == b.Value {
0000000000000000000000000000000000000000;;				m &^= b.Value
0000000000000000000000000000000000000000;;				events += "|" + b.Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m != 0 {
0000000000000000000000000000000000000000;;			events += fmt.Sprintf("|%#x", m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(events) > 0 {
0000000000000000000000000000000000000000;;			events = " == " + events[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%q: %#x%s", e.Name, e.Mask, events)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Options for inotify_init() are not exported
0000000000000000000000000000000000000000;;		// IN_CLOEXEC    uint32 = syscall.IN_CLOEXEC
0000000000000000000000000000000000000000;;		// IN_NONBLOCK   uint32 = syscall.IN_NONBLOCK
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Options for AddWatch
0000000000000000000000000000000000000000;;		IN_DONT_FOLLOW uint32 = syscall.IN_DONT_FOLLOW
0000000000000000000000000000000000000000;;		IN_ONESHOT     uint32 = syscall.IN_ONESHOT
0000000000000000000000000000000000000000;;		IN_ONLYDIR     uint32 = syscall.IN_ONLYDIR
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The "IN_MASK_ADD" option is not exported, as AddWatch
0000000000000000000000000000000000000000;;		// adds it automatically, if there is already a watch for the given path
0000000000000000000000000000000000000000;;		// IN_MASK_ADD      uint32 = syscall.IN_MASK_ADD
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Events
0000000000000000000000000000000000000000;;		IN_ACCESS        uint32 = syscall.IN_ACCESS
0000000000000000000000000000000000000000;;		IN_ALL_EVENTS    uint32 = syscall.IN_ALL_EVENTS
0000000000000000000000000000000000000000;;		IN_ATTRIB        uint32 = syscall.IN_ATTRIB
0000000000000000000000000000000000000000;;		IN_CLOSE         uint32 = syscall.IN_CLOSE
0000000000000000000000000000000000000000;;		IN_CLOSE_NOWRITE uint32 = syscall.IN_CLOSE_NOWRITE
0000000000000000000000000000000000000000;;		IN_CLOSE_WRITE   uint32 = syscall.IN_CLOSE_WRITE
0000000000000000000000000000000000000000;;		IN_CREATE        uint32 = syscall.IN_CREATE
0000000000000000000000000000000000000000;;		IN_DELETE        uint32 = syscall.IN_DELETE
0000000000000000000000000000000000000000;;		IN_DELETE_SELF   uint32 = syscall.IN_DELETE_SELF
0000000000000000000000000000000000000000;;		IN_MODIFY        uint32 = syscall.IN_MODIFY
0000000000000000000000000000000000000000;;		IN_MOVE          uint32 = syscall.IN_MOVE
0000000000000000000000000000000000000000;;		IN_MOVED_FROM    uint32 = syscall.IN_MOVED_FROM
0000000000000000000000000000000000000000;;		IN_MOVED_TO      uint32 = syscall.IN_MOVED_TO
0000000000000000000000000000000000000000;;		IN_MOVE_SELF     uint32 = syscall.IN_MOVE_SELF
0000000000000000000000000000000000000000;;		IN_OPEN          uint32 = syscall.IN_OPEN
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Special events
0000000000000000000000000000000000000000;;		IN_ISDIR      uint32 = syscall.IN_ISDIR
0000000000000000000000000000000000000000;;		IN_IGNORED    uint32 = syscall.IN_IGNORED
0000000000000000000000000000000000000000;;		IN_Q_OVERFLOW uint32 = syscall.IN_Q_OVERFLOW
0000000000000000000000000000000000000000;;		IN_UNMOUNT    uint32 = syscall.IN_UNMOUNT
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var eventBits = []struct {
0000000000000000000000000000000000000000;;		Value uint32
0000000000000000000000000000000000000000;;		Name  string
0000000000000000000000000000000000000000;;	}{
0000000000000000000000000000000000000000;;		{IN_ACCESS, "IN_ACCESS"},
0000000000000000000000000000000000000000;;		{IN_ATTRIB, "IN_ATTRIB"},
0000000000000000000000000000000000000000;;		{IN_CLOSE, "IN_CLOSE"},
0000000000000000000000000000000000000000;;		{IN_CLOSE_NOWRITE, "IN_CLOSE_NOWRITE"},
0000000000000000000000000000000000000000;;		{IN_CLOSE_WRITE, "IN_CLOSE_WRITE"},
0000000000000000000000000000000000000000;;		{IN_CREATE, "IN_CREATE"},
0000000000000000000000000000000000000000;;		{IN_DELETE, "IN_DELETE"},
0000000000000000000000000000000000000000;;		{IN_DELETE_SELF, "IN_DELETE_SELF"},
0000000000000000000000000000000000000000;;		{IN_MODIFY, "IN_MODIFY"},
0000000000000000000000000000000000000000;;		{IN_MOVE, "IN_MOVE"},
0000000000000000000000000000000000000000;;		{IN_MOVED_FROM, "IN_MOVED_FROM"},
0000000000000000000000000000000000000000;;		{IN_MOVED_TO, "IN_MOVED_TO"},
0000000000000000000000000000000000000000;;		{IN_MOVE_SELF, "IN_MOVE_SELF"},
0000000000000000000000000000000000000000;;		{IN_OPEN, "IN_OPEN"},
0000000000000000000000000000000000000000;;		{IN_ISDIR, "IN_ISDIR"},
0000000000000000000000000000000000000000;;		{IN_IGNORED, "IN_IGNORED"},
0000000000000000000000000000000000000000;;		{IN_Q_OVERFLOW, "IN_Q_OVERFLOW"},
0000000000000000000000000000000000000000;;		{IN_UNMOUNT, "IN_UNMOUNT"},
0000000000000000000000000000000000000000;;	}
