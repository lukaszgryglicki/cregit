0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/golang.org/x/oauth2/oauth2.go[Godeps/_workspace/src/golang.org/x/oauth2/oauth2.go][vendor/golang.org/x/oauth2/oauth2.go];	
0000000000000000000000000000000000000000;;	// Package oauth2 provides support for making
0000000000000000000000000000000000000000;;	// OAuth2 authorized and authenticated HTTP requests.
0000000000000000000000000000000000000000;;	// It can additionally grant authorization with Bearer JWT.
0000000000000000000000000000000000000000;;	package oauth2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/internal"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NoContext is the default context you should supply if not using
0000000000000000000000000000000000000000;;	// your own context.Context (see https://golang.org/x/net/context).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: Use context.Background() or context.TODO() instead.
0000000000000000000000000000000000000000;;	var NoContext = context.TODO()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterBrokenAuthHeaderProvider registers an OAuth2 server
0000000000000000000000000000000000000000;;	// identified by the tokenURL prefix as an OAuth2 implementation
0000000000000000000000000000000000000000;;	// which doesn't support the HTTP Basic authentication
0000000000000000000000000000000000000000;;	// scheme to authenticate with the authorization server.
0000000000000000000000000000000000000000;;	// Once a server is registered, credentials (client_id and client_secret)
0000000000000000000000000000000000000000;;	// will be passed as query parameters rather than being present
0000000000000000000000000000000000000000;;	// in the Authorization header.
0000000000000000000000000000000000000000;;	// See https://code.google.com/p/goauth2/issues/detail?id=31 for background.
0000000000000000000000000000000000000000;;	func RegisterBrokenAuthHeaderProvider(tokenURL string) {
0000000000000000000000000000000000000000;;		internal.RegisterBrokenAuthHeaderProvider(tokenURL)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config describes a typical 3-legged OAuth2 flow, with both the
0000000000000000000000000000000000000000;;	// client application information and the server's endpoint URLs.
0000000000000000000000000000000000000000;;	// For the client credentials 2-legged OAuth2 flow, see the clientcredentials
0000000000000000000000000000000000000000;;	// package (https://golang.org/x/oauth2/clientcredentials).
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// ClientID is the application's ID.
0000000000000000000000000000000000000000;;		ClientID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClientSecret is the application's secret.
0000000000000000000000000000000000000000;;		ClientSecret string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Endpoint contains the resource server's token endpoint
0000000000000000000000000000000000000000;;		// URLs. These are constants specific to each server and are
0000000000000000000000000000000000000000;;		// often available via site-specific packages, such as
0000000000000000000000000000000000000000;;		// google.Endpoint or github.Endpoint.
0000000000000000000000000000000000000000;;		Endpoint Endpoint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RedirectURL is the URL to redirect users going through
0000000000000000000000000000000000000000;;		// the OAuth flow, after the resource owner's URLs.
0000000000000000000000000000000000000000;;		RedirectURL string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scope specifies optional requested permissions.
0000000000000000000000000000000000000000;;		Scopes []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A TokenSource is anything that can return a token.
0000000000000000000000000000000000000000;;	type TokenSource interface {
0000000000000000000000000000000000000000;;		// Token returns a token or an error.
0000000000000000000000000000000000000000;;		// Token must be safe for concurrent use by multiple goroutines.
0000000000000000000000000000000000000000;;		// The returned Token must not be modified.
0000000000000000000000000000000000000000;;		Token() (*Token, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Endpoint contains the OAuth 2.0 provider's authorization and token
0000000000000000000000000000000000000000;;	// endpoint URLs.
0000000000000000000000000000000000000000;;	type Endpoint struct {
0000000000000000000000000000000000000000;;		AuthURL  string
0000000000000000000000000000000000000000;;		TokenURL string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// AccessTypeOnline and AccessTypeOffline are options passed
0000000000000000000000000000000000000000;;		// to the Options.AuthCodeURL method. They modify the
0000000000000000000000000000000000000000;;		// "access_type" field that gets sent in the URL returned by
0000000000000000000000000000000000000000;;		// AuthCodeURL.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Online is the default if neither is specified. If your
0000000000000000000000000000000000000000;;		// application needs to refresh access tokens when the user
0000000000000000000000000000000000000000;;		// is not present at the browser, then use offline. This will
0000000000000000000000000000000000000000;;		// result in your application obtaining a refresh token the
0000000000000000000000000000000000000000;;		// first time your application exchanges an authorization
0000000000000000000000000000000000000000;;		// code for a user.
0000000000000000000000000000000000000000;;		AccessTypeOnline  AuthCodeOption = SetAuthURLParam("access_type", "online")
0000000000000000000000000000000000000000;;		AccessTypeOffline AuthCodeOption = SetAuthURLParam("access_type", "offline")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ApprovalForce forces the users to view the consent dialog
0000000000000000000000000000000000000000;;		// and confirm the permissions request at the URL returned
0000000000000000000000000000000000000000;;		// from AuthCodeURL, even if they've already done so.
0000000000000000000000000000000000000000;;		ApprovalForce AuthCodeOption = SetAuthURLParam("approval_prompt", "force")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An AuthCodeOption is passed to Config.AuthCodeURL.
0000000000000000000000000000000000000000;;	type AuthCodeOption interface {
0000000000000000000000000000000000000000;;		setValue(url.Values)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type setParam struct{ k, v string }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p setParam) setValue(m url.Values) { m.Set(p.k, p.v) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetAuthURLParam builds an AuthCodeOption which passes key/value parameters
0000000000000000000000000000000000000000;;	// to a provider's authorization endpoint.
0000000000000000000000000000000000000000;;	func SetAuthURLParam(key, value string) AuthCodeOption {
0000000000000000000000000000000000000000;;		return setParam{key, value}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthCodeURL returns a URL to OAuth 2.0 provider's consent page
0000000000000000000000000000000000000000;;	// that asks for permissions for the required scopes explicitly.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// State is a token to protect the user from CSRF attacks. You must
0000000000000000000000000000000000000000;;	// always provide a non-zero string and validate that it matches the
0000000000000000000000000000000000000000;;	// the state query parameter on your redirect callback.
0000000000000000000000000000000000000000;;	// See http://tools.ietf.org/html/rfc6749#section-10.12 for more info.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Opts may include AccessTypeOnline or AccessTypeOffline, as well
0000000000000000000000000000000000000000;;	// as ApprovalForce.
0000000000000000000000000000000000000000;;	func (c *Config) AuthCodeURL(state string, opts ...AuthCodeOption) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		buf.WriteString(c.Endpoint.AuthURL)
0000000000000000000000000000000000000000;;		v := url.Values{
0000000000000000000000000000000000000000;;			"response_type": {"code"},
0000000000000000000000000000000000000000;;			"client_id":     {c.ClientID},
0000000000000000000000000000000000000000;;			"redirect_uri":  internal.CondVal(c.RedirectURL),
0000000000000000000000000000000000000000;;			"scope":         internal.CondVal(strings.Join(c.Scopes, " ")),
0000000000000000000000000000000000000000;;			"state":         internal.CondVal(state),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, opt := range opts {
0000000000000000000000000000000000000000;;			opt.setValue(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(c.Endpoint.AuthURL, "?") {
0000000000000000000000000000000000000000;;			buf.WriteByte('&')
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			buf.WriteByte('?')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.WriteString(v.Encode())
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PasswordCredentialsToken converts a resource owner username and password
0000000000000000000000000000000000000000;;	// pair into a token.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Per the RFC, this grant type should only be used "when there is a high
0000000000000000000000000000000000000000;;	// degree of trust between the resource owner and the client (e.g., the client
0000000000000000000000000000000000000000;;	// is part of the device operating system or a highly privileged application),
0000000000000000000000000000000000000000;;	// and when other authorization grant types are not available."
0000000000000000000000000000000000000000;;	// See https://tools.ietf.org/html/rfc6749#section-4.3 for more info.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The HTTP client to use is derived from the context.
0000000000000000000000000000000000000000;;	// If nil, http.DefaultClient is used.
0000000000000000000000000000000000000000;;	func (c *Config) PasswordCredentialsToken(ctx context.Context, username, password string) (*Token, error) {
0000000000000000000000000000000000000000;;		return retrieveToken(ctx, c, url.Values{
0000000000000000000000000000000000000000;;			"grant_type": {"password"},
0000000000000000000000000000000000000000;;			"username":   {username},
0000000000000000000000000000000000000000;;			"password":   {password},
0000000000000000000000000000000000000000;;			"scope":      internal.CondVal(strings.Join(c.Scopes, " ")),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exchange converts an authorization code into a token.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is used after a resource provider redirects the user back
0000000000000000000000000000000000000000;;	// to the Redirect URI (the URL obtained from AuthCodeURL).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The HTTP client to use is derived from the context.
0000000000000000000000000000000000000000;;	// If a client is not provided via the context, http.DefaultClient is used.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The code will be in the *http.Request.FormValue("code"). Before
0000000000000000000000000000000000000000;;	// calling Exchange, be sure to validate FormValue("state").
0000000000000000000000000000000000000000;;	func (c *Config) Exchange(ctx context.Context, code string) (*Token, error) {
0000000000000000000000000000000000000000;;		return retrieveToken(ctx, c, url.Values{
0000000000000000000000000000000000000000;;			"grant_type":   {"authorization_code"},
0000000000000000000000000000000000000000;;			"code":         {code},
0000000000000000000000000000000000000000;;			"redirect_uri": internal.CondVal(c.RedirectURL),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client returns an HTTP client using the provided token.
0000000000000000000000000000000000000000;;	// The token will auto-refresh as necessary. The underlying
0000000000000000000000000000000000000000;;	// HTTP transport will be obtained using the provided context.
0000000000000000000000000000000000000000;;	// The returned client and its Transport should not be modified.
0000000000000000000000000000000000000000;;	func (c *Config) Client(ctx context.Context, t *Token) *http.Client {
0000000000000000000000000000000000000000;;		return NewClient(ctx, c.TokenSource(ctx, t))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TokenSource returns a TokenSource that returns t until t expires,
0000000000000000000000000000000000000000;;	// automatically refreshing it as necessary using the provided context.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Most users will use Config.Client instead.
0000000000000000000000000000000000000000;;	func (c *Config) TokenSource(ctx context.Context, t *Token) TokenSource {
0000000000000000000000000000000000000000;;		tkr := &tokenRefresher{
0000000000000000000000000000000000000000;;			ctx:  ctx,
0000000000000000000000000000000000000000;;			conf: c,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t != nil {
0000000000000000000000000000000000000000;;			tkr.refreshToken = t.RefreshToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &reuseTokenSource{
0000000000000000000000000000000000000000;;			t:   t,
0000000000000000000000000000000000000000;;			new: tkr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tokenRefresher is a TokenSource that makes "grant_type"=="refresh_token"
0000000000000000000000000000000000000000;;	// HTTP requests to renew a token using a RefreshToken.
0000000000000000000000000000000000000000;;	type tokenRefresher struct {
0000000000000000000000000000000000000000;;		ctx          context.Context // used to get HTTP requests
0000000000000000000000000000000000000000;;		conf         *Config
0000000000000000000000000000000000000000;;		refreshToken string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WARNING: Token is not safe for concurrent access, as it
0000000000000000000000000000000000000000;;	// updates the tokenRefresher's refreshToken field.
0000000000000000000000000000000000000000;;	// Within this package, it is used by reuseTokenSource which
0000000000000000000000000000000000000000;;	// synchronizes calls to this method with its own mutex.
0000000000000000000000000000000000000000;;	func (tf *tokenRefresher) Token() (*Token, error) {
0000000000000000000000000000000000000000;;		if tf.refreshToken == "" {
0000000000000000000000000000000000000000;;			return nil, errors.New("oauth2: token expired and refresh token is not set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tk, err := retrieveToken(tf.ctx, tf.conf, url.Values{
0000000000000000000000000000000000000000;;			"grant_type":    {"refresh_token"},
0000000000000000000000000000000000000000;;			"refresh_token": {tf.refreshToken},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tf.refreshToken != tk.RefreshToken {
0000000000000000000000000000000000000000;;			tf.refreshToken = tk.RefreshToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tk, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reuseTokenSource is a TokenSource that holds a single token in memory
0000000000000000000000000000000000000000;;	// and validates its expiry before each call to retrieve it with
0000000000000000000000000000000000000000;;	// Token. If it's expired, it will be auto-refreshed using the
0000000000000000000000000000000000000000;;	// new TokenSource.
0000000000000000000000000000000000000000;;	type reuseTokenSource struct {
0000000000000000000000000000000000000000;;		new TokenSource // called when t is expired.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu sync.Mutex // guards t
0000000000000000000000000000000000000000;;		t  *Token
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token returns the current token if it's still valid, else will
0000000000000000000000000000000000000000;;	// refresh the current token (using r.Context for HTTP client
0000000000000000000000000000000000000000;;	// information) and return the new one.
0000000000000000000000000000000000000000;;	func (s *reuseTokenSource) Token() (*Token, error) {
0000000000000000000000000000000000000000;;		s.mu.Lock()
0000000000000000000000000000000000000000;;		defer s.mu.Unlock()
0000000000000000000000000000000000000000;;		if s.t.Valid() {
0000000000000000000000000000000000000000;;			return s.t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, err := s.new.Token()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.t = t
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StaticTokenSource returns a TokenSource that always returns the same token.
0000000000000000000000000000000000000000;;	// Because the provided token t is never refreshed, StaticTokenSource is only
0000000000000000000000000000000000000000;;	// useful for tokens that never expire.
0000000000000000000000000000000000000000;;	func StaticTokenSource(t *Token) TokenSource {
0000000000000000000000000000000000000000;;		return staticTokenSource{t}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// staticTokenSource is a TokenSource that always returns the same Token.
0000000000000000000000000000000000000000;;	type staticTokenSource struct {
0000000000000000000000000000000000000000;;		t *Token
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s staticTokenSource) Token() (*Token, error) {
0000000000000000000000000000000000000000;;		return s.t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPClient is the context key to use with golang.org/x/net/context's
0000000000000000000000000000000000000000;;	// WithValue function to associate an *http.Client value with a context.
0000000000000000000000000000000000000000;;	var HTTPClient internal.ContextKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient creates an *http.Client from a Context and TokenSource.
0000000000000000000000000000000000000000;;	// The returned client is not valid beyond the lifetime of the context.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As a special case, if src is nil, a non-OAuth2 client is returned
0000000000000000000000000000000000000000;;	// using the provided context. This exists to support related OAuth2
0000000000000000000000000000000000000000;;	// packages.
0000000000000000000000000000000000000000;;	func NewClient(ctx context.Context, src TokenSource) *http.Client {
0000000000000000000000000000000000000000;;		if src == nil {
0000000000000000000000000000000000000000;;			c, err := internal.ContextClient(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return &http.Client{Transport: internal.ErrorTransport{Err: err}}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &http.Client{
0000000000000000000000000000000000000000;;			Transport: &Transport{
0000000000000000000000000000000000000000;;				Base:   internal.ContextTransport(ctx),
0000000000000000000000000000000000000000;;				Source: ReuseTokenSource(nil, src),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReuseTokenSource returns a TokenSource which repeatedly returns the
0000000000000000000000000000000000000000;;	// same token as long as it's valid, starting with t.
0000000000000000000000000000000000000000;;	// When its cached token is invalid, a new token is obtained from src.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ReuseTokenSource is typically used to reuse tokens from a cache
0000000000000000000000000000000000000000;;	// (such as a file on disk) between runs of a program, rather than
0000000000000000000000000000000000000000;;	// obtaining new tokens unnecessarily.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The initial token t may be nil, in which case the TokenSource is
0000000000000000000000000000000000000000;;	// wrapped in a caching version if it isn't one already. This also
0000000000000000000000000000000000000000;;	// means it's always safe to wrap ReuseTokenSource around any other
0000000000000000000000000000000000000000;;	// TokenSource without adverse effects.
0000000000000000000000000000000000000000;;	func ReuseTokenSource(t *Token, src TokenSource) TokenSource {
0000000000000000000000000000000000000000;;		// Don't wrap a reuseTokenSource in itself. That would work,
0000000000000000000000000000000000000000;;		// but cause an unnecessary number of mutex operations.
0000000000000000000000000000000000000000;;		// Just build the equivalent one.
0000000000000000000000000000000000000000;;		if rt, ok := src.(*reuseTokenSource); ok {
0000000000000000000000000000000000000000;;			if t == nil {
0000000000000000000000000000000000000000;;				// Just use it directly.
0000000000000000000000000000000000000000;;				return rt
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			src = rt.new
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &reuseTokenSource{
0000000000000000000000000000000000000000;;			t:   t,
0000000000000000000000000000000000000000;;			new: src,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
