0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
ebf43e4ef7c9c1b2ea6bf70710d9b269028e79a0;Godeps/_workspace/src/golang.org/x/oauth2/google/sdk.go[Godeps/_workspace/src/golang.org/x/oauth2/google/sdk.go][vendor/golang.org/x/oauth2/google/sdk.go];	
0000000000000000000000000000000000000000;;	package google
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/user"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/internal"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sdkCredentials struct {
0000000000000000000000000000000000000000;;		Data []struct {
0000000000000000000000000000000000000000;;			Credential struct {
0000000000000000000000000000000000000000;;				ClientID     string     `json:"client_id"`
0000000000000000000000000000000000000000;;				ClientSecret string     `json:"client_secret"`
0000000000000000000000000000000000000000;;				AccessToken  string     `json:"access_token"`
0000000000000000000000000000000000000000;;				RefreshToken string     `json:"refresh_token"`
0000000000000000000000000000000000000000;;				TokenExpiry  *time.Time `json:"token_expiry"`
0000000000000000000000000000000000000000;;			} `json:"credential"`
0000000000000000000000000000000000000000;;			Key struct {
0000000000000000000000000000000000000000;;				Account string `json:"account"`
0000000000000000000000000000000000000000;;				Scope   string `json:"scope"`
0000000000000000000000000000000000000000;;			} `json:"key"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An SDKConfig provides access to tokens from an account already
0000000000000000000000000000000000000000;;	// authorized via the Google Cloud SDK.
0000000000000000000000000000000000000000;;	type SDKConfig struct {
0000000000000000000000000000000000000000;;		conf         oauth2.Config
0000000000000000000000000000000000000000;;		initialToken *oauth2.Token
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSDKConfig creates an SDKConfig for the given Google Cloud SDK
0000000000000000000000000000000000000000;;	// account. If account is empty, the account currently active in
0000000000000000000000000000000000000000;;	// Google Cloud SDK properties is used.
0000000000000000000000000000000000000000;;	// Google Cloud SDK credentials must be created by running `gcloud auth`
0000000000000000000000000000000000000000;;	// before using this function.
0000000000000000000000000000000000000000;;	// The Google Cloud SDK is available at https://cloud.google.com/sdk/.
0000000000000000000000000000000000000000;;	func NewSDKConfig(account string) (*SDKConfig, error) {
0000000000000000000000000000000000000000;;		configPath, err := sdkConfigPath()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2/google: error getting SDK config path: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		credentialsPath := filepath.Join(configPath, "credentials")
0000000000000000000000000000000000000000;;		f, err := os.Open(credentialsPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2/google: failed to load SDK credentials: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var c sdkCredentials
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(f).Decode(&c); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2/google: failed to decode SDK credentials from %q: %v", credentialsPath, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(c.Data) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2/google: no credentials found in %q, run `gcloud auth login` to create one", credentialsPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if account == "" {
0000000000000000000000000000000000000000;;			propertiesPath := filepath.Join(configPath, "properties")
0000000000000000000000000000000000000000;;			f, err := os.Open(propertiesPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("oauth2/google: failed to load SDK properties: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer f.Close()
0000000000000000000000000000000000000000;;			ini, err := internal.ParseINI(f)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("oauth2/google: failed to parse SDK properties %q: %v", propertiesPath, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			core, ok := ini["core"]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("oauth2/google: failed to find [core] section in %v", ini)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			active, ok := core["account"]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("oauth2/google: failed to find %q attribute in %v", "account", core)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			account = active
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, d := range c.Data {
0000000000000000000000000000000000000000;;			if account == "" || d.Key.Account == account {
0000000000000000000000000000000000000000;;				if d.Credential.AccessToken == "" && d.Credential.RefreshToken == "" {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("oauth2/google: no token available for account %q", account)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var expiry time.Time
0000000000000000000000000000000000000000;;				if d.Credential.TokenExpiry != nil {
0000000000000000000000000000000000000000;;					expiry = *d.Credential.TokenExpiry
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return &SDKConfig{
0000000000000000000000000000000000000000;;					conf: oauth2.Config{
0000000000000000000000000000000000000000;;						ClientID:     d.Credential.ClientID,
0000000000000000000000000000000000000000;;						ClientSecret: d.Credential.ClientSecret,
0000000000000000000000000000000000000000;;						Scopes:       strings.Split(d.Key.Scope, " "),
0000000000000000000000000000000000000000;;						Endpoint:     Endpoint,
0000000000000000000000000000000000000000;;						RedirectURL:  "oob",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					initialToken: &oauth2.Token{
0000000000000000000000000000000000000000;;						AccessToken:  d.Credential.AccessToken,
0000000000000000000000000000000000000000;;						RefreshToken: d.Credential.RefreshToken,
0000000000000000000000000000000000000000;;						Expiry:       expiry,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("oauth2/google: no such credentials for account %q", account)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client returns an HTTP client using Google Cloud SDK credentials to
0000000000000000000000000000000000000000;;	// authorize requests. The token will auto-refresh as necessary. The
0000000000000000000000000000000000000000;;	// underlying http.RoundTripper will be obtained using the provided
0000000000000000000000000000000000000000;;	// context. The returned client and its Transport should not be
0000000000000000000000000000000000000000;;	// modified.
0000000000000000000000000000000000000000;;	func (c *SDKConfig) Client(ctx context.Context) *http.Client {
0000000000000000000000000000000000000000;;		return &http.Client{
0000000000000000000000000000000000000000;;			Transport: &oauth2.Transport{
0000000000000000000000000000000000000000;;				Source: c.TokenSource(ctx),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TokenSource returns an oauth2.TokenSource that retrieve tokens from
0000000000000000000000000000000000000000;;	// Google Cloud SDK credentials using the provided context.
0000000000000000000000000000000000000000;;	// It will returns the current access token stored in the credentials,
0000000000000000000000000000000000000000;;	// and refresh it when it expires, but it won't update the credentials
0000000000000000000000000000000000000000;;	// with the new access token.
0000000000000000000000000000000000000000;;	func (c *SDKConfig) TokenSource(ctx context.Context) oauth2.TokenSource {
0000000000000000000000000000000000000000;;		return c.conf.TokenSource(ctx, c.initialToken)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scopes are the OAuth 2.0 scopes the current account is authorized for.
0000000000000000000000000000000000000000;;	func (c *SDKConfig) Scopes() []string {
0000000000000000000000000000000000000000;;		return c.conf.Scopes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sdkConfigPath tries to guess where the gcloud config is located.
0000000000000000000000000000000000000000;;	// It can be overridden during tests.
0000000000000000000000000000000000000000;;	var sdkConfigPath = func() (string, error) {
0000000000000000000000000000000000000000;;		if runtime.GOOS == "windows" {
0000000000000000000000000000000000000000;;			return filepath.Join(os.Getenv("APPDATA"), "gcloud"), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		homeDir := guessUnixHomeDir()
0000000000000000000000000000000000000000;;		if homeDir == "" {
0000000000000000000000000000000000000000;;			return "", errors.New("unable to get current user home directory: os/user lookup failed; $HOME is empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Join(homeDir, ".config", "gcloud"), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func guessUnixHomeDir() string {
0000000000000000000000000000000000000000;;		// Prefer $HOME over user.Current due to glibc bug: golang.org/issue/13470
0000000000000000000000000000000000000000;;		if v := os.Getenv("HOME"); v != "" {
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Else, fall back to user.Current:
0000000000000000000000000000000000000000;;		if u, err := user.Current(); err == nil {
0000000000000000000000000000000000000000;;			return u.HomeDir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
