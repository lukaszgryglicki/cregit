0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
edbcd7131459086bebd8b977925afcb7a234f8d4;;	
0000000000000000000000000000000000000000;;	package google
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/internal"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/jws"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JWTAccessTokenSourceFromJSON uses a Google Developers service account JSON
0000000000000000000000000000000000000000;;	// key file to read the credentials that authorize and authenticate the
0000000000000000000000000000000000000000;;	// requests, and returns a TokenSource that does not use any OAuth2 flow but
0000000000000000000000000000000000000000;;	// instead creates a JWT and sends that as the access token.
0000000000000000000000000000000000000000;;	// The audience is typically a URL that specifies the scope of the credentials.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that this is not a standard OAuth flow, but rather an
0000000000000000000000000000000000000000;;	// optimization supported by a few Google services.
0000000000000000000000000000000000000000;;	// Unless you know otherwise, you should use JWTConfigFromJSON instead.
0000000000000000000000000000000000000000;;	func JWTAccessTokenSourceFromJSON(jsonKey []byte, audience string) (oauth2.TokenSource, error) {
0000000000000000000000000000000000000000;;		cfg, err := JWTConfigFromJSON(jsonKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("google: could not parse JSON key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pk, err := internal.ParseKey(cfg.PrivateKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("google: could not parse key: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ts := &jwtAccessTokenSource{
0000000000000000000000000000000000000000;;			email:    cfg.Email,
0000000000000000000000000000000000000000;;			audience: audience,
0000000000000000000000000000000000000000;;			pk:       pk,
0000000000000000000000000000000000000000;;			pkID:     cfg.PrivateKeyID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tok, err := ts.Token()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return oauth2.ReuseTokenSource(tok, ts), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jwtAccessTokenSource struct {
0000000000000000000000000000000000000000;;		email, audience string
0000000000000000000000000000000000000000;;		pk              *rsa.PrivateKey
0000000000000000000000000000000000000000;;		pkID            string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *jwtAccessTokenSource) Token() (*oauth2.Token, error) {
0000000000000000000000000000000000000000;;		iat := time.Now()
0000000000000000000000000000000000000000;;		exp := iat.Add(time.Hour)
0000000000000000000000000000000000000000;;		cs := &jws.ClaimSet{
0000000000000000000000000000000000000000;;			Iss: ts.email,
0000000000000000000000000000000000000000;;			Sub: ts.email,
0000000000000000000000000000000000000000;;			Aud: ts.audience,
0000000000000000000000000000000000000000;;			Iat: iat.Unix(),
0000000000000000000000000000000000000000;;			Exp: exp.Unix(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hdr := &jws.Header{
0000000000000000000000000000000000000000;;			Algorithm: "RS256",
0000000000000000000000000000000000000000;;			Typ:       "JWT",
0000000000000000000000000000000000000000;;			KeyID:     string(ts.pkID),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg, err := jws.Encode(hdr, cs, ts.pk)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("google: could not encode JWT: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &oauth2.Token{AccessToken: msg, TokenType: "Bearer", Expiry: exp}, nil
0000000000000000000000000000000000000000;;	}
