0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/golang.org/x/oauth2/google/google.go[Godeps/_workspace/src/golang.org/x/oauth2/google/google.go][vendor/golang.org/x/oauth2/google/google.go];	
0000000000000000000000000000000000000000;;	// Package google provides support for making OAuth2 authorized and
0000000000000000000000000000000000000000;;	// authenticated HTTP requests to Google APIs.
0000000000000000000000000000000000000000;;	// It supports the Web server flow, client-side credentials, service accounts,
0000000000000000000000000000000000000000;;	// Google Compute Engine service accounts, and Google App Engine service
0000000000000000000000000000000000000000;;	// accounts.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more information, please read
0000000000000000000000000000000000000000;;	// https://developers.google.com/accounts/docs/OAuth2
0000000000000000000000000000000000000000;;	// and
0000000000000000000000000000000000000000;;	// https://developers.google.com/accounts/docs/application-default-credentials.
0000000000000000000000000000000000000000;;	package google
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"cloud.google.com/go/compute/metadata"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/jwt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Endpoint is Google's OAuth 2.0 endpoint.
0000000000000000000000000000000000000000;;	var Endpoint = oauth2.Endpoint{
0000000000000000000000000000000000000000;;		AuthURL:  "https://accounts.google.com/o/oauth2/auth",
0000000000000000000000000000000000000000;;		TokenURL: "https://accounts.google.com/o/oauth2/token",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JWTTokenURL is Google's OAuth 2.0 token URL to use with the JWT flow.
0000000000000000000000000000000000000000;;	const JWTTokenURL = "https://accounts.google.com/o/oauth2/token"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigFromJSON uses a Google Developers Console client_credentials.json
0000000000000000000000000000000000000000;;	// file to construct a config.
0000000000000000000000000000000000000000;;	// client_credentials.json can be downloaded from
0000000000000000000000000000000000000000;;	// https://console.developers.google.com, under "Credentials". Download the Web
0000000000000000000000000000000000000000;;	// application credentials in the JSON format and provide the contents of the
0000000000000000000000000000000000000000;;	// file as jsonKey.
0000000000000000000000000000000000000000;;	func ConfigFromJSON(jsonKey []byte, scope ...string) (*oauth2.Config, error) {
0000000000000000000000000000000000000000;;		type cred struct {
0000000000000000000000000000000000000000;;			ClientID     string   `json:"client_id"`
0000000000000000000000000000000000000000;;			ClientSecret string   `json:"client_secret"`
0000000000000000000000000000000000000000;;			RedirectURIs []string `json:"redirect_uris"`
0000000000000000000000000000000000000000;;			AuthURI      string   `json:"auth_uri"`
0000000000000000000000000000000000000000;;			TokenURI     string   `json:"token_uri"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var j struct {
0000000000000000000000000000000000000000;;			Web       *cred `json:"web"`
0000000000000000000000000000000000000000;;			Installed *cred `json:"installed"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(jsonKey, &j); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var c *cred
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case j.Web != nil:
0000000000000000000000000000000000000000;;			c = j.Web
0000000000000000000000000000000000000000;;		case j.Installed != nil:
0000000000000000000000000000000000000000;;			c = j.Installed
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2/google: no credentials found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(c.RedirectURIs) < 1 {
0000000000000000000000000000000000000000;;			return nil, errors.New("oauth2/google: missing redirect URL in the client_credentials.json")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &oauth2.Config{
0000000000000000000000000000000000000000;;			ClientID:     c.ClientID,
0000000000000000000000000000000000000000;;			ClientSecret: c.ClientSecret,
0000000000000000000000000000000000000000;;			RedirectURL:  c.RedirectURIs[0],
0000000000000000000000000000000000000000;;			Scopes:       scope,
0000000000000000000000000000000000000000;;			Endpoint: oauth2.Endpoint{
0000000000000000000000000000000000000000;;				AuthURL:  c.AuthURI,
0000000000000000000000000000000000000000;;				TokenURL: c.TokenURI,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JWTConfigFromJSON uses a Google Developers service account JSON key file to read
0000000000000000000000000000000000000000;;	// the credentials that authorize and authenticate the requests.
0000000000000000000000000000000000000000;;	// Create a service account on "Credentials" for your project at
0000000000000000000000000000000000000000;;	// https://console.developers.google.com to download a JSON key file.
0000000000000000000000000000000000000000;;	func JWTConfigFromJSON(jsonKey []byte, scope ...string) (*jwt.Config, error) {
0000000000000000000000000000000000000000;;		var f credentialsFile
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(jsonKey, &f); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.Type != serviceAccountKey {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("google: read JWT from JSON credentials: 'type' field is %q (expected %q)", f.Type, serviceAccountKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scope = append([]string(nil), scope...) // copy
0000000000000000000000000000000000000000;;		return f.jwtConfig(scope), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSON key file types.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		serviceAccountKey  = "service_account"
0000000000000000000000000000000000000000;;		userCredentialsKey = "authorized_user"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// credentialsFile is the unmarshalled representation of a credentials file.
0000000000000000000000000000000000000000;;	type credentialsFile struct {
0000000000000000000000000000000000000000;;		Type string `json:"type"` // serviceAccountKey or userCredentialsKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Service Account fields
0000000000000000000000000000000000000000;;		ClientEmail  string `json:"client_email"`
0000000000000000000000000000000000000000;;		PrivateKeyID string `json:"private_key_id"`
0000000000000000000000000000000000000000;;		PrivateKey   string `json:"private_key"`
0000000000000000000000000000000000000000;;		TokenURL     string `json:"token_uri"`
0000000000000000000000000000000000000000;;		ProjectID    string `json:"project_id"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// User Credential fields
0000000000000000000000000000000000000000;;		// (These typically come from gcloud auth.)
0000000000000000000000000000000000000000;;		ClientSecret string `json:"client_secret"`
0000000000000000000000000000000000000000;;		ClientID     string `json:"client_id"`
0000000000000000000000000000000000000000;;		RefreshToken string `json:"refresh_token"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *credentialsFile) jwtConfig(scopes []string) *jwt.Config {
0000000000000000000000000000000000000000;;		cfg := &jwt.Config{
0000000000000000000000000000000000000000;;			Email:        f.ClientEmail,
0000000000000000000000000000000000000000;;			PrivateKey:   []byte(f.PrivateKey),
0000000000000000000000000000000000000000;;			PrivateKeyID: f.PrivateKeyID,
0000000000000000000000000000000000000000;;			Scopes:       scopes,
0000000000000000000000000000000000000000;;			TokenURL:     f.TokenURL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.TokenURL == "" {
0000000000000000000000000000000000000000;;			cfg.TokenURL = JWTTokenURL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *credentialsFile) tokenSource(ctx context.Context, scopes []string) (oauth2.TokenSource, error) {
0000000000000000000000000000000000000000;;		switch f.Type {
0000000000000000000000000000000000000000;;		case serviceAccountKey:
0000000000000000000000000000000000000000;;			cfg := f.jwtConfig(scopes)
0000000000000000000000000000000000000000;;			return cfg.TokenSource(ctx), nil
0000000000000000000000000000000000000000;;		case userCredentialsKey:
0000000000000000000000000000000000000000;;			cfg := &oauth2.Config{
0000000000000000000000000000000000000000;;				ClientID:     f.ClientID,
0000000000000000000000000000000000000000;;				ClientSecret: f.ClientSecret,
0000000000000000000000000000000000000000;;				Scopes:       scopes,
0000000000000000000000000000000000000000;;				Endpoint:     Endpoint,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tok := &oauth2.Token{RefreshToken: f.RefreshToken}
0000000000000000000000000000000000000000;;			return cfg.TokenSource(ctx, tok), nil
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			return nil, errors.New("missing 'type' field in credentials")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown credential type: %q", f.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ComputeTokenSource returns a token source that fetches access tokens
0000000000000000000000000000000000000000;;	// from Google Compute Engine (GCE)'s metadata server. It's only valid to use
0000000000000000000000000000000000000000;;	// this token source if your program is running on a GCE instance.
0000000000000000000000000000000000000000;;	// If no account is specified, "default" is used.
0000000000000000000000000000000000000000;;	// Further information about retrieving access tokens from the GCE metadata
0000000000000000000000000000000000000000;;	// server can be found at https://cloud.google.com/compute/docs/authentication.
0000000000000000000000000000000000000000;;	func ComputeTokenSource(account string) oauth2.TokenSource {
0000000000000000000000000000000000000000;;		return oauth2.ReuseTokenSource(nil, computeSource{account: account})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type computeSource struct {
0000000000000000000000000000000000000000;;		account string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs computeSource) Token() (*oauth2.Token, error) {
0000000000000000000000000000000000000000;;		if !metadata.OnGCE() {
0000000000000000000000000000000000000000;;			return nil, errors.New("oauth2/google: can't get a token from the metadata service; not running on GCE")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		acct := cs.account
0000000000000000000000000000000000000000;;		if acct == "" {
0000000000000000000000000000000000000000;;			acct = "default"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tokenJSON, err := metadata.Get("instance/service-accounts/" + acct + "/token")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var res struct {
0000000000000000000000000000000000000000;;			AccessToken  string `json:"access_token"`
0000000000000000000000000000000000000000;;			ExpiresInSec int    `json:"expires_in"`
0000000000000000000000000000000000000000;;			TokenType    string `json:"token_type"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.NewDecoder(strings.NewReader(tokenJSON)).Decode(&res)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2/google: invalid token JSON from metadata: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.ExpiresInSec == 0 || res.AccessToken == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2/google: incomplete token received from metadata")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &oauth2.Token{
0000000000000000000000000000000000000000;;			AccessToken: res.AccessToken,
0000000000000000000000000000000000000000;;			TokenType:   res.TokenType,
0000000000000000000000000000000000000000;;			Expiry:      time.Now().Add(time.Duration(res.ExpiresInSec) * time.Second),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
