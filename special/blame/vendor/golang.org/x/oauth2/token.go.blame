0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/golang.org/x/oauth2/token.go[Godeps/_workspace/src/golang.org/x/oauth2/token.go][vendor/golang.org/x/oauth2/token.go];	
0000000000000000000000000000000000000000;;	package oauth2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/internal"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// expiryDelta determines how earlier a token should be considered
0000000000000000000000000000000000000000;;	// expired than its actual expiration time. It is used to avoid late
0000000000000000000000000000000000000000;;	// expirations due to client-server time mismatches.
0000000000000000000000000000000000000000;;	const expiryDelta = 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token represents the crendentials used to authorize
0000000000000000000000000000000000000000;;	// the requests to access protected resources on the OAuth 2.0
0000000000000000000000000000000000000000;;	// provider's backend.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Most users of this package should not access fields of Token
0000000000000000000000000000000000000000;;	// directly. They're exported mostly for use by related packages
0000000000000000000000000000000000000000;;	// implementing derivative OAuth2 flows.
0000000000000000000000000000000000000000;;	type Token struct {
0000000000000000000000000000000000000000;;		// AccessToken is the token that authorizes and authenticates
0000000000000000000000000000000000000000;;		// the requests.
0000000000000000000000000000000000000000;;		AccessToken string `json:"access_token"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TokenType is the type of token.
0000000000000000000000000000000000000000;;		// The Type method returns either this or "Bearer", the default.
0000000000000000000000000000000000000000;;		TokenType string `json:"token_type,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RefreshToken is a token that's used by the application
0000000000000000000000000000000000000000;;		// (as opposed to the user) to refresh the access token
0000000000000000000000000000000000000000;;		// if it expires.
0000000000000000000000000000000000000000;;		RefreshToken string `json:"refresh_token,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expiry is the optional expiration time of the access token.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If zero, TokenSource implementations will reuse the same
0000000000000000000000000000000000000000;;		// token forever and RefreshToken or equivalent
0000000000000000000000000000000000000000;;		// mechanisms for that TokenSource will not be used.
0000000000000000000000000000000000000000;;		Expiry time.Time `json:"expiry,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// raw optionally contains extra metadata from the server
0000000000000000000000000000000000000000;;		// when updating a token.
0000000000000000000000000000000000000000;;		raw interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type returns t.TokenType if non-empty, else "Bearer".
0000000000000000000000000000000000000000;;	func (t *Token) Type() string {
0000000000000000000000000000000000000000;;		if strings.EqualFold(t.TokenType, "bearer") {
0000000000000000000000000000000000000000;;			return "Bearer"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.EqualFold(t.TokenType, "mac") {
0000000000000000000000000000000000000000;;			return "MAC"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.EqualFold(t.TokenType, "basic") {
0000000000000000000000000000000000000000;;			return "Basic"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.TokenType != "" {
0000000000000000000000000000000000000000;;			return t.TokenType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "Bearer"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetAuthHeader sets the Authorization header to r using the access
0000000000000000000000000000000000000000;;	// token in t.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method is unnecessary when using Transport or an HTTP Client
0000000000000000000000000000000000000000;;	// returned by this package.
0000000000000000000000000000000000000000;;	func (t *Token) SetAuthHeader(r *http.Request) {
0000000000000000000000000000000000000000;;		r.Header.Set("Authorization", t.Type()+" "+t.AccessToken)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithExtra returns a new Token that's a clone of t, but using the
0000000000000000000000000000000000000000;;	// provided raw extra map. This is only intended for use by packages
0000000000000000000000000000000000000000;;	// implementing derivative OAuth2 flows.
0000000000000000000000000000000000000000;;	func (t *Token) WithExtra(extra interface{}) *Token {
0000000000000000000000000000000000000000;;		t2 := new(Token)
0000000000000000000000000000000000000000;;		*t2 = *t
0000000000000000000000000000000000000000;;		t2.raw = extra
0000000000000000000000000000000000000000;;		return t2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extra returns an extra field.
0000000000000000000000000000000000000000;;	// Extra fields are key-value pairs returned by the server as a
0000000000000000000000000000000000000000;;	// part of the token retrieval response.
0000000000000000000000000000000000000000;;	func (t *Token) Extra(key string) interface{} {
0000000000000000000000000000000000000000;;		if raw, ok := t.raw.(map[string]interface{}); ok {
0000000000000000000000000000000000000000;;			return raw[key]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vals, ok := t.raw.(url.Values)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := vals.Get(key)
0000000000000000000000000000000000000000;;		switch s := strings.TrimSpace(v); strings.Count(s, ".") {
0000000000000000000000000000000000000000;;		case 0: // Contains no "."; try to parse as int
0000000000000000000000000000000000000000;;			if i, err := strconv.ParseInt(s, 10, 64); err == nil {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 1: // Contains a single "."; try to parse as float
0000000000000000000000000000000000000000;;			if f, err := strconv.ParseFloat(s, 64); err == nil {
0000000000000000000000000000000000000000;;				return f
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// expired reports whether the token is expired.
0000000000000000000000000000000000000000;;	// t must be non-nil.
0000000000000000000000000000000000000000;;	func (t *Token) expired() bool {
0000000000000000000000000000000000000000;;		if t.Expiry.IsZero() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.Expiry.Add(-expiryDelta).Before(time.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid reports whether t is non-nil, has an AccessToken, and is not expired.
0000000000000000000000000000000000000000;;	func (t *Token) Valid() bool {
0000000000000000000000000000000000000000;;		return t != nil && t.AccessToken != "" && !t.expired()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tokenFromInternal maps an *internal.Token struct into
0000000000000000000000000000000000000000;;	// a *Token struct.
0000000000000000000000000000000000000000;;	func tokenFromInternal(t *internal.Token) *Token {
0000000000000000000000000000000000000000;;		if t == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Token{
0000000000000000000000000000000000000000;;			AccessToken:  t.AccessToken,
0000000000000000000000000000000000000000;;			TokenType:    t.TokenType,
0000000000000000000000000000000000000000;;			RefreshToken: t.RefreshToken,
0000000000000000000000000000000000000000;;			Expiry:       t.Expiry,
0000000000000000000000000000000000000000;;			raw:          t.Raw,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// retrieveToken takes a *Config and uses that to retrieve an *internal.Token.
0000000000000000000000000000000000000000;;	// This token is then mapped from *internal.Token into an *oauth2.Token which is returned along
0000000000000000000000000000000000000000;;	// with an error..
0000000000000000000000000000000000000000;;	func retrieveToken(ctx context.Context, c *Config, v url.Values) (*Token, error) {
0000000000000000000000000000000000000000;;		tk, err := internal.RetrieveToken(ctx, c.ClientID, c.ClientSecret, c.Endpoint.TokenURL, v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tokenFromInternal(tk), nil
0000000000000000000000000000000000000000;;	}
