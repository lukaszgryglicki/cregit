0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
ebf43e4ef7c9c1b2ea6bf70710d9b269028e79a0;Godeps/_workspace/src/golang.org/x/oauth2/internal/token.go[Godeps/_workspace/src/golang.org/x/oauth2/internal/token.go][vendor/golang.org/x/oauth2/internal/token.go];	
0000000000000000000000000000000000000000;;	// Package internal contains support packages for oauth2 package.
0000000000000000000000000000000000000000;;	package internal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token represents the crendentials used to authorize
0000000000000000000000000000000000000000;;	// the requests to access protected resources on the OAuth 2.0
0000000000000000000000000000000000000000;;	// provider's backend.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This type is a mirror of oauth2.Token and exists to break
0000000000000000000000000000000000000000;;	// an otherwise-circular dependency. Other internal packages
0000000000000000000000000000000000000000;;	// should convert this Token into an oauth2.Token before use.
0000000000000000000000000000000000000000;;	type Token struct {
0000000000000000000000000000000000000000;;		// AccessToken is the token that authorizes and authenticates
0000000000000000000000000000000000000000;;		// the requests.
0000000000000000000000000000000000000000;;		AccessToken string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TokenType is the type of token.
0000000000000000000000000000000000000000;;		// The Type method returns either this or "Bearer", the default.
0000000000000000000000000000000000000000;;		TokenType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RefreshToken is a token that's used by the application
0000000000000000000000000000000000000000;;		// (as opposed to the user) to refresh the access token
0000000000000000000000000000000000000000;;		// if it expires.
0000000000000000000000000000000000000000;;		RefreshToken string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expiry is the optional expiration time of the access token.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If zero, TokenSource implementations will reuse the same
0000000000000000000000000000000000000000;;		// token forever and RefreshToken or equivalent
0000000000000000000000000000000000000000;;		// mechanisms for that TokenSource will not be used.
0000000000000000000000000000000000000000;;		Expiry time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Raw optionally contains extra metadata from the server
0000000000000000000000000000000000000000;;		// when updating a token.
0000000000000000000000000000000000000000;;		Raw interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tokenJSON is the struct representing the HTTP response from OAuth2
0000000000000000000000000000000000000000;;	// providers returning a token in JSON form.
0000000000000000000000000000000000000000;;	type tokenJSON struct {
0000000000000000000000000000000000000000;;		AccessToken  string         `json:"access_token"`
0000000000000000000000000000000000000000;;		TokenType    string         `json:"token_type"`
0000000000000000000000000000000000000000;;		RefreshToken string         `json:"refresh_token"`
0000000000000000000000000000000000000000;;		ExpiresIn    expirationTime `json:"expires_in"` // at least PayPal returns string, while most return number
0000000000000000000000000000000000000000;;		Expires      expirationTime `json:"expires"`    // broken Facebook spelling of expires_in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *tokenJSON) expiry() (t time.Time) {
0000000000000000000000000000000000000000;;		if v := e.ExpiresIn; v != 0 {
0000000000000000000000000000000000000000;;			return time.Now().Add(time.Duration(v) * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v := e.Expires; v != 0 {
0000000000000000000000000000000000000000;;			return time.Now().Add(time.Duration(v) * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type expirationTime int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *expirationTime) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var n json.Number
0000000000000000000000000000000000000000;;		err := json.Unmarshal(b, &n)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, err := n.Int64()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*e = expirationTime(i)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var brokenAuthHeaderProviders = []string{
0000000000000000000000000000000000000000;;		"https://accounts.google.com/",
0000000000000000000000000000000000000000;;		"https://api.codeswholesale.com/oauth/token",
0000000000000000000000000000000000000000;;		"https://api.dropbox.com/",
0000000000000000000000000000000000000000;;		"https://api.dropboxapi.com/",
0000000000000000000000000000000000000000;;		"https://api.instagram.com/",
0000000000000000000000000000000000000000;;		"https://api.netatmo.net/",
0000000000000000000000000000000000000000;;		"https://api.odnoklassniki.ru/",
0000000000000000000000000000000000000000;;		"https://api.pushbullet.com/",
0000000000000000000000000000000000000000;;		"https://api.soundcloud.com/",
0000000000000000000000000000000000000000;;		"https://api.twitch.tv/",
0000000000000000000000000000000000000000;;		"https://app.box.com/",
0000000000000000000000000000000000000000;;		"https://connect.stripe.com/",
0000000000000000000000000000000000000000;;		"https://graph.facebook.com", // see https://github.com/golang/oauth2/issues/214
0000000000000000000000000000000000000000;;		"https://login.microsoftonline.com/",
0000000000000000000000000000000000000000;;		"https://login.salesforce.com/",
0000000000000000000000000000000000000000;;		"https://oauth.sandbox.trainingpeaks.com/",
0000000000000000000000000000000000000000;;		"https://oauth.trainingpeaks.com/",
0000000000000000000000000000000000000000;;		"https://oauth.vk.com/",
0000000000000000000000000000000000000000;;		"https://openapi.baidu.com/",
0000000000000000000000000000000000000000;;		"https://slack.com/",
0000000000000000000000000000000000000000;;		"https://test-sandbox.auth.corp.google.com",
0000000000000000000000000000000000000000;;		"https://test.salesforce.com/",
0000000000000000000000000000000000000000;;		"https://user.gini.net/",
0000000000000000000000000000000000000000;;		"https://www.douban.com/",
0000000000000000000000000000000000000000;;		"https://www.googleapis.com/",
0000000000000000000000000000000000000000;;		"https://www.linkedin.com/",
0000000000000000000000000000000000000000;;		"https://www.strava.com/oauth/",
0000000000000000000000000000000000000000;;		"https://www.wunderlist.com/oauth/",
0000000000000000000000000000000000000000;;		"https://api.patreon.com/",
0000000000000000000000000000000000000000;;		"https://sandbox.codeswholesale.com/oauth/token",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// brokenAuthHeaderDomains lists broken providers that issue dynamic endpoints.
0000000000000000000000000000000000000000;;	var brokenAuthHeaderDomains = []string{
0000000000000000000000000000000000000000;;		".force.com",
0000000000000000000000000000000000000000;;		".okta.com",
0000000000000000000000000000000000000000;;		".oktapreview.com",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RegisterBrokenAuthHeaderProvider(tokenURL string) {
0000000000000000000000000000000000000000;;		brokenAuthHeaderProviders = append(brokenAuthHeaderProviders, tokenURL)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// providerAuthHeaderWorks reports whether the OAuth2 server identified by the tokenURL
0000000000000000000000000000000000000000;;	// implements the OAuth2 spec correctly
0000000000000000000000000000000000000000;;	// See https://code.google.com/p/goauth2/issues/detail?id=31 for background.
0000000000000000000000000000000000000000;;	// In summary:
0000000000000000000000000000000000000000;;	// - Reddit only accepts client secret in the Authorization header
0000000000000000000000000000000000000000;;	// - Dropbox accepts either it in URL param or Auth header, but not both.
0000000000000000000000000000000000000000;;	// - Google only accepts URL param (not spec compliant?), not Auth header
0000000000000000000000000000000000000000;;	// - Stripe only accepts client secret in Auth header with Bearer method, not Basic
0000000000000000000000000000000000000000;;	func providerAuthHeaderWorks(tokenURL string) bool {
0000000000000000000000000000000000000000;;		for _, s := range brokenAuthHeaderProviders {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(tokenURL, s) {
0000000000000000000000000000000000000000;;				// Some sites fail to implement the OAuth2 spec fully.
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u, err := url.Parse(tokenURL); err == nil {
0000000000000000000000000000000000000000;;			for _, s := range brokenAuthHeaderDomains {
0000000000000000000000000000000000000000;;				if strings.HasSuffix(u.Host, s) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assume the provider implements the spec properly
0000000000000000000000000000000000000000;;		// otherwise. We can add more exceptions as they're
0000000000000000000000000000000000000000;;		// discovered. We will _not_ be adding configurable hooks
0000000000000000000000000000000000000000;;		// to this package to let users select server bugs.
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RetrieveToken(ctx context.Context, clientID, clientSecret, tokenURL string, v url.Values) (*Token, error) {
0000000000000000000000000000000000000000;;		hc, err := ContextClient(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bustedAuth := !providerAuthHeaderWorks(tokenURL)
0000000000000000000000000000000000000000;;		if bustedAuth {
0000000000000000000000000000000000000000;;			if clientID != "" {
0000000000000000000000000000000000000000;;				v.Set("client_id", clientID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if clientSecret != "" {
0000000000000000000000000000000000000000;;				v.Set("client_secret", clientSecret)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", tokenURL, strings.NewReader(v.Encode()))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
0000000000000000000000000000000000000000;;		if !bustedAuth {
0000000000000000000000000000000000000000;;			req.SetBasicAuth(clientID, clientSecret)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, err := hc.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer r.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1<<20))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2: cannot fetch token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if code := r.StatusCode; code < 200 || code > 299 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2: cannot fetch token: %v\nResponse: %s", r.Status, body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var token *Token
0000000000000000000000000000000000000000;;		content, _, _ := mime.ParseMediaType(r.Header.Get("Content-Type"))
0000000000000000000000000000000000000000;;		switch content {
0000000000000000000000000000000000000000;;		case "application/x-www-form-urlencoded", "text/plain":
0000000000000000000000000000000000000000;;			vals, err := url.ParseQuery(string(body))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			token = &Token{
0000000000000000000000000000000000000000;;				AccessToken:  vals.Get("access_token"),
0000000000000000000000000000000000000000;;				TokenType:    vals.Get("token_type"),
0000000000000000000000000000000000000000;;				RefreshToken: vals.Get("refresh_token"),
0000000000000000000000000000000000000000;;				Raw:          vals,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e := vals.Get("expires_in")
0000000000000000000000000000000000000000;;			if e == "" {
0000000000000000000000000000000000000000;;				// TODO(jbd): Facebook's OAuth2 implementation is broken and
0000000000000000000000000000000000000000;;				// returns expires_in field in expires. Remove the fallback to expires,
0000000000000000000000000000000000000000;;				// when Facebook fixes their implementation.
0000000000000000000000000000000000000000;;				e = vals.Get("expires")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			expires, _ := strconv.Atoi(e)
0000000000000000000000000000000000000000;;			if expires != 0 {
0000000000000000000000000000000000000000;;				token.Expiry = time.Now().Add(time.Duration(expires) * time.Second)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			var tj tokenJSON
0000000000000000000000000000000000000000;;			if err = json.Unmarshal(body, &tj); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			token = &Token{
0000000000000000000000000000000000000000;;				AccessToken:  tj.AccessToken,
0000000000000000000000000000000000000000;;				TokenType:    tj.TokenType,
0000000000000000000000000000000000000000;;				RefreshToken: tj.RefreshToken,
0000000000000000000000000000000000000000;;				Expiry:       tj.expiry(),
0000000000000000000000000000000000000000;;				Raw:          make(map[string]interface{}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			json.Unmarshal(body, &token.Raw) // no error checks for optional fields
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Don't overwrite `RefreshToken` with an empty value
0000000000000000000000000000000000000000;;		// if this was a token refreshing request.
0000000000000000000000000000000000000000;;		if token.RefreshToken == "" {
0000000000000000000000000000000000000000;;			token.RefreshToken = v.Get("refresh_token")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return token, nil
0000000000000000000000000000000000000000;;	}
