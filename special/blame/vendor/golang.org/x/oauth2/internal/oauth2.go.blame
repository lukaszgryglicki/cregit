0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/golang.org/x/oauth2/internal/oauth2.go[Godeps/_workspace/src/golang.org/x/oauth2/internal/oauth2.go][vendor/golang.org/x/oauth2/internal/oauth2.go];	
0000000000000000000000000000000000000000;;	// Package internal contains support packages for oauth2 package.
0000000000000000000000000000000000000000;;	package internal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseKey converts the binary contents of a private key file
0000000000000000000000000000000000000000;;	// to an *rsa.PrivateKey. It detects whether the private key is in a
0000000000000000000000000000000000000000;;	// PEM container or not. If so, it extracts the the private key
0000000000000000000000000000000000000000;;	// from PEM container before conversion. It only supports PEM
0000000000000000000000000000000000000000;;	// containers with no passphrase.
0000000000000000000000000000000000000000;;	func ParseKey(key []byte) (*rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		block, _ := pem.Decode(key)
0000000000000000000000000000000000000000;;		if block != nil {
0000000000000000000000000000000000000000;;			key = block.Bytes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parsedKey, err := x509.ParsePKCS8PrivateKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			parsedKey, err = x509.ParsePKCS1PrivateKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("private key should be a PEM or plain PKSC1 or PKCS8; parse error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parsed, ok := parsedKey.(*rsa.PrivateKey)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("private key is invalid")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parsed, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParseINI(ini io.Reader) (map[string]map[string]string, error) {
0000000000000000000000000000000000000000;;		result := map[string]map[string]string{
0000000000000000000000000000000000000000;;			"": {}, // root section
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(ini)
0000000000000000000000000000000000000000;;		currentSection := ""
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			line := strings.TrimSpace(scanner.Text())
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, ";") {
0000000000000000000000000000000000000000;;				// comment.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, "[") && strings.HasSuffix(line, "]") {
0000000000000000000000000000000000000000;;				currentSection = strings.TrimSpace(line[1 : len(line)-1])
0000000000000000000000000000000000000000;;				result[currentSection] = map[string]string{}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parts := strings.SplitN(line, "=", 2)
0000000000000000000000000000000000000000;;			if len(parts) == 2 && parts[0] != "" {
0000000000000000000000000000000000000000;;				result[currentSection][strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := scanner.Err(); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error scanning ini: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CondVal(v string) []string {
0000000000000000000000000000000000000000;;		if v == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []string{v}
0000000000000000000000000000000000000000;;	}
