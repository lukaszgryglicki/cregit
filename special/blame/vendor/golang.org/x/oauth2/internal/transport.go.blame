0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
ebf43e4ef7c9c1b2ea6bf70710d9b269028e79a0;Godeps/_workspace/src/golang.org/x/oauth2/internal/transport.go[Godeps/_workspace/src/golang.org/x/oauth2/internal/transport.go][vendor/golang.org/x/oauth2/internal/transport.go];	
0000000000000000000000000000000000000000;;	// Package internal contains support packages for oauth2 package.
0000000000000000000000000000000000000000;;	package internal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPClient is the context key to use with golang.org/x/net/context's
0000000000000000000000000000000000000000;;	// WithValue function to associate an *http.Client value with a context.
0000000000000000000000000000000000000000;;	var HTTPClient ContextKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContextKey is just an empty struct. It exists so HTTPClient can be
0000000000000000000000000000000000000000;;	// an immutable public variable with a unique type. It's immutable
0000000000000000000000000000000000000000;;	// because nobody else can create a ContextKey, being unexported.
0000000000000000000000000000000000000000;;	type ContextKey struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContextClientFunc is a func which tries to return an *http.Client
0000000000000000000000000000000000000000;;	// given a Context value. If it returns an error, the search stops
0000000000000000000000000000000000000000;;	// with that error.  If it returns (nil, nil), the search continues
0000000000000000000000000000000000000000;;	// down the list of registered funcs.
0000000000000000000000000000000000000000;;	type ContextClientFunc func(context.Context) (*http.Client, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var contextClientFuncs []ContextClientFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RegisterContextClientFunc(fn ContextClientFunc) {
0000000000000000000000000000000000000000;;		contextClientFuncs = append(contextClientFuncs, fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ContextClient(ctx context.Context) (*http.Client, error) {
0000000000000000000000000000000000000000;;		if ctx != nil {
0000000000000000000000000000000000000000;;			if hc, ok := ctx.Value(HTTPClient).(*http.Client); ok {
0000000000000000000000000000000000000000;;				return hc, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, fn := range contextClientFuncs {
0000000000000000000000000000000000000000;;			c, err := fn(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != nil {
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return http.DefaultClient, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ContextTransport(ctx context.Context) http.RoundTripper {
0000000000000000000000000000000000000000;;		hc, err := ContextClient(ctx)
0000000000000000000000000000000000000000;;		// This is a rare error case (somebody using nil on App Engine).
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ErrorTransport{err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hc.Transport
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorTransport returns the specified error on RoundTrip.
0000000000000000000000000000000000000000;;	// This RoundTripper should be used in rare error cases where
0000000000000000000000000000000000000000;;	// error handling can be postponed to response handling time.
0000000000000000000000000000000000000000;;	type ErrorTransport struct{ Err error }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t ErrorTransport) RoundTrip(*http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return nil, t.Err
0000000000000000000000000000000000000000;;	}
