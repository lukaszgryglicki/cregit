0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/golang.org/x/oauth2/jwt/jwt.go[Godeps/_workspace/src/golang.org/x/oauth2/jwt/jwt.go][vendor/golang.org/x/oauth2/jwt/jwt.go];	
0000000000000000000000000000000000000000;;	// Package jwt implements the OAuth 2.0 JSON Web Token flow, commonly
0000000000000000000000000000000000000000;;	// known as "two-legged OAuth 2.0".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See: https://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-12
0000000000000000000000000000000000000000;;	package jwt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/internal"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/jws"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		defaultGrantType = "urn:ietf:params:oauth:grant-type:jwt-bearer"
0000000000000000000000000000000000000000;;		defaultHeader    = &jws.Header{Algorithm: "RS256", Typ: "JWT"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config is the configuration for using JWT to fetch tokens,
0000000000000000000000000000000000000000;;	// commonly known as "two-legged OAuth 2.0".
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// Email is the OAuth client identifier used when communicating with
0000000000000000000000000000000000000000;;		// the configured OAuth provider.
0000000000000000000000000000000000000000;;		Email string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PrivateKey contains the contents of an RSA private key or the
0000000000000000000000000000000000000000;;		// contents of a PEM file that contains a private key. The provided
0000000000000000000000000000000000000000;;		// private key is used to sign JWT payloads.
0000000000000000000000000000000000000000;;		// PEM containers with a passphrase are not supported.
0000000000000000000000000000000000000000;;		// Use the following command to convert a PKCS 12 file into a PEM.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//    $ openssl pkcs12 -in key.p12 -out key.pem -nodes
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		PrivateKey []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PrivateKeyID contains an optional hint indicating which key is being
0000000000000000000000000000000000000000;;		// used.
0000000000000000000000000000000000000000;;		PrivateKeyID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Subject is the optional user to impersonate.
0000000000000000000000000000000000000000;;		Subject string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scopes optionally specifies a list of requested permission scopes.
0000000000000000000000000000000000000000;;		Scopes []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TokenURL is the endpoint required to complete the 2-legged JWT flow.
0000000000000000000000000000000000000000;;		TokenURL string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expires optionally specifies how long the token is valid for.
0000000000000000000000000000000000000000;;		Expires time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TokenSource returns a JWT TokenSource using the configuration
0000000000000000000000000000000000000000;;	// in c and the HTTP client from the provided context.
0000000000000000000000000000000000000000;;	func (c *Config) TokenSource(ctx context.Context) oauth2.TokenSource {
0000000000000000000000000000000000000000;;		return oauth2.ReuseTokenSource(nil, jwtSource{ctx, c})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client returns an HTTP client wrapping the context's
0000000000000000000000000000000000000000;;	// HTTP transport and adding Authorization headers with tokens
0000000000000000000000000000000000000000;;	// obtained from c.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The returned client and its Transport should not be modified.
0000000000000000000000000000000000000000;;	func (c *Config) Client(ctx context.Context) *http.Client {
0000000000000000000000000000000000000000;;		return oauth2.NewClient(ctx, c.TokenSource(ctx))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// jwtSource is a source that always does a signed JWT request for a token.
0000000000000000000000000000000000000000;;	// It should typically be wrapped with a reuseTokenSource.
0000000000000000000000000000000000000000;;	type jwtSource struct {
0000000000000000000000000000000000000000;;		ctx  context.Context
0000000000000000000000000000000000000000;;		conf *Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (js jwtSource) Token() (*oauth2.Token, error) {
0000000000000000000000000000000000000000;;		pk, err := internal.ParseKey(js.conf.PrivateKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hc := oauth2.NewClient(js.ctx, nil)
0000000000000000000000000000000000000000;;		claimSet := &jws.ClaimSet{
0000000000000000000000000000000000000000;;			Iss:   js.conf.Email,
0000000000000000000000000000000000000000;;			Scope: strings.Join(js.conf.Scopes, " "),
0000000000000000000000000000000000000000;;			Aud:   js.conf.TokenURL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if subject := js.conf.Subject; subject != "" {
0000000000000000000000000000000000000000;;			claimSet.Sub = subject
0000000000000000000000000000000000000000;;			// prn is the old name of sub. Keep setting it
0000000000000000000000000000000000000000;;			// to be compatible with legacy OAuth 2.0 providers.
0000000000000000000000000000000000000000;;			claimSet.Prn = subject
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t := js.conf.Expires; t > 0 {
0000000000000000000000000000000000000000;;			claimSet.Exp = time.Now().Add(t).Unix()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := *defaultHeader
0000000000000000000000000000000000000000;;		h.KeyID = js.conf.PrivateKeyID
0000000000000000000000000000000000000000;;		payload, err := jws.Encode(&h, claimSet, pk)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := url.Values{}
0000000000000000000000000000000000000000;;		v.Set("grant_type", defaultGrantType)
0000000000000000000000000000000000000000;;		v.Set("assertion", payload)
0000000000000000000000000000000000000000;;		resp, err := hc.PostForm(js.conf.TokenURL, v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2: cannot fetch token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(io.LimitReader(resp.Body, 1<<20))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2: cannot fetch token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c := resp.StatusCode; c < 200 || c > 299 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2: cannot fetch token: %v\nResponse: %s", resp.Status, body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// tokenRes is the JSON response body.
0000000000000000000000000000000000000000;;		var tokenRes struct {
0000000000000000000000000000000000000000;;			AccessToken string `json:"access_token"`
0000000000000000000000000000000000000000;;			TokenType   string `json:"token_type"`
0000000000000000000000000000000000000000;;			IDToken     string `json:"id_token"`
0000000000000000000000000000000000000000;;			ExpiresIn   int64  `json:"expires_in"` // relative seconds from now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(body, &tokenRes); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("oauth2: cannot fetch token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token := &oauth2.Token{
0000000000000000000000000000000000000000;;			AccessToken: tokenRes.AccessToken,
0000000000000000000000000000000000000000;;			TokenType:   tokenRes.TokenType,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		raw := make(map[string]interface{})
0000000000000000000000000000000000000000;;		json.Unmarshal(body, &raw) // no error checks for optional fields
0000000000000000000000000000000000000000;;		token = token.WithExtra(raw)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if secs := tokenRes.ExpiresIn; secs > 0 {
0000000000000000000000000000000000000000;;			token.Expiry = time.Now().Add(time.Duration(secs) * time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v := tokenRes.IDToken; v != "" {
0000000000000000000000000000000000000000;;			// decode returned id token to get expiry
0000000000000000000000000000000000000000;;			claimSet, err := jws.Decode(v)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("oauth2: error decoding JWT token: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			token.Expiry = time.Unix(claimSet.Exp, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return token, nil
0000000000000000000000000000000000000000;;	}
