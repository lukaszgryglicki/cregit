0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/golang.org/x/oauth2/transport.go[Godeps/_workspace/src/golang.org/x/oauth2/transport.go][vendor/golang.org/x/oauth2/transport.go];	
0000000000000000000000000000000000000000;;	package oauth2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transport is an http.RoundTripper that makes OAuth 2.0 HTTP requests,
0000000000000000000000000000000000000000;;	// wrapping a base RoundTripper and adding an Authorization header
0000000000000000000000000000000000000000;;	// with a token from the supplied Sources.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Transport is a low-level mechanism. Most code will use the
0000000000000000000000000000000000000000;;	// higher-level Config.Client method instead.
0000000000000000000000000000000000000000;;	type Transport struct {
0000000000000000000000000000000000000000;;		// Source supplies the token to add to outgoing requests'
0000000000000000000000000000000000000000;;		// Authorization headers.
0000000000000000000000000000000000000000;;		Source TokenSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Base is the base RoundTripper used to make HTTP requests.
0000000000000000000000000000000000000000;;		// If nil, http.DefaultTransport is used.
0000000000000000000000000000000000000000;;		Base http.RoundTripper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu     sync.Mutex                      // guards modReq
0000000000000000000000000000000000000000;;		modReq map[*http.Request]*http.Request // original -> modified
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTrip authorizes and authenticates the request with an
0000000000000000000000000000000000000000;;	// access token. If no token exists or token is expired,
0000000000000000000000000000000000000000;;	// tries to refresh/fetch a new token.
0000000000000000000000000000000000000000;;	func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if t.Source == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("oauth2: Transport's Source is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token, err := t.Source.Token()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req2 := cloneRequest(req) // per RoundTripper contract
0000000000000000000000000000000000000000;;		token.SetAuthHeader(req2)
0000000000000000000000000000000000000000;;		t.setModReq(req, req2)
0000000000000000000000000000000000000000;;		res, err := t.base().RoundTrip(req2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.setModReq(req, nil)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res.Body = &onEOFReader{
0000000000000000000000000000000000000000;;			rc: res.Body,
0000000000000000000000000000000000000000;;			fn: func() { t.setModReq(req, nil) },
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CancelRequest cancels an in-flight request by closing its connection.
0000000000000000000000000000000000000000;;	func (t *Transport) CancelRequest(req *http.Request) {
0000000000000000000000000000000000000000;;		type canceler interface {
0000000000000000000000000000000000000000;;			CancelRequest(*http.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cr, ok := t.base().(canceler); ok {
0000000000000000000000000000000000000000;;			t.mu.Lock()
0000000000000000000000000000000000000000;;			modReq := t.modReq[req]
0000000000000000000000000000000000000000;;			delete(t.modReq, req)
0000000000000000000000000000000000000000;;			t.mu.Unlock()
0000000000000000000000000000000000000000;;			cr.CancelRequest(modReq)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) base() http.RoundTripper {
0000000000000000000000000000000000000000;;		if t.Base != nil {
0000000000000000000000000000000000000000;;			return t.Base
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return http.DefaultTransport
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) setModReq(orig, mod *http.Request) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		if t.modReq == nil {
0000000000000000000000000000000000000000;;			t.modReq = make(map[*http.Request]*http.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mod == nil {
0000000000000000000000000000000000000000;;			delete(t.modReq, orig)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.modReq[orig] = mod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cloneRequest returns a clone of the provided *http.Request.
0000000000000000000000000000000000000000;;	// The clone is a shallow copy of the struct and its Header map.
0000000000000000000000000000000000000000;;	func cloneRequest(r *http.Request) *http.Request {
0000000000000000000000000000000000000000;;		// shallow copy of the struct
0000000000000000000000000000000000000000;;		r2 := new(http.Request)
0000000000000000000000000000000000000000;;		*r2 = *r
0000000000000000000000000000000000000000;;		// deep copy of the Header
0000000000000000000000000000000000000000;;		r2.Header = make(http.Header, len(r.Header))
0000000000000000000000000000000000000000;;		for k, s := range r.Header {
0000000000000000000000000000000000000000;;			r2.Header[k] = append([]string(nil), s...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type onEOFReader struct {
0000000000000000000000000000000000000000;;		rc io.ReadCloser
0000000000000000000000000000000000000000;;		fn func()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *onEOFReader) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		n, err = r.rc.Read(p)
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			r.runFunc()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *onEOFReader) Close() error {
0000000000000000000000000000000000000000;;		err := r.rc.Close()
0000000000000000000000000000000000000000;;		r.runFunc()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *onEOFReader) runFunc() {
0000000000000000000000000000000000000000;;		if fn := r.fn; fn != nil {
0000000000000000000000000000000000000000;;			fn()
0000000000000000000000000000000000000000;;			r.fn = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
