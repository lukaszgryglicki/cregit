0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
fb07fa00004c1f8a445543653f60d38694101f82;Godeps/_workspace/src/golang.org/x/oauth2/jws/jws.go[Godeps/_workspace/src/golang.org/x/oauth2/jws/jws.go][vendor/golang.org/x/oauth2/jws/jws.go];	
0000000000000000000000000000000000000000;;	// Package jws provides a partial implementation
0000000000000000000000000000000000000000;;	// of JSON Web Signature encoding and decoding.
0000000000000000000000000000000000000000;;	// It exists to support the golang.org/x/oauth2 package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See RFC 7515.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Deprecated: this package is not intended for public use and might be
0000000000000000000000000000000000000000;;	// removed in the future. It exists for internal use only.
0000000000000000000000000000000000000000;;	// Please switch to another JWS package or copy this package into your own
0000000000000000000000000000000000000000;;	// source tree.
0000000000000000000000000000000000000000;;	package jws
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClaimSet contains information about the JWT signature including the
0000000000000000000000000000000000000000;;	// permissions being requested (scopes), the target of the token, the issuer,
0000000000000000000000000000000000000000;;	// the time the token was issued, and the lifetime of the token.
0000000000000000000000000000000000000000;;	type ClaimSet struct {
0000000000000000000000000000000000000000;;		Iss   string `json:"iss"`             // email address of the client_id of the application making the access token request
0000000000000000000000000000000000000000;;		Scope string `json:"scope,omitempty"` // space-delimited list of the permissions the application requests
0000000000000000000000000000000000000000;;		Aud   string `json:"aud"`             // descriptor of the intended target of the assertion (Optional).
0000000000000000000000000000000000000000;;		Exp   int64  `json:"exp"`             // the expiration time of the assertion (seconds since Unix epoch)
0000000000000000000000000000000000000000;;		Iat   int64  `json:"iat"`             // the time the assertion was issued (seconds since Unix epoch)
0000000000000000000000000000000000000000;;		Typ   string `json:"typ,omitempty"`   // token type (Optional).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Email for which the application is requesting delegated access (Optional).
0000000000000000000000000000000000000000;;		Sub string `json:"sub,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The old name of Sub. Client keeps setting Prn to be
0000000000000000000000000000000000000000;;		// complaint with legacy OAuth 2.0 providers. (Optional)
0000000000000000000000000000000000000000;;		Prn string `json:"prn,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// See http://tools.ietf.org/html/draft-jones-json-web-token-10#section-4.3
0000000000000000000000000000000000000000;;		// This array is marshalled using custom code (see (c *ClaimSet) encode()).
0000000000000000000000000000000000000000;;		PrivateClaims map[string]interface{} `json:"-"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ClaimSet) encode() (string, error) {
0000000000000000000000000000000000000000;;		// Reverting time back for machines whose time is not perfectly in sync.
0000000000000000000000000000000000000000;;		// If client machine's time is in the future according
0000000000000000000000000000000000000000;;		// to Google servers, an access token will not be issued.
0000000000000000000000000000000000000000;;		now := time.Now().Add(-10 * time.Second)
0000000000000000000000000000000000000000;;		if c.Iat == 0 {
0000000000000000000000000000000000000000;;			c.Iat = now.Unix()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.Exp == 0 {
0000000000000000000000000000000000000000;;			c.Exp = now.Add(time.Hour).Unix()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.Exp < c.Iat {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("jws: invalid Exp = %v; must be later than Iat = %v", c.Exp, c.Iat)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := json.Marshal(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.PrivateClaims) == 0 {
0000000000000000000000000000000000000000;;			return base64.RawURLEncoding.EncodeToString(b), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Marshal private claim set and then append it to b.
0000000000000000000000000000000000000000;;		prv, err := json.Marshal(c.PrivateClaims)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("jws: invalid map of private claims %v", c.PrivateClaims)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Concatenate public and private claim JSON objects.
0000000000000000000000000000000000000000;;		if !bytes.HasSuffix(b, []byte{'}'}) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("jws: invalid JSON %s", b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !bytes.HasPrefix(prv, []byte{'{'}) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("jws: invalid JSON %s", prv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b[len(b)-1] = ','         // Replace closing curly brace with a comma.
0000000000000000000000000000000000000000;;		b = append(b, prv[1:]...) // Append private claims.
0000000000000000000000000000000000000000;;		return base64.RawURLEncoding.EncodeToString(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Header represents the header for the signed JWS payloads.
0000000000000000000000000000000000000000;;	type Header struct {
0000000000000000000000000000000000000000;;		// The algorithm used for signature.
0000000000000000000000000000000000000000;;		Algorithm string `json:"alg"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Represents the token type.
0000000000000000000000000000000000000000;;		Typ string `json:"typ"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The optional hint of which key is being used.
0000000000000000000000000000000000000000;;		KeyID string `json:"kid,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *Header) encode() (string, error) {
0000000000000000000000000000000000000000;;		b, err := json.Marshal(h)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return base64.RawURLEncoding.EncodeToString(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode decodes a claim set from a JWS payload.
0000000000000000000000000000000000000000;;	func Decode(payload string) (*ClaimSet, error) {
0000000000000000000000000000000000000000;;		// decode returned id token to get expiry
0000000000000000000000000000000000000000;;		s := strings.Split(payload, ".")
0000000000000000000000000000000000000000;;		if len(s) < 2 {
0000000000000000000000000000000000000000;;			// TODO(jbd): Provide more context about the error.
0000000000000000000000000000000000000000;;			return nil, errors.New("jws: invalid token received")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decoded, err := base64.RawURLEncoding.DecodeString(s[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := &ClaimSet{}
0000000000000000000000000000000000000000;;		err = json.NewDecoder(bytes.NewBuffer(decoded)).Decode(c)
0000000000000000000000000000000000000000;;		return c, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signer returns a signature for the given data.
0000000000000000000000000000000000000000;;	type Signer func(data []byte) (sig []byte, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeWithSigner encodes a header and claim set with the provided signer.
0000000000000000000000000000000000000000;;	func EncodeWithSigner(header *Header, c *ClaimSet, sg Signer) (string, error) {
0000000000000000000000000000000000000000;;		head, err := header.encode()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs, err := c.encode()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss := fmt.Sprintf("%s.%s", head, cs)
0000000000000000000000000000000000000000;;		sig, err := sg([]byte(ss))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s.%s", ss, base64.RawURLEncoding.EncodeToString(sig)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode encodes a signed JWS with provided header and claim set.
0000000000000000000000000000000000000000;;	// This invokes EncodeWithSigner using crypto/rsa.SignPKCS1v15 with the given RSA private key.
0000000000000000000000000000000000000000;;	func Encode(header *Header, c *ClaimSet, key *rsa.PrivateKey) (string, error) {
0000000000000000000000000000000000000000;;		sg := func(data []byte) (sig []byte, err error) {
0000000000000000000000000000000000000000;;			h := sha256.New()
0000000000000000000000000000000000000000;;			h.Write(data)
0000000000000000000000000000000000000000;;			return rsa.SignPKCS1v15(rand.Reader, key, crypto.SHA256, h.Sum(nil))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return EncodeWithSigner(header, c, sg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify tests whether the provided JWT token's signature was produced by the private key
0000000000000000000000000000000000000000;;	// associated with the supplied public key.
0000000000000000000000000000000000000000;;	func Verify(token string, key *rsa.PublicKey) error {
0000000000000000000000000000000000000000;;		parts := strings.Split(token, ".")
0000000000000000000000000000000000000000;;		if len(parts) != 3 {
0000000000000000000000000000000000000000;;			return errors.New("jws: invalid token received, token must have 3 parts")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signedContent := parts[0] + "." + parts[1]
0000000000000000000000000000000000000000;;		signatureString, err := base64.RawURLEncoding.DecodeString(parts[2])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := sha256.New()
0000000000000000000000000000000000000000;;		h.Write([]byte(signedContent))
0000000000000000000000000000000000000000;;		return rsa.VerifyPKCS1v15(key, crypto.SHA256, h.Sum(nil), []byte(signatureString))
0000000000000000000000000000000000000000;;	}
