0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
6cf8b80e5da3322f98ca221bde5f9ff5eb4fa392;Godeps/_workspace/src/golang.org/x/net/trace/histogram.go[Godeps/_workspace/src/golang.org/x/net/trace/histogram.go][vendor/golang.org/x/net/trace/histogram.go];	
0000000000000000000000000000000000000000;;	package trace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file implements histogramming for RPC statistics collection.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"html/template"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/internal/timeseries"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bucketCount = 38
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// histogram keeps counts of values in buckets that are spaced
0000000000000000000000000000000000000000;;	// out in powers of 2: 0-1, 2-3, 4-7...
0000000000000000000000000000000000000000;;	// histogram implements timeseries.Observable
0000000000000000000000000000000000000000;;	type histogram struct {
0000000000000000000000000000000000000000;;		sum          int64   // running total of measurements
0000000000000000000000000000000000000000;;		sumOfSquares float64 // square of running total
0000000000000000000000000000000000000000;;		buckets      []int64 // bucketed values for histogram
0000000000000000000000000000000000000000;;		value        int     // holds a single value as an optimization
0000000000000000000000000000000000000000;;		valueCount   int64   // number of values recorded for single value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddMeasurement records a value measurement observation to the histogram.
0000000000000000000000000000000000000000;;	func (h *histogram) addMeasurement(value int64) {
0000000000000000000000000000000000000000;;		// TODO: assert invariant
0000000000000000000000000000000000000000;;		h.sum += value
0000000000000000000000000000000000000000;;		h.sumOfSquares += float64(value) * float64(value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bucketIndex := getBucket(value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h.valueCount == 0 || (h.valueCount > 0 && h.value == bucketIndex) {
0000000000000000000000000000000000000000;;			h.value = bucketIndex
0000000000000000000000000000000000000000;;			h.valueCount++
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			h.allocateBuckets()
0000000000000000000000000000000000000000;;			h.buckets[bucketIndex]++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *histogram) allocateBuckets() {
0000000000000000000000000000000000000000;;		if h.buckets == nil {
0000000000000000000000000000000000000000;;			h.buckets = make([]int64, bucketCount)
0000000000000000000000000000000000000000;;			h.buckets[h.value] = h.valueCount
0000000000000000000000000000000000000000;;			h.value = 0
0000000000000000000000000000000000000000;;			h.valueCount = -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func log2(i int64) int {
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		for ; i >= 0x100; i >>= 8 {
0000000000000000000000000000000000000000;;			n += 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for ; i > 0; i >>= 1 {
0000000000000000000000000000000000000000;;			n += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getBucket(i int64) (index int) {
0000000000000000000000000000000000000000;;		index = log2(i) - 1
0000000000000000000000000000000000000000;;		if index < 0 {
0000000000000000000000000000000000000000;;			index = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if index >= bucketCount {
0000000000000000000000000000000000000000;;			index = bucketCount - 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Total returns the number of recorded observations.
0000000000000000000000000000000000000000;;	func (h *histogram) total() (total int64) {
0000000000000000000000000000000000000000;;		if h.valueCount >= 0 {
0000000000000000000000000000000000000000;;			total = h.valueCount
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, val := range h.buckets {
0000000000000000000000000000000000000000;;			total += int64(val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Average returns the average value of recorded observations.
0000000000000000000000000000000000000000;;	func (h *histogram) average() float64 {
0000000000000000000000000000000000000000;;		t := h.total()
0000000000000000000000000000000000000000;;		if t == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return float64(h.sum) / float64(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Variance returns the variance of recorded observations.
0000000000000000000000000000000000000000;;	func (h *histogram) variance() float64 {
0000000000000000000000000000000000000000;;		t := float64(h.total())
0000000000000000000000000000000000000000;;		if t == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := float64(h.sum) / t
0000000000000000000000000000000000000000;;		return h.sumOfSquares/t - s*s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StandardDeviation returns the standard deviation of recorded observations.
0000000000000000000000000000000000000000;;	func (h *histogram) standardDeviation() float64 {
0000000000000000000000000000000000000000;;		return math.Sqrt(h.variance())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PercentileBoundary estimates the value that the given fraction of recorded
0000000000000000000000000000000000000000;;	// observations are less than.
0000000000000000000000000000000000000000;;	func (h *histogram) percentileBoundary(percentile float64) int64 {
0000000000000000000000000000000000000000;;		total := h.total()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Corner cases (make sure result is strictly less than Total())
0000000000000000000000000000000000000000;;		if total == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		} else if total == 1 {
0000000000000000000000000000000000000000;;			return int64(h.average())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		percentOfTotal := round(float64(total) * percentile)
0000000000000000000000000000000000000000;;		var runningTotal int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range h.buckets {
0000000000000000000000000000000000000000;;			value := h.buckets[i]
0000000000000000000000000000000000000000;;			runningTotal += value
0000000000000000000000000000000000000000;;			if runningTotal == percentOfTotal {
0000000000000000000000000000000000000000;;				// We hit an exact bucket boundary. If the next bucket has data, it is a
0000000000000000000000000000000000000000;;				// good estimate of the value. If the bucket is empty, we interpolate the
0000000000000000000000000000000000000000;;				// midpoint between the next bucket's boundary and the next non-zero
0000000000000000000000000000000000000000;;				// bucket. If the remaining buckets are all empty, then we use the
0000000000000000000000000000000000000000;;				// boundary for the next bucket as the estimate.
0000000000000000000000000000000000000000;;				j := uint8(i + 1)
0000000000000000000000000000000000000000;;				min := bucketBoundary(j)
0000000000000000000000000000000000000000;;				if runningTotal < total {
0000000000000000000000000000000000000000;;					for h.buckets[j] == 0 {
0000000000000000000000000000000000000000;;						j++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				max := bucketBoundary(j)
0000000000000000000000000000000000000000;;				return min + round(float64(max-min)/2)
0000000000000000000000000000000000000000;;			} else if runningTotal > percentOfTotal {
0000000000000000000000000000000000000000;;				// The value is in this bucket. Interpolate the value.
0000000000000000000000000000000000000000;;				delta := runningTotal - percentOfTotal
0000000000000000000000000000000000000000;;				percentBucket := float64(value-delta) / float64(value)
0000000000000000000000000000000000000000;;				bucketMin := bucketBoundary(uint8(i))
0000000000000000000000000000000000000000;;				nextBucketMin := bucketBoundary(uint8(i + 1))
0000000000000000000000000000000000000000;;				bucketSize := nextBucketMin - bucketMin
0000000000000000000000000000000000000000;;				return bucketMin + round(percentBucket*float64(bucketSize))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bucketBoundary(bucketCount - 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Median returns the estimated median of the observed values.
0000000000000000000000000000000000000000;;	func (h *histogram) median() int64 {
0000000000000000000000000000000000000000;;		return h.percentileBoundary(0.5)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds other to h.
0000000000000000000000000000000000000000;;	func (h *histogram) Add(other timeseries.Observable) {
0000000000000000000000000000000000000000;;		o := other.(*histogram)
0000000000000000000000000000000000000000;;		if o.valueCount == 0 {
0000000000000000000000000000000000000000;;			// Other histogram is empty
0000000000000000000000000000000000000000;;		} else if h.valueCount >= 0 && o.valueCount > 0 && h.value == o.value {
0000000000000000000000000000000000000000;;			// Both have a single bucketed value, aggregate them
0000000000000000000000000000000000000000;;			h.valueCount += o.valueCount
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Two different values necessitate buckets in this histogram
0000000000000000000000000000000000000000;;			h.allocateBuckets()
0000000000000000000000000000000000000000;;			if o.valueCount >= 0 {
0000000000000000000000000000000000000000;;				h.buckets[o.value] += o.valueCount
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for i := range h.buckets {
0000000000000000000000000000000000000000;;					h.buckets[i] += o.buckets[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.sumOfSquares += o.sumOfSquares
0000000000000000000000000000000000000000;;		h.sum += o.sum
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clear resets the histogram to an empty state, removing all observed values.
0000000000000000000000000000000000000000;;	func (h *histogram) Clear() {
0000000000000000000000000000000000000000;;		h.buckets = nil
0000000000000000000000000000000000000000;;		h.value = 0
0000000000000000000000000000000000000000;;		h.valueCount = 0
0000000000000000000000000000000000000000;;		h.sum = 0
0000000000000000000000000000000000000000;;		h.sumOfSquares = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyFrom copies from other, which must be a *histogram, into h.
0000000000000000000000000000000000000000;;	func (h *histogram) CopyFrom(other timeseries.Observable) {
0000000000000000000000000000000000000000;;		o := other.(*histogram)
0000000000000000000000000000000000000000;;		if o.valueCount == -1 {
0000000000000000000000000000000000000000;;			h.allocateBuckets()
0000000000000000000000000000000000000000;;			copy(h.buckets, o.buckets)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.sum = o.sum
0000000000000000000000000000000000000000;;		h.sumOfSquares = o.sumOfSquares
0000000000000000000000000000000000000000;;		h.value = o.value
0000000000000000000000000000000000000000;;		h.valueCount = o.valueCount
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Multiply scales the histogram by the specified ratio.
0000000000000000000000000000000000000000;;	func (h *histogram) Multiply(ratio float64) {
0000000000000000000000000000000000000000;;		if h.valueCount == -1 {
0000000000000000000000000000000000000000;;			for i := range h.buckets {
0000000000000000000000000000000000000000;;				h.buckets[i] = int64(float64(h.buckets[i]) * ratio)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			h.valueCount = int64(float64(h.valueCount) * ratio)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.sum = int64(float64(h.sum) * ratio)
0000000000000000000000000000000000000000;;		h.sumOfSquares = h.sumOfSquares * ratio
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new histogram.
0000000000000000000000000000000000000000;;	func (h *histogram) New() timeseries.Observable {
0000000000000000000000000000000000000000;;		r := new(histogram)
0000000000000000000000000000000000000000;;		r.Clear()
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *histogram) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%d, %f, %d, %d, %v",
0000000000000000000000000000000000000000;;			h.sum, h.sumOfSquares, h.value, h.valueCount, h.buckets)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// round returns the closest int64 to the argument
0000000000000000000000000000000000000000;;	func round(in float64) int64 {
0000000000000000000000000000000000000000;;		return int64(math.Floor(in + 0.5))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bucketBoundary returns the first value in the bucket.
0000000000000000000000000000000000000000;;	func bucketBoundary(bucket uint8) int64 {
0000000000000000000000000000000000000000;;		if bucket == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 1 << bucket
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bucketData holds data about a specific bucket for use in distTmpl.
0000000000000000000000000000000000000000;;	type bucketData struct {
0000000000000000000000000000000000000000;;		Lower, Upper       int64
0000000000000000000000000000000000000000;;		N                  int64
0000000000000000000000000000000000000000;;		Pct, CumulativePct float64
0000000000000000000000000000000000000000;;		GraphWidth         int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// data holds data about a Distribution for use in distTmpl.
0000000000000000000000000000000000000000;;	type data struct {
0000000000000000000000000000000000000000;;		Buckets                 []*bucketData
0000000000000000000000000000000000000000;;		Count, Median           int64
0000000000000000000000000000000000000000;;		Mean, StandardDeviation float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxHTMLBarWidth is the maximum width of the HTML bar for visualizing buckets.
0000000000000000000000000000000000000000;;	const maxHTMLBarWidth = 350.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newData returns data representing h for use in distTmpl.
0000000000000000000000000000000000000000;;	func (h *histogram) newData() *data {
0000000000000000000000000000000000000000;;		// Force the allocation of buckets to simplify the rendering implementation
0000000000000000000000000000000000000000;;		h.allocateBuckets()
0000000000000000000000000000000000000000;;		// We scale the bars on the right so that the largest bar is
0000000000000000000000000000000000000000;;		// maxHTMLBarWidth pixels in width.
0000000000000000000000000000000000000000;;		maxBucket := int64(0)
0000000000000000000000000000000000000000;;		for _, n := range h.buckets {
0000000000000000000000000000000000000000;;			if n > maxBucket {
0000000000000000000000000000000000000000;;				maxBucket = n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		total := h.total()
0000000000000000000000000000000000000000;;		barsizeMult := maxHTMLBarWidth / float64(maxBucket)
0000000000000000000000000000000000000000;;		var pctMult float64
0000000000000000000000000000000000000000;;		if total == 0 {
0000000000000000000000000000000000000000;;			pctMult = 1.0
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pctMult = 100.0 / float64(total)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buckets := make([]*bucketData, len(h.buckets))
0000000000000000000000000000000000000000;;		runningTotal := int64(0)
0000000000000000000000000000000000000000;;		for i, n := range h.buckets {
0000000000000000000000000000000000000000;;			if n == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			runningTotal += n
0000000000000000000000000000000000000000;;			var upperBound int64
0000000000000000000000000000000000000000;;			if i < bucketCount-1 {
0000000000000000000000000000000000000000;;				upperBound = bucketBoundary(uint8(i + 1))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				upperBound = math.MaxInt64
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buckets[i] = &bucketData{
0000000000000000000000000000000000000000;;				Lower:         bucketBoundary(uint8(i)),
0000000000000000000000000000000000000000;;				Upper:         upperBound,
0000000000000000000000000000000000000000;;				N:             n,
0000000000000000000000000000000000000000;;				Pct:           float64(n) * pctMult,
0000000000000000000000000000000000000000;;				CumulativePct: float64(runningTotal) * pctMult,
0000000000000000000000000000000000000000;;				GraphWidth:    int(float64(n) * barsizeMult),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &data{
0000000000000000000000000000000000000000;;			Buckets:           buckets,
0000000000000000000000000000000000000000;;			Count:             total,
0000000000000000000000000000000000000000;;			Median:            h.median(),
0000000000000000000000000000000000000000;;			Mean:              h.average(),
0000000000000000000000000000000000000000;;			StandardDeviation: h.standardDeviation(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *histogram) html() template.HTML {
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		if err := distTmpl().Execute(buf, h.newData()); err != nil {
0000000000000000000000000000000000000000;;			buf.Reset()
0000000000000000000000000000000000000000;;			log.Printf("net/trace: couldn't execute template: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return template.HTML(buf.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var distTmplCache *template.Template
0000000000000000000000000000000000000000;;	var distTmplOnce sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func distTmpl() *template.Template {
0000000000000000000000000000000000000000;;		distTmplOnce.Do(func() {
0000000000000000000000000000000000000000;;			// Input: data
0000000000000000000000000000000000000000;;			distTmplCache = template.Must(template.New("distTmpl").Parse(`
0000000000000000000000000000000000000000;;	<table>
0000000000000000000000000000000000000000;;	<tr>
0000000000000000000000000000000000000000;;	    <td style="padding:0.25em">Count: {{.Count}}</td>
0000000000000000000000000000000000000000;;	    <td style="padding:0.25em">Mean: {{printf "%.0f" .Mean}}</td>
0000000000000000000000000000000000000000;;	    <td style="padding:0.25em">StdDev: {{printf "%.0f" .StandardDeviation}}</td>
0000000000000000000000000000000000000000;;	    <td style="padding:0.25em">Median: {{.Median}}</td>
0000000000000000000000000000000000000000;;	</tr>
0000000000000000000000000000000000000000;;	</table>
0000000000000000000000000000000000000000;;	<hr>
0000000000000000000000000000000000000000;;	<table>
0000000000000000000000000000000000000000;;	{{range $b := .Buckets}}
0000000000000000000000000000000000000000;;	{{if $b}}
0000000000000000000000000000000000000000;;	  <tr>
0000000000000000000000000000000000000000;;	    <td style="padding:0 0 0 0.25em">[</td>
0000000000000000000000000000000000000000;;	    <td style="text-align:right;padding:0 0.25em">{{.Lower}},</td>
0000000000000000000000000000000000000000;;	    <td style="text-align:right;padding:0 0.25em">{{.Upper}})</td>
0000000000000000000000000000000000000000;;	    <td style="text-align:right;padding:0 0.25em">{{.N}}</td>
0000000000000000000000000000000000000000;;	    <td style="text-align:right;padding:0 0.25em">{{printf "%#.3f" .Pct}}%</td>
0000000000000000000000000000000000000000;;	    <td style="text-align:right;padding:0 0.25em">{{printf "%#.3f" .CumulativePct}}%</td>
0000000000000000000000000000000000000000;;	    <td><div style="background-color: blue; height: 1em; width: {{.GraphWidth}};"></div></td>
0000000000000000000000000000000000000000;;	  </tr>
0000000000000000000000000000000000000000;;	{{end}}
0000000000000000000000000000000000000000;;	{{end}}
0000000000000000000000000000000000000000;;	</table>
0000000000000000000000000000000000000000;;	`))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return distTmplCache
0000000000000000000000000000000000000000;;	}
