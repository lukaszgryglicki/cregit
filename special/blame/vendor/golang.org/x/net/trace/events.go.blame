0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
6cf8b80e5da3322f98ca221bde5f9ff5eb4fa392;Godeps/_workspace/src/golang.org/x/net/trace/events.go[Godeps/_workspace/src/golang.org/x/net/trace/events.go][vendor/golang.org/x/net/trace/events.go];	
0000000000000000000000000000000000000000;;	package trace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"html/template"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"text/tabwriter"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxEventsPerLog = 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bucket struct {
0000000000000000000000000000000000000000;;		MaxErrAge time.Duration
0000000000000000000000000000000000000000;;		String    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var buckets = []bucket{
0000000000000000000000000000000000000000;;		{0, "total"},
0000000000000000000000000000000000000000;;		{10 * time.Second, "errs<10s"},
0000000000000000000000000000000000000000;;		{1 * time.Minute, "errs<1m"},
0000000000000000000000000000000000000000;;		{10 * time.Minute, "errs<10m"},
0000000000000000000000000000000000000000;;		{1 * time.Hour, "errs<1h"},
0000000000000000000000000000000000000000;;		{10 * time.Hour, "errs<10h"},
0000000000000000000000000000000000000000;;		{24000 * time.Hour, "errors"},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RenderEvents renders the HTML page typically served at /debug/events.
0000000000000000000000000000000000000000;;	// It does not do any auth checking; see AuthRequest for the default auth check
0000000000000000000000000000000000000000;;	// used by the handler registered on http.DefaultServeMux.
0000000000000000000000000000000000000000;;	// req may be nil.
0000000000000000000000000000000000000000;;	func RenderEvents(w http.ResponseWriter, req *http.Request, sensitive bool) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		data := &struct {
0000000000000000000000000000000000000000;;			Families []string // family names
0000000000000000000000000000000000000000;;			Buckets  []bucket
0000000000000000000000000000000000000000;;			Counts   [][]int // eventLog count per family/bucket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set when a bucket has been selected.
0000000000000000000000000000000000000000;;			Family    string
0000000000000000000000000000000000000000;;			Bucket    int
0000000000000000000000000000000000000000;;			EventLogs eventLogs
0000000000000000000000000000000000000000;;			Expanded  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			Buckets: buckets,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data.Families = make([]string, 0, len(families))
0000000000000000000000000000000000000000;;		famMu.RLock()
0000000000000000000000000000000000000000;;		for name := range families {
0000000000000000000000000000000000000000;;			data.Families = append(data.Families, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		famMu.RUnlock()
0000000000000000000000000000000000000000;;		sort.Strings(data.Families)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Count the number of eventLogs in each family for each error age.
0000000000000000000000000000000000000000;;		data.Counts = make([][]int, len(data.Families))
0000000000000000000000000000000000000000;;		for i, name := range data.Families {
0000000000000000000000000000000000000000;;			// TODO(sameer): move this loop under the family lock.
0000000000000000000000000000000000000000;;			f := getEventFamily(name)
0000000000000000000000000000000000000000;;			data.Counts[i] = make([]int, len(data.Buckets))
0000000000000000000000000000000000000000;;			for j, b := range data.Buckets {
0000000000000000000000000000000000000000;;				data.Counts[i][j] = f.Count(now, b.MaxErrAge)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if req != nil {
0000000000000000000000000000000000000000;;			var ok bool
0000000000000000000000000000000000000000;;			data.Family, data.Bucket, ok = parseEventsArgs(req)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// No-op
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				data.EventLogs = getEventFamily(data.Family).Copy(now, buckets[data.Bucket].MaxErrAge)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if data.EventLogs != nil {
0000000000000000000000000000000000000000;;				defer data.EventLogs.Free()
0000000000000000000000000000000000000000;;				sort.Sort(data.EventLogs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exp, err := strconv.ParseBool(req.FormValue("exp")); err == nil {
0000000000000000000000000000000000000000;;				data.Expanded = exp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		famMu.RLock()
0000000000000000000000000000000000000000;;		defer famMu.RUnlock()
0000000000000000000000000000000000000000;;		if err := eventsTmpl().Execute(w, data); err != nil {
0000000000000000000000000000000000000000;;			log.Printf("net/trace: Failed executing template: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseEventsArgs(req *http.Request) (fam string, b int, ok bool) {
0000000000000000000000000000000000000000;;		fam, bStr := req.FormValue("fam"), req.FormValue("b")
0000000000000000000000000000000000000000;;		if fam == "" || bStr == "" {
0000000000000000000000000000000000000000;;			return "", 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := strconv.Atoi(bStr)
0000000000000000000000000000000000000000;;		if err != nil || b < 0 || b >= len(buckets) {
0000000000000000000000000000000000000000;;			return "", 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fam, b, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An EventLog provides a log of events associated with a specific object.
0000000000000000000000000000000000000000;;	type EventLog interface {
0000000000000000000000000000000000000000;;		// Printf formats its arguments with fmt.Sprintf and adds the
0000000000000000000000000000000000000000;;		// result to the event log.
0000000000000000000000000000000000000000;;		Printf(format string, a ...interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Errorf is like Printf, but it marks this event as an error.
0000000000000000000000000000000000000000;;		Errorf(format string, a ...interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finish declares that this event log is complete.
0000000000000000000000000000000000000000;;		// The event log should not be used after calling this method.
0000000000000000000000000000000000000000;;		Finish()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEventLog returns a new EventLog with the specified family name
0000000000000000000000000000000000000000;;	// and title.
0000000000000000000000000000000000000000;;	func NewEventLog(family, title string) EventLog {
0000000000000000000000000000000000000000;;		el := newEventLog()
0000000000000000000000000000000000000000;;		el.ref()
0000000000000000000000000000000000000000;;		el.Family, el.Title = family, title
0000000000000000000000000000000000000000;;		el.Start = time.Now()
0000000000000000000000000000000000000000;;		el.events = make([]logEntry, 0, maxEventsPerLog)
0000000000000000000000000000000000000000;;		el.stack = make([]uintptr, 32)
0000000000000000000000000000000000000000;;		n := runtime.Callers(2, el.stack)
0000000000000000000000000000000000000000;;		el.stack = el.stack[:n]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getEventFamily(family).add(el)
0000000000000000000000000000000000000000;;		return el
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) Finish() {
0000000000000000000000000000000000000000;;		getEventFamily(el.Family).remove(el)
0000000000000000000000000000000000000000;;		el.unref() // matches ref in New
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		famMu    sync.RWMutex
0000000000000000000000000000000000000000;;		families = make(map[string]*eventFamily) // family name => family
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getEventFamily(fam string) *eventFamily {
0000000000000000000000000000000000000000;;		famMu.Lock()
0000000000000000000000000000000000000000;;		defer famMu.Unlock()
0000000000000000000000000000000000000000;;		f := families[fam]
0000000000000000000000000000000000000000;;		if f == nil {
0000000000000000000000000000000000000000;;			f = &eventFamily{}
0000000000000000000000000000000000000000;;			families[fam] = f
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type eventFamily struct {
0000000000000000000000000000000000000000;;		mu        sync.RWMutex
0000000000000000000000000000000000000000;;		eventLogs eventLogs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *eventFamily) add(el *eventLog) {
0000000000000000000000000000000000000000;;		f.mu.Lock()
0000000000000000000000000000000000000000;;		f.eventLogs = append(f.eventLogs, el)
0000000000000000000000000000000000000000;;		f.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *eventFamily) remove(el *eventLog) {
0000000000000000000000000000000000000000;;		f.mu.Lock()
0000000000000000000000000000000000000000;;		defer f.mu.Unlock()
0000000000000000000000000000000000000000;;		for i, el0 := range f.eventLogs {
0000000000000000000000000000000000000000;;			if el == el0 {
0000000000000000000000000000000000000000;;				copy(f.eventLogs[i:], f.eventLogs[i+1:])
0000000000000000000000000000000000000000;;				f.eventLogs = f.eventLogs[:len(f.eventLogs)-1]
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *eventFamily) Count(now time.Time, maxErrAge time.Duration) (n int) {
0000000000000000000000000000000000000000;;		f.mu.RLock()
0000000000000000000000000000000000000000;;		defer f.mu.RUnlock()
0000000000000000000000000000000000000000;;		for _, el := range f.eventLogs {
0000000000000000000000000000000000000000;;			if el.hasRecentError(now, maxErrAge) {
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *eventFamily) Copy(now time.Time, maxErrAge time.Duration) (els eventLogs) {
0000000000000000000000000000000000000000;;		f.mu.RLock()
0000000000000000000000000000000000000000;;		defer f.mu.RUnlock()
0000000000000000000000000000000000000000;;		els = make(eventLogs, 0, len(f.eventLogs))
0000000000000000000000000000000000000000;;		for _, el := range f.eventLogs {
0000000000000000000000000000000000000000;;			if el.hasRecentError(now, maxErrAge) {
0000000000000000000000000000000000000000;;				el.ref()
0000000000000000000000000000000000000000;;				els = append(els, el)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type eventLogs []*eventLog
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Free calls unref on each element of the list.
0000000000000000000000000000000000000000;;	func (els eventLogs) Free() {
0000000000000000000000000000000000000000;;		for _, el := range els {
0000000000000000000000000000000000000000;;			el.unref()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// eventLogs may be sorted in reverse chronological order.
0000000000000000000000000000000000000000;;	func (els eventLogs) Len() int           { return len(els) }
0000000000000000000000000000000000000000;;	func (els eventLogs) Less(i, j int) bool { return els[i].Start.After(els[j].Start) }
0000000000000000000000000000000000000000;;	func (els eventLogs) Swap(i, j int)      { els[i], els[j] = els[j], els[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A logEntry is a timestamped log entry in an event log.
0000000000000000000000000000000000000000;;	type logEntry struct {
0000000000000000000000000000000000000000;;		When    time.Time
0000000000000000000000000000000000000000;;		Elapsed time.Duration // since previous event in log
0000000000000000000000000000000000000000;;		NewDay  bool          // whether this event is on a different day to the previous event
0000000000000000000000000000000000000000;;		What    string
0000000000000000000000000000000000000000;;		IsErr   bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhenString returns a string representation of the elapsed time of the event.
0000000000000000000000000000000000000000;;	// It will include the date if midnight was crossed.
0000000000000000000000000000000000000000;;	func (e logEntry) WhenString() string {
0000000000000000000000000000000000000000;;		if e.NewDay {
0000000000000000000000000000000000000000;;			return e.When.Format("2006/01/02 15:04:05.000000")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.When.Format("15:04:05.000000")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An eventLog represents an active event log.
0000000000000000000000000000000000000000;;	type eventLog struct {
0000000000000000000000000000000000000000;;		// Family is the top-level grouping of event logs to which this belongs.
0000000000000000000000000000000000000000;;		Family string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Title is the title of this event log.
0000000000000000000000000000000000000000;;		Title string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Timing information.
0000000000000000000000000000000000000000;;		Start time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call stack where this event log was created.
0000000000000000000000000000000000000000;;		stack []uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Append-only sequence of events.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO(sameer): change this to a ring buffer to avoid the array copy
0000000000000000000000000000000000000000;;		// when we hit maxEventsPerLog.
0000000000000000000000000000000000000000;;		mu            sync.RWMutex
0000000000000000000000000000000000000000;;		events        []logEntry
0000000000000000000000000000000000000000;;		LastErrorTime time.Time
0000000000000000000000000000000000000000;;		discarded     int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		refs int32 // how many buckets this is in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) reset() {
0000000000000000000000000000000000000000;;		// Clear all but the mutex. Mutexes may not be copied, even when unlocked.
0000000000000000000000000000000000000000;;		el.Family = ""
0000000000000000000000000000000000000000;;		el.Title = ""
0000000000000000000000000000000000000000;;		el.Start = time.Time{}
0000000000000000000000000000000000000000;;		el.stack = nil
0000000000000000000000000000000000000000;;		el.events = nil
0000000000000000000000000000000000000000;;		el.LastErrorTime = time.Time{}
0000000000000000000000000000000000000000;;		el.discarded = 0
0000000000000000000000000000000000000000;;		el.refs = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) hasRecentError(now time.Time, maxErrAge time.Duration) bool {
0000000000000000000000000000000000000000;;		if maxErrAge == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		el.mu.RLock()
0000000000000000000000000000000000000000;;		defer el.mu.RUnlock()
0000000000000000000000000000000000000000;;		return now.Sub(el.LastErrorTime) < maxErrAge
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delta returns the elapsed time since the last event or the log start,
0000000000000000000000000000000000000000;;	// and whether it spans midnight.
0000000000000000000000000000000000000000;;	// L >= el.mu
0000000000000000000000000000000000000000;;	func (el *eventLog) delta(t time.Time) (time.Duration, bool) {
0000000000000000000000000000000000000000;;		if len(el.events) == 0 {
0000000000000000000000000000000000000000;;			return t.Sub(el.Start), false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prev := el.events[len(el.events)-1].When
0000000000000000000000000000000000000000;;		return t.Sub(prev), prev.Day() != t.Day()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) Printf(format string, a ...interface{}) {
0000000000000000000000000000000000000000;;		el.printf(false, format, a...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) Errorf(format string, a ...interface{}) {
0000000000000000000000000000000000000000;;		el.printf(true, format, a...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) printf(isErr bool, format string, a ...interface{}) {
0000000000000000000000000000000000000000;;		e := logEntry{When: time.Now(), IsErr: isErr, What: fmt.Sprintf(format, a...)}
0000000000000000000000000000000000000000;;		el.mu.Lock()
0000000000000000000000000000000000000000;;		e.Elapsed, e.NewDay = el.delta(e.When)
0000000000000000000000000000000000000000;;		if len(el.events) < maxEventsPerLog {
0000000000000000000000000000000000000000;;			el.events = append(el.events, e)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Discard the oldest event.
0000000000000000000000000000000000000000;;			if el.discarded == 0 {
0000000000000000000000000000000000000000;;				// el.discarded starts at two to count for the event it
0000000000000000000000000000000000000000;;				// is replacing, plus the next one that we are about to
0000000000000000000000000000000000000000;;				// drop.
0000000000000000000000000000000000000000;;				el.discarded = 2
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				el.discarded++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO(sameer): if this causes allocations on a critical path,
0000000000000000000000000000000000000000;;			// change eventLog.What to be a fmt.Stringer, as in trace.go.
0000000000000000000000000000000000000000;;			el.events[0].What = fmt.Sprintf("(%d events discarded)", el.discarded)
0000000000000000000000000000000000000000;;			// The timestamp of the discarded meta-event should be
0000000000000000000000000000000000000000;;			// the time of the last event it is representing.
0000000000000000000000000000000000000000;;			el.events[0].When = el.events[1].When
0000000000000000000000000000000000000000;;			copy(el.events[1:], el.events[2:])
0000000000000000000000000000000000000000;;			el.events[maxEventsPerLog-1] = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.IsErr {
0000000000000000000000000000000000000000;;			el.LastErrorTime = e.When
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		el.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) ref() {
0000000000000000000000000000000000000000;;		atomic.AddInt32(&el.refs, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) unref() {
0000000000000000000000000000000000000000;;		if atomic.AddInt32(&el.refs, -1) == 0 {
0000000000000000000000000000000000000000;;			freeEventLog(el)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) When() string {
0000000000000000000000000000000000000000;;		return el.Start.Format("2006/01/02 15:04:05.000000")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) ElapsedTime() string {
0000000000000000000000000000000000000000;;		elapsed := time.Since(el.Start)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%.6f", elapsed.Seconds())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) Stack() string {
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		tw := tabwriter.NewWriter(buf, 1, 8, 1, '\t', 0)
0000000000000000000000000000000000000000;;		printStackRecord(tw, el.stack)
0000000000000000000000000000000000000000;;		tw.Flush()
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printStackRecord prints the function + source line information
0000000000000000000000000000000000000000;;	// for a single stack trace.
0000000000000000000000000000000000000000;;	// Adapted from runtime/pprof/pprof.go.
0000000000000000000000000000000000000000;;	func printStackRecord(w io.Writer, stk []uintptr) {
0000000000000000000000000000000000000000;;		for _, pc := range stk {
0000000000000000000000000000000000000000;;			f := runtime.FuncForPC(pc)
0000000000000000000000000000000000000000;;			if f == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			file, line := f.FileLine(pc)
0000000000000000000000000000000000000000;;			name := f.Name()
0000000000000000000000000000000000000000;;			// Hide runtime.goexit and any runtime functions at the beginning.
0000000000000000000000000000000000000000;;			if strings.HasPrefix(name, "runtime.") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "#   %s\t%s:%d\n", name, file, line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (el *eventLog) Events() []logEntry {
0000000000000000000000000000000000000000;;		el.mu.RLock()
0000000000000000000000000000000000000000;;		defer el.mu.RUnlock()
0000000000000000000000000000000000000000;;		return el.events
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// freeEventLogs is a freelist of *eventLog
0000000000000000000000000000000000000000;;	var freeEventLogs = make(chan *eventLog, 1000)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newEventLog returns a event log ready to use.
0000000000000000000000000000000000000000;;	func newEventLog() *eventLog {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case el := <-freeEventLogs:
0000000000000000000000000000000000000000;;			return el
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return new(eventLog)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// freeEventLog adds el to freeEventLogs if there's room.
0000000000000000000000000000000000000000;;	// This is non-blocking.
0000000000000000000000000000000000000000;;	func freeEventLog(el *eventLog) {
0000000000000000000000000000000000000000;;		el.reset()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case freeEventLogs <- el:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var eventsTmplCache *template.Template
0000000000000000000000000000000000000000;;	var eventsTmplOnce sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func eventsTmpl() *template.Template {
0000000000000000000000000000000000000000;;		eventsTmplOnce.Do(func() {
0000000000000000000000000000000000000000;;			eventsTmplCache = template.Must(template.New("events").Funcs(template.FuncMap{
0000000000000000000000000000000000000000;;				"elapsed":   elapsed,
0000000000000000000000000000000000000000;;				"trimSpace": strings.TrimSpace,
0000000000000000000000000000000000000000;;			}).Parse(eventsHTML))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return eventsTmplCache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const eventsHTML = `
0000000000000000000000000000000000000000;;	<html>
0000000000000000000000000000000000000000;;		<head>
0000000000000000000000000000000000000000;;			<title>events</title>
0000000000000000000000000000000000000000;;		</head>
0000000000000000000000000000000000000000;;		<style type="text/css">
0000000000000000000000000000000000000000;;			body {
0000000000000000000000000000000000000000;;				font-family: sans-serif;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#req-status td.family {
0000000000000000000000000000000000000000;;				padding-right: 2em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#req-status td.active {
0000000000000000000000000000000000000000;;				padding-right: 1em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#req-status td.empty {
0000000000000000000000000000000000000000;;				color: #aaa;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#reqs {
0000000000000000000000000000000000000000;;				margin-top: 1em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#reqs tr.first {
0000000000000000000000000000000000000000;;				{{if $.Expanded}}font-weight: bold;{{end}}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#reqs td {
0000000000000000000000000000000000000000;;				font-family: monospace;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#reqs td.when {
0000000000000000000000000000000000000000;;				text-align: right;
0000000000000000000000000000000000000000;;				white-space: nowrap;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#reqs td.elapsed {
0000000000000000000000000000000000000000;;				padding: 0 0.5em;
0000000000000000000000000000000000000000;;				text-align: right;
0000000000000000000000000000000000000000;;				white-space: pre;
0000000000000000000000000000000000000000;;				width: 10em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			address {
0000000000000000000000000000000000000000;;				font-size: smaller;
0000000000000000000000000000000000000000;;				margin-top: 5em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		</style>
0000000000000000000000000000000000000000;;		<body>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<h1>/debug/events</h1>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<table id="req-status">
0000000000000000000000000000000000000000;;		{{range $i, $fam := .Families}}
0000000000000000000000000000000000000000;;		<tr>
0000000000000000000000000000000000000000;;			<td class="family">{{$fam}}</td>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		        {{range $j, $bucket := $.Buckets}}
0000000000000000000000000000000000000000;;		        {{$n := index $.Counts $i $j}}
0000000000000000000000000000000000000000;;			<td class="{{if not $bucket.MaxErrAge}}active{{end}}{{if not $n}}empty{{end}}">
0000000000000000000000000000000000000000;;		                {{if $n}}<a href="?fam={{$fam}}&b={{$j}}{{if $.Expanded}}&exp=1{{end}}">{{end}}
0000000000000000000000000000000000000000;;			        [{{$n}} {{$bucket.String}}]
0000000000000000000000000000000000000000;;				{{if $n}}</a>{{end}}
0000000000000000000000000000000000000000;;			</td>
0000000000000000000000000000000000000000;;	                {{end}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		</tr>{{end}}
0000000000000000000000000000000000000000;;	</table>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{if $.EventLogs}}
0000000000000000000000000000000000000000;;	<hr />
0000000000000000000000000000000000000000;;	<h3>Family: {{$.Family}}</h3>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{if $.Expanded}}<a href="?fam={{$.Family}}&b={{$.Bucket}}">{{end}}
0000000000000000000000000000000000000000;;	[Summary]{{if $.Expanded}}</a>{{end}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{if not $.Expanded}}<a href="?fam={{$.Family}}&b={{$.Bucket}}&exp=1">{{end}}
0000000000000000000000000000000000000000;;	[Expanded]{{if not $.Expanded}}</a>{{end}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<table id="reqs">
0000000000000000000000000000000000000000;;		<tr><th>When</th><th>Elapsed</th></tr>
0000000000000000000000000000000000000000;;		{{range $el := $.EventLogs}}
0000000000000000000000000000000000000000;;		<tr class="first">
0000000000000000000000000000000000000000;;			<td class="when">{{$el.When}}</td>
0000000000000000000000000000000000000000;;			<td class="elapsed">{{$el.ElapsedTime}}</td>
0000000000000000000000000000000000000000;;			<td>{{$el.Title}}
0000000000000000000000000000000000000000;;		</tr>
0000000000000000000000000000000000000000;;		{{if $.Expanded}}
0000000000000000000000000000000000000000;;		<tr>
0000000000000000000000000000000000000000;;			<td class="when"></td>
0000000000000000000000000000000000000000;;			<td class="elapsed"></td>
0000000000000000000000000000000000000000;;			<td><pre>{{$el.Stack|trimSpace}}</pre></td>
0000000000000000000000000000000000000000;;		</tr>
0000000000000000000000000000000000000000;;		{{range $el.Events}}
0000000000000000000000000000000000000000;;		<tr>
0000000000000000000000000000000000000000;;			<td class="when">{{.WhenString}}</td>
0000000000000000000000000000000000000000;;			<td class="elapsed">{{elapsed .Elapsed}}</td>
0000000000000000000000000000000000000000;;			<td>.{{if .IsErr}}E{{else}}.{{end}}. {{.What}}</td>
0000000000000000000000000000000000000000;;		</tr>
0000000000000000000000000000000000000000;;		{{end}}
0000000000000000000000000000000000000000;;		{{end}}
0000000000000000000000000000000000000000;;		{{end}}
0000000000000000000000000000000000000000;;	</table>
0000000000000000000000000000000000000000;;	{{end}}
0000000000000000000000000000000000000000;;		</body>
0000000000000000000000000000000000000000;;	</html>
0000000000000000000000000000000000000000;;	`
