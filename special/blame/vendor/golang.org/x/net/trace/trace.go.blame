0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
6cf8b80e5da3322f98ca221bde5f9ff5eb4fa392;Godeps/_workspace/src/golang.org/x/net/trace/trace.go[Godeps/_workspace/src/golang.org/x/net/trace/trace.go][vendor/golang.org/x/net/trace/trace.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package trace implements tracing of requests and long-lived objects.
0000000000000000000000000000000000000000;;	It exports HTTP interfaces on /debug/requests and /debug/events.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A trace.Trace provides tracing for short-lived objects, usually requests.
0000000000000000000000000000000000000000;;	A request handler might be implemented like this:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func fooHandler(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			tr := trace.New("mypkg.Foo", req.URL.Path)
0000000000000000000000000000000000000000;;			defer tr.Finish()
0000000000000000000000000000000000000000;;			...
0000000000000000000000000000000000000000;;			tr.LazyPrintf("some event %q happened", str)
0000000000000000000000000000000000000000;;			...
0000000000000000000000000000000000000000;;			if err := somethingImportant(); err != nil {
0000000000000000000000000000000000000000;;				tr.LazyPrintf("somethingImportant failed: %v", err)
0000000000000000000000000000000000000000;;				tr.SetError()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The /debug/requests HTTP endpoint organizes the traces by family,
0000000000000000000000000000000000000000;;	errors, and duration.  It also provides histogram of request duration
0000000000000000000000000000000000000000;;	for each family.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A trace.EventLog provides tracing for long-lived objects, such as RPC
0000000000000000000000000000000000000000;;	connections.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A Fetcher fetches URL paths for a single domain.
0000000000000000000000000000000000000000;;		type Fetcher struct {
0000000000000000000000000000000000000000;;			domain string
0000000000000000000000000000000000000000;;			events trace.EventLog
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func NewFetcher(domain string) *Fetcher {
0000000000000000000000000000000000000000;;			return &Fetcher{
0000000000000000000000000000000000000000;;				domain,
0000000000000000000000000000000000000000;;				trace.NewEventLog("mypkg.Fetcher", domain),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (f *Fetcher) Fetch(path string) (string, error) {
0000000000000000000000000000000000000000;;			resp, err := http.Get("http://" + f.domain + "/" + path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				f.events.Errorf("Get(%q) = %v", path, err)
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.events.Printf("Get(%q) = %s", path, resp.Status)
0000000000000000000000000000000000000000;;			...
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (f *Fetcher) Close() error {
0000000000000000000000000000000000000000;;			f.events.Finish()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The /debug/events HTTP endpoint organizes the event logs by family and
0000000000000000000000000000000000000000;;	by time since the last error.  The expanded view displays recent log
0000000000000000000000000000000000000000;;	entries and the log's call stack.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package trace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"html/template"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/net/internal/timeseries"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DebugUseAfterFinish controls whether to debug uses of Trace values after finishing.
0000000000000000000000000000000000000000;;	// FOR DEBUGGING ONLY. This will slow down the program.
0000000000000000000000000000000000000000;;	var DebugUseAfterFinish = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthRequest determines whether a specific request is permitted to load the
0000000000000000000000000000000000000000;;	// /debug/requests or /debug/events pages.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It returns two bools; the first indicates whether the page may be viewed at all,
0000000000000000000000000000000000000000;;	// and the second indicates whether sensitive events will be shown.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// AuthRequest may be replaced by a program to customize its authorization requirements.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The default AuthRequest function returns (true, true) if and only if the request
0000000000000000000000000000000000000000;;	// comes from localhost/127.0.0.1/[::1].
0000000000000000000000000000000000000000;;	var AuthRequest = func(req *http.Request) (any, sensitive bool) {
0000000000000000000000000000000000000000;;		// RemoteAddr is commonly in the form "IP" or "IP:port".
0000000000000000000000000000000000000000;;		// If it is in the form "IP:port", split off the port.
0000000000000000000000000000000000000000;;		host, _, err := net.SplitHostPort(req.RemoteAddr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			host = req.RemoteAddr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch host {
0000000000000000000000000000000000000000;;		case "localhost", "127.0.0.1", "::1":
0000000000000000000000000000000000000000;;			return true, true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		http.HandleFunc("/debug/requests", func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			any, sensitive := AuthRequest(req)
0000000000000000000000000000000000000000;;			if !any {
0000000000000000000000000000000000000000;;				http.Error(w, "not allowed", http.StatusUnauthorized)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "text/html; charset=utf-8")
0000000000000000000000000000000000000000;;			Render(w, req, sensitive)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		http.HandleFunc("/debug/events", func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;			any, sensitive := AuthRequest(req)
0000000000000000000000000000000000000000;;			if !any {
0000000000000000000000000000000000000000;;				http.Error(w, "not allowed", http.StatusUnauthorized)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "text/html; charset=utf-8")
0000000000000000000000000000000000000000;;			RenderEvents(w, req, sensitive)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Render renders the HTML page typically served at /debug/requests.
0000000000000000000000000000000000000000;;	// It does not do any auth checking; see AuthRequest for the default auth check
0000000000000000000000000000000000000000;;	// used by the handler registered on http.DefaultServeMux.
0000000000000000000000000000000000000000;;	// req may be nil.
0000000000000000000000000000000000000000;;	func Render(w io.Writer, req *http.Request, sensitive bool) {
0000000000000000000000000000000000000000;;		data := &struct {
0000000000000000000000000000000000000000;;			Families         []string
0000000000000000000000000000000000000000;;			ActiveTraceCount map[string]int
0000000000000000000000000000000000000000;;			CompletedTraces  map[string]*family
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set when a bucket has been selected.
0000000000000000000000000000000000000000;;			Traces        traceList
0000000000000000000000000000000000000000;;			Family        string
0000000000000000000000000000000000000000;;			Bucket        int
0000000000000000000000000000000000000000;;			Expanded      bool
0000000000000000000000000000000000000000;;			Traced        bool
0000000000000000000000000000000000000000;;			Active        bool
0000000000000000000000000000000000000000;;			ShowSensitive bool // whether to show sensitive events
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Histogram       template.HTML
0000000000000000000000000000000000000000;;			HistogramWindow string // e.g. "last minute", "last hour", "all time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If non-zero, the set of traces is a partial set,
0000000000000000000000000000000000000000;;			// and this is the total number.
0000000000000000000000000000000000000000;;			Total int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			CompletedTraces: completedTraces,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data.ShowSensitive = sensitive
0000000000000000000000000000000000000000;;		if req != nil {
0000000000000000000000000000000000000000;;			// Allow show_sensitive=0 to force hiding of sensitive data for testing.
0000000000000000000000000000000000000000;;			// This only goes one way; you can't use show_sensitive=1 to see things.
0000000000000000000000000000000000000000;;			if req.FormValue("show_sensitive") == "0" {
0000000000000000000000000000000000000000;;				data.ShowSensitive = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if exp, err := strconv.ParseBool(req.FormValue("exp")); err == nil {
0000000000000000000000000000000000000000;;				data.Expanded = exp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exp, err := strconv.ParseBool(req.FormValue("rtraced")); err == nil {
0000000000000000000000000000000000000000;;				data.Traced = exp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		completedMu.RLock()
0000000000000000000000000000000000000000;;		data.Families = make([]string, 0, len(completedTraces))
0000000000000000000000000000000000000000;;		for fam := range completedTraces {
0000000000000000000000000000000000000000;;			data.Families = append(data.Families, fam)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		completedMu.RUnlock()
0000000000000000000000000000000000000000;;		sort.Strings(data.Families)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We are careful here to minimize the time spent locking activeMu,
0000000000000000000000000000000000000000;;		// since that lock is required every time an RPC starts and finishes.
0000000000000000000000000000000000000000;;		data.ActiveTraceCount = make(map[string]int, len(data.Families))
0000000000000000000000000000000000000000;;		activeMu.RLock()
0000000000000000000000000000000000000000;;		for fam, s := range activeTraces {
0000000000000000000000000000000000000000;;			data.ActiveTraceCount[fam] = s.Len()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		activeMu.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		data.Family, data.Bucket, ok = parseArgs(req)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case !ok:
0000000000000000000000000000000000000000;;			// No-op
0000000000000000000000000000000000000000;;		case data.Bucket == -1:
0000000000000000000000000000000000000000;;			data.Active = true
0000000000000000000000000000000000000000;;			n := data.ActiveTraceCount[data.Family]
0000000000000000000000000000000000000000;;			data.Traces = getActiveTraces(data.Family)
0000000000000000000000000000000000000000;;			if len(data.Traces) < n {
0000000000000000000000000000000000000000;;				data.Total = n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case data.Bucket < bucketsPerFamily:
0000000000000000000000000000000000000000;;			if b := lookupBucket(data.Family, data.Bucket); b != nil {
0000000000000000000000000000000000000000;;				data.Traces = b.Copy(data.Traced)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if f := getFamily(data.Family, false); f != nil {
0000000000000000000000000000000000000000;;				var obs timeseries.Observable
0000000000000000000000000000000000000000;;				f.LatencyMu.RLock()
0000000000000000000000000000000000000000;;				switch o := data.Bucket - bucketsPerFamily; o {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					obs = f.Latency.Minute()
0000000000000000000000000000000000000000;;					data.HistogramWindow = "last minute"
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					obs = f.Latency.Hour()
0000000000000000000000000000000000000000;;					data.HistogramWindow = "last hour"
0000000000000000000000000000000000000000;;				case 2:
0000000000000000000000000000000000000000;;					obs = f.Latency.Total()
0000000000000000000000000000000000000000;;					data.HistogramWindow = "all time"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				f.LatencyMu.RUnlock()
0000000000000000000000000000000000000000;;				if obs != nil {
0000000000000000000000000000000000000000;;					data.Histogram = obs.(*histogram).html()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if data.Traces != nil {
0000000000000000000000000000000000000000;;			defer data.Traces.Free()
0000000000000000000000000000000000000000;;			sort.Sort(data.Traces)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		completedMu.RLock()
0000000000000000000000000000000000000000;;		defer completedMu.RUnlock()
0000000000000000000000000000000000000000;;		if err := pageTmpl().ExecuteTemplate(w, "Page", data); err != nil {
0000000000000000000000000000000000000000;;			log.Printf("net/trace: Failed executing template: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseArgs(req *http.Request) (fam string, b int, ok bool) {
0000000000000000000000000000000000000000;;		if req == nil {
0000000000000000000000000000000000000000;;			return "", 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fam, bStr := req.FormValue("fam"), req.FormValue("b")
0000000000000000000000000000000000000000;;		if fam == "" || bStr == "" {
0000000000000000000000000000000000000000;;			return "", 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := strconv.Atoi(bStr)
0000000000000000000000000000000000000000;;		if err != nil || b < -1 {
0000000000000000000000000000000000000000;;			return "", 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fam, b, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lookupBucket(fam string, b int) *traceBucket {
0000000000000000000000000000000000000000;;		f := getFamily(fam, false)
0000000000000000000000000000000000000000;;		if f == nil || b < 0 || b >= len(f.Buckets) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.Buckets[b]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type contextKeyT string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var contextKey = contextKeyT("golang.org/x/net/trace.Trace")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewContext returns a copy of the parent context
0000000000000000000000000000000000000000;;	// and associates it with a Trace.
0000000000000000000000000000000000000000;;	func NewContext(ctx context.Context, tr Trace) context.Context {
0000000000000000000000000000000000000000;;		return context.WithValue(ctx, contextKey, tr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromContext returns the Trace bound to the context, if any.
0000000000000000000000000000000000000000;;	func FromContext(ctx context.Context) (tr Trace, ok bool) {
0000000000000000000000000000000000000000;;		tr, ok = ctx.Value(contextKey).(Trace)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Trace represents an active request.
0000000000000000000000000000000000000000;;	type Trace interface {
0000000000000000000000000000000000000000;;		// LazyLog adds x to the event log. It will be evaluated each time the
0000000000000000000000000000000000000000;;		// /debug/requests page is rendered. Any memory referenced by x will be
0000000000000000000000000000000000000000;;		// pinned until the trace is finished and later discarded.
0000000000000000000000000000000000000000;;		LazyLog(x fmt.Stringer, sensitive bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LazyPrintf evaluates its arguments with fmt.Sprintf each time the
0000000000000000000000000000000000000000;;		// /debug/requests page is rendered. Any memory referenced by a will be
0000000000000000000000000000000000000000;;		// pinned until the trace is finished and later discarded.
0000000000000000000000000000000000000000;;		LazyPrintf(format string, a ...interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetError declares that this trace resulted in an error.
0000000000000000000000000000000000000000;;		SetError()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetRecycler sets a recycler for the trace.
0000000000000000000000000000000000000000;;		// f will be called for each event passed to LazyLog at a time when
0000000000000000000000000000000000000000;;		// it is no longer required, whether while the trace is still active
0000000000000000000000000000000000000000;;		// and the event is discarded, or when a completed trace is discarded.
0000000000000000000000000000000000000000;;		SetRecycler(f func(interface{}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetTraceInfo sets the trace info for the trace.
0000000000000000000000000000000000000000;;		// This is currently unused.
0000000000000000000000000000000000000000;;		SetTraceInfo(traceID, spanID uint64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetMaxEvents sets the maximum number of events that will be stored
0000000000000000000000000000000000000000;;		// in the trace. This has no effect if any events have already been
0000000000000000000000000000000000000000;;		// added to the trace.
0000000000000000000000000000000000000000;;		SetMaxEvents(m int)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finish declares that this trace is complete.
0000000000000000000000000000000000000000;;		// The trace should not be used after calling this method.
0000000000000000000000000000000000000000;;		Finish()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lazySprintf struct {
0000000000000000000000000000000000000000;;		format string
0000000000000000000000000000000000000000;;		a      []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lazySprintf) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(l.format, l.a...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Trace with the specified family and title.
0000000000000000000000000000000000000000;;	func New(family, title string) Trace {
0000000000000000000000000000000000000000;;		tr := newTrace()
0000000000000000000000000000000000000000;;		tr.ref()
0000000000000000000000000000000000000000;;		tr.Family, tr.Title = family, title
0000000000000000000000000000000000000000;;		tr.Start = time.Now()
0000000000000000000000000000000000000000;;		tr.maxEvents = maxEventsPerTrace
0000000000000000000000000000000000000000;;		tr.events = tr.eventsBuf[:0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		activeMu.RLock()
0000000000000000000000000000000000000000;;		s := activeTraces[tr.Family]
0000000000000000000000000000000000000000;;		activeMu.RUnlock()
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			activeMu.Lock()
0000000000000000000000000000000000000000;;			s = activeTraces[tr.Family] // check again
0000000000000000000000000000000000000000;;			if s == nil {
0000000000000000000000000000000000000000;;				s = new(traceSet)
0000000000000000000000000000000000000000;;				activeTraces[tr.Family] = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			activeMu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.Add(tr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Trigger allocation of the completed trace structure for this family.
0000000000000000000000000000000000000000;;		// This will cause the family to be present in the request page during
0000000000000000000000000000000000000000;;		// the first trace of this family. We don't care about the return value,
0000000000000000000000000000000000000000;;		// nor is there any need for this to run inline, so we execute it in its
0000000000000000000000000000000000000000;;		// own goroutine, but only if the family isn't allocated yet.
0000000000000000000000000000000000000000;;		completedMu.RLock()
0000000000000000000000000000000000000000;;		if _, ok := completedTraces[tr.Family]; !ok {
0000000000000000000000000000000000000000;;			go allocFamily(tr.Family)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		completedMu.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) Finish() {
0000000000000000000000000000000000000000;;		tr.Elapsed = time.Now().Sub(tr.Start)
0000000000000000000000000000000000000000;;		if DebugUseAfterFinish {
0000000000000000000000000000000000000000;;			buf := make([]byte, 4<<10) // 4 KB should be enough
0000000000000000000000000000000000000000;;			n := runtime.Stack(buf, false)
0000000000000000000000000000000000000000;;			tr.finishStack = buf[:n]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		activeMu.RLock()
0000000000000000000000000000000000000000;;		m := activeTraces[tr.Family]
0000000000000000000000000000000000000000;;		activeMu.RUnlock()
0000000000000000000000000000000000000000;;		m.Remove(tr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := getFamily(tr.Family, true)
0000000000000000000000000000000000000000;;		for _, b := range f.Buckets {
0000000000000000000000000000000000000000;;			if b.Cond.match(tr) {
0000000000000000000000000000000000000000;;				b.Add(tr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add a sample of elapsed time as microseconds to the family's timeseries
0000000000000000000000000000000000000000;;		h := new(histogram)
0000000000000000000000000000000000000000;;		h.addMeasurement(tr.Elapsed.Nanoseconds() / 1e3)
0000000000000000000000000000000000000000;;		f.LatencyMu.Lock()
0000000000000000000000000000000000000000;;		f.Latency.Add(h)
0000000000000000000000000000000000000000;;		f.LatencyMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tr.unref() // matches ref in New
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bucketsPerFamily    = 9
0000000000000000000000000000000000000000;;		tracesPerBucket     = 10
0000000000000000000000000000000000000000;;		maxActiveTraces     = 20 // Maximum number of active traces to show.
0000000000000000000000000000000000000000;;		maxEventsPerTrace   = 10
0000000000000000000000000000000000000000;;		numHistogramBuckets = 38
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// The active traces.
0000000000000000000000000000000000000000;;		activeMu     sync.RWMutex
0000000000000000000000000000000000000000;;		activeTraces = make(map[string]*traceSet) // family -> traces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Families of completed traces.
0000000000000000000000000000000000000000;;		completedMu     sync.RWMutex
0000000000000000000000000000000000000000;;		completedTraces = make(map[string]*family) // family -> traces
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type traceSet struct {
0000000000000000000000000000000000000000;;		mu sync.RWMutex
0000000000000000000000000000000000000000;;		m  map[*trace]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We could avoid the entire map scan in FirstN by having a slice of all the traces
0000000000000000000000000000000000000000;;		// ordered by start time, and an index into that from the trace struct, with a periodic
0000000000000000000000000000000000000000;;		// repack of the slice after enough traces finish; we could also use a skip list or similar.
0000000000000000000000000000000000000000;;		// However, that would shift some of the expense from /debug/requests time to RPC time,
0000000000000000000000000000000000000000;;		// which is probably the wrong trade-off.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *traceSet) Len() int {
0000000000000000000000000000000000000000;;		ts.mu.RLock()
0000000000000000000000000000000000000000;;		defer ts.mu.RUnlock()
0000000000000000000000000000000000000000;;		return len(ts.m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *traceSet) Add(tr *trace) {
0000000000000000000000000000000000000000;;		ts.mu.Lock()
0000000000000000000000000000000000000000;;		if ts.m == nil {
0000000000000000000000000000000000000000;;			ts.m = make(map[*trace]bool)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ts.m[tr] = true
0000000000000000000000000000000000000000;;		ts.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *traceSet) Remove(tr *trace) {
0000000000000000000000000000000000000000;;		ts.mu.Lock()
0000000000000000000000000000000000000000;;		delete(ts.m, tr)
0000000000000000000000000000000000000000;;		ts.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FirstN returns the first n traces ordered by time.
0000000000000000000000000000000000000000;;	func (ts *traceSet) FirstN(n int) traceList {
0000000000000000000000000000000000000000;;		ts.mu.RLock()
0000000000000000000000000000000000000000;;		defer ts.mu.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n > len(ts.m) {
0000000000000000000000000000000000000000;;			n = len(ts.m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		trl := make(traceList, 0, n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fast path for when no selectivity is needed.
0000000000000000000000000000000000000000;;		if n == len(ts.m) {
0000000000000000000000000000000000000000;;			for tr := range ts.m {
0000000000000000000000000000000000000000;;				tr.ref()
0000000000000000000000000000000000000000;;				trl = append(trl, tr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Sort(trl)
0000000000000000000000000000000000000000;;			return trl
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pick the oldest n traces.
0000000000000000000000000000000000000000;;		// This is inefficient. See the comment in the traceSet struct.
0000000000000000000000000000000000000000;;		for tr := range ts.m {
0000000000000000000000000000000000000000;;			// Put the first n traces into trl in the order they occur.
0000000000000000000000000000000000000000;;			// When we have n, sort trl, and thereafter maintain its order.
0000000000000000000000000000000000000000;;			if len(trl) < n {
0000000000000000000000000000000000000000;;				tr.ref()
0000000000000000000000000000000000000000;;				trl = append(trl, tr)
0000000000000000000000000000000000000000;;				if len(trl) == n {
0000000000000000000000000000000000000000;;					// This is guaranteed to happen exactly once during this loop.
0000000000000000000000000000000000000000;;					sort.Sort(trl)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tr.Start.After(trl[n-1].Start) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Find where to insert this one.
0000000000000000000000000000000000000000;;			tr.ref()
0000000000000000000000000000000000000000;;			i := sort.Search(n, func(i int) bool { return trl[i].Start.After(tr.Start) })
0000000000000000000000000000000000000000;;			trl[n-1].unref()
0000000000000000000000000000000000000000;;			copy(trl[i+1:], trl[i:])
0000000000000000000000000000000000000000;;			trl[i] = tr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return trl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getActiveTraces(fam string) traceList {
0000000000000000000000000000000000000000;;		activeMu.RLock()
0000000000000000000000000000000000000000;;		s := activeTraces[fam]
0000000000000000000000000000000000000000;;		activeMu.RUnlock()
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.FirstN(maxActiveTraces)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getFamily(fam string, allocNew bool) *family {
0000000000000000000000000000000000000000;;		completedMu.RLock()
0000000000000000000000000000000000000000;;		f := completedTraces[fam]
0000000000000000000000000000000000000000;;		completedMu.RUnlock()
0000000000000000000000000000000000000000;;		if f == nil && allocNew {
0000000000000000000000000000000000000000;;			f = allocFamily(fam)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func allocFamily(fam string) *family {
0000000000000000000000000000000000000000;;		completedMu.Lock()
0000000000000000000000000000000000000000;;		defer completedMu.Unlock()
0000000000000000000000000000000000000000;;		f := completedTraces[fam]
0000000000000000000000000000000000000000;;		if f == nil {
0000000000000000000000000000000000000000;;			f = newFamily()
0000000000000000000000000000000000000000;;			completedTraces[fam] = f
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// family represents a set of trace buckets and associated latency information.
0000000000000000000000000000000000000000;;	type family struct {
0000000000000000000000000000000000000000;;		// traces may occur in multiple buckets.
0000000000000000000000000000000000000000;;		Buckets [bucketsPerFamily]*traceBucket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// latency time series
0000000000000000000000000000000000000000;;		LatencyMu sync.RWMutex
0000000000000000000000000000000000000000;;		Latency   *timeseries.MinuteHourSeries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFamily() *family {
0000000000000000000000000000000000000000;;		return &family{
0000000000000000000000000000000000000000;;			Buckets: [bucketsPerFamily]*traceBucket{
0000000000000000000000000000000000000000;;				{Cond: minCond(0)},
0000000000000000000000000000000000000000;;				{Cond: minCond(50 * time.Millisecond)},
0000000000000000000000000000000000000000;;				{Cond: minCond(100 * time.Millisecond)},
0000000000000000000000000000000000000000;;				{Cond: minCond(200 * time.Millisecond)},
0000000000000000000000000000000000000000;;				{Cond: minCond(500 * time.Millisecond)},
0000000000000000000000000000000000000000;;				{Cond: minCond(1 * time.Second)},
0000000000000000000000000000000000000000;;				{Cond: minCond(10 * time.Second)},
0000000000000000000000000000000000000000;;				{Cond: minCond(100 * time.Second)},
0000000000000000000000000000000000000000;;				{Cond: errorCond{}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Latency: timeseries.NewMinuteHourSeries(func() timeseries.Observable { return new(histogram) }),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// traceBucket represents a size-capped bucket of historic traces,
0000000000000000000000000000000000000000;;	// along with a condition for a trace to belong to the bucket.
0000000000000000000000000000000000000000;;	type traceBucket struct {
0000000000000000000000000000000000000000;;		Cond cond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ring buffer implementation of a fixed-size FIFO queue.
0000000000000000000000000000000000000000;;		mu     sync.RWMutex
0000000000000000000000000000000000000000;;		buf    [tracesPerBucket]*trace
0000000000000000000000000000000000000000;;		start  int // < tracesPerBucket
0000000000000000000000000000000000000000;;		length int // <= tracesPerBucket
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *traceBucket) Add(tr *trace) {
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := b.start + b.length
0000000000000000000000000000000000000000;;		if i >= tracesPerBucket {
0000000000000000000000000000000000000000;;			i -= tracesPerBucket
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.length == tracesPerBucket {
0000000000000000000000000000000000000000;;			// "Remove" an element from the bucket.
0000000000000000000000000000000000000000;;			b.buf[i].unref()
0000000000000000000000000000000000000000;;			b.start++
0000000000000000000000000000000000000000;;			if b.start == tracesPerBucket {
0000000000000000000000000000000000000000;;				b.start = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.buf[i] = tr
0000000000000000000000000000000000000000;;		if b.length < tracesPerBucket {
0000000000000000000000000000000000000000;;			b.length++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tr.ref()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy returns a copy of the traces in the bucket.
0000000000000000000000000000000000000000;;	// If tracedOnly is true, only the traces with trace information will be returned.
0000000000000000000000000000000000000000;;	// The logs will be ref'd before returning; the caller should call
0000000000000000000000000000000000000000;;	// the Free method when it is done with them.
0000000000000000000000000000000000000000;;	// TODO(dsymonds): keep track of traced requests in separate buckets.
0000000000000000000000000000000000000000;;	func (b *traceBucket) Copy(tracedOnly bool) traceList {
0000000000000000000000000000000000000000;;		b.mu.RLock()
0000000000000000000000000000000000000000;;		defer b.mu.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trl := make(traceList, 0, b.length)
0000000000000000000000000000000000000000;;		for i, x := 0, b.start; i < b.length; i++ {
0000000000000000000000000000000000000000;;			tr := b.buf[x]
0000000000000000000000000000000000000000;;			if !tracedOnly || tr.spanID != 0 {
0000000000000000000000000000000000000000;;				tr.ref()
0000000000000000000000000000000000000000;;				trl = append(trl, tr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x++
0000000000000000000000000000000000000000;;			if x == b.length {
0000000000000000000000000000000000000000;;				x = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return trl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *traceBucket) Empty() bool {
0000000000000000000000000000000000000000;;		b.mu.RLock()
0000000000000000000000000000000000000000;;		defer b.mu.RUnlock()
0000000000000000000000000000000000000000;;		return b.length == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cond represents a condition on a trace.
0000000000000000000000000000000000000000;;	type cond interface {
0000000000000000000000000000000000000000;;		match(t *trace) bool
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type minCond time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m minCond) match(t *trace) bool { return t.Elapsed >= time.Duration(m) }
0000000000000000000000000000000000000000;;	func (m minCond) String() string      { return fmt.Sprintf("â‰¥%gs", time.Duration(m).Seconds()) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errorCond struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e errorCond) match(t *trace) bool { return t.IsError }
0000000000000000000000000000000000000000;;	func (e errorCond) String() string      { return "errors" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type traceList []*trace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Free calls unref on each element of the list.
0000000000000000000000000000000000000000;;	func (trl traceList) Free() {
0000000000000000000000000000000000000000;;		for _, t := range trl {
0000000000000000000000000000000000000000;;			t.unref()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// traceList may be sorted in reverse chronological order.
0000000000000000000000000000000000000000;;	func (trl traceList) Len() int           { return len(trl) }
0000000000000000000000000000000000000000;;	func (trl traceList) Less(i, j int) bool { return trl[i].Start.After(trl[j].Start) }
0000000000000000000000000000000000000000;;	func (trl traceList) Swap(i, j int)      { trl[i], trl[j] = trl[j], trl[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An event is a timestamped log entry in a trace.
0000000000000000000000000000000000000000;;	type event struct {
0000000000000000000000000000000000000000;;		When       time.Time
0000000000000000000000000000000000000000;;		Elapsed    time.Duration // since previous event in trace
0000000000000000000000000000000000000000;;		NewDay     bool          // whether this event is on a different day to the previous event
0000000000000000000000000000000000000000;;		Recyclable bool          // whether this event was passed via LazyLog
0000000000000000000000000000000000000000;;		Sensitive  bool          // whether this event contains sensitive information
0000000000000000000000000000000000000000;;		What       interface{}   // string or fmt.Stringer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhenString returns a string representation of the elapsed time of the event.
0000000000000000000000000000000000000000;;	// It will include the date if midnight was crossed.
0000000000000000000000000000000000000000;;	func (e event) WhenString() string {
0000000000000000000000000000000000000000;;		if e.NewDay {
0000000000000000000000000000000000000000;;			return e.When.Format("2006/01/02 15:04:05.000000")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.When.Format("15:04:05.000000")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// discarded represents a number of discarded events.
0000000000000000000000000000000000000000;;	// It is stored as *discarded to make it easier to update in-place.
0000000000000000000000000000000000000000;;	type discarded int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *discarded) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("(%d events discarded)", int(*d))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// trace represents an active or complete request,
0000000000000000000000000000000000000000;;	// either sent or received by this program.
0000000000000000000000000000000000000000;;	type trace struct {
0000000000000000000000000000000000000000;;		// Family is the top-level grouping of traces to which this belongs.
0000000000000000000000000000000000000000;;		Family string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Title is the title of this trace.
0000000000000000000000000000000000000000;;		Title string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Timing information.
0000000000000000000000000000000000000000;;		Start   time.Time
0000000000000000000000000000000000000000;;		Elapsed time.Duration // zero while active
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Trace information if non-zero.
0000000000000000000000000000000000000000;;		traceID uint64
0000000000000000000000000000000000000000;;		spanID  uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether this trace resulted in an error.
0000000000000000000000000000000000000000;;		IsError bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Append-only sequence of events (modulo discards).
0000000000000000000000000000000000000000;;		mu        sync.RWMutex
0000000000000000000000000000000000000000;;		events    []event
0000000000000000000000000000000000000000;;		maxEvents int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		refs     int32 // how many buckets this is in
0000000000000000000000000000000000000000;;		recycler func(interface{})
0000000000000000000000000000000000000000;;		disc     discarded // scratch space to avoid allocation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		finishStack []byte // where finish was called, if DebugUseAfterFinish is set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventsBuf [4]event // preallocated buffer in case we only log a few events
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) reset() {
0000000000000000000000000000000000000000;;		// Clear all but the mutex. Mutexes may not be copied, even when unlocked.
0000000000000000000000000000000000000000;;		tr.Family = ""
0000000000000000000000000000000000000000;;		tr.Title = ""
0000000000000000000000000000000000000000;;		tr.Start = time.Time{}
0000000000000000000000000000000000000000;;		tr.Elapsed = 0
0000000000000000000000000000000000000000;;		tr.traceID = 0
0000000000000000000000000000000000000000;;		tr.spanID = 0
0000000000000000000000000000000000000000;;		tr.IsError = false
0000000000000000000000000000000000000000;;		tr.maxEvents = 0
0000000000000000000000000000000000000000;;		tr.events = nil
0000000000000000000000000000000000000000;;		tr.refs = 0
0000000000000000000000000000000000000000;;		tr.recycler = nil
0000000000000000000000000000000000000000;;		tr.disc = 0
0000000000000000000000000000000000000000;;		tr.finishStack = nil
0000000000000000000000000000000000000000;;		for i := range tr.eventsBuf {
0000000000000000000000000000000000000000;;			tr.eventsBuf[i] = event{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delta returns the elapsed time since the last event or the trace start,
0000000000000000000000000000000000000000;;	// and whether it spans midnight.
0000000000000000000000000000000000000000;;	// L >= tr.mu
0000000000000000000000000000000000000000;;	func (tr *trace) delta(t time.Time) (time.Duration, bool) {
0000000000000000000000000000000000000000;;		if len(tr.events) == 0 {
0000000000000000000000000000000000000000;;			return t.Sub(tr.Start), false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prev := tr.events[len(tr.events)-1].When
0000000000000000000000000000000000000000;;		return t.Sub(prev), prev.Day() != t.Day()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) addEvent(x interface{}, recyclable, sensitive bool) {
0000000000000000000000000000000000000000;;		if DebugUseAfterFinish && tr.finishStack != nil {
0000000000000000000000000000000000000000;;			buf := make([]byte, 4<<10) // 4 KB should be enough
0000000000000000000000000000000000000000;;			n := runtime.Stack(buf, false)
0000000000000000000000000000000000000000;;			log.Printf("net/trace: trace used after finish:\nFinished at:\n%s\nUsed at:\n%s", tr.finishStack, buf[:n])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			NOTE TO DEBUGGERS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			If you are here because your program panicked in this code,
0000000000000000000000000000000000000000;;			it is almost definitely the fault of code using this package,
0000000000000000000000000000000000000000;;			and very unlikely to be the fault of this code.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			The most likely scenario is that some code elsewhere is using
0000000000000000000000000000000000000000;;			a trace.Trace after its Finish method is called.
0000000000000000000000000000000000000000;;			You can temporarily set the DebugUseAfterFinish var
0000000000000000000000000000000000000000;;			to help discover where that is; do not leave that var set,
0000000000000000000000000000000000000000;;			since it makes this package much less efficient.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := event{When: time.Now(), What: x, Recyclable: recyclable, Sensitive: sensitive}
0000000000000000000000000000000000000000;;		tr.mu.Lock()
0000000000000000000000000000000000000000;;		e.Elapsed, e.NewDay = tr.delta(e.When)
0000000000000000000000000000000000000000;;		if len(tr.events) < tr.maxEvents {
0000000000000000000000000000000000000000;;			tr.events = append(tr.events, e)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Discard the middle events.
0000000000000000000000000000000000000000;;			di := int((tr.maxEvents - 1) / 2)
0000000000000000000000000000000000000000;;			if d, ok := tr.events[di].What.(*discarded); ok {
0000000000000000000000000000000000000000;;				(*d)++
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// disc starts at two to count for the event it is replacing,
0000000000000000000000000000000000000000;;				// plus the next one that we are about to drop.
0000000000000000000000000000000000000000;;				tr.disc = 2
0000000000000000000000000000000000000000;;				if tr.recycler != nil && tr.events[di].Recyclable {
0000000000000000000000000000000000000000;;					go tr.recycler(tr.events[di].What)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tr.events[di].What = &tr.disc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// The timestamp of the discarded meta-event should be
0000000000000000000000000000000000000000;;			// the time of the last event it is representing.
0000000000000000000000000000000000000000;;			tr.events[di].When = tr.events[di+1].When
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tr.recycler != nil && tr.events[di+1].Recyclable {
0000000000000000000000000000000000000000;;				go tr.recycler(tr.events[di+1].What)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy(tr.events[di+1:], tr.events[di+2:])
0000000000000000000000000000000000000000;;			tr.events[tr.maxEvents-1] = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tr.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) LazyLog(x fmt.Stringer, sensitive bool) {
0000000000000000000000000000000000000000;;		tr.addEvent(x, true, sensitive)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) LazyPrintf(format string, a ...interface{}) {
0000000000000000000000000000000000000000;;		tr.addEvent(&lazySprintf{format, a}, false, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) SetError() { tr.IsError = true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) SetRecycler(f func(interface{})) {
0000000000000000000000000000000000000000;;		tr.recycler = f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) SetTraceInfo(traceID, spanID uint64) {
0000000000000000000000000000000000000000;;		tr.traceID, tr.spanID = traceID, spanID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) SetMaxEvents(m int) {
0000000000000000000000000000000000000000;;		// Always keep at least three events: first, discarded count, last.
0000000000000000000000000000000000000000;;		if len(tr.events) == 0 && m > 3 {
0000000000000000000000000000000000000000;;			tr.maxEvents = m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) ref() {
0000000000000000000000000000000000000000;;		atomic.AddInt32(&tr.refs, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) unref() {
0000000000000000000000000000000000000000;;		if atomic.AddInt32(&tr.refs, -1) == 0 {
0000000000000000000000000000000000000000;;			if tr.recycler != nil {
0000000000000000000000000000000000000000;;				// freeTrace clears tr, so we hold tr.recycler and tr.events here.
0000000000000000000000000000000000000000;;				go func(f func(interface{}), es []event) {
0000000000000000000000000000000000000000;;					for _, e := range es {
0000000000000000000000000000000000000000;;						if e.Recyclable {
0000000000000000000000000000000000000000;;							f(e.What)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}(tr.recycler, tr.events)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			freeTrace(tr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) When() string {
0000000000000000000000000000000000000000;;		return tr.Start.Format("2006/01/02 15:04:05.000000")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) ElapsedTime() string {
0000000000000000000000000000000000000000;;		t := tr.Elapsed
0000000000000000000000000000000000000000;;		if t == 0 {
0000000000000000000000000000000000000000;;			// Active trace.
0000000000000000000000000000000000000000;;			t = time.Since(tr.Start)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%.6f", t.Seconds())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tr *trace) Events() []event {
0000000000000000000000000000000000000000;;		tr.mu.RLock()
0000000000000000000000000000000000000000;;		defer tr.mu.RUnlock()
0000000000000000000000000000000000000000;;		return tr.events
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var traceFreeList = make(chan *trace, 1000) // TODO(dsymonds): Use sync.Pool?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newTrace returns a trace ready to use.
0000000000000000000000000000000000000000;;	func newTrace() *trace {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case tr := <-traceFreeList:
0000000000000000000000000000000000000000;;			return tr
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return new(trace)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// freeTrace adds tr to traceFreeList if there's room.
0000000000000000000000000000000000000000;;	// This is non-blocking.
0000000000000000000000000000000000000000;;	func freeTrace(tr *trace) {
0000000000000000000000000000000000000000;;		if DebugUseAfterFinish {
0000000000000000000000000000000000000000;;			return // never reuse
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tr.reset()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case traceFreeList <- tr:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func elapsed(d time.Duration) string {
0000000000000000000000000000000000000000;;		b := []byte(fmt.Sprintf("%.6f", d.Seconds()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For subsecond durations, blank all zeros before decimal point,
0000000000000000000000000000000000000000;;		// and all zeros between the decimal point and the first non-zero digit.
0000000000000000000000000000000000000000;;		if d < time.Second {
0000000000000000000000000000000000000000;;			dot := bytes.IndexByte(b, '.')
0000000000000000000000000000000000000000;;			for i := 0; i < dot; i++ {
0000000000000000000000000000000000000000;;				b[i] = ' '
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := dot + 1; i < len(b); i++ {
0000000000000000000000000000000000000000;;				if b[i] == '0' {
0000000000000000000000000000000000000000;;					b[i] = ' '
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var pageTmplCache *template.Template
0000000000000000000000000000000000000000;;	var pageTmplOnce sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pageTmpl() *template.Template {
0000000000000000000000000000000000000000;;		pageTmplOnce.Do(func() {
0000000000000000000000000000000000000000;;			pageTmplCache = template.Must(template.New("Page").Funcs(template.FuncMap{
0000000000000000000000000000000000000000;;				"elapsed": elapsed,
0000000000000000000000000000000000000000;;				"add":     func(a, b int) int { return a + b },
0000000000000000000000000000000000000000;;			}).Parse(pageHTML))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return pageTmplCache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const pageHTML = `
0000000000000000000000000000000000000000;;	{{template "Prolog" .}}
0000000000000000000000000000000000000000;;	{{template "StatusTable" .}}
0000000000000000000000000000000000000000;;	{{template "Epilog" .}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{define "Prolog"}}
0000000000000000000000000000000000000000;;	<html>
0000000000000000000000000000000000000000;;		<head>
0000000000000000000000000000000000000000;;		<title>/debug/requests</title>
0000000000000000000000000000000000000000;;		<style type="text/css">
0000000000000000000000000000000000000000;;			body {
0000000000000000000000000000000000000000;;				font-family: sans-serif;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#tr-status td.family {
0000000000000000000000000000000000000000;;				padding-right: 2em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#tr-status td.active {
0000000000000000000000000000000000000000;;				padding-right: 1em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#tr-status td.latency-first {
0000000000000000000000000000000000000000;;				padding-left: 1em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#tr-status td.empty {
0000000000000000000000000000000000000000;;				color: #aaa;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#reqs {
0000000000000000000000000000000000000000;;				margin-top: 1em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#reqs tr.first {
0000000000000000000000000000000000000000;;				{{if $.Expanded}}font-weight: bold;{{end}}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#reqs td {
0000000000000000000000000000000000000000;;				font-family: monospace;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#reqs td.when {
0000000000000000000000000000000000000000;;				text-align: right;
0000000000000000000000000000000000000000;;				white-space: nowrap;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table#reqs td.elapsed {
0000000000000000000000000000000000000000;;				padding: 0 0.5em;
0000000000000000000000000000000000000000;;				text-align: right;
0000000000000000000000000000000000000000;;				white-space: pre;
0000000000000000000000000000000000000000;;				width: 10em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			address {
0000000000000000000000000000000000000000;;				font-size: smaller;
0000000000000000000000000000000000000000;;				margin-top: 5em;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		</style>
0000000000000000000000000000000000000000;;		</head>
0000000000000000000000000000000000000000;;		<body>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<h1>/debug/requests</h1>
0000000000000000000000000000000000000000;;	{{end}} {{/* end of Prolog */}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{define "StatusTable"}}
0000000000000000000000000000000000000000;;	<table id="tr-status">
0000000000000000000000000000000000000000;;		{{range $fam := .Families}}
0000000000000000000000000000000000000000;;		<tr>
0000000000000000000000000000000000000000;;			<td class="family">{{$fam}}</td>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{{$n := index $.ActiveTraceCount $fam}}
0000000000000000000000000000000000000000;;			<td class="active {{if not $n}}empty{{end}}">
0000000000000000000000000000000000000000;;				{{if $n}}<a href="?fam={{$fam}}&b=-1{{if $.Expanded}}&exp=1{{end}}">{{end}}
0000000000000000000000000000000000000000;;				[{{$n}} active]
0000000000000000000000000000000000000000;;				{{if $n}}</a>{{end}}
0000000000000000000000000000000000000000;;			</td>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{{$f := index $.CompletedTraces $fam}}
0000000000000000000000000000000000000000;;			{{range $i, $b := $f.Buckets}}
0000000000000000000000000000000000000000;;			{{$empty := $b.Empty}}
0000000000000000000000000000000000000000;;			<td {{if $empty}}class="empty"{{end}}>
0000000000000000000000000000000000000000;;			{{if not $empty}}<a href="?fam={{$fam}}&b={{$i}}{{if $.Expanded}}&exp=1{{end}}">{{end}}
0000000000000000000000000000000000000000;;			[{{.Cond}}]
0000000000000000000000000000000000000000;;			{{if not $empty}}</a>{{end}}
0000000000000000000000000000000000000000;;			</td>
0000000000000000000000000000000000000000;;			{{end}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{{$nb := len $f.Buckets}}
0000000000000000000000000000000000000000;;			<td class="latency-first">
0000000000000000000000000000000000000000;;			<a href="?fam={{$fam}}&b={{$nb}}">[minute]</a>
0000000000000000000000000000000000000000;;			</td>
0000000000000000000000000000000000000000;;			<td>
0000000000000000000000000000000000000000;;			<a href="?fam={{$fam}}&b={{add $nb 1}}">[hour]</a>
0000000000000000000000000000000000000000;;			</td>
0000000000000000000000000000000000000000;;			<td>
0000000000000000000000000000000000000000;;			<a href="?fam={{$fam}}&b={{add $nb 2}}">[total]</a>
0000000000000000000000000000000000000000;;			</td>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		</tr>
0000000000000000000000000000000000000000;;		{{end}}
0000000000000000000000000000000000000000;;	</table>
0000000000000000000000000000000000000000;;	{{end}} {{/* end of StatusTable */}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{define "Epilog"}}
0000000000000000000000000000000000000000;;	{{if $.Traces}}
0000000000000000000000000000000000000000;;	<hr />
0000000000000000000000000000000000000000;;	<h3>Family: {{$.Family}}</h3>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{if or $.Expanded $.Traced}}
0000000000000000000000000000000000000000;;	  <a href="?fam={{$.Family}}&b={{$.Bucket}}">[Normal/Summary]</a>
0000000000000000000000000000000000000000;;	{{else}}
0000000000000000000000000000000000000000;;	  [Normal/Summary]
0000000000000000000000000000000000000000;;	{{end}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{if or (not $.Expanded) $.Traced}}
0000000000000000000000000000000000000000;;	  <a href="?fam={{$.Family}}&b={{$.Bucket}}&exp=1">[Normal/Expanded]</a>
0000000000000000000000000000000000000000;;	{{else}}
0000000000000000000000000000000000000000;;	  [Normal/Expanded]
0000000000000000000000000000000000000000;;	{{end}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{if not $.Active}}
0000000000000000000000000000000000000000;;		{{if or $.Expanded (not $.Traced)}}
0000000000000000000000000000000000000000;;		<a href="?fam={{$.Family}}&b={{$.Bucket}}&rtraced=1">[Traced/Summary]</a>
0000000000000000000000000000000000000000;;		{{else}}
0000000000000000000000000000000000000000;;		[Traced/Summary]
0000000000000000000000000000000000000000;;		{{end}}
0000000000000000000000000000000000000000;;		{{if or (not $.Expanded) (not $.Traced)}}
0000000000000000000000000000000000000000;;		<a href="?fam={{$.Family}}&b={{$.Bucket}}&exp=1&rtraced=1">[Traced/Expanded]</a>
0000000000000000000000000000000000000000;;	        {{else}}
0000000000000000000000000000000000000000;;		[Traced/Expanded]
0000000000000000000000000000000000000000;;		{{end}}
0000000000000000000000000000000000000000;;	{{end}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{if $.Total}}
0000000000000000000000000000000000000000;;	<p><em>Showing <b>{{len $.Traces}}</b> of <b>{{$.Total}}</b> traces.</em></p>
0000000000000000000000000000000000000000;;	{{end}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<table id="reqs">
0000000000000000000000000000000000000000;;		<caption>
0000000000000000000000000000000000000000;;			{{if $.Active}}Active{{else}}Completed{{end}} Requests
0000000000000000000000000000000000000000;;		</caption>
0000000000000000000000000000000000000000;;		<tr><th>When</th><th>Elapsed&nbsp;(s)</th></tr>
0000000000000000000000000000000000000000;;		{{range $tr := $.Traces}}
0000000000000000000000000000000000000000;;		<tr class="first">
0000000000000000000000000000000000000000;;			<td class="when">{{$tr.When}}</td>
0000000000000000000000000000000000000000;;			<td class="elapsed">{{$tr.ElapsedTime}}</td>
0000000000000000000000000000000000000000;;			<td>{{$tr.Title}}</td>
0000000000000000000000000000000000000000;;			{{/* TODO: include traceID/spanID */}}
0000000000000000000000000000000000000000;;		</tr>
0000000000000000000000000000000000000000;;		{{if $.Expanded}}
0000000000000000000000000000000000000000;;		{{range $tr.Events}}
0000000000000000000000000000000000000000;;		<tr>
0000000000000000000000000000000000000000;;			<td class="when">{{.WhenString}}</td>
0000000000000000000000000000000000000000;;			<td class="elapsed">{{elapsed .Elapsed}}</td>
0000000000000000000000000000000000000000;;			<td>{{if or $.ShowSensitive (not .Sensitive)}}... {{.What}}{{else}}<em>[redacted]</em>{{end}}</td>
0000000000000000000000000000000000000000;;		</tr>
0000000000000000000000000000000000000000;;		{{end}}
0000000000000000000000000000000000000000;;		{{end}}
0000000000000000000000000000000000000000;;		{{end}}
0000000000000000000000000000000000000000;;	</table>
0000000000000000000000000000000000000000;;	{{end}} {{/* if $.Traces */}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	{{if $.Histogram}}
0000000000000000000000000000000000000000;;	<h4>Latency (&micro;s) of {{$.Family}} over {{$.HistogramWindow}}</h4>
0000000000000000000000000000000000000000;;	{{$.Histogram}}
0000000000000000000000000000000000000000;;	{{end}} {{/* if $.Histogram */}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		</body>
0000000000000000000000000000000000000000;;	</html>
0000000000000000000000000000000000000000;;	{{end}} {{/* end of Epilog */}}
0000000000000000000000000000000000000000;;	`
