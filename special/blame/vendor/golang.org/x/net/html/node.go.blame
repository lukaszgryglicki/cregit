0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
c2bfd044362efe23765620d054edcdab7497bde5;third_party/src/code.google.com/p/go.net/html/node.go[third_party/src/code.google.com/p/go.net/html/node.go][vendor/golang.org/x/net/html/node.go];	
0000000000000000000000000000000000000000;;	package html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"golang.org/x/net/html/atom"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A NodeType is the type of a Node.
0000000000000000000000000000000000000000;;	type NodeType uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ErrorNode NodeType = iota
0000000000000000000000000000000000000000;;		TextNode
0000000000000000000000000000000000000000;;		DocumentNode
0000000000000000000000000000000000000000;;		ElementNode
0000000000000000000000000000000000000000;;		CommentNode
0000000000000000000000000000000000000000;;		DoctypeNode
0000000000000000000000000000000000000000;;		scopeMarkerNode
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.3.3 says "scope markers are inserted when entering applet
0000000000000000000000000000000000000000;;	// elements, buttons, object elements, marquees, table cells, and table
0000000000000000000000000000000000000000;;	// captions, and are used to prevent formatting from 'leaking'".
0000000000000000000000000000000000000000;;	var scopeMarker = Node{Type: scopeMarkerNode}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Node consists of a NodeType and some Data (tag name for element nodes,
0000000000000000000000000000000000000000;;	// content for text) and are part of a tree of Nodes. Element nodes may also
0000000000000000000000000000000000000000;;	// have a Namespace and contain a slice of Attributes. Data is unescaped, so
0000000000000000000000000000000000000000;;	// that it looks like "a<b" rather than "a&lt;b". For element nodes, DataAtom
0000000000000000000000000000000000000000;;	// is the atom for Data, or zero if Data is not a known tag name.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An empty Namespace implies a "http://www.w3.org/1999/xhtml" namespace.
0000000000000000000000000000000000000000;;	// Similarly, "math" is short for "http://www.w3.org/1998/Math/MathML", and
0000000000000000000000000000000000000000;;	// "svg" is short for "http://www.w3.org/2000/svg".
0000000000000000000000000000000000000000;;	type Node struct {
0000000000000000000000000000000000000000;;		Parent, FirstChild, LastChild, PrevSibling, NextSibling *Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Type      NodeType
0000000000000000000000000000000000000000;;		DataAtom  atom.Atom
0000000000000000000000000000000000000000;;		Data      string
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		Attr      []Attribute
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InsertBefore inserts newChild as a child of n, immediately before oldChild
0000000000000000000000000000000000000000;;	// in the sequence of n's children. oldChild may be nil, in which case newChild
0000000000000000000000000000000000000000;;	// is appended to the end of n's children.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will panic if newChild already has a parent or siblings.
0000000000000000000000000000000000000000;;	func (n *Node) InsertBefore(newChild, oldChild *Node) {
0000000000000000000000000000000000000000;;		if newChild.Parent != nil || newChild.PrevSibling != nil || newChild.NextSibling != nil {
0000000000000000000000000000000000000000;;			panic("html: InsertBefore called for an attached child Node")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var prev, next *Node
0000000000000000000000000000000000000000;;		if oldChild != nil {
0000000000000000000000000000000000000000;;			prev, next = oldChild.PrevSibling, oldChild
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			prev = n.LastChild
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if prev != nil {
0000000000000000000000000000000000000000;;			prev.NextSibling = newChild
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			n.FirstChild = newChild
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if next != nil {
0000000000000000000000000000000000000000;;			next.PrevSibling = newChild
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			n.LastChild = newChild
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newChild.Parent = n
0000000000000000000000000000000000000000;;		newChild.PrevSibling = prev
0000000000000000000000000000000000000000;;		newChild.NextSibling = next
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppendChild adds a node c as a child of n.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will panic if c already has a parent or siblings.
0000000000000000000000000000000000000000;;	func (n *Node) AppendChild(c *Node) {
0000000000000000000000000000000000000000;;		if c.Parent != nil || c.PrevSibling != nil || c.NextSibling != nil {
0000000000000000000000000000000000000000;;			panic("html: AppendChild called for an attached child Node")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		last := n.LastChild
0000000000000000000000000000000000000000;;		if last != nil {
0000000000000000000000000000000000000000;;			last.NextSibling = c
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			n.FirstChild = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.LastChild = c
0000000000000000000000000000000000000000;;		c.Parent = n
0000000000000000000000000000000000000000;;		c.PrevSibling = last
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveChild removes a node c that is a child of n. Afterwards, c will have
0000000000000000000000000000000000000000;;	// no parent and no siblings.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will panic if c's parent is not n.
0000000000000000000000000000000000000000;;	func (n *Node) RemoveChild(c *Node) {
0000000000000000000000000000000000000000;;		if c.Parent != n {
0000000000000000000000000000000000000000;;			panic("html: RemoveChild called for a non-child Node")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.FirstChild == c {
0000000000000000000000000000000000000000;;			n.FirstChild = c.NextSibling
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.NextSibling != nil {
0000000000000000000000000000000000000000;;			c.NextSibling.PrevSibling = c.PrevSibling
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.LastChild == c {
0000000000000000000000000000000000000000;;			n.LastChild = c.PrevSibling
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.PrevSibling != nil {
0000000000000000000000000000000000000000;;			c.PrevSibling.NextSibling = c.NextSibling
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Parent = nil
0000000000000000000000000000000000000000;;		c.PrevSibling = nil
0000000000000000000000000000000000000000;;		c.NextSibling = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reparentChildren reparents all of src's child nodes to dst.
0000000000000000000000000000000000000000;;	func reparentChildren(dst, src *Node) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			child := src.FirstChild
0000000000000000000000000000000000000000;;			if child == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			src.RemoveChild(child)
0000000000000000000000000000000000000000;;			dst.AppendChild(child)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clone returns a new node with the same type, data and attributes.
0000000000000000000000000000000000000000;;	// The clone has no parent, no siblings and no children.
0000000000000000000000000000000000000000;;	func (n *Node) clone() *Node {
0000000000000000000000000000000000000000;;		m := &Node{
0000000000000000000000000000000000000000;;			Type:     n.Type,
0000000000000000000000000000000000000000;;			DataAtom: n.DataAtom,
0000000000000000000000000000000000000000;;			Data:     n.Data,
0000000000000000000000000000000000000000;;			Attr:     make([]Attribute, len(n.Attr)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(m.Attr, n.Attr)
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nodeStack is a stack of nodes.
0000000000000000000000000000000000000000;;	type nodeStack []*Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pop pops the stack. It will panic if s is empty.
0000000000000000000000000000000000000000;;	func (s *nodeStack) pop() *Node {
0000000000000000000000000000000000000000;;		i := len(*s)
0000000000000000000000000000000000000000;;		n := (*s)[i-1]
0000000000000000000000000000000000000000;;		*s = (*s)[:i-1]
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// top returns the most recently pushed node, or nil if s is empty.
0000000000000000000000000000000000000000;;	func (s *nodeStack) top() *Node {
0000000000000000000000000000000000000000;;		if i := len(*s); i > 0 {
0000000000000000000000000000000000000000;;			return (*s)[i-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// index returns the index of the top-most occurrence of n in the stack, or -1
0000000000000000000000000000000000000000;;	// if n is not present.
0000000000000000000000000000000000000000;;	func (s *nodeStack) index(n *Node) int {
0000000000000000000000000000000000000000;;		for i := len(*s) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			if (*s)[i] == n {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insert inserts a node at the given index.
0000000000000000000000000000000000000000;;	func (s *nodeStack) insert(i int, n *Node) {
0000000000000000000000000000000000000000;;		(*s) = append(*s, nil)
0000000000000000000000000000000000000000;;		copy((*s)[i+1:], (*s)[i:])
0000000000000000000000000000000000000000;;		(*s)[i] = n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// remove removes a node from the stack. It is a no-op if n is not present.
0000000000000000000000000000000000000000;;	func (s *nodeStack) remove(n *Node) {
0000000000000000000000000000000000000000;;		i := s.index(n)
0000000000000000000000000000000000000000;;		if i == -1 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy((*s)[i:], (*s)[i+1:])
0000000000000000000000000000000000000000;;		j := len(*s) - 1
0000000000000000000000000000000000000000;;		(*s)[j] = nil
0000000000000000000000000000000000000000;;		*s = (*s)[:j]
0000000000000000000000000000000000000000;;	}
