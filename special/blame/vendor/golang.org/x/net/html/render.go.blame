0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
c2bfd044362efe23765620d054edcdab7497bde5;third_party/src/code.google.com/p/go.net/html/render.go[third_party/src/code.google.com/p/go.net/html/render.go][vendor/golang.org/x/net/html/render.go];	
0000000000000000000000000000000000000000;;	package html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type writer interface {
0000000000000000000000000000000000000000;;		io.Writer
0000000000000000000000000000000000000000;;		io.ByteWriter
0000000000000000000000000000000000000000;;		WriteString(string) (int, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Render renders the parse tree n to the given writer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Rendering is done on a 'best effort' basis: calling Parse on the output of
0000000000000000000000000000000000000000;;	// Render will always result in something similar to the original tree, but it
0000000000000000000000000000000000000000;;	// is not necessarily an exact clone unless the original tree was 'well-formed'.
0000000000000000000000000000000000000000;;	// 'Well-formed' is not easily specified; the HTML5 specification is
0000000000000000000000000000000000000000;;	// complicated.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Calling Parse on arbitrary input typically results in a 'well-formed' parse
0000000000000000000000000000000000000000;;	// tree. However, it is possible for Parse to yield a 'badly-formed' parse tree.
0000000000000000000000000000000000000000;;	// For example, in a 'well-formed' parse tree, no <a> element is a child of
0000000000000000000000000000000000000000;;	// another <a> element: parsing "<a><a>" results in two sibling elements.
0000000000000000000000000000000000000000;;	// Similarly, in a 'well-formed' parse tree, no <a> element is a child of a
0000000000000000000000000000000000000000;;	// <table> element: parsing "<p><table><a>" results in a <p> with two sibling
0000000000000000000000000000000000000000;;	// children; the <a> is reparented to the <table>'s parent. However, calling
0000000000000000000000000000000000000000;;	// Parse on "<a><table><a>" does not return an error, but the result has an <a>
0000000000000000000000000000000000000000;;	// element with an <a> child, and is therefore not 'well-formed'.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Programmatically constructed trees are typically also 'well-formed', but it
0000000000000000000000000000000000000000;;	// is possible to construct a tree that looks innocuous but, when rendered and
0000000000000000000000000000000000000000;;	// re-parsed, results in a different tree. A simple example is that a solitary
0000000000000000000000000000000000000000;;	// text node would become a tree containing <html>, <head> and <body> elements.
0000000000000000000000000000000000000000;;	// Another example is that the programmatic equivalent of "a<head>b</head>c"
0000000000000000000000000000000000000000;;	// becomes "<html><head><head/><body>abc</body></html>".
0000000000000000000000000000000000000000;;	func Render(w io.Writer, n *Node) error {
0000000000000000000000000000000000000000;;		if x, ok := w.(writer); ok {
0000000000000000000000000000000000000000;;			return render(x, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := bufio.NewWriter(w)
0000000000000000000000000000000000000000;;		if err := render(buf, n); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// plaintextAbort is returned from render1 when a <plaintext> element
0000000000000000000000000000000000000000;;	// has been rendered. No more end tags should be rendered after that.
0000000000000000000000000000000000000000;;	var plaintextAbort = errors.New("html: internal error (plaintext abort)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func render(w writer, n *Node) error {
0000000000000000000000000000000000000000;;		err := render1(w, n)
0000000000000000000000000000000000000000;;		if err == plaintextAbort {
0000000000000000000000000000000000000000;;			err = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func render1(w writer, n *Node) error {
0000000000000000000000000000000000000000;;		// Render non-element nodes; these are the easy cases.
0000000000000000000000000000000000000000;;		switch n.Type {
0000000000000000000000000000000000000000;;		case ErrorNode:
0000000000000000000000000000000000000000;;			return errors.New("html: cannot render an ErrorNode node")
0000000000000000000000000000000000000000;;		case TextNode:
0000000000000000000000000000000000000000;;			return escape(w, n.Data)
0000000000000000000000000000000000000000;;		case DocumentNode:
0000000000000000000000000000000000000000;;			for c := n.FirstChild; c != nil; c = c.NextSibling {
0000000000000000000000000000000000000000;;				if err := render1(w, c); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case ElementNode:
0000000000000000000000000000000000000000;;			// No-op.
0000000000000000000000000000000000000000;;		case CommentNode:
0000000000000000000000000000000000000000;;			if _, err := w.WriteString("<!--"); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := w.WriteString(n.Data); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := w.WriteString("-->"); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case DoctypeNode:
0000000000000000000000000000000000000000;;			if _, err := w.WriteString("<!DOCTYPE "); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := w.WriteString(n.Data); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n.Attr != nil {
0000000000000000000000000000000000000000;;				var p, s string
0000000000000000000000000000000000000000;;				for _, a := range n.Attr {
0000000000000000000000000000000000000000;;					switch a.Key {
0000000000000000000000000000000000000000;;					case "public":
0000000000000000000000000000000000000000;;						p = a.Val
0000000000000000000000000000000000000000;;					case "system":
0000000000000000000000000000000000000000;;						s = a.Val
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if p != "" {
0000000000000000000000000000000000000000;;					if _, err := w.WriteString(" PUBLIC "); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := writeQuoted(w, p); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if s != "" {
0000000000000000000000000000000000000000;;						if err := w.WriteByte(' '); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if err := writeQuoted(w, s); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if s != "" {
0000000000000000000000000000000000000000;;					if _, err := w.WriteString(" SYSTEM "); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := writeQuoted(w, s); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return w.WriteByte('>')
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errors.New("html: unknown node type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Render the <xxx> opening tag.
0000000000000000000000000000000000000000;;		if err := w.WriteByte('<'); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := w.WriteString(n.Data); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, a := range n.Attr {
0000000000000000000000000000000000000000;;			if err := w.WriteByte(' '); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if a.Namespace != "" {
0000000000000000000000000000000000000000;;				if _, err := w.WriteString(a.Namespace); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := w.WriteByte(':'); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := w.WriteString(a.Key); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := w.WriteString(`="`); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := escape(w, a.Val); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := w.WriteByte('"'); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if voidElements[n.Data] {
0000000000000000000000000000000000000000;;			if n.FirstChild != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("html: void element <%s> has child nodes", n.Data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := w.WriteString("/>")
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := w.WriteByte('>'); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add initial newline where there is danger of a newline beging ignored.
0000000000000000000000000000000000000000;;		if c := n.FirstChild; c != nil && c.Type == TextNode && strings.HasPrefix(c.Data, "\n") {
0000000000000000000000000000000000000000;;			switch n.Data {
0000000000000000000000000000000000000000;;			case "pre", "listing", "textarea":
0000000000000000000000000000000000000000;;				if err := w.WriteByte('\n'); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Render any child nodes.
0000000000000000000000000000000000000000;;		switch n.Data {
0000000000000000000000000000000000000000;;		case "iframe", "noembed", "noframes", "noscript", "plaintext", "script", "style", "xmp":
0000000000000000000000000000000000000000;;			for c := n.FirstChild; c != nil; c = c.NextSibling {
0000000000000000000000000000000000000000;;				if c.Type == TextNode {
0000000000000000000000000000000000000000;;					if _, err := w.WriteString(c.Data); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err := render1(w, c); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n.Data == "plaintext" {
0000000000000000000000000000000000000000;;				// Don't render anything else. <plaintext> must be the
0000000000000000000000000000000000000000;;				// last element in the file, with no closing tag.
0000000000000000000000000000000000000000;;				return plaintextAbort
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			for c := n.FirstChild; c != nil; c = c.NextSibling {
0000000000000000000000000000000000000000;;				if err := render1(w, c); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Render the </xxx> closing tag.
0000000000000000000000000000000000000000;;		if _, err := w.WriteString("</"); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := w.WriteString(n.Data); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.WriteByte('>')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeQuoted writes s to w surrounded by quotes. Normally it will use double
0000000000000000000000000000000000000000;;	// quotes, but if s contains a double quote, it will use single quotes.
0000000000000000000000000000000000000000;;	// It is used for writing the identifiers in a doctype declaration.
0000000000000000000000000000000000000000;;	// In valid HTML, they can't contain both types of quotes.
0000000000000000000000000000000000000000;;	func writeQuoted(w writer, s string) error {
0000000000000000000000000000000000000000;;		var q byte = '"'
0000000000000000000000000000000000000000;;		if strings.Contains(s, `"`) {
0000000000000000000000000000000000000000;;			q = '\''
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := w.WriteByte(q); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := w.WriteString(s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := w.WriteByte(q); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.1.2, "Elements", gives this list of void elements. Void elements
0000000000000000000000000000000000000000;;	// are those that can't have any contents.
0000000000000000000000000000000000000000;;	var voidElements = map[string]bool{
0000000000000000000000000000000000000000;;		"area":    true,
0000000000000000000000000000000000000000;;		"base":    true,
0000000000000000000000000000000000000000;;		"br":      true,
0000000000000000000000000000000000000000;;		"col":     true,
0000000000000000000000000000000000000000;;		"command": true,
0000000000000000000000000000000000000000;;		"embed":   true,
0000000000000000000000000000000000000000;;		"hr":      true,
0000000000000000000000000000000000000000;;		"img":     true,
0000000000000000000000000000000000000000;;		"input":   true,
0000000000000000000000000000000000000000;;		"keygen":  true,
0000000000000000000000000000000000000000;;		"link":    true,
0000000000000000000000000000000000000000;;		"meta":    true,
0000000000000000000000000000000000000000;;		"param":   true,
0000000000000000000000000000000000000000;;		"source":  true,
0000000000000000000000000000000000000000;;		"track":   true,
0000000000000000000000000000000000000000;;		"wbr":     true,
0000000000000000000000000000000000000000;;	}
