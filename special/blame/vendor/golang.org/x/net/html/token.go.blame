0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
c2bfd044362efe23765620d054edcdab7497bde5;third_party/src/code.google.com/p/go.net/html/token.go[third_party/src/code.google.com/p/go.net/html/token.go][vendor/golang.org/x/net/html/token.go];	
0000000000000000000000000000000000000000;;	package html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/html/atom"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A TokenType is the type of a Token.
0000000000000000000000000000000000000000;;	type TokenType uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ErrorToken means that an error occurred during tokenization.
0000000000000000000000000000000000000000;;		ErrorToken TokenType = iota
0000000000000000000000000000000000000000;;		// TextToken means a text node.
0000000000000000000000000000000000000000;;		TextToken
0000000000000000000000000000000000000000;;		// A StartTagToken looks like <a>.
0000000000000000000000000000000000000000;;		StartTagToken
0000000000000000000000000000000000000000;;		// An EndTagToken looks like </a>.
0000000000000000000000000000000000000000;;		EndTagToken
0000000000000000000000000000000000000000;;		// A SelfClosingTagToken tag looks like <br/>.
0000000000000000000000000000000000000000;;		SelfClosingTagToken
0000000000000000000000000000000000000000;;		// A CommentToken looks like <!--x-->.
0000000000000000000000000000000000000000;;		CommentToken
0000000000000000000000000000000000000000;;		// A DoctypeToken looks like <!DOCTYPE x>
0000000000000000000000000000000000000000;;		DoctypeToken
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrBufferExceeded means that the buffering limit was exceeded.
0000000000000000000000000000000000000000;;	var ErrBufferExceeded = errors.New("max buffer exceeded")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string representation of the TokenType.
0000000000000000000000000000000000000000;;	func (t TokenType) String() string {
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case ErrorToken:
0000000000000000000000000000000000000000;;			return "Error"
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			return "Text"
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			return "StartTag"
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			return "EndTag"
0000000000000000000000000000000000000000;;		case SelfClosingTagToken:
0000000000000000000000000000000000000000;;			return "SelfClosingTag"
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			return "Comment"
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			return "Doctype"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "Invalid(" + strconv.Itoa(int(t)) + ")"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Attribute is an attribute namespace-key-value triple. Namespace is
0000000000000000000000000000000000000000;;	// non-empty for foreign attributes like xlink, Key is alphabetic (and hence
0000000000000000000000000000000000000000;;	// does not contain escapable characters like '&', '<' or '>'), and Val is
0000000000000000000000000000000000000000;;	// unescaped (it looks like "a<b" rather than "a&lt;b").
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Namespace is only used by the parser, not the tokenizer.
0000000000000000000000000000000000000000;;	type Attribute struct {
0000000000000000000000000000000000000000;;		Namespace, Key, Val string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Token consists of a TokenType and some Data (tag name for start and end
0000000000000000000000000000000000000000;;	// tags, content for text, comments and doctypes). A tag Token may also contain
0000000000000000000000000000000000000000;;	// a slice of Attributes. Data is unescaped for all Tokens (it looks like "a<b"
0000000000000000000000000000000000000000;;	// rather than "a&lt;b"). For tag Tokens, DataAtom is the atom for Data, or
0000000000000000000000000000000000000000;;	// zero if Data is not a known tag name.
0000000000000000000000000000000000000000;;	type Token struct {
0000000000000000000000000000000000000000;;		Type     TokenType
0000000000000000000000000000000000000000;;		DataAtom atom.Atom
0000000000000000000000000000000000000000;;		Data     string
0000000000000000000000000000000000000000;;		Attr     []Attribute
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tagString returns a string representation of a tag Token's Data and Attr.
0000000000000000000000000000000000000000;;	func (t Token) tagString() string {
0000000000000000000000000000000000000000;;		if len(t.Attr) == 0 {
0000000000000000000000000000000000000000;;			return t.Data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := bytes.NewBufferString(t.Data)
0000000000000000000000000000000000000000;;		for _, a := range t.Attr {
0000000000000000000000000000000000000000;;			buf.WriteByte(' ')
0000000000000000000000000000000000000000;;			buf.WriteString(a.Key)
0000000000000000000000000000000000000000;;			buf.WriteString(`="`)
0000000000000000000000000000000000000000;;			escape(buf, a.Val)
0000000000000000000000000000000000000000;;			buf.WriteByte('"')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string representation of the Token.
0000000000000000000000000000000000000000;;	func (t Token) String() string {
0000000000000000000000000000000000000000;;		switch t.Type {
0000000000000000000000000000000000000000;;		case ErrorToken:
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			return EscapeString(t.Data)
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			return "<" + t.tagString() + ">"
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			return "</" + t.tagString() + ">"
0000000000000000000000000000000000000000;;		case SelfClosingTagToken:
0000000000000000000000000000000000000000;;			return "<" + t.tagString() + "/>"
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			return "<!--" + t.Data + "-->"
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			return "<!DOCTYPE " + t.Data + ">"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "Invalid(" + strconv.Itoa(int(t.Type)) + ")"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// span is a range of bytes in a Tokenizer's buffer. The start is inclusive,
0000000000000000000000000000000000000000;;	// the end is exclusive.
0000000000000000000000000000000000000000;;	type span struct {
0000000000000000000000000000000000000000;;		start, end int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Tokenizer returns a stream of HTML Tokens.
0000000000000000000000000000000000000000;;	type Tokenizer struct {
0000000000000000000000000000000000000000;;		// r is the source of the HTML text.
0000000000000000000000000000000000000000;;		r io.Reader
0000000000000000000000000000000000000000;;		// tt is the TokenType of the current token.
0000000000000000000000000000000000000000;;		tt TokenType
0000000000000000000000000000000000000000;;		// err is the first error encountered during tokenization. It is possible
0000000000000000000000000000000000000000;;		// for tt != Error && err != nil to hold: this means that Next returned a
0000000000000000000000000000000000000000;;		// valid token but the subsequent Next call will return an error token.
0000000000000000000000000000000000000000;;		// For example, if the HTML text input was just "plain", then the first
0000000000000000000000000000000000000000;;		// Next call would set z.err to io.EOF but return a TextToken, and all
0000000000000000000000000000000000000000;;		// subsequent Next calls would return an ErrorToken.
0000000000000000000000000000000000000000;;		// err is never reset. Once it becomes non-nil, it stays non-nil.
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;		// readErr is the error returned by the io.Reader r. It is separate from
0000000000000000000000000000000000000000;;		// err because it is valid for an io.Reader to return (n int, err1 error)
0000000000000000000000000000000000000000;;		// such that n > 0 && err1 != nil, and callers should always process the
0000000000000000000000000000000000000000;;		// n > 0 bytes before considering the error err1.
0000000000000000000000000000000000000000;;		readErr error
0000000000000000000000000000000000000000;;		// buf[raw.start:raw.end] holds the raw bytes of the current token.
0000000000000000000000000000000000000000;;		// buf[raw.end:] is buffered input that will yield future tokens.
0000000000000000000000000000000000000000;;		raw span
0000000000000000000000000000000000000000;;		buf []byte
0000000000000000000000000000000000000000;;		// maxBuf limits the data buffered in buf. A value of 0 means unlimited.
0000000000000000000000000000000000000000;;		maxBuf int
0000000000000000000000000000000000000000;;		// buf[data.start:data.end] holds the raw bytes of the current token's data:
0000000000000000000000000000000000000000;;		// a text token's text, a tag token's tag name, etc.
0000000000000000000000000000000000000000;;		data span
0000000000000000000000000000000000000000;;		// pendingAttr is the attribute key and value currently being tokenized.
0000000000000000000000000000000000000000;;		// When complete, pendingAttr is pushed onto attr. nAttrReturned is
0000000000000000000000000000000000000000;;		// incremented on each call to TagAttr.
0000000000000000000000000000000000000000;;		pendingAttr   [2]span
0000000000000000000000000000000000000000;;		attr          [][2]span
0000000000000000000000000000000000000000;;		nAttrReturned int
0000000000000000000000000000000000000000;;		// rawTag is the "script" in "</script>" that closes the next token. If
0000000000000000000000000000000000000000;;		// non-empty, the subsequent call to Next will return a raw or RCDATA text
0000000000000000000000000000000000000000;;		// token: one that treats "<p>" as text instead of an element.
0000000000000000000000000000000000000000;;		// rawTag's contents are lower-cased.
0000000000000000000000000000000000000000;;		rawTag string
0000000000000000000000000000000000000000;;		// textIsRaw is whether the current text token's data is not escaped.
0000000000000000000000000000000000000000;;		textIsRaw bool
0000000000000000000000000000000000000000;;		// convertNUL is whether NUL bytes in the current token's data should
0000000000000000000000000000000000000000;;		// be converted into \ufffd replacement characters.
0000000000000000000000000000000000000000;;		convertNUL bool
0000000000000000000000000000000000000000;;		// allowCDATA is whether CDATA sections are allowed in the current context.
0000000000000000000000000000000000000000;;		allowCDATA bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllowCDATA sets whether or not the tokenizer recognizes <![CDATA[foo]]> as
0000000000000000000000000000000000000000;;	// the text "foo". The default value is false, which means to recognize it as
0000000000000000000000000000000000000000;;	// a bogus comment "<!-- [CDATA[foo]] -->" instead.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Strictly speaking, an HTML5 compliant tokenizer should allow CDATA if and
0000000000000000000000000000000000000000;;	// only if tokenizing foreign content, such as MathML and SVG. However,
0000000000000000000000000000000000000000;;	// tracking foreign-contentness is difficult to do purely in the tokenizer,
0000000000000000000000000000000000000000;;	// as opposed to the parser, due to HTML integration points: an <svg> element
0000000000000000000000000000000000000000;;	// can contain a <foreignObject> that is foreign-to-SVG but not foreign-to-
0000000000000000000000000000000000000000;;	// HTML. For strict compliance with the HTML5 tokenization algorithm, it is the
0000000000000000000000000000000000000000;;	// responsibility of the user of a tokenizer to call AllowCDATA as appropriate.
0000000000000000000000000000000000000000;;	// In practice, if using the tokenizer without caring whether MathML or SVG
0000000000000000000000000000000000000000;;	// CDATA is text or comments, such as tokenizing HTML to find all the anchor
0000000000000000000000000000000000000000;;	// text, it is acceptable to ignore this responsibility.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) AllowCDATA(allowCDATA bool) {
0000000000000000000000000000000000000000;;		z.allowCDATA = allowCDATA
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextIsNotRawText instructs the tokenizer that the next token should not be
0000000000000000000000000000000000000000;;	// considered as 'raw text'. Some elements, such as script and title elements,
0000000000000000000000000000000000000000;;	// normally require the next token after the opening tag to be 'raw text' that
0000000000000000000000000000000000000000;;	// has no child elements. For example, tokenizing "<title>a<b>c</b>d</title>"
0000000000000000000000000000000000000000;;	// yields a start tag token for "<title>", a text token for "a<b>c</b>d", and
0000000000000000000000000000000000000000;;	// an end tag token for "</title>". There are no distinct start tag or end tag
0000000000000000000000000000000000000000;;	// tokens for the "<b>" and "</b>".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This tokenizer implementation will generally look for raw text at the right
0000000000000000000000000000000000000000;;	// times. Strictly speaking, an HTML5 compliant tokenizer should not look for
0000000000000000000000000000000000000000;;	// raw text if in foreign content: <title> generally needs raw text, but a
0000000000000000000000000000000000000000;;	// <title> inside an <svg> does not. Another example is that a <textarea>
0000000000000000000000000000000000000000;;	// generally needs raw text, but a <textarea> is not allowed as an immediate
0000000000000000000000000000000000000000;;	// child of a <select>; in normal parsing, a <textarea> implies </select>, but
0000000000000000000000000000000000000000;;	// one cannot close the implicit element when parsing a <select>'s InnerHTML.
0000000000000000000000000000000000000000;;	// Similarly to AllowCDATA, tracking the correct moment to override raw-text-
0000000000000000000000000000000000000000;;	// ness is difficult to do purely in the tokenizer, as opposed to the parser.
0000000000000000000000000000000000000000;;	// For strict compliance with the HTML5 tokenization algorithm, it is the
0000000000000000000000000000000000000000;;	// responsibility of the user of a tokenizer to call NextIsNotRawText as
0000000000000000000000000000000000000000;;	// appropriate. In practice, like AllowCDATA, it is acceptable to ignore this
0000000000000000000000000000000000000000;;	// responsibility for basic usage.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that this 'raw text' concept is different from the one offered by the
0000000000000000000000000000000000000000;;	// Tokenizer.Raw method.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) NextIsNotRawText() {
0000000000000000000000000000000000000000;;		z.rawTag = ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Err returns the error associated with the most recent ErrorToken token.
0000000000000000000000000000000000000000;;	// This is typically io.EOF, meaning the end of tokenization.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) Err() error {
0000000000000000000000000000000000000000;;		if z.tt != ErrorToken {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return z.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readByte returns the next byte from the input stream, doing a buffered read
0000000000000000000000000000000000000000;;	// from z.r into z.buf if necessary. z.buf[z.raw.start:z.raw.end] remains a contiguous byte
0000000000000000000000000000000000000000;;	// slice that holds all the bytes read so far for the current token.
0000000000000000000000000000000000000000;;	// It sets z.err if the underlying reader returns an error.
0000000000000000000000000000000000000000;;	// Pre-condition: z.err == nil.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readByte() byte {
0000000000000000000000000000000000000000;;		if z.raw.end >= len(z.buf) {
0000000000000000000000000000000000000000;;			// Our buffer is exhausted and we have to read from z.r. Check if the
0000000000000000000000000000000000000000;;			// previous read resulted in an error.
0000000000000000000000000000000000000000;;			if z.readErr != nil {
0000000000000000000000000000000000000000;;				z.err = z.readErr
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We copy z.buf[z.raw.start:z.raw.end] to the beginning of z.buf. If the length
0000000000000000000000000000000000000000;;			// z.raw.end - z.raw.start is more than half the capacity of z.buf, then we
0000000000000000000000000000000000000000;;			// allocate a new buffer before the copy.
0000000000000000000000000000000000000000;;			c := cap(z.buf)
0000000000000000000000000000000000000000;;			d := z.raw.end - z.raw.start
0000000000000000000000000000000000000000;;			var buf1 []byte
0000000000000000000000000000000000000000;;			if 2*d > c {
0000000000000000000000000000000000000000;;				buf1 = make([]byte, d, 2*c)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buf1 = z.buf[:d]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy(buf1, z.buf[z.raw.start:z.raw.end])
0000000000000000000000000000000000000000;;			if x := z.raw.start; x != 0 {
0000000000000000000000000000000000000000;;				// Adjust the data/attr spans to refer to the same contents after the copy.
0000000000000000000000000000000000000000;;				z.data.start -= x
0000000000000000000000000000000000000000;;				z.data.end -= x
0000000000000000000000000000000000000000;;				z.pendingAttr[0].start -= x
0000000000000000000000000000000000000000;;				z.pendingAttr[0].end -= x
0000000000000000000000000000000000000000;;				z.pendingAttr[1].start -= x
0000000000000000000000000000000000000000;;				z.pendingAttr[1].end -= x
0000000000000000000000000000000000000000;;				for i := range z.attr {
0000000000000000000000000000000000000000;;					z.attr[i][0].start -= x
0000000000000000000000000000000000000000;;					z.attr[i][0].end -= x
0000000000000000000000000000000000000000;;					z.attr[i][1].start -= x
0000000000000000000000000000000000000000;;					z.attr[i][1].end -= x
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			z.raw.start, z.raw.end, z.buf = 0, d, buf1[:d]
0000000000000000000000000000000000000000;;			// Now that we have copied the live bytes to the start of the buffer,
0000000000000000000000000000000000000000;;			// we read from z.r into the remainder.
0000000000000000000000000000000000000000;;			var n int
0000000000000000000000000000000000000000;;			n, z.readErr = readAtLeastOneByte(z.r, buf1[d:cap(buf1)])
0000000000000000000000000000000000000000;;			if n == 0 {
0000000000000000000000000000000000000000;;				z.err = z.readErr
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			z.buf = buf1[:d+n]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := z.buf[z.raw.end]
0000000000000000000000000000000000000000;;		z.raw.end++
0000000000000000000000000000000000000000;;		if z.maxBuf > 0 && z.raw.end-z.raw.start >= z.maxBuf {
0000000000000000000000000000000000000000;;			z.err = ErrBufferExceeded
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Buffered returns a slice containing data buffered but not yet tokenized.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) Buffered() []byte {
0000000000000000000000000000000000000000;;		return z.buf[z.raw.end:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readAtLeastOneByte wraps an io.Reader so that reading cannot return (0, nil).
0000000000000000000000000000000000000000;;	// It returns io.ErrNoProgress if the underlying r.Read method returns (0, nil)
0000000000000000000000000000000000000000;;	// too many times in succession.
0000000000000000000000000000000000000000;;	func readAtLeastOneByte(r io.Reader, b []byte) (int, error) {
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			n, err := r.Read(b)
0000000000000000000000000000000000000000;;			if n != 0 || err != nil {
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, io.ErrNoProgress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// skipWhiteSpace skips past any white space.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) skipWhiteSpace() {
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case ' ', '\n', '\r', '\t', '\f':
0000000000000000000000000000000000000000;;				// No-op.
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				z.raw.end--
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readRawOrRCDATA reads until the next "</foo>", where "foo" is z.rawTag and
0000000000000000000000000000000000000000;;	// is typically something like "script" or "textarea".
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readRawOrRCDATA() {
0000000000000000000000000000000000000000;;		if z.rawTag == "script" {
0000000000000000000000000000000000000000;;			z.readScript()
0000000000000000000000000000000000000000;;			z.textIsRaw = true
0000000000000000000000000000000000000000;;			z.rawTag = ""
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != '<' {
0000000000000000000000000000000000000000;;				continue loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c = z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != '/' {
0000000000000000000000000000000000000000;;				continue loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if z.readRawEndTag() || z.err != nil {
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.data.end = z.raw.end
0000000000000000000000000000000000000000;;		// A textarea's or title's RCDATA can contain escaped entities.
0000000000000000000000000000000000000000;;		z.textIsRaw = z.rawTag != "textarea" && z.rawTag != "title"
0000000000000000000000000000000000000000;;		z.rawTag = ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readRawEndTag attempts to read a tag like "</foo>", where "foo" is z.rawTag.
0000000000000000000000000000000000000000;;	// If it succeeds, it backs up the input position to reconsume the tag and
0000000000000000000000000000000000000000;;	// returns true. Otherwise it returns false. The opening "</" has already been
0000000000000000000000000000000000000000;;	// consumed.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readRawEndTag() bool {
0000000000000000000000000000000000000000;;		for i := 0; i < len(z.rawTag); i++ {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != z.rawTag[i] && c != z.rawTag[i]-('a'-'A') {
0000000000000000000000000000000000000000;;				z.raw.end--
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case ' ', '\n', '\r', '\t', '\f', '/', '>':
0000000000000000000000000000000000000000;;			// The 3 is 2 for the leading "</" plus 1 for the trailing character c.
0000000000000000000000000000000000000000;;			z.raw.end -= 3 + len(z.rawTag)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.raw.end--
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readScript reads until the next </script> tag, following the byzantine
0000000000000000000000000000000000000000;;	// rules for escaping/hiding the closing tag.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readScript() {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			z.data.end = z.raw.end
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		var c byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptData:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == '<' {
0000000000000000000000000000000000000000;;			goto scriptDataLessThanSign
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		goto scriptData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataLessThanSign:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '/':
0000000000000000000000000000000000000000;;			goto scriptDataEndTagOpen
0000000000000000000000000000000000000000;;		case '!':
0000000000000000000000000000000000000000;;			goto scriptDataEscapeStart
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.raw.end--
0000000000000000000000000000000000000000;;		goto scriptData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataEndTagOpen:
0000000000000000000000000000000000000000;;		if z.readRawEndTag() || z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		goto scriptData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataEscapeStart:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == '-' {
0000000000000000000000000000000000000000;;			goto scriptDataEscapeStartDash
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.raw.end--
0000000000000000000000000000000000000000;;		goto scriptData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataEscapeStartDash:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == '-' {
0000000000000000000000000000000000000000;;			goto scriptDataEscapedDashDash
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.raw.end--
0000000000000000000000000000000000000000;;		goto scriptData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataEscaped:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '-':
0000000000000000000000000000000000000000;;			goto scriptDataEscapedDash
0000000000000000000000000000000000000000;;		case '<':
0000000000000000000000000000000000000000;;			goto scriptDataEscapedLessThanSign
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		goto scriptDataEscaped
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataEscapedDash:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '-':
0000000000000000000000000000000000000000;;			goto scriptDataEscapedDashDash
0000000000000000000000000000000000000000;;		case '<':
0000000000000000000000000000000000000000;;			goto scriptDataEscapedLessThanSign
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		goto scriptDataEscaped
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataEscapedDashDash:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '-':
0000000000000000000000000000000000000000;;			goto scriptDataEscapedDashDash
0000000000000000000000000000000000000000;;		case '<':
0000000000000000000000000000000000000000;;			goto scriptDataEscapedLessThanSign
0000000000000000000000000000000000000000;;		case '>':
0000000000000000000000000000000000000000;;			goto scriptData
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		goto scriptDataEscaped
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataEscapedLessThanSign:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == '/' {
0000000000000000000000000000000000000000;;			goto scriptDataEscapedEndTagOpen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' {
0000000000000000000000000000000000000000;;			goto scriptDataDoubleEscapeStart
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.raw.end--
0000000000000000000000000000000000000000;;		goto scriptData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataEscapedEndTagOpen:
0000000000000000000000000000000000000000;;		if z.readRawEndTag() || z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		goto scriptDataEscaped
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataDoubleEscapeStart:
0000000000000000000000000000000000000000;;		z.raw.end--
0000000000000000000000000000000000000000;;		for i := 0; i < len("script"); i++ {
0000000000000000000000000000000000000000;;			c = z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != "script"[i] && c != "SCRIPT"[i] {
0000000000000000000000000000000000000000;;				z.raw.end--
0000000000000000000000000000000000000000;;				goto scriptDataEscaped
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case ' ', '\n', '\r', '\t', '\f', '/', '>':
0000000000000000000000000000000000000000;;			goto scriptDataDoubleEscaped
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.raw.end--
0000000000000000000000000000000000000000;;		goto scriptDataEscaped
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataDoubleEscaped:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '-':
0000000000000000000000000000000000000000;;			goto scriptDataDoubleEscapedDash
0000000000000000000000000000000000000000;;		case '<':
0000000000000000000000000000000000000000;;			goto scriptDataDoubleEscapedLessThanSign
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		goto scriptDataDoubleEscaped
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataDoubleEscapedDash:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '-':
0000000000000000000000000000000000000000;;			goto scriptDataDoubleEscapedDashDash
0000000000000000000000000000000000000000;;		case '<':
0000000000000000000000000000000000000000;;			goto scriptDataDoubleEscapedLessThanSign
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		goto scriptDataDoubleEscaped
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataDoubleEscapedDashDash:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '-':
0000000000000000000000000000000000000000;;			goto scriptDataDoubleEscapedDashDash
0000000000000000000000000000000000000000;;		case '<':
0000000000000000000000000000000000000000;;			goto scriptDataDoubleEscapedLessThanSign
0000000000000000000000000000000000000000;;		case '>':
0000000000000000000000000000000000000000;;			goto scriptData
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		goto scriptDataDoubleEscaped
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataDoubleEscapedLessThanSign:
0000000000000000000000000000000000000000;;		c = z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == '/' {
0000000000000000000000000000000000000000;;			goto scriptDataDoubleEscapeEnd
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.raw.end--
0000000000000000000000000000000000000000;;		goto scriptDataDoubleEscaped
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	scriptDataDoubleEscapeEnd:
0000000000000000000000000000000000000000;;		if z.readRawEndTag() {
0000000000000000000000000000000000000000;;			z.raw.end += len("</script>")
0000000000000000000000000000000000000000;;			goto scriptDataEscaped
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		goto scriptDataDoubleEscaped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readComment reads the next comment token starting with "<!--". The opening
0000000000000000000000000000000000000000;;	// "<!--" has already been consumed.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readComment() {
0000000000000000000000000000000000000000;;		z.data.start = z.raw.end
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if z.data.end < z.data.start {
0000000000000000000000000000000000000000;;				// It's a comment with no data, like <!-->.
0000000000000000000000000000000000000000;;				z.data.end = z.data.start
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		for dashCount := 2; ; {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				// Ignore up to two dashes at EOF.
0000000000000000000000000000000000000000;;				if dashCount > 2 {
0000000000000000000000000000000000000000;;					dashCount = 2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end - dashCount
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case '-':
0000000000000000000000000000000000000000;;				dashCount++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case '>':
0000000000000000000000000000000000000000;;				if dashCount >= 2 {
0000000000000000000000000000000000000000;;					z.data.end = z.raw.end - len("-->")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case '!':
0000000000000000000000000000000000000000;;				if dashCount >= 2 {
0000000000000000000000000000000000000000;;					c = z.readByte()
0000000000000000000000000000000000000000;;					if z.err != nil {
0000000000000000000000000000000000000000;;						z.data.end = z.raw.end
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if c == '>' {
0000000000000000000000000000000000000000;;						z.data.end = z.raw.end - len("--!>")
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dashCount = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readUntilCloseAngle reads until the next ">".
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readUntilCloseAngle() {
0000000000000000000000000000000000000000;;		z.data.start = z.raw.end
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c == '>' {
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end - len(">")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readMarkupDeclaration reads the next token starting with "<!". It might be
0000000000000000000000000000000000000000;;	// a "<!--comment-->", a "<!DOCTYPE foo>", a "<![CDATA[section]]>" or
0000000000000000000000000000000000000000;;	// "<!a bogus comment". The opening "<!" has already been consumed.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readMarkupDeclaration() TokenType {
0000000000000000000000000000000000000000;;		z.data.start = z.raw.end
0000000000000000000000000000000000000000;;		var c [2]byte
0000000000000000000000000000000000000000;;		for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;			c[i] = z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end
0000000000000000000000000000000000000000;;				return CommentToken
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c[0] == '-' && c[1] == '-' {
0000000000000000000000000000000000000000;;			z.readComment()
0000000000000000000000000000000000000000;;			return CommentToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.raw.end -= 2
0000000000000000000000000000000000000000;;		if z.readDoctype() {
0000000000000000000000000000000000000000;;			return DoctypeToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if z.allowCDATA && z.readCDATA() {
0000000000000000000000000000000000000000;;			z.convertNUL = true
0000000000000000000000000000000000000000;;			return TextToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// It's a bogus comment.
0000000000000000000000000000000000000000;;		z.readUntilCloseAngle()
0000000000000000000000000000000000000000;;		return CommentToken
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readDoctype attempts to read a doctype declaration and returns true if
0000000000000000000000000000000000000000;;	// successful. The opening "<!" has already been consumed.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readDoctype() bool {
0000000000000000000000000000000000000000;;		const s = "DOCTYPE"
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != s[i] && c != s[i]+('a'-'A') {
0000000000000000000000000000000000000000;;				// Back up to read the fragment of "DOCTYPE" again.
0000000000000000000000000000000000000000;;				z.raw.end = z.data.start
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if z.skipWhiteSpace(); z.err != nil {
0000000000000000000000000000000000000000;;			z.data.start = z.raw.end
0000000000000000000000000000000000000000;;			z.data.end = z.raw.end
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.readUntilCloseAngle()
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readCDATA attempts to read a CDATA section and returns true if
0000000000000000000000000000000000000000;;	// successful. The opening "<!" has already been consumed.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readCDATA() bool {
0000000000000000000000000000000000000000;;		const s = "[CDATA["
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != s[i] {
0000000000000000000000000000000000000000;;				// Back up to read the fragment of "[CDATA[" again.
0000000000000000000000000000000000000000;;				z.raw.end = z.data.start
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.data.start = z.raw.end
0000000000000000000000000000000000000000;;		brackets := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case ']':
0000000000000000000000000000000000000000;;				brackets++
0000000000000000000000000000000000000000;;			case '>':
0000000000000000000000000000000000000000;;				if brackets >= 2 {
0000000000000000000000000000000000000000;;					z.data.end = z.raw.end - len("]]>")
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				brackets = 0
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				brackets = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startTagIn returns whether the start tag in z.buf[z.data.start:z.data.end]
0000000000000000000000000000000000000000;;	// case-insensitively matches any element of ss.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) startTagIn(ss ...string) bool {
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for _, s := range ss {
0000000000000000000000000000000000000000;;			if z.data.end-z.data.start != len(s) {
0000000000000000000000000000000000000000;;				continue loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;				c := z.buf[z.data.start+i]
0000000000000000000000000000000000000000;;				if 'A' <= c && c <= 'Z' {
0000000000000000000000000000000000000000;;					c += 'a' - 'A'
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c != s[i] {
0000000000000000000000000000000000000000;;					continue loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readStartTag reads the next start tag token. The opening "<a" has already
0000000000000000000000000000000000000000;;	// been consumed, where 'a' means anything in [A-Za-z].
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readStartTag() TokenType {
0000000000000000000000000000000000000000;;		z.readTag(true)
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return ErrorToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Several tags flag the tokenizer's next token as raw.
0000000000000000000000000000000000000000;;		c, raw := z.buf[z.data.start], false
0000000000000000000000000000000000000000;;		if 'A' <= c && c <= 'Z' {
0000000000000000000000000000000000000000;;			c += 'a' - 'A'
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case 'i':
0000000000000000000000000000000000000000;;			raw = z.startTagIn("iframe")
0000000000000000000000000000000000000000;;		case 'n':
0000000000000000000000000000000000000000;;			raw = z.startTagIn("noembed", "noframes", "noscript")
0000000000000000000000000000000000000000;;		case 'p':
0000000000000000000000000000000000000000;;			raw = z.startTagIn("plaintext")
0000000000000000000000000000000000000000;;		case 's':
0000000000000000000000000000000000000000;;			raw = z.startTagIn("script", "style")
0000000000000000000000000000000000000000;;		case 't':
0000000000000000000000000000000000000000;;			raw = z.startTagIn("textarea", "title")
0000000000000000000000000000000000000000;;		case 'x':
0000000000000000000000000000000000000000;;			raw = z.startTagIn("xmp")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if raw {
0000000000000000000000000000000000000000;;			z.rawTag = strings.ToLower(string(z.buf[z.data.start:z.data.end]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Look for a self-closing token like "<br/>".
0000000000000000000000000000000000000000;;		if z.err == nil && z.buf[z.raw.end-2] == '/' {
0000000000000000000000000000000000000000;;			return SelfClosingTagToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return StartTagToken
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readTag reads the next tag token and its attributes. If saveAttr, those
0000000000000000000000000000000000000000;;	// attributes are saved in z.attr, otherwise z.attr is set to an empty slice.
0000000000000000000000000000000000000000;;	// The opening "<a" or "</a" has already been consumed, where 'a' means anything
0000000000000000000000000000000000000000;;	// in [A-Za-z].
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readTag(saveAttr bool) {
0000000000000000000000000000000000000000;;		z.attr = z.attr[:0]
0000000000000000000000000000000000000000;;		z.nAttrReturned = 0
0000000000000000000000000000000000000000;;		// Read the tag name and attribute key/value pairs.
0000000000000000000000000000000000000000;;		z.readTagName()
0000000000000000000000000000000000000000;;		if z.skipWhiteSpace(); z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil || c == '>' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			z.raw.end--
0000000000000000000000000000000000000000;;			z.readTagAttrKey()
0000000000000000000000000000000000000000;;			z.readTagAttrVal()
0000000000000000000000000000000000000000;;			// Save pendingAttr if saveAttr and that attribute has a non-empty key.
0000000000000000000000000000000000000000;;			if saveAttr && z.pendingAttr[0].start != z.pendingAttr[0].end {
0000000000000000000000000000000000000000;;				z.attr = append(z.attr, z.pendingAttr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if z.skipWhiteSpace(); z.err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readTagName sets z.data to the "div" in "<div k=v>". The reader (z.raw.end)
0000000000000000000000000000000000000000;;	// is positioned such that the first byte of the tag name (the "d" in "<div")
0000000000000000000000000000000000000000;;	// has already been consumed.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readTagName() {
0000000000000000000000000000000000000000;;		z.data.start = z.raw.end - 1
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case ' ', '\n', '\r', '\t', '\f':
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end - 1
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case '/', '>':
0000000000000000000000000000000000000000;;				z.raw.end--
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readTagAttrKey sets z.pendingAttr[0] to the "k" in "<div k=v>".
0000000000000000000000000000000000000000;;	// Precondition: z.err == nil.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readTagAttrKey() {
0000000000000000000000000000000000000000;;		z.pendingAttr[0].start = z.raw.end
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				z.pendingAttr[0].end = z.raw.end
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case ' ', '\n', '\r', '\t', '\f', '/':
0000000000000000000000000000000000000000;;				z.pendingAttr[0].end = z.raw.end - 1
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case '=', '>':
0000000000000000000000000000000000000000;;				z.raw.end--
0000000000000000000000000000000000000000;;				z.pendingAttr[0].end = z.raw.end
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readTagAttrVal sets z.pendingAttr[1] to the "v" in "<div k=v>".
0000000000000000000000000000000000000000;;	func (z *Tokenizer) readTagAttrVal() {
0000000000000000000000000000000000000000;;		z.pendingAttr[1].start = z.raw.end
0000000000000000000000000000000000000000;;		z.pendingAttr[1].end = z.raw.end
0000000000000000000000000000000000000000;;		if z.skipWhiteSpace(); z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c != '=' {
0000000000000000000000000000000000000000;;			z.raw.end--
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if z.skipWhiteSpace(); z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		quote := z.readByte()
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch quote {
0000000000000000000000000000000000000000;;		case '>':
0000000000000000000000000000000000000000;;			z.raw.end--
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case '\'', '"':
0000000000000000000000000000000000000000;;			z.pendingAttr[1].start = z.raw.end
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				c := z.readByte()
0000000000000000000000000000000000000000;;				if z.err != nil {
0000000000000000000000000000000000000000;;					z.pendingAttr[1].end = z.raw.end
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c == quote {
0000000000000000000000000000000000000000;;					z.pendingAttr[1].end = z.raw.end - 1
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			z.pendingAttr[1].start = z.raw.end - 1
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				c := z.readByte()
0000000000000000000000000000000000000000;;				if z.err != nil {
0000000000000000000000000000000000000000;;					z.pendingAttr[1].end = z.raw.end
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch c {
0000000000000000000000000000000000000000;;				case ' ', '\n', '\r', '\t', '\f':
0000000000000000000000000000000000000000;;					z.pendingAttr[1].end = z.raw.end - 1
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				case '>':
0000000000000000000000000000000000000000;;					z.raw.end--
0000000000000000000000000000000000000000;;					z.pendingAttr[1].end = z.raw.end
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Next scans the next token and returns its type.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) Next() TokenType {
0000000000000000000000000000000000000000;;		z.raw.start = z.raw.end
0000000000000000000000000000000000000000;;		z.data.start = z.raw.end
0000000000000000000000000000000000000000;;		z.data.end = z.raw.end
0000000000000000000000000000000000000000;;		if z.err != nil {
0000000000000000000000000000000000000000;;			z.tt = ErrorToken
0000000000000000000000000000000000000000;;			return z.tt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if z.rawTag != "" {
0000000000000000000000000000000000000000;;			if z.rawTag == "plaintext" {
0000000000000000000000000000000000000000;;				// Read everything up to EOF.
0000000000000000000000000000000000000000;;				for z.err == nil {
0000000000000000000000000000000000000000;;					z.readByte()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end
0000000000000000000000000000000000000000;;				z.textIsRaw = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				z.readRawOrRCDATA()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if z.data.end > z.data.start {
0000000000000000000000000000000000000000;;				z.tt = TextToken
0000000000000000000000000000000000000000;;				z.convertNUL = true
0000000000000000000000000000000000000000;;				return z.tt
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.textIsRaw = false
0000000000000000000000000000000000000000;;		z.convertNUL = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c := z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != '<' {
0000000000000000000000000000000000000000;;				continue loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check if the '<' we have just read is part of a tag, comment
0000000000000000000000000000000000000000;;			// or doctype. If not, it's part of the accumulated text token.
0000000000000000000000000000000000000000;;			c = z.readByte()
0000000000000000000000000000000000000000;;			if z.err != nil {
0000000000000000000000000000000000000000;;				break loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var tokenType TokenType
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z':
0000000000000000000000000000000000000000;;				tokenType = StartTagToken
0000000000000000000000000000000000000000;;			case c == '/':
0000000000000000000000000000000000000000;;				tokenType = EndTagToken
0000000000000000000000000000000000000000;;			case c == '!' || c == '?':
0000000000000000000000000000000000000000;;				// We use CommentToken to mean any of "<!--actual comments-->",
0000000000000000000000000000000000000000;;				// "<!DOCTYPE declarations>" and "<?xml processing instructions?>".
0000000000000000000000000000000000000000;;				tokenType = CommentToken
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// Reconsume the current character.
0000000000000000000000000000000000000000;;				z.raw.end--
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We have a non-text token, but we might have accumulated some text
0000000000000000000000000000000000000000;;			// before that. If so, we return the text first, and return the non-
0000000000000000000000000000000000000000;;			// text token on the subsequent call to Next.
0000000000000000000000000000000000000000;;			if x := z.raw.end - len("<a"); z.raw.start < x {
0000000000000000000000000000000000000000;;				z.raw.end = x
0000000000000000000000000000000000000000;;				z.data.end = x
0000000000000000000000000000000000000000;;				z.tt = TextToken
0000000000000000000000000000000000000000;;				return z.tt
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch tokenType {
0000000000000000000000000000000000000000;;			case StartTagToken:
0000000000000000000000000000000000000000;;				z.tt = z.readStartTag()
0000000000000000000000000000000000000000;;				return z.tt
0000000000000000000000000000000000000000;;			case EndTagToken:
0000000000000000000000000000000000000000;;				c = z.readByte()
0000000000000000000000000000000000000000;;				if z.err != nil {
0000000000000000000000000000000000000000;;					break loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c == '>' {
0000000000000000000000000000000000000000;;					// "</>" does not generate a token at all. Generate an empty comment
0000000000000000000000000000000000000000;;					// to allow passthrough clients to pick up the data using Raw.
0000000000000000000000000000000000000000;;					// Reset the tokenizer state and start again.
0000000000000000000000000000000000000000;;					z.tt = CommentToken
0000000000000000000000000000000000000000;;					return z.tt
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' {
0000000000000000000000000000000000000000;;					z.readTag(false)
0000000000000000000000000000000000000000;;					if z.err != nil {
0000000000000000000000000000000000000000;;						z.tt = ErrorToken
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						z.tt = EndTagToken
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return z.tt
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				z.raw.end--
0000000000000000000000000000000000000000;;				z.readUntilCloseAngle()
0000000000000000000000000000000000000000;;				z.tt = CommentToken
0000000000000000000000000000000000000000;;				return z.tt
0000000000000000000000000000000000000000;;			case CommentToken:
0000000000000000000000000000000000000000;;				if c == '!' {
0000000000000000000000000000000000000000;;					z.tt = z.readMarkupDeclaration()
0000000000000000000000000000000000000000;;					return z.tt
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				z.raw.end--
0000000000000000000000000000000000000000;;				z.readUntilCloseAngle()
0000000000000000000000000000000000000000;;				z.tt = CommentToken
0000000000000000000000000000000000000000;;				return z.tt
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if z.raw.start < z.raw.end {
0000000000000000000000000000000000000000;;			z.data.end = z.raw.end
0000000000000000000000000000000000000000;;			z.tt = TextToken
0000000000000000000000000000000000000000;;			return z.tt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.tt = ErrorToken
0000000000000000000000000000000000000000;;		return z.tt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Raw returns the unmodified text of the current token. Calling Next, Token,
0000000000000000000000000000000000000000;;	// Text, TagName or TagAttr may change the contents of the returned slice.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) Raw() []byte {
0000000000000000000000000000000000000000;;		return z.buf[z.raw.start:z.raw.end]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertNewlines converts "\r" and "\r\n" in s to "\n".
0000000000000000000000000000000000000000;;	// The conversion happens in place, but the resulting slice may be shorter.
0000000000000000000000000000000000000000;;	func convertNewlines(s []byte) []byte {
0000000000000000000000000000000000000000;;		for i, c := range s {
0000000000000000000000000000000000000000;;			if c != '\r' {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			src := i + 1
0000000000000000000000000000000000000000;;			if src >= len(s) || s[src] != '\n' {
0000000000000000000000000000000000000000;;				s[i] = '\n'
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dst := i
0000000000000000000000000000000000000000;;			for src < len(s) {
0000000000000000000000000000000000000000;;				if s[src] == '\r' {
0000000000000000000000000000000000000000;;					if src+1 < len(s) && s[src+1] == '\n' {
0000000000000000000000000000000000000000;;						src++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					s[dst] = '\n'
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					s[dst] = s[src]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				src++
0000000000000000000000000000000000000000;;				dst++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s[:dst]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		nul         = []byte("\x00")
0000000000000000000000000000000000000000;;		replacement = []byte("\ufffd")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Text returns the unescaped text of a text, comment or doctype token. The
0000000000000000000000000000000000000000;;	// contents of the returned slice may change on the next call to Next.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) Text() []byte {
0000000000000000000000000000000000000000;;		switch z.tt {
0000000000000000000000000000000000000000;;		case TextToken, CommentToken, DoctypeToken:
0000000000000000000000000000000000000000;;			s := z.buf[z.data.start:z.data.end]
0000000000000000000000000000000000000000;;			z.data.start = z.raw.end
0000000000000000000000000000000000000000;;			z.data.end = z.raw.end
0000000000000000000000000000000000000000;;			s = convertNewlines(s)
0000000000000000000000000000000000000000;;			if (z.convertNUL || z.tt == CommentToken) && bytes.Contains(s, nul) {
0000000000000000000000000000000000000000;;				s = bytes.Replace(s, nul, replacement, -1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !z.textIsRaw {
0000000000000000000000000000000000000000;;				s = unescape(s, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TagName returns the lower-cased name of a tag token (the `img` out of
0000000000000000000000000000000000000000;;	// `<IMG SRC="foo">`) and whether the tag has attributes.
0000000000000000000000000000000000000000;;	// The contents of the returned slice may change on the next call to Next.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) TagName() (name []byte, hasAttr bool) {
0000000000000000000000000000000000000000;;		if z.data.start < z.data.end {
0000000000000000000000000000000000000000;;			switch z.tt {
0000000000000000000000000000000000000000;;			case StartTagToken, EndTagToken, SelfClosingTagToken:
0000000000000000000000000000000000000000;;				s := z.buf[z.data.start:z.data.end]
0000000000000000000000000000000000000000;;				z.data.start = z.raw.end
0000000000000000000000000000000000000000;;				z.data.end = z.raw.end
0000000000000000000000000000000000000000;;				return lower(s), z.nAttrReturned < len(z.attr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TagAttr returns the lower-cased key and unescaped value of the next unparsed
0000000000000000000000000000000000000000;;	// attribute for the current tag token and whether there are more attributes.
0000000000000000000000000000000000000000;;	// The contents of the returned slices may change on the next call to Next.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) TagAttr() (key, val []byte, moreAttr bool) {
0000000000000000000000000000000000000000;;		if z.nAttrReturned < len(z.attr) {
0000000000000000000000000000000000000000;;			switch z.tt {
0000000000000000000000000000000000000000;;			case StartTagToken, SelfClosingTagToken:
0000000000000000000000000000000000000000;;				x := z.attr[z.nAttrReturned]
0000000000000000000000000000000000000000;;				z.nAttrReturned++
0000000000000000000000000000000000000000;;				key = z.buf[x[0].start:x[0].end]
0000000000000000000000000000000000000000;;				val = z.buf[x[1].start:x[1].end]
0000000000000000000000000000000000000000;;				return lower(key), unescape(convertNewlines(val), true), z.nAttrReturned < len(z.attr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token returns the next Token. The result's Data and Attr values remain valid
0000000000000000000000000000000000000000;;	// after subsequent Next calls.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) Token() Token {
0000000000000000000000000000000000000000;;		t := Token{Type: z.tt}
0000000000000000000000000000000000000000;;		switch z.tt {
0000000000000000000000000000000000000000;;		case TextToken, CommentToken, DoctypeToken:
0000000000000000000000000000000000000000;;			t.Data = string(z.Text())
0000000000000000000000000000000000000000;;		case StartTagToken, SelfClosingTagToken, EndTagToken:
0000000000000000000000000000000000000000;;			name, moreAttr := z.TagName()
0000000000000000000000000000000000000000;;			for moreAttr {
0000000000000000000000000000000000000000;;				var key, val []byte
0000000000000000000000000000000000000000;;				key, val, moreAttr = z.TagAttr()
0000000000000000000000000000000000000000;;				t.Attr = append(t.Attr, Attribute{"", atom.String(key), string(val)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if a := atom.Lookup(name); a != 0 {
0000000000000000000000000000000000000000;;				t.DataAtom, t.Data = a, a.String()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.DataAtom, t.Data = 0, string(name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMaxBuf sets a limit on the amount of data buffered during tokenization.
0000000000000000000000000000000000000000;;	// A value of 0 means unlimited.
0000000000000000000000000000000000000000;;	func (z *Tokenizer) SetMaxBuf(n int) {
0000000000000000000000000000000000000000;;		z.maxBuf = n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTokenizer returns a new HTML Tokenizer for the given Reader.
0000000000000000000000000000000000000000;;	// The input is assumed to be UTF-8 encoded.
0000000000000000000000000000000000000000;;	func NewTokenizer(r io.Reader) *Tokenizer {
0000000000000000000000000000000000000000;;		return NewTokenizerFragment(r, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTokenizerFragment returns a new HTML Tokenizer for the given Reader, for
0000000000000000000000000000000000000000;;	// tokenizing an existing element's InnerHTML fragment. contextTag is that
0000000000000000000000000000000000000000;;	// element's tag, such as "div" or "iframe".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example, how the InnerHTML "a<b" is tokenized depends on whether it is
0000000000000000000000000000000000000000;;	// for a <p> tag or a <script> tag.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The input is assumed to be UTF-8 encoded.
0000000000000000000000000000000000000000;;	func NewTokenizerFragment(r io.Reader, contextTag string) *Tokenizer {
0000000000000000000000000000000000000000;;		z := &Tokenizer{
0000000000000000000000000000000000000000;;			r:   r,
0000000000000000000000000000000000000000;;			buf: make([]byte, 0, 4096),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if contextTag != "" {
0000000000000000000000000000000000000000;;			switch s := strings.ToLower(contextTag); s {
0000000000000000000000000000000000000000;;			case "iframe", "noembed", "noframes", "noscript", "plaintext", "script", "style", "title", "textarea", "xmp":
0000000000000000000000000000000000000000;;				z.rawTag = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return z
0000000000000000000000000000000000000000;;	}
