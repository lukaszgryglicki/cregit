0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
c2bfd044362efe23765620d054edcdab7497bde5;third_party/src/code.google.com/p/go.net/html/parse.go[third_party/src/code.google.com/p/go.net/html/parse.go][vendor/golang.org/x/net/html/parse.go];	
0000000000000000000000000000000000000000;;	package html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a "golang.org/x/net/html/atom"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A parser implements the HTML5 parsing algorithm:
0000000000000000000000000000000000000000;;	// https://html.spec.whatwg.org/multipage/syntax.html#tree-construction
0000000000000000000000000000000000000000;;	type parser struct {
0000000000000000000000000000000000000000;;		// tokenizer provides the tokens for the parser.
0000000000000000000000000000000000000000;;		tokenizer *Tokenizer
0000000000000000000000000000000000000000;;		// tok is the most recently read token.
0000000000000000000000000000000000000000;;		tok Token
0000000000000000000000000000000000000000;;		// Self-closing tags like <hr/> are treated as start tags, except that
0000000000000000000000000000000000000000;;		// hasSelfClosingToken is set while they are being processed.
0000000000000000000000000000000000000000;;		hasSelfClosingToken bool
0000000000000000000000000000000000000000;;		// doc is the document root element.
0000000000000000000000000000000000000000;;		doc *Node
0000000000000000000000000000000000000000;;		// The stack of open elements (section 12.2.3.2) and active formatting
0000000000000000000000000000000000000000;;		// elements (section 12.2.3.3).
0000000000000000000000000000000000000000;;		oe, afe nodeStack
0000000000000000000000000000000000000000;;		// Element pointers (section 12.2.3.4).
0000000000000000000000000000000000000000;;		head, form *Node
0000000000000000000000000000000000000000;;		// Other parsing state flags (section 12.2.3.5).
0000000000000000000000000000000000000000;;		scripting, framesetOK bool
0000000000000000000000000000000000000000;;		// im is the current insertion mode.
0000000000000000000000000000000000000000;;		im insertionMode
0000000000000000000000000000000000000000;;		// originalIM is the insertion mode to go back to after completing a text
0000000000000000000000000000000000000000;;		// or inTableText insertion mode.
0000000000000000000000000000000000000000;;		originalIM insertionMode
0000000000000000000000000000000000000000;;		// fosterParenting is whether new elements should be inserted according to
0000000000000000000000000000000000000000;;		// the foster parenting rules (section 12.2.5.3).
0000000000000000000000000000000000000000;;		fosterParenting bool
0000000000000000000000000000000000000000;;		// quirks is whether the parser is operating in "quirks mode."
0000000000000000000000000000000000000000;;		quirks bool
0000000000000000000000000000000000000000;;		// fragment is whether the parser is parsing an HTML fragment.
0000000000000000000000000000000000000000;;		fragment bool
0000000000000000000000000000000000000000;;		// context is the context element when parsing an HTML fragment
0000000000000000000000000000000000000000;;		// (section 12.4).
0000000000000000000000000000000000000000;;		context *Node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) top() *Node {
0000000000000000000000000000000000000000;;		if n := p.oe.top(); n != nil {
0000000000000000000000000000000000000000;;			return n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.doc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop tags for use in popUntil. These come from section 12.2.3.2.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		defaultScopeStopTags = map[string][]a.Atom{
0000000000000000000000000000000000000000;;			"":     {a.Applet, a.Caption, a.Html, a.Table, a.Td, a.Th, a.Marquee, a.Object, a.Template},
0000000000000000000000000000000000000000;;			"math": {a.AnnotationXml, a.Mi, a.Mn, a.Mo, a.Ms, a.Mtext},
0000000000000000000000000000000000000000;;			"svg":  {a.Desc, a.ForeignObject, a.Title},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type scope int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultScope scope = iota
0000000000000000000000000000000000000000;;		listItemScope
0000000000000000000000000000000000000000;;		buttonScope
0000000000000000000000000000000000000000;;		tableScope
0000000000000000000000000000000000000000;;		tableRowScope
0000000000000000000000000000000000000000;;		tableBodyScope
0000000000000000000000000000000000000000;;		selectScope
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// popUntil pops the stack of open elements at the highest element whose tag
0000000000000000000000000000000000000000;;	// is in matchTags, provided there is no higher element in the scope's stop
0000000000000000000000000000000000000000;;	// tags (as defined in section 12.2.3.2). It returns whether or not there was
0000000000000000000000000000000000000000;;	// such an element. If there was not, popUntil leaves the stack unchanged.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example, the set of stop tags for table scope is: "html", "table". If
0000000000000000000000000000000000000000;;	// the stack was:
0000000000000000000000000000000000000000;;	// ["html", "body", "font", "table", "b", "i", "u"]
0000000000000000000000000000000000000000;;	// then popUntil(tableScope, "font") would return false, but
0000000000000000000000000000000000000000;;	// popUntil(tableScope, "i") would return true and the stack would become:
0000000000000000000000000000000000000000;;	// ["html", "body", "font", "table", "b"]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If an element's tag is in both the stop tags and matchTags, then the stack
0000000000000000000000000000000000000000;;	// will be popped and the function returns true (provided, of course, there was
0000000000000000000000000000000000000000;;	// no higher element in the stack that was also in the stop tags). For example,
0000000000000000000000000000000000000000;;	// popUntil(tableScope, "table") returns true and leaves:
0000000000000000000000000000000000000000;;	// ["html", "body", "font"]
0000000000000000000000000000000000000000;;	func (p *parser) popUntil(s scope, matchTags ...a.Atom) bool {
0000000000000000000000000000000000000000;;		if i := p.indexOfElementInScope(s, matchTags...); i != -1 {
0000000000000000000000000000000000000000;;			p.oe = p.oe[:i]
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// indexOfElementInScope returns the index in p.oe of the highest element whose
0000000000000000000000000000000000000000;;	// tag is in matchTags that is in scope. If no matching element is in scope, it
0000000000000000000000000000000000000000;;	// returns -1.
0000000000000000000000000000000000000000;;	func (p *parser) indexOfElementInScope(s scope, matchTags ...a.Atom) int {
0000000000000000000000000000000000000000;;		for i := len(p.oe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			tagAtom := p.oe[i].DataAtom
0000000000000000000000000000000000000000;;			if p.oe[i].Namespace == "" {
0000000000000000000000000000000000000000;;				for _, t := range matchTags {
0000000000000000000000000000000000000000;;					if t == tagAtom {
0000000000000000000000000000000000000000;;						return i
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch s {
0000000000000000000000000000000000000000;;				case defaultScope:
0000000000000000000000000000000000000000;;					// No-op.
0000000000000000000000000000000000000000;;				case listItemScope:
0000000000000000000000000000000000000000;;					if tagAtom == a.Ol || tagAtom == a.Ul {
0000000000000000000000000000000000000000;;						return -1
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case buttonScope:
0000000000000000000000000000000000000000;;					if tagAtom == a.Button {
0000000000000000000000000000000000000000;;						return -1
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case tableScope:
0000000000000000000000000000000000000000;;					if tagAtom == a.Html || tagAtom == a.Table {
0000000000000000000000000000000000000000;;						return -1
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case selectScope:
0000000000000000000000000000000000000000;;					if tagAtom != a.Optgroup && tagAtom != a.Option {
0000000000000000000000000000000000000000;;						return -1
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					panic("unreachable")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch s {
0000000000000000000000000000000000000000;;			case defaultScope, listItemScope, buttonScope:
0000000000000000000000000000000000000000;;				for _, t := range defaultScopeStopTags[p.oe[i].Namespace] {
0000000000000000000000000000000000000000;;					if t == tagAtom {
0000000000000000000000000000000000000000;;						return -1
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// elementInScope is like popUntil, except that it doesn't modify the stack of
0000000000000000000000000000000000000000;;	// open elements.
0000000000000000000000000000000000000000;;	func (p *parser) elementInScope(s scope, matchTags ...a.Atom) bool {
0000000000000000000000000000000000000000;;		return p.indexOfElementInScope(s, matchTags...) != -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clearStackToContext pops elements off the stack of open elements until a
0000000000000000000000000000000000000000;;	// scope-defined element is found.
0000000000000000000000000000000000000000;;	func (p *parser) clearStackToContext(s scope) {
0000000000000000000000000000000000000000;;		for i := len(p.oe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			tagAtom := p.oe[i].DataAtom
0000000000000000000000000000000000000000;;			switch s {
0000000000000000000000000000000000000000;;			case tableScope:
0000000000000000000000000000000000000000;;				if tagAtom == a.Html || tagAtom == a.Table {
0000000000000000000000000000000000000000;;					p.oe = p.oe[:i+1]
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case tableRowScope:
0000000000000000000000000000000000000000;;				if tagAtom == a.Html || tagAtom == a.Tr {
0000000000000000000000000000000000000000;;					p.oe = p.oe[:i+1]
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case tableBodyScope:
0000000000000000000000000000000000000000;;				if tagAtom == a.Html || tagAtom == a.Tbody || tagAtom == a.Tfoot || tagAtom == a.Thead {
0000000000000000000000000000000000000000;;					p.oe = p.oe[:i+1]
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("unreachable")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateImpliedEndTags pops nodes off the stack of open elements as long as
0000000000000000000000000000000000000000;;	// the top node has a tag name of dd, dt, li, option, optgroup, p, rp, or rt.
0000000000000000000000000000000000000000;;	// If exceptions are specified, nodes with that name will not be popped off.
0000000000000000000000000000000000000000;;	func (p *parser) generateImpliedEndTags(exceptions ...string) {
0000000000000000000000000000000000000000;;		var i int
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for i = len(p.oe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			n := p.oe[i]
0000000000000000000000000000000000000000;;			if n.Type == ElementNode {
0000000000000000000000000000000000000000;;				switch n.DataAtom {
0000000000000000000000000000000000000000;;				case a.Dd, a.Dt, a.Li, a.Option, a.Optgroup, a.P, a.Rp, a.Rt:
0000000000000000000000000000000000000000;;					for _, except := range exceptions {
0000000000000000000000000000000000000000;;						if n.Data == except {
0000000000000000000000000000000000000000;;							break loop
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.oe = p.oe[:i+1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addChild adds a child node n to the top element, and pushes n onto the stack
0000000000000000000000000000000000000000;;	// of open elements if it is an element node.
0000000000000000000000000000000000000000;;	func (p *parser) addChild(n *Node) {
0000000000000000000000000000000000000000;;		if p.shouldFosterParent() {
0000000000000000000000000000000000000000;;			p.fosterParent(n)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.top().AppendChild(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n.Type == ElementNode {
0000000000000000000000000000000000000000;;			p.oe = append(p.oe, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldFosterParent returns whether the next node to be added should be
0000000000000000000000000000000000000000;;	// foster parented.
0000000000000000000000000000000000000000;;	func (p *parser) shouldFosterParent() bool {
0000000000000000000000000000000000000000;;		if p.fosterParenting {
0000000000000000000000000000000000000000;;			switch p.top().DataAtom {
0000000000000000000000000000000000000000;;			case a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fosterParent adds a child node according to the foster parenting rules.
0000000000000000000000000000000000000000;;	// Section 12.2.5.3, "foster parenting".
0000000000000000000000000000000000000000;;	func (p *parser) fosterParent(n *Node) {
0000000000000000000000000000000000000000;;		var table, parent, prev *Node
0000000000000000000000000000000000000000;;		var i int
0000000000000000000000000000000000000000;;		for i = len(p.oe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			if p.oe[i].DataAtom == a.Table {
0000000000000000000000000000000000000000;;				table = p.oe[i]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if table == nil {
0000000000000000000000000000000000000000;;			// The foster parent is the html element.
0000000000000000000000000000000000000000;;			parent = p.oe[0]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			parent = table.Parent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parent == nil {
0000000000000000000000000000000000000000;;			parent = p.oe[i-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if table != nil {
0000000000000000000000000000000000000000;;			prev = table.PrevSibling
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			prev = parent.LastChild
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if prev != nil && prev.Type == TextNode && n.Type == TextNode {
0000000000000000000000000000000000000000;;			prev.Data += n.Data
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parent.InsertBefore(n, table)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addText adds text to the preceding node if it is a text node, or else it
0000000000000000000000000000000000000000;;	// calls addChild with a new text node.
0000000000000000000000000000000000000000;;	func (p *parser) addText(text string) {
0000000000000000000000000000000000000000;;		if text == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.shouldFosterParent() {
0000000000000000000000000000000000000000;;			p.fosterParent(&Node{
0000000000000000000000000000000000000000;;				Type: TextNode,
0000000000000000000000000000000000000000;;				Data: text,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := p.top()
0000000000000000000000000000000000000000;;		if n := t.LastChild; n != nil && n.Type == TextNode {
0000000000000000000000000000000000000000;;			n.Data += text
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.addChild(&Node{
0000000000000000000000000000000000000000;;			Type: TextNode,
0000000000000000000000000000000000000000;;			Data: text,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addElement adds a child element based on the current token.
0000000000000000000000000000000000000000;;	func (p *parser) addElement() {
0000000000000000000000000000000000000000;;		p.addChild(&Node{
0000000000000000000000000000000000000000;;			Type:     ElementNode,
0000000000000000000000000000000000000000;;			DataAtom: p.tok.DataAtom,
0000000000000000000000000000000000000000;;			Data:     p.tok.Data,
0000000000000000000000000000000000000000;;			Attr:     p.tok.Attr,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.3.3.
0000000000000000000000000000000000000000;;	func (p *parser) addFormattingElement() {
0000000000000000000000000000000000000000;;		tagAtom, attr := p.tok.DataAtom, p.tok.Attr
0000000000000000000000000000000000000000;;		p.addElement()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Implement the Noah's Ark clause, but with three per family instead of two.
0000000000000000000000000000000000000000;;		identicalElements := 0
0000000000000000000000000000000000000000;;	findIdenticalElements:
0000000000000000000000000000000000000000;;		for i := len(p.afe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			n := p.afe[i]
0000000000000000000000000000000000000000;;			if n.Type == scopeMarkerNode {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n.Type != ElementNode {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n.Namespace != "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n.DataAtom != tagAtom {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(n.Attr) != len(attr) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		compareAttributes:
0000000000000000000000000000000000000000;;			for _, t0 := range n.Attr {
0000000000000000000000000000000000000000;;				for _, t1 := range attr {
0000000000000000000000000000000000000000;;					if t0.Key == t1.Key && t0.Namespace == t1.Namespace && t0.Val == t1.Val {
0000000000000000000000000000000000000000;;						// Found a match for this attribute, continue with the next attribute.
0000000000000000000000000000000000000000;;						continue compareAttributes
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If we get here, there is no attribute that matches a.
0000000000000000000000000000000000000000;;				// Therefore the element is not identical to the new one.
0000000000000000000000000000000000000000;;				continue findIdenticalElements
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			identicalElements++
0000000000000000000000000000000000000000;;			if identicalElements >= 3 {
0000000000000000000000000000000000000000;;				p.afe.remove(n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.afe = append(p.afe, p.top())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.3.3.
0000000000000000000000000000000000000000;;	func (p *parser) clearActiveFormattingElements() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n := p.afe.pop()
0000000000000000000000000000000000000000;;			if len(p.afe) == 0 || n.Type == scopeMarkerNode {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.3.3.
0000000000000000000000000000000000000000;;	func (p *parser) reconstructActiveFormattingElements() {
0000000000000000000000000000000000000000;;		n := p.afe.top()
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.Type == scopeMarkerNode || p.oe.index(n) != -1 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := len(p.afe) - 1
0000000000000000000000000000000000000000;;		for n.Type != scopeMarkerNode && p.oe.index(n) == -1 {
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				i = -1
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i--
0000000000000000000000000000000000000000;;			n = p.afe[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			clone := p.afe[i].clone()
0000000000000000000000000000000000000000;;			p.addChild(clone)
0000000000000000000000000000000000000000;;			p.afe[i] = clone
0000000000000000000000000000000000000000;;			if i == len(p.afe)-1 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.4.
0000000000000000000000000000000000000000;;	func (p *parser) acknowledgeSelfClosingTag() {
0000000000000000000000000000000000000000;;		p.hasSelfClosingToken = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An insertion mode (section 12.2.3.1) is the state transition function from
0000000000000000000000000000000000000000;;	// a particular state in the HTML5 parser's state machine. It updates the
0000000000000000000000000000000000000000;;	// parser's fields depending on parser.tok (where ErrorToken means EOF).
0000000000000000000000000000000000000000;;	// It returns whether the token was consumed.
0000000000000000000000000000000000000000;;	type insertionMode func(*parser) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setOriginalIM sets the insertion mode to return to after completing a text or
0000000000000000000000000000000000000000;;	// inTableText insertion mode.
0000000000000000000000000000000000000000;;	// Section 12.2.3.1, "using the rules for".
0000000000000000000000000000000000000000;;	func (p *parser) setOriginalIM() {
0000000000000000000000000000000000000000;;		if p.originalIM != nil {
0000000000000000000000000000000000000000;;			panic("html: bad parser state: originalIM was set twice")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.originalIM = p.im
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.3.1, "reset the insertion mode".
0000000000000000000000000000000000000000;;	func (p *parser) resetInsertionMode() {
0000000000000000000000000000000000000000;;		for i := len(p.oe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			n := p.oe[i]
0000000000000000000000000000000000000000;;			if i == 0 && p.context != nil {
0000000000000000000000000000000000000000;;				n = p.context
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch n.DataAtom {
0000000000000000000000000000000000000000;;			case a.Select:
0000000000000000000000000000000000000000;;				p.im = inSelectIM
0000000000000000000000000000000000000000;;			case a.Td, a.Th:
0000000000000000000000000000000000000000;;				p.im = inCellIM
0000000000000000000000000000000000000000;;			case a.Tr:
0000000000000000000000000000000000000000;;				p.im = inRowIM
0000000000000000000000000000000000000000;;			case a.Tbody, a.Thead, a.Tfoot:
0000000000000000000000000000000000000000;;				p.im = inTableBodyIM
0000000000000000000000000000000000000000;;			case a.Caption:
0000000000000000000000000000000000000000;;				p.im = inCaptionIM
0000000000000000000000000000000000000000;;			case a.Colgroup:
0000000000000000000000000000000000000000;;				p.im = inColumnGroupIM
0000000000000000000000000000000000000000;;			case a.Table:
0000000000000000000000000000000000000000;;				p.im = inTableIM
0000000000000000000000000000000000000000;;			case a.Head:
0000000000000000000000000000000000000000;;				p.im = inBodyIM
0000000000000000000000000000000000000000;;			case a.Body:
0000000000000000000000000000000000000000;;				p.im = inBodyIM
0000000000000000000000000000000000000000;;			case a.Frameset:
0000000000000000000000000000000000000000;;				p.im = inFramesetIM
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				p.im = beforeHeadIM
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.im = inBodyIM
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const whitespace = " \t\r\n\f"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.1.
0000000000000000000000000000000000000000;;	func initialIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			p.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)
0000000000000000000000000000000000000000;;			if len(p.tok.Data) == 0 {
0000000000000000000000000000000000000000;;				// It was all whitespace, so ignore it.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.doc.AppendChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			n, quirks := parseDoctype(p.tok.Data)
0000000000000000000000000000000000000000;;			p.doc.AppendChild(n)
0000000000000000000000000000000000000000;;			p.quirks = quirks
0000000000000000000000000000000000000000;;			p.im = beforeHTMLIM
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.quirks = true
0000000000000000000000000000000000000000;;		p.im = beforeHTMLIM
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.2.
0000000000000000000000000000000000000000;;	func beforeHTMLIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			p.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)
0000000000000000000000000000000000000000;;			if len(p.tok.Data) == 0 {
0000000000000000000000000000000000000000;;				// It was all whitespace, so ignore it.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			if p.tok.DataAtom == a.Html {
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.im = beforeHeadIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Head, a.Body, a.Html, a.Br:
0000000000000000000000000000000000000000;;				p.parseImpliedToken(StartTagToken, a.Html, a.Html.String())
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.doc.AppendChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.parseImpliedToken(StartTagToken, a.Html, a.Html.String())
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.3.
0000000000000000000000000000000000000000;;	func beforeHeadIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			p.tok.Data = strings.TrimLeft(p.tok.Data, whitespace)
0000000000000000000000000000000000000000;;			if len(p.tok.Data) == 0 {
0000000000000000000000000000000000000000;;				// It was all whitespace, so ignore it.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Head:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.head = p.top()
0000000000000000000000000000000000000000;;				p.im = inHeadIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Head, a.Body, a.Html, a.Br:
0000000000000000000000000000000000000000;;				p.parseImpliedToken(StartTagToken, a.Head, a.Head.String())
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.parseImpliedToken(StartTagToken, a.Head, a.Head.String())
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.4.
0000000000000000000000000000000000000000;;	func inHeadIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			s := strings.TrimLeft(p.tok.Data, whitespace)
0000000000000000000000000000000000000000;;			if len(s) < len(p.tok.Data) {
0000000000000000000000000000000000000000;;				// Add the initial whitespace to the current node.
0000000000000000000000000000000000000000;;				p.addText(p.tok.Data[:len(p.tok.Data)-len(s)])
0000000000000000000000000000000000000000;;				if s == "" {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.tok.Data = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			case a.Base, a.Basefont, a.Bgsound, a.Command, a.Link, a.Meta:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.oe.pop()
0000000000000000000000000000000000000000;;				p.acknowledgeSelfClosingTag()
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Script, a.Title, a.Noscript, a.Noframes, a.Style:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.setOriginalIM()
0000000000000000000000000000000000000000;;				p.im = textIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Head:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Head:
0000000000000000000000000000000000000000;;				n := p.oe.pop()
0000000000000000000000000000000000000000;;				if n.DataAtom != a.Head {
0000000000000000000000000000000000000000;;					panic("html: bad parser state: <head> element not found, in the in-head insertion mode")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.im = afterHeadIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Body, a.Html, a.Br:
0000000000000000000000000000000000000000;;				p.parseImpliedToken(EndTagToken, a.Head, a.Head.String())
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.parseImpliedToken(EndTagToken, a.Head, a.Head.String())
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.6.
0000000000000000000000000000000000000000;;	func afterHeadIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			s := strings.TrimLeft(p.tok.Data, whitespace)
0000000000000000000000000000000000000000;;			if len(s) < len(p.tok.Data) {
0000000000000000000000000000000000000000;;				// Add the initial whitespace to the current node.
0000000000000000000000000000000000000000;;				p.addText(p.tok.Data[:len(p.tok.Data)-len(s)])
0000000000000000000000000000000000000000;;				if s == "" {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.tok.Data = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			case a.Body:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				p.im = inBodyIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Frameset:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.im = inFramesetIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Base, a.Basefont, a.Bgsound, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Title:
0000000000000000000000000000000000000000;;				p.oe = append(p.oe, p.head)
0000000000000000000000000000000000000000;;				defer p.oe.remove(p.head)
0000000000000000000000000000000000000000;;				return inHeadIM(p)
0000000000000000000000000000000000000000;;			case a.Head:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Body, a.Html, a.Br:
0000000000000000000000000000000000000000;;				// Drop down to creating an implied <body> tag.
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.parseImpliedToken(StartTagToken, a.Body, a.Body.String())
0000000000000000000000000000000000000000;;		p.framesetOK = true
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyAttributes copies attributes of src not found on dst to dst.
0000000000000000000000000000000000000000;;	func copyAttributes(dst *Node, src Token) {
0000000000000000000000000000000000000000;;		if len(src.Attr) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attr := map[string]string{}
0000000000000000000000000000000000000000;;		for _, t := range dst.Attr {
0000000000000000000000000000000000000000;;			attr[t.Key] = t.Val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, t := range src.Attr {
0000000000000000000000000000000000000000;;			if _, ok := attr[t.Key]; !ok {
0000000000000000000000000000000000000000;;				dst.Attr = append(dst.Attr, t)
0000000000000000000000000000000000000000;;				attr[t.Key] = t.Val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.7.
0000000000000000000000000000000000000000;;	func inBodyIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			d := p.tok.Data
0000000000000000000000000000000000000000;;			switch n := p.oe.top(); n.DataAtom {
0000000000000000000000000000000000000000;;			case a.Pre, a.Listing:
0000000000000000000000000000000000000000;;				if n.FirstChild == nil {
0000000000000000000000000000000000000000;;					// Ignore a newline at the start of a <pre> block.
0000000000000000000000000000000000000000;;					if d != "" && d[0] == '\r' {
0000000000000000000000000000000000000000;;						d = d[1:]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if d != "" && d[0] == '\n' {
0000000000000000000000000000000000000000;;						d = d[1:]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d = strings.Replace(d, "\x00", "", -1)
0000000000000000000000000000000000000000;;			if d == "" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;			p.addText(d)
0000000000000000000000000000000000000000;;			if p.framesetOK && strings.TrimLeft(d, whitespace) != "" {
0000000000000000000000000000000000000000;;				// There were non-whitespace characters inserted.
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				copyAttributes(p.oe[0], p.tok)
0000000000000000000000000000000000000000;;			case a.Base, a.Basefont, a.Bgsound, a.Command, a.Link, a.Meta, a.Noframes, a.Script, a.Style, a.Title:
0000000000000000000000000000000000000000;;				return inHeadIM(p)
0000000000000000000000000000000000000000;;			case a.Body:
0000000000000000000000000000000000000000;;				if len(p.oe) >= 2 {
0000000000000000000000000000000000000000;;					body := p.oe[1]
0000000000000000000000000000000000000000;;					if body.Type == ElementNode && body.DataAtom == a.Body {
0000000000000000000000000000000000000000;;						p.framesetOK = false
0000000000000000000000000000000000000000;;						copyAttributes(body, p.tok)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case a.Frameset:
0000000000000000000000000000000000000000;;				if !p.framesetOK || len(p.oe) < 2 || p.oe[1].DataAtom != a.Body {
0000000000000000000000000000000000000000;;					// Ignore the token.
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				body := p.oe[1]
0000000000000000000000000000000000000000;;				if body.Parent != nil {
0000000000000000000000000000000000000000;;					body.Parent.RemoveChild(body)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.oe = p.oe[:1]
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.im = inFramesetIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Address, a.Article, a.Aside, a.Blockquote, a.Center, a.Details, a.Dir, a.Div, a.Dl, a.Fieldset, a.Figcaption, a.Figure, a.Footer, a.Header, a.Hgroup, a.Menu, a.Nav, a.Ol, a.P, a.Section, a.Summary, a.Ul:
0000000000000000000000000000000000000000;;				p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			case a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:
0000000000000000000000000000000000000000;;				p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;				switch n := p.top(); n.DataAtom {
0000000000000000000000000000000000000000;;				case a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:
0000000000000000000000000000000000000000;;					p.oe.pop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			case a.Pre, a.Listing:
0000000000000000000000000000000000000000;;				p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				// The newline, if any, will be dealt with by the TextToken case.
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;			case a.Form:
0000000000000000000000000000000000000000;;				if p.form == nil {
0000000000000000000000000000000000000000;;					p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;					p.addElement()
0000000000000000000000000000000000000000;;					p.form = p.top()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case a.Li:
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				for i := len(p.oe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;					node := p.oe[i]
0000000000000000000000000000000000000000;;					switch node.DataAtom {
0000000000000000000000000000000000000000;;					case a.Li:
0000000000000000000000000000000000000000;;						p.oe = p.oe[:i]
0000000000000000000000000000000000000000;;					case a.Address, a.Div, a.P:
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						if !isSpecialElement(node) {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			case a.Dd, a.Dt:
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				for i := len(p.oe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;					node := p.oe[i]
0000000000000000000000000000000000000000;;					switch node.DataAtom {
0000000000000000000000000000000000000000;;					case a.Dd, a.Dt:
0000000000000000000000000000000000000000;;						p.oe = p.oe[:i]
0000000000000000000000000000000000000000;;					case a.Address, a.Div, a.P:
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						if !isSpecialElement(node) {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			case a.Plaintext:
0000000000000000000000000000000000000000;;				p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			case a.Button:
0000000000000000000000000000000000000000;;				p.popUntil(defaultScope, a.Button)
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;			case a.A:
0000000000000000000000000000000000000000;;				for i := len(p.afe) - 1; i >= 0 && p.afe[i].Type != scopeMarkerNode; i-- {
0000000000000000000000000000000000000000;;					if n := p.afe[i]; n.Type == ElementNode && n.DataAtom == a.A {
0000000000000000000000000000000000000000;;						p.inBodyEndTagFormatting(a.A)
0000000000000000000000000000000000000000;;						p.oe.remove(n)
0000000000000000000000000000000000000000;;						p.afe.remove(n)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.addFormattingElement()
0000000000000000000000000000000000000000;;			case a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.addFormattingElement()
0000000000000000000000000000000000000000;;			case a.Nobr:
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				if p.elementInScope(defaultScope, a.Nobr) {
0000000000000000000000000000000000000000;;					p.inBodyEndTagFormatting(a.Nobr)
0000000000000000000000000000000000000000;;					p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.addFormattingElement()
0000000000000000000000000000000000000000;;			case a.Applet, a.Marquee, a.Object:
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.afe = append(p.afe, &scopeMarker)
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;			case a.Table:
0000000000000000000000000000000000000000;;				if !p.quirks {
0000000000000000000000000000000000000000;;					p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				p.im = inTableIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Area, a.Br, a.Embed, a.Img, a.Input, a.Keygen, a.Wbr:
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.oe.pop()
0000000000000000000000000000000000000000;;				p.acknowledgeSelfClosingTag()
0000000000000000000000000000000000000000;;				if p.tok.DataAtom == a.Input {
0000000000000000000000000000000000000000;;					for _, t := range p.tok.Attr {
0000000000000000000000000000000000000000;;						if t.Key == "type" {
0000000000000000000000000000000000000000;;							if strings.ToLower(t.Val) == "hidden" {
0000000000000000000000000000000000000000;;								// Skip setting framesetOK = false
0000000000000000000000000000000000000000;;								return true
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;			case a.Param, a.Source, a.Track:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.oe.pop()
0000000000000000000000000000000000000000;;				p.acknowledgeSelfClosingTag()
0000000000000000000000000000000000000000;;			case a.Hr:
0000000000000000000000000000000000000000;;				p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.oe.pop()
0000000000000000000000000000000000000000;;				p.acknowledgeSelfClosingTag()
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;			case a.Image:
0000000000000000000000000000000000000000;;				p.tok.DataAtom = a.Img
0000000000000000000000000000000000000000;;				p.tok.Data = a.Img.String()
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			case a.Isindex:
0000000000000000000000000000000000000000;;				if p.form != nil {
0000000000000000000000000000000000000000;;					// Ignore the token.
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				action := ""
0000000000000000000000000000000000000000;;				prompt := "This is a searchable index. Enter search keywords: "
0000000000000000000000000000000000000000;;				attr := []Attribute{{Key: "name", Val: "isindex"}}
0000000000000000000000000000000000000000;;				for _, t := range p.tok.Attr {
0000000000000000000000000000000000000000;;					switch t.Key {
0000000000000000000000000000000000000000;;					case "action":
0000000000000000000000000000000000000000;;						action = t.Val
0000000000000000000000000000000000000000;;					case "name":
0000000000000000000000000000000000000000;;						// Ignore the attribute.
0000000000000000000000000000000000000000;;					case "prompt":
0000000000000000000000000000000000000000;;						prompt = t.Val
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						attr = append(attr, t)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.acknowledgeSelfClosingTag()
0000000000000000000000000000000000000000;;				p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;				p.parseImpliedToken(StartTagToken, a.Form, a.Form.String())
0000000000000000000000000000000000000000;;				if action != "" {
0000000000000000000000000000000000000000;;					p.form.Attr = []Attribute{{Key: "action", Val: action}}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.parseImpliedToken(StartTagToken, a.Hr, a.Hr.String())
0000000000000000000000000000000000000000;;				p.parseImpliedToken(StartTagToken, a.Label, a.Label.String())
0000000000000000000000000000000000000000;;				p.addText(prompt)
0000000000000000000000000000000000000000;;				p.addChild(&Node{
0000000000000000000000000000000000000000;;					Type:     ElementNode,
0000000000000000000000000000000000000000;;					DataAtom: a.Input,
0000000000000000000000000000000000000000;;					Data:     a.Input.String(),
0000000000000000000000000000000000000000;;					Attr:     attr,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				p.oe.pop()
0000000000000000000000000000000000000000;;				p.parseImpliedToken(EndTagToken, a.Label, a.Label.String())
0000000000000000000000000000000000000000;;				p.parseImpliedToken(StartTagToken, a.Hr, a.Hr.String())
0000000000000000000000000000000000000000;;				p.parseImpliedToken(EndTagToken, a.Form, a.Form.String())
0000000000000000000000000000000000000000;;			case a.Textarea:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.setOriginalIM()
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				p.im = textIM
0000000000000000000000000000000000000000;;			case a.Xmp:
0000000000000000000000000000000000000000;;				p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.setOriginalIM()
0000000000000000000000000000000000000000;;				p.im = textIM
0000000000000000000000000000000000000000;;			case a.Iframe:
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.setOriginalIM()
0000000000000000000000000000000000000000;;				p.im = textIM
0000000000000000000000000000000000000000;;			case a.Noembed, a.Noscript:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.setOriginalIM()
0000000000000000000000000000000000000000;;				p.im = textIM
0000000000000000000000000000000000000000;;			case a.Select:
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				p.im = inSelectIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Optgroup, a.Option:
0000000000000000000000000000000000000000;;				if p.top().DataAtom == a.Option {
0000000000000000000000000000000000000000;;					p.oe.pop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			case a.Rp, a.Rt:
0000000000000000000000000000000000000000;;				if p.elementInScope(defaultScope, a.Ruby) {
0000000000000000000000000000000000000000;;					p.generateImpliedEndTags()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			case a.Math, a.Svg:
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				if p.tok.DataAtom == a.Math {
0000000000000000000000000000000000000000;;					adjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					adjustAttributeNames(p.tok.Attr, svgAttributeAdjustments)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				adjustForeignAttributes(p.tok.Attr)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.top().Namespace = p.tok.Data
0000000000000000000000000000000000000000;;				if p.hasSelfClosingToken {
0000000000000000000000000000000000000000;;					p.oe.pop()
0000000000000000000000000000000000000000;;					p.acknowledgeSelfClosingTag()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Caption, a.Col, a.Colgroup, a.Frame, a.Head, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Body:
0000000000000000000000000000000000000000;;				if p.elementInScope(defaultScope, a.Body) {
0000000000000000000000000000000000000000;;					p.im = afterBodyIM
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				if p.elementInScope(defaultScope, a.Body) {
0000000000000000000000000000000000000000;;					p.parseImpliedToken(EndTagToken, a.Body, a.Body.String())
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Address, a.Article, a.Aside, a.Blockquote, a.Button, a.Center, a.Details, a.Dir, a.Div, a.Dl, a.Fieldset, a.Figcaption, a.Figure, a.Footer, a.Header, a.Hgroup, a.Listing, a.Menu, a.Nav, a.Ol, a.Pre, a.Section, a.Summary, a.Ul:
0000000000000000000000000000000000000000;;				p.popUntil(defaultScope, p.tok.DataAtom)
0000000000000000000000000000000000000000;;			case a.Form:
0000000000000000000000000000000000000000;;				node := p.form
0000000000000000000000000000000000000000;;				p.form = nil
0000000000000000000000000000000000000000;;				i := p.indexOfElementInScope(defaultScope, a.Form)
0000000000000000000000000000000000000000;;				if node == nil || i == -1 || p.oe[i] != node {
0000000000000000000000000000000000000000;;					// Ignore the token.
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.generateImpliedEndTags()
0000000000000000000000000000000000000000;;				p.oe.remove(node)
0000000000000000000000000000000000000000;;			case a.P:
0000000000000000000000000000000000000000;;				if !p.elementInScope(buttonScope, a.P) {
0000000000000000000000000000000000000000;;					p.parseImpliedToken(StartTagToken, a.P, a.P.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.popUntil(buttonScope, a.P)
0000000000000000000000000000000000000000;;			case a.Li:
0000000000000000000000000000000000000000;;				p.popUntil(listItemScope, a.Li)
0000000000000000000000000000000000000000;;			case a.Dd, a.Dt:
0000000000000000000000000000000000000000;;				p.popUntil(defaultScope, p.tok.DataAtom)
0000000000000000000000000000000000000000;;			case a.H1, a.H2, a.H3, a.H4, a.H5, a.H6:
0000000000000000000000000000000000000000;;				p.popUntil(defaultScope, a.H1, a.H2, a.H3, a.H4, a.H5, a.H6)
0000000000000000000000000000000000000000;;			case a.A, a.B, a.Big, a.Code, a.Em, a.Font, a.I, a.Nobr, a.S, a.Small, a.Strike, a.Strong, a.Tt, a.U:
0000000000000000000000000000000000000000;;				p.inBodyEndTagFormatting(p.tok.DataAtom)
0000000000000000000000000000000000000000;;			case a.Applet, a.Marquee, a.Object:
0000000000000000000000000000000000000000;;				if p.popUntil(defaultScope, p.tok.DataAtom) {
0000000000000000000000000000000000000000;;					p.clearActiveFormattingElements()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case a.Br:
0000000000000000000000000000000000000000;;				p.tok.Type = StartTagToken
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				p.inBodyEndTagOther(p.tok.DataAtom)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) inBodyEndTagFormatting(tagAtom a.Atom) {
0000000000000000000000000000000000000000;;		// This is the "adoption agency" algorithm, described at
0000000000000000000000000000000000000000;;		// https://html.spec.whatwg.org/multipage/syntax.html#adoptionAgency
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: this is a fairly literal line-by-line translation of that algorithm.
0000000000000000000000000000000000000000;;		// Once the code successfully parses the comprehensive test suite, we should
0000000000000000000000000000000000000000;;		// refactor this code to be more idiomatic.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Steps 1-4. The outer loop.
0000000000000000000000000000000000000000;;		for i := 0; i < 8; i++ {
0000000000000000000000000000000000000000;;			// Step 5. Find the formatting element.
0000000000000000000000000000000000000000;;			var formattingElement *Node
0000000000000000000000000000000000000000;;			for j := len(p.afe) - 1; j >= 0; j-- {
0000000000000000000000000000000000000000;;				if p.afe[j].Type == scopeMarkerNode {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if p.afe[j].DataAtom == tagAtom {
0000000000000000000000000000000000000000;;					formattingElement = p.afe[j]
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if formattingElement == nil {
0000000000000000000000000000000000000000;;				p.inBodyEndTagOther(tagAtom)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			feIndex := p.oe.index(formattingElement)
0000000000000000000000000000000000000000;;			if feIndex == -1 {
0000000000000000000000000000000000000000;;				p.afe.remove(formattingElement)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !p.elementInScope(defaultScope, tagAtom) {
0000000000000000000000000000000000000000;;				// Ignore the tag.
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Steps 9-10. Find the furthest block.
0000000000000000000000000000000000000000;;			var furthestBlock *Node
0000000000000000000000000000000000000000;;			for _, e := range p.oe[feIndex:] {
0000000000000000000000000000000000000000;;				if isSpecialElement(e) {
0000000000000000000000000000000000000000;;					furthestBlock = e
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if furthestBlock == nil {
0000000000000000000000000000000000000000;;				e := p.oe.pop()
0000000000000000000000000000000000000000;;				for e != formattingElement {
0000000000000000000000000000000000000000;;					e = p.oe.pop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.afe.remove(e)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Steps 11-12. Find the common ancestor and bookmark node.
0000000000000000000000000000000000000000;;			commonAncestor := p.oe[feIndex-1]
0000000000000000000000000000000000000000;;			bookmark := p.afe.index(formattingElement)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Step 13. The inner loop. Find the lastNode to reparent.
0000000000000000000000000000000000000000;;			lastNode := furthestBlock
0000000000000000000000000000000000000000;;			node := furthestBlock
0000000000000000000000000000000000000000;;			x := p.oe.index(node)
0000000000000000000000000000000000000000;;			// Steps 13.1-13.2
0000000000000000000000000000000000000000;;			for j := 0; j < 3; j++ {
0000000000000000000000000000000000000000;;				// Step 13.3.
0000000000000000000000000000000000000000;;				x--
0000000000000000000000000000000000000000;;				node = p.oe[x]
0000000000000000000000000000000000000000;;				// Step 13.4 - 13.5.
0000000000000000000000000000000000000000;;				if p.afe.index(node) == -1 {
0000000000000000000000000000000000000000;;					p.oe.remove(node)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Step 13.6.
0000000000000000000000000000000000000000;;				if node == formattingElement {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Step 13.7.
0000000000000000000000000000000000000000;;				clone := node.clone()
0000000000000000000000000000000000000000;;				p.afe[p.afe.index(node)] = clone
0000000000000000000000000000000000000000;;				p.oe[p.oe.index(node)] = clone
0000000000000000000000000000000000000000;;				node = clone
0000000000000000000000000000000000000000;;				// Step 13.8.
0000000000000000000000000000000000000000;;				if lastNode == furthestBlock {
0000000000000000000000000000000000000000;;					bookmark = p.afe.index(node) + 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Step 13.9.
0000000000000000000000000000000000000000;;				if lastNode.Parent != nil {
0000000000000000000000000000000000000000;;					lastNode.Parent.RemoveChild(lastNode)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				node.AppendChild(lastNode)
0000000000000000000000000000000000000000;;				// Step 13.10.
0000000000000000000000000000000000000000;;				lastNode = node
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Step 14. Reparent lastNode to the common ancestor,
0000000000000000000000000000000000000000;;			// or for misnested table nodes, to the foster parent.
0000000000000000000000000000000000000000;;			if lastNode.Parent != nil {
0000000000000000000000000000000000000000;;				lastNode.Parent.RemoveChild(lastNode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch commonAncestor.DataAtom {
0000000000000000000000000000000000000000;;			case a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;				p.fosterParent(lastNode)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				commonAncestor.AppendChild(lastNode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Steps 15-17. Reparent nodes from the furthest block's children
0000000000000000000000000000000000000000;;			// to a clone of the formatting element.
0000000000000000000000000000000000000000;;			clone := formattingElement.clone()
0000000000000000000000000000000000000000;;			reparentChildren(clone, furthestBlock)
0000000000000000000000000000000000000000;;			furthestBlock.AppendChild(clone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Step 18. Fix up the list of active formatting elements.
0000000000000000000000000000000000000000;;			if oldLoc := p.afe.index(formattingElement); oldLoc != -1 && oldLoc < bookmark {
0000000000000000000000000000000000000000;;				// Move the bookmark with the rest of the list.
0000000000000000000000000000000000000000;;				bookmark--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.afe.remove(formattingElement)
0000000000000000000000000000000000000000;;			p.afe.insert(bookmark, clone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Step 19. Fix up the stack of open elements.
0000000000000000000000000000000000000000;;			p.oe.remove(formattingElement)
0000000000000000000000000000000000000000;;			p.oe.insert(p.oe.index(furthestBlock)+1, clone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// inBodyEndTagOther performs the "any other end tag" algorithm for inBodyIM.
0000000000000000000000000000000000000000;;	// "Any other end tag" handling from 12.2.5.5 The rules for parsing tokens in foreign content
0000000000000000000000000000000000000000;;	// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inforeign
0000000000000000000000000000000000000000;;	func (p *parser) inBodyEndTagOther(tagAtom a.Atom) {
0000000000000000000000000000000000000000;;		for i := len(p.oe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			if p.oe[i].DataAtom == tagAtom {
0000000000000000000000000000000000000000;;				p.oe = p.oe[:i]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isSpecialElement(p.oe[i]) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.8.
0000000000000000000000000000000000000000;;	func textIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case ErrorToken:
0000000000000000000000000000000000000000;;			p.oe.pop()
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			d := p.tok.Data
0000000000000000000000000000000000000000;;			if n := p.oe.top(); n.DataAtom == a.Textarea && n.FirstChild == nil {
0000000000000000000000000000000000000000;;				// Ignore a newline at the start of a <textarea> block.
0000000000000000000000000000000000000000;;				if d != "" && d[0] == '\r' {
0000000000000000000000000000000000000000;;					d = d[1:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if d != "" && d[0] == '\n' {
0000000000000000000000000000000000000000;;					d = d[1:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if d == "" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.addText(d)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			p.oe.pop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.im = p.originalIM
0000000000000000000000000000000000000000;;		p.originalIM = nil
0000000000000000000000000000000000000000;;		return p.tok.Type == EndTagToken
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.9.
0000000000000000000000000000000000000000;;	func inTableIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case ErrorToken:
0000000000000000000000000000000000000000;;			// Stop parsing.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			p.tok.Data = strings.Replace(p.tok.Data, "\x00", "", -1)
0000000000000000000000000000000000000000;;			switch p.oe.top().DataAtom {
0000000000000000000000000000000000000000;;			case a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;				if strings.Trim(p.tok.Data, whitespace) == "" {
0000000000000000000000000000000000000000;;					p.addText(p.tok.Data)
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Caption:
0000000000000000000000000000000000000000;;				p.clearStackToContext(tableScope)
0000000000000000000000000000000000000000;;				p.afe = append(p.afe, &scopeMarker)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.im = inCaptionIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Colgroup:
0000000000000000000000000000000000000000;;				p.clearStackToContext(tableScope)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.im = inColumnGroupIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Col:
0000000000000000000000000000000000000000;;				p.parseImpliedToken(StartTagToken, a.Colgroup, a.Colgroup.String())
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			case a.Tbody, a.Tfoot, a.Thead:
0000000000000000000000000000000000000000;;				p.clearStackToContext(tableScope)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.im = inTableBodyIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Td, a.Th, a.Tr:
0000000000000000000000000000000000000000;;				p.parseImpliedToken(StartTagToken, a.Tbody, a.Tbody.String())
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			case a.Table:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Table) {
0000000000000000000000000000000000000000;;					p.resetInsertionMode()
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Style, a.Script:
0000000000000000000000000000000000000000;;				return inHeadIM(p)
0000000000000000000000000000000000000000;;			case a.Input:
0000000000000000000000000000000000000000;;				for _, t := range p.tok.Attr {
0000000000000000000000000000000000000000;;					if t.Key == "type" && strings.ToLower(t.Val) == "hidden" {
0000000000000000000000000000000000000000;;						p.addElement()
0000000000000000000000000000000000000000;;						p.oe.pop()
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Otherwise drop down to the default action.
0000000000000000000000000000000000000000;;			case a.Form:
0000000000000000000000000000000000000000;;				if p.form != nil {
0000000000000000000000000000000000000000;;					// Ignore the token.
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.form = p.oe.pop()
0000000000000000000000000000000000000000;;			case a.Select:
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				switch p.top().DataAtom {
0000000000000000000000000000000000000000;;				case a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;					p.fosterParenting = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.fosterParenting = false
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				p.im = inSelectInTableIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Table:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Table) {
0000000000000000000000000000000000000000;;					p.resetInsertionMode()
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.fosterParenting = true
0000000000000000000000000000000000000000;;		defer func() { p.fosterParenting = false }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return inBodyIM(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.11.
0000000000000000000000000000000000000000;;	func inCaptionIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Caption, a.Col, a.Colgroup, a.Tbody, a.Td, a.Tfoot, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Caption) {
0000000000000000000000000000000000000000;;					p.clearActiveFormattingElements()
0000000000000000000000000000000000000000;;					p.im = inTableIM
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Ignore the token.
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case a.Select:
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				p.im = inSelectInTableIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Caption:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Caption) {
0000000000000000000000000000000000000000;;					p.clearActiveFormattingElements()
0000000000000000000000000000000000000000;;					p.im = inTableIM
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Table:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Caption) {
0000000000000000000000000000000000000000;;					p.clearActiveFormattingElements()
0000000000000000000000000000000000000000;;					p.im = inTableIM
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Ignore the token.
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case a.Body, a.Col, a.Colgroup, a.Html, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return inBodyIM(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.12.
0000000000000000000000000000000000000000;;	func inColumnGroupIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			s := strings.TrimLeft(p.tok.Data, whitespace)
0000000000000000000000000000000000000000;;			if len(s) < len(p.tok.Data) {
0000000000000000000000000000000000000000;;				// Add the initial whitespace to the current node.
0000000000000000000000000000000000000000;;				p.addText(p.tok.Data[:len(p.tok.Data)-len(s)])
0000000000000000000000000000000000000000;;				if s == "" {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.tok.Data = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			case a.Col:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.oe.pop()
0000000000000000000000000000000000000000;;				p.acknowledgeSelfClosingTag()
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Colgroup:
0000000000000000000000000000000000000000;;				if p.oe.top().DataAtom != a.Html {
0000000000000000000000000000000000000000;;					p.oe.pop()
0000000000000000000000000000000000000000;;					p.im = inTableIM
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Col:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.oe.top().DataAtom != a.Html {
0000000000000000000000000000000000000000;;			p.oe.pop()
0000000000000000000000000000000000000000;;			p.im = inTableIM
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.13.
0000000000000000000000000000000000000000;;	func inTableBodyIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Tr:
0000000000000000000000000000000000000000;;				p.clearStackToContext(tableBodyScope)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.im = inRowIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Td, a.Th:
0000000000000000000000000000000000000000;;				p.parseImpliedToken(StartTagToken, a.Tr, a.Tr.String())
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			case a.Caption, a.Col, a.Colgroup, a.Tbody, a.Tfoot, a.Thead:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Tbody, a.Thead, a.Tfoot) {
0000000000000000000000000000000000000000;;					p.im = inTableIM
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Tbody, a.Tfoot, a.Thead:
0000000000000000000000000000000000000000;;				if p.elementInScope(tableScope, p.tok.DataAtom) {
0000000000000000000000000000000000000000;;					p.clearStackToContext(tableBodyScope)
0000000000000000000000000000000000000000;;					p.oe.pop()
0000000000000000000000000000000000000000;;					p.im = inTableIM
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Table:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Tbody, a.Thead, a.Tfoot) {
0000000000000000000000000000000000000000;;					p.im = inTableIM
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Td, a.Th, a.Tr:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return inTableIM(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.14.
0000000000000000000000000000000000000000;;	func inRowIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Td, a.Th:
0000000000000000000000000000000000000000;;				p.clearStackToContext(tableRowScope)
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.afe = append(p.afe, &scopeMarker)
0000000000000000000000000000000000000000;;				p.im = inCellIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Caption, a.Col, a.Colgroup, a.Tbody, a.Tfoot, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Tr) {
0000000000000000000000000000000000000000;;					p.im = inTableBodyIM
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Tr:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Tr) {
0000000000000000000000000000000000000000;;					p.im = inTableBodyIM
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Table:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Tr) {
0000000000000000000000000000000000000000;;					p.im = inTableBodyIM
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Tbody, a.Tfoot, a.Thead:
0000000000000000000000000000000000000000;;				if p.elementInScope(tableScope, p.tok.DataAtom) {
0000000000000000000000000000000000000000;;					p.parseImpliedToken(EndTagToken, a.Tr, a.Tr.String())
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Body, a.Caption, a.Col, a.Colgroup, a.Html, a.Td, a.Th:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return inTableIM(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.15.
0000000000000000000000000000000000000000;;	func inCellIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Caption, a.Col, a.Colgroup, a.Tbody, a.Td, a.Tfoot, a.Th, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;				if p.popUntil(tableScope, a.Td, a.Th) {
0000000000000000000000000000000000000000;;					// Close the cell and reprocess.
0000000000000000000000000000000000000000;;					p.clearActiveFormattingElements()
0000000000000000000000000000000000000000;;					p.im = inRowIM
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Select:
0000000000000000000000000000000000000000;;				p.reconstructActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.framesetOK = false
0000000000000000000000000000000000000000;;				p.im = inSelectInTableIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Td, a.Th:
0000000000000000000000000000000000000000;;				if !p.popUntil(tableScope, p.tok.DataAtom) {
0000000000000000000000000000000000000000;;					// Ignore the token.
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.clearActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.im = inRowIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Body, a.Caption, a.Col, a.Colgroup, a.Html:
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr:
0000000000000000000000000000000000000000;;				if !p.elementInScope(tableScope, p.tok.DataAtom) {
0000000000000000000000000000000000000000;;					// Ignore the token.
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Close the cell and reprocess.
0000000000000000000000000000000000000000;;				p.popUntil(tableScope, a.Td, a.Th)
0000000000000000000000000000000000000000;;				p.clearActiveFormattingElements()
0000000000000000000000000000000000000000;;				p.im = inRowIM
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return inBodyIM(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.16.
0000000000000000000000000000000000000000;;	func inSelectIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case ErrorToken:
0000000000000000000000000000000000000000;;			// Stop parsing.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			p.addText(strings.Replace(p.tok.Data, "\x00", "", -1))
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			case a.Option:
0000000000000000000000000000000000000000;;				if p.top().DataAtom == a.Option {
0000000000000000000000000000000000000000;;					p.oe.pop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			case a.Optgroup:
0000000000000000000000000000000000000000;;				if p.top().DataAtom == a.Option {
0000000000000000000000000000000000000000;;					p.oe.pop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if p.top().DataAtom == a.Optgroup {
0000000000000000000000000000000000000000;;					p.oe.pop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			case a.Select:
0000000000000000000000000000000000000000;;				p.tok.Type = EndTagToken
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			case a.Input, a.Keygen, a.Textarea:
0000000000000000000000000000000000000000;;				if p.elementInScope(selectScope, a.Select) {
0000000000000000000000000000000000000000;;					p.parseImpliedToken(EndTagToken, a.Select, a.Select.String())
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// In order to properly ignore <textarea>, we need to change the tokenizer mode.
0000000000000000000000000000000000000000;;				p.tokenizer.NextIsNotRawText()
0000000000000000000000000000000000000000;;				// Ignore the token.
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case a.Script:
0000000000000000000000000000000000000000;;				return inHeadIM(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Option:
0000000000000000000000000000000000000000;;				if p.top().DataAtom == a.Option {
0000000000000000000000000000000000000000;;					p.oe.pop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case a.Optgroup:
0000000000000000000000000000000000000000;;				i := len(p.oe) - 1
0000000000000000000000000000000000000000;;				if p.oe[i].DataAtom == a.Option {
0000000000000000000000000000000000000000;;					i--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if p.oe[i].DataAtom == a.Optgroup {
0000000000000000000000000000000000000000;;					p.oe = p.oe[:i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case a.Select:
0000000000000000000000000000000000000000;;				if p.popUntil(selectScope, a.Select) {
0000000000000000000000000000000000000000;;					p.resetInsertionMode()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.17.
0000000000000000000000000000000000000000;;	func inSelectInTableIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case StartTagToken, EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Caption, a.Table, a.Tbody, a.Tfoot, a.Thead, a.Tr, a.Td, a.Th:
0000000000000000000000000000000000000000;;				if p.tok.Type == StartTagToken || p.elementInScope(tableScope, p.tok.DataAtom) {
0000000000000000000000000000000000000000;;					p.parseImpliedToken(EndTagToken, a.Select, a.Select.String())
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Ignore the token.
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return inSelectIM(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.18.
0000000000000000000000000000000000000000;;	func afterBodyIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case ErrorToken:
0000000000000000000000000000000000000000;;			// Stop parsing.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			s := strings.TrimLeft(p.tok.Data, whitespace)
0000000000000000000000000000000000000000;;			if len(s) == 0 {
0000000000000000000000000000000000000000;;				// It was all whitespace.
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			if p.tok.DataAtom == a.Html {
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			if p.tok.DataAtom == a.Html {
0000000000000000000000000000000000000000;;				if !p.fragment {
0000000000000000000000000000000000000000;;					p.im = afterAfterBodyIM
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			// The comment is attached to the <html> element.
0000000000000000000000000000000000000000;;			if len(p.oe) < 1 || p.oe[0].DataAtom != a.Html {
0000000000000000000000000000000000000000;;				panic("html: bad parser state: <html> element not found, in the after-body insertion mode")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.oe[0].AppendChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.im = inBodyIM
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.19.
0000000000000000000000000000000000000000;;	func inFramesetIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			// Ignore all text but whitespace.
0000000000000000000000000000000000000000;;			s := strings.Map(func(c rune) rune {
0000000000000000000000000000000000000000;;				switch c {
0000000000000000000000000000000000000000;;				case ' ', '\t', '\n', '\f', '\r':
0000000000000000000000000000000000000000;;					return c
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}, p.tok.Data)
0000000000000000000000000000000000000000;;			if s != "" {
0000000000000000000000000000000000000000;;				p.addText(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			case a.Frameset:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;			case a.Frame:
0000000000000000000000000000000000000000;;				p.addElement()
0000000000000000000000000000000000000000;;				p.oe.pop()
0000000000000000000000000000000000000000;;				p.acknowledgeSelfClosingTag()
0000000000000000000000000000000000000000;;			case a.Noframes:
0000000000000000000000000000000000000000;;				return inHeadIM(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Frameset:
0000000000000000000000000000000000000000;;				if p.oe.top().DataAtom != a.Html {
0000000000000000000000000000000000000000;;					p.oe.pop()
0000000000000000000000000000000000000000;;					if p.oe.top().DataAtom != a.Frameset {
0000000000000000000000000000000000000000;;						p.im = afterFramesetIM
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.20.
0000000000000000000000000000000000000000;;	func afterFramesetIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			// Ignore all text but whitespace.
0000000000000000000000000000000000000000;;			s := strings.Map(func(c rune) rune {
0000000000000000000000000000000000000000;;				switch c {
0000000000000000000000000000000000000000;;				case ' ', '\t', '\n', '\f', '\r':
0000000000000000000000000000000000000000;;					return c
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}, p.tok.Data)
0000000000000000000000000000000000000000;;			if s != "" {
0000000000000000000000000000000000000000;;				p.addText(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			case a.Noframes:
0000000000000000000000000000000000000000;;				return inHeadIM(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				p.im = afterAfterFramesetIM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.21.
0000000000000000000000000000000000000000;;	func afterAfterBodyIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case ErrorToken:
0000000000000000000000000000000000000000;;			// Stop parsing.
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			s := strings.TrimLeft(p.tok.Data, whitespace)
0000000000000000000000000000000000000000;;			if len(s) == 0 {
0000000000000000000000000000000000000000;;				// It was all whitespace.
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			if p.tok.DataAtom == a.Html {
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.doc.AppendChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			return inBodyIM(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.im = inBodyIM
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.4.22.
0000000000000000000000000000000000000000;;	func afterAfterFramesetIM(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.doc.AppendChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			// Ignore all text but whitespace.
0000000000000000000000000000000000000000;;			s := strings.Map(func(c rune) rune {
0000000000000000000000000000000000000000;;				switch c {
0000000000000000000000000000000000000000;;				case ' ', '\t', '\n', '\f', '\r':
0000000000000000000000000000000000000000;;					return c
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}, p.tok.Data)
0000000000000000000000000000000000000000;;			if s != "" {
0000000000000000000000000000000000000000;;				p.tok.Data = s
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			switch p.tok.DataAtom {
0000000000000000000000000000000000000000;;			case a.Html:
0000000000000000000000000000000000000000;;				return inBodyIM(p)
0000000000000000000000000000000000000000;;			case a.Noframes:
0000000000000000000000000000000000000000;;				return inHeadIM(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case DoctypeToken:
0000000000000000000000000000000000000000;;			return inBodyIM(p)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const whitespaceOrNUL = whitespace + "\x00"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.5.
0000000000000000000000000000000000000000;;	func parseForeignContent(p *parser) bool {
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case TextToken:
0000000000000000000000000000000000000000;;			if p.framesetOK {
0000000000000000000000000000000000000000;;				p.framesetOK = strings.TrimLeft(p.tok.Data, whitespaceOrNUL) == ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.tok.Data = strings.Replace(p.tok.Data, "\x00", "\ufffd", -1)
0000000000000000000000000000000000000000;;			p.addText(p.tok.Data)
0000000000000000000000000000000000000000;;		case CommentToken:
0000000000000000000000000000000000000000;;			p.addChild(&Node{
0000000000000000000000000000000000000000;;				Type: CommentNode,
0000000000000000000000000000000000000000;;				Data: p.tok.Data,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case StartTagToken:
0000000000000000000000000000000000000000;;			b := breakout[p.tok.Data]
0000000000000000000000000000000000000000;;			if p.tok.DataAtom == a.Font {
0000000000000000000000000000000000000000;;			loop:
0000000000000000000000000000000000000000;;				for _, attr := range p.tok.Attr {
0000000000000000000000000000000000000000;;					switch attr.Key {
0000000000000000000000000000000000000000;;					case "color", "face", "size":
0000000000000000000000000000000000000000;;						b = true
0000000000000000000000000000000000000000;;						break loop
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b {
0000000000000000000000000000000000000000;;				for i := len(p.oe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;					n := p.oe[i]
0000000000000000000000000000000000000000;;					if n.Namespace == "" || htmlIntegrationPoint(n) || mathMLTextIntegrationPoint(n) {
0000000000000000000000000000000000000000;;						p.oe = p.oe[:i+1]
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch p.top().Namespace {
0000000000000000000000000000000000000000;;			case "math":
0000000000000000000000000000000000000000;;				adjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments)
0000000000000000000000000000000000000000;;			case "svg":
0000000000000000000000000000000000000000;;				// Adjust SVG tag names. The tokenizer lower-cases tag names, but
0000000000000000000000000000000000000000;;				// SVG wants e.g. "foreignObject" with a capital second "O".
0000000000000000000000000000000000000000;;				if x := svgTagNameAdjustments[p.tok.Data]; x != "" {
0000000000000000000000000000000000000000;;					p.tok.DataAtom = a.Lookup([]byte(x))
0000000000000000000000000000000000000000;;					p.tok.Data = x
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				adjustAttributeNames(p.tok.Attr, svgAttributeAdjustments)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("html: bad parser state: unexpected namespace")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			adjustForeignAttributes(p.tok.Attr)
0000000000000000000000000000000000000000;;			namespace := p.top().Namespace
0000000000000000000000000000000000000000;;			p.addElement()
0000000000000000000000000000000000000000;;			p.top().Namespace = namespace
0000000000000000000000000000000000000000;;			if namespace != "" {
0000000000000000000000000000000000000000;;				// Don't let the tokenizer go into raw text mode in foreign content
0000000000000000000000000000000000000000;;				// (e.g. in an SVG <title> tag).
0000000000000000000000000000000000000000;;				p.tokenizer.NextIsNotRawText()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.hasSelfClosingToken {
0000000000000000000000000000000000000000;;				p.oe.pop()
0000000000000000000000000000000000000000;;				p.acknowledgeSelfClosingTag()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndTagToken:
0000000000000000000000000000000000000000;;			for i := len(p.oe) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;				if p.oe[i].Namespace == "" {
0000000000000000000000000000000000000000;;					return p.im(p)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if strings.EqualFold(p.oe[i].Data, p.tok.Data) {
0000000000000000000000000000000000000000;;					p.oe = p.oe[:i]
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Ignore the token.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Section 12.2.5.
0000000000000000000000000000000000000000;;	func (p *parser) inForeignContent() bool {
0000000000000000000000000000000000000000;;		if len(p.oe) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := p.oe[len(p.oe)-1]
0000000000000000000000000000000000000000;;		if n.Namespace == "" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mathMLTextIntegrationPoint(n) {
0000000000000000000000000000000000000000;;			if p.tok.Type == StartTagToken && p.tok.DataAtom != a.Mglyph && p.tok.DataAtom != a.Malignmark {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.tok.Type == TextToken {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.Namespace == "math" && n.DataAtom == a.AnnotationXml && p.tok.Type == StartTagToken && p.tok.DataAtom == a.Svg {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if htmlIntegrationPoint(n) && (p.tok.Type == StartTagToken || p.tok.Type == TextToken) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.tok.Type == ErrorToken {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseImpliedToken parses a token as though it had appeared in the parser's
0000000000000000000000000000000000000000;;	// input.
0000000000000000000000000000000000000000;;	func (p *parser) parseImpliedToken(t TokenType, dataAtom a.Atom, data string) {
0000000000000000000000000000000000000000;;		realToken, selfClosing := p.tok, p.hasSelfClosingToken
0000000000000000000000000000000000000000;;		p.tok = Token{
0000000000000000000000000000000000000000;;			Type:     t,
0000000000000000000000000000000000000000;;			DataAtom: dataAtom,
0000000000000000000000000000000000000000;;			Data:     data,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.hasSelfClosingToken = false
0000000000000000000000000000000000000000;;		p.parseCurrentToken()
0000000000000000000000000000000000000000;;		p.tok, p.hasSelfClosingToken = realToken, selfClosing
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseCurrentToken runs the current token through the parsing routines
0000000000000000000000000000000000000000;;	// until it is consumed.
0000000000000000000000000000000000000000;;	func (p *parser) parseCurrentToken() {
0000000000000000000000000000000000000000;;		if p.tok.Type == SelfClosingTagToken {
0000000000000000000000000000000000000000;;			p.hasSelfClosingToken = true
0000000000000000000000000000000000000000;;			p.tok.Type = StartTagToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		consumed := false
0000000000000000000000000000000000000000;;		for !consumed {
0000000000000000000000000000000000000000;;			if p.inForeignContent() {
0000000000000000000000000000000000000000;;				consumed = parseForeignContent(p)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				consumed = p.im(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.hasSelfClosingToken {
0000000000000000000000000000000000000000;;			// This is a parse error, but ignore it.
0000000000000000000000000000000000000000;;			p.hasSelfClosingToken = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) parse() error {
0000000000000000000000000000000000000000;;		// Iterate until EOF. Any other error will cause an early return.
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for err != io.EOF {
0000000000000000000000000000000000000000;;			// CDATA sections are allowed only in foreign content.
0000000000000000000000000000000000000000;;			n := p.oe.top()
0000000000000000000000000000000000000000;;			p.tokenizer.AllowCDATA(n != nil && n.Namespace != "")
0000000000000000000000000000000000000000;;			// Read and parse the next token.
0000000000000000000000000000000000000000;;			p.tokenizer.Next()
0000000000000000000000000000000000000000;;			p.tok = p.tokenizer.Token()
0000000000000000000000000000000000000000;;			if p.tok.Type == ErrorToken {
0000000000000000000000000000000000000000;;				err = p.tokenizer.Err()
0000000000000000000000000000000000000000;;				if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.parseCurrentToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse returns the parse tree for the HTML from the given Reader.
0000000000000000000000000000000000000000;;	// The input is assumed to be UTF-8 encoded.
0000000000000000000000000000000000000000;;	func Parse(r io.Reader) (*Node, error) {
0000000000000000000000000000000000000000;;		p := &parser{
0000000000000000000000000000000000000000;;			tokenizer: NewTokenizer(r),
0000000000000000000000000000000000000000;;			doc: &Node{
0000000000000000000000000000000000000000;;				Type: DocumentNode,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			scripting:  true,
0000000000000000000000000000000000000000;;			framesetOK: true,
0000000000000000000000000000000000000000;;			im:         initialIM,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := p.parse()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.doc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseFragment parses a fragment of HTML and returns the nodes that were
0000000000000000000000000000000000000000;;	// found. If the fragment is the InnerHTML for an existing element, pass that
0000000000000000000000000000000000000000;;	// element in context.
0000000000000000000000000000000000000000;;	func ParseFragment(r io.Reader, context *Node) ([]*Node, error) {
0000000000000000000000000000000000000000;;		contextTag := ""
0000000000000000000000000000000000000000;;		if context != nil {
0000000000000000000000000000000000000000;;			if context.Type != ElementNode {
0000000000000000000000000000000000000000;;				return nil, errors.New("html: ParseFragment of non-element Node")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// The next check isn't just context.DataAtom.String() == context.Data because
0000000000000000000000000000000000000000;;			// it is valid to pass an element whose tag isn't a known atom. For example,
0000000000000000000000000000000000000000;;			// DataAtom == 0 and Data = "tagfromthefuture" is perfectly consistent.
0000000000000000000000000000000000000000;;			if context.DataAtom != a.Lookup([]byte(context.Data)) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("html: inconsistent Node: DataAtom=%q, Data=%q", context.DataAtom, context.Data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			contextTag = context.DataAtom.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := &parser{
0000000000000000000000000000000000000000;;			tokenizer: NewTokenizerFragment(r, contextTag),
0000000000000000000000000000000000000000;;			doc: &Node{
0000000000000000000000000000000000000000;;				Type: DocumentNode,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			scripting: true,
0000000000000000000000000000000000000000;;			fragment:  true,
0000000000000000000000000000000000000000;;			context:   context,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		root := &Node{
0000000000000000000000000000000000000000;;			Type:     ElementNode,
0000000000000000000000000000000000000000;;			DataAtom: a.Html,
0000000000000000000000000000000000000000;;			Data:     a.Html.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.doc.AppendChild(root)
0000000000000000000000000000000000000000;;		p.oe = nodeStack{root}
0000000000000000000000000000000000000000;;		p.resetInsertionMode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for n := context; n != nil; n = n.Parent {
0000000000000000000000000000000000000000;;			if n.Type == ElementNode && n.DataAtom == a.Form {
0000000000000000000000000000000000000000;;				p.form = n
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := p.parse()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parent := p.doc
0000000000000000000000000000000000000000;;		if context != nil {
0000000000000000000000000000000000000000;;			parent = root
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result []*Node
0000000000000000000000000000000000000000;;		for c := parent.FirstChild; c != nil; {
0000000000000000000000000000000000000000;;			next := c.NextSibling
0000000000000000000000000000000000000000;;			parent.RemoveChild(c)
0000000000000000000000000000000000000000;;			result = append(result, c)
0000000000000000000000000000000000000000;;			c = next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
