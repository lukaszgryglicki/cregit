0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
c2bfd044362efe23765620d054edcdab7497bde5;third_party/src/code.google.com/p/go.net/html/atom/atom.go[third_party/src/code.google.com/p/go.net/html/atom/atom.go][vendor/golang.org/x/net/html/atom/atom.go];	
0000000000000000000000000000000000000000;;	// Package atom provides integer codes (also known as atoms) for a fixed set of
0000000000000000000000000000000000000000;;	// frequently occurring HTML strings: tag names and attribute keys such as "p"
0000000000000000000000000000000000000000;;	// and "id".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Sharing an atom's name between all elements with the same tag can result in
0000000000000000000000000000000000000000;;	// fewer string allocations when tokenizing and parsing HTML. Integer
0000000000000000000000000000000000000000;;	// comparisons are also generally faster than string comparisons.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The value of an atom's particular code is not guaranteed to stay the same
0000000000000000000000000000000000000000;;	// between versions of this package. Neither is any ordering guaranteed:
0000000000000000000000000000000000000000;;	// whether atom.H1 < atom.H2 may also change. The codes are not guaranteed to
0000000000000000000000000000000000000000;;	// be dense. The only guarantees are that e.g. looking up "div" will yield
0000000000000000000000000000000000000000;;	// atom.Div, calling atom.Div.String will return "div", and atom.Div != 0.
0000000000000000000000000000000000000000;;	package atom
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Atom is an integer code for a string. The zero value maps to "".
0000000000000000000000000000000000000000;;	type Atom uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the atom's name.
0000000000000000000000000000000000000000;;	func (a Atom) String() string {
0000000000000000000000000000000000000000;;		start := uint32(a >> 8)
0000000000000000000000000000000000000000;;		n := uint32(a & 0xff)
0000000000000000000000000000000000000000;;		if start+n > uint32(len(atomText)) {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return atomText[start : start+n]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Atom) string() string {
0000000000000000000000000000000000000000;;		return atomText[a>>8 : a>>8+a&0xff]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fnv computes the FNV hash with an arbitrary starting value h.
0000000000000000000000000000000000000000;;	func fnv(h uint32, s []byte) uint32 {
0000000000000000000000000000000000000000;;		for i := range s {
0000000000000000000000000000000000000000;;			h ^= uint32(s[i])
0000000000000000000000000000000000000000;;			h *= 16777619
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func match(s string, t []byte) bool {
0000000000000000000000000000000000000000;;		for i, c := range t {
0000000000000000000000000000000000000000;;			if s[i] != c {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lookup returns the atom whose name is s. It returns zero if there is no
0000000000000000000000000000000000000000;;	// such atom. The lookup is case sensitive.
0000000000000000000000000000000000000000;;	func Lookup(s []byte) Atom {
0000000000000000000000000000000000000000;;		if len(s) == 0 || len(s) > maxAtomLen {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := fnv(hash0, s)
0000000000000000000000000000000000000000;;		if a := table[h&uint32(len(table)-1)]; int(a&0xff) == len(s) && match(a.string(), s) {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a := table[(h>>16)&uint32(len(table)-1)]; int(a&0xff) == len(s) && match(a.string(), s) {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string whose contents are equal to s. In that sense, it is
0000000000000000000000000000000000000000;;	// equivalent to string(s) but may be more efficient.
0000000000000000000000000000000000000000;;	func String(s []byte) string {
0000000000000000000000000000000000000000;;		if a := Lookup(s); a != 0 {
0000000000000000000000000000000000000000;;			return a.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(s)
0000000000000000000000000000000000000000;;	}
