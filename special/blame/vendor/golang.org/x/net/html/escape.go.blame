0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
c2bfd044362efe23765620d054edcdab7497bde5;third_party/src/code.google.com/p/go.net/html/escape.go[third_party/src/code.google.com/p/go.net/html/escape.go][vendor/golang.org/x/net/html/escape.go];	
0000000000000000000000000000000000000000;;	package html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These replacements permit compatibility with old numeric entities that
0000000000000000000000000000000000000000;;	// assumed Windows-1252 encoding.
0000000000000000000000000000000000000000;;	// https://html.spec.whatwg.org/multipage/syntax.html#consume-a-character-reference
0000000000000000000000000000000000000000;;	var replacementTable = [...]rune{
0000000000000000000000000000000000000000;;		'\u20AC', // First entry is what 0x80 should be replaced with.
0000000000000000000000000000000000000000;;		'\u0081',
0000000000000000000000000000000000000000;;		'\u201A',
0000000000000000000000000000000000000000;;		'\u0192',
0000000000000000000000000000000000000000;;		'\u201E',
0000000000000000000000000000000000000000;;		'\u2026',
0000000000000000000000000000000000000000;;		'\u2020',
0000000000000000000000000000000000000000;;		'\u2021',
0000000000000000000000000000000000000000;;		'\u02C6',
0000000000000000000000000000000000000000;;		'\u2030',
0000000000000000000000000000000000000000;;		'\u0160',
0000000000000000000000000000000000000000;;		'\u2039',
0000000000000000000000000000000000000000;;		'\u0152',
0000000000000000000000000000000000000000;;		'\u008D',
0000000000000000000000000000000000000000;;		'\u017D',
0000000000000000000000000000000000000000;;		'\u008F',
0000000000000000000000000000000000000000;;		'\u0090',
0000000000000000000000000000000000000000;;		'\u2018',
0000000000000000000000000000000000000000;;		'\u2019',
0000000000000000000000000000000000000000;;		'\u201C',
0000000000000000000000000000000000000000;;		'\u201D',
0000000000000000000000000000000000000000;;		'\u2022',
0000000000000000000000000000000000000000;;		'\u2013',
0000000000000000000000000000000000000000;;		'\u2014',
0000000000000000000000000000000000000000;;		'\u02DC',
0000000000000000000000000000000000000000;;		'\u2122',
0000000000000000000000000000000000000000;;		'\u0161',
0000000000000000000000000000000000000000;;		'\u203A',
0000000000000000000000000000000000000000;;		'\u0153',
0000000000000000000000000000000000000000;;		'\u009D',
0000000000000000000000000000000000000000;;		'\u017E',
0000000000000000000000000000000000000000;;		'\u0178', // Last entry is 0x9F.
0000000000000000000000000000000000000000;;		// 0x00->'\uFFFD' is handled programmatically.
0000000000000000000000000000000000000000;;		// 0x0D->'\u000D' is a no-op.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unescapeEntity reads an entity like "&lt;" from b[src:] and writes the
0000000000000000000000000000000000000000;;	// corresponding "<" to b[dst:], returning the incremented dst and src cursors.
0000000000000000000000000000000000000000;;	// Precondition: b[src] == '&' && dst <= src.
0000000000000000000000000000000000000000;;	// attribute should be true if parsing an attribute value.
0000000000000000000000000000000000000000;;	func unescapeEntity(b []byte, dst, src int, attribute bool) (dst1, src1 int) {
0000000000000000000000000000000000000000;;		// https://html.spec.whatwg.org/multipage/syntax.html#consume-a-character-reference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// i starts at 1 because we already know that s[0] == '&'.
0000000000000000000000000000000000000000;;		i, s := 1, b[src:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(s) <= 1 {
0000000000000000000000000000000000000000;;			b[dst] = b[src]
0000000000000000000000000000000000000000;;			return dst + 1, src + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s[i] == '#' {
0000000000000000000000000000000000000000;;			if len(s) <= 3 { // We need to have at least "&#.".
0000000000000000000000000000000000000000;;				b[dst] = b[src]
0000000000000000000000000000000000000000;;				return dst + 1, src + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			c := s[i]
0000000000000000000000000000000000000000;;			hex := false
0000000000000000000000000000000000000000;;			if c == 'x' || c == 'X' {
0000000000000000000000000000000000000000;;				hex = true
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			x := '\x00'
0000000000000000000000000000000000000000;;			for i < len(s) {
0000000000000000000000000000000000000000;;				c = s[i]
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				if hex {
0000000000000000000000000000000000000000;;					if '0' <= c && c <= '9' {
0000000000000000000000000000000000000000;;						x = 16*x + rune(c) - '0'
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					} else if 'a' <= c && c <= 'f' {
0000000000000000000000000000000000000000;;						x = 16*x + rune(c) - 'a' + 10
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					} else if 'A' <= c && c <= 'F' {
0000000000000000000000000000000000000000;;						x = 16*x + rune(c) - 'A' + 10
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if '0' <= c && c <= '9' {
0000000000000000000000000000000000000000;;					x = 10*x + rune(c) - '0'
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c != ';' {
0000000000000000000000000000000000000000;;					i--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i <= 3 { // No characters matched.
0000000000000000000000000000000000000000;;				b[dst] = b[src]
0000000000000000000000000000000000000000;;				return dst + 1, src + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if 0x80 <= x && x <= 0x9F {
0000000000000000000000000000000000000000;;				// Replace characters from Windows-1252 with UTF-8 equivalents.
0000000000000000000000000000000000000000;;				x = replacementTable[x-0x80]
0000000000000000000000000000000000000000;;			} else if x == 0 || (0xD800 <= x && x <= 0xDFFF) || x > 0x10FFFF {
0000000000000000000000000000000000000000;;				// Replace invalid characters with the replacement character.
0000000000000000000000000000000000000000;;				x = '\uFFFD'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return dst + utf8.EncodeRune(b[dst:], x), src + i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Consume the maximum number of characters possible, with the
0000000000000000000000000000000000000000;;		// consumed characters matching one of the named references.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i < len(s) {
0000000000000000000000000000000000000000;;			c := s[i]
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			// Lower-cased characters are more common in entities, so we check for them first.
0000000000000000000000000000000000000000;;			if 'a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' || '0' <= c && c <= '9' {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != ';' {
0000000000000000000000000000000000000000;;				i--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entityName := string(s[1:i])
0000000000000000000000000000000000000000;;		if entityName == "" {
0000000000000000000000000000000000000000;;			// No-op.
0000000000000000000000000000000000000000;;		} else if attribute && entityName[len(entityName)-1] != ';' && len(s) > i && s[i] == '=' {
0000000000000000000000000000000000000000;;			// No-op.
0000000000000000000000000000000000000000;;		} else if x := entity[entityName]; x != 0 {
0000000000000000000000000000000000000000;;			return dst + utf8.EncodeRune(b[dst:], x), src + i
0000000000000000000000000000000000000000;;		} else if x := entity2[entityName]; x[0] != 0 {
0000000000000000000000000000000000000000;;			dst1 := dst + utf8.EncodeRune(b[dst:], x[0])
0000000000000000000000000000000000000000;;			return dst1 + utf8.EncodeRune(b[dst1:], x[1]), src + i
0000000000000000000000000000000000000000;;		} else if !attribute {
0000000000000000000000000000000000000000;;			maxLen := len(entityName) - 1
0000000000000000000000000000000000000000;;			if maxLen > longestEntityWithoutSemicolon {
0000000000000000000000000000000000000000;;				maxLen = longestEntityWithoutSemicolon
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j := maxLen; j > 1; j-- {
0000000000000000000000000000000000000000;;				if x := entity[entityName[:j]]; x != 0 {
0000000000000000000000000000000000000000;;					return dst + utf8.EncodeRune(b[dst:], x), src + j + 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dst1, src1 = dst+i, src+i
0000000000000000000000000000000000000000;;		copy(b[dst:dst1], b[src:src1])
0000000000000000000000000000000000000000;;		return dst1, src1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unescape unescapes b's entities in-place, so that "a&lt;b" becomes "a<b".
0000000000000000000000000000000000000000;;	// attribute should be true if parsing an attribute value.
0000000000000000000000000000000000000000;;	func unescape(b []byte, attribute bool) []byte {
0000000000000000000000000000000000000000;;		for i, c := range b {
0000000000000000000000000000000000000000;;			if c == '&' {
0000000000000000000000000000000000000000;;				dst, src := unescapeEntity(b, i, i, attribute)
0000000000000000000000000000000000000000;;				for src < len(b) {
0000000000000000000000000000000000000000;;					c := b[src]
0000000000000000000000000000000000000000;;					if c == '&' {
0000000000000000000000000000000000000000;;						dst, src = unescapeEntity(b, dst, src, attribute)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						b[dst] = c
0000000000000000000000000000000000000000;;						dst, src = dst+1, src+1
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return b[0:dst]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lower lower-cases the A-Z bytes in b in-place, so that "aBc" becomes "abc".
0000000000000000000000000000000000000000;;	func lower(b []byte) []byte {
0000000000000000000000000000000000000000;;		for i, c := range b {
0000000000000000000000000000000000000000;;			if 'A' <= c && c <= 'Z' {
0000000000000000000000000000000000000000;;				b[i] = c + 'a' - 'A'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const escapedChars = "&'<>\"\r"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func escape(w writer, s string) error {
0000000000000000000000000000000000000000;;		i := strings.IndexAny(s, escapedChars)
0000000000000000000000000000000000000000;;		for i != -1 {
0000000000000000000000000000000000000000;;			if _, err := w.WriteString(s[:i]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var esc string
0000000000000000000000000000000000000000;;			switch s[i] {
0000000000000000000000000000000000000000;;			case '&':
0000000000000000000000000000000000000000;;				esc = "&amp;"
0000000000000000000000000000000000000000;;			case '\'':
0000000000000000000000000000000000000000;;				// "&#39;" is shorter than "&apos;" and apos was not in HTML until HTML5.
0000000000000000000000000000000000000000;;				esc = "&#39;"
0000000000000000000000000000000000000000;;			case '<':
0000000000000000000000000000000000000000;;				esc = "&lt;"
0000000000000000000000000000000000000000;;			case '>':
0000000000000000000000000000000000000000;;				esc = "&gt;"
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				// "&#34;" is shorter than "&quot;".
0000000000000000000000000000000000000000;;				esc = "&#34;"
0000000000000000000000000000000000000000;;			case '\r':
0000000000000000000000000000000000000000;;				esc = "&#13;"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("unrecognized escape character")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = s[i+1:]
0000000000000000000000000000000000000000;;			if _, err := w.WriteString(esc); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = strings.IndexAny(s, escapedChars)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := w.WriteString(s)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EscapeString escapes special characters like "<" to become "&lt;". It
0000000000000000000000000000000000000000;;	// escapes only five such characters: <, >, &, ' and ".
0000000000000000000000000000000000000000;;	// UnescapeString(EscapeString(s)) == s always holds, but the converse isn't
0000000000000000000000000000000000000000;;	// always true.
0000000000000000000000000000000000000000;;	func EscapeString(s string) string {
0000000000000000000000000000000000000000;;		if strings.IndexAny(s, escapedChars) == -1 {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		escape(&buf, s)
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnescapeString unescapes entities like "&lt;" to become "<". It unescapes a
0000000000000000000000000000000000000000;;	// larger range of entities than EscapeString escapes. For example, "&aacute;"
0000000000000000000000000000000000000000;;	// unescapes to "รก", as does "&#225;" and "&xE1;".
0000000000000000000000000000000000000000;;	// UnescapeString(EscapeString(s)) == s always holds, but the converse isn't
0000000000000000000000000000000000000000;;	// always true.
0000000000000000000000000000000000000000;;	func UnescapeString(s string) string {
0000000000000000000000000000000000000000;;		for _, c := range s {
0000000000000000000000000000000000000000;;			if c == '&' {
0000000000000000000000000000000000000000;;				return string(unescape([]byte(s), false))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
