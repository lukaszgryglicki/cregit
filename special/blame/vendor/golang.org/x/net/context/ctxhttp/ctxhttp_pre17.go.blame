0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5f86d3a99c832846d70d13f1c71f1c4ed2622a9c;;	
0000000000000000000000000000000000000000;;	// +build !go1.7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package ctxhttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nop() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		testHookContextDoneBeforeHeaders = nop
0000000000000000000000000000000000000000;;		testHookDoReturned               = nop
0000000000000000000000000000000000000000;;		testHookDidBodyClose             = nop
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do sends an HTTP request with the provided http.Client and returns an HTTP response.
0000000000000000000000000000000000000000;;	// If the client is nil, http.DefaultClient is used.
0000000000000000000000000000000000000000;;	// If the context is canceled or times out, ctx.Err() will be returned.
0000000000000000000000000000000000000000;;	func Do(ctx context.Context, client *http.Client, req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if client == nil {
0000000000000000000000000000000000000000;;			client = http.DefaultClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(djd): Respect any existing value of req.Cancel.
0000000000000000000000000000000000000000;;		cancel := make(chan struct{})
0000000000000000000000000000000000000000;;		req.Cancel = cancel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type responseAndError struct {
0000000000000000000000000000000000000000;;			resp *http.Response
0000000000000000000000000000000000000000;;			err  error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := make(chan responseAndError, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make local copies of test hooks closed over by goroutines below.
0000000000000000000000000000000000000000;;		// Prevents data races in tests.
0000000000000000000000000000000000000000;;		testHookDoReturned := testHookDoReturned
0000000000000000000000000000000000000000;;		testHookDidBodyClose := testHookDidBodyClose
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			resp, err := client.Do(req)
0000000000000000000000000000000000000000;;			testHookDoReturned()
0000000000000000000000000000000000000000;;			result <- responseAndError{resp, err}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resp *http.Response
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			testHookContextDoneBeforeHeaders()
0000000000000000000000000000000000000000;;			close(cancel)
0000000000000000000000000000000000000000;;			// Clean up after the goroutine calling client.Do:
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				if r := <-result; r.resp != nil {
0000000000000000000000000000000000000000;;					testHookDidBodyClose()
0000000000000000000000000000000000000000;;					r.resp.Body.Close()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			return nil, ctx.Err()
0000000000000000000000000000000000000000;;		case r := <-result:
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			resp, err = r.resp, r.err
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				close(cancel)
0000000000000000000000000000000000000000;;			case <-c:
0000000000000000000000000000000000000000;;				// The response's Body is closed.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		resp.Body = &notifyingReader{resp.Body, c}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get issues a GET request via the Do function.
0000000000000000000000000000000000000000;;	func Get(ctx context.Context, client *http.Client, url string) (*http.Response, error) {
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", url, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Do(ctx, client, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Head issues a HEAD request via the Do function.
0000000000000000000000000000000000000000;;	func Head(ctx context.Context, client *http.Client, url string) (*http.Response, error) {
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("HEAD", url, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Do(ctx, client, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Post issues a POST request via the Do function.
0000000000000000000000000000000000000000;;	func Post(ctx context.Context, client *http.Client, url string, bodyType string, body io.Reader) (*http.Response, error) {
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", url, body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", bodyType)
0000000000000000000000000000000000000000;;		return Do(ctx, client, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PostForm issues a POST request via the Do function.
0000000000000000000000000000000000000000;;	func PostForm(ctx context.Context, client *http.Client, url string, data url.Values) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return Post(ctx, client, url, "application/x-www-form-urlencoded", strings.NewReader(data.Encode()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// notifyingReader is an io.ReadCloser that closes the notify channel after
0000000000000000000000000000000000000000;;	// Close is called or a Read fails on the underlying ReadCloser.
0000000000000000000000000000000000000000;;	type notifyingReader struct {
0000000000000000000000000000000000000000;;		io.ReadCloser
0000000000000000000000000000000000000000;;		notify chan<- struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *notifyingReader) Read(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		n, err := r.ReadCloser.Read(p)
0000000000000000000000000000000000000000;;		if err != nil && r.notify != nil {
0000000000000000000000000000000000000000;;			close(r.notify)
0000000000000000000000000000000000000000;;			r.notify = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *notifyingReader) Close() error {
0000000000000000000000000000000000000000;;		err := r.ReadCloser.Close()
0000000000000000000000000000000000000000;;		if r.notify != nil {
0000000000000000000000000000000000000000;;			close(r.notify)
0000000000000000000000000000000000000000;;			r.notify = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
