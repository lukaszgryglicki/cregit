0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5f86d3a99c832846d70d13f1c71f1c4ed2622a9c;;	
0000000000000000000000000000000000000000;;	// +build !go1.7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An emptyCtx is never canceled, has no values, and has no deadline.  It is not
0000000000000000000000000000000000000000;;	// struct{}, since vars of this type must have distinct addresses.
0000000000000000000000000000000000000000;;	type emptyCtx int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*emptyCtx) Done() <-chan struct{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*emptyCtx) Err() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*emptyCtx) Value(key interface{}) interface{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *emptyCtx) String() string {
0000000000000000000000000000000000000000;;		switch e {
0000000000000000000000000000000000000000;;		case background:
0000000000000000000000000000000000000000;;			return "context.Background"
0000000000000000000000000000000000000000;;		case todo:
0000000000000000000000000000000000000000;;			return "context.TODO"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "unknown empty Context"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		background = new(emptyCtx)
0000000000000000000000000000000000000000;;		todo       = new(emptyCtx)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Canceled is the error returned by Context.Err when the context is canceled.
0000000000000000000000000000000000000000;;	var Canceled = errors.New("context canceled")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeadlineExceeded is the error returned by Context.Err when the context's
0000000000000000000000000000000000000000;;	// deadline passes.
0000000000000000000000000000000000000000;;	var DeadlineExceeded = errors.New("context deadline exceeded")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithCancel returns a copy of parent with a new Done channel. The returned
0000000000000000000000000000000000000000;;	// context's Done channel is closed when the returned cancel function is called
0000000000000000000000000000000000000000;;	// or when the parent context's Done channel is closed, whichever happens first.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Canceling this context releases resources associated with it, so code should
0000000000000000000000000000000000000000;;	// call cancel as soon as the operations running in this Context complete.
0000000000000000000000000000000000000000;;	func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
0000000000000000000000000000000000000000;;		c := newCancelCtx(parent)
0000000000000000000000000000000000000000;;		propagateCancel(parent, c)
0000000000000000000000000000000000000000;;		return c, func() { c.cancel(true, Canceled) }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newCancelCtx returns an initialized cancelCtx.
0000000000000000000000000000000000000000;;	func newCancelCtx(parent Context) *cancelCtx {
0000000000000000000000000000000000000000;;		return &cancelCtx{
0000000000000000000000000000000000000000;;			Context: parent,
0000000000000000000000000000000000000000;;			done:    make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// propagateCancel arranges for child to be canceled when parent is.
0000000000000000000000000000000000000000;;	func propagateCancel(parent Context, child canceler) {
0000000000000000000000000000000000000000;;		if parent.Done() == nil {
0000000000000000000000000000000000000000;;			return // parent is never canceled
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p, ok := parentCancelCtx(parent); ok {
0000000000000000000000000000000000000000;;			p.mu.Lock()
0000000000000000000000000000000000000000;;			if p.err != nil {
0000000000000000000000000000000000000000;;				// parent has already been canceled
0000000000000000000000000000000000000000;;				child.cancel(false, p.err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if p.children == nil {
0000000000000000000000000000000000000000;;					p.children = make(map[canceler]bool)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.children[child] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.mu.Unlock()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-parent.Done():
0000000000000000000000000000000000000000;;					child.cancel(false, parent.Err())
0000000000000000000000000000000000000000;;				case <-child.Done():
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parentCancelCtx follows a chain of parent references until it finds a
0000000000000000000000000000000000000000;;	// *cancelCtx.  This function understands how each of the concrete types in this
0000000000000000000000000000000000000000;;	// package represents its parent.
0000000000000000000000000000000000000000;;	func parentCancelCtx(parent Context) (*cancelCtx, bool) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			switch c := parent.(type) {
0000000000000000000000000000000000000000;;			case *cancelCtx:
0000000000000000000000000000000000000000;;				return c, true
0000000000000000000000000000000000000000;;			case *timerCtx:
0000000000000000000000000000000000000000;;				return c.cancelCtx, true
0000000000000000000000000000000000000000;;			case *valueCtx:
0000000000000000000000000000000000000000;;				parent = c.Context
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeChild removes a context from its parent.
0000000000000000000000000000000000000000;;	func removeChild(parent Context, child canceler) {
0000000000000000000000000000000000000000;;		p, ok := parentCancelCtx(parent)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		if p.children != nil {
0000000000000000000000000000000000000000;;			delete(p.children, child)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A canceler is a context type that can be canceled directly.  The
0000000000000000000000000000000000000000;;	// implementations are *cancelCtx and *timerCtx.
0000000000000000000000000000000000000000;;	type canceler interface {
0000000000000000000000000000000000000000;;		cancel(removeFromParent bool, err error)
0000000000000000000000000000000000000000;;		Done() <-chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A cancelCtx can be canceled.  When canceled, it also cancels any children
0000000000000000000000000000000000000000;;	// that implement canceler.
0000000000000000000000000000000000000000;;	type cancelCtx struct {
0000000000000000000000000000000000000000;;		Context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		done chan struct{} // closed by the first cancel call.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu       sync.Mutex
0000000000000000000000000000000000000000;;		children map[canceler]bool // set to nil by the first cancel call
0000000000000000000000000000000000000000;;		err      error             // set to non-nil by the first cancel call
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cancelCtx) Done() <-chan struct{} {
0000000000000000000000000000000000000000;;		return c.done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cancelCtx) Err() error {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		defer c.mu.Unlock()
0000000000000000000000000000000000000000;;		return c.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cancelCtx) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v.WithCancel", c.Context)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cancel closes c.done, cancels each of c's children, and, if
0000000000000000000000000000000000000000;;	// removeFromParent is true, removes c from its parent's children.
0000000000000000000000000000000000000000;;	func (c *cancelCtx) cancel(removeFromParent bool, err error) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			panic("context: internal error: missing cancel error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		if c.err != nil {
0000000000000000000000000000000000000000;;			c.mu.Unlock()
0000000000000000000000000000000000000000;;			return // already canceled
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.err = err
0000000000000000000000000000000000000000;;		close(c.done)
0000000000000000000000000000000000000000;;		for child := range c.children {
0000000000000000000000000000000000000000;;			// NOTE: acquiring the child's lock while holding parent's lock.
0000000000000000000000000000000000000000;;			child.cancel(false, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.children = nil
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if removeFromParent {
0000000000000000000000000000000000000000;;			removeChild(c.Context, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithDeadline returns a copy of the parent context with the deadline adjusted
0000000000000000000000000000000000000000;;	// to be no later than d.  If the parent's deadline is already earlier than d,
0000000000000000000000000000000000000000;;	// WithDeadline(parent, d) is semantically equivalent to parent.  The returned
0000000000000000000000000000000000000000;;	// context's Done channel is closed when the deadline expires, when the returned
0000000000000000000000000000000000000000;;	// cancel function is called, or when the parent context's Done channel is
0000000000000000000000000000000000000000;;	// closed, whichever happens first.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Canceling this context releases resources associated with it, so code should
0000000000000000000000000000000000000000;;	// call cancel as soon as the operations running in this Context complete.
0000000000000000000000000000000000000000;;	func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {
0000000000000000000000000000000000000000;;		if cur, ok := parent.Deadline(); ok && cur.Before(deadline) {
0000000000000000000000000000000000000000;;			// The current deadline is already sooner than the new one.
0000000000000000000000000000000000000000;;			return WithCancel(parent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := &timerCtx{
0000000000000000000000000000000000000000;;			cancelCtx: newCancelCtx(parent),
0000000000000000000000000000000000000000;;			deadline:  deadline,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		propagateCancel(parent, c)
0000000000000000000000000000000000000000;;		d := deadline.Sub(time.Now())
0000000000000000000000000000000000000000;;		if d <= 0 {
0000000000000000000000000000000000000000;;			c.cancel(true, DeadlineExceeded) // deadline has already passed
0000000000000000000000000000000000000000;;			return c, func() { c.cancel(true, Canceled) }
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		defer c.mu.Unlock()
0000000000000000000000000000000000000000;;		if c.err == nil {
0000000000000000000000000000000000000000;;			c.timer = time.AfterFunc(d, func() {
0000000000000000000000000000000000000000;;				c.cancel(true, DeadlineExceeded)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, func() { c.cancel(true, Canceled) }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A timerCtx carries a timer and a deadline.  It embeds a cancelCtx to
0000000000000000000000000000000000000000;;	// implement Done and Err.  It implements cancel by stopping its timer then
0000000000000000000000000000000000000000;;	// delegating to cancelCtx.cancel.
0000000000000000000000000000000000000000;;	type timerCtx struct {
0000000000000000000000000000000000000000;;		*cancelCtx
0000000000000000000000000000000000000000;;		timer *time.Timer // Under cancelCtx.mu.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deadline time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *timerCtx) Deadline() (deadline time.Time, ok bool) {
0000000000000000000000000000000000000000;;		return c.deadline, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *timerCtx) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v.WithDeadline(%s [%s])", c.cancelCtx.Context, c.deadline, c.deadline.Sub(time.Now()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *timerCtx) cancel(removeFromParent bool, err error) {
0000000000000000000000000000000000000000;;		c.cancelCtx.cancel(false, err)
0000000000000000000000000000000000000000;;		if removeFromParent {
0000000000000000000000000000000000000000;;			// Remove this timerCtx from its parent cancelCtx's children.
0000000000000000000000000000000000000000;;			removeChild(c.cancelCtx.Context, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		if c.timer != nil {
0000000000000000000000000000000000000000;;			c.timer.Stop()
0000000000000000000000000000000000000000;;			c.timer = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Canceling this context releases resources associated with it, so code should
0000000000000000000000000000000000000000;;	// call cancel as soon as the operations running in this Context complete:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 	func slowOperationWithTimeout(ctx context.Context) (Result, error) {
0000000000000000000000000000000000000000;;	// 		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
0000000000000000000000000000000000000000;;	// 		defer cancel()  // releases resources if slowOperation completes before timeout elapses
0000000000000000000000000000000000000000;;	// 		return slowOperation(ctx)
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
0000000000000000000000000000000000000000;;		return WithDeadline(parent, time.Now().Add(timeout))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithValue returns a copy of parent in which the value associated with key is
0000000000000000000000000000000000000000;;	// val.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use context Values only for request-scoped data that transits processes and
0000000000000000000000000000000000000000;;	// APIs, not for passing optional parameters to functions.
0000000000000000000000000000000000000000;;	func WithValue(parent Context, key interface{}, val interface{}) Context {
0000000000000000000000000000000000000000;;		return &valueCtx{parent, key, val}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A valueCtx carries a key-value pair.  It implements Value for that key and
0000000000000000000000000000000000000000;;	// delegates all other calls to the embedded Context.
0000000000000000000000000000000000000000;;	type valueCtx struct {
0000000000000000000000000000000000000000;;		Context
0000000000000000000000000000000000000000;;		key, val interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *valueCtx) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v.WithValue(%#v, %#v)", c.Context, c.key, c.val)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *valueCtx) Value(key interface{}) interface{} {
0000000000000000000000000000000000000000;;		if c.key == key {
0000000000000000000000000000000000000000;;			return c.val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.Context.Value(key)
0000000000000000000000000000000000000000;;	}
