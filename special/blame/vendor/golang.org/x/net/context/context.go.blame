0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
b03c0a91f632235ea3b91ecd706c312119c76d09;Godeps/_workspace/src/code.google.com/p/go.net/context/context.go[Godeps/_workspace/src/code.google.com/p/go.net/context/context.go][vendor/golang.org/x/net/context/context.go];	
0000000000000000000000000000000000000000;;	// Package context defines the Context type, which carries deadlines,
0000000000000000000000000000000000000000;;	// cancelation signals, and other request-scoped values across API boundaries
0000000000000000000000000000000000000000;;	// and between processes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Incoming requests to a server should create a Context, and outgoing calls to
0000000000000000000000000000000000000000;;	// servers should accept a Context.  The chain of function calls between must
0000000000000000000000000000000000000000;;	// propagate the Context, optionally replacing it with a modified copy created
0000000000000000000000000000000000000000;;	// using WithDeadline, WithTimeout, WithCancel, or WithValue.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Programs that use Contexts should follow these rules to keep interfaces
0000000000000000000000000000000000000000;;	// consistent across packages and enable static analysis tools to check context
0000000000000000000000000000000000000000;;	// propagation:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Do not store Contexts inside a struct type; instead, pass a Context
0000000000000000000000000000000000000000;;	// explicitly to each function that needs it.  The Context should be the first
0000000000000000000000000000000000000000;;	// parameter, typically named ctx:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 	func DoSomething(ctx context.Context, arg Arg) error {
0000000000000000000000000000000000000000;;	// 		// ... use ctx ...
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Do not pass a nil Context, even if a function permits it.  Pass context.TODO
0000000000000000000000000000000000000000;;	// if you are unsure about which Context to use.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use context Values only for request-scoped data that transits processes and
0000000000000000000000000000000000000000;;	// APIs, not for passing optional parameters to functions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The same Context may be passed to functions running in different goroutines;
0000000000000000000000000000000000000000;;	// Contexts are safe for simultaneous use by multiple goroutines.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See http://blog.golang.org/context for example code for a server that uses
0000000000000000000000000000000000000000;;	// Contexts.
0000000000000000000000000000000000000000;;	package context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Context carries a deadline, a cancelation signal, and other values across
0000000000000000000000000000000000000000;;	// API boundaries.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Context's methods may be called by multiple goroutines simultaneously.
0000000000000000000000000000000000000000;;	type Context interface {
0000000000000000000000000000000000000000;;		// Deadline returns the time when work done on behalf of this context
0000000000000000000000000000000000000000;;		// should be canceled.  Deadline returns ok==false when no deadline is
0000000000000000000000000000000000000000;;		// set.  Successive calls to Deadline return the same results.
0000000000000000000000000000000000000000;;		Deadline() (deadline time.Time, ok bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Done returns a channel that's closed when work done on behalf of this
0000000000000000000000000000000000000000;;		// context should be canceled.  Done may return nil if this context can
0000000000000000000000000000000000000000;;		// never be canceled.  Successive calls to Done return the same value.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// WithCancel arranges for Done to be closed when cancel is called;
0000000000000000000000000000000000000000;;		// WithDeadline arranges for Done to be closed when the deadline
0000000000000000000000000000000000000000;;		// expires; WithTimeout arranges for Done to be closed when the timeout
0000000000000000000000000000000000000000;;		// elapses.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Done is provided for use in select statements:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//  // Stream generates values with DoSomething and sends them to out
0000000000000000000000000000000000000000;;		//  // until DoSomething returns an error or ctx.Done is closed.
0000000000000000000000000000000000000000;;		//  func Stream(ctx context.Context, out chan<- Value) error {
0000000000000000000000000000000000000000;;		//  	for {
0000000000000000000000000000000000000000;;		//  		v, err := DoSomething(ctx)
0000000000000000000000000000000000000000;;		//  		if err != nil {
0000000000000000000000000000000000000000;;		//  			return err
0000000000000000000000000000000000000000;;		//  		}
0000000000000000000000000000000000000000;;		//  		select {
0000000000000000000000000000000000000000;;		//  		case <-ctx.Done():
0000000000000000000000000000000000000000;;		//  			return ctx.Err()
0000000000000000000000000000000000000000;;		//  		case out <- v:
0000000000000000000000000000000000000000;;		//  		}
0000000000000000000000000000000000000000;;		//  	}
0000000000000000000000000000000000000000;;		//  }
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// See http://blog.golang.org/pipelines for more examples of how to use
0000000000000000000000000000000000000000;;		// a Done channel for cancelation.
0000000000000000000000000000000000000000;;		Done() <-chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Err returns a non-nil error value after Done is closed.  Err returns
0000000000000000000000000000000000000000;;		// Canceled if the context was canceled or DeadlineExceeded if the
0000000000000000000000000000000000000000;;		// context's deadline passed.  No other values for Err are defined.
0000000000000000000000000000000000000000;;		// After Done is closed, successive calls to Err return the same value.
0000000000000000000000000000000000000000;;		Err() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Value returns the value associated with this context for key, or nil
0000000000000000000000000000000000000000;;		// if no value is associated with key.  Successive calls to Value with
0000000000000000000000000000000000000000;;		// the same key returns the same result.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Use context values only for request-scoped data that transits
0000000000000000000000000000000000000000;;		// processes and API boundaries, not for passing optional parameters to
0000000000000000000000000000000000000000;;		// functions.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// A key identifies a specific value in a Context.  Functions that wish
0000000000000000000000000000000000000000;;		// to store values in Context typically allocate a key in a global
0000000000000000000000000000000000000000;;		// variable then use that key as the argument to context.WithValue and
0000000000000000000000000000000000000000;;		// Context.Value.  A key can be any type that supports equality;
0000000000000000000000000000000000000000;;		// packages should define keys as an unexported type to avoid
0000000000000000000000000000000000000000;;		// collisions.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Packages that define a Context key should provide type-safe accessors
0000000000000000000000000000000000000000;;		// for the values stores using that key:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	// Package user defines a User type that's stored in Contexts.
0000000000000000000000000000000000000000;;		// 	package user
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	import "golang.org/x/net/context"
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	// User is the type of value stored in the Contexts.
0000000000000000000000000000000000000000;;		// 	type User struct {...}
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	// key is an unexported type for keys defined in this package.
0000000000000000000000000000000000000000;;		// 	// This prevents collisions with keys defined in other packages.
0000000000000000000000000000000000000000;;		// 	type key int
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	// userKey is the key for user.User values in Contexts.  It is
0000000000000000000000000000000000000000;;		// 	// unexported; clients use user.NewContext and user.FromContext
0000000000000000000000000000000000000000;;		// 	// instead of using this key directly.
0000000000000000000000000000000000000000;;		// 	var userKey key = 0
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	// NewContext returns a new Context that carries value u.
0000000000000000000000000000000000000000;;		// 	func NewContext(ctx context.Context, u *User) context.Context {
0000000000000000000000000000000000000000;;		// 		return context.WithValue(ctx, userKey, u)
0000000000000000000000000000000000000000;;		// 	}
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	// FromContext returns the User value stored in ctx, if any.
0000000000000000000000000000000000000000;;		// 	func FromContext(ctx context.Context) (*User, bool) {
0000000000000000000000000000000000000000;;		// 		u, ok := ctx.Value(userKey).(*User)
0000000000000000000000000000000000000000;;		// 		return u, ok
0000000000000000000000000000000000000000;;		// 	}
0000000000000000000000000000000000000000;;		Value(key interface{}) interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Background returns a non-nil, empty Context. It is never canceled, has no
0000000000000000000000000000000000000000;;	// values, and has no deadline.  It is typically used by the main function,
0000000000000000000000000000000000000000;;	// initialization, and tests, and as the top-level Context for incoming
0000000000000000000000000000000000000000;;	// requests.
0000000000000000000000000000000000000000;;	func Background() Context {
0000000000000000000000000000000000000000;;		return background
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO returns a non-nil, empty Context.  Code should use context.TODO when
0000000000000000000000000000000000000000;;	// it's unclear which Context to use or it is not yet available (because the
0000000000000000000000000000000000000000;;	// surrounding function has not yet been extended to accept a Context
0000000000000000000000000000000000000000;;	// parameter).  TODO is recognized by static analysis tools that determine
0000000000000000000000000000000000000000;;	// whether Contexts are propagated correctly in a program.
0000000000000000000000000000000000000000;;	func TODO() Context {
0000000000000000000000000000000000000000;;		return todo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A CancelFunc tells an operation to abandon its work.
0000000000000000000000000000000000000000;;	// A CancelFunc does not wait for the work to stop.
0000000000000000000000000000000000000000;;	// After the first call, subsequent calls to a CancelFunc do nothing.
0000000000000000000000000000000000000000;;	type CancelFunc func()
