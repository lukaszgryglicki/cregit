0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
6cf8b80e5da3322f98ca221bde5f9ff5eb4fa392;Godeps/_workspace/src/golang.org/x/net/internal/timeseries/timeseries.go[Godeps/_workspace/src/golang.org/x/net/internal/timeseries/timeseries.go][vendor/golang.org/x/net/internal/timeseries/timeseries.go];	
0000000000000000000000000000000000000000;;	// Package timeseries implements a time series structure for stats collection.
0000000000000000000000000000000000000000;;	package timeseries
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		timeSeriesNumBuckets       = 64
0000000000000000000000000000000000000000;;		minuteHourSeriesNumBuckets = 60
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var timeSeriesResolutions = []time.Duration{
0000000000000000000000000000000000000000;;		1 * time.Second,
0000000000000000000000000000000000000000;;		10 * time.Second,
0000000000000000000000000000000000000000;;		1 * time.Minute,
0000000000000000000000000000000000000000;;		10 * time.Minute,
0000000000000000000000000000000000000000;;		1 * time.Hour,
0000000000000000000000000000000000000000;;		6 * time.Hour,
0000000000000000000000000000000000000000;;		24 * time.Hour,          // 1 day
0000000000000000000000000000000000000000;;		7 * 24 * time.Hour,      // 1 week
0000000000000000000000000000000000000000;;		4 * 7 * 24 * time.Hour,  // 4 weeks
0000000000000000000000000000000000000000;;		16 * 7 * 24 * time.Hour, // 16 weeks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var minuteHourSeriesResolutions = []time.Duration{
0000000000000000000000000000000000000000;;		1 * time.Second,
0000000000000000000000000000000000000000;;		1 * time.Minute,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Observable is a kind of data that can be aggregated in a time series.
0000000000000000000000000000000000000000;;	type Observable interface {
0000000000000000000000000000000000000000;;		Multiply(ratio float64)    // Multiplies the data in self by a given ratio
0000000000000000000000000000000000000000;;		Add(other Observable)      // Adds the data from a different observation to self
0000000000000000000000000000000000000000;;		Clear()                    // Clears the observation so it can be reused.
0000000000000000000000000000000000000000;;		CopyFrom(other Observable) // Copies the contents of a given observation to self
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float attaches the methods of Observable to a float64.
0000000000000000000000000000000000000000;;	type Float float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFloat returns a Float.
0000000000000000000000000000000000000000;;	func NewFloat() Observable {
0000000000000000000000000000000000000000;;		f := Float(0)
0000000000000000000000000000000000000000;;		return &f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the float as a string.
0000000000000000000000000000000000000000;;	func (f *Float) String() string { return fmt.Sprintf("%g", f.Value()) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value returns the float's value.
0000000000000000000000000000000000000000;;	func (f *Float) Value() float64 { return float64(*f) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Float) Multiply(ratio float64) { *f *= Float(ratio) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Float) Add(other Observable) {
0000000000000000000000000000000000000000;;		o := other.(*Float)
0000000000000000000000000000000000000000;;		*f += *o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Float) Clear() { *f = 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Float) CopyFrom(other Observable) {
0000000000000000000000000000000000000000;;		o := other.(*Float)
0000000000000000000000000000000000000000;;		*f = *o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Clock tells the current time.
0000000000000000000000000000000000000000;;	type Clock interface {
0000000000000000000000000000000000000000;;		Time() time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type defaultClock int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultClockInstance defaultClock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (defaultClock) Time() time.Time { return time.Now() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Information kept per level. Each level consists of a circular list of
0000000000000000000000000000000000000000;;	// observations. The start of the level may be derived from end and the
0000000000000000000000000000000000000000;;	// len(buckets) * sizeInMillis.
0000000000000000000000000000000000000000;;	type tsLevel struct {
0000000000000000000000000000000000000000;;		oldest   int               // index to oldest bucketed Observable
0000000000000000000000000000000000000000;;		newest   int               // index to newest bucketed Observable
0000000000000000000000000000000000000000;;		end      time.Time         // end timestamp for this level
0000000000000000000000000000000000000000;;		size     time.Duration     // duration of the bucketed Observable
0000000000000000000000000000000000000000;;		buckets  []Observable      // collections of observations
0000000000000000000000000000000000000000;;		provider func() Observable // used for creating new Observable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tsLevel) Clear() {
0000000000000000000000000000000000000000;;		l.oldest = 0
0000000000000000000000000000000000000000;;		l.newest = len(l.buckets) - 1
0000000000000000000000000000000000000000;;		l.end = time.Time{}
0000000000000000000000000000000000000000;;		for i := range l.buckets {
0000000000000000000000000000000000000000;;			if l.buckets[i] != nil {
0000000000000000000000000000000000000000;;				l.buckets[i].Clear()
0000000000000000000000000000000000000000;;				l.buckets[i] = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tsLevel) InitLevel(size time.Duration, numBuckets int, f func() Observable) {
0000000000000000000000000000000000000000;;		l.size = size
0000000000000000000000000000000000000000;;		l.provider = f
0000000000000000000000000000000000000000;;		l.buckets = make([]Observable, numBuckets)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keeps a sequence of levels. Each level is responsible for storing data at
0000000000000000000000000000000000000000;;	// a given resolution. For example, the first level stores data at a one
0000000000000000000000000000000000000000;;	// minute resolution while the second level stores data at a one hour
0000000000000000000000000000000000000000;;	// resolution.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Each level is represented by a sequence of buckets. Each bucket spans an
0000000000000000000000000000000000000000;;	// interval equal to the resolution of the level. New observations are added
0000000000000000000000000000000000000000;;	// to the last bucket.
0000000000000000000000000000000000000000;;	type timeSeries struct {
0000000000000000000000000000000000000000;;		provider    func() Observable // make more Observable
0000000000000000000000000000000000000000;;		numBuckets  int               // number of buckets in each level
0000000000000000000000000000000000000000;;		levels      []*tsLevel        // levels of bucketed Observable
0000000000000000000000000000000000000000;;		lastAdd     time.Time         // time of last Observable tracked
0000000000000000000000000000000000000000;;		total       Observable        // convenient aggregation of all Observable
0000000000000000000000000000000000000000;;		clock       Clock             // Clock for getting current time
0000000000000000000000000000000000000000;;		pending     Observable        // observations not yet bucketed
0000000000000000000000000000000000000000;;		pendingTime time.Time         // what time are we keeping in pending
0000000000000000000000000000000000000000;;		dirty       bool              // if there are pending observations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// init initializes a level according to the supplied criteria.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) init(resolutions []time.Duration, f func() Observable, numBuckets int, clock Clock) {
0000000000000000000000000000000000000000;;		ts.provider = f
0000000000000000000000000000000000000000;;		ts.numBuckets = numBuckets
0000000000000000000000000000000000000000;;		ts.clock = clock
0000000000000000000000000000000000000000;;		ts.levels = make([]*tsLevel, len(resolutions))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range resolutions {
0000000000000000000000000000000000000000;;			if i > 0 && resolutions[i-1] >= resolutions[i] {
0000000000000000000000000000000000000000;;				log.Print("timeseries: resolutions must be monotonically increasing")
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newLevel := new(tsLevel)
0000000000000000000000000000000000000000;;			newLevel.InitLevel(resolutions[i], ts.numBuckets, ts.provider)
0000000000000000000000000000000000000000;;			ts.levels[i] = newLevel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ts.Clear()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clear removes all observations from the time series.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) Clear() {
0000000000000000000000000000000000000000;;		ts.lastAdd = time.Time{}
0000000000000000000000000000000000000000;;		ts.total = ts.resetObservation(ts.total)
0000000000000000000000000000000000000000;;		ts.pending = ts.resetObservation(ts.pending)
0000000000000000000000000000000000000000;;		ts.pendingTime = time.Time{}
0000000000000000000000000000000000000000;;		ts.dirty = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range ts.levels {
0000000000000000000000000000000000000000;;			ts.levels[i].Clear()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add records an observation at the current time.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) Add(observation Observable) {
0000000000000000000000000000000000000000;;		ts.AddWithTime(observation, ts.clock.Time())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddWithTime records an observation at the specified time.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) AddWithTime(observation Observable, t time.Time) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		smallBucketDuration := ts.levels[0].size
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.After(ts.lastAdd) {
0000000000000000000000000000000000000000;;			ts.lastAdd = t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.After(ts.pendingTime) {
0000000000000000000000000000000000000000;;			ts.advance(t)
0000000000000000000000000000000000000000;;			ts.mergePendingUpdates()
0000000000000000000000000000000000000000;;			ts.pendingTime = ts.levels[0].end
0000000000000000000000000000000000000000;;			ts.pending.CopyFrom(observation)
0000000000000000000000000000000000000000;;			ts.dirty = true
0000000000000000000000000000000000000000;;		} else if t.After(ts.pendingTime.Add(-1 * smallBucketDuration)) {
0000000000000000000000000000000000000000;;			// The observation is close enough to go into the pending bucket.
0000000000000000000000000000000000000000;;			// This compensates for clock skewing and small scheduling delays
0000000000000000000000000000000000000000;;			// by letting the update stay in the fast path.
0000000000000000000000000000000000000000;;			ts.pending.Add(observation)
0000000000000000000000000000000000000000;;			ts.dirty = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ts.mergeValue(observation, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeValue inserts the observation at the specified time in the past into all levels.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) mergeValue(observation Observable, t time.Time) {
0000000000000000000000000000000000000000;;		for _, level := range ts.levels {
0000000000000000000000000000000000000000;;			index := (ts.numBuckets - 1) - int(level.end.Sub(t)/level.size)
0000000000000000000000000000000000000000;;			if 0 <= index && index < ts.numBuckets {
0000000000000000000000000000000000000000;;				bucketNumber := (level.oldest + index) % ts.numBuckets
0000000000000000000000000000000000000000;;				if level.buckets[bucketNumber] == nil {
0000000000000000000000000000000000000000;;					level.buckets[bucketNumber] = level.provider()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				level.buckets[bucketNumber].Add(observation)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ts.total.Add(observation)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergePendingUpdates applies the pending updates into all levels.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) mergePendingUpdates() {
0000000000000000000000000000000000000000;;		if ts.dirty {
0000000000000000000000000000000000000000;;			ts.mergeValue(ts.pending, ts.pendingTime)
0000000000000000000000000000000000000000;;			ts.pending = ts.resetObservation(ts.pending)
0000000000000000000000000000000000000000;;			ts.dirty = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// advance cycles the buckets at each level until the latest bucket in
0000000000000000000000000000000000000000;;	// each level can hold the time specified.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) advance(t time.Time) {
0000000000000000000000000000000000000000;;		if !t.After(ts.levels[0].end) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(ts.levels); i++ {
0000000000000000000000000000000000000000;;			level := ts.levels[i]
0000000000000000000000000000000000000000;;			if !level.end.Before(t) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the time is sufficiently far, just clear the level and advance
0000000000000000000000000000000000000000;;			// directly.
0000000000000000000000000000000000000000;;			if !t.Before(level.end.Add(level.size * time.Duration(ts.numBuckets))) {
0000000000000000000000000000000000000000;;				for _, b := range level.buckets {
0000000000000000000000000000000000000000;;					ts.resetObservation(b)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				level.end = time.Unix(0, (t.UnixNano()/level.size.Nanoseconds())*level.size.Nanoseconds())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for t.After(level.end) {
0000000000000000000000000000000000000000;;				level.end = level.end.Add(level.size)
0000000000000000000000000000000000000000;;				level.newest = level.oldest
0000000000000000000000000000000000000000;;				level.oldest = (level.oldest + 1) % ts.numBuckets
0000000000000000000000000000000000000000;;				ts.resetObservation(level.buckets[level.newest])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t = level.end
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Latest returns the sum of the num latest buckets from the level.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) Latest(level, num int) Observable {
0000000000000000000000000000000000000000;;		now := ts.clock.Time()
0000000000000000000000000000000000000000;;		if ts.levels[0].end.Before(now) {
0000000000000000000000000000000000000000;;			ts.advance(now)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ts.mergePendingUpdates()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := ts.provider()
0000000000000000000000000000000000000000;;		l := ts.levels[level]
0000000000000000000000000000000000000000;;		index := l.newest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < num; i++ {
0000000000000000000000000000000000000000;;			if l.buckets[index] != nil {
0000000000000000000000000000000000000000;;				result.Add(l.buckets[index])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if index == 0 {
0000000000000000000000000000000000000000;;				index = ts.numBuckets
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			index--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LatestBuckets returns a copy of the num latest buckets from level.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) LatestBuckets(level, num int) []Observable {
0000000000000000000000000000000000000000;;		if level < 0 || level > len(ts.levels) {
0000000000000000000000000000000000000000;;			log.Print("timeseries: bad level argument: ", level)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if num < 0 || num >= ts.numBuckets {
0000000000000000000000000000000000000000;;			log.Print("timeseries: bad num argument: ", num)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		results := make([]Observable, num)
0000000000000000000000000000000000000000;;		now := ts.clock.Time()
0000000000000000000000000000000000000000;;		if ts.levels[0].end.Before(now) {
0000000000000000000000000000000000000000;;			ts.advance(now)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ts.mergePendingUpdates()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := ts.levels[level]
0000000000000000000000000000000000000000;;		index := l.newest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < num; i++ {
0000000000000000000000000000000000000000;;			result := ts.provider()
0000000000000000000000000000000000000000;;			results[i] = result
0000000000000000000000000000000000000000;;			if l.buckets[index] != nil {
0000000000000000000000000000000000000000;;				result.CopyFrom(l.buckets[index])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if index == 0 {
0000000000000000000000000000000000000000;;				index = ts.numBuckets
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			index -= 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleBy updates observations by scaling by factor.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) ScaleBy(factor float64) {
0000000000000000000000000000000000000000;;		for _, l := range ts.levels {
0000000000000000000000000000000000000000;;			for i := 0; i < ts.numBuckets; i++ {
0000000000000000000000000000000000000000;;				l.buckets[i].Multiply(factor)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ts.total.Multiply(factor)
0000000000000000000000000000000000000000;;		ts.pending.Multiply(factor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Range returns the sum of observations added over the specified time range.
0000000000000000000000000000000000000000;;	// If start or finish times don't fall on bucket boundaries of the same
0000000000000000000000000000000000000000;;	// level, then return values are approximate answers.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) Range(start, finish time.Time) Observable {
0000000000000000000000000000000000000000;;		return ts.ComputeRange(start, finish, 1)[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recent returns the sum of observations from the last delta.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) Recent(delta time.Duration) Observable {
0000000000000000000000000000000000000000;;		now := ts.clock.Time()
0000000000000000000000000000000000000000;;		return ts.Range(now.Add(-delta), now)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Total returns the total of all observations.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) Total() Observable {
0000000000000000000000000000000000000000;;		ts.mergePendingUpdates()
0000000000000000000000000000000000000000;;		return ts.total
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ComputeRange computes a specified number of values into a slice using
0000000000000000000000000000000000000000;;	// the observations recorded over the specified time period. The return
0000000000000000000000000000000000000000;;	// values are approximate if the start or finish times don't fall on the
0000000000000000000000000000000000000000;;	// bucket boundaries at the same level or if the number of buckets spanning
0000000000000000000000000000000000000000;;	// the range is not an integral multiple of num.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) ComputeRange(start, finish time.Time, num int) []Observable {
0000000000000000000000000000000000000000;;		if start.After(finish) {
0000000000000000000000000000000000000000;;			log.Printf("timeseries: start > finish, %v>%v", start, finish)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if num < 0 {
0000000000000000000000000000000000000000;;			log.Printf("timeseries: num < 0, %v", num)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		results := make([]Observable, num)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, l := range ts.levels {
0000000000000000000000000000000000000000;;			if !start.Before(l.end.Add(-l.size * time.Duration(ts.numBuckets))) {
0000000000000000000000000000000000000000;;				ts.extract(l, start, finish, num, results)
0000000000000000000000000000000000000000;;				return results
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Failed to find a level that covers the desired range.  So just
0000000000000000000000000000000000000000;;		// extract from the last level, even if it doesn't cover the entire
0000000000000000000000000000000000000000;;		// desired range.
0000000000000000000000000000000000000000;;		ts.extract(ts.levels[len(ts.levels)-1], start, finish, num, results)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return results
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecentList returns the specified number of values in slice over the most
0000000000000000000000000000000000000000;;	// recent time period of the specified range.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) RecentList(delta time.Duration, num int) []Observable {
0000000000000000000000000000000000000000;;		if delta < 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := ts.clock.Time()
0000000000000000000000000000000000000000;;		return ts.ComputeRange(now.Add(-delta), now, num)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extract returns a slice of specified number of observations from a given
0000000000000000000000000000000000000000;;	// level over a given range.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) extract(l *tsLevel, start, finish time.Time, num int, results []Observable) {
0000000000000000000000000000000000000000;;		ts.mergePendingUpdates()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		srcInterval := l.size
0000000000000000000000000000000000000000;;		dstInterval := finish.Sub(start) / time.Duration(num)
0000000000000000000000000000000000000000;;		dstStart := start
0000000000000000000000000000000000000000;;		srcStart := l.end.Add(-srcInterval * time.Duration(ts.numBuckets))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		srcIndex := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Where should scanning start?
0000000000000000000000000000000000000000;;		if dstStart.After(srcStart) {
0000000000000000000000000000000000000000;;			advance := dstStart.Sub(srcStart) / srcInterval
0000000000000000000000000000000000000000;;			srcIndex += int(advance)
0000000000000000000000000000000000000000;;			srcStart = srcStart.Add(advance * srcInterval)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The i'th value is computed as show below.
0000000000000000000000000000000000000000;;		// interval = (finish/start)/num
0000000000000000000000000000000000000000;;		// i'th value = sum of observation in range
0000000000000000000000000000000000000000;;		//   [ start + i       * interval,
0000000000000000000000000000000000000000;;		//     start + (i + 1) * interval )
0000000000000000000000000000000000000000;;		for i := 0; i < num; i++ {
0000000000000000000000000000000000000000;;			results[i] = ts.resetObservation(results[i])
0000000000000000000000000000000000000000;;			dstEnd := dstStart.Add(dstInterval)
0000000000000000000000000000000000000000;;			for srcIndex < ts.numBuckets && srcStart.Before(dstEnd) {
0000000000000000000000000000000000000000;;				srcEnd := srcStart.Add(srcInterval)
0000000000000000000000000000000000000000;;				if srcEnd.After(ts.lastAdd) {
0000000000000000000000000000000000000000;;					srcEnd = ts.lastAdd
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !srcEnd.Before(dstStart) {
0000000000000000000000000000000000000000;;					srcValue := l.buckets[(srcIndex+l.oldest)%ts.numBuckets]
0000000000000000000000000000000000000000;;					if !srcStart.Before(dstStart) && !srcEnd.After(dstEnd) {
0000000000000000000000000000000000000000;;						// dst completely contains src.
0000000000000000000000000000000000000000;;						if srcValue != nil {
0000000000000000000000000000000000000000;;							results[i].Add(srcValue)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// dst partially overlaps src.
0000000000000000000000000000000000000000;;						overlapStart := maxTime(srcStart, dstStart)
0000000000000000000000000000000000000000;;						overlapEnd := minTime(srcEnd, dstEnd)
0000000000000000000000000000000000000000;;						base := srcEnd.Sub(srcStart)
0000000000000000000000000000000000000000;;						fraction := overlapEnd.Sub(overlapStart).Seconds() / base.Seconds()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						used := ts.provider()
0000000000000000000000000000000000000000;;						if srcValue != nil {
0000000000000000000000000000000000000000;;							used.CopyFrom(srcValue)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						used.Multiply(fraction)
0000000000000000000000000000000000000000;;						results[i].Add(used)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if srcEnd.After(dstEnd) {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				srcIndex++
0000000000000000000000000000000000000000;;				srcStart = srcStart.Add(srcInterval)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dstStart = dstStart.Add(dstInterval)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resetObservation clears the content so the struct may be reused.
0000000000000000000000000000000000000000;;	func (ts *timeSeries) resetObservation(observation Observable) Observable {
0000000000000000000000000000000000000000;;		if observation == nil {
0000000000000000000000000000000000000000;;			observation = ts.provider()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			observation.Clear()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return observation
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimeSeries tracks data at granularities from 1 second to 16 weeks.
0000000000000000000000000000000000000000;;	type TimeSeries struct {
0000000000000000000000000000000000000000;;		timeSeries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTimeSeries creates a new TimeSeries using the function provided for creating new Observable.
0000000000000000000000000000000000000000;;	func NewTimeSeries(f func() Observable) *TimeSeries {
0000000000000000000000000000000000000000;;		return NewTimeSeriesWithClock(f, defaultClockInstance)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTimeSeriesWithClock creates a new TimeSeries using the function provided for creating new Observable and the clock for
0000000000000000000000000000000000000000;;	// assigning timestamps.
0000000000000000000000000000000000000000;;	func NewTimeSeriesWithClock(f func() Observable, clock Clock) *TimeSeries {
0000000000000000000000000000000000000000;;		ts := new(TimeSeries)
0000000000000000000000000000000000000000;;		ts.timeSeries.init(timeSeriesResolutions, f, timeSeriesNumBuckets, clock)
0000000000000000000000000000000000000000;;		return ts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MinuteHourSeries tracks data at granularities of 1 minute and 1 hour.
0000000000000000000000000000000000000000;;	type MinuteHourSeries struct {
0000000000000000000000000000000000000000;;		timeSeries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMinuteHourSeries creates a new MinuteHourSeries using the function provided for creating new Observable.
0000000000000000000000000000000000000000;;	func NewMinuteHourSeries(f func() Observable) *MinuteHourSeries {
0000000000000000000000000000000000000000;;		return NewMinuteHourSeriesWithClock(f, defaultClockInstance)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMinuteHourSeriesWithClock creates a new MinuteHourSeries using the function provided for creating new Observable and the clock for
0000000000000000000000000000000000000000;;	// assigning timestamps.
0000000000000000000000000000000000000000;;	func NewMinuteHourSeriesWithClock(f func() Observable, clock Clock) *MinuteHourSeries {
0000000000000000000000000000000000000000;;		ts := new(MinuteHourSeries)
0000000000000000000000000000000000000000;;		ts.timeSeries.init(minuteHourSeriesResolutions, f,
0000000000000000000000000000000000000000;;			minuteHourSeriesNumBuckets, clock)
0000000000000000000000000000000000000000;;		return ts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *MinuteHourSeries) Minute() Observable {
0000000000000000000000000000000000000000;;		return ts.timeSeries.Latest(0, 60)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *MinuteHourSeries) Hour() Observable {
0000000000000000000000000000000000000000;;		return ts.timeSeries.Latest(1, 60)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func minTime(a, b time.Time) time.Time {
0000000000000000000000000000000000000000;;		if a.Before(b) {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func maxTime(a, b time.Time) time.Time {
0000000000000000000000000000000000000000;;		if a.After(b) {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
