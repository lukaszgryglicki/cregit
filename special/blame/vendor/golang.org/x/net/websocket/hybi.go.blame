0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5523d6b09d9d51d8a0e43a77ea5d81aa9394f2bf;third_party/src/code.google.com/p/go.net/websocket/hybi.go[third_party/src/code.google.com/p/go.net/websocket/hybi.go][vendor/golang.org/x/net/websocket/hybi.go];	
0000000000000000000000000000000000000000;;	package websocket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file implements a protocol of hybi draft.
0000000000000000000000000000000000000000;;	// http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		websocketGUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closeStatusNormal            = 1000
0000000000000000000000000000000000000000;;		closeStatusGoingAway         = 1001
0000000000000000000000000000000000000000;;		closeStatusProtocolError     = 1002
0000000000000000000000000000000000000000;;		closeStatusUnsupportedData   = 1003
0000000000000000000000000000000000000000;;		closeStatusFrameTooLarge     = 1004
0000000000000000000000000000000000000000;;		closeStatusNoStatusRcvd      = 1005
0000000000000000000000000000000000000000;;		closeStatusAbnormalClosure   = 1006
0000000000000000000000000000000000000000;;		closeStatusBadMessageData    = 1007
0000000000000000000000000000000000000000;;		closeStatusPolicyViolation   = 1008
0000000000000000000000000000000000000000;;		closeStatusTooBigData        = 1009
0000000000000000000000000000000000000000;;		closeStatusExtensionMismatch = 1010
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxControlFramePayloadLength = 125
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrBadMaskingKey         = &ProtocolError{"bad masking key"}
0000000000000000000000000000000000000000;;		ErrBadPongMessage        = &ProtocolError{"bad pong message"}
0000000000000000000000000000000000000000;;		ErrBadClosingStatus      = &ProtocolError{"bad closing status"}
0000000000000000000000000000000000000000;;		ErrUnsupportedExtensions = &ProtocolError{"unsupported extensions"}
0000000000000000000000000000000000000000;;		ErrNotImplemented        = &ProtocolError{"not implemented"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handshakeHeader = map[string]bool{
0000000000000000000000000000000000000000;;			"Host":                   true,
0000000000000000000000000000000000000000;;			"Upgrade":                true,
0000000000000000000000000000000000000000;;			"Connection":             true,
0000000000000000000000000000000000000000;;			"Sec-Websocket-Key":      true,
0000000000000000000000000000000000000000;;			"Sec-Websocket-Origin":   true,
0000000000000000000000000000000000000000;;			"Sec-Websocket-Version":  true,
0000000000000000000000000000000000000000;;			"Sec-Websocket-Protocol": true,
0000000000000000000000000000000000000000;;			"Sec-Websocket-Accept":   true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A hybiFrameHeader is a frame header as defined in hybi draft.
0000000000000000000000000000000000000000;;	type hybiFrameHeader struct {
0000000000000000000000000000000000000000;;		Fin        bool
0000000000000000000000000000000000000000;;		Rsv        [3]bool
0000000000000000000000000000000000000000;;		OpCode     byte
0000000000000000000000000000000000000000;;		Length     int64
0000000000000000000000000000000000000000;;		MaskingKey []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data *bytes.Buffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A hybiFrameReader is a reader for hybi frame.
0000000000000000000000000000000000000000;;	type hybiFrameReader struct {
0000000000000000000000000000000000000000;;		reader io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		header hybiFrameHeader
0000000000000000000000000000000000000000;;		pos    int64
0000000000000000000000000000000000000000;;		length int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *hybiFrameReader) Read(msg []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		n, err = frame.reader.Read(msg)
0000000000000000000000000000000000000000;;		if frame.header.MaskingKey != nil {
0000000000000000000000000000000000000000;;			for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;				msg[i] = msg[i] ^ frame.header.MaskingKey[frame.pos%4]
0000000000000000000000000000000000000000;;				frame.pos++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *hybiFrameReader) PayloadType() byte { return frame.header.OpCode }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *hybiFrameReader) HeaderReader() io.Reader {
0000000000000000000000000000000000000000;;		if frame.header.data == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.header.data.Len() == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return frame.header.data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *hybiFrameReader) TrailerReader() io.Reader { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *hybiFrameReader) Len() (n int) { return frame.length }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A hybiFrameReaderFactory creates new frame reader based on its frame type.
0000000000000000000000000000000000000000;;	type hybiFrameReaderFactory struct {
0000000000000000000000000000000000000000;;		*bufio.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFrameReader reads a frame header from the connection, and creates new reader for the frame.
0000000000000000000000000000000000000000;;	// See Section 5.2 Base Framing protocol for detail.
0000000000000000000000000000000000000000;;	// http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5.2
0000000000000000000000000000000000000000;;	func (buf hybiFrameReaderFactory) NewFrameReader() (frame frameReader, err error) {
0000000000000000000000000000000000000000;;		hybiFrame := new(hybiFrameReader)
0000000000000000000000000000000000000000;;		frame = hybiFrame
0000000000000000000000000000000000000000;;		var header []byte
0000000000000000000000000000000000000000;;		var b byte
0000000000000000000000000000000000000000;;		// First byte. FIN/RSV1/RSV2/RSV3/OpCode(4bits)
0000000000000000000000000000000000000000;;		b, err = buf.ReadByte()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		header = append(header, b)
0000000000000000000000000000000000000000;;		hybiFrame.header.Fin = ((header[0] >> 7) & 1) != 0
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			j := uint(6 - i)
0000000000000000000000000000000000000000;;			hybiFrame.header.Rsv[i] = ((header[0] >> j) & 1) != 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hybiFrame.header.OpCode = header[0] & 0x0f
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Second byte. Mask/Payload len(7bits)
0000000000000000000000000000000000000000;;		b, err = buf.ReadByte()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		header = append(header, b)
0000000000000000000000000000000000000000;;		mask := (b & 0x80) != 0
0000000000000000000000000000000000000000;;		b &= 0x7f
0000000000000000000000000000000000000000;;		lengthFields := 0
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case b <= 125: // Payload length 7bits.
0000000000000000000000000000000000000000;;			hybiFrame.header.Length = int64(b)
0000000000000000000000000000000000000000;;		case b == 126: // Payload length 7+16bits
0000000000000000000000000000000000000000;;			lengthFields = 2
0000000000000000000000000000000000000000;;		case b == 127: // Payload length 7+64bits
0000000000000000000000000000000000000000;;			lengthFields = 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < lengthFields; i++ {
0000000000000000000000000000000000000000;;			b, err = buf.ReadByte()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lengthFields == 8 && i == 0 { // MSB must be zero when 7+64 bits
0000000000000000000000000000000000000000;;				b &= 0x7f
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			header = append(header, b)
0000000000000000000000000000000000000000;;			hybiFrame.header.Length = hybiFrame.header.Length*256 + int64(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask {
0000000000000000000000000000000000000000;;			// Masking key. 4 bytes.
0000000000000000000000000000000000000000;;			for i := 0; i < 4; i++ {
0000000000000000000000000000000000000000;;				b, err = buf.ReadByte()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				header = append(header, b)
0000000000000000000000000000000000000000;;				hybiFrame.header.MaskingKey = append(hybiFrame.header.MaskingKey, b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hybiFrame.reader = io.LimitReader(buf.Reader, hybiFrame.header.Length)
0000000000000000000000000000000000000000;;		hybiFrame.header.data = bytes.NewBuffer(header)
0000000000000000000000000000000000000000;;		hybiFrame.length = len(header) + int(hybiFrame.header.Length)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A HybiFrameWriter is a writer for hybi frame.
0000000000000000000000000000000000000000;;	type hybiFrameWriter struct {
0000000000000000000000000000000000000000;;		writer *bufio.Writer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		header *hybiFrameHeader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *hybiFrameWriter) Write(msg []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		var header []byte
0000000000000000000000000000000000000000;;		var b byte
0000000000000000000000000000000000000000;;		if frame.header.Fin {
0000000000000000000000000000000000000000;;			b |= 0x80
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < 3; i++ {
0000000000000000000000000000000000000000;;			if frame.header.Rsv[i] {
0000000000000000000000000000000000000000;;				j := uint(6 - i)
0000000000000000000000000000000000000000;;				b |= 1 << j
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b |= frame.header.OpCode
0000000000000000000000000000000000000000;;		header = append(header, b)
0000000000000000000000000000000000000000;;		if frame.header.MaskingKey != nil {
0000000000000000000000000000000000000000;;			b = 0x80
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			b = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lengthFields := 0
0000000000000000000000000000000000000000;;		length := len(msg)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case length <= 125:
0000000000000000000000000000000000000000;;			b |= byte(length)
0000000000000000000000000000000000000000;;		case length < 65536:
0000000000000000000000000000000000000000;;			b |= 126
0000000000000000000000000000000000000000;;			lengthFields = 2
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			b |= 127
0000000000000000000000000000000000000000;;			lengthFields = 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		header = append(header, b)
0000000000000000000000000000000000000000;;		for i := 0; i < lengthFields; i++ {
0000000000000000000000000000000000000000;;			j := uint((lengthFields - i - 1) * 8)
0000000000000000000000000000000000000000;;			b = byte((length >> j) & 0xff)
0000000000000000000000000000000000000000;;			header = append(header, b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame.header.MaskingKey != nil {
0000000000000000000000000000000000000000;;			if len(frame.header.MaskingKey) != 4 {
0000000000000000000000000000000000000000;;				return 0, ErrBadMaskingKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			header = append(header, frame.header.MaskingKey...)
0000000000000000000000000000000000000000;;			frame.writer.Write(header)
0000000000000000000000000000000000000000;;			data := make([]byte, length)
0000000000000000000000000000000000000000;;			for i := range data {
0000000000000000000000000000000000000000;;				data[i] = msg[i] ^ frame.header.MaskingKey[i%4]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			frame.writer.Write(data)
0000000000000000000000000000000000000000;;			err = frame.writer.Flush()
0000000000000000000000000000000000000000;;			return length, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frame.writer.Write(header)
0000000000000000000000000000000000000000;;		frame.writer.Write(msg)
0000000000000000000000000000000000000000;;		err = frame.writer.Flush()
0000000000000000000000000000000000000000;;		return length, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (frame *hybiFrameWriter) Close() error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hybiFrameWriterFactory struct {
0000000000000000000000000000000000000000;;		*bufio.Writer
0000000000000000000000000000000000000000;;		needMaskingKey bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (buf hybiFrameWriterFactory) NewFrameWriter(payloadType byte) (frame frameWriter, err error) {
0000000000000000000000000000000000000000;;		frameHeader := &hybiFrameHeader{Fin: true, OpCode: payloadType}
0000000000000000000000000000000000000000;;		if buf.needMaskingKey {
0000000000000000000000000000000000000000;;			frameHeader.MaskingKey, err = generateMaskingKey()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &hybiFrameWriter{writer: buf.Writer, header: frameHeader}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hybiFrameHandler struct {
0000000000000000000000000000000000000000;;		conn        *Conn
0000000000000000000000000000000000000000;;		payloadType byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *hybiFrameHandler) HandleFrame(frame frameReader) (frameReader, error) {
0000000000000000000000000000000000000000;;		if handler.conn.IsServerConn() {
0000000000000000000000000000000000000000;;			// The client MUST mask all frames sent to the server.
0000000000000000000000000000000000000000;;			if frame.(*hybiFrameReader).header.MaskingKey == nil {
0000000000000000000000000000000000000000;;				handler.WriteClose(closeStatusProtocolError)
0000000000000000000000000000000000000000;;				return nil, io.EOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The server MUST NOT mask all frames.
0000000000000000000000000000000000000000;;			if frame.(*hybiFrameReader).header.MaskingKey != nil {
0000000000000000000000000000000000000000;;				handler.WriteClose(closeStatusProtocolError)
0000000000000000000000000000000000000000;;				return nil, io.EOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if header := frame.HeaderReader(); header != nil {
0000000000000000000000000000000000000000;;			io.Copy(ioutil.Discard, header)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch frame.PayloadType() {
0000000000000000000000000000000000000000;;		case ContinuationFrame:
0000000000000000000000000000000000000000;;			frame.(*hybiFrameReader).header.OpCode = handler.payloadType
0000000000000000000000000000000000000000;;		case TextFrame, BinaryFrame:
0000000000000000000000000000000000000000;;			handler.payloadType = frame.PayloadType()
0000000000000000000000000000000000000000;;		case CloseFrame:
0000000000000000000000000000000000000000;;			return nil, io.EOF
0000000000000000000000000000000000000000;;		case PingFrame, PongFrame:
0000000000000000000000000000000000000000;;			b := make([]byte, maxControlFramePayloadLength)
0000000000000000000000000000000000000000;;			n, err := io.ReadFull(frame, b)
0000000000000000000000000000000000000000;;			if err != nil && err != io.EOF && err != io.ErrUnexpectedEOF {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			io.Copy(ioutil.Discard, frame)
0000000000000000000000000000000000000000;;			if frame.PayloadType() == PingFrame {
0000000000000000000000000000000000000000;;				if _, err := handler.WritePong(b[:n]); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return frame, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *hybiFrameHandler) WriteClose(status int) (err error) {
0000000000000000000000000000000000000000;;		handler.conn.wio.Lock()
0000000000000000000000000000000000000000;;		defer handler.conn.wio.Unlock()
0000000000000000000000000000000000000000;;		w, err := handler.conn.frameWriterFactory.NewFrameWriter(CloseFrame)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg := make([]byte, 2)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(msg, uint16(status))
0000000000000000000000000000000000000000;;		_, err = w.Write(msg)
0000000000000000000000000000000000000000;;		w.Close()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *hybiFrameHandler) WritePong(msg []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		handler.conn.wio.Lock()
0000000000000000000000000000000000000000;;		defer handler.conn.wio.Unlock()
0000000000000000000000000000000000000000;;		w, err := handler.conn.frameWriterFactory.NewFrameWriter(PongFrame)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = w.Write(msg)
0000000000000000000000000000000000000000;;		w.Close()
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newHybiConn creates a new WebSocket connection speaking hybi draft protocol.
0000000000000000000000000000000000000000;;	func newHybiConn(config *Config, buf *bufio.ReadWriter, rwc io.ReadWriteCloser, request *http.Request) *Conn {
0000000000000000000000000000000000000000;;		if buf == nil {
0000000000000000000000000000000000000000;;			br := bufio.NewReader(rwc)
0000000000000000000000000000000000000000;;			bw := bufio.NewWriter(rwc)
0000000000000000000000000000000000000000;;			buf = bufio.NewReadWriter(br, bw)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ws := &Conn{config: config, request: request, buf: buf, rwc: rwc,
0000000000000000000000000000000000000000;;			frameReaderFactory: hybiFrameReaderFactory{buf.Reader},
0000000000000000000000000000000000000000;;			frameWriterFactory: hybiFrameWriterFactory{
0000000000000000000000000000000000000000;;				buf.Writer, request == nil},
0000000000000000000000000000000000000000;;			PayloadType:        TextFrame,
0000000000000000000000000000000000000000;;			defaultCloseStatus: closeStatusNormal}
0000000000000000000000000000000000000000;;		ws.frameHandler = &hybiFrameHandler{conn: ws}
0000000000000000000000000000000000000000;;		return ws
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateMaskingKey generates a masking key for a frame.
0000000000000000000000000000000000000000;;	func generateMaskingKey() (maskingKey []byte, err error) {
0000000000000000000000000000000000000000;;		maskingKey = make([]byte, 4)
0000000000000000000000000000000000000000;;		if _, err = io.ReadFull(rand.Reader, maskingKey); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateNonce generates a nonce consisting of a randomly selected 16-byte
0000000000000000000000000000000000000000;;	// value that has been base64-encoded.
0000000000000000000000000000000000000000;;	func generateNonce() (nonce []byte) {
0000000000000000000000000000000000000000;;		key := make([]byte, 16)
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rand.Reader, key); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nonce = make([]byte, 24)
0000000000000000000000000000000000000000;;		base64.StdEncoding.Encode(nonce, key)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeZone removes IPv6 zone identifer from host.
0000000000000000000000000000000000000000;;	// E.g., "[fe80::1%en0]:8080" to "[fe80::1]:8080"
0000000000000000000000000000000000000000;;	func removeZone(host string) string {
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(host, "[") {
0000000000000000000000000000000000000000;;			return host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := strings.LastIndex(host, "]")
0000000000000000000000000000000000000000;;		if i < 0 {
0000000000000000000000000000000000000000;;			return host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		j := strings.LastIndex(host[:i], "%")
0000000000000000000000000000000000000000;;		if j < 0 {
0000000000000000000000000000000000000000;;			return host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return host[:j] + host[i:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNonceAccept computes the base64-encoded SHA-1 of the concatenation of
0000000000000000000000000000000000000000;;	// the nonce ("Sec-WebSocket-Key" value) with the websocket GUID string.
0000000000000000000000000000000000000000;;	func getNonceAccept(nonce []byte) (expected []byte, err error) {
0000000000000000000000000000000000000000;;		h := sha1.New()
0000000000000000000000000000000000000000;;		if _, err = h.Write(nonce); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err = h.Write([]byte(websocketGUID)); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expected = make([]byte, 28)
0000000000000000000000000000000000000000;;		base64.StdEncoding.Encode(expected, h.Sum(nil))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client handshake described in draft-ietf-hybi-thewebsocket-protocol-17
0000000000000000000000000000000000000000;;	func hybiClientHandshake(config *Config, br *bufio.Reader, bw *bufio.Writer) (err error) {
0000000000000000000000000000000000000000;;		bw.WriteString("GET " + config.Location.RequestURI() + " HTTP/1.1\r\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// According to RFC 6874, an HTTP client, proxy, or other
0000000000000000000000000000000000000000;;		// intermediary must remove any IPv6 zone identifier attached
0000000000000000000000000000000000000000;;		// to an outgoing URI.
0000000000000000000000000000000000000000;;		bw.WriteString("Host: " + removeZone(config.Location.Host) + "\r\n")
0000000000000000000000000000000000000000;;		bw.WriteString("Upgrade: websocket\r\n")
0000000000000000000000000000000000000000;;		bw.WriteString("Connection: Upgrade\r\n")
0000000000000000000000000000000000000000;;		nonce := generateNonce()
0000000000000000000000000000000000000000;;		if config.handshakeData != nil {
0000000000000000000000000000000000000000;;			nonce = []byte(config.handshakeData["key"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bw.WriteString("Sec-WebSocket-Key: " + string(nonce) + "\r\n")
0000000000000000000000000000000000000000;;		bw.WriteString("Origin: " + strings.ToLower(config.Origin.String()) + "\r\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.Version != ProtocolVersionHybi13 {
0000000000000000000000000000000000000000;;			return ErrBadProtocolVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bw.WriteString("Sec-WebSocket-Version: " + fmt.Sprintf("%d", config.Version) + "\r\n")
0000000000000000000000000000000000000000;;		if len(config.Protocol) > 0 {
0000000000000000000000000000000000000000;;			bw.WriteString("Sec-WebSocket-Protocol: " + strings.Join(config.Protocol, ", ") + "\r\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(ukai): send Sec-WebSocket-Extensions.
0000000000000000000000000000000000000000;;		err = config.Header.WriteSubset(bw, handshakeHeader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bw.WriteString("\r\n")
0000000000000000000000000000000000000000;;		if err = bw.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.ReadResponse(br, &http.Request{Method: "GET"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != 101 {
0000000000000000000000000000000000000000;;			return ErrBadStatus
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.ToLower(resp.Header.Get("Upgrade")) != "websocket" ||
0000000000000000000000000000000000000000;;			strings.ToLower(resp.Header.Get("Connection")) != "upgrade" {
0000000000000000000000000000000000000000;;			return ErrBadUpgrade
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedAccept, err := getNonceAccept(nonce)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.Header.Get("Sec-WebSocket-Accept") != string(expectedAccept) {
0000000000000000000000000000000000000000;;			return ErrChallengeResponse
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.Header.Get("Sec-WebSocket-Extensions") != "" {
0000000000000000000000000000000000000000;;			return ErrUnsupportedExtensions
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		offeredProtocol := resp.Header.Get("Sec-WebSocket-Protocol")
0000000000000000000000000000000000000000;;		if offeredProtocol != "" {
0000000000000000000000000000000000000000;;			protocolMatched := false
0000000000000000000000000000000000000000;;			for i := 0; i < len(config.Protocol); i++ {
0000000000000000000000000000000000000000;;				if config.Protocol[i] == offeredProtocol {
0000000000000000000000000000000000000000;;					protocolMatched = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !protocolMatched {
0000000000000000000000000000000000000000;;				return ErrBadWebSocketProtocol
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config.Protocol = []string{offeredProtocol}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newHybiClientConn creates a client WebSocket connection after handshake.
0000000000000000000000000000000000000000;;	func newHybiClientConn(config *Config, buf *bufio.ReadWriter, rwc io.ReadWriteCloser) *Conn {
0000000000000000000000000000000000000000;;		return newHybiConn(config, buf, rwc, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A HybiServerHandshaker performs a server handshake using hybi draft protocol.
0000000000000000000000000000000000000000;;	type hybiServerHandshaker struct {
0000000000000000000000000000000000000000;;		*Config
0000000000000000000000000000000000000000;;		accept []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *hybiServerHandshaker) ReadHandshake(buf *bufio.Reader, req *http.Request) (code int, err error) {
0000000000000000000000000000000000000000;;		c.Version = ProtocolVersionHybi13
0000000000000000000000000000000000000000;;		if req.Method != "GET" {
0000000000000000000000000000000000000000;;			return http.StatusMethodNotAllowed, ErrBadRequestMethod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// HTTP version can be safely ignored.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.ToLower(req.Header.Get("Upgrade")) != "websocket" ||
0000000000000000000000000000000000000000;;			!strings.Contains(strings.ToLower(req.Header.Get("Connection")), "upgrade") {
0000000000000000000000000000000000000000;;			return http.StatusBadRequest, ErrNotWebSocket
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := req.Header.Get("Sec-Websocket-Key")
0000000000000000000000000000000000000000;;		if key == "" {
0000000000000000000000000000000000000000;;			return http.StatusBadRequest, ErrChallengeResponse
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version := req.Header.Get("Sec-Websocket-Version")
0000000000000000000000000000000000000000;;		switch version {
0000000000000000000000000000000000000000;;		case "13":
0000000000000000000000000000000000000000;;			c.Version = ProtocolVersionHybi13
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return http.StatusBadRequest, ErrBadWebSocketVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var scheme string
0000000000000000000000000000000000000000;;		if req.TLS != nil {
0000000000000000000000000000000000000000;;			scheme = "wss"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			scheme = "ws"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Location, err = url.ParseRequestURI(scheme + "://" + req.Host + req.URL.RequestURI())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return http.StatusBadRequest, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		protocol := strings.TrimSpace(req.Header.Get("Sec-Websocket-Protocol"))
0000000000000000000000000000000000000000;;		if protocol != "" {
0000000000000000000000000000000000000000;;			protocols := strings.Split(protocol, ",")
0000000000000000000000000000000000000000;;			for i := 0; i < len(protocols); i++ {
0000000000000000000000000000000000000000;;				c.Protocol = append(c.Protocol, strings.TrimSpace(protocols[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.accept, err = getNonceAccept([]byte(key))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return http.StatusInternalServerError, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return http.StatusSwitchingProtocols, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Origin parses the Origin header in req.
0000000000000000000000000000000000000000;;	// If the Origin header is not set, it returns nil and nil.
0000000000000000000000000000000000000000;;	func Origin(config *Config, req *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;		var origin string
0000000000000000000000000000000000000000;;		switch config.Version {
0000000000000000000000000000000000000000;;		case ProtocolVersionHybi13:
0000000000000000000000000000000000000000;;			origin = req.Header.Get("Origin")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if origin == "" {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return url.ParseRequestURI(origin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *hybiServerHandshaker) AcceptHandshake(buf *bufio.Writer) (err error) {
0000000000000000000000000000000000000000;;		if len(c.Protocol) > 0 {
0000000000000000000000000000000000000000;;			if len(c.Protocol) != 1 {
0000000000000000000000000000000000000000;;				// You need choose a Protocol in Handshake func in Server.
0000000000000000000000000000000000000000;;				return ErrBadWebSocketProtocol
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.WriteString("HTTP/1.1 101 Switching Protocols\r\n")
0000000000000000000000000000000000000000;;		buf.WriteString("Upgrade: websocket\r\n")
0000000000000000000000000000000000000000;;		buf.WriteString("Connection: Upgrade\r\n")
0000000000000000000000000000000000000000;;		buf.WriteString("Sec-WebSocket-Accept: " + string(c.accept) + "\r\n")
0000000000000000000000000000000000000000;;		if len(c.Protocol) > 0 {
0000000000000000000000000000000000000000;;			buf.WriteString("Sec-WebSocket-Protocol: " + c.Protocol[0] + "\r\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(ukai): send Sec-WebSocket-Extensions.
0000000000000000000000000000000000000000;;		if c.Header != nil {
0000000000000000000000000000000000000000;;			err := c.Header.WriteSubset(buf, handshakeHeader)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf.WriteString("\r\n")
0000000000000000000000000000000000000000;;		return buf.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *hybiServerHandshaker) NewServerConn(buf *bufio.ReadWriter, rwc io.ReadWriteCloser, request *http.Request) *Conn {
0000000000000000000000000000000000000000;;		return newHybiServerConn(c.Config, buf, rwc, request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newHybiServerConn returns a new WebSocket connection speaking hybi draft protocol.
0000000000000000000000000000000000000000;;	func newHybiServerConn(config *Config, buf *bufio.ReadWriter, rwc io.ReadWriteCloser, request *http.Request) *Conn {
0000000000000000000000000000000000000000;;		return newHybiConn(config, buf, rwc, request)
0000000000000000000000000000000000000000;;	}
