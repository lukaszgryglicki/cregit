0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5523d6b09d9d51d8a0e43a77ea5d81aa9394f2bf;third_party/src/code.google.com/p/go.net/websocket/websocket.go[third_party/src/code.google.com/p/go.net/websocket/websocket.go][vendor/golang.org/x/net/websocket/websocket.go];	
0000000000000000000000000000000000000000;;	// Package websocket implements a client and server for the WebSocket protocol
0000000000000000000000000000000000000000;;	// as specified in RFC 6455.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This package currently lacks some features found in an alternative
0000000000000000000000000000000000000000;;	// and more actively maintained WebSocket package:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     https://godoc.org/github.com/gorilla/websocket
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package websocket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ProtocolVersionHybi13    = 13
0000000000000000000000000000000000000000;;		ProtocolVersionHybi      = ProtocolVersionHybi13
0000000000000000000000000000000000000000;;		SupportedProtocolVersion = "13"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ContinuationFrame = 0
0000000000000000000000000000000000000000;;		TextFrame         = 1
0000000000000000000000000000000000000000;;		BinaryFrame       = 2
0000000000000000000000000000000000000000;;		CloseFrame        = 8
0000000000000000000000000000000000000000;;		PingFrame         = 9
0000000000000000000000000000000000000000;;		PongFrame         = 10
0000000000000000000000000000000000000000;;		UnknownFrame      = 255
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DefaultMaxPayloadBytes = 32 << 20 // 32MB
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProtocolError represents WebSocket protocol errors.
0000000000000000000000000000000000000000;;	type ProtocolError struct {
0000000000000000000000000000000000000000;;		ErrorString string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err *ProtocolError) Error() string { return err.ErrorString }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrBadProtocolVersion   = &ProtocolError{"bad protocol version"}
0000000000000000000000000000000000000000;;		ErrBadScheme            = &ProtocolError{"bad scheme"}
0000000000000000000000000000000000000000;;		ErrBadStatus            = &ProtocolError{"bad status"}
0000000000000000000000000000000000000000;;		ErrBadUpgrade           = &ProtocolError{"missing or bad upgrade"}
0000000000000000000000000000000000000000;;		ErrBadWebSocketOrigin   = &ProtocolError{"missing or bad WebSocket-Origin"}
0000000000000000000000000000000000000000;;		ErrBadWebSocketLocation = &ProtocolError{"missing or bad WebSocket-Location"}
0000000000000000000000000000000000000000;;		ErrBadWebSocketProtocol = &ProtocolError{"missing or bad WebSocket-Protocol"}
0000000000000000000000000000000000000000;;		ErrBadWebSocketVersion  = &ProtocolError{"missing or bad WebSocket Version"}
0000000000000000000000000000000000000000;;		ErrChallengeResponse    = &ProtocolError{"mismatch challenge/response"}
0000000000000000000000000000000000000000;;		ErrBadFrame             = &ProtocolError{"bad frame"}
0000000000000000000000000000000000000000;;		ErrBadFrameBoundary     = &ProtocolError{"not on frame boundary"}
0000000000000000000000000000000000000000;;		ErrNotWebSocket         = &ProtocolError{"not websocket protocol"}
0000000000000000000000000000000000000000;;		ErrBadRequestMethod     = &ProtocolError{"bad method"}
0000000000000000000000000000000000000000;;		ErrNotSupported         = &ProtocolError{"not supported"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrFrameTooLarge is returned by Codec's Receive method if payload size
0000000000000000000000000000000000000000;;	// exceeds limit set by Conn.MaxPayloadBytes
0000000000000000000000000000000000000000;;	var ErrFrameTooLarge = errors.New("websocket: frame payload size exceeds limit")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Addr is an implementation of net.Addr for WebSocket.
0000000000000000000000000000000000000000;;	type Addr struct {
0000000000000000000000000000000000000000;;		*url.URL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Network returns the network type for a WebSocket, "websocket".
0000000000000000000000000000000000000000;;	func (addr *Addr) Network() string { return "websocket" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config is a WebSocket configuration
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// A WebSocket server address.
0000000000000000000000000000000000000000;;		Location *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A Websocket client origin.
0000000000000000000000000000000000000000;;		Origin *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WebSocket subprotocols.
0000000000000000000000000000000000000000;;		Protocol []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WebSocket protocol version.
0000000000000000000000000000000000000000;;		Version int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLS config for secure WebSocket (wss).
0000000000000000000000000000000000000000;;		TlsConfig *tls.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Additional header fields to be sent in WebSocket opening handshake.
0000000000000000000000000000000000000000;;		Header http.Header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dialer used when opening websocket connections.
0000000000000000000000000000000000000000;;		Dialer *net.Dialer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handshakeData map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serverHandshaker is an interface to handle WebSocket server side handshake.
0000000000000000000000000000000000000000;;	type serverHandshaker interface {
0000000000000000000000000000000000000000;;		// ReadHandshake reads handshake request message from client.
0000000000000000000000000000000000000000;;		// Returns http response code and error if any.
0000000000000000000000000000000000000000;;		ReadHandshake(buf *bufio.Reader, req *http.Request) (code int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AcceptHandshake accepts the client handshake request and sends
0000000000000000000000000000000000000000;;		// handshake response back to client.
0000000000000000000000000000000000000000;;		AcceptHandshake(buf *bufio.Writer) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewServerConn creates a new WebSocket connection.
0000000000000000000000000000000000000000;;		NewServerConn(buf *bufio.ReadWriter, rwc io.ReadWriteCloser, request *http.Request) (conn *Conn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// frameReader is an interface to read a WebSocket frame.
0000000000000000000000000000000000000000;;	type frameReader interface {
0000000000000000000000000000000000000000;;		// Reader is to read payload of the frame.
0000000000000000000000000000000000000000;;		io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PayloadType returns payload type.
0000000000000000000000000000000000000000;;		PayloadType() byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HeaderReader returns a reader to read header of the frame.
0000000000000000000000000000000000000000;;		HeaderReader() io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TrailerReader returns a reader to read trailer of the frame.
0000000000000000000000000000000000000000;;		// If it returns nil, there is no trailer in the frame.
0000000000000000000000000000000000000000;;		TrailerReader() io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Len returns total length of the frame, including header and trailer.
0000000000000000000000000000000000000000;;		Len() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// frameReaderFactory is an interface to creates new frame reader.
0000000000000000000000000000000000000000;;	type frameReaderFactory interface {
0000000000000000000000000000000000000000;;		NewFrameReader() (r frameReader, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// frameWriter is an interface to write a WebSocket frame.
0000000000000000000000000000000000000000;;	type frameWriter interface {
0000000000000000000000000000000000000000;;		// Writer is to write payload of the frame.
0000000000000000000000000000000000000000;;		io.WriteCloser
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// frameWriterFactory is an interface to create new frame writer.
0000000000000000000000000000000000000000;;	type frameWriterFactory interface {
0000000000000000000000000000000000000000;;		NewFrameWriter(payloadType byte) (w frameWriter, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type frameHandler interface {
0000000000000000000000000000000000000000;;		HandleFrame(frame frameReader) (r frameReader, err error)
0000000000000000000000000000000000000000;;		WriteClose(status int) (err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Conn represents a WebSocket connection.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Multiple goroutines may invoke methods on a Conn simultaneously.
0000000000000000000000000000000000000000;;	type Conn struct {
0000000000000000000000000000000000000000;;		config  *Config
0000000000000000000000000000000000000000;;		request *http.Request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf *bufio.ReadWriter
0000000000000000000000000000000000000000;;		rwc io.ReadWriteCloser
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rio sync.Mutex
0000000000000000000000000000000000000000;;		frameReaderFactory
0000000000000000000000000000000000000000;;		frameReader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wio sync.Mutex
0000000000000000000000000000000000000000;;		frameWriterFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		frameHandler
0000000000000000000000000000000000000000;;		PayloadType        byte
0000000000000000000000000000000000000000;;		defaultCloseStatus int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxPayloadBytes limits the size of frame payload received over Conn
0000000000000000000000000000000000000000;;		// by Codec's Receive method. If zero, DefaultMaxPayloadBytes is used.
0000000000000000000000000000000000000000;;		MaxPayloadBytes int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read implements the io.Reader interface:
0000000000000000000000000000000000000000;;	// it reads data of a frame from the WebSocket connection.
0000000000000000000000000000000000000000;;	// if msg is not large enough for the frame data, it fills the msg and next Read
0000000000000000000000000000000000000000;;	// will read the rest of the frame data.
0000000000000000000000000000000000000000;;	// it reads Text frame or Binary frame.
0000000000000000000000000000000000000000;;	func (ws *Conn) Read(msg []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		ws.rio.Lock()
0000000000000000000000000000000000000000;;		defer ws.rio.Unlock()
0000000000000000000000000000000000000000;;	again:
0000000000000000000000000000000000000000;;		if ws.frameReader == nil {
0000000000000000000000000000000000000000;;			frame, err := ws.frameReaderFactory.NewFrameReader()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ws.frameReader, err = ws.frameHandler.HandleFrame(frame)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ws.frameReader == nil {
0000000000000000000000000000000000000000;;				goto again
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = ws.frameReader.Read(msg)
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			if trailer := ws.frameReader.TrailerReader(); trailer != nil {
0000000000000000000000000000000000000000;;				io.Copy(ioutil.Discard, trailer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ws.frameReader = nil
0000000000000000000000000000000000000000;;			goto again
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write implements the io.Writer interface:
0000000000000000000000000000000000000000;;	// it writes data as a frame to the WebSocket connection.
0000000000000000000000000000000000000000;;	func (ws *Conn) Write(msg []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		ws.wio.Lock()
0000000000000000000000000000000000000000;;		defer ws.wio.Unlock()
0000000000000000000000000000000000000000;;		w, err := ws.frameWriterFactory.NewFrameWriter(ws.PayloadType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = w.Write(msg)
0000000000000000000000000000000000000000;;		w.Close()
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close implements the io.Closer interface.
0000000000000000000000000000000000000000;;	func (ws *Conn) Close() error {
0000000000000000000000000000000000000000;;		err := ws.frameHandler.WriteClose(ws.defaultCloseStatus)
0000000000000000000000000000000000000000;;		err1 := ws.rwc.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *Conn) IsClientConn() bool { return ws.request == nil }
0000000000000000000000000000000000000000;;	func (ws *Conn) IsServerConn() bool { return ws.request != nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LocalAddr returns the WebSocket Origin for the connection for client, or
0000000000000000000000000000000000000000;;	// the WebSocket location for server.
0000000000000000000000000000000000000000;;	func (ws *Conn) LocalAddr() net.Addr {
0000000000000000000000000000000000000000;;		if ws.IsClientConn() {
0000000000000000000000000000000000000000;;			return &Addr{ws.config.Origin}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Addr{ws.config.Location}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteAddr returns the WebSocket location for the connection for client, or
0000000000000000000000000000000000000000;;	// the Websocket Origin for server.
0000000000000000000000000000000000000000;;	func (ws *Conn) RemoteAddr() net.Addr {
0000000000000000000000000000000000000000;;		if ws.IsClientConn() {
0000000000000000000000000000000000000000;;			return &Addr{ws.config.Location}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Addr{ws.config.Origin}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errSetDeadline = errors.New("websocket: cannot set deadline: not using a net.Conn")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetDeadline sets the connection's network read & write deadlines.
0000000000000000000000000000000000000000;;	func (ws *Conn) SetDeadline(t time.Time) error {
0000000000000000000000000000000000000000;;		if conn, ok := ws.rwc.(net.Conn); ok {
0000000000000000000000000000000000000000;;			return conn.SetDeadline(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errSetDeadline
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetReadDeadline sets the connection's network read deadline.
0000000000000000000000000000000000000000;;	func (ws *Conn) SetReadDeadline(t time.Time) error {
0000000000000000000000000000000000000000;;		if conn, ok := ws.rwc.(net.Conn); ok {
0000000000000000000000000000000000000000;;			return conn.SetReadDeadline(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errSetDeadline
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetWriteDeadline sets the connection's network write deadline.
0000000000000000000000000000000000000000;;	func (ws *Conn) SetWriteDeadline(t time.Time) error {
0000000000000000000000000000000000000000;;		if conn, ok := ws.rwc.(net.Conn); ok {
0000000000000000000000000000000000000000;;			return conn.SetWriteDeadline(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errSetDeadline
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config returns the WebSocket config.
0000000000000000000000000000000000000000;;	func (ws *Conn) Config() *Config { return ws.config }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Request returns the http request upgraded to the WebSocket.
0000000000000000000000000000000000000000;;	// It is nil for client side.
0000000000000000000000000000000000000000;;	func (ws *Conn) Request() *http.Request { return ws.request }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Codec represents a symmetric pair of functions that implement a codec.
0000000000000000000000000000000000000000;;	type Codec struct {
0000000000000000000000000000000000000000;;		Marshal   func(v interface{}) (data []byte, payloadType byte, err error)
0000000000000000000000000000000000000000;;		Unmarshal func(data []byte, payloadType byte, v interface{}) (err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Send sends v marshaled by cd.Marshal as single frame to ws.
0000000000000000000000000000000000000000;;	func (cd Codec) Send(ws *Conn, v interface{}) (err error) {
0000000000000000000000000000000000000000;;		data, payloadType, err := cd.Marshal(v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ws.wio.Lock()
0000000000000000000000000000000000000000;;		defer ws.wio.Unlock()
0000000000000000000000000000000000000000;;		w, err := ws.frameWriterFactory.NewFrameWriter(payloadType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = w.Write(data)
0000000000000000000000000000000000000000;;		w.Close()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Receive receives single frame from ws, unmarshaled by cd.Unmarshal and stores
0000000000000000000000000000000000000000;;	// in v. The whole frame payload is read to an in-memory buffer; max size of
0000000000000000000000000000000000000000;;	// payload is defined by ws.MaxPayloadBytes. If frame payload size exceeds
0000000000000000000000000000000000000000;;	// limit, ErrFrameTooLarge is returned; in this case frame is not read off wire
0000000000000000000000000000000000000000;;	// completely. The next call to Receive would read and discard leftover data of
0000000000000000000000000000000000000000;;	// previous oversized frame before processing next frame.
0000000000000000000000000000000000000000;;	func (cd Codec) Receive(ws *Conn, v interface{}) (err error) {
0000000000000000000000000000000000000000;;		ws.rio.Lock()
0000000000000000000000000000000000000000;;		defer ws.rio.Unlock()
0000000000000000000000000000000000000000;;		if ws.frameReader != nil {
0000000000000000000000000000000000000000;;			_, err = io.Copy(ioutil.Discard, ws.frameReader)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ws.frameReader = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	again:
0000000000000000000000000000000000000000;;		frame, err := ws.frameReaderFactory.NewFrameReader()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frame, err = ws.frameHandler.HandleFrame(frame)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if frame == nil {
0000000000000000000000000000000000000000;;			goto again
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		maxPayloadBytes := ws.MaxPayloadBytes
0000000000000000000000000000000000000000;;		if maxPayloadBytes == 0 {
0000000000000000000000000000000000000000;;			maxPayloadBytes = DefaultMaxPayloadBytes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hf, ok := frame.(*hybiFrameReader); ok && hf.header.Length > int64(maxPayloadBytes) {
0000000000000000000000000000000000000000;;			// payload size exceeds limit, no need to call Unmarshal
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// set frameReader to current oversized frame so that
0000000000000000000000000000000000000000;;			// the next call to this function can drain leftover
0000000000000000000000000000000000000000;;			// data before processing the next frame
0000000000000000000000000000000000000000;;			ws.frameReader = frame
0000000000000000000000000000000000000000;;			return ErrFrameTooLarge
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		payloadType := frame.PayloadType()
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadAll(frame)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cd.Unmarshal(data, payloadType, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshal(v interface{}) (msg []byte, payloadType byte, err error) {
0000000000000000000000000000000000000000;;		switch data := v.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			return []byte(data), TextFrame, nil
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			return data, BinaryFrame, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, UnknownFrame, ErrNotSupported
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshal(msg []byte, payloadType byte, v interface{}) (err error) {
0000000000000000000000000000000000000000;;		switch data := v.(type) {
0000000000000000000000000000000000000000;;		case *string:
0000000000000000000000000000000000000000;;			*data = string(msg)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case *[]byte:
0000000000000000000000000000000000000000;;			*data = msg
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ErrNotSupported
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Message is a codec to send/receive text/binary data in a frame on WebSocket connection.
0000000000000000000000000000000000000000;;	To send/receive text frame, use string type.
0000000000000000000000000000000000000000;;	To send/receive binary frame, use []byte type.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Trivial usage:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		import "websocket"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// receive text frame
0000000000000000000000000000000000000000;;		var message string
0000000000000000000000000000000000000000;;		websocket.Message.Receive(ws, &message)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// send text frame
0000000000000000000000000000000000000000;;		message = "hello"
0000000000000000000000000000000000000000;;		websocket.Message.Send(ws, message)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// receive binary frame
0000000000000000000000000000000000000000;;		var data []byte
0000000000000000000000000000000000000000;;		websocket.Message.Receive(ws, &data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// send binary frame
0000000000000000000000000000000000000000;;		data = []byte{0, 1, 2}
0000000000000000000000000000000000000000;;		websocket.Message.Send(ws, data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	var Message = Codec{marshal, unmarshal}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jsonMarshal(v interface{}) (msg []byte, payloadType byte, err error) {
0000000000000000000000000000000000000000;;		msg, err = json.Marshal(v)
0000000000000000000000000000000000000000;;		return msg, TextFrame, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jsonUnmarshal(msg []byte, payloadType byte, v interface{}) (err error) {
0000000000000000000000000000000000000000;;		return json.Unmarshal(msg, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	JSON is a codec to send/receive JSON data in a frame from a WebSocket connection.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Trivial usage:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		import "websocket"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type T struct {
0000000000000000000000000000000000000000;;			Msg string
0000000000000000000000000000000000000000;;			Count int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// receive JSON type T
0000000000000000000000000000000000000000;;		var data T
0000000000000000000000000000000000000000;;		websocket.JSON.Receive(ws, &data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// send JSON type T
0000000000000000000000000000000000000000;;		websocket.JSON.Send(ws, data)
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	var JSON = Codec{jsonMarshal, jsonUnmarshal}
