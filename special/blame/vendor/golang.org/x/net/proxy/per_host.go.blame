0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/golang.org/x/net/proxy/per_host.go[Godeps/_workspace/src/golang.org/x/net/proxy/per_host.go][vendor/golang.org/x/net/proxy/per_host.go];	
0000000000000000000000000000000000000000;;	package proxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A PerHost directs connections to a default Dialer unless the hostname
0000000000000000000000000000000000000000;;	// requested matches one of a number of exceptions.
0000000000000000000000000000000000000000;;	type PerHost struct {
0000000000000000000000000000000000000000;;		def, bypass Dialer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bypassNetworks []*net.IPNet
0000000000000000000000000000000000000000;;		bypassIPs      []net.IP
0000000000000000000000000000000000000000;;		bypassZones    []string
0000000000000000000000000000000000000000;;		bypassHosts    []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPerHost returns a PerHost Dialer that directs connections to either
0000000000000000000000000000000000000000;;	// defaultDialer or bypass, depending on whether the connection matches one of
0000000000000000000000000000000000000000;;	// the configured rules.
0000000000000000000000000000000000000000;;	func NewPerHost(defaultDialer, bypass Dialer) *PerHost {
0000000000000000000000000000000000000000;;		return &PerHost{
0000000000000000000000000000000000000000;;			def:    defaultDialer,
0000000000000000000000000000000000000000;;			bypass: bypass,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial connects to the address addr on the given network through either
0000000000000000000000000000000000000000;;	// defaultDialer or bypass.
0000000000000000000000000000000000000000;;	func (p *PerHost) Dial(network, addr string) (c net.Conn, err error) {
0000000000000000000000000000000000000000;;		host, _, err := net.SplitHostPort(addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p.dialerForRequest(host).Dial(network, addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *PerHost) dialerForRequest(host string) Dialer {
0000000000000000000000000000000000000000;;		if ip := net.ParseIP(host); ip != nil {
0000000000000000000000000000000000000000;;			for _, net := range p.bypassNetworks {
0000000000000000000000000000000000000000;;				if net.Contains(ip) {
0000000000000000000000000000000000000000;;					return p.bypass
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, bypassIP := range p.bypassIPs {
0000000000000000000000000000000000000000;;				if bypassIP.Equal(ip) {
0000000000000000000000000000000000000000;;					return p.bypass
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p.def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, zone := range p.bypassZones {
0000000000000000000000000000000000000000;;			if strings.HasSuffix(host, zone) {
0000000000000000000000000000000000000000;;				return p.bypass
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if host == zone[1:] {
0000000000000000000000000000000000000000;;				// For a zone "example.com", we match "example.com"
0000000000000000000000000000000000000000;;				// too.
0000000000000000000000000000000000000000;;				return p.bypass
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, bypassHost := range p.bypassHosts {
0000000000000000000000000000000000000000;;			if bypassHost == host {
0000000000000000000000000000000000000000;;				return p.bypass
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.def
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFromString parses a string that contains comma-separated values
0000000000000000000000000000000000000000;;	// specifying hosts that should use the bypass proxy. Each value is either an
0000000000000000000000000000000000000000;;	// IP address, a CIDR range, a zone (*.example.com) or a hostname
0000000000000000000000000000000000000000;;	// (localhost). A best effort is made to parse the string and errors are
0000000000000000000000000000000000000000;;	// ignored.
0000000000000000000000000000000000000000;;	func (p *PerHost) AddFromString(s string) {
0000000000000000000000000000000000000000;;		hosts := strings.Split(s, ",")
0000000000000000000000000000000000000000;;		for _, host := range hosts {
0000000000000000000000000000000000000000;;			host = strings.TrimSpace(host)
0000000000000000000000000000000000000000;;			if len(host) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.Contains(host, "/") {
0000000000000000000000000000000000000000;;				// We assume that it's a CIDR address like 127.0.0.0/8
0000000000000000000000000000000000000000;;				if _, net, err := net.ParseCIDR(host); err == nil {
0000000000000000000000000000000000000000;;					p.AddNetwork(net)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(host); ip != nil {
0000000000000000000000000000000000000000;;				p.AddIP(ip)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(host, "*.") {
0000000000000000000000000000000000000000;;				p.AddZone(host[1:])
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.AddHost(host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddIP specifies an IP address that will use the bypass proxy. Note that
0000000000000000000000000000000000000000;;	// this will only take effect if a literal IP address is dialed. A connection
0000000000000000000000000000000000000000;;	// to a named host will never match an IP.
0000000000000000000000000000000000000000;;	func (p *PerHost) AddIP(ip net.IP) {
0000000000000000000000000000000000000000;;		p.bypassIPs = append(p.bypassIPs, ip)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddNetwork specifies an IP range that will use the bypass proxy. Note that
0000000000000000000000000000000000000000;;	// this will only take effect if a literal IP address is dialed. A connection
0000000000000000000000000000000000000000;;	// to a named host will never match.
0000000000000000000000000000000000000000;;	func (p *PerHost) AddNetwork(net *net.IPNet) {
0000000000000000000000000000000000000000;;		p.bypassNetworks = append(p.bypassNetworks, net)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddZone specifies a DNS suffix that will use the bypass proxy. A zone of
0000000000000000000000000000000000000000;;	// "example.com" matches "example.com" and all of its subdomains.
0000000000000000000000000000000000000000;;	func (p *PerHost) AddZone(zone string) {
0000000000000000000000000000000000000000;;		if strings.HasSuffix(zone, ".") {
0000000000000000000000000000000000000000;;			zone = zone[:len(zone)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(zone, ".") {
0000000000000000000000000000000000000000;;			zone = "." + zone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.bypassZones = append(p.bypassZones, zone)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddHost specifies a hostname that will use the bypass proxy.
0000000000000000000000000000000000000000;;	func (p *PerHost) AddHost(host string) {
0000000000000000000000000000000000000000;;		if strings.HasSuffix(host, ".") {
0000000000000000000000000000000000000000;;			host = host[:len(host)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.bypassHosts = append(p.bypassHosts, host)
0000000000000000000000000000000000000000;;	}
