0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/golang.org/x/net/proxy/proxy.go[Godeps/_workspace/src/golang.org/x/net/proxy/proxy.go][vendor/golang.org/x/net/proxy/proxy.go];	
0000000000000000000000000000000000000000;;	// Package proxy provides support for a variety of protocols to proxy network
0000000000000000000000000000000000000000;;	// data.
0000000000000000000000000000000000000000;;	package proxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Dialer is a means to establish a connection.
0000000000000000000000000000000000000000;;	type Dialer interface {
0000000000000000000000000000000000000000;;		// Dial connects to the given address via the proxy.
0000000000000000000000000000000000000000;;		Dial(network, addr string) (c net.Conn, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Auth contains authentication parameters that specific Dialers may require.
0000000000000000000000000000000000000000;;	type Auth struct {
0000000000000000000000000000000000000000;;		User, Password string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromEnvironment returns the dialer specified by the proxy related variables in
0000000000000000000000000000000000000000;;	// the environment.
0000000000000000000000000000000000000000;;	func FromEnvironment() Dialer {
0000000000000000000000000000000000000000;;		allProxy := os.Getenv("all_proxy")
0000000000000000000000000000000000000000;;		if len(allProxy) == 0 {
0000000000000000000000000000000000000000;;			return Direct
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyURL, err := url.Parse(allProxy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Direct
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxy, err := FromURL(proxyURL, Direct)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Direct
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noProxy := os.Getenv("no_proxy")
0000000000000000000000000000000000000000;;		if len(noProxy) == 0 {
0000000000000000000000000000000000000000;;			return proxy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		perHost := NewPerHost(proxy, Direct)
0000000000000000000000000000000000000000;;		perHost.AddFromString(noProxy)
0000000000000000000000000000000000000000;;		return perHost
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// proxySchemes is a map from URL schemes to a function that creates a Dialer
0000000000000000000000000000000000000000;;	// from a URL with such a scheme.
0000000000000000000000000000000000000000;;	var proxySchemes map[string]func(*url.URL, Dialer) (Dialer, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterDialerType takes a URL scheme and a function to generate Dialers from
0000000000000000000000000000000000000000;;	// a URL with that scheme and a forwarding Dialer. Registered schemes are used
0000000000000000000000000000000000000000;;	// by FromURL.
0000000000000000000000000000000000000000;;	func RegisterDialerType(scheme string, f func(*url.URL, Dialer) (Dialer, error)) {
0000000000000000000000000000000000000000;;		if proxySchemes == nil {
0000000000000000000000000000000000000000;;			proxySchemes = make(map[string]func(*url.URL, Dialer) (Dialer, error))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxySchemes[scheme] = f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromURL returns a Dialer given a URL specification and an underlying
0000000000000000000000000000000000000000;;	// Dialer for it to make network requests.
0000000000000000000000000000000000000000;;	func FromURL(u *url.URL, forward Dialer) (Dialer, error) {
0000000000000000000000000000000000000000;;		var auth *Auth
0000000000000000000000000000000000000000;;		if u.User != nil {
0000000000000000000000000000000000000000;;			auth = new(Auth)
0000000000000000000000000000000000000000;;			auth.User = u.User.Username()
0000000000000000000000000000000000000000;;			if p, ok := u.User.Password(); ok {
0000000000000000000000000000000000000000;;				auth.Password = p
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch u.Scheme {
0000000000000000000000000000000000000000;;		case "socks5":
0000000000000000000000000000000000000000;;			return SOCKS5("tcp", u.Host, auth, forward)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the scheme doesn't match any of the built-in schemes, see if it
0000000000000000000000000000000000000000;;		// was registered by another package.
0000000000000000000000000000000000000000;;		if proxySchemes != nil {
0000000000000000000000000000000000000000;;			if f, ok := proxySchemes[u.Scheme]; ok {
0000000000000000000000000000000000000000;;				return f(u, forward)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, errors.New("proxy: unknown scheme: " + u.Scheme)
0000000000000000000000000000000000000000;;	}
