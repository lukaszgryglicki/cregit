0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5f86d3a99c832846d70d13f1c71f1c4ed2622a9c;;	
0000000000000000000000000000000000000000;;	// Package httplex contains rules around lexical matters of various
0000000000000000000000000000000000000000;;	// HTTP-related specifications.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This package is shared by the standard library (which vendors it)
0000000000000000000000000000000000000000;;	// and x/net/http2. It comes with no API stability promise.
0000000000000000000000000000000000000000;;	package httplex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/idna"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var isTokenTable = [127]bool{
0000000000000000000000000000000000000000;;		'!':  true,
0000000000000000000000000000000000000000;;		'#':  true,
0000000000000000000000000000000000000000;;		'$':  true,
0000000000000000000000000000000000000000;;		'%':  true,
0000000000000000000000000000000000000000;;		'&':  true,
0000000000000000000000000000000000000000;;		'\'': true,
0000000000000000000000000000000000000000;;		'*':  true,
0000000000000000000000000000000000000000;;		'+':  true,
0000000000000000000000000000000000000000;;		'-':  true,
0000000000000000000000000000000000000000;;		'.':  true,
0000000000000000000000000000000000000000;;		'0':  true,
0000000000000000000000000000000000000000;;		'1':  true,
0000000000000000000000000000000000000000;;		'2':  true,
0000000000000000000000000000000000000000;;		'3':  true,
0000000000000000000000000000000000000000;;		'4':  true,
0000000000000000000000000000000000000000;;		'5':  true,
0000000000000000000000000000000000000000;;		'6':  true,
0000000000000000000000000000000000000000;;		'7':  true,
0000000000000000000000000000000000000000;;		'8':  true,
0000000000000000000000000000000000000000;;		'9':  true,
0000000000000000000000000000000000000000;;		'A':  true,
0000000000000000000000000000000000000000;;		'B':  true,
0000000000000000000000000000000000000000;;		'C':  true,
0000000000000000000000000000000000000000;;		'D':  true,
0000000000000000000000000000000000000000;;		'E':  true,
0000000000000000000000000000000000000000;;		'F':  true,
0000000000000000000000000000000000000000;;		'G':  true,
0000000000000000000000000000000000000000;;		'H':  true,
0000000000000000000000000000000000000000;;		'I':  true,
0000000000000000000000000000000000000000;;		'J':  true,
0000000000000000000000000000000000000000;;		'K':  true,
0000000000000000000000000000000000000000;;		'L':  true,
0000000000000000000000000000000000000000;;		'M':  true,
0000000000000000000000000000000000000000;;		'N':  true,
0000000000000000000000000000000000000000;;		'O':  true,
0000000000000000000000000000000000000000;;		'P':  true,
0000000000000000000000000000000000000000;;		'Q':  true,
0000000000000000000000000000000000000000;;		'R':  true,
0000000000000000000000000000000000000000;;		'S':  true,
0000000000000000000000000000000000000000;;		'T':  true,
0000000000000000000000000000000000000000;;		'U':  true,
0000000000000000000000000000000000000000;;		'W':  true,
0000000000000000000000000000000000000000;;		'V':  true,
0000000000000000000000000000000000000000;;		'X':  true,
0000000000000000000000000000000000000000;;		'Y':  true,
0000000000000000000000000000000000000000;;		'Z':  true,
0000000000000000000000000000000000000000;;		'^':  true,
0000000000000000000000000000000000000000;;		'_':  true,
0000000000000000000000000000000000000000;;		'`':  true,
0000000000000000000000000000000000000000;;		'a':  true,
0000000000000000000000000000000000000000;;		'b':  true,
0000000000000000000000000000000000000000;;		'c':  true,
0000000000000000000000000000000000000000;;		'd':  true,
0000000000000000000000000000000000000000;;		'e':  true,
0000000000000000000000000000000000000000;;		'f':  true,
0000000000000000000000000000000000000000;;		'g':  true,
0000000000000000000000000000000000000000;;		'h':  true,
0000000000000000000000000000000000000000;;		'i':  true,
0000000000000000000000000000000000000000;;		'j':  true,
0000000000000000000000000000000000000000;;		'k':  true,
0000000000000000000000000000000000000000;;		'l':  true,
0000000000000000000000000000000000000000;;		'm':  true,
0000000000000000000000000000000000000000;;		'n':  true,
0000000000000000000000000000000000000000;;		'o':  true,
0000000000000000000000000000000000000000;;		'p':  true,
0000000000000000000000000000000000000000;;		'q':  true,
0000000000000000000000000000000000000000;;		'r':  true,
0000000000000000000000000000000000000000;;		's':  true,
0000000000000000000000000000000000000000;;		't':  true,
0000000000000000000000000000000000000000;;		'u':  true,
0000000000000000000000000000000000000000;;		'v':  true,
0000000000000000000000000000000000000000;;		'w':  true,
0000000000000000000000000000000000000000;;		'x':  true,
0000000000000000000000000000000000000000;;		'y':  true,
0000000000000000000000000000000000000000;;		'z':  true,
0000000000000000000000000000000000000000;;		'|':  true,
0000000000000000000000000000000000000000;;		'~':  true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsTokenRune(r rune) bool {
0000000000000000000000000000000000000000;;		i := int(r)
0000000000000000000000000000000000000000;;		return i < len(isTokenTable) && isTokenTable[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isNotToken(r rune) bool {
0000000000000000000000000000000000000000;;		return !IsTokenRune(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HeaderValuesContainsToken reports whether any string in values
0000000000000000000000000000000000000000;;	// contains the provided token, ASCII case-insensitively.
0000000000000000000000000000000000000000;;	func HeaderValuesContainsToken(values []string, token string) bool {
0000000000000000000000000000000000000000;;		for _, v := range values {
0000000000000000000000000000000000000000;;			if headerValueContainsToken(v, token) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isOWS reports whether b is an optional whitespace byte, as defined
0000000000000000000000000000000000000000;;	// by RFC 7230 section 3.2.3.
0000000000000000000000000000000000000000;;	func isOWS(b byte) bool { return b == ' ' || b == '\t' }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// trimOWS returns x with all optional whitespace removes from the
0000000000000000000000000000000000000000;;	// beginning and end.
0000000000000000000000000000000000000000;;	func trimOWS(x string) string {
0000000000000000000000000000000000000000;;		// TODO: consider using strings.Trim(x, " \t") instead,
0000000000000000000000000000000000000000;;		// if and when it's fast enough. See issue 10292.
0000000000000000000000000000000000000000;;		// But this ASCII-only code will probably always beat UTF-8
0000000000000000000000000000000000000000;;		// aware code.
0000000000000000000000000000000000000000;;		for len(x) > 0 && isOWS(x[0]) {
0000000000000000000000000000000000000000;;			x = x[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for len(x) > 0 && isOWS(x[len(x)-1]) {
0000000000000000000000000000000000000000;;			x = x[:len(x)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// headerValueContainsToken reports whether v (assumed to be a
0000000000000000000000000000000000000000;;	// 0#element, in the ABNF extension described in RFC 7230 section 7)
0000000000000000000000000000000000000000;;	// contains token amongst its comma-separated tokens, ASCII
0000000000000000000000000000000000000000;;	// case-insensitively.
0000000000000000000000000000000000000000;;	func headerValueContainsToken(v string, token string) bool {
0000000000000000000000000000000000000000;;		v = trimOWS(v)
0000000000000000000000000000000000000000;;		if comma := strings.IndexByte(v, ','); comma != -1 {
0000000000000000000000000000000000000000;;			return tokenEqual(trimOWS(v[:comma]), token) || headerValueContainsToken(v[comma+1:], token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tokenEqual(v, token)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lowerASCII returns the ASCII lowercase version of b.
0000000000000000000000000000000000000000;;	func lowerASCII(b byte) byte {
0000000000000000000000000000000000000000;;		if 'A' <= b && b <= 'Z' {
0000000000000000000000000000000000000000;;			return b + ('a' - 'A')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tokenEqual reports whether t1 and t2 are equal, ASCII case-insensitively.
0000000000000000000000000000000000000000;;	func tokenEqual(t1, t2 string) bool {
0000000000000000000000000000000000000000;;		if len(t1) != len(t2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, b := range t1 {
0000000000000000000000000000000000000000;;			if b >= utf8.RuneSelf {
0000000000000000000000000000000000000000;;				// No UTF-8 or non-ASCII allowed in tokens.
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lowerASCII(byte(b)) != lowerASCII(t2[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isLWS reports whether b is linear white space, according
0000000000000000000000000000000000000000;;	// to http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2
0000000000000000000000000000000000000000;;	//      LWS            = [CRLF] 1*( SP | HT )
0000000000000000000000000000000000000000;;	func isLWS(b byte) bool { return b == ' ' || b == '\t' }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isCTL reports whether b is a control byte, according
0000000000000000000000000000000000000000;;	// to http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2
0000000000000000000000000000000000000000;;	//      CTL            = <any US-ASCII control character
0000000000000000000000000000000000000000;;	//                       (octets 0 - 31) and DEL (127)>
0000000000000000000000000000000000000000;;	func isCTL(b byte) bool {
0000000000000000000000000000000000000000;;		const del = 0x7f // a CTL
0000000000000000000000000000000000000000;;		return b < ' ' || b == del
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidHeaderFieldName reports whether v is a valid HTTP/1.x header name.
0000000000000000000000000000000000000000;;	// HTTP/2 imposes the additional restriction that uppercase ASCII
0000000000000000000000000000000000000000;;	// letters are not allowed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  RFC 7230 says:
0000000000000000000000000000000000000000;;	//   header-field   = field-name ":" OWS field-value OWS
0000000000000000000000000000000000000000;;	//   field-name     = token
0000000000000000000000000000000000000000;;	//   token          = 1*tchar
0000000000000000000000000000000000000000;;	//   tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
0000000000000000000000000000000000000000;;	//           "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
0000000000000000000000000000000000000000;;	func ValidHeaderFieldName(v string) bool {
0000000000000000000000000000000000000000;;		if len(v) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, r := range v {
0000000000000000000000000000000000000000;;			if !IsTokenRune(r) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidHostHeader reports whether h is a valid host header.
0000000000000000000000000000000000000000;;	func ValidHostHeader(h string) bool {
0000000000000000000000000000000000000000;;		// The latest spec is actually this:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// http://tools.ietf.org/html/rfc7230#section-5.4
0000000000000000000000000000000000000000;;		//     Host = uri-host [ ":" port ]
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Where uri-host is:
0000000000000000000000000000000000000000;;		//     http://tools.ietf.org/html/rfc3986#section-3.2.2
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// But we're going to be much more lenient for now and just
0000000000000000000000000000000000000000;;		// search for any byte that's not a valid byte in any of those
0000000000000000000000000000000000000000;;		// expressions.
0000000000000000000000000000000000000000;;		for i := 0; i < len(h); i++ {
0000000000000000000000000000000000000000;;			if !validHostByte[h[i]] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See the validHostHeader comment.
0000000000000000000000000000000000000000;;	var validHostByte = [256]bool{
0000000000000000000000000000000000000000;;		'0': true, '1': true, '2': true, '3': true, '4': true, '5': true, '6': true, '7': true,
0000000000000000000000000000000000000000;;		'8': true, '9': true,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		'a': true, 'b': true, 'c': true, 'd': true, 'e': true, 'f': true, 'g': true, 'h': true,
0000000000000000000000000000000000000000;;		'i': true, 'j': true, 'k': true, 'l': true, 'm': true, 'n': true, 'o': true, 'p': true,
0000000000000000000000000000000000000000;;		'q': true, 'r': true, 's': true, 't': true, 'u': true, 'v': true, 'w': true, 'x': true,
0000000000000000000000000000000000000000;;		'y': true, 'z': true,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		'A': true, 'B': true, 'C': true, 'D': true, 'E': true, 'F': true, 'G': true, 'H': true,
0000000000000000000000000000000000000000;;		'I': true, 'J': true, 'K': true, 'L': true, 'M': true, 'N': true, 'O': true, 'P': true,
0000000000000000000000000000000000000000;;		'Q': true, 'R': true, 'S': true, 'T': true, 'U': true, 'V': true, 'W': true, 'X': true,
0000000000000000000000000000000000000000;;		'Y': true, 'Z': true,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		'!':  true, // sub-delims
0000000000000000000000000000000000000000;;		'$':  true, // sub-delims
0000000000000000000000000000000000000000;;		'%':  true, // pct-encoded (and used in IPv6 zones)
0000000000000000000000000000000000000000;;		'&':  true, // sub-delims
0000000000000000000000000000000000000000;;		'(':  true, // sub-delims
0000000000000000000000000000000000000000;;		')':  true, // sub-delims
0000000000000000000000000000000000000000;;		'*':  true, // sub-delims
0000000000000000000000000000000000000000;;		'+':  true, // sub-delims
0000000000000000000000000000000000000000;;		',':  true, // sub-delims
0000000000000000000000000000000000000000;;		'-':  true, // unreserved
0000000000000000000000000000000000000000;;		'.':  true, // unreserved
0000000000000000000000000000000000000000;;		':':  true, // IPv6address + Host expression's optional port
0000000000000000000000000000000000000000;;		';':  true, // sub-delims
0000000000000000000000000000000000000000;;		'=':  true, // sub-delims
0000000000000000000000000000000000000000;;		'[':  true,
0000000000000000000000000000000000000000;;		'\'': true, // sub-delims
0000000000000000000000000000000000000000;;		']':  true,
0000000000000000000000000000000000000000;;		'_':  true, // unreserved
0000000000000000000000000000000000000000;;		'~':  true, // unreserved
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidHeaderFieldValue reports whether v is a valid "field-value" according to
0000000000000000000000000000000000000000;;	// http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 :
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//        message-header = field-name ":" [ field-value ]
0000000000000000000000000000000000000000;;	//        field-value    = *( field-content | LWS )
0000000000000000000000000000000000000000;;	//        field-content  = <the OCTETs making up the field-value
0000000000000000000000000000000000000000;;	//                         and consisting of either *TEXT or combinations
0000000000000000000000000000000000000000;;	//                         of token, separators, and quoted-string>
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2 :
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//        TEXT           = <any OCTET except CTLs,
0000000000000000000000000000000000000000;;	//                          but including LWS>
0000000000000000000000000000000000000000;;	//        LWS            = [CRLF] 1*( SP | HT )
0000000000000000000000000000000000000000;;	//        CTL            = <any US-ASCII control character
0000000000000000000000000000000000000000;;	//                         (octets 0 - 31) and DEL (127)>
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// RFC 7230 says:
0000000000000000000000000000000000000000;;	//  field-value    = *( field-content / obs-fold )
0000000000000000000000000000000000000000;;	//  obj-fold       =  N/A to http2, and deprecated
0000000000000000000000000000000000000000;;	//  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
0000000000000000000000000000000000000000;;	//  field-vchar    = VCHAR / obs-text
0000000000000000000000000000000000000000;;	//  obs-text       = %x80-FF
0000000000000000000000000000000000000000;;	//  VCHAR          = "any visible [USASCII] character"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http2 further says: "Similarly, HTTP/2 allows header field values
0000000000000000000000000000000000000000;;	// that are not valid. While most of the values that can be encoded
0000000000000000000000000000000000000000;;	// will not alter header field parsing, carriage return (CR, ASCII
0000000000000000000000000000000000000000;;	// 0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII
0000000000000000000000000000000000000000;;	// 0x0) might be exploited by an attacker if they are translated
0000000000000000000000000000000000000000;;	// verbatim. Any request or response that contains a character not
0000000000000000000000000000000000000000;;	// permitted in a header field value MUST be treated as malformed
0000000000000000000000000000000000000000;;	// (Section 8.1.2.6). Valid characters are defined by the
0000000000000000000000000000000000000000;;	// field-content ABNF rule in Section 3.2 of [RFC7230]."
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This function does not (yet?) properly handle the rejection of
0000000000000000000000000000000000000000;;	// strings that begin or end with SP or HTAB.
0000000000000000000000000000000000000000;;	func ValidHeaderFieldValue(v string) bool {
0000000000000000000000000000000000000000;;		for i := 0; i < len(v); i++ {
0000000000000000000000000000000000000000;;			b := v[i]
0000000000000000000000000000000000000000;;			if isCTL(b) && !isLWS(b) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isASCII(s string) bool {
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			if s[i] >= utf8.RuneSelf {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PunycodeHostPort returns the IDNA Punycode version
0000000000000000000000000000000000000000;;	// of the provided "host" or "host:port" string.
0000000000000000000000000000000000000000;;	func PunycodeHostPort(v string) (string, error) {
0000000000000000000000000000000000000000;;		if isASCII(v) {
0000000000000000000000000000000000000000;;			return v, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host, port, err := net.SplitHostPort(v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// The input 'v' argument was just a "host" argument,
0000000000000000000000000000000000000000;;			// without a port. This error should not be returned
0000000000000000000000000000000000000000;;			// to the caller.
0000000000000000000000000000000000000000;;			host = v
0000000000000000000000000000000000000000;;			port = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		host, err = idna.ToASCII(host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Non-UTF-8? Not representable in Punycode, in any
0000000000000000000000000000000000000000;;			// case.
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if port == "" {
0000000000000000000000000000000000000000;;			return host, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return net.JoinHostPort(host, port), nil
0000000000000000000000000000000000000000;;	}
