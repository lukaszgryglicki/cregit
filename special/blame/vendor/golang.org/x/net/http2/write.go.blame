0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/write.go[Godeps/_workspace/src/github.com/bradfitz/http2/write.go][vendor/golang.org/x/net/http2/write.go];	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2/hpack"
0000000000000000000000000000000000000000;;		"golang.org/x/net/lex/httplex"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeFramer is implemented by any type that is used to write frames.
0000000000000000000000000000000000000000;;	type writeFramer interface {
0000000000000000000000000000000000000000;;		writeFrame(writeContext) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// staysWithinBuffer reports whether this writer promises that
0000000000000000000000000000000000000000;;		// it will only write less than or equal to size bytes, and it
0000000000000000000000000000000000000000;;		// won't Flush the write context.
0000000000000000000000000000000000000000;;		staysWithinBuffer(size int) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeContext is the interface needed by the various frame writer
0000000000000000000000000000000000000000;;	// types below. All the writeFrame methods below are scheduled via the
0000000000000000000000000000000000000000;;	// frame writing scheduler (see writeScheduler in writesched.go).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This interface is implemented by *serverConn.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: decide whether to a) use this in the client code (which didn't
0000000000000000000000000000000000000000;;	// end up using this yet, because it has a simpler design, not
0000000000000000000000000000000000000000;;	// currently implementing priorities), or b) delete this and
0000000000000000000000000000000000000000;;	// make the server code a bit more concrete.
0000000000000000000000000000000000000000;;	type writeContext interface {
0000000000000000000000000000000000000000;;		Framer() *Framer
0000000000000000000000000000000000000000;;		Flush() error
0000000000000000000000000000000000000000;;		CloseConn() error
0000000000000000000000000000000000000000;;		// HeaderEncoder returns an HPACK encoder that writes to the
0000000000000000000000000000000000000000;;		// returned buffer.
0000000000000000000000000000000000000000;;		HeaderEncoder() (*hpack.Encoder, *bytes.Buffer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeEndsStream reports whether w writes a frame that will transition
0000000000000000000000000000000000000000;;	// the stream to a half-closed local state. This returns false for RST_STREAM,
0000000000000000000000000000000000000000;;	// which closes the entire stream (not just the local half).
0000000000000000000000000000000000000000;;	func writeEndsStream(w writeFramer) bool {
0000000000000000000000000000000000000000;;		switch v := w.(type) {
0000000000000000000000000000000000000000;;		case *writeData:
0000000000000000000000000000000000000000;;			return v.endStream
0000000000000000000000000000000000000000;;		case *writeResHeaders:
0000000000000000000000000000000000000000;;			return v.endStream
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			// This can only happen if the caller reuses w after it's
0000000000000000000000000000000000000000;;			// been intentionally nil'ed out to prevent use. Keep this
0000000000000000000000000000000000000000;;			// here to catch future refactoring breaking it.
0000000000000000000000000000000000000000;;			panic("writeEndsStream called on nil writeFramer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type flushFrameWriter struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (flushFrameWriter) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		return ctx.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (flushFrameWriter) staysWithinBuffer(max int) bool { return false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type writeSettings []Setting
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s writeSettings) staysWithinBuffer(max int) bool {
0000000000000000000000000000000000000000;;		const settingSize = 6 // uint16 + uint32
0000000000000000000000000000000000000000;;		return frameHeaderLen+settingSize*len(s) <= max
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s writeSettings) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		return ctx.Framer().WriteSettings([]Setting(s)...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type writeGoAway struct {
0000000000000000000000000000000000000000;;		maxStreamID uint32
0000000000000000000000000000000000000000;;		code        ErrCode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *writeGoAway) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		err := ctx.Framer().WriteGoAway(p.maxStreamID, p.code, nil)
0000000000000000000000000000000000000000;;		if p.code != 0 {
0000000000000000000000000000000000000000;;			ctx.Flush() // ignore error: we're hanging up on them anyway
0000000000000000000000000000000000000000;;			time.Sleep(50 * time.Millisecond)
0000000000000000000000000000000000000000;;			ctx.CloseConn()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*writeGoAway) staysWithinBuffer(max int) bool { return false } // flushes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type writeData struct {
0000000000000000000000000000000000000000;;		streamID  uint32
0000000000000000000000000000000000000000;;		p         []byte
0000000000000000000000000000000000000000;;		endStream bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *writeData) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("writeData(stream=%d, p=%d, endStream=%v)", w.streamID, len(w.p), w.endStream)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *writeData) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		return ctx.Framer().WriteData(w.streamID, w.endStream, w.p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *writeData) staysWithinBuffer(max int) bool {
0000000000000000000000000000000000000000;;		return frameHeaderLen+len(w.p) <= max
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handlerPanicRST is the message sent from handler goroutines when
0000000000000000000000000000000000000000;;	// the handler panics.
0000000000000000000000000000000000000000;;	type handlerPanicRST struct {
0000000000000000000000000000000000000000;;		StreamID uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hp handlerPanicRST) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		return ctx.Framer().WriteRSTStream(hp.StreamID, ErrCodeInternal)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hp handlerPanicRST) staysWithinBuffer(max int) bool { return frameHeaderLen+4 <= max }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (se StreamError) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		return ctx.Framer().WriteRSTStream(se.StreamID, se.Code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (se StreamError) staysWithinBuffer(max int) bool { return frameHeaderLen+4 <= max }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type writePingAck struct{ pf *PingFrame }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w writePingAck) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		return ctx.Framer().WritePing(true, w.pf.Data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w writePingAck) staysWithinBuffer(max int) bool { return frameHeaderLen+len(w.pf.Data) <= max }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type writeSettingsAck struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (writeSettingsAck) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		return ctx.Framer().WriteSettingsAck()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (writeSettingsAck) staysWithinBuffer(max int) bool { return frameHeaderLen <= max }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitHeaderBlock splits headerBlock into fragments so that each fragment fits
0000000000000000000000000000000000000000;;	// in a single frame, then calls fn for each fragment. firstFrag/lastFrag are true
0000000000000000000000000000000000000000;;	// for the first/last fragment, respectively.
0000000000000000000000000000000000000000;;	func splitHeaderBlock(ctx writeContext, headerBlock []byte, fn func(ctx writeContext, frag []byte, firstFrag, lastFrag bool) error) error {
0000000000000000000000000000000000000000;;		// For now we're lazy and just pick the minimum MAX_FRAME_SIZE
0000000000000000000000000000000000000000;;		// that all peers must support (16KB). Later we could care
0000000000000000000000000000000000000000;;		// more and send larger frames if the peer advertised it, but
0000000000000000000000000000000000000000;;		// there's little point. Most headers are small anyway (so we
0000000000000000000000000000000000000000;;		// generally won't have CONTINUATION frames), and extra frames
0000000000000000000000000000000000000000;;		// only waste 9 bytes anyway.
0000000000000000000000000000000000000000;;		const maxFrameSize = 16384
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		first := true
0000000000000000000000000000000000000000;;		for len(headerBlock) > 0 {
0000000000000000000000000000000000000000;;			frag := headerBlock
0000000000000000000000000000000000000000;;			if len(frag) > maxFrameSize {
0000000000000000000000000000000000000000;;				frag = frag[:maxFrameSize]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			headerBlock = headerBlock[len(frag):]
0000000000000000000000000000000000000000;;			if err := fn(ctx, frag, first, len(headerBlock) == 0); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			first = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeResHeaders is a request to write a HEADERS and 0+ CONTINUATION frames
0000000000000000000000000000000000000000;;	// for HTTP response headers or trailers from a server handler.
0000000000000000000000000000000000000000;;	type writeResHeaders struct {
0000000000000000000000000000000000000000;;		streamID    uint32
0000000000000000000000000000000000000000;;		httpResCode int         // 0 means no ":status" line
0000000000000000000000000000000000000000;;		h           http.Header // may be nil
0000000000000000000000000000000000000000;;		trailers    []string    // if non-nil, which keys of h to write. nil means all.
0000000000000000000000000000000000000000;;		endStream   bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		date          string
0000000000000000000000000000000000000000;;		contentType   string
0000000000000000000000000000000000000000;;		contentLength string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encKV(enc *hpack.Encoder, k, v string) {
0000000000000000000000000000000000000000;;		if VerboseLogs {
0000000000000000000000000000000000000000;;			log.Printf("http2: server encoding header %q = %q", k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		enc.WriteField(hpack.HeaderField{Name: k, Value: v})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *writeResHeaders) staysWithinBuffer(max int) bool {
0000000000000000000000000000000000000000;;		// TODO: this is a common one. It'd be nice to return true
0000000000000000000000000000000000000000;;		// here and get into the fast path if we could be clever and
0000000000000000000000000000000000000000;;		// calculate the size fast enough, or at least a conservative
0000000000000000000000000000000000000000;;		// uppper bound that usually fires. (Maybe if w.h and
0000000000000000000000000000000000000000;;		// w.trailers are nil, so we don't need to enumerate it.)
0000000000000000000000000000000000000000;;		// Otherwise I'm afraid that just calculating the length to
0000000000000000000000000000000000000000;;		// answer this question would be slower than the ~2Âµs benefit.
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *writeResHeaders) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		enc, buf := ctx.HeaderEncoder()
0000000000000000000000000000000000000000;;		buf.Reset()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.httpResCode != 0 {
0000000000000000000000000000000000000000;;			encKV(enc, ":status", httpCodeString(w.httpResCode))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encodeHeaders(enc, w.h, w.trailers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.contentType != "" {
0000000000000000000000000000000000000000;;			encKV(enc, "content-type", w.contentType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w.contentLength != "" {
0000000000000000000000000000000000000000;;			encKV(enc, "content-length", w.contentLength)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if w.date != "" {
0000000000000000000000000000000000000000;;			encKV(enc, "date", w.date)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headerBlock := buf.Bytes()
0000000000000000000000000000000000000000;;		if len(headerBlock) == 0 && w.trailers == nil {
0000000000000000000000000000000000000000;;			panic("unexpected empty hpack")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *writeResHeaders) writeHeaderBlock(ctx writeContext, frag []byte, firstFrag, lastFrag bool) error {
0000000000000000000000000000000000000000;;		if firstFrag {
0000000000000000000000000000000000000000;;			return ctx.Framer().WriteHeaders(HeadersFrameParam{
0000000000000000000000000000000000000000;;				StreamID:      w.streamID,
0000000000000000000000000000000000000000;;				BlockFragment: frag,
0000000000000000000000000000000000000000;;				EndStream:     w.endStream,
0000000000000000000000000000000000000000;;				EndHeaders:    lastFrag,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writePushPromise is a request to write a PUSH_PROMISE and 0+ CONTINUATION frames.
0000000000000000000000000000000000000000;;	type writePushPromise struct {
0000000000000000000000000000000000000000;;		streamID uint32   // pusher stream
0000000000000000000000000000000000000000;;		method   string   // for :method
0000000000000000000000000000000000000000;;		url      *url.URL // for :scheme, :authority, :path
0000000000000000000000000000000000000000;;		h        http.Header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Creates an ID for a pushed stream. This runs on serveG just before
0000000000000000000000000000000000000000;;		// the frame is written. The returned ID is copied to promisedID.
0000000000000000000000000000000000000000;;		allocatePromisedID func() (uint32, error)
0000000000000000000000000000000000000000;;		promisedID         uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *writePushPromise) staysWithinBuffer(max int) bool {
0000000000000000000000000000000000000000;;		// TODO: see writeResHeaders.staysWithinBuffer
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *writePushPromise) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		enc, buf := ctx.HeaderEncoder()
0000000000000000000000000000000000000000;;		buf.Reset()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encKV(enc, ":method", w.method)
0000000000000000000000000000000000000000;;		encKV(enc, ":scheme", w.url.Scheme)
0000000000000000000000000000000000000000;;		encKV(enc, ":authority", w.url.Host)
0000000000000000000000000000000000000000;;		encKV(enc, ":path", w.url.RequestURI())
0000000000000000000000000000000000000000;;		encodeHeaders(enc, w.h, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headerBlock := buf.Bytes()
0000000000000000000000000000000000000000;;		if len(headerBlock) == 0 {
0000000000000000000000000000000000000000;;			panic("unexpected empty hpack")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return splitHeaderBlock(ctx, headerBlock, w.writeHeaderBlock)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *writePushPromise) writeHeaderBlock(ctx writeContext, frag []byte, firstFrag, lastFrag bool) error {
0000000000000000000000000000000000000000;;		if firstFrag {
0000000000000000000000000000000000000000;;			return ctx.Framer().WritePushPromise(PushPromiseParam{
0000000000000000000000000000000000000000;;				StreamID:      w.streamID,
0000000000000000000000000000000000000000;;				PromiseID:     w.promisedID,
0000000000000000000000000000000000000000;;				BlockFragment: frag,
0000000000000000000000000000000000000000;;				EndHeaders:    lastFrag,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return ctx.Framer().WriteContinuation(w.streamID, lastFrag, frag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type write100ContinueHeadersFrame struct {
0000000000000000000000000000000000000000;;		streamID uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w write100ContinueHeadersFrame) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		enc, buf := ctx.HeaderEncoder()
0000000000000000000000000000000000000000;;		buf.Reset()
0000000000000000000000000000000000000000;;		encKV(enc, ":status", "100")
0000000000000000000000000000000000000000;;		return ctx.Framer().WriteHeaders(HeadersFrameParam{
0000000000000000000000000000000000000000;;			StreamID:      w.streamID,
0000000000000000000000000000000000000000;;			BlockFragment: buf.Bytes(),
0000000000000000000000000000000000000000;;			EndStream:     false,
0000000000000000000000000000000000000000;;			EndHeaders:    true,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w write100ContinueHeadersFrame) staysWithinBuffer(max int) bool {
0000000000000000000000000000000000000000;;		// Sloppy but conservative:
0000000000000000000000000000000000000000;;		return 9+2*(len(":status")+len("100")) <= max
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type writeWindowUpdate struct {
0000000000000000000000000000000000000000;;		streamID uint32 // or 0 for conn-level
0000000000000000000000000000000000000000;;		n        uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wu writeWindowUpdate) staysWithinBuffer(max int) bool { return frameHeaderLen+4 <= max }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wu writeWindowUpdate) writeFrame(ctx writeContext) error {
0000000000000000000000000000000000000000;;		return ctx.Framer().WriteWindowUpdate(wu.streamID, wu.n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encodeHeaders encodes an http.Header. If keys is not nil, then (k, h[k])
0000000000000000000000000000000000000000;;	// is encoded only only if k is in keys.
0000000000000000000000000000000000000000;;	func encodeHeaders(enc *hpack.Encoder, h http.Header, keys []string) {
0000000000000000000000000000000000000000;;		if keys == nil {
0000000000000000000000000000000000000000;;			sorter := sorterPool.Get().(*sorter)
0000000000000000000000000000000000000000;;			// Using defer here, since the returned keys from the
0000000000000000000000000000000000000000;;			// sorter.Keys method is only valid until the sorter
0000000000000000000000000000000000000000;;			// is returned:
0000000000000000000000000000000000000000;;			defer sorterPool.Put(sorter)
0000000000000000000000000000000000000000;;			keys = sorter.Keys(h)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			vv := h[k]
0000000000000000000000000000000000000000;;			k = lowerHeader(k)
0000000000000000000000000000000000000000;;			if !validWireHeaderFieldName(k) {
0000000000000000000000000000000000000000;;				// Skip it as backup paranoia. Per
0000000000000000000000000000000000000000;;				// golang.org/issue/14048, these should
0000000000000000000000000000000000000000;;				// already be rejected at a higher level.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			isTE := k == "transfer-encoding"
0000000000000000000000000000000000000000;;			for _, v := range vv {
0000000000000000000000000000000000000000;;				if !httplex.ValidHeaderFieldValue(v) {
0000000000000000000000000000000000000000;;					// TODO: return an error? golang.org/issue/14048
0000000000000000000000000000000000000000;;					// For now just omit it.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// TODO: more of "8.1.2.2 Connection-Specific Header Fields"
0000000000000000000000000000000000000000;;				if isTE && v != "trailers" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				encKV(enc, k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
