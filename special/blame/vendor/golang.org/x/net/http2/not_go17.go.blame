0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5f86d3a99c832846d70d13f1c71f1c4ed2622a9c;;	
0000000000000000000000000000000000000000;;	// +build !go1.7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type contextContext interface {
0000000000000000000000000000000000000000;;		Done() <-chan struct{}
0000000000000000000000000000000000000000;;		Err() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeContext struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fakeContext) Done() <-chan struct{} { return nil }
0000000000000000000000000000000000000000;;	func (fakeContext) Err() error            { panic("should not be called") }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reqContext(r *http.Request) fakeContext {
0000000000000000000000000000000000000000;;		return fakeContext{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setResponseUncompressed(res *http.Response) {
0000000000000000000000000000000000000000;;		// Nothing.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clientTrace struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func requestTrace(*http.Request) *clientTrace { return nil }
0000000000000000000000000000000000000000;;	func traceGotConn(*http.Request, *ClientConn) {}
0000000000000000000000000000000000000000;;	func traceFirstResponseByte(*clientTrace)     {}
0000000000000000000000000000000000000000;;	func traceWroteHeaders(*clientTrace)          {}
0000000000000000000000000000000000000000;;	func traceWroteRequest(*clientTrace, error)   {}
0000000000000000000000000000000000000000;;	func traceGot100Continue(trace *clientTrace)  {}
0000000000000000000000000000000000000000;;	func traceWait100Continue(trace *clientTrace) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nop() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serverConnBaseContext(c net.Conn, opts *ServeConnOpts) (ctx contextContext, cancel func()) {
0000000000000000000000000000000000000000;;		return nil, nop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contextWithCancel(ctx contextContext) (_ contextContext, cancel func()) {
0000000000000000000000000000000000000000;;		return ctx, nop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func requestWithContext(req *http.Request, ctx contextContext) *http.Request {
0000000000000000000000000000000000000000;;		return req
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// temporary copy of Go 1.6's private tls.Config.clone:
0000000000000000000000000000000000000000;;	func cloneTLSConfig(c *tls.Config) *tls.Config {
0000000000000000000000000000000000000000;;		return &tls.Config{
0000000000000000000000000000000000000000;;			Rand:                     c.Rand,
0000000000000000000000000000000000000000;;			Time:                     c.Time,
0000000000000000000000000000000000000000;;			Certificates:             c.Certificates,
0000000000000000000000000000000000000000;;			NameToCertificate:        c.NameToCertificate,
0000000000000000000000000000000000000000;;			GetCertificate:           c.GetCertificate,
0000000000000000000000000000000000000000;;			RootCAs:                  c.RootCAs,
0000000000000000000000000000000000000000;;			NextProtos:               c.NextProtos,
0000000000000000000000000000000000000000;;			ServerName:               c.ServerName,
0000000000000000000000000000000000000000;;			ClientAuth:               c.ClientAuth,
0000000000000000000000000000000000000000;;			ClientCAs:                c.ClientCAs,
0000000000000000000000000000000000000000;;			InsecureSkipVerify:       c.InsecureSkipVerify,
0000000000000000000000000000000000000000;;			CipherSuites:             c.CipherSuites,
0000000000000000000000000000000000000000;;			PreferServerCipherSuites: c.PreferServerCipherSuites,
0000000000000000000000000000000000000000;;			SessionTicketsDisabled:   c.SessionTicketsDisabled,
0000000000000000000000000000000000000000;;			SessionTicketKey:         c.SessionTicketKey,
0000000000000000000000000000000000000000;;			ClientSessionCache:       c.ClientSessionCache,
0000000000000000000000000000000000000000;;			MinVersion:               c.MinVersion,
0000000000000000000000000000000000000000;;			MaxVersion:               c.MaxVersion,
0000000000000000000000000000000000000000;;			CurvePreferences:         c.CurvePreferences,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) Ping(ctx contextContext) error {
0000000000000000000000000000000000000000;;		return cc.ping(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) idleConnTimeout() time.Duration { return 0 }
