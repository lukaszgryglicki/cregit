0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5f86d3a99c832846d70d13f1c71f1c4ed2622a9c;;	
0000000000000000000000000000000000000000;;	// +build go1.7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptrace"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type contextContext interface {
0000000000000000000000000000000000000000;;		context.Context
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serverConnBaseContext(c net.Conn, opts *ServeConnOpts) (ctx contextContext, cancel func()) {
0000000000000000000000000000000000000000;;		ctx, cancel = context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		ctx = context.WithValue(ctx, http.LocalAddrContextKey, c.LocalAddr())
0000000000000000000000000000000000000000;;		if hs := opts.baseConfig(); hs != nil {
0000000000000000000000000000000000000000;;			ctx = context.WithValue(ctx, http.ServerContextKey, hs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contextWithCancel(ctx contextContext) (_ contextContext, cancel func()) {
0000000000000000000000000000000000000000;;		return context.WithCancel(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func requestWithContext(req *http.Request, ctx contextContext) *http.Request {
0000000000000000000000000000000000000000;;		return req.WithContext(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clientTrace httptrace.ClientTrace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reqContext(r *http.Request) context.Context { return r.Context() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) idleConnTimeout() time.Duration {
0000000000000000000000000000000000000000;;		if t.t1 != nil {
0000000000000000000000000000000000000000;;			return t.t1.IdleConnTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setResponseUncompressed(res *http.Response) { res.Uncompressed = true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func traceGotConn(req *http.Request, cc *ClientConn) {
0000000000000000000000000000000000000000;;		trace := httptrace.ContextClientTrace(req.Context())
0000000000000000000000000000000000000000;;		if trace == nil || trace.GotConn == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ci := httptrace.GotConnInfo{Conn: cc.tconn}
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		ci.Reused = cc.nextStreamID > 1
0000000000000000000000000000000000000000;;		ci.WasIdle = len(cc.streams) == 0 && ci.Reused
0000000000000000000000000000000000000000;;		if ci.WasIdle && !cc.lastActive.IsZero() {
0000000000000000000000000000000000000000;;			ci.IdleTime = time.Now().Sub(cc.lastActive)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trace.GotConn(ci)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func traceWroteHeaders(trace *clientTrace) {
0000000000000000000000000000000000000000;;		if trace != nil && trace.WroteHeaders != nil {
0000000000000000000000000000000000000000;;			trace.WroteHeaders()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func traceGot100Continue(trace *clientTrace) {
0000000000000000000000000000000000000000;;		if trace != nil && trace.Got100Continue != nil {
0000000000000000000000000000000000000000;;			trace.Got100Continue()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func traceWait100Continue(trace *clientTrace) {
0000000000000000000000000000000000000000;;		if trace != nil && trace.Wait100Continue != nil {
0000000000000000000000000000000000000000;;			trace.Wait100Continue()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func traceWroteRequest(trace *clientTrace, err error) {
0000000000000000000000000000000000000000;;		if trace != nil && trace.WroteRequest != nil {
0000000000000000000000000000000000000000;;			trace.WroteRequest(httptrace.WroteRequestInfo{Err: err})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func traceFirstResponseByte(trace *clientTrace) {
0000000000000000000000000000000000000000;;		if trace != nil && trace.GotFirstResponseByte != nil {
0000000000000000000000000000000000000000;;			trace.GotFirstResponseByte()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func requestTrace(req *http.Request) *clientTrace {
0000000000000000000000000000000000000000;;		trace := httptrace.ContextClientTrace(req.Context())
0000000000000000000000000000000000000000;;		return (*clientTrace)(trace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ping sends a PING frame to the server and waits for the ack.
0000000000000000000000000000000000000000;;	func (cc *ClientConn) Ping(ctx context.Context) error {
0000000000000000000000000000000000000000;;		return cc.ping(ctx)
0000000000000000000000000000000000000000;;	}
