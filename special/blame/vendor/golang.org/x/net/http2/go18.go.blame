0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	// +build go1.8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cloneTLSConfig(c *tls.Config) *tls.Config { return c.Clone() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ http.Pusher = (*responseWriter)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Push implements http.Pusher.
0000000000000000000000000000000000000000;;	func (w *responseWriter) Push(target string, opts *http.PushOptions) error {
0000000000000000000000000000000000000000;;		internalOpts := pushOptions{}
0000000000000000000000000000000000000000;;		if opts != nil {
0000000000000000000000000000000000000000;;			internalOpts.Method = opts.Method
0000000000000000000000000000000000000000;;			internalOpts.Header = opts.Header
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.push(target, internalOpts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func configureServer18(h1 *http.Server, h2 *Server) error {
0000000000000000000000000000000000000000;;		if h2.IdleTimeout == 0 {
0000000000000000000000000000000000000000;;			if h1.IdleTimeout != 0 {
0000000000000000000000000000000000000000;;				h2.IdleTimeout = h1.IdleTimeout
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				h2.IdleTimeout = h1.ReadTimeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shouldLogPanic(panicValue interface{}) bool {
0000000000000000000000000000000000000000;;		return panicValue != nil && panicValue != http.ErrAbortHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reqGetBody(req *http.Request) func() (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		return req.GetBody
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reqBodyIsNoBody(body io.ReadCloser) bool {
0000000000000000000000000000000000000000;;		return body == http.NoBody
0000000000000000000000000000000000000000;;	}
