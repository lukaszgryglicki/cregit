0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "math"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRandomWriteScheduler constructs a WriteScheduler that ignores HTTP/2
0000000000000000000000000000000000000000;;	// priorities. Control frames like SETTINGS and PING are written before DATA
0000000000000000000000000000000000000000;;	// frames, but if no control frames are queued and multiple streams have queued
0000000000000000000000000000000000000000;;	// HEADERS or DATA frames, Pop selects a ready stream arbitrarily.
0000000000000000000000000000000000000000;;	func NewRandomWriteScheduler() WriteScheduler {
0000000000000000000000000000000000000000;;		return &randomWriteScheduler{sq: make(map[uint32]*writeQueue)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type randomWriteScheduler struct {
0000000000000000000000000000000000000000;;		// zero are frames not associated with a specific stream.
0000000000000000000000000000000000000000;;		zero writeQueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sq contains the stream-specific queues, keyed by stream ID.
0000000000000000000000000000000000000000;;		// When a stream is idle or closed, it's deleted from the map.
0000000000000000000000000000000000000000;;		sq map[uint32]*writeQueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pool of empty queues for reuse.
0000000000000000000000000000000000000000;;		queuePool writeQueuePool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *randomWriteScheduler) OpenStream(streamID uint32, options OpenStreamOptions) {
0000000000000000000000000000000000000000;;		// no-op: idle streams are not tracked
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *randomWriteScheduler) CloseStream(streamID uint32) {
0000000000000000000000000000000000000000;;		q, ok := ws.sq[streamID]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(ws.sq, streamID)
0000000000000000000000000000000000000000;;		ws.queuePool.put(q)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *randomWriteScheduler) AdjustStream(streamID uint32, priority PriorityParam) {
0000000000000000000000000000000000000000;;		// no-op: priorities are ignored
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *randomWriteScheduler) Push(wr FrameWriteRequest) {
0000000000000000000000000000000000000000;;		id := wr.StreamID()
0000000000000000000000000000000000000000;;		if id == 0 {
0000000000000000000000000000000000000000;;			ws.zero.push(wr)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q, ok := ws.sq[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			q = ws.queuePool.get()
0000000000000000000000000000000000000000;;			ws.sq[id] = q
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.push(wr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *randomWriteScheduler) Pop() (FrameWriteRequest, bool) {
0000000000000000000000000000000000000000;;		// Control frames first.
0000000000000000000000000000000000000000;;		if !ws.zero.empty() {
0000000000000000000000000000000000000000;;			return ws.zero.shift(), true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Iterate over all non-idle streams until finding one that can be consumed.
0000000000000000000000000000000000000000;;		for _, q := range ws.sq {
0000000000000000000000000000000000000000;;			if wr, ok := q.consume(math.MaxInt32); ok {
0000000000000000000000000000000000000000;;				return wr, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return FrameWriteRequest{}, false
0000000000000000000000000000000000000000;;	}
