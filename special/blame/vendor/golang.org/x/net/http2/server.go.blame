0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/server.go[Godeps/_workspace/src/github.com/bradfitz/http2/server.go][vendor/golang.org/x/net/http2/server.go];	
0000000000000000000000000000000000000000;;	// TODO: turn off the serve goroutine when idle, so
0000000000000000000000000000000000000000;;	// an idle conn only has the readFrames goroutine active. (which could
0000000000000000000000000000000000000000;;	// also be optimized probably to pin less memory in crypto/tls). This
0000000000000000000000000000000000000000;;	// would involve tracking when the serve goroutine is active (atomic
0000000000000000000000000000000000000000;;	// int32 read/CAS probably?) and starting it up when frames arrive,
0000000000000000000000000000000000000000;;	// and shutting it down when all handlers exit. the occasional PING
0000000000000000000000000000000000000000;;	// packets could use time.AfterFunc to call sc.wakeStartServeLoop()
0000000000000000000000000000000000000000;;	// (which is a no-op if already running) and then queue the PING write
0000000000000000000000000000000000000000;;	// as normal. The serve loop would then exit in most cases (if no
0000000000000000000000000000000000000000;;	// Handlers running) and not be woken up again until the PING packet
0000000000000000000000000000000000000000;;	// returns.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO (maybe): add a mechanism for Handlers to going into
0000000000000000000000000000000000000000;;	// half-closed-local mode (rw.(io.Closer) test?) but not exit their
0000000000000000000000000000000000000000;;	// handler, and continue to be able to read from the
0000000000000000000000000000000000000000;;	// Request.Body. This would be a somewhat semantic change from HTTP/1
0000000000000000000000000000000000000000;;	// (or at least what we expose in net/http), so I'd probably want to
0000000000000000000000000000000000000000;;	// add it there too. For now, this package says that returning from
0000000000000000000000000000000000000000;;	// the Handler ServeHTTP function means you're both done reading and
0000000000000000000000000000000000000000;;	// done writing, without a way to stop just one or the other.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/textproto"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2/hpack"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		prefaceTimeout        = 10 * time.Second
0000000000000000000000000000000000000000;;		firstSettingsTimeout  = 2 * time.Second // should be in-flight with preface anyway
0000000000000000000000000000000000000000;;		handlerChunkWriteSize = 4 << 10
0000000000000000000000000000000000000000;;		defaultMaxStreams     = 250 // TODO: make this 100 as the GFE seems to?
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errClientDisconnected = errors.New("client disconnected")
0000000000000000000000000000000000000000;;		errClosedBody         = errors.New("body closed by handler")
0000000000000000000000000000000000000000;;		errHandlerComplete    = errors.New("http2: request body closed due to handler exiting")
0000000000000000000000000000000000000000;;		errStreamClosed       = errors.New("http2: stream closed")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var responseWriterStatePool = sync.Pool{
0000000000000000000000000000000000000000;;		New: func() interface{} {
0000000000000000000000000000000000000000;;			rws := &responseWriterState{}
0000000000000000000000000000000000000000;;			rws.bw = bufio.NewWriterSize(chunkWriter{rws}, handlerChunkWriteSize)
0000000000000000000000000000000000000000;;			return rws
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test hooks.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		testHookOnConn        func()
0000000000000000000000000000000000000000;;		testHookGetServerConn func(*serverConn)
0000000000000000000000000000000000000000;;		testHookOnPanicMu     *sync.Mutex // nil except in tests
0000000000000000000000000000000000000000;;		testHookOnPanic       func(sc *serverConn, panicVal interface{}) (rePanic bool)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Server is an HTTP/2 server.
0000000000000000000000000000000000000000;;	type Server struct {
0000000000000000000000000000000000000000;;		// MaxHandlers limits the number of http.Handler ServeHTTP goroutines
0000000000000000000000000000000000000000;;		// which may run at a time over all connections.
0000000000000000000000000000000000000000;;		// Negative or zero no limit.
0000000000000000000000000000000000000000;;		// TODO: implement
0000000000000000000000000000000000000000;;		MaxHandlers int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxConcurrentStreams optionally specifies the number of
0000000000000000000000000000000000000000;;		// concurrent streams that each client may have open at a
0000000000000000000000000000000000000000;;		// time. This is unrelated to the number of http.Handler goroutines
0000000000000000000000000000000000000000;;		// which may be active globally, which is MaxHandlers.
0000000000000000000000000000000000000000;;		// If zero, MaxConcurrentStreams defaults to at least 100, per
0000000000000000000000000000000000000000;;		// the HTTP/2 spec's recommendations.
0000000000000000000000000000000000000000;;		MaxConcurrentStreams uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxReadFrameSize optionally specifies the largest frame
0000000000000000000000000000000000000000;;		// this server is willing to read. A valid value is between
0000000000000000000000000000000000000000;;		// 16k and 16M, inclusive. If zero or otherwise invalid, a
0000000000000000000000000000000000000000;;		// default value is used.
0000000000000000000000000000000000000000;;		MaxReadFrameSize uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PermitProhibitedCipherSuites, if true, permits the use of
0000000000000000000000000000000000000000;;		// cipher suites prohibited by the HTTP/2 spec.
0000000000000000000000000000000000000000;;		PermitProhibitedCipherSuites bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IdleTimeout specifies how long until idle clients should be
0000000000000000000000000000000000000000;;		// closed with a GOAWAY frame. PING frames are not considered
0000000000000000000000000000000000000000;;		// activity for the purposes of IdleTimeout.
0000000000000000000000000000000000000000;;		IdleTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewWriteScheduler constructs a write scheduler for a connection.
0000000000000000000000000000000000000000;;		// If nil, a default scheduler is chosen.
0000000000000000000000000000000000000000;;		NewWriteScheduler func() WriteScheduler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) maxReadFrameSize() uint32 {
0000000000000000000000000000000000000000;;		if v := s.MaxReadFrameSize; v >= minMaxFrameSize && v <= maxFrameSize {
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultMaxReadFrameSize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Server) maxConcurrentStreams() uint32 {
0000000000000000000000000000000000000000;;		if v := s.MaxConcurrentStreams; v > 0 {
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defaultMaxStreams
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigureServer adds HTTP/2 support to a net/http Server.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The configuration conf may be nil.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ConfigureServer must be called before s begins serving.
0000000000000000000000000000000000000000;;	func ConfigureServer(s *http.Server, conf *Server) error {
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			panic("nil *http.Server")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if conf == nil {
0000000000000000000000000000000000000000;;			conf = new(Server)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := configureServer18(s, conf); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.TLSConfig == nil {
0000000000000000000000000000000000000000;;			s.TLSConfig = new(tls.Config)
0000000000000000000000000000000000000000;;		} else if s.TLSConfig.CipherSuites != nil {
0000000000000000000000000000000000000000;;			// If they already provided a CipherSuite list, return
0000000000000000000000000000000000000000;;			// an error if it has a bad order or is missing
0000000000000000000000000000000000000000;;			// ECDHE_RSA_WITH_AES_128_GCM_SHA256.
0000000000000000000000000000000000000000;;			const requiredCipher = tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
0000000000000000000000000000000000000000;;			haveRequired := false
0000000000000000000000000000000000000000;;			sawBad := false
0000000000000000000000000000000000000000;;			for i, cs := range s.TLSConfig.CipherSuites {
0000000000000000000000000000000000000000;;				if cs == requiredCipher {
0000000000000000000000000000000000000000;;					haveRequired = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isBadCipher(cs) {
0000000000000000000000000000000000000000;;					sawBad = true
0000000000000000000000000000000000000000;;				} else if sawBad {
0000000000000000000000000000000000000000;;					return fmt.Errorf("http2: TLSConfig.CipherSuites index %d contains an HTTP/2-approved cipher suite (%#04x), but it comes after unapproved cipher suites. With this configuration, clients that don't support previous, approved cipher suites may be given an unapproved one and reject the connection.", i, cs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !haveRequired {
0000000000000000000000000000000000000000;;				return fmt.Errorf("http2: TLSConfig.CipherSuites is missing HTTP/2-required TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note: not setting MinVersion to tls.VersionTLS12,
0000000000000000000000000000000000000000;;		// as we don't want to interfere with HTTP/1.1 traffic
0000000000000000000000000000000000000000;;		// on the user's server. We enforce TLS 1.2 later once
0000000000000000000000000000000000000000;;		// we accept a connection. Ideally this should be done
0000000000000000000000000000000000000000;;		// during next-proto selection, but using TLS <1.2 with
0000000000000000000000000000000000000000;;		// HTTP/2 is still the client's bug.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.TLSConfig.PreferServerCipherSuites = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		haveNPN := false
0000000000000000000000000000000000000000;;		for _, p := range s.TLSConfig.NextProtos {
0000000000000000000000000000000000000000;;			if p == NextProtoTLS {
0000000000000000000000000000000000000000;;				haveNPN = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !haveNPN {
0000000000000000000000000000000000000000;;			s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, NextProtoTLS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.TLSNextProto == nil {
0000000000000000000000000000000000000000;;			s.TLSNextProto = map[string]func(*http.Server, *tls.Conn, http.Handler){}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		protoHandler := func(hs *http.Server, c *tls.Conn, h http.Handler) {
0000000000000000000000000000000000000000;;			if testHookOnConn != nil {
0000000000000000000000000000000000000000;;				testHookOnConn()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conf.ServeConn(c, &ServeConnOpts{
0000000000000000000000000000000000000000;;				Handler:    h,
0000000000000000000000000000000000000000;;				BaseConfig: hs,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.TLSNextProto[NextProtoTLS] = protoHandler
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeConnOpts are options for the Server.ServeConn method.
0000000000000000000000000000000000000000;;	type ServeConnOpts struct {
0000000000000000000000000000000000000000;;		// BaseConfig optionally sets the base configuration
0000000000000000000000000000000000000000;;		// for values. If nil, defaults are used.
0000000000000000000000000000000000000000;;		BaseConfig *http.Server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handler specifies which handler to use for processing
0000000000000000000000000000000000000000;;		// requests. If nil, BaseConfig.Handler is used. If BaseConfig
0000000000000000000000000000000000000000;;		// or BaseConfig.Handler is nil, http.DefaultServeMux is used.
0000000000000000000000000000000000000000;;		Handler http.Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ServeConnOpts) baseConfig() *http.Server {
0000000000000000000000000000000000000000;;		if o != nil && o.BaseConfig != nil {
0000000000000000000000000000000000000000;;			return o.BaseConfig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return new(http.Server)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ServeConnOpts) handler() http.Handler {
0000000000000000000000000000000000000000;;		if o != nil {
0000000000000000000000000000000000000000;;			if o.Handler != nil {
0000000000000000000000000000000000000000;;				return o.Handler
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if o.BaseConfig != nil && o.BaseConfig.Handler != nil {
0000000000000000000000000000000000000000;;				return o.BaseConfig.Handler
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return http.DefaultServeMux
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeConn serves HTTP/2 requests on the provided connection and
0000000000000000000000000000000000000000;;	// blocks until the connection is no longer readable.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ServeConn starts speaking HTTP/2 assuming that c has not had any
0000000000000000000000000000000000000000;;	// reads or writes. It writes its initial settings frame and expects
0000000000000000000000000000000000000000;;	// to be able to read the preface and settings frame from the
0000000000000000000000000000000000000000;;	// client. If c has a ConnectionState method like a *tls.Conn, the
0000000000000000000000000000000000000000;;	// ConnectionState is used to verify the TLS ciphersuite and to set
0000000000000000000000000000000000000000;;	// the Request.TLS field in Handlers.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ServeConn does not support h2c by itself. Any h2c support must be
0000000000000000000000000000000000000000;;	// implemented in terms of providing a suitably-behaving net.Conn.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The opts parameter is optional. If nil, default values are used.
0000000000000000000000000000000000000000;;	func (s *Server) ServeConn(c net.Conn, opts *ServeConnOpts) {
0000000000000000000000000000000000000000;;		baseCtx, cancel := serverConnBaseContext(c, opts)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc := &serverConn{
0000000000000000000000000000000000000000;;			srv:               s,
0000000000000000000000000000000000000000;;			hs:                opts.baseConfig(),
0000000000000000000000000000000000000000;;			conn:              c,
0000000000000000000000000000000000000000;;			baseCtx:           baseCtx,
0000000000000000000000000000000000000000;;			remoteAddrStr:     c.RemoteAddr().String(),
0000000000000000000000000000000000000000;;			bw:                newBufferedWriter(c),
0000000000000000000000000000000000000000;;			handler:           opts.handler(),
0000000000000000000000000000000000000000;;			streams:           make(map[uint32]*stream),
0000000000000000000000000000000000000000;;			readFrameCh:       make(chan readFrameResult),
0000000000000000000000000000000000000000;;			wantWriteFrameCh:  make(chan FrameWriteRequest, 8),
0000000000000000000000000000000000000000;;			wantStartPushCh:   make(chan startPushRequest, 8),
0000000000000000000000000000000000000000;;			wroteFrameCh:      make(chan frameWriteResult, 1), // buffered; one send in writeFrameAsync
0000000000000000000000000000000000000000;;			bodyReadCh:        make(chan bodyReadMsg),         // buffering doesn't matter either way
0000000000000000000000000000000000000000;;			doneServing:       make(chan struct{}),
0000000000000000000000000000000000000000;;			clientMaxStreams:  math.MaxUint32, // Section 6.5.2: "Initially, there is no limit to this value"
0000000000000000000000000000000000000000;;			advMaxStreams:     s.maxConcurrentStreams(),
0000000000000000000000000000000000000000;;			initialWindowSize: initialWindowSize,
0000000000000000000000000000000000000000;;			maxFrameSize:      initialMaxFrameSize,
0000000000000000000000000000000000000000;;			headerTableSize:   initialHeaderTableSize,
0000000000000000000000000000000000000000;;			serveG:            newGoroutineLock(),
0000000000000000000000000000000000000000;;			pushEnabled:       true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The net/http package sets the write deadline from the
0000000000000000000000000000000000000000;;		// http.Server.WriteTimeout during the TLS handshake, but then
0000000000000000000000000000000000000000;;		// passes the connection off to us with the deadline already
0000000000000000000000000000000000000000;;		// set. Disarm it here so that it is not applied to additional
0000000000000000000000000000000000000000;;		// streams opened on this connection.
0000000000000000000000000000000000000000;;		// TODO: implement WriteTimeout fully. See Issue 18437.
0000000000000000000000000000000000000000;;		if sc.hs.WriteTimeout != 0 {
0000000000000000000000000000000000000000;;			sc.conn.SetWriteDeadline(time.Time{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.NewWriteScheduler != nil {
0000000000000000000000000000000000000000;;			sc.writeSched = s.NewWriteScheduler()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sc.writeSched = NewRandomWriteScheduler()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc.flow.add(initialWindowSize)
0000000000000000000000000000000000000000;;		sc.inflow.add(initialWindowSize)
0000000000000000000000000000000000000000;;		sc.hpackEncoder = hpack.NewEncoder(&sc.headerWriteBuf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fr := NewFramer(sc.bw, c)
0000000000000000000000000000000000000000;;		fr.ReadMetaHeaders = hpack.NewDecoder(initialHeaderTableSize, nil)
0000000000000000000000000000000000000000;;		fr.MaxHeaderListSize = sc.maxHeaderListSize()
0000000000000000000000000000000000000000;;		fr.SetMaxReadFrameSize(s.maxReadFrameSize())
0000000000000000000000000000000000000000;;		sc.framer = fr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tc, ok := c.(connectionStater); ok {
0000000000000000000000000000000000000000;;			sc.tlsState = new(tls.ConnectionState)
0000000000000000000000000000000000000000;;			*sc.tlsState = tc.ConnectionState()
0000000000000000000000000000000000000000;;			// 9.2 Use of TLS Features
0000000000000000000000000000000000000000;;			// An implementation of HTTP/2 over TLS MUST use TLS
0000000000000000000000000000000000000000;;			// 1.2 or higher with the restrictions on feature set
0000000000000000000000000000000000000000;;			// and cipher suite described in this section. Due to
0000000000000000000000000000000000000000;;			// implementation limitations, it might not be
0000000000000000000000000000000000000000;;			// possible to fail TLS negotiation. An endpoint MUST
0000000000000000000000000000000000000000;;			// immediately terminate an HTTP/2 connection that
0000000000000000000000000000000000000000;;			// does not meet the TLS requirements described in
0000000000000000000000000000000000000000;;			// this section with a connection error (Section
0000000000000000000000000000000000000000;;			// 5.4.1) of type INADEQUATE_SECURITY.
0000000000000000000000000000000000000000;;			if sc.tlsState.Version < tls.VersionTLS12 {
0000000000000000000000000000000000000000;;				sc.rejectConn(ErrCodeInadequateSecurity, "TLS version too low")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if sc.tlsState.ServerName == "" {
0000000000000000000000000000000000000000;;				// Client must use SNI, but we don't enforce that anymore,
0000000000000000000000000000000000000000;;				// since it was causing problems when connecting to bare IP
0000000000000000000000000000000000000000;;				// addresses during development.
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// TODO: optionally enforce? Or enforce at the time we receive
0000000000000000000000000000000000000000;;				// a new request, and verify the the ServerName matches the :authority?
0000000000000000000000000000000000000000;;				// But that precludes proxy situations, perhaps.
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// So for now, do nothing here again.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !s.PermitProhibitedCipherSuites && isBadCipher(sc.tlsState.CipherSuite) {
0000000000000000000000000000000000000000;;				// "Endpoints MAY choose to generate a connection error
0000000000000000000000000000000000000000;;				// (Section 5.4.1) of type INADEQUATE_SECURITY if one of
0000000000000000000000000000000000000000;;				// the prohibited cipher suites are negotiated."
0000000000000000000000000000000000000000;;				//
0000000000000000000000000000000000000000;;				// We choose that. In my opinion, the spec is weak
0000000000000000000000000000000000000000;;				// here. It also says both parties must support at least
0000000000000000000000000000000000000000;;				// TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 so there's no
0000000000000000000000000000000000000000;;				// excuses here. If we really must, we could allow an
0000000000000000000000000000000000000000;;				// "AllowInsecureWeakCiphers" option on the server later.
0000000000000000000000000000000000000000;;				// Let's see how it plays out first.
0000000000000000000000000000000000000000;;				sc.rejectConn(ErrCodeInadequateSecurity, fmt.Sprintf("Prohibited TLS 1.2 Cipher Suite: %x", sc.tlsState.CipherSuite))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hook := testHookGetServerConn; hook != nil {
0000000000000000000000000000000000000000;;			hook(sc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.serve()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) rejectConn(err ErrCode, debug string) {
0000000000000000000000000000000000000000;;		sc.vlogf("http2: server rejecting conn: %v, %s", err, debug)
0000000000000000000000000000000000000000;;		// ignoring errors. hanging up anyway.
0000000000000000000000000000000000000000;;		sc.framer.WriteGoAway(0, err, []byte(debug))
0000000000000000000000000000000000000000;;		sc.bw.Flush()
0000000000000000000000000000000000000000;;		sc.conn.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serverConn struct {
0000000000000000000000000000000000000000;;		// Immutable:
0000000000000000000000000000000000000000;;		srv              *Server
0000000000000000000000000000000000000000;;		hs               *http.Server
0000000000000000000000000000000000000000;;		conn             net.Conn
0000000000000000000000000000000000000000;;		bw               *bufferedWriter // writing to conn
0000000000000000000000000000000000000000;;		handler          http.Handler
0000000000000000000000000000000000000000;;		baseCtx          contextContext
0000000000000000000000000000000000000000;;		framer           *Framer
0000000000000000000000000000000000000000;;		doneServing      chan struct{}          // closed when serverConn.serve ends
0000000000000000000000000000000000000000;;		readFrameCh      chan readFrameResult   // written by serverConn.readFrames
0000000000000000000000000000000000000000;;		wantWriteFrameCh chan FrameWriteRequest // from handlers -> serve
0000000000000000000000000000000000000000;;		wantStartPushCh  chan startPushRequest  // from handlers -> serve
0000000000000000000000000000000000000000;;		wroteFrameCh     chan frameWriteResult  // from writeFrameAsync -> serve, tickles more frame writes
0000000000000000000000000000000000000000;;		bodyReadCh       chan bodyReadMsg       // from handlers -> serve
0000000000000000000000000000000000000000;;		testHookCh       chan func(int)         // code to run on the serve loop
0000000000000000000000000000000000000000;;		flow             flow                   // conn-wide (not stream-specific) outbound flow control
0000000000000000000000000000000000000000;;		inflow           flow                   // conn-wide inbound flow control
0000000000000000000000000000000000000000;;		tlsState         *tls.ConnectionState   // shared by all handlers, like net/http
0000000000000000000000000000000000000000;;		remoteAddrStr    string
0000000000000000000000000000000000000000;;		writeSched       WriteScheduler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Everything following is owned by the serve loop; use serveG.check():
0000000000000000000000000000000000000000;;		serveG                goroutineLock // used to verify funcs are on serve()
0000000000000000000000000000000000000000;;		pushEnabled           bool
0000000000000000000000000000000000000000;;		sawFirstSettings      bool // got the initial SETTINGS frame after the preface
0000000000000000000000000000000000000000;;		needToSendSettingsAck bool
0000000000000000000000000000000000000000;;		unackedSettings       int    // how many SETTINGS have we sent without ACKs?
0000000000000000000000000000000000000000;;		clientMaxStreams      uint32 // SETTINGS_MAX_CONCURRENT_STREAMS from client (our PUSH_PROMISE limit)
0000000000000000000000000000000000000000;;		advMaxStreams         uint32 // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client
0000000000000000000000000000000000000000;;		curClientStreams      uint32 // number of open streams initiated by the client
0000000000000000000000000000000000000000;;		curPushedStreams      uint32 // number of open streams initiated by server push
0000000000000000000000000000000000000000;;		maxClientStreamID     uint32 // max ever seen from client (odd), or 0 if there have been no client requests
0000000000000000000000000000000000000000;;		maxPushPromiseID      uint32 // ID of the last push promise (even), or 0 if there have been no pushes
0000000000000000000000000000000000000000;;		streams               map[uint32]*stream
0000000000000000000000000000000000000000;;		initialWindowSize     int32
0000000000000000000000000000000000000000;;		maxFrameSize          int32
0000000000000000000000000000000000000000;;		headerTableSize       uint32
0000000000000000000000000000000000000000;;		peerMaxHeaderListSize uint32            // zero means unknown (default)
0000000000000000000000000000000000000000;;		canonHeader           map[string]string // http2-lower-case -> Go-Canonical-Case
0000000000000000000000000000000000000000;;		writingFrame          bool              // started writing a frame (on serve goroutine or separate)
0000000000000000000000000000000000000000;;		writingFrameAsync     bool              // started a frame on its own goroutine but haven't heard back on wroteFrameCh
0000000000000000000000000000000000000000;;		needsFrameFlush       bool              // last frame write wasn't a flush
0000000000000000000000000000000000000000;;		inGoAway              bool              // we've started to or sent GOAWAY
0000000000000000000000000000000000000000;;		inFrameScheduleLoop   bool              // whether we're in the scheduleFrameWrite loop
0000000000000000000000000000000000000000;;		needToSendGoAway      bool              // we need to schedule a GOAWAY frame write
0000000000000000000000000000000000000000;;		goAwayCode            ErrCode
0000000000000000000000000000000000000000;;		shutdownTimerCh       <-chan time.Time // nil until used
0000000000000000000000000000000000000000;;		shutdownTimer         *time.Timer      // nil until used
0000000000000000000000000000000000000000;;		idleTimer             *time.Timer      // nil if unused
0000000000000000000000000000000000000000;;		idleTimerCh           <-chan time.Time // nil if unused
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Owned by the writeFrameAsync goroutine:
0000000000000000000000000000000000000000;;		headerWriteBuf bytes.Buffer
0000000000000000000000000000000000000000;;		hpackEncoder   *hpack.Encoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) maxHeaderListSize() uint32 {
0000000000000000000000000000000000000000;;		n := sc.hs.MaxHeaderBytes
0000000000000000000000000000000000000000;;		if n <= 0 {
0000000000000000000000000000000000000000;;			n = http.DefaultMaxHeaderBytes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// http2's count is in a slightly different unit and includes 32 bytes per pair.
0000000000000000000000000000000000000000;;		// So, take the net/http.Server value and pad it up a bit, assuming 10 headers.
0000000000000000000000000000000000000000;;		const perFieldOverhead = 32 // per http2 spec
0000000000000000000000000000000000000000;;		const typicalHeaders = 10   // conservative
0000000000000000000000000000000000000000;;		return uint32(n + typicalHeaders*perFieldOverhead)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) curOpenStreams() uint32 {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		return sc.curClientStreams + sc.curPushedStreams
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stream represents a stream. This is the minimal metadata needed by
0000000000000000000000000000000000000000;;	// the serve goroutine. Most of the actual stream state is owned by
0000000000000000000000000000000000000000;;	// the http.Handler's goroutine in the responseWriter. Because the
0000000000000000000000000000000000000000;;	// responseWriter's responseWriterState is recycled at the end of a
0000000000000000000000000000000000000000;;	// handler, this struct intentionally has no pointer to the
0000000000000000000000000000000000000000;;	// *responseWriter{,State} itself, as the Handler ending nils out the
0000000000000000000000000000000000000000;;	// responseWriter's state field.
0000000000000000000000000000000000000000;;	type stream struct {
0000000000000000000000000000000000000000;;		// immutable:
0000000000000000000000000000000000000000;;		sc        *serverConn
0000000000000000000000000000000000000000;;		id        uint32
0000000000000000000000000000000000000000;;		body      *pipe       // non-nil if expecting DATA frames
0000000000000000000000000000000000000000;;		cw        closeWaiter // closed wait stream transitions to closed state
0000000000000000000000000000000000000000;;		ctx       contextContext
0000000000000000000000000000000000000000;;		cancelCtx func()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// owned by serverConn's serve loop:
0000000000000000000000000000000000000000;;		bodyBytes        int64   // body bytes seen so far
0000000000000000000000000000000000000000;;		declBodyBytes    int64   // or -1 if undeclared
0000000000000000000000000000000000000000;;		flow             flow    // limits writing from Handler to client
0000000000000000000000000000000000000000;;		inflow           flow    // what the client is allowed to POST/etc to us
0000000000000000000000000000000000000000;;		parent           *stream // or nil
0000000000000000000000000000000000000000;;		numTrailerValues int64
0000000000000000000000000000000000000000;;		weight           uint8
0000000000000000000000000000000000000000;;		state            streamState
0000000000000000000000000000000000000000;;		resetQueued      bool   // RST_STREAM queued for write; set by sc.resetStream
0000000000000000000000000000000000000000;;		gotTrailerHeader bool   // HEADER frame for trailers was seen
0000000000000000000000000000000000000000;;		wroteHeaders     bool   // whether we wrote headers (not status 100)
0000000000000000000000000000000000000000;;		reqBuf           []byte // if non-nil, body pipe buffer to return later at EOF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trailer    http.Header // accumulated trailers
0000000000000000000000000000000000000000;;		reqTrailer http.Header // handler's Request.Trailer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) Framer() *Framer  { return sc.framer }
0000000000000000000000000000000000000000;;	func (sc *serverConn) CloseConn() error { return sc.conn.Close() }
0000000000000000000000000000000000000000;;	func (sc *serverConn) Flush() error     { return sc.bw.Flush() }
0000000000000000000000000000000000000000;;	func (sc *serverConn) HeaderEncoder() (*hpack.Encoder, *bytes.Buffer) {
0000000000000000000000000000000000000000;;		return sc.hpackEncoder, &sc.headerWriteBuf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) state(streamID uint32) (streamState, *stream) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		// http://tools.ietf.org/html/rfc7540#section-5.1
0000000000000000000000000000000000000000;;		if st, ok := sc.streams[streamID]; ok {
0000000000000000000000000000000000000000;;			return st.state, st
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// "The first use of a new stream identifier implicitly closes all
0000000000000000000000000000000000000000;;		// streams in the "idle" state that might have been initiated by
0000000000000000000000000000000000000000;;		// that peer with a lower-valued stream identifier. For example, if
0000000000000000000000000000000000000000;;		// a client sends a HEADERS frame on stream 7 without ever sending a
0000000000000000000000000000000000000000;;		// frame on stream 5, then stream 5 transitions to the "closed"
0000000000000000000000000000000000000000;;		// state when the first frame for stream 7 is sent or received."
0000000000000000000000000000000000000000;;		if streamID%2 == 1 {
0000000000000000000000000000000000000000;;			if streamID <= sc.maxClientStreamID {
0000000000000000000000000000000000000000;;				return stateClosed, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if streamID <= sc.maxPushPromiseID {
0000000000000000000000000000000000000000;;				return stateClosed, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stateIdle, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setConnState calls the net/http ConnState hook for this connection, if configured.
0000000000000000000000000000000000000000;;	// Note that the net/http package does StateNew and StateClosed for us.
0000000000000000000000000000000000000000;;	// There is currently no plan for StateHijacked or hijacking HTTP/2 connections.
0000000000000000000000000000000000000000;;	func (sc *serverConn) setConnState(state http.ConnState) {
0000000000000000000000000000000000000000;;		if sc.hs.ConnState != nil {
0000000000000000000000000000000000000000;;			sc.hs.ConnState(sc.conn, state)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) vlogf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if VerboseLogs {
0000000000000000000000000000000000000000;;			sc.logf(format, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) logf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if lg := sc.hs.ErrorLog; lg != nil {
0000000000000000000000000000000000000000;;			lg.Printf(format, args...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			log.Printf(format, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errno returns v's underlying uintptr, else 0.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: remove this helper function once http2 can use build
0000000000000000000000000000000000000000;;	// tags. See comment in isClosedConnError.
0000000000000000000000000000000000000000;;	func errno(v error) uintptr {
0000000000000000000000000000000000000000;;		if rv := reflect.ValueOf(v); rv.Kind() == reflect.Uintptr {
0000000000000000000000000000000000000000;;			return uintptr(rv.Uint())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isClosedConnError reports whether err is an error from use of a closed
0000000000000000000000000000000000000000;;	// network connection.
0000000000000000000000000000000000000000;;	func isClosedConnError(err error) bool {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: remove this string search and be more like the Windows
0000000000000000000000000000000000000000;;		// case below. That might involve modifying the standard library
0000000000000000000000000000000000000000;;		// to return better error types.
0000000000000000000000000000000000000000;;		str := err.Error()
0000000000000000000000000000000000000000;;		if strings.Contains(str, "use of closed network connection") {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(bradfitz): x/tools/cmd/bundle doesn't really support
0000000000000000000000000000000000000000;;		// build tags, so I can't make an http2_windows.go file with
0000000000000000000000000000000000000000;;		// Windows-specific stuff. Fix that and move this, once we
0000000000000000000000000000000000000000;;		// have a way to bundle this into std's net/http somehow.
0000000000000000000000000000000000000000;;		if runtime.GOOS == "windows" {
0000000000000000000000000000000000000000;;			if oe, ok := err.(*net.OpError); ok && oe.Op == "read" {
0000000000000000000000000000000000000000;;				if se, ok := oe.Err.(*os.SyscallError); ok && se.Syscall == "wsarecv" {
0000000000000000000000000000000000000000;;					const WSAECONNABORTED = 10053
0000000000000000000000000000000000000000;;					const WSAECONNRESET = 10054
0000000000000000000000000000000000000000;;					if n := errno(se.Err); n == WSAECONNRESET || n == WSAECONNABORTED {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) condlogf(err error, format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == io.EOF || err == io.ErrUnexpectedEOF || isClosedConnError(err) {
0000000000000000000000000000000000000000;;			// Boring, expected errors.
0000000000000000000000000000000000000000;;			sc.vlogf(format, args...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sc.logf(format, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) canonicalHeader(v string) string {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		cv, ok := commonCanonHeader[v]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return cv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cv, ok = sc.canonHeader[v]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return cv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sc.canonHeader == nil {
0000000000000000000000000000000000000000;;			sc.canonHeader = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cv = http.CanonicalHeaderKey(v)
0000000000000000000000000000000000000000;;		sc.canonHeader[v] = cv
0000000000000000000000000000000000000000;;		return cv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type readFrameResult struct {
0000000000000000000000000000000000000000;;		f   Frame // valid until readMore is called
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readMore should be called once the consumer no longer needs or
0000000000000000000000000000000000000000;;		// retains f. After readMore, f is invalid and more frames can be
0000000000000000000000000000000000000000;;		// read.
0000000000000000000000000000000000000000;;		readMore func()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readFrames is the loop that reads incoming frames.
0000000000000000000000000000000000000000;;	// It takes care to only read one frame at a time, blocking until the
0000000000000000000000000000000000000000;;	// consumer is done with the frame.
0000000000000000000000000000000000000000;;	// It's run on its own goroutine.
0000000000000000000000000000000000000000;;	func (sc *serverConn) readFrames() {
0000000000000000000000000000000000000000;;		gate := make(gate)
0000000000000000000000000000000000000000;;		gateDone := gate.Done
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			f, err := sc.framer.ReadFrame()
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case sc.readFrameCh <- readFrameResult{f, err, gateDone}:
0000000000000000000000000000000000000000;;			case <-sc.doneServing:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-gate:
0000000000000000000000000000000000000000;;			case <-sc.doneServing:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if terminalReadFrameError(err) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// frameWriteResult is the message passed from writeFrameAsync to the serve goroutine.
0000000000000000000000000000000000000000;;	type frameWriteResult struct {
0000000000000000000000000000000000000000;;		wr  FrameWriteRequest // what was written (or attempted)
0000000000000000000000000000000000000000;;		err error             // result of the writeFrame call
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeFrameAsync runs in its own goroutine and writes a single frame
0000000000000000000000000000000000000000;;	// and then reports when it's done.
0000000000000000000000000000000000000000;;	// At most one goroutine can be running writeFrameAsync at a time per
0000000000000000000000000000000000000000;;	// serverConn.
0000000000000000000000000000000000000000;;	func (sc *serverConn) writeFrameAsync(wr FrameWriteRequest) {
0000000000000000000000000000000000000000;;		err := wr.write.writeFrame(sc)
0000000000000000000000000000000000000000;;		sc.wroteFrameCh <- frameWriteResult{wr, err}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) closeAllStreamsOnConnClose() {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		for _, st := range sc.streams {
0000000000000000000000000000000000000000;;			sc.closeStream(st, errClientDisconnected)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) stopShutdownTimer() {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if t := sc.shutdownTimer; t != nil {
0000000000000000000000000000000000000000;;			t.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) notePanic() {
0000000000000000000000000000000000000000;;		// Note: this is for serverConn.serve panicking, not http.Handler code.
0000000000000000000000000000000000000000;;		if testHookOnPanicMu != nil {
0000000000000000000000000000000000000000;;			testHookOnPanicMu.Lock()
0000000000000000000000000000000000000000;;			defer testHookOnPanicMu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if testHookOnPanic != nil {
0000000000000000000000000000000000000000;;			if e := recover(); e != nil {
0000000000000000000000000000000000000000;;				if testHookOnPanic(sc, e) {
0000000000000000000000000000000000000000;;					panic(e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) serve() {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		defer sc.notePanic()
0000000000000000000000000000000000000000;;		defer sc.conn.Close()
0000000000000000000000000000000000000000;;		defer sc.closeAllStreamsOnConnClose()
0000000000000000000000000000000000000000;;		defer sc.stopShutdownTimer()
0000000000000000000000000000000000000000;;		defer close(sc.doneServing) // unblocks handlers trying to send
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if VerboseLogs {
0000000000000000000000000000000000000000;;			sc.vlogf("http2: server connection from %v on %p", sc.conn.RemoteAddr(), sc.hs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc.writeFrame(FrameWriteRequest{
0000000000000000000000000000000000000000;;			write: writeSettings{
0000000000000000000000000000000000000000;;				{SettingMaxFrameSize, sc.srv.maxReadFrameSize()},
0000000000000000000000000000000000000000;;				{SettingMaxConcurrentStreams, sc.advMaxStreams},
0000000000000000000000000000000000000000;;				{SettingMaxHeaderListSize, sc.maxHeaderListSize()},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: more actual settings, notably
0000000000000000000000000000000000000000;;				// SettingInitialWindowSize, but then we also
0000000000000000000000000000000000000000;;				// want to bump up the conn window size the
0000000000000000000000000000000000000000;;				// same amount here right after the settings
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		sc.unackedSettings++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := sc.readPreface(); err != nil {
0000000000000000000000000000000000000000;;			sc.condlogf(err, "http2: server: error reading preface from client %v: %v", sc.conn.RemoteAddr(), err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Now that we've got the preface, get us out of the
0000000000000000000000000000000000000000;;		// "StateNew" state.  We can't go directly to idle, though.
0000000000000000000000000000000000000000;;		// Active means we read some data and anticipate a request. We'll
0000000000000000000000000000000000000000;;		// do another Active when we get a HEADERS frame.
0000000000000000000000000000000000000000;;		sc.setConnState(http.StateActive)
0000000000000000000000000000000000000000;;		sc.setConnState(http.StateIdle)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sc.srv.IdleTimeout != 0 {
0000000000000000000000000000000000000000;;			sc.idleTimer = time.NewTimer(sc.srv.IdleTimeout)
0000000000000000000000000000000000000000;;			defer sc.idleTimer.Stop()
0000000000000000000000000000000000000000;;			sc.idleTimerCh = sc.idleTimer.C
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var gracefulShutdownCh <-chan struct{}
0000000000000000000000000000000000000000;;		if sc.hs != nil {
0000000000000000000000000000000000000000;;			gracefulShutdownCh = h1ServerShutdownChan(sc.hs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go sc.readFrames() // closed by defer sc.conn.Close above
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		settingsTimer := time.NewTimer(firstSettingsTimeout)
0000000000000000000000000000000000000000;;		loopNum := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			loopNum++
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case wr := <-sc.wantWriteFrameCh:
0000000000000000000000000000000000000000;;				sc.writeFrame(wr)
0000000000000000000000000000000000000000;;			case spr := <-sc.wantStartPushCh:
0000000000000000000000000000000000000000;;				sc.startPush(spr)
0000000000000000000000000000000000000000;;			case res := <-sc.wroteFrameCh:
0000000000000000000000000000000000000000;;				sc.wroteFrame(res)
0000000000000000000000000000000000000000;;			case res := <-sc.readFrameCh:
0000000000000000000000000000000000000000;;				if !sc.processFrameFromReader(res) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				res.readMore()
0000000000000000000000000000000000000000;;				if settingsTimer.C != nil {
0000000000000000000000000000000000000000;;					settingsTimer.Stop()
0000000000000000000000000000000000000000;;					settingsTimer.C = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case m := <-sc.bodyReadCh:
0000000000000000000000000000000000000000;;				sc.noteBodyRead(m.st, m.n)
0000000000000000000000000000000000000000;;			case <-settingsTimer.C:
0000000000000000000000000000000000000000;;				sc.logf("timeout waiting for SETTINGS frames from %v", sc.conn.RemoteAddr())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-gracefulShutdownCh:
0000000000000000000000000000000000000000;;				gracefulShutdownCh = nil
0000000000000000000000000000000000000000;;				sc.startGracefulShutdown()
0000000000000000000000000000000000000000;;			case <-sc.shutdownTimerCh:
0000000000000000000000000000000000000000;;				sc.vlogf("GOAWAY close timer fired; closing conn from %v", sc.conn.RemoteAddr())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-sc.idleTimerCh:
0000000000000000000000000000000000000000;;				sc.vlogf("connection is idle")
0000000000000000000000000000000000000000;;				sc.goAway(ErrCodeNo)
0000000000000000000000000000000000000000;;			case fn := <-sc.testHookCh:
0000000000000000000000000000000000000000;;				fn(loopNum)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if sc.inGoAway && sc.curOpenStreams() == 0 && !sc.needToSendGoAway && !sc.writingFrame {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readPreface reads the ClientPreface greeting from the peer
0000000000000000000000000000000000000000;;	// or returns an error on timeout or an invalid greeting.
0000000000000000000000000000000000000000;;	func (sc *serverConn) readPreface() error {
0000000000000000000000000000000000000000;;		errc := make(chan error, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// Read the client preface
0000000000000000000000000000000000000000;;			buf := make([]byte, len(ClientPreface))
0000000000000000000000000000000000000000;;			if _, err := io.ReadFull(sc.conn, buf); err != nil {
0000000000000000000000000000000000000000;;				errc <- err
0000000000000000000000000000000000000000;;			} else if !bytes.Equal(buf, clientPreface) {
0000000000000000000000000000000000000000;;				errc <- fmt.Errorf("bogus greeting %q", buf)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				errc <- nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		timer := time.NewTimer(prefaceTimeout) // TODO: configurable on *Server?
0000000000000000000000000000000000000000;;		defer timer.Stop()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-timer.C:
0000000000000000000000000000000000000000;;			return errors.New("timeout waiting for client preface")
0000000000000000000000000000000000000000;;		case err := <-errc:
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				if VerboseLogs {
0000000000000000000000000000000000000000;;					sc.vlogf("http2: server: client %v said hello", sc.conn.RemoteAddr())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errChanPool = sync.Pool{
0000000000000000000000000000000000000000;;		New: func() interface{} { return make(chan error, 1) },
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var writeDataPool = sync.Pool{
0000000000000000000000000000000000000000;;		New: func() interface{} { return new(writeData) },
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeDataFromHandler writes DATA response frames from a handler on
0000000000000000000000000000000000000000;;	// the given stream.
0000000000000000000000000000000000000000;;	func (sc *serverConn) writeDataFromHandler(stream *stream, data []byte, endStream bool) error {
0000000000000000000000000000000000000000;;		ch := errChanPool.Get().(chan error)
0000000000000000000000000000000000000000;;		writeArg := writeDataPool.Get().(*writeData)
0000000000000000000000000000000000000000;;		*writeArg = writeData{stream.id, data, endStream}
0000000000000000000000000000000000000000;;		err := sc.writeFrameFromHandler(FrameWriteRequest{
0000000000000000000000000000000000000000;;			write:  writeArg,
0000000000000000000000000000000000000000;;			stream: stream,
0000000000000000000000000000000000000000;;			done:   ch,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var frameWriteDone bool // the frame write is done (successfully or not)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err = <-ch:
0000000000000000000000000000000000000000;;			frameWriteDone = true
0000000000000000000000000000000000000000;;		case <-sc.doneServing:
0000000000000000000000000000000000000000;;			return errClientDisconnected
0000000000000000000000000000000000000000;;		case <-stream.cw:
0000000000000000000000000000000000000000;;			// If both ch and stream.cw were ready (as might
0000000000000000000000000000000000000000;;			// happen on the final Write after an http.Handler
0000000000000000000000000000000000000000;;			// ends), prefer the write result. Otherwise this
0000000000000000000000000000000000000000;;			// might just be us successfully closing the stream.
0000000000000000000000000000000000000000;;			// The writeFrameAsync and serve goroutines guarantee
0000000000000000000000000000000000000000;;			// that the ch send will happen before the stream.cw
0000000000000000000000000000000000000000;;			// close.
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case err = <-ch:
0000000000000000000000000000000000000000;;				frameWriteDone = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return errStreamClosed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errChanPool.Put(ch)
0000000000000000000000000000000000000000;;		if frameWriteDone {
0000000000000000000000000000000000000000;;			writeDataPool.Put(writeArg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeFrameFromHandler sends wr to sc.wantWriteFrameCh, but aborts
0000000000000000000000000000000000000000;;	// if the connection has gone away.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This must not be run from the serve goroutine itself, else it might
0000000000000000000000000000000000000000;;	// deadlock writing to sc.wantWriteFrameCh (which is only mildly
0000000000000000000000000000000000000000;;	// buffered and is read by serve itself). If you're on the serve
0000000000000000000000000000000000000000;;	// goroutine, call writeFrame instead.
0000000000000000000000000000000000000000;;	func (sc *serverConn) writeFrameFromHandler(wr FrameWriteRequest) error {
0000000000000000000000000000000000000000;;		sc.serveG.checkNotOn() // NOT
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case sc.wantWriteFrameCh <- wr:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case <-sc.doneServing:
0000000000000000000000000000000000000000;;			// Serve loop is gone.
0000000000000000000000000000000000000000;;			// Client has closed their connection to the server.
0000000000000000000000000000000000000000;;			return errClientDisconnected
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeFrame schedules a frame to write and sends it if there's nothing
0000000000000000000000000000000000000000;;	// already being written.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There is no pushback here (the serve goroutine never blocks). It's
0000000000000000000000000000000000000000;;	// the http.Handlers that block, waiting for their previous frames to
0000000000000000000000000000000000000000;;	// make it onto the wire
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If you're not on the serve goroutine, use writeFrameFromHandler instead.
0000000000000000000000000000000000000000;;	func (sc *serverConn) writeFrame(wr FrameWriteRequest) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If true, wr will not be written and wr.done will not be signaled.
0000000000000000000000000000000000000000;;		var ignoreWrite bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We are not allowed to write frames on closed streams. RFC 7540 Section
0000000000000000000000000000000000000000;;		// 5.1.1 says: "An endpoint MUST NOT send frames other than PRIORITY on
0000000000000000000000000000000000000000;;		// a closed stream." Our server never sends PRIORITY, so that exception
0000000000000000000000000000000000000000;;		// does not apply.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The serverConn might close an open stream while the stream's handler
0000000000000000000000000000000000000000;;		// is still running. For example, the server might close a stream when it
0000000000000000000000000000000000000000;;		// receives bad data from the client. If this happens, the handler might
0000000000000000000000000000000000000000;;		// attempt to write a frame after the stream has been closed (since the
0000000000000000000000000000000000000000;;		// handler hasn't yet been notified of the close). In this case, we simply
0000000000000000000000000000000000000000;;		// ignore the frame. The handler will notice that the stream is closed when
0000000000000000000000000000000000000000;;		// it waits for the frame to be written.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// As an exception to this rule, we allow sending RST_STREAM after close.
0000000000000000000000000000000000000000;;		// This allows us to immediately reject new streams without tracking any
0000000000000000000000000000000000000000;;		// state for those streams (except for the queued RST_STREAM frame). This
0000000000000000000000000000000000000000;;		// may result in duplicate RST_STREAMs in some cases, but the client should
0000000000000000000000000000000000000000;;		// ignore those.
0000000000000000000000000000000000000000;;		if wr.StreamID() != 0 {
0000000000000000000000000000000000000000;;			_, isReset := wr.write.(StreamError)
0000000000000000000000000000000000000000;;			if state, _ := sc.state(wr.StreamID()); state == stateClosed && !isReset {
0000000000000000000000000000000000000000;;				ignoreWrite = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't send a 100-continue response if we've already sent headers.
0000000000000000000000000000000000000000;;		// See golang.org/issue/14030.
0000000000000000000000000000000000000000;;		switch wr.write.(type) {
0000000000000000000000000000000000000000;;		case *writeResHeaders:
0000000000000000000000000000000000000000;;			wr.stream.wroteHeaders = true
0000000000000000000000000000000000000000;;		case write100ContinueHeadersFrame:
0000000000000000000000000000000000000000;;			if wr.stream.wroteHeaders {
0000000000000000000000000000000000000000;;				// We do not need to notify wr.done because this frame is
0000000000000000000000000000000000000000;;				// never written with wr.done != nil.
0000000000000000000000000000000000000000;;				if wr.done != nil {
0000000000000000000000000000000000000000;;					panic("wr.done != nil for write100ContinueHeadersFrame")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ignoreWrite = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ignoreWrite {
0000000000000000000000000000000000000000;;			sc.writeSched.Push(wr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.scheduleFrameWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startFrameWrite starts a goroutine to write wr (in a separate
0000000000000000000000000000000000000000;;	// goroutine since that might block on the network), and updates the
0000000000000000000000000000000000000000;;	// serve goroutine's state about the world, updated from info in wr.
0000000000000000000000000000000000000000;;	func (sc *serverConn) startFrameWrite(wr FrameWriteRequest) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if sc.writingFrame {
0000000000000000000000000000000000000000;;			panic("internal error: can only be writing one frame at a time")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		st := wr.stream
0000000000000000000000000000000000000000;;		if st != nil {
0000000000000000000000000000000000000000;;			switch st.state {
0000000000000000000000000000000000000000;;			case stateHalfClosedLocal:
0000000000000000000000000000000000000000;;				switch wr.write.(type) {
0000000000000000000000000000000000000000;;				case StreamError, handlerPanicRST, writeWindowUpdate:
0000000000000000000000000000000000000000;;					// RFC 7540 Section 5.1 allows sending RST_STREAM, PRIORITY, and WINDOW_UPDATE
0000000000000000000000000000000000000000;;					// in this state. (We never send PRIORITY from the server, so that is not checked.)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("internal error: attempt to send frame on a half-closed-local stream: %v", wr))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case stateClosed:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("internal error: attempt to send frame on a closed stream: %v", wr))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wpp, ok := wr.write.(*writePushPromise); ok {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			wpp.promisedID, err = wpp.allocatePromisedID()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				sc.writingFrameAsync = false
0000000000000000000000000000000000000000;;				wr.replyToWriter(err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc.writingFrame = true
0000000000000000000000000000000000000000;;		sc.needsFrameFlush = true
0000000000000000000000000000000000000000;;		if wr.write.staysWithinBuffer(sc.bw.Available()) {
0000000000000000000000000000000000000000;;			sc.writingFrameAsync = false
0000000000000000000000000000000000000000;;			err := wr.write.writeFrame(sc)
0000000000000000000000000000000000000000;;			sc.wroteFrame(frameWriteResult{wr, err})
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sc.writingFrameAsync = true
0000000000000000000000000000000000000000;;			go sc.writeFrameAsync(wr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errHandlerPanicked is the error given to any callers blocked in a read from
0000000000000000000000000000000000000000;;	// Request.Body when the main goroutine panics. Since most handlers read in the
0000000000000000000000000000000000000000;;	// the main ServeHTTP goroutine, this will show up rarely.
0000000000000000000000000000000000000000;;	var errHandlerPanicked = errors.New("http2: handler panicked")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wroteFrame is called on the serve goroutine with the result of
0000000000000000000000000000000000000000;;	// whatever happened on writeFrameAsync.
0000000000000000000000000000000000000000;;	func (sc *serverConn) wroteFrame(res frameWriteResult) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if !sc.writingFrame {
0000000000000000000000000000000000000000;;			panic("internal error: expected to be already writing a frame")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.writingFrame = false
0000000000000000000000000000000000000000;;		sc.writingFrameAsync = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wr := res.wr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if writeEndsStream(wr.write) {
0000000000000000000000000000000000000000;;			st := wr.stream
0000000000000000000000000000000000000000;;			if st == nil {
0000000000000000000000000000000000000000;;				panic("internal error: expecting non-nil stream")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch st.state {
0000000000000000000000000000000000000000;;			case stateOpen:
0000000000000000000000000000000000000000;;				// Here we would go to stateHalfClosedLocal in
0000000000000000000000000000000000000000;;				// theory, but since our handler is done and
0000000000000000000000000000000000000000;;				// the net/http package provides no mechanism
0000000000000000000000000000000000000000;;				// for closing a ResponseWriter while still
0000000000000000000000000000000000000000;;				// reading data (see possible TODO at top of
0000000000000000000000000000000000000000;;				// this file), we go into closed state here
0000000000000000000000000000000000000000;;				// anyway, after telling the peer we're
0000000000000000000000000000000000000000;;				// hanging up on them. We'll transition to
0000000000000000000000000000000000000000;;				// stateClosed after the RST_STREAM frame is
0000000000000000000000000000000000000000;;				// written.
0000000000000000000000000000000000000000;;				st.state = stateHalfClosedLocal
0000000000000000000000000000000000000000;;				sc.resetStream(streamError(st.id, ErrCodeCancel))
0000000000000000000000000000000000000000;;			case stateHalfClosedRemote:
0000000000000000000000000000000000000000;;				sc.closeStream(st, errHandlerComplete)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			switch v := wr.write.(type) {
0000000000000000000000000000000000000000;;			case StreamError:
0000000000000000000000000000000000000000;;				// st may be unknown if the RST_STREAM was generated to reject bad input.
0000000000000000000000000000000000000000;;				if st, ok := sc.streams[v.StreamID]; ok {
0000000000000000000000000000000000000000;;					sc.closeStream(st, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case handlerPanicRST:
0000000000000000000000000000000000000000;;				sc.closeStream(wr.stream, errHandlerPanicked)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reply (if requested) to unblock the ServeHTTP goroutine.
0000000000000000000000000000000000000000;;		wr.replyToWriter(res.err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc.scheduleFrameWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scheduleFrameWrite tickles the frame writing scheduler.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a frame is already being written, nothing happens. This will be called again
0000000000000000000000000000000000000000;;	// when the frame is done being written.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a frame isn't being written we need to send one, the best frame
0000000000000000000000000000000000000000;;	// to send is selected, preferring first things that aren't
0000000000000000000000000000000000000000;;	// stream-specific (e.g. ACKing settings), and then finding the
0000000000000000000000000000000000000000;;	// highest priority stream.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a frame isn't being written and there's nothing else to send, we
0000000000000000000000000000000000000000;;	// flush the write buffer.
0000000000000000000000000000000000000000;;	func (sc *serverConn) scheduleFrameWrite() {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if sc.writingFrame || sc.inFrameScheduleLoop {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.inFrameScheduleLoop = true
0000000000000000000000000000000000000000;;		for !sc.writingFrameAsync {
0000000000000000000000000000000000000000;;			if sc.needToSendGoAway {
0000000000000000000000000000000000000000;;				sc.needToSendGoAway = false
0000000000000000000000000000000000000000;;				sc.startFrameWrite(FrameWriteRequest{
0000000000000000000000000000000000000000;;					write: &writeGoAway{
0000000000000000000000000000000000000000;;						maxStreamID: sc.maxClientStreamID,
0000000000000000000000000000000000000000;;						code:        sc.goAwayCode,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sc.needToSendSettingsAck {
0000000000000000000000000000000000000000;;				sc.needToSendSettingsAck = false
0000000000000000000000000000000000000000;;				sc.startFrameWrite(FrameWriteRequest{write: writeSettingsAck{}})
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !sc.inGoAway || sc.goAwayCode == ErrCodeNo {
0000000000000000000000000000000000000000;;				if wr, ok := sc.writeSched.Pop(); ok {
0000000000000000000000000000000000000000;;					sc.startFrameWrite(wr)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sc.needsFrameFlush {
0000000000000000000000000000000000000000;;				sc.startFrameWrite(FrameWriteRequest{write: flushFrameWriter{}})
0000000000000000000000000000000000000000;;				sc.needsFrameFlush = false // after startFrameWrite, since it sets this true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.inFrameScheduleLoop = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startGracefulShutdown sends a GOAWAY with ErrCodeNo to tell the
0000000000000000000000000000000000000000;;	// client we're gracefully shutting down. The connection isn't closed
0000000000000000000000000000000000000000;;	// until all current streams are done.
0000000000000000000000000000000000000000;;	func (sc *serverConn) startGracefulShutdown() {
0000000000000000000000000000000000000000;;		sc.goAwayIn(ErrCodeNo, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) goAway(code ErrCode) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		var forceCloseIn time.Duration
0000000000000000000000000000000000000000;;		if code != ErrCodeNo {
0000000000000000000000000000000000000000;;			forceCloseIn = 250 * time.Millisecond
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// TODO: configurable
0000000000000000000000000000000000000000;;			forceCloseIn = 1 * time.Second
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.goAwayIn(code, forceCloseIn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) goAwayIn(code ErrCode, forceCloseIn time.Duration) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if sc.inGoAway {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if forceCloseIn != 0 {
0000000000000000000000000000000000000000;;			sc.shutDownIn(forceCloseIn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.inGoAway = true
0000000000000000000000000000000000000000;;		sc.needToSendGoAway = true
0000000000000000000000000000000000000000;;		sc.goAwayCode = code
0000000000000000000000000000000000000000;;		sc.scheduleFrameWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) shutDownIn(d time.Duration) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		sc.shutdownTimer = time.NewTimer(d)
0000000000000000000000000000000000000000;;		sc.shutdownTimerCh = sc.shutdownTimer.C
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) resetStream(se StreamError) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		sc.writeFrame(FrameWriteRequest{write: se})
0000000000000000000000000000000000000000;;		if st, ok := sc.streams[se.StreamID]; ok {
0000000000000000000000000000000000000000;;			st.resetQueued = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processFrameFromReader processes the serve loop's read from readFrameCh from the
0000000000000000000000000000000000000000;;	// frame-reading goroutine.
0000000000000000000000000000000000000000;;	// processFrameFromReader returns whether the connection should be kept open.
0000000000000000000000000000000000000000;;	func (sc *serverConn) processFrameFromReader(res readFrameResult) bool {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		err := res.err
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == ErrFrameTooLarge {
0000000000000000000000000000000000000000;;				sc.goAway(ErrCodeFrameSize)
0000000000000000000000000000000000000000;;				return true // goAway will close the loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			clientGone := err == io.EOF || err == io.ErrUnexpectedEOF || isClosedConnError(err)
0000000000000000000000000000000000000000;;			if clientGone {
0000000000000000000000000000000000000000;;				// TODO: could we also get into this state if
0000000000000000000000000000000000000000;;				// the peer does a half close
0000000000000000000000000000000000000000;;				// (e.g. CloseWrite) because they're done
0000000000000000000000000000000000000000;;				// sending frames but they're still wanting
0000000000000000000000000000000000000000;;				// our open replies?  Investigate.
0000000000000000000000000000000000000000;;				// TODO: add CloseWrite to crypto/tls.Conn first
0000000000000000000000000000000000000000;;				// so we have a way to test this? I suppose
0000000000000000000000000000000000000000;;				// just for testing we could have a non-TLS mode.
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f := res.f
0000000000000000000000000000000000000000;;			if VerboseLogs {
0000000000000000000000000000000000000000;;				sc.vlogf("http2: server read frame %v", summarizeFrame(f))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = sc.processFrame(f)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch ev := err.(type) {
0000000000000000000000000000000000000000;;		case StreamError:
0000000000000000000000000000000000000000;;			sc.resetStream(ev)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case goAwayFlowError:
0000000000000000000000000000000000000000;;			sc.goAway(ErrCodeFlowControl)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case ConnectionError:
0000000000000000000000000000000000000000;;			sc.logf("http2: server connection error from %v: %v", sc.conn.RemoteAddr(), ev)
0000000000000000000000000000000000000000;;			sc.goAway(ErrCode(ev))
0000000000000000000000000000000000000000;;			return true // goAway will handle shutdown
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if res.err != nil {
0000000000000000000000000000000000000000;;				sc.vlogf("http2: server closing client connection; error reading frame from client %s: %v", sc.conn.RemoteAddr(), err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sc.logf("http2: server closing client connection: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processFrame(f Frame) error {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First frame received must be SETTINGS.
0000000000000000000000000000000000000000;;		if !sc.sawFirstSettings {
0000000000000000000000000000000000000000;;			if _, ok := f.(*SettingsFrame); !ok {
0000000000000000000000000000000000000000;;				return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc.sawFirstSettings = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch f := f.(type) {
0000000000000000000000000000000000000000;;		case *SettingsFrame:
0000000000000000000000000000000000000000;;			return sc.processSettings(f)
0000000000000000000000000000000000000000;;		case *MetaHeadersFrame:
0000000000000000000000000000000000000000;;			return sc.processHeaders(f)
0000000000000000000000000000000000000000;;		case *WindowUpdateFrame:
0000000000000000000000000000000000000000;;			return sc.processWindowUpdate(f)
0000000000000000000000000000000000000000;;		case *PingFrame:
0000000000000000000000000000000000000000;;			return sc.processPing(f)
0000000000000000000000000000000000000000;;		case *DataFrame:
0000000000000000000000000000000000000000;;			return sc.processData(f)
0000000000000000000000000000000000000000;;		case *RSTStreamFrame:
0000000000000000000000000000000000000000;;			return sc.processResetStream(f)
0000000000000000000000000000000000000000;;		case *PriorityFrame:
0000000000000000000000000000000000000000;;			return sc.processPriority(f)
0000000000000000000000000000000000000000;;		case *GoAwayFrame:
0000000000000000000000000000000000000000;;			return sc.processGoAway(f)
0000000000000000000000000000000000000000;;		case *PushPromiseFrame:
0000000000000000000000000000000000000000;;			// A client cannot push. Thus, servers MUST treat the receipt of a PUSH_PROMISE
0000000000000000000000000000000000000000;;			// frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			sc.vlogf("http2: server ignoring frame: %v", f.Header())
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processPing(f *PingFrame) error {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if f.IsAck() {
0000000000000000000000000000000000000000;;			// 6.7 PING: " An endpoint MUST NOT respond to PING frames
0000000000000000000000000000000000000000;;			// containing this flag."
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.StreamID != 0 {
0000000000000000000000000000000000000000;;			// "PING frames are not associated with any individual
0000000000000000000000000000000000000000;;			// stream. If a PING frame is received with a stream
0000000000000000000000000000000000000000;;			// identifier field value other than 0x0, the recipient MUST
0000000000000000000000000000000000000000;;			// respond with a connection error (Section 5.4.1) of type
0000000000000000000000000000000000000000;;			// PROTOCOL_ERROR."
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sc.inGoAway && sc.goAwayCode != ErrCodeNo {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.writeFrame(FrameWriteRequest{write: writePingAck{f}})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processWindowUpdate(f *WindowUpdateFrame) error {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case f.StreamID != 0: // stream-level flow control
0000000000000000000000000000000000000000;;			state, st := sc.state(f.StreamID)
0000000000000000000000000000000000000000;;			if state == stateIdle {
0000000000000000000000000000000000000000;;				// Section 5.1: "Receiving any frame other than HEADERS
0000000000000000000000000000000000000000;;				// or PRIORITY on a stream in this state MUST be
0000000000000000000000000000000000000000;;				// treated as a connection error (Section 5.4.1) of
0000000000000000000000000000000000000000;;				// type PROTOCOL_ERROR."
0000000000000000000000000000000000000000;;				return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if st == nil {
0000000000000000000000000000000000000000;;				// "WINDOW_UPDATE can be sent by a peer that has sent a
0000000000000000000000000000000000000000;;				// frame bearing the END_STREAM flag. This means that a
0000000000000000000000000000000000000000;;				// receiver could receive a WINDOW_UPDATE frame on a "half
0000000000000000000000000000000000000000;;				// closed (remote)" or "closed" stream. A receiver MUST
0000000000000000000000000000000000000000;;				// NOT treat this as an error, see Section 5.1."
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !st.flow.add(int32(f.Increment)) {
0000000000000000000000000000000000000000;;				return streamError(f.StreamID, ErrCodeFlowControl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default: // connection-level flow control
0000000000000000000000000000000000000000;;			if !sc.flow.add(int32(f.Increment)) {
0000000000000000000000000000000000000000;;				return goAwayFlowError{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.scheduleFrameWrite()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processResetStream(f *RSTStreamFrame) error {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state, st := sc.state(f.StreamID)
0000000000000000000000000000000000000000;;		if state == stateIdle {
0000000000000000000000000000000000000000;;			// 6.4 "RST_STREAM frames MUST NOT be sent for a
0000000000000000000000000000000000000000;;			// stream in the "idle" state. If a RST_STREAM frame
0000000000000000000000000000000000000000;;			// identifying an idle stream is received, the
0000000000000000000000000000000000000000;;			// recipient MUST treat this as a connection error
0000000000000000000000000000000000000000;;			// (Section 5.4.1) of type PROTOCOL_ERROR.
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if st != nil {
0000000000000000000000000000000000000000;;			st.cancelCtx()
0000000000000000000000000000000000000000;;			sc.closeStream(st, streamError(f.StreamID, f.ErrCode))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) closeStream(st *stream, err error) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if st.state == stateIdle || st.state == stateClosed {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("invariant; can't close stream in state %v", st.state))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st.state = stateClosed
0000000000000000000000000000000000000000;;		if st.isPushed() {
0000000000000000000000000000000000000000;;			sc.curPushedStreams--
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sc.curClientStreams--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(sc.streams, st.id)
0000000000000000000000000000000000000000;;		if len(sc.streams) == 0 {
0000000000000000000000000000000000000000;;			sc.setConnState(http.StateIdle)
0000000000000000000000000000000000000000;;			if sc.srv.IdleTimeout != 0 {
0000000000000000000000000000000000000000;;				sc.idleTimer.Reset(sc.srv.IdleTimeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if h1ServerKeepAlivesDisabled(sc.hs) {
0000000000000000000000000000000000000000;;				sc.startGracefulShutdown()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p := st.body; p != nil {
0000000000000000000000000000000000000000;;			// Return any buffered unread bytes worth of conn-level flow control.
0000000000000000000000000000000000000000;;			// See golang.org/issue/16481
0000000000000000000000000000000000000000;;			sc.sendWindowUpdate(nil, p.Len())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p.CloseWithError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st.cw.Close() // signals Handler's CloseNotifier, unblocks writes, etc
0000000000000000000000000000000000000000;;		sc.writeSched.CloseStream(st.id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processSettings(f *SettingsFrame) error {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if f.IsAck() {
0000000000000000000000000000000000000000;;			sc.unackedSettings--
0000000000000000000000000000000000000000;;			if sc.unackedSettings < 0 {
0000000000000000000000000000000000000000;;				// Why is the peer ACKing settings we never sent?
0000000000000000000000000000000000000000;;				// The spec doesn't mention this case, but
0000000000000000000000000000000000000000;;				// hang up on them anyway.
0000000000000000000000000000000000000000;;				return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := f.ForeachSetting(sc.processSetting); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.needToSendSettingsAck = true
0000000000000000000000000000000000000000;;		sc.scheduleFrameWrite()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processSetting(s Setting) error {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if err := s.Valid(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if VerboseLogs {
0000000000000000000000000000000000000000;;			sc.vlogf("http2: server processing setting %v", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch s.ID {
0000000000000000000000000000000000000000;;		case SettingHeaderTableSize:
0000000000000000000000000000000000000000;;			sc.headerTableSize = s.Val
0000000000000000000000000000000000000000;;			sc.hpackEncoder.SetMaxDynamicTableSize(s.Val)
0000000000000000000000000000000000000000;;		case SettingEnablePush:
0000000000000000000000000000000000000000;;			sc.pushEnabled = s.Val != 0
0000000000000000000000000000000000000000;;		case SettingMaxConcurrentStreams:
0000000000000000000000000000000000000000;;			sc.clientMaxStreams = s.Val
0000000000000000000000000000000000000000;;		case SettingInitialWindowSize:
0000000000000000000000000000000000000000;;			return sc.processSettingInitialWindowSize(s.Val)
0000000000000000000000000000000000000000;;		case SettingMaxFrameSize:
0000000000000000000000000000000000000000;;			sc.maxFrameSize = int32(s.Val) // the maximum valid s.Val is < 2^31
0000000000000000000000000000000000000000;;		case SettingMaxHeaderListSize:
0000000000000000000000000000000000000000;;			sc.peerMaxHeaderListSize = s.Val
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Unknown setting: "An endpoint that receives a SETTINGS
0000000000000000000000000000000000000000;;			// frame with any unknown or unsupported identifier MUST
0000000000000000000000000000000000000000;;			// ignore that setting."
0000000000000000000000000000000000000000;;			if VerboseLogs {
0000000000000000000000000000000000000000;;				sc.vlogf("http2: server ignoring unknown setting %v", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processSettingInitialWindowSize(val uint32) error {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		// Note: val already validated to be within range by
0000000000000000000000000000000000000000;;		// processSetting's Valid call.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// "A SETTINGS frame can alter the initial flow control window
0000000000000000000000000000000000000000;;		// size for all current streams. When the value of
0000000000000000000000000000000000000000;;		// SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST
0000000000000000000000000000000000000000;;		// adjust the size of all stream flow control windows that it
0000000000000000000000000000000000000000;;		// maintains by the difference between the new value and the
0000000000000000000000000000000000000000;;		// old value."
0000000000000000000000000000000000000000;;		old := sc.initialWindowSize
0000000000000000000000000000000000000000;;		sc.initialWindowSize = int32(val)
0000000000000000000000000000000000000000;;		growth := sc.initialWindowSize - old // may be negative
0000000000000000000000000000000000000000;;		for _, st := range sc.streams {
0000000000000000000000000000000000000000;;			if !st.flow.add(growth) {
0000000000000000000000000000000000000000;;				// 6.9.2 Initial Flow Control Window Size
0000000000000000000000000000000000000000;;				// "An endpoint MUST treat a change to
0000000000000000000000000000000000000000;;				// SETTINGS_INITIAL_WINDOW_SIZE that causes any flow
0000000000000000000000000000000000000000;;				// control window to exceed the maximum size as a
0000000000000000000000000000000000000000;;				// connection error (Section 5.4.1) of type
0000000000000000000000000000000000000000;;				// FLOW_CONTROL_ERROR."
0000000000000000000000000000000000000000;;				return ConnectionError(ErrCodeFlowControl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processData(f *DataFrame) error {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if sc.inGoAway && sc.goAwayCode != ErrCodeNo {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data := f.Data()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// "If a DATA frame is received whose stream is not in "open"
0000000000000000000000000000000000000000;;		// or "half closed (local)" state, the recipient MUST respond
0000000000000000000000000000000000000000;;		// with a stream error (Section 5.4.2) of type STREAM_CLOSED."
0000000000000000000000000000000000000000;;		id := f.Header().StreamID
0000000000000000000000000000000000000000;;		state, st := sc.state(id)
0000000000000000000000000000000000000000;;		if id == 0 || state == stateIdle {
0000000000000000000000000000000000000000;;			// Section 5.1: "Receiving any frame other than HEADERS
0000000000000000000000000000000000000000;;			// or PRIORITY on a stream in this state MUST be
0000000000000000000000000000000000000000;;			// treated as a connection error (Section 5.4.1) of
0000000000000000000000000000000000000000;;			// type PROTOCOL_ERROR."
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if st == nil || state != stateOpen || st.gotTrailerHeader || st.resetQueued {
0000000000000000000000000000000000000000;;			// This includes sending a RST_STREAM if the stream is
0000000000000000000000000000000000000000;;			// in stateHalfClosedLocal (which currently means that
0000000000000000000000000000000000000000;;			// the http.Handler returned, so it's done reading &
0000000000000000000000000000000000000000;;			// done writing). Try to stop the client from sending
0000000000000000000000000000000000000000;;			// more DATA.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// But still enforce their connection-level flow control,
0000000000000000000000000000000000000000;;			// and return any flow control bytes since we're not going
0000000000000000000000000000000000000000;;			// to consume them.
0000000000000000000000000000000000000000;;			if sc.inflow.available() < int32(f.Length) {
0000000000000000000000000000000000000000;;				return streamError(id, ErrCodeFlowControl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Deduct the flow control from inflow, since we're
0000000000000000000000000000000000000000;;			// going to immediately add it back in
0000000000000000000000000000000000000000;;			// sendWindowUpdate, which also schedules sending the
0000000000000000000000000000000000000000;;			// frames.
0000000000000000000000000000000000000000;;			sc.inflow.take(int32(f.Length))
0000000000000000000000000000000000000000;;			sc.sendWindowUpdate(nil, int(f.Length)) // conn-level
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if st != nil && st.resetQueued {
0000000000000000000000000000000000000000;;				// Already have a stream error in flight. Don't send another.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return streamError(id, ErrCodeStreamClosed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if st.body == nil {
0000000000000000000000000000000000000000;;			panic("internal error: should have a body in this state")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sender sending more than they'd declared?
0000000000000000000000000000000000000000;;		if st.declBodyBytes != -1 && st.bodyBytes+int64(len(data)) > st.declBodyBytes {
0000000000000000000000000000000000000000;;			st.body.CloseWithError(fmt.Errorf("sender tried to send more than declared Content-Length of %d bytes", st.declBodyBytes))
0000000000000000000000000000000000000000;;			return streamError(id, ErrCodeStreamClosed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.Length > 0 {
0000000000000000000000000000000000000000;;			// Check whether the client has flow control quota.
0000000000000000000000000000000000000000;;			if st.inflow.available() < int32(f.Length) {
0000000000000000000000000000000000000000;;				return streamError(id, ErrCodeFlowControl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			st.inflow.take(int32(f.Length))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(data) > 0 {
0000000000000000000000000000000000000000;;				wrote, err := st.body.Write(data)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return streamError(id, ErrCodeStreamClosed)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if wrote != len(data) {
0000000000000000000000000000000000000000;;					panic("internal error: bad Writer")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st.bodyBytes += int64(len(data))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Return any padded flow control now, since we won't
0000000000000000000000000000000000000000;;			// refund it later on body reads.
0000000000000000000000000000000000000000;;			if pad := int32(f.Length) - int32(len(data)); pad > 0 {
0000000000000000000000000000000000000000;;				sc.sendWindowUpdate32(nil, pad)
0000000000000000000000000000000000000000;;				sc.sendWindowUpdate32(st, pad)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.StreamEnded() {
0000000000000000000000000000000000000000;;			st.endStream()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processGoAway(f *GoAwayFrame) error {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if f.ErrCode != ErrCodeNo {
0000000000000000000000000000000000000000;;			sc.logf("http2: received GOAWAY %+v, starting graceful shutdown", f)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sc.vlogf("http2: received GOAWAY %+v, starting graceful shutdown", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.startGracefulShutdown()
0000000000000000000000000000000000000000;;		// http://tools.ietf.org/html/rfc7540#section-6.8
0000000000000000000000000000000000000000;;		// We should not create any new streams, which means we should disable push.
0000000000000000000000000000000000000000;;		sc.pushEnabled = false
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isPushed reports whether the stream is server-initiated.
0000000000000000000000000000000000000000;;	func (st *stream) isPushed() bool {
0000000000000000000000000000000000000000;;		return st.id%2 == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// endStream closes a Request.Body's pipe. It is called when a DATA
0000000000000000000000000000000000000000;;	// frame says a request body is over (or after trailers).
0000000000000000000000000000000000000000;;	func (st *stream) endStream() {
0000000000000000000000000000000000000000;;		sc := st.sc
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if st.declBodyBytes != -1 && st.declBodyBytes != st.bodyBytes {
0000000000000000000000000000000000000000;;			st.body.CloseWithError(fmt.Errorf("request declared a Content-Length of %d but only wrote %d bytes",
0000000000000000000000000000000000000000;;				st.declBodyBytes, st.bodyBytes))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			st.body.closeWithErrorAndCode(io.EOF, st.copyTrailersToHandlerRequest)
0000000000000000000000000000000000000000;;			st.body.CloseWithError(io.EOF)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st.state = stateHalfClosedRemote
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyTrailersToHandlerRequest is run in the Handler's goroutine in
0000000000000000000000000000000000000000;;	// its Request.Body.Read just before it gets io.EOF.
0000000000000000000000000000000000000000;;	func (st *stream) copyTrailersToHandlerRequest() {
0000000000000000000000000000000000000000;;		for k, vv := range st.trailer {
0000000000000000000000000000000000000000;;			if _, ok := st.reqTrailer[k]; ok {
0000000000000000000000000000000000000000;;				// Only copy it over it was pre-declared.
0000000000000000000000000000000000000000;;				st.reqTrailer[k] = vv
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processHeaders(f *MetaHeadersFrame) error {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		id := f.StreamID
0000000000000000000000000000000000000000;;		if sc.inGoAway {
0000000000000000000000000000000000000000;;			// Ignore.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// http://tools.ietf.org/html/rfc7540#section-5.1.1
0000000000000000000000000000000000000000;;		// Streams initiated by a client MUST use odd-numbered stream
0000000000000000000000000000000000000000;;		// identifiers. [...] An endpoint that receives an unexpected
0000000000000000000000000000000000000000;;		// stream identifier MUST respond with a connection error
0000000000000000000000000000000000000000;;		// (Section 5.4.1) of type PROTOCOL_ERROR.
0000000000000000000000000000000000000000;;		if id%2 != 1 {
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// A HEADERS frame can be used to create a new stream or
0000000000000000000000000000000000000000;;		// send a trailer for an open one. If we already have a stream
0000000000000000000000000000000000000000;;		// open, let it process its own HEADERS frame (trailers at this
0000000000000000000000000000000000000000;;		// point, if it's valid).
0000000000000000000000000000000000000000;;		if st := sc.streams[f.StreamID]; st != nil {
0000000000000000000000000000000000000000;;			if st.resetQueued {
0000000000000000000000000000000000000000;;				// We're sending RST_STREAM to close the stream, so don't bother
0000000000000000000000000000000000000000;;				// processing this frame.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return st.processTrailerHeaders(f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// [...] The identifier of a newly established stream MUST be
0000000000000000000000000000000000000000;;		// numerically greater than all streams that the initiating
0000000000000000000000000000000000000000;;		// endpoint has opened or reserved. [...]  An endpoint that
0000000000000000000000000000000000000000;;		// receives an unexpected stream identifier MUST respond with
0000000000000000000000000000000000000000;;		// a connection error (Section 5.4.1) of type PROTOCOL_ERROR.
0000000000000000000000000000000000000000;;		if id <= sc.maxClientStreamID {
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.maxClientStreamID = id
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sc.idleTimer != nil {
0000000000000000000000000000000000000000;;			sc.idleTimer.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// http://tools.ietf.org/html/rfc7540#section-5.1.2
0000000000000000000000000000000000000000;;		// [...] Endpoints MUST NOT exceed the limit set by their peer. An
0000000000000000000000000000000000000000;;		// endpoint that receives a HEADERS frame that causes their
0000000000000000000000000000000000000000;;		// advertised concurrent stream limit to be exceeded MUST treat
0000000000000000000000000000000000000000;;		// this as a stream error (Section 5.4.2) of type PROTOCOL_ERROR
0000000000000000000000000000000000000000;;		// or REFUSED_STREAM.
0000000000000000000000000000000000000000;;		if sc.curClientStreams+1 > sc.advMaxStreams {
0000000000000000000000000000000000000000;;			if sc.unackedSettings == 0 {
0000000000000000000000000000000000000000;;				// They should know better.
0000000000000000000000000000000000000000;;				return streamError(id, ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Assume it's a network race, where they just haven't
0000000000000000000000000000000000000000;;			// received our last SETTINGS update. But actually
0000000000000000000000000000000000000000;;			// this can't happen yet, because we don't yet provide
0000000000000000000000000000000000000000;;			// a way for users to adjust server parameters at
0000000000000000000000000000000000000000;;			// runtime.
0000000000000000000000000000000000000000;;			return streamError(id, ErrCodeRefusedStream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		initialState := stateOpen
0000000000000000000000000000000000000000;;		if f.StreamEnded() {
0000000000000000000000000000000000000000;;			initialState = stateHalfClosedRemote
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st := sc.newStream(id, 0, initialState)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.HasPriority() {
0000000000000000000000000000000000000000;;			if err := checkPriority(f.StreamID, f.Priority); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc.writeSched.AdjustStream(st.id, f.Priority)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rw, req, err := sc.newWriterAndRequest(st, f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st.reqTrailer = req.Trailer
0000000000000000000000000000000000000000;;		if st.reqTrailer != nil {
0000000000000000000000000000000000000000;;			st.trailer = make(http.Header)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st.body = req.Body.(*requestBody).pipe // may be nil
0000000000000000000000000000000000000000;;		st.declBodyBytes = req.ContentLength
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := sc.handler.ServeHTTP
0000000000000000000000000000000000000000;;		if f.Truncated {
0000000000000000000000000000000000000000;;			// Their header list was too long. Send a 431 error.
0000000000000000000000000000000000000000;;			handler = handleHeaderListTooLong
0000000000000000000000000000000000000000;;		} else if err := checkValidHTTP2RequestHeaders(req.Header); err != nil {
0000000000000000000000000000000000000000;;			handler = new400Handler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The net/http package sets the read deadline from the
0000000000000000000000000000000000000000;;		// http.Server.ReadTimeout during the TLS handshake, but then
0000000000000000000000000000000000000000;;		// passes the connection off to us with the deadline already
0000000000000000000000000000000000000000;;		// set. Disarm it here after the request headers are read,
0000000000000000000000000000000000000000;;		// similar to how the http1 server works. Here it's
0000000000000000000000000000000000000000;;		// technically more like the http1 Server's ReadHeaderTimeout
0000000000000000000000000000000000000000;;		// (in Go 1.8), though. That's a more sane option anyway.
0000000000000000000000000000000000000000;;		if sc.hs.ReadTimeout != 0 {
0000000000000000000000000000000000000000;;			sc.conn.SetReadDeadline(time.Time{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go sc.runHandler(rw, req, handler)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (st *stream) processTrailerHeaders(f *MetaHeadersFrame) error {
0000000000000000000000000000000000000000;;		sc := st.sc
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if st.gotTrailerHeader {
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st.gotTrailerHeader = true
0000000000000000000000000000000000000000;;		if !f.StreamEnded() {
0000000000000000000000000000000000000000;;			return streamError(st.id, ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(f.PseudoFields()) > 0 {
0000000000000000000000000000000000000000;;			return streamError(st.id, ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if st.trailer != nil {
0000000000000000000000000000000000000000;;			for _, hf := range f.RegularFields() {
0000000000000000000000000000000000000000;;				key := sc.canonicalHeader(hf.Name)
0000000000000000000000000000000000000000;;				if !ValidTrailerHeader(key) {
0000000000000000000000000000000000000000;;					// TODO: send more details to the peer somehow. But http2 has
0000000000000000000000000000000000000000;;					// no way to send debug data at a stream level. Discuss with
0000000000000000000000000000000000000000;;					// HTTP folk.
0000000000000000000000000000000000000000;;					return streamError(st.id, ErrCodeProtocol)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st.trailer[key] = append(st.trailer[key], hf.Value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st.endStream()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkPriority(streamID uint32, p PriorityParam) error {
0000000000000000000000000000000000000000;;		if streamID == p.StreamDep {
0000000000000000000000000000000000000000;;			// Section 5.3.1: "A stream cannot depend on itself. An endpoint MUST treat
0000000000000000000000000000000000000000;;			// this as a stream error (Section 5.4.2) of type PROTOCOL_ERROR."
0000000000000000000000000000000000000000;;			// Section 5.3.3 says that a stream can depend on one of its dependencies,
0000000000000000000000000000000000000000;;			// so it's only self-dependencies that are forbidden.
0000000000000000000000000000000000000000;;			return streamError(streamID, ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) processPriority(f *PriorityFrame) error {
0000000000000000000000000000000000000000;;		if sc.inGoAway {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := checkPriority(f.StreamID, f.PriorityParam); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.writeSched.AdjustStream(f.StreamID, f.PriorityParam)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) newStream(id, pusherID uint32, state streamState) *stream {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if id == 0 {
0000000000000000000000000000000000000000;;			panic("internal error: cannot create stream with id 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancelCtx := contextWithCancel(sc.baseCtx)
0000000000000000000000000000000000000000;;		st := &stream{
0000000000000000000000000000000000000000;;			sc:        sc,
0000000000000000000000000000000000000000;;			id:        id,
0000000000000000000000000000000000000000;;			state:     state,
0000000000000000000000000000000000000000;;			ctx:       ctx,
0000000000000000000000000000000000000000;;			cancelCtx: cancelCtx,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st.cw.Init()
0000000000000000000000000000000000000000;;		st.flow.conn = &sc.flow // link to conn-level counter
0000000000000000000000000000000000000000;;		st.flow.add(sc.initialWindowSize)
0000000000000000000000000000000000000000;;		st.inflow.conn = &sc.inflow      // link to conn-level counter
0000000000000000000000000000000000000000;;		st.inflow.add(initialWindowSize) // TODO: update this when we send a higher initial window size in the initial settings
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc.streams[id] = st
0000000000000000000000000000000000000000;;		sc.writeSched.OpenStream(st.id, OpenStreamOptions{PusherID: pusherID})
0000000000000000000000000000000000000000;;		if st.isPushed() {
0000000000000000000000000000000000000000;;			sc.curPushedStreams++
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sc.curClientStreams++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sc.curOpenStreams() == 1 {
0000000000000000000000000000000000000000;;			sc.setConnState(http.StateActive)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return st
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) newWriterAndRequest(st *stream, f *MetaHeadersFrame) (*responseWriter, *http.Request, error) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rp := requestParam{
0000000000000000000000000000000000000000;;			method:    f.PseudoValue("method"),
0000000000000000000000000000000000000000;;			scheme:    f.PseudoValue("scheme"),
0000000000000000000000000000000000000000;;			authority: f.PseudoValue("authority"),
0000000000000000000000000000000000000000;;			path:      f.PseudoValue("path"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isConnect := rp.method == "CONNECT"
0000000000000000000000000000000000000000;;		if isConnect {
0000000000000000000000000000000000000000;;			if rp.path != "" || rp.scheme != "" || rp.authority == "" {
0000000000000000000000000000000000000000;;				return nil, nil, streamError(f.StreamID, ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if rp.method == "" || rp.path == "" || (rp.scheme != "https" && rp.scheme != "http") {
0000000000000000000000000000000000000000;;			// See 8.1.2.6 Malformed Requests and Responses:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Malformed requests or responses that are detected
0000000000000000000000000000000000000000;;			// MUST be treated as a stream error (Section 5.4.2)
0000000000000000000000000000000000000000;;			// of type PROTOCOL_ERROR."
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// 8.1.2.3 Request Pseudo-Header Fields
0000000000000000000000000000000000000000;;			// "All HTTP/2 requests MUST include exactly one valid
0000000000000000000000000000000000000000;;			// value for the :method, :scheme, and :path
0000000000000000000000000000000000000000;;			// pseudo-header fields"
0000000000000000000000000000000000000000;;			return nil, nil, streamError(f.StreamID, ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bodyOpen := !f.StreamEnded()
0000000000000000000000000000000000000000;;		if rp.method == "HEAD" && bodyOpen {
0000000000000000000000000000000000000000;;			// HEAD requests can't have bodies
0000000000000000000000000000000000000000;;			return nil, nil, streamError(f.StreamID, ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rp.header = make(http.Header)
0000000000000000000000000000000000000000;;		for _, hf := range f.RegularFields() {
0000000000000000000000000000000000000000;;			rp.header.Add(sc.canonicalHeader(hf.Name), hf.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rp.authority == "" {
0000000000000000000000000000000000000000;;			rp.authority = rp.header.Get("Host")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rw, req, err := sc.newWriterAndRequestNoBody(st, rp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bodyOpen {
0000000000000000000000000000000000000000;;			st.reqBuf = getRequestBodyBuf()
0000000000000000000000000000000000000000;;			req.Body.(*requestBody).pipe = &pipe{
0000000000000000000000000000000000000000;;				b: &fixedBuffer{buf: st.reqBuf},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if vv, ok := rp.header["Content-Length"]; ok {
0000000000000000000000000000000000000000;;				req.ContentLength, _ = strconv.ParseInt(vv[0], 10, 64)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				req.ContentLength = -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rw, req, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type requestParam struct {
0000000000000000000000000000000000000000;;		method                  string
0000000000000000000000000000000000000000;;		scheme, authority, path string
0000000000000000000000000000000000000000;;		header                  http.Header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) newWriterAndRequestNoBody(st *stream, rp requestParam) (*responseWriter, *http.Request, error) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tlsState *tls.ConnectionState // nil if not scheme https
0000000000000000000000000000000000000000;;		if rp.scheme == "https" {
0000000000000000000000000000000000000000;;			tlsState = sc.tlsState
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		needsContinue := rp.header.Get("Expect") == "100-continue"
0000000000000000000000000000000000000000;;		if needsContinue {
0000000000000000000000000000000000000000;;			rp.header.Del("Expect")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Merge Cookie headers into one "; "-delimited value.
0000000000000000000000000000000000000000;;		if cookies := rp.header["Cookie"]; len(cookies) > 1 {
0000000000000000000000000000000000000000;;			rp.header.Set("Cookie", strings.Join(cookies, "; "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup Trailers
0000000000000000000000000000000000000000;;		var trailer http.Header
0000000000000000000000000000000000000000;;		for _, v := range rp.header["Trailer"] {
0000000000000000000000000000000000000000;;			for _, key := range strings.Split(v, ",") {
0000000000000000000000000000000000000000;;				key = http.CanonicalHeaderKey(strings.TrimSpace(key))
0000000000000000000000000000000000000000;;				switch key {
0000000000000000000000000000000000000000;;				case "Transfer-Encoding", "Trailer", "Content-Length":
0000000000000000000000000000000000000000;;					// Bogus. (copy of http1 rules)
0000000000000000000000000000000000000000;;					// Ignore.
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					if trailer == nil {
0000000000000000000000000000000000000000;;						trailer = make(http.Header)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					trailer[key] = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(rp.header, "Trailer")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var url_ *url.URL
0000000000000000000000000000000000000000;;		var requestURI string
0000000000000000000000000000000000000000;;		if rp.method == "CONNECT" {
0000000000000000000000000000000000000000;;			url_ = &url.URL{Host: rp.authority}
0000000000000000000000000000000000000000;;			requestURI = rp.authority // mimic HTTP/1 server behavior
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			url_, err = url.ParseRequestURI(rp.path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, streamError(st.id, ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			requestURI = rp.path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body := &requestBody{
0000000000000000000000000000000000000000;;			conn:          sc,
0000000000000000000000000000000000000000;;			stream:        st,
0000000000000000000000000000000000000000;;			needsContinue: needsContinue,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req := &http.Request{
0000000000000000000000000000000000000000;;			Method:     rp.method,
0000000000000000000000000000000000000000;;			URL:        url_,
0000000000000000000000000000000000000000;;			RemoteAddr: sc.remoteAddrStr,
0000000000000000000000000000000000000000;;			Header:     rp.header,
0000000000000000000000000000000000000000;;			RequestURI: requestURI,
0000000000000000000000000000000000000000;;			Proto:      "HTTP/2.0",
0000000000000000000000000000000000000000;;			ProtoMajor: 2,
0000000000000000000000000000000000000000;;			ProtoMinor: 0,
0000000000000000000000000000000000000000;;			TLS:        tlsState,
0000000000000000000000000000000000000000;;			Host:       rp.authority,
0000000000000000000000000000000000000000;;			Body:       body,
0000000000000000000000000000000000000000;;			Trailer:    trailer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req = requestWithContext(req, st.ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rws := responseWriterStatePool.Get().(*responseWriterState)
0000000000000000000000000000000000000000;;		bwSave := rws.bw
0000000000000000000000000000000000000000;;		*rws = responseWriterState{} // zero all the fields
0000000000000000000000000000000000000000;;		rws.conn = sc
0000000000000000000000000000000000000000;;		rws.bw = bwSave
0000000000000000000000000000000000000000;;		rws.bw.Reset(chunkWriter{rws})
0000000000000000000000000000000000000000;;		rws.stream = st
0000000000000000000000000000000000000000;;		rws.req = req
0000000000000000000000000000000000000000;;		rws.body = body
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rw := &responseWriter{rws: rws}
0000000000000000000000000000000000000000;;		return rw, req, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var reqBodyCache = make(chan []byte, 8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRequestBodyBuf() []byte {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case b := <-reqBodyCache:
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return make([]byte, initialWindowSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func putRequestBodyBuf(b []byte) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case reqBodyCache <- b:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run on its own goroutine.
0000000000000000000000000000000000000000;;	func (sc *serverConn) runHandler(rw *responseWriter, req *http.Request, handler func(http.ResponseWriter, *http.Request)) {
0000000000000000000000000000000000000000;;		didPanic := true
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			rw.rws.stream.cancelCtx()
0000000000000000000000000000000000000000;;			if didPanic {
0000000000000000000000000000000000000000;;				e := recover()
0000000000000000000000000000000000000000;;				sc.writeFrameFromHandler(FrameWriteRequest{
0000000000000000000000000000000000000000;;					write:  handlerPanicRST{rw.rws.stream.id},
0000000000000000000000000000000000000000;;					stream: rw.rws.stream,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				// Same as net/http:
0000000000000000000000000000000000000000;;				if shouldLogPanic(e) {
0000000000000000000000000000000000000000;;					const size = 64 << 10
0000000000000000000000000000000000000000;;					buf := make([]byte, size)
0000000000000000000000000000000000000000;;					buf = buf[:runtime.Stack(buf, false)]
0000000000000000000000000000000000000000;;					sc.logf("http2: panic serving %v: %v\n%s", sc.conn.RemoteAddr(), e, buf)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rw.handlerDone()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		handler(rw, req)
0000000000000000000000000000000000000000;;		didPanic = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleHeaderListTooLong(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		// 10.5.1 Limits on Header Block Size:
0000000000000000000000000000000000000000;;		// .. "A server that receives a larger header block than it is
0000000000000000000000000000000000000000;;		// willing to handle can send an HTTP 431 (Request Header Fields Too
0000000000000000000000000000000000000000;;		// Large) status code"
0000000000000000000000000000000000000000;;		const statusRequestHeaderFieldsTooLarge = 431 // only in Go 1.6+
0000000000000000000000000000000000000000;;		w.WriteHeader(statusRequestHeaderFieldsTooLarge)
0000000000000000000000000000000000000000;;		io.WriteString(w, "<h1>HTTP Error 431</h1><p>Request Header Field(s) Too Large</p>")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// called from handler goroutines.
0000000000000000000000000000000000000000;;	// h may be nil.
0000000000000000000000000000000000000000;;	func (sc *serverConn) writeHeaders(st *stream, headerData *writeResHeaders) error {
0000000000000000000000000000000000000000;;		sc.serveG.checkNotOn() // NOT on
0000000000000000000000000000000000000000;;		var errc chan error
0000000000000000000000000000000000000000;;		if headerData.h != nil {
0000000000000000000000000000000000000000;;			// If there's a header map (which we don't own), so we have to block on
0000000000000000000000000000000000000000;;			// waiting for this frame to be written, so an http.Flush mid-handler
0000000000000000000000000000000000000000;;			// writes out the correct value of keys, before a handler later potentially
0000000000000000000000000000000000000000;;			// mutates it.
0000000000000000000000000000000000000000;;			errc = errChanPool.Get().(chan error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := sc.writeFrameFromHandler(FrameWriteRequest{
0000000000000000000000000000000000000000;;			write:  headerData,
0000000000000000000000000000000000000000;;			stream: st,
0000000000000000000000000000000000000000;;			done:   errc,
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errc != nil {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case err := <-errc:
0000000000000000000000000000000000000000;;				errChanPool.Put(errc)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			case <-sc.doneServing:
0000000000000000000000000000000000000000;;				return errClientDisconnected
0000000000000000000000000000000000000000;;			case <-st.cw:
0000000000000000000000000000000000000000;;				return errStreamClosed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// called from handler goroutines.
0000000000000000000000000000000000000000;;	func (sc *serverConn) write100ContinueHeaders(st *stream) {
0000000000000000000000000000000000000000;;		sc.writeFrameFromHandler(FrameWriteRequest{
0000000000000000000000000000000000000000;;			write:  write100ContinueHeadersFrame{st.id},
0000000000000000000000000000000000000000;;			stream: st,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A bodyReadMsg tells the server loop that the http.Handler read n
0000000000000000000000000000000000000000;;	// bytes of the DATA from the client on the given stream.
0000000000000000000000000000000000000000;;	type bodyReadMsg struct {
0000000000000000000000000000000000000000;;		st *stream
0000000000000000000000000000000000000000;;		n  int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// called from handler goroutines.
0000000000000000000000000000000000000000;;	// Notes that the handler for the given stream ID read n bytes of its body
0000000000000000000000000000000000000000;;	// and schedules flow control tokens to be sent.
0000000000000000000000000000000000000000;;	func (sc *serverConn) noteBodyReadFromHandler(st *stream, n int, err error) {
0000000000000000000000000000000000000000;;		sc.serveG.checkNotOn() // NOT on
0000000000000000000000000000000000000000;;		if n > 0 {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case sc.bodyReadCh <- bodyReadMsg{st, n}:
0000000000000000000000000000000000000000;;			case <-sc.doneServing:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			if buf := st.reqBuf; buf != nil {
0000000000000000000000000000000000000000;;				st.reqBuf = nil // shouldn't matter; field unused by other
0000000000000000000000000000000000000000;;				putRequestBodyBuf(buf)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) noteBodyRead(st *stream, n int) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		sc.sendWindowUpdate(nil, n) // conn-level
0000000000000000000000000000000000000000;;		if st.state != stateHalfClosedRemote && st.state != stateClosed {
0000000000000000000000000000000000000000;;			// Don't send this WINDOW_UPDATE if the stream is closed
0000000000000000000000000000000000000000;;			// remotely.
0000000000000000000000000000000000000000;;			sc.sendWindowUpdate(st, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// st may be nil for conn-level
0000000000000000000000000000000000000000;;	func (sc *serverConn) sendWindowUpdate(st *stream, n int) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		// "The legal range for the increment to the flow control
0000000000000000000000000000000000000000;;		// window is 1 to 2^31-1 (2,147,483,647) octets."
0000000000000000000000000000000000000000;;		// A Go Read call on 64-bit machines could in theory read
0000000000000000000000000000000000000000;;		// a larger Read than this. Very unlikely, but we handle it here
0000000000000000000000000000000000000000;;		// rather than elsewhere for now.
0000000000000000000000000000000000000000;;		const maxUint31 = 1<<31 - 1
0000000000000000000000000000000000000000;;		for n >= maxUint31 {
0000000000000000000000000000000000000000;;			sc.sendWindowUpdate32(st, maxUint31)
0000000000000000000000000000000000000000;;			n -= maxUint31
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.sendWindowUpdate32(st, int32(n))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// st may be nil for conn-level
0000000000000000000000000000000000000000;;	func (sc *serverConn) sendWindowUpdate32(st *stream, n int32) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n < 0 {
0000000000000000000000000000000000000000;;			panic("negative update")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var streamID uint32
0000000000000000000000000000000000000000;;		if st != nil {
0000000000000000000000000000000000000000;;			streamID = st.id
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc.writeFrame(FrameWriteRequest{
0000000000000000000000000000000000000000;;			write:  writeWindowUpdate{streamID: streamID, n: uint32(n)},
0000000000000000000000000000000000000000;;			stream: st,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if st == nil {
0000000000000000000000000000000000000000;;			ok = sc.inflow.add(n)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ok = st.inflow.add(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			panic("internal error; sent too many window updates without decrements?")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requestBody is the Handler's Request.Body type.
0000000000000000000000000000000000000000;;	// Read and Close may be called concurrently.
0000000000000000000000000000000000000000;;	type requestBody struct {
0000000000000000000000000000000000000000;;		stream        *stream
0000000000000000000000000000000000000000;;		conn          *serverConn
0000000000000000000000000000000000000000;;		closed        bool  // for use by Close only
0000000000000000000000000000000000000000;;		sawEOF        bool  // for use by Read only
0000000000000000000000000000000000000000;;		pipe          *pipe // non-nil if we have a HTTP entity message body
0000000000000000000000000000000000000000;;		needsContinue bool  // need to send a 100-continue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *requestBody) Close() error {
0000000000000000000000000000000000000000;;		if b.pipe != nil && !b.closed {
0000000000000000000000000000000000000000;;			b.pipe.BreakWithError(errClosedBody)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.closed = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *requestBody) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if b.needsContinue {
0000000000000000000000000000000000000000;;			b.needsContinue = false
0000000000000000000000000000000000000000;;			b.conn.write100ContinueHeaders(b.stream)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.pipe == nil || b.sawEOF {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = b.pipe.Read(p)
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			b.sawEOF = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.conn == nil && inTests {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.conn.noteBodyReadFromHandler(b.stream, n, err)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// responseWriter is the http.ResponseWriter implementation.  It's
0000000000000000000000000000000000000000;;	// intentionally small (1 pointer wide) to minimize garbage.  The
0000000000000000000000000000000000000000;;	// responseWriterState pointer inside is zeroed at the end of a
0000000000000000000000000000000000000000;;	// request (in handlerDone) and calls on the responseWriter thereafter
0000000000000000000000000000000000000000;;	// simply crash (caller's mistake), but the much larger responseWriterState
0000000000000000000000000000000000000000;;	// and buffers are reused between multiple requests.
0000000000000000000000000000000000000000;;	type responseWriter struct {
0000000000000000000000000000000000000000;;		rws *responseWriterState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Optional http.ResponseWriter interfaces implemented.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ http.CloseNotifier = (*responseWriter)(nil)
0000000000000000000000000000000000000000;;		_ http.Flusher       = (*responseWriter)(nil)
0000000000000000000000000000000000000000;;		_ stringWriter       = (*responseWriter)(nil)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type responseWriterState struct {
0000000000000000000000000000000000000000;;		// immutable within a request:
0000000000000000000000000000000000000000;;		stream *stream
0000000000000000000000000000000000000000;;		req    *http.Request
0000000000000000000000000000000000000000;;		body   *requestBody // to close at end of request, if DATA frames didn't
0000000000000000000000000000000000000000;;		conn   *serverConn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: adjust buffer writing sizes based on server config, frame size updates from peer, etc
0000000000000000000000000000000000000000;;		bw *bufio.Writer // writing to a chunkWriter{this *responseWriterState}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mutated by http.Handler goroutine:
0000000000000000000000000000000000000000;;		handlerHeader http.Header // nil until called
0000000000000000000000000000000000000000;;		snapHeader    http.Header // snapshot of handlerHeader at WriteHeader time
0000000000000000000000000000000000000000;;		trailers      []string    // set in writeChunk
0000000000000000000000000000000000000000;;		status        int         // status code passed to WriteHeader
0000000000000000000000000000000000000000;;		wroteHeader   bool        // WriteHeader called (explicitly or implicitly). Not necessarily sent to user yet.
0000000000000000000000000000000000000000;;		sentHeader    bool        // have we sent the header frame?
0000000000000000000000000000000000000000;;		handlerDone   bool        // handler has finished
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sentContentLen int64 // non-zero if handler set a Content-Length header
0000000000000000000000000000000000000000;;		wroteBytes     int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closeNotifierMu sync.Mutex // guards closeNotifierCh
0000000000000000000000000000000000000000;;		closeNotifierCh chan bool  // nil until first used
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type chunkWriter struct{ rws *responseWriterState }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cw chunkWriter) Write(p []byte) (n int, err error) { return cw.rws.writeChunk(p) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rws *responseWriterState) hasTrailers() bool { return len(rws.trailers) != 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// declareTrailer is called for each Trailer header when the
0000000000000000000000000000000000000000;;	// response header is written. It notes that a header will need to be
0000000000000000000000000000000000000000;;	// written in the trailers at the end of the response.
0000000000000000000000000000000000000000;;	func (rws *responseWriterState) declareTrailer(k string) {
0000000000000000000000000000000000000000;;		k = http.CanonicalHeaderKey(k)
0000000000000000000000000000000000000000;;		if !ValidTrailerHeader(k) {
0000000000000000000000000000000000000000;;			// Forbidden by RFC 2616 14.40.
0000000000000000000000000000000000000000;;			rws.conn.logf("ignoring invalid trailer %q", k)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strSliceContains(rws.trailers, k) {
0000000000000000000000000000000000000000;;			rws.trailers = append(rws.trailers, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeChunk writes chunks from the bufio.Writer. But because
0000000000000000000000000000000000000000;;	// bufio.Writer may bypass its chunking, sometimes p may be
0000000000000000000000000000000000000000;;	// arbitrarily large.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// writeChunk is also responsible (on the first chunk) for sending the
0000000000000000000000000000000000000000;;	// HEADER response.
0000000000000000000000000000000000000000;;	func (rws *responseWriterState) writeChunk(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if !rws.wroteHeader {
0000000000000000000000000000000000000000;;			rws.writeHeader(200)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isHeadResp := rws.req.Method == "HEAD"
0000000000000000000000000000000000000000;;		if !rws.sentHeader {
0000000000000000000000000000000000000000;;			rws.sentHeader = true
0000000000000000000000000000000000000000;;			var ctype, clen string
0000000000000000000000000000000000000000;;			if clen = rws.snapHeader.Get("Content-Length"); clen != "" {
0000000000000000000000000000000000000000;;				rws.snapHeader.Del("Content-Length")
0000000000000000000000000000000000000000;;				clen64, err := strconv.ParseInt(clen, 10, 64)
0000000000000000000000000000000000000000;;				if err == nil && clen64 >= 0 {
0000000000000000000000000000000000000000;;					rws.sentContentLen = clen64
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					clen = ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if clen == "" && rws.handlerDone && bodyAllowedForStatus(rws.status) && (len(p) > 0 || !isHeadResp) {
0000000000000000000000000000000000000000;;				clen = strconv.Itoa(len(p))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, hasContentType := rws.snapHeader["Content-Type"]
0000000000000000000000000000000000000000;;			if !hasContentType && bodyAllowedForStatus(rws.status) {
0000000000000000000000000000000000000000;;				ctype = http.DetectContentType(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var date string
0000000000000000000000000000000000000000;;			if _, ok := rws.snapHeader["Date"]; !ok {
0000000000000000000000000000000000000000;;				// TODO(bradfitz): be faster here, like net/http? measure.
0000000000000000000000000000000000000000;;				date = time.Now().UTC().Format(http.TimeFormat)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, v := range rws.snapHeader["Trailer"] {
0000000000000000000000000000000000000000;;				foreachHeaderElement(v, rws.declareTrailer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			endStream := (rws.handlerDone && !rws.hasTrailers() && len(p) == 0) || isHeadResp
0000000000000000000000000000000000000000;;			err = rws.conn.writeHeaders(rws.stream, &writeResHeaders{
0000000000000000000000000000000000000000;;				streamID:      rws.stream.id,
0000000000000000000000000000000000000000;;				httpResCode:   rws.status,
0000000000000000000000000000000000000000;;				h:             rws.snapHeader,
0000000000000000000000000000000000000000;;				endStream:     endStream,
0000000000000000000000000000000000000000;;				contentType:   ctype,
0000000000000000000000000000000000000000;;				contentLength: clen,
0000000000000000000000000000000000000000;;				date:          date,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if endStream {
0000000000000000000000000000000000000000;;				return 0, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isHeadResp {
0000000000000000000000000000000000000000;;			return len(p), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p) == 0 && !rws.handlerDone {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rws.handlerDone {
0000000000000000000000000000000000000000;;			rws.promoteUndeclaredTrailers()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endStream := rws.handlerDone && !rws.hasTrailers()
0000000000000000000000000000000000000000;;		if len(p) > 0 || endStream {
0000000000000000000000000000000000000000;;			// only send a 0 byte DATA frame if we're ending the stream.
0000000000000000000000000000000000000000;;			if err := rws.conn.writeDataFromHandler(rws.stream, p, endStream); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rws.handlerDone && rws.hasTrailers() {
0000000000000000000000000000000000000000;;			err = rws.conn.writeHeaders(rws.stream, &writeResHeaders{
0000000000000000000000000000000000000000;;				streamID:  rws.stream.id,
0000000000000000000000000000000000000000;;				h:         rws.handlerHeader,
0000000000000000000000000000000000000000;;				trailers:  rws.trailers,
0000000000000000000000000000000000000000;;				endStream: true,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			return len(p), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(p), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TrailerPrefix is a magic prefix for ResponseWriter.Header map keys
0000000000000000000000000000000000000000;;	// that, if present, signals that the map entry is actually for
0000000000000000000000000000000000000000;;	// the response trailers, and not the response headers. The prefix
0000000000000000000000000000000000000000;;	// is stripped after the ServeHTTP call finishes and the values are
0000000000000000000000000000000000000000;;	// sent in the trailers.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This mechanism is intended only for trailers that are not known
0000000000000000000000000000000000000000;;	// prior to the headers being written. If the set of trailers is fixed
0000000000000000000000000000000000000000;;	// or known before the header is written, the normal Go trailers mechanism
0000000000000000000000000000000000000000;;	// is preferred:
0000000000000000000000000000000000000000;;	//    https://golang.org/pkg/net/http/#ResponseWriter
0000000000000000000000000000000000000000;;	//    https://golang.org/pkg/net/http/#example_ResponseWriter_trailers
0000000000000000000000000000000000000000;;	const TrailerPrefix = "Trailer:"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// promoteUndeclaredTrailers permits http.Handlers to set trailers
0000000000000000000000000000000000000000;;	// after the header has already been flushed. Because the Go
0000000000000000000000000000000000000000;;	// ResponseWriter interface has no way to set Trailers (only the
0000000000000000000000000000000000000000;;	// Header), and because we didn't want to expand the ResponseWriter
0000000000000000000000000000000000000000;;	// interface, and because nobody used trailers, and because RFC 2616
0000000000000000000000000000000000000000;;	// says you SHOULD (but not must) predeclare any trailers in the
0000000000000000000000000000000000000000;;	// header, the official ResponseWriter rules said trailers in Go must
0000000000000000000000000000000000000000;;	// be predeclared, and then we reuse the same ResponseWriter.Header()
0000000000000000000000000000000000000000;;	// map to mean both Headers and Trailers.  When it's time to write the
0000000000000000000000000000000000000000;;	// Trailers, we pick out the fields of Headers that were declared as
0000000000000000000000000000000000000000;;	// trailers. That worked for a while, until we found the first major
0000000000000000000000000000000000000000;;	// user of Trailers in the wild: gRPC (using them only over http2),
0000000000000000000000000000000000000000;;	// and gRPC libraries permit setting trailers mid-stream without
0000000000000000000000000000000000000000;;	// predeclarnig them. So: change of plans. We still permit the old
0000000000000000000000000000000000000000;;	// way, but we also permit this hack: if a Header() key begins with
0000000000000000000000000000000000000000;;	// "Trailer:", the suffix of that key is a Trailer. Because ':' is an
0000000000000000000000000000000000000000;;	// invalid token byte anyway, there is no ambiguity. (And it's already
0000000000000000000000000000000000000000;;	// filtered out) It's mildly hacky, but not terrible.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method runs after the Handler is done and promotes any Header
0000000000000000000000000000000000000000;;	// fields to be trailers.
0000000000000000000000000000000000000000;;	func (rws *responseWriterState) promoteUndeclaredTrailers() {
0000000000000000000000000000000000000000;;		for k, vv := range rws.handlerHeader {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(k, TrailerPrefix) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			trailerKey := strings.TrimPrefix(k, TrailerPrefix)
0000000000000000000000000000000000000000;;			rws.declareTrailer(trailerKey)
0000000000000000000000000000000000000000;;			rws.handlerHeader[http.CanonicalHeaderKey(trailerKey)] = vv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(rws.trailers) > 1 {
0000000000000000000000000000000000000000;;			sorter := sorterPool.Get().(*sorter)
0000000000000000000000000000000000000000;;			sorter.SortStrings(rws.trailers)
0000000000000000000000000000000000000000;;			sorterPool.Put(sorter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *responseWriter) Flush() {
0000000000000000000000000000000000000000;;		rws := w.rws
0000000000000000000000000000000000000000;;		if rws == nil {
0000000000000000000000000000000000000000;;			panic("Header called after Handler finished")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rws.bw.Buffered() > 0 {
0000000000000000000000000000000000000000;;			if err := rws.bw.Flush(); err != nil {
0000000000000000000000000000000000000000;;				// Ignore the error. The frame writer already knows.
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// The bufio.Writer won't call chunkWriter.Write
0000000000000000000000000000000000000000;;			// (writeChunk with zero bytes, so we have to do it
0000000000000000000000000000000000000000;;			// ourselves to force the HTTP response header and/or
0000000000000000000000000000000000000000;;			// final DATA frame (with END_STREAM) to be sent.
0000000000000000000000000000000000000000;;			rws.writeChunk(nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *responseWriter) CloseNotify() <-chan bool {
0000000000000000000000000000000000000000;;		rws := w.rws
0000000000000000000000000000000000000000;;		if rws == nil {
0000000000000000000000000000000000000000;;			panic("CloseNotify called after Handler finished")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rws.closeNotifierMu.Lock()
0000000000000000000000000000000000000000;;		ch := rws.closeNotifierCh
0000000000000000000000000000000000000000;;		if ch == nil {
0000000000000000000000000000000000000000;;			ch = make(chan bool, 1)
0000000000000000000000000000000000000000;;			rws.closeNotifierCh = ch
0000000000000000000000000000000000000000;;			cw := rws.stream.cw
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				cw.Wait() // wait for close
0000000000000000000000000000000000000000;;				ch <- true
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rws.closeNotifierMu.Unlock()
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *responseWriter) Header() http.Header {
0000000000000000000000000000000000000000;;		rws := w.rws
0000000000000000000000000000000000000000;;		if rws == nil {
0000000000000000000000000000000000000000;;			panic("Header called after Handler finished")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rws.handlerHeader == nil {
0000000000000000000000000000000000000000;;			rws.handlerHeader = make(http.Header)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rws.handlerHeader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *responseWriter) WriteHeader(code int) {
0000000000000000000000000000000000000000;;		rws := w.rws
0000000000000000000000000000000000000000;;		if rws == nil {
0000000000000000000000000000000000000000;;			panic("WriteHeader called after Handler finished")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rws.writeHeader(code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rws *responseWriterState) writeHeader(code int) {
0000000000000000000000000000000000000000;;		if !rws.wroteHeader {
0000000000000000000000000000000000000000;;			rws.wroteHeader = true
0000000000000000000000000000000000000000;;			rws.status = code
0000000000000000000000000000000000000000;;			if len(rws.handlerHeader) > 0 {
0000000000000000000000000000000000000000;;				rws.snapHeader = cloneHeader(rws.handlerHeader)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cloneHeader(h http.Header) http.Header {
0000000000000000000000000000000000000000;;		h2 := make(http.Header, len(h))
0000000000000000000000000000000000000000;;		for k, vv := range h {
0000000000000000000000000000000000000000;;			vv2 := make([]string, len(vv))
0000000000000000000000000000000000000000;;			copy(vv2, vv)
0000000000000000000000000000000000000000;;			h2[k] = vv2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Life Of A Write is like this:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * Handler calls w.Write or w.WriteString ->
0000000000000000000000000000000000000000;;	// * -> rws.bw (*bufio.Writer) ->
0000000000000000000000000000000000000000;;	// * (Handler migth call Flush)
0000000000000000000000000000000000000000;;	// * -> chunkWriter{rws}
0000000000000000000000000000000000000000;;	// * -> responseWriterState.writeChunk(p []byte)
0000000000000000000000000000000000000000;;	// * -> responseWriterState.writeChunk (most of the magic; see comment there)
0000000000000000000000000000000000000000;;	func (w *responseWriter) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		return w.write(len(p), p, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *responseWriter) WriteString(s string) (n int, err error) {
0000000000000000000000000000000000000000;;		return w.write(len(s), nil, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// either dataB or dataS is non-zero.
0000000000000000000000000000000000000000;;	func (w *responseWriter) write(lenData int, dataB []byte, dataS string) (n int, err error) {
0000000000000000000000000000000000000000;;		rws := w.rws
0000000000000000000000000000000000000000;;		if rws == nil {
0000000000000000000000000000000000000000;;			panic("Write called after Handler finished")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !rws.wroteHeader {
0000000000000000000000000000000000000000;;			w.WriteHeader(200)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !bodyAllowedForStatus(rws.status) {
0000000000000000000000000000000000000000;;			return 0, http.ErrBodyNotAllowed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rws.wroteBytes += int64(len(dataB)) + int64(len(dataS)) // only one can be set
0000000000000000000000000000000000000000;;		if rws.sentContentLen != 0 && rws.wroteBytes > rws.sentContentLen {
0000000000000000000000000000000000000000;;			// TODO: send a RST_STREAM
0000000000000000000000000000000000000000;;			return 0, errors.New("http2: handler wrote more than declared Content-Length")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dataB != nil {
0000000000000000000000000000000000000000;;			return rws.bw.Write(dataB)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return rws.bw.WriteString(dataS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *responseWriter) handlerDone() {
0000000000000000000000000000000000000000;;		rws := w.rws
0000000000000000000000000000000000000000;;		rws.handlerDone = true
0000000000000000000000000000000000000000;;		w.Flush()
0000000000000000000000000000000000000000;;		w.rws = nil
0000000000000000000000000000000000000000;;		responseWriterStatePool.Put(rws)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Push errors.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrRecursivePush    = errors.New("http2: recursive push not allowed")
0000000000000000000000000000000000000000;;		ErrPushLimitReached = errors.New("http2: push would exceed peer's SETTINGS_MAX_CONCURRENT_STREAMS")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pushOptions is the internal version of http.PushOptions, which we
0000000000000000000000000000000000000000;;	// cannot include here because it's only defined in Go 1.8 and later.
0000000000000000000000000000000000000000;;	type pushOptions struct {
0000000000000000000000000000000000000000;;		Method string
0000000000000000000000000000000000000000;;		Header http.Header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *responseWriter) push(target string, opts pushOptions) error {
0000000000000000000000000000000000000000;;		st := w.rws.stream
0000000000000000000000000000000000000000;;		sc := st.sc
0000000000000000000000000000000000000000;;		sc.serveG.checkNotOn()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No recursive pushes: "PUSH_PROMISE frames MUST only be sent on a peer-initiated stream."
0000000000000000000000000000000000000000;;		// http://tools.ietf.org/html/rfc7540#section-6.6
0000000000000000000000000000000000000000;;		if st.isPushed() {
0000000000000000000000000000000000000000;;			return ErrRecursivePush
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default options.
0000000000000000000000000000000000000000;;		if opts.Method == "" {
0000000000000000000000000000000000000000;;			opts.Method = "GET"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.Header == nil {
0000000000000000000000000000000000000000;;			opts.Header = http.Header{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wantScheme := "http"
0000000000000000000000000000000000000000;;		if w.rws.req.TLS != nil {
0000000000000000000000000000000000000000;;			wantScheme = "https"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate the request.
0000000000000000000000000000000000000000;;		u, err := url.Parse(target)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u.Scheme == "" {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(target, "/") {
0000000000000000000000000000000000000000;;				return fmt.Errorf("target must be an absolute URL or an absolute path: %q", target)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			u.Scheme = wantScheme
0000000000000000000000000000000000000000;;			u.Host = w.rws.req.Host
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if u.Scheme != wantScheme {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot push URL with scheme %q from request with scheme %q", u.Scheme, wantScheme)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if u.Host == "" {
0000000000000000000000000000000000000000;;				return errors.New("URL must have a host")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k := range opts.Header {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(k, ":") {
0000000000000000000000000000000000000000;;				return fmt.Errorf("promised request headers cannot include pseudo header %q", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// These headers are meaningful only if the request has a body,
0000000000000000000000000000000000000000;;			// but PUSH_PROMISE requests cannot have a body.
0000000000000000000000000000000000000000;;			// http://tools.ietf.org/html/rfc7540#section-8.2
0000000000000000000000000000000000000000;;			// Also disallow Host, since the promised URL must be absolute.
0000000000000000000000000000000000000000;;			switch strings.ToLower(k) {
0000000000000000000000000000000000000000;;			case "content-length", "content-encoding", "trailer", "te", "expect", "host":
0000000000000000000000000000000000000000;;				return fmt.Errorf("promised request headers cannot include %q", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := checkValidHTTP2RequestHeaders(opts.Header); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The RFC effectively limits promised requests to GET and HEAD:
0000000000000000000000000000000000000000;;		// "Promised requests MUST be cacheable [GET, HEAD, or POST], and MUST be safe [GET or HEAD]"
0000000000000000000000000000000000000000;;		// http://tools.ietf.org/html/rfc7540#section-8.2
0000000000000000000000000000000000000000;;		if opts.Method != "GET" && opts.Method != "HEAD" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("method %q must be GET or HEAD", opts.Method)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msg := startPushRequest{
0000000000000000000000000000000000000000;;			parent: st,
0000000000000000000000000000000000000000;;			method: opts.Method,
0000000000000000000000000000000000000000;;			url:    u,
0000000000000000000000000000000000000000;;			header: cloneHeader(opts.Header),
0000000000000000000000000000000000000000;;			done:   errChanPool.Get().(chan error),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-sc.doneServing:
0000000000000000000000000000000000000000;;			return errClientDisconnected
0000000000000000000000000000000000000000;;		case <-st.cw:
0000000000000000000000000000000000000000;;			return errStreamClosed
0000000000000000000000000000000000000000;;		case sc.wantStartPushCh <- msg:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-sc.doneServing:
0000000000000000000000000000000000000000;;			return errClientDisconnected
0000000000000000000000000000000000000000;;		case <-st.cw:
0000000000000000000000000000000000000000;;			return errStreamClosed
0000000000000000000000000000000000000000;;		case err := <-msg.done:
0000000000000000000000000000000000000000;;			errChanPool.Put(msg.done)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type startPushRequest struct {
0000000000000000000000000000000000000000;;		parent *stream
0000000000000000000000000000000000000000;;		method string
0000000000000000000000000000000000000000;;		url    *url.URL
0000000000000000000000000000000000000000;;		header http.Header
0000000000000000000000000000000000000000;;		done   chan error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sc *serverConn) startPush(msg startPushRequest) {
0000000000000000000000000000000000000000;;		sc.serveG.check()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// http://tools.ietf.org/html/rfc7540#section-6.6.
0000000000000000000000000000000000000000;;		// PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that
0000000000000000000000000000000000000000;;		// is in either the "open" or "half-closed (remote)" state.
0000000000000000000000000000000000000000;;		if msg.parent.state != stateOpen && msg.parent.state != stateHalfClosedRemote {
0000000000000000000000000000000000000000;;			// responseWriter.Push checks that the stream is peer-initiaed.
0000000000000000000000000000000000000000;;			msg.done <- errStreamClosed
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// http://tools.ietf.org/html/rfc7540#section-6.6.
0000000000000000000000000000000000000000;;		if !sc.pushEnabled {
0000000000000000000000000000000000000000;;			msg.done <- http.ErrNotSupported
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PUSH_PROMISE frames must be sent in increasing order by stream ID, so
0000000000000000000000000000000000000000;;		// we allocate an ID for the promised stream lazily, when the PUSH_PROMISE
0000000000000000000000000000000000000000;;		// is written. Once the ID is allocated, we start the request handler.
0000000000000000000000000000000000000000;;		allocatePromisedID := func() (uint32, error) {
0000000000000000000000000000000000000000;;			sc.serveG.check()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check this again, just in case. Technically, we might have received
0000000000000000000000000000000000000000;;			// an updated SETTINGS by the time we got around to writing this frame.
0000000000000000000000000000000000000000;;			if !sc.pushEnabled {
0000000000000000000000000000000000000000;;				return 0, http.ErrNotSupported
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// http://tools.ietf.org/html/rfc7540#section-6.5.2.
0000000000000000000000000000000000000000;;			if sc.curPushedStreams+1 > sc.clientMaxStreams {
0000000000000000000000000000000000000000;;				return 0, ErrPushLimitReached
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// http://tools.ietf.org/html/rfc7540#section-5.1.1.
0000000000000000000000000000000000000000;;			// Streams initiated by the server MUST use even-numbered identifiers.
0000000000000000000000000000000000000000;;			// A server that is unable to establish a new stream identifier can send a GOAWAY
0000000000000000000000000000000000000000;;			// frame so that the client is forced to open a new connection for new streams.
0000000000000000000000000000000000000000;;			if sc.maxPushPromiseID+2 >= 1<<31 {
0000000000000000000000000000000000000000;;				sc.startGracefulShutdown()
0000000000000000000000000000000000000000;;				return 0, ErrPushLimitReached
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sc.maxPushPromiseID += 2
0000000000000000000000000000000000000000;;			promisedID := sc.maxPushPromiseID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// http://tools.ietf.org/html/rfc7540#section-8.2.
0000000000000000000000000000000000000000;;			// Strictly speaking, the new stream should start in "reserved (local)", then
0000000000000000000000000000000000000000;;			// transition to "half closed (remote)" after sending the initial HEADERS, but
0000000000000000000000000000000000000000;;			// we start in "half closed (remote)" for simplicity.
0000000000000000000000000000000000000000;;			// See further comments at the definition of stateHalfClosedRemote.
0000000000000000000000000000000000000000;;			promised := sc.newStream(promisedID, msg.parent.id, stateHalfClosedRemote)
0000000000000000000000000000000000000000;;			rw, req, err := sc.newWriterAndRequestNoBody(promised, requestParam{
0000000000000000000000000000000000000000;;				method:    msg.method,
0000000000000000000000000000000000000000;;				scheme:    msg.url.Scheme,
0000000000000000000000000000000000000000;;				authority: msg.url.Host,
0000000000000000000000000000000000000000;;				path:      msg.url.RequestURI(),
0000000000000000000000000000000000000000;;				header:    cloneHeader(msg.header), // clone since handler runs concurrently with writing the PUSH_PROMISE
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Should not happen, since we've already validated msg.url.
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("newWriterAndRequestNoBody(%+v): %v", msg.url, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			go sc.runHandler(rw, req, sc.handler.ServeHTTP)
0000000000000000000000000000000000000000;;			return promisedID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sc.writeFrame(FrameWriteRequest{
0000000000000000000000000000000000000000;;			write: &writePushPromise{
0000000000000000000000000000000000000000;;				streamID:           msg.parent.id,
0000000000000000000000000000000000000000;;				method:             msg.method,
0000000000000000000000000000000000000000;;				url:                msg.url,
0000000000000000000000000000000000000000;;				h:                  msg.header,
0000000000000000000000000000000000000000;;				allocatePromisedID: allocatePromisedID,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			stream: msg.parent,
0000000000000000000000000000000000000000;;			done:   msg.done,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// foreachHeaderElement splits v according to the "#rule" construction
0000000000000000000000000000000000000000;;	// in RFC 2616 section 2.1 and calls fn for each non-empty element.
0000000000000000000000000000000000000000;;	func foreachHeaderElement(v string, fn func(string)) {
0000000000000000000000000000000000000000;;		v = textproto.TrimString(v)
0000000000000000000000000000000000000000;;		if v == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(v, ",") {
0000000000000000000000000000000000000000;;			fn(v)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, f := range strings.Split(v, ",") {
0000000000000000000000000000000000000000;;			if f = textproto.TrimString(f); f != "" {
0000000000000000000000000000000000000000;;				fn(f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// From http://httpwg.org/specs/rfc7540.html#rfc.section.8.1.2.2
0000000000000000000000000000000000000000;;	var connHeaders = []string{
0000000000000000000000000000000000000000;;		"Connection",
0000000000000000000000000000000000000000;;		"Keep-Alive",
0000000000000000000000000000000000000000;;		"Proxy-Connection",
0000000000000000000000000000000000000000;;		"Transfer-Encoding",
0000000000000000000000000000000000000000;;		"Upgrade",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkValidHTTP2RequestHeaders checks whether h is a valid HTTP/2 request,
0000000000000000000000000000000000000000;;	// per RFC 7540 Section 8.1.2.2.
0000000000000000000000000000000000000000;;	// The returned error is reported to users.
0000000000000000000000000000000000000000;;	func checkValidHTTP2RequestHeaders(h http.Header) error {
0000000000000000000000000000000000000000;;		for _, k := range connHeaders {
0000000000000000000000000000000000000000;;			if _, ok := h[k]; ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("request header %q is not valid in HTTP/2", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		te := h["Te"]
0000000000000000000000000000000000000000;;		if len(te) > 0 && (len(te) > 1 || (te[0] != "trailers" && te[0] != "")) {
0000000000000000000000000000000000000000;;			return errors.New(`request header "TE" may only be "trailers" in HTTP/2`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func new400Handler(err error) http.HandlerFunc {
0000000000000000000000000000000000000000;;		return func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusBadRequest)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidTrailerHeader reports whether name is a valid header field name to appear
0000000000000000000000000000000000000000;;	// in trailers.
0000000000000000000000000000000000000000;;	// See: http://tools.ietf.org/html/rfc7230#section-4.1.2
0000000000000000000000000000000000000000;;	func ValidTrailerHeader(name string) bool {
0000000000000000000000000000000000000000;;		name = http.CanonicalHeaderKey(name)
0000000000000000000000000000000000000000;;		if strings.HasPrefix(name, "If-") || badTrailer[name] {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var badTrailer = map[string]bool{
0000000000000000000000000000000000000000;;		"Authorization":       true,
0000000000000000000000000000000000000000;;		"Cache-Control":       true,
0000000000000000000000000000000000000000;;		"Connection":          true,
0000000000000000000000000000000000000000;;		"Content-Encoding":    true,
0000000000000000000000000000000000000000;;		"Content-Length":      true,
0000000000000000000000000000000000000000;;		"Content-Range":       true,
0000000000000000000000000000000000000000;;		"Content-Type":        true,
0000000000000000000000000000000000000000;;		"Expect":              true,
0000000000000000000000000000000000000000;;		"Host":                true,
0000000000000000000000000000000000000000;;		"Keep-Alive":          true,
0000000000000000000000000000000000000000;;		"Max-Forwards":        true,
0000000000000000000000000000000000000000;;		"Pragma":              true,
0000000000000000000000000000000000000000;;		"Proxy-Authenticate":  true,
0000000000000000000000000000000000000000;;		"Proxy-Authorization": true,
0000000000000000000000000000000000000000;;		"Proxy-Connection":    true,
0000000000000000000000000000000000000000;;		"Range":               true,
0000000000000000000000000000000000000000;;		"Realm":               true,
0000000000000000000000000000000000000000;;		"Te":                  true,
0000000000000000000000000000000000000000;;		"Trailer":             true,
0000000000000000000000000000000000000000;;		"Transfer-Encoding":   true,
0000000000000000000000000000000000000000;;		"Www-Authenticate":    true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// h1ServerShutdownChan returns a channel that will be closed when the
0000000000000000000000000000000000000000;;	// provided *http.Server wants to shut down.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is a somewhat hacky way to get at http1 innards. It works
0000000000000000000000000000000000000000;;	// when the http2 code is bundled into the net/http package in the
0000000000000000000000000000000000000000;;	// standard library. The alternatives ended up making the cmd/go tool
0000000000000000000000000000000000000000;;	// depend on http Servers. This is the lightest option for now.
0000000000000000000000000000000000000000;;	// This is tested via the TestServeShutdown* tests in net/http.
0000000000000000000000000000000000000000;;	func h1ServerShutdownChan(hs *http.Server) <-chan struct{} {
0000000000000000000000000000000000000000;;		if fn := testh1ServerShutdownChan; fn != nil {
0000000000000000000000000000000000000000;;			return fn(hs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var x interface{} = hs
0000000000000000000000000000000000000000;;		type I interface {
0000000000000000000000000000000000000000;;			getDoneChan() <-chan struct{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hs, ok := x.(I); ok {
0000000000000000000000000000000000000000;;			return hs.getDoneChan()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// optional test hook for h1ServerShutdownChan.
0000000000000000000000000000000000000000;;	var testh1ServerShutdownChan func(hs *http.Server) <-chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// h1ServerKeepAlivesDisabled reports whether hs has its keep-alives
0000000000000000000000000000000000000000;;	// disabled. See comments on h1ServerShutdownChan above for why
0000000000000000000000000000000000000000;;	// the code is written this way.
0000000000000000000000000000000000000000;;	func h1ServerKeepAlivesDisabled(hs *http.Server) bool {
0000000000000000000000000000000000000000;;		var x interface{} = hs
0000000000000000000000000000000000000000;;		type I interface {
0000000000000000000000000000000000000000;;			doKeepAlives() bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hs, ok := x.(I); ok {
0000000000000000000000000000000000000000;;			return !hs.doKeepAlives()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
