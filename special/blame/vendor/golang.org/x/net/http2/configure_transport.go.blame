0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
9bf82937ec2c61ef2f0dca3af92c234867d12038;;	
0000000000000000000000000000000000000000;;	// +build go1.6
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func configureTransport(t1 *http.Transport) (*Transport, error) {
0000000000000000000000000000000000000000;;		connPool := new(clientConnPool)
0000000000000000000000000000000000000000;;		t2 := &Transport{
0000000000000000000000000000000000000000;;			ConnPool: noDialClientConnPool{connPool},
0000000000000000000000000000000000000000;;			t1:       t1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		connPool.t = t2
0000000000000000000000000000000000000000;;		if err := registerHTTPSProtocol(t1, noDialH2RoundTripper{t2}); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t1.TLSClientConfig == nil {
0000000000000000000000000000000000000000;;			t1.TLSClientConfig = new(tls.Config)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strSliceContains(t1.TLSClientConfig.NextProtos, "h2") {
0000000000000000000000000000000000000000;;			t1.TLSClientConfig.NextProtos = append([]string{"h2"}, t1.TLSClientConfig.NextProtos...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strSliceContains(t1.TLSClientConfig.NextProtos, "http/1.1") {
0000000000000000000000000000000000000000;;			t1.TLSClientConfig.NextProtos = append(t1.TLSClientConfig.NextProtos, "http/1.1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		upgradeFn := func(authority string, c *tls.Conn) http.RoundTripper {
0000000000000000000000000000000000000000;;			addr := authorityAddr("https", authority)
0000000000000000000000000000000000000000;;			if used, err := connPool.addConnIfNeeded(addr, t2, c); err != nil {
0000000000000000000000000000000000000000;;				go c.Close()
0000000000000000000000000000000000000000;;				return erringRoundTripper{err}
0000000000000000000000000000000000000000;;			} else if !used {
0000000000000000000000000000000000000000;;				// Turns out we don't need this c.
0000000000000000000000000000000000000000;;				// For example, two goroutines made requests to the same host
0000000000000000000000000000000000000000;;				// at the same time, both kicking off TCP dials. (since protocol
0000000000000000000000000000000000000000;;				// was unknown)
0000000000000000000000000000000000000000;;				go c.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return t2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m := t1.TLSNextProto; len(m) == 0 {
0000000000000000000000000000000000000000;;			t1.TLSNextProto = map[string]func(string, *tls.Conn) http.RoundTripper{
0000000000000000000000000000000000000000;;				"h2": upgradeFn,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m["h2"] = upgradeFn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t2, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// registerHTTPSProtocol calls Transport.RegisterProtocol but
0000000000000000000000000000000000000000;;	// convering panics into errors.
0000000000000000000000000000000000000000;;	func registerHTTPSProtocol(t *http.Transport, rt http.RoundTripper) (err error) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if e := recover(); e != nil {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("%v", e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		t.RegisterProtocol("https", rt)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// noDialH2RoundTripper is a RoundTripper which only tries to complete the request
0000000000000000000000000000000000000000;;	// if there's already has a cached connection to the host.
0000000000000000000000000000000000000000;;	type noDialH2RoundTripper struct{ t *Transport }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt noDialH2RoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		res, err := rt.t.RoundTrip(req)
0000000000000000000000000000000000000000;;		if err == ErrNoCachedConn {
0000000000000000000000000000000000000000;;			return nil, http.ErrSkipAltProtocol
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, err
0000000000000000000000000000000000000000;;	}
