0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/flow.go[Godeps/_workspace/src/github.com/bradfitz/http2/flow.go][vendor/golang.org/x/net/http2/flow.go];	
0000000000000000000000000000000000000000;;	// Flow control
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flow is the flow control window's size.
0000000000000000000000000000000000000000;;	type flow struct {
0000000000000000000000000000000000000000;;		// n is the number of DATA bytes we're allowed to send.
0000000000000000000000000000000000000000;;		// A flow is kept both on a conn and a per-stream.
0000000000000000000000000000000000000000;;		n int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// conn points to the shared connection-level flow that is
0000000000000000000000000000000000000000;;		// shared by all streams on that conn. It is nil for the flow
0000000000000000000000000000000000000000;;		// that's on the conn directly.
0000000000000000000000000000000000000000;;		conn *flow
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *flow) setConnFlow(cf *flow) { f.conn = cf }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *flow) available() int32 {
0000000000000000000000000000000000000000;;		n := f.n
0000000000000000000000000000000000000000;;		if f.conn != nil && f.conn.n < n {
0000000000000000000000000000000000000000;;			n = f.conn.n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *flow) take(n int32) {
0000000000000000000000000000000000000000;;		if n > f.available() {
0000000000000000000000000000000000000000;;			panic("internal error: took too much")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.n -= n
0000000000000000000000000000000000000000;;		if f.conn != nil {
0000000000000000000000000000000000000000;;			f.conn.n -= n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// add adds n bytes (positive or negative) to the flow control window.
0000000000000000000000000000000000000000;;	// It returns false if the sum would exceed 2^31-1.
0000000000000000000000000000000000000000;;	func (f *flow) add(n int32) bool {
0000000000000000000000000000000000000000;;		remain := (1<<31 - 1) - f.n
0000000000000000000000000000000000000000;;		if n > remain {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.n += n
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
