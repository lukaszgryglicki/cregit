0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/hpack/huffman.go[Godeps/_workspace/src/github.com/bradfitz/http2/hpack/huffman.go][vendor/golang.org/x/net/http2/hpack/huffman.go];	
0000000000000000000000000000000000000000;;	package hpack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bufPool = sync.Pool{
0000000000000000000000000000000000000000;;		New: func() interface{} { return new(bytes.Buffer) },
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HuffmanDecode decodes the string in v and writes the expanded
0000000000000000000000000000000000000000;;	// result to w, returning the number of bytes written to w and the
0000000000000000000000000000000000000000;;	// Write call's return value. At most one Write call is made.
0000000000000000000000000000000000000000;;	func HuffmanDecode(w io.Writer, v []byte) (int, error) {
0000000000000000000000000000000000000000;;		buf := bufPool.Get().(*bytes.Buffer)
0000000000000000000000000000000000000000;;		buf.Reset()
0000000000000000000000000000000000000000;;		defer bufPool.Put(buf)
0000000000000000000000000000000000000000;;		if err := huffmanDecode(buf, 0, v); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.Write(buf.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HuffmanDecodeToString decodes the string in v.
0000000000000000000000000000000000000000;;	func HuffmanDecodeToString(v []byte) (string, error) {
0000000000000000000000000000000000000000;;		buf := bufPool.Get().(*bytes.Buffer)
0000000000000000000000000000000000000000;;		buf.Reset()
0000000000000000000000000000000000000000;;		defer bufPool.Put(buf)
0000000000000000000000000000000000000000;;		if err := huffmanDecode(buf, 0, v); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrInvalidHuffman is returned for errors found decoding
0000000000000000000000000000000000000000;;	// Huffman-encoded strings.
0000000000000000000000000000000000000000;;	var ErrInvalidHuffman = errors.New("hpack: invalid Huffman-encoded data")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// huffmanDecode decodes v to buf.
0000000000000000000000000000000000000000;;	// If maxLen is greater than 0, attempts to write more to buf than
0000000000000000000000000000000000000000;;	// maxLen bytes will return ErrStringLength.
0000000000000000000000000000000000000000;;	func huffmanDecode(buf *bytes.Buffer, maxLen int, v []byte) error {
0000000000000000000000000000000000000000;;		n := rootHuffmanNode
0000000000000000000000000000000000000000;;		// cur is the bit buffer that has not been fed into n.
0000000000000000000000000000000000000000;;		// cbits is the number of low order bits in cur that are valid.
0000000000000000000000000000000000000000;;		// sbits is the number of bits of the symbol prefix being decoded.
0000000000000000000000000000000000000000;;		cur, cbits, sbits := uint(0), uint8(0), uint8(0)
0000000000000000000000000000000000000000;;		for _, b := range v {
0000000000000000000000000000000000000000;;			cur = cur<<8 | uint(b)
0000000000000000000000000000000000000000;;			cbits += 8
0000000000000000000000000000000000000000;;			sbits += 8
0000000000000000000000000000000000000000;;			for cbits >= 8 {
0000000000000000000000000000000000000000;;				idx := byte(cur >> (cbits - 8))
0000000000000000000000000000000000000000;;				n = n.children[idx]
0000000000000000000000000000000000000000;;				if n == nil {
0000000000000000000000000000000000000000;;					return ErrInvalidHuffman
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if n.children == nil {
0000000000000000000000000000000000000000;;					if maxLen != 0 && buf.Len() == maxLen {
0000000000000000000000000000000000000000;;						return ErrStringLength
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					buf.WriteByte(n.sym)
0000000000000000000000000000000000000000;;					cbits -= n.codeLen
0000000000000000000000000000000000000000;;					n = rootHuffmanNode
0000000000000000000000000000000000000000;;					sbits = cbits
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					cbits -= 8
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for cbits > 0 {
0000000000000000000000000000000000000000;;			n = n.children[byte(cur<<(8-cbits))]
0000000000000000000000000000000000000000;;			if n == nil {
0000000000000000000000000000000000000000;;				return ErrInvalidHuffman
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n.children != nil || n.codeLen > cbits {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if maxLen != 0 && buf.Len() == maxLen {
0000000000000000000000000000000000000000;;				return ErrStringLength
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.WriteByte(n.sym)
0000000000000000000000000000000000000000;;			cbits -= n.codeLen
0000000000000000000000000000000000000000;;			n = rootHuffmanNode
0000000000000000000000000000000000000000;;			sbits = cbits
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sbits > 7 {
0000000000000000000000000000000000000000;;			// Either there was an incomplete symbol, or overlong padding.
0000000000000000000000000000000000000000;;			// Both are decoding errors per RFC 7541 section 5.2.
0000000000000000000000000000000000000000;;			return ErrInvalidHuffman
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mask := uint(1<<cbits - 1); cur&mask != mask {
0000000000000000000000000000000000000000;;			// Trailing bits must be a prefix of EOS per RFC 7541 section 5.2.
0000000000000000000000000000000000000000;;			return ErrInvalidHuffman
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type node struct {
0000000000000000000000000000000000000000;;		// children is non-nil for internal nodes
0000000000000000000000000000000000000000;;		children []*node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The following are only valid if children is nil:
0000000000000000000000000000000000000000;;		codeLen uint8 // number of bits that led to the output of sym
0000000000000000000000000000000000000000;;		sym     byte  // output symbol
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newInternalNode() *node {
0000000000000000000000000000000000000000;;		return &node{children: make([]*node, 256)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var rootHuffmanNode = newInternalNode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if len(huffmanCodes) != 256 {
0000000000000000000000000000000000000000;;			panic("unexpected size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, code := range huffmanCodes {
0000000000000000000000000000000000000000;;			addDecoderNode(byte(i), code, huffmanCodeLen[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addDecoderNode(sym byte, code uint32, codeLen uint8) {
0000000000000000000000000000000000000000;;		cur := rootHuffmanNode
0000000000000000000000000000000000000000;;		for codeLen > 8 {
0000000000000000000000000000000000000000;;			codeLen -= 8
0000000000000000000000000000000000000000;;			i := uint8(code >> codeLen)
0000000000000000000000000000000000000000;;			if cur.children[i] == nil {
0000000000000000000000000000000000000000;;				cur.children[i] = newInternalNode()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cur = cur.children[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		shift := 8 - codeLen
0000000000000000000000000000000000000000;;		start, end := int(uint8(code<<shift)), int(1<<shift)
0000000000000000000000000000000000000000;;		for i := start; i < start+end; i++ {
0000000000000000000000000000000000000000;;			cur.children[i] = &node{sym: sym, codeLen: codeLen}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppendHuffmanString appends s, as encoded in Huffman codes, to dst
0000000000000000000000000000000000000000;;	// and returns the extended buffer.
0000000000000000000000000000000000000000;;	func AppendHuffmanString(dst []byte, s string) []byte {
0000000000000000000000000000000000000000;;		rembits := uint8(8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			if rembits == 8 {
0000000000000000000000000000000000000000;;				dst = append(dst, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst, rembits = appendByteToHuffmanCode(dst, rembits, s[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rembits < 8 {
0000000000000000000000000000000000000000;;			// special EOS symbol
0000000000000000000000000000000000000000;;			code := uint32(0x3fffffff)
0000000000000000000000000000000000000000;;			nbits := uint8(30)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t := uint8(code >> (nbits - rembits))
0000000000000000000000000000000000000000;;			dst[len(dst)-1] |= t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dst
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HuffmanEncodeLength returns the number of bytes required to encode
0000000000000000000000000000000000000000;;	// s in Huffman codes. The result is round up to byte boundary.
0000000000000000000000000000000000000000;;	func HuffmanEncodeLength(s string) uint64 {
0000000000000000000000000000000000000000;;		n := uint64(0)
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			n += uint64(huffmanCodeLen[s[i]])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (n + 7) / 8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendByteToHuffmanCode appends Huffman code for c to dst and
0000000000000000000000000000000000000000;;	// returns the extended buffer and the remaining bits in the last
0000000000000000000000000000000000000000;;	// element. The appending is not byte aligned and the remaining bits
0000000000000000000000000000000000000000;;	// in the last element of dst is given in rembits.
0000000000000000000000000000000000000000;;	func appendByteToHuffmanCode(dst []byte, rembits uint8, c byte) ([]byte, uint8) {
0000000000000000000000000000000000000000;;		code := huffmanCodes[c]
0000000000000000000000000000000000000000;;		nbits := huffmanCodeLen[c]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if rembits > nbits {
0000000000000000000000000000000000000000;;				t := uint8(code << (rembits - nbits))
0000000000000000000000000000000000000000;;				dst[len(dst)-1] |= t
0000000000000000000000000000000000000000;;				rembits -= nbits
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t := uint8(code >> (nbits - rembits))
0000000000000000000000000000000000000000;;			dst[len(dst)-1] |= t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nbits -= rembits
0000000000000000000000000000000000000000;;			rembits = 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if nbits == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dst = append(dst, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dst, rembits
0000000000000000000000000000000000000000;;	}
