0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/hpack/hpack.go[Godeps/_workspace/src/github.com/bradfitz/http2/hpack/hpack.go][vendor/golang.org/x/net/http2/hpack/hpack.go];	
0000000000000000000000000000000000000000;;	// Package hpack implements HPACK, a compression format for
0000000000000000000000000000000000000000;;	// efficiently representing HTTP header fields in the context of HTTP/2.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-09
0000000000000000000000000000000000000000;;	package hpack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A DecodingError is something the spec defines as a decoding error.
0000000000000000000000000000000000000000;;	type DecodingError struct {
0000000000000000000000000000000000000000;;		Err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (de DecodingError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("decoding error: %v", de.Err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An InvalidIndexError is returned when an encoder references a table
0000000000000000000000000000000000000000;;	// entry before the static table or after the end of the dynamic table.
0000000000000000000000000000000000000000;;	type InvalidIndexError int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e InvalidIndexError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("invalid indexed representation index %d", int(e))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A HeaderField is a name-value pair. Both the name and value are
0000000000000000000000000000000000000000;;	// treated as opaque sequences of octets.
0000000000000000000000000000000000000000;;	type HeaderField struct {
0000000000000000000000000000000000000000;;		Name, Value string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sensitive means that this header field should never be
0000000000000000000000000000000000000000;;		// indexed.
0000000000000000000000000000000000000000;;		Sensitive bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPseudo reports whether the header field is an http2 pseudo header.
0000000000000000000000000000000000000000;;	// That is, it reports whether it starts with a colon.
0000000000000000000000000000000000000000;;	// It is not otherwise guaranteed to be a valid pseudo header field,
0000000000000000000000000000000000000000;;	// though.
0000000000000000000000000000000000000000;;	func (hf HeaderField) IsPseudo() bool {
0000000000000000000000000000000000000000;;		return len(hf.Name) != 0 && hf.Name[0] == ':'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hf HeaderField) String() string {
0000000000000000000000000000000000000000;;		var suffix string
0000000000000000000000000000000000000000;;		if hf.Sensitive {
0000000000000000000000000000000000000000;;			suffix = " (sensitive)"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("header field %q = %q%s", hf.Name, hf.Value, suffix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size returns the size of an entry per RFC 7541 section 4.1.
0000000000000000000000000000000000000000;;	func (hf HeaderField) Size() uint32 {
0000000000000000000000000000000000000000;;		// http://http2.github.io/http2-spec/compression.html#rfc.section.4.1
0000000000000000000000000000000000000000;;		// "The size of the dynamic table is the sum of the size of
0000000000000000000000000000000000000000;;		// its entries.  The size of an entry is the sum of its name's
0000000000000000000000000000000000000000;;		// length in octets (as defined in Section 5.2), its value's
0000000000000000000000000000000000000000;;		// length in octets (see Section 5.2), plus 32.  The size of
0000000000000000000000000000000000000000;;		// an entry is calculated using the length of the name and
0000000000000000000000000000000000000000;;		// value without any Huffman encoding applied."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This can overflow if somebody makes a large HeaderField
0000000000000000000000000000000000000000;;		// Name and/or Value by hand, but we don't care, because that
0000000000000000000000000000000000000000;;		// won't happen on the wire because the encoding doesn't allow
0000000000000000000000000000000000000000;;		// it.
0000000000000000000000000000000000000000;;		return uint32(len(hf.Name) + len(hf.Value) + 32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Decoder is the decoding context for incremental processing of
0000000000000000000000000000000000000000;;	// header blocks.
0000000000000000000000000000000000000000;;	type Decoder struct {
0000000000000000000000000000000000000000;;		dynTab dynamicTable
0000000000000000000000000000000000000000;;		emit   func(f HeaderField)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		emitEnabled bool // whether calls to emit are enabled
0000000000000000000000000000000000000000;;		maxStrLen   int  // 0 means unlimited
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// buf is the unparsed buffer. It's only written to
0000000000000000000000000000000000000000;;		// saveBuf if it was truncated in the middle of a header
0000000000000000000000000000000000000000;;		// block. Because it's usually not owned, we can only
0000000000000000000000000000000000000000;;		// process it under Write.
0000000000000000000000000000000000000000;;		buf []byte // not owned; only valid during Write
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// saveBuf is previous data passed to Write which we weren't able
0000000000000000000000000000000000000000;;		// to fully parse before. Unlike buf, we own this data.
0000000000000000000000000000000000000000;;		saveBuf bytes.Buffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoder returns a new decoder with the provided maximum dynamic
0000000000000000000000000000000000000000;;	// table size. The emitFunc will be called for each valid field
0000000000000000000000000000000000000000;;	// parsed, in the same goroutine as calls to Write, before Write returns.
0000000000000000000000000000000000000000;;	func NewDecoder(maxDynamicTableSize uint32, emitFunc func(f HeaderField)) *Decoder {
0000000000000000000000000000000000000000;;		d := &Decoder{
0000000000000000000000000000000000000000;;			emit:        emitFunc,
0000000000000000000000000000000000000000;;			emitEnabled: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.dynTab.allowedMaxSize = maxDynamicTableSize
0000000000000000000000000000000000000000;;		d.dynTab.setMaxSize(maxDynamicTableSize)
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrStringLength is returned by Decoder.Write when the max string length
0000000000000000000000000000000000000000;;	// (as configured by Decoder.SetMaxStringLength) would be violated.
0000000000000000000000000000000000000000;;	var ErrStringLength = errors.New("hpack: string too long")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMaxStringLength sets the maximum size of a HeaderField name or
0000000000000000000000000000000000000000;;	// value string. If a string exceeds this length (even after any
0000000000000000000000000000000000000000;;	// decompression), Write will return ErrStringLength.
0000000000000000000000000000000000000000;;	// A value of 0 means unlimited and is the default from NewDecoder.
0000000000000000000000000000000000000000;;	func (d *Decoder) SetMaxStringLength(n int) {
0000000000000000000000000000000000000000;;		d.maxStrLen = n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetEmitFunc changes the callback used when new header fields
0000000000000000000000000000000000000000;;	// are decoded.
0000000000000000000000000000000000000000;;	// It must be non-nil. It does not affect EmitEnabled.
0000000000000000000000000000000000000000;;	func (d *Decoder) SetEmitFunc(emitFunc func(f HeaderField)) {
0000000000000000000000000000000000000000;;		d.emit = emitFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetEmitEnabled controls whether the emitFunc provided to NewDecoder
0000000000000000000000000000000000000000;;	// should be called. The default is true.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This facility exists to let servers enforce MAX_HEADER_LIST_SIZE
0000000000000000000000000000000000000000;;	// while still decoding and keeping in-sync with decoder state, but
0000000000000000000000000000000000000000;;	// without doing unnecessary decompression or generating unnecessary
0000000000000000000000000000000000000000;;	// garbage for header fields past the limit.
0000000000000000000000000000000000000000;;	func (d *Decoder) SetEmitEnabled(v bool) { d.emitEnabled = v }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EmitEnabled reports whether calls to the emitFunc provided to NewDecoder
0000000000000000000000000000000000000000;;	// are currently enabled. The default is true.
0000000000000000000000000000000000000000;;	func (d *Decoder) EmitEnabled() bool { return d.emitEnabled }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: add method *Decoder.Reset(maxSize, emitFunc) to let callers re-use Decoders and their
0000000000000000000000000000000000000000;;	// underlying buffers for garbage reasons.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) SetMaxDynamicTableSize(v uint32) {
0000000000000000000000000000000000000000;;		d.dynTab.setMaxSize(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetAllowedMaxDynamicTableSize sets the upper bound that the encoded
0000000000000000000000000000000000000000;;	// stream (via dynamic table size updates) may set the maximum size
0000000000000000000000000000000000000000;;	// to.
0000000000000000000000000000000000000000;;	func (d *Decoder) SetAllowedMaxDynamicTableSize(v uint32) {
0000000000000000000000000000000000000000;;		d.dynTab.allowedMaxSize = v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dynamicTable struct {
0000000000000000000000000000000000000000;;		// ents is the FIFO described at
0000000000000000000000000000000000000000;;		// http://http2.github.io/http2-spec/compression.html#rfc.section.2.3.2
0000000000000000000000000000000000000000;;		// The newest (low index) is append at the end, and items are
0000000000000000000000000000000000000000;;		// evicted from the front.
0000000000000000000000000000000000000000;;		ents           []HeaderField
0000000000000000000000000000000000000000;;		size           uint32
0000000000000000000000000000000000000000;;		maxSize        uint32 // current maxSize
0000000000000000000000000000000000000000;;		allowedMaxSize uint32 // maxSize may go up to this, inclusive
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dt *dynamicTable) setMaxSize(v uint32) {
0000000000000000000000000000000000000000;;		dt.maxSize = v
0000000000000000000000000000000000000000;;		dt.evict()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: change dynamicTable to be a struct with a slice and a size int field,
0000000000000000000000000000000000000000;;	// per http://http2.github.io/http2-spec/compression.html#rfc.section.4.1:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Then make add increment the size. maybe the max size should move from Decoder to
0000000000000000000000000000000000000000;;	// dynamicTable and add should return an ok bool if there was enough space.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Later we'll need a remove operation on dynamicTable.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dt *dynamicTable) add(f HeaderField) {
0000000000000000000000000000000000000000;;		dt.ents = append(dt.ents, f)
0000000000000000000000000000000000000000;;		dt.size += f.Size()
0000000000000000000000000000000000000000;;		dt.evict()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If we're too big, evict old stuff (front of the slice)
0000000000000000000000000000000000000000;;	func (dt *dynamicTable) evict() {
0000000000000000000000000000000000000000;;		base := dt.ents // keep base pointer of slice
0000000000000000000000000000000000000000;;		for dt.size > dt.maxSize {
0000000000000000000000000000000000000000;;			dt.size -= dt.ents[0].Size()
0000000000000000000000000000000000000000;;			dt.ents = dt.ents[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Shift slice contents down if we evicted things.
0000000000000000000000000000000000000000;;		if len(dt.ents) != len(base) {
0000000000000000000000000000000000000000;;			copy(base, dt.ents)
0000000000000000000000000000000000000000;;			dt.ents = base[:len(dt.ents)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// constantTimeStringCompare compares string a and b in a constant
0000000000000000000000000000000000000000;;	// time manner.
0000000000000000000000000000000000000000;;	func constantTimeStringCompare(a, b string) bool {
0000000000000000000000000000000000000000;;		if len(a) != len(b) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := byte(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(a); i++ {
0000000000000000000000000000000000000000;;			c |= a[i] ^ b[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Search searches f in the table. The return value i is 0 if there is
0000000000000000000000000000000000000000;;	// no name match. If there is name match or name/value match, i is the
0000000000000000000000000000000000000000;;	// index of that entry (1-based). If both name and value match,
0000000000000000000000000000000000000000;;	// nameValueMatch becomes true.
0000000000000000000000000000000000000000;;	func (dt *dynamicTable) search(f HeaderField) (i uint64, nameValueMatch bool) {
0000000000000000000000000000000000000000;;		l := len(dt.ents)
0000000000000000000000000000000000000000;;		for j := l - 1; j >= 0; j-- {
0000000000000000000000000000000000000000;;			ent := dt.ents[j]
0000000000000000000000000000000000000000;;			if !constantTimeStringCompare(ent.Name, f.Name) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				i = uint64(l - j)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f.Sensitive {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !constantTimeStringCompare(ent.Value, f.Value) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = uint64(l - j)
0000000000000000000000000000000000000000;;			nameValueMatch = true
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) maxTableIndex() int {
0000000000000000000000000000000000000000;;		return len(d.dynTab.ents) + len(staticTable)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) at(i uint64) (hf HeaderField, ok bool) {
0000000000000000000000000000000000000000;;		if i < 1 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i > uint64(d.maxTableIndex()) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i <= uint64(len(staticTable)) {
0000000000000000000000000000000000000000;;			return staticTable[i-1], true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dents := d.dynTab.ents
0000000000000000000000000000000000000000;;		return dents[len(dents)-(int(i)-len(staticTable))], true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode decodes an entire block.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: remove this method and make it incremental later? This is
0000000000000000000000000000000000000000;;	// easier for debugging now.
0000000000000000000000000000000000000000;;	func (d *Decoder) DecodeFull(p []byte) ([]HeaderField, error) {
0000000000000000000000000000000000000000;;		var hf []HeaderField
0000000000000000000000000000000000000000;;		saveFunc := d.emit
0000000000000000000000000000000000000000;;		defer func() { d.emit = saveFunc }()
0000000000000000000000000000000000000000;;		d.emit = func(f HeaderField) { hf = append(hf, f) }
0000000000000000000000000000000000000000;;		if _, err := d.Write(p); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := d.Close(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) Close() error {
0000000000000000000000000000000000000000;;		if d.saveBuf.Len() > 0 {
0000000000000000000000000000000000000000;;			d.saveBuf.Reset()
0000000000000000000000000000000000000000;;			return DecodingError{errors.New("truncated headers")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if len(p) == 0 {
0000000000000000000000000000000000000000;;			// Prevent state machine CPU attacks (making us redo
0000000000000000000000000000000000000000;;			// work up to the point of finding out we don't have
0000000000000000000000000000000000000000;;			// enough data)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Only copy the data if we have to. Optimistically assume
0000000000000000000000000000000000000000;;		// that p will contain a complete header block.
0000000000000000000000000000000000000000;;		if d.saveBuf.Len() == 0 {
0000000000000000000000000000000000000000;;			d.buf = p
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.saveBuf.Write(p)
0000000000000000000000000000000000000000;;			d.buf = d.saveBuf.Bytes()
0000000000000000000000000000000000000000;;			d.saveBuf.Reset()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(d.buf) > 0 {
0000000000000000000000000000000000000000;;			err = d.parseHeaderFieldRepr()
0000000000000000000000000000000000000000;;			if err == errNeedMore {
0000000000000000000000000000000000000000;;				// Extra paranoia, making sure saveBuf won't
0000000000000000000000000000000000000000;;				// get too large.  All the varint and string
0000000000000000000000000000000000000000;;				// reading code earlier should already catch
0000000000000000000000000000000000000000;;				// overlong things and return ErrStringLength,
0000000000000000000000000000000000000000;;				// but keep this as a last resort.
0000000000000000000000000000000000000000;;				const varIntOverhead = 8 // conservative
0000000000000000000000000000000000000000;;				if d.maxStrLen != 0 && int64(len(d.buf)) > 2*(int64(d.maxStrLen)+varIntOverhead) {
0000000000000000000000000000000000000000;;					return 0, ErrStringLength
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.saveBuf.Write(d.buf)
0000000000000000000000000000000000000000;;				return len(p), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(p), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errNeedMore is an internal sentinel error value that means the
0000000000000000000000000000000000000000;;	// buffer is truncated and we need to read more data before we can
0000000000000000000000000000000000000000;;	// continue parsing.
0000000000000000000000000000000000000000;;	var errNeedMore = errors.New("need more data")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type indexType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		indexedTrue indexType = iota
0000000000000000000000000000000000000000;;		indexedFalse
0000000000000000000000000000000000000000;;		indexedNever
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v indexType) indexed() bool   { return v == indexedTrue }
0000000000000000000000000000000000000000;;	func (v indexType) sensitive() bool { return v == indexedNever }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns errNeedMore if there isn't enough data available.
0000000000000000000000000000000000000000;;	// any other error is fatal.
0000000000000000000000000000000000000000;;	// consumes d.buf iff it returns nil.
0000000000000000000000000000000000000000;;	// precondition: must be called with len(d.buf) > 0
0000000000000000000000000000000000000000;;	func (d *Decoder) parseHeaderFieldRepr() error {
0000000000000000000000000000000000000000;;		b := d.buf[0]
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case b&128 != 0:
0000000000000000000000000000000000000000;;			// Indexed representation.
0000000000000000000000000000000000000000;;			// High bit set?
0000000000000000000000000000000000000000;;			// http://http2.github.io/http2-spec/compression.html#rfc.section.6.1
0000000000000000000000000000000000000000;;			return d.parseFieldIndexed()
0000000000000000000000000000000000000000;;		case b&192 == 64:
0000000000000000000000000000000000000000;;			// 6.2.1 Literal Header Field with Incremental Indexing
0000000000000000000000000000000000000000;;			// 0b10xxxxxx: top two bits are 10
0000000000000000000000000000000000000000;;			// http://http2.github.io/http2-spec/compression.html#rfc.section.6.2.1
0000000000000000000000000000000000000000;;			return d.parseFieldLiteral(6, indexedTrue)
0000000000000000000000000000000000000000;;		case b&240 == 0:
0000000000000000000000000000000000000000;;			// 6.2.2 Literal Header Field without Indexing
0000000000000000000000000000000000000000;;			// 0b0000xxxx: top four bits are 0000
0000000000000000000000000000000000000000;;			// http://http2.github.io/http2-spec/compression.html#rfc.section.6.2.2
0000000000000000000000000000000000000000;;			return d.parseFieldLiteral(4, indexedFalse)
0000000000000000000000000000000000000000;;		case b&240 == 16:
0000000000000000000000000000000000000000;;			// 6.2.3 Literal Header Field never Indexed
0000000000000000000000000000000000000000;;			// 0b0001xxxx: top four bits are 0001
0000000000000000000000000000000000000000;;			// http://http2.github.io/http2-spec/compression.html#rfc.section.6.2.3
0000000000000000000000000000000000000000;;			return d.parseFieldLiteral(4, indexedNever)
0000000000000000000000000000000000000000;;		case b&224 == 32:
0000000000000000000000000000000000000000;;			// 6.3 Dynamic Table Size Update
0000000000000000000000000000000000000000;;			// Top three bits are '001'.
0000000000000000000000000000000000000000;;			// http://http2.github.io/http2-spec/compression.html#rfc.section.6.3
0000000000000000000000000000000000000000;;			return d.parseDynamicTableSizeUpdate()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return DecodingError{errors.New("invalid encoding")}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// (same invariants and behavior as parseHeaderFieldRepr)
0000000000000000000000000000000000000000;;	func (d *Decoder) parseFieldIndexed() error {
0000000000000000000000000000000000000000;;		buf := d.buf
0000000000000000000000000000000000000000;;		idx, buf, err := readVarInt(7, buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hf, ok := d.at(idx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return DecodingError{InvalidIndexError(idx)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.buf = buf
0000000000000000000000000000000000000000;;		return d.callEmit(HeaderField{Name: hf.Name, Value: hf.Value})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// (same invariants and behavior as parseHeaderFieldRepr)
0000000000000000000000000000000000000000;;	func (d *Decoder) parseFieldLiteral(n uint8, it indexType) error {
0000000000000000000000000000000000000000;;		buf := d.buf
0000000000000000000000000000000000000000;;		nameIdx, buf, err := readVarInt(n, buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hf HeaderField
0000000000000000000000000000000000000000;;		wantStr := d.emitEnabled || it.indexed()
0000000000000000000000000000000000000000;;		if nameIdx > 0 {
0000000000000000000000000000000000000000;;			ihf, ok := d.at(nameIdx)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return DecodingError{InvalidIndexError(nameIdx)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hf.Name = ihf.Name
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			hf.Name, buf, err = d.readString(buf, wantStr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hf.Value, buf, err = d.readString(buf, wantStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.buf = buf
0000000000000000000000000000000000000000;;		if it.indexed() {
0000000000000000000000000000000000000000;;			d.dynTab.add(hf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hf.Sensitive = it.sensitive()
0000000000000000000000000000000000000000;;		return d.callEmit(hf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) callEmit(hf HeaderField) error {
0000000000000000000000000000000000000000;;		if d.maxStrLen != 0 {
0000000000000000000000000000000000000000;;			if len(hf.Name) > d.maxStrLen || len(hf.Value) > d.maxStrLen {
0000000000000000000000000000000000000000;;				return ErrStringLength
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.emitEnabled {
0000000000000000000000000000000000000000;;			d.emit(hf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// (same invariants and behavior as parseHeaderFieldRepr)
0000000000000000000000000000000000000000;;	func (d *Decoder) parseDynamicTableSizeUpdate() error {
0000000000000000000000000000000000000000;;		buf := d.buf
0000000000000000000000000000000000000000;;		size, buf, err := readVarInt(5, buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if size > uint64(d.dynTab.allowedMaxSize) {
0000000000000000000000000000000000000000;;			return DecodingError{errors.New("dynamic table size update too large")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.dynTab.setMaxSize(uint32(size))
0000000000000000000000000000000000000000;;		d.buf = buf
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errVarintOverflow = DecodingError{errors.New("varint integer overflow")}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readVarInt reads an unsigned variable length integer off the
0000000000000000000000000000000000000000;;	// beginning of p. n is the parameter as described in
0000000000000000000000000000000000000000;;	// http://http2.github.io/http2-spec/compression.html#rfc.section.5.1.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// n must always be between 1 and 8.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The returned remain buffer is either a smaller suffix of p, or err != nil.
0000000000000000000000000000000000000000;;	// The error is errNeedMore if p doesn't contain a complete integer.
0000000000000000000000000000000000000000;;	func readVarInt(n byte, p []byte) (i uint64, remain []byte, err error) {
0000000000000000000000000000000000000000;;		if n < 1 || n > 8 {
0000000000000000000000000000000000000000;;			panic("bad n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p) == 0 {
0000000000000000000000000000000000000000;;			return 0, p, errNeedMore
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i = uint64(p[0])
0000000000000000000000000000000000000000;;		if n < 8 {
0000000000000000000000000000000000000000;;			i &= (1 << uint64(n)) - 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i < (1<<uint64(n))-1 {
0000000000000000000000000000000000000000;;			return i, p[1:], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		origP := p
0000000000000000000000000000000000000000;;		p = p[1:]
0000000000000000000000000000000000000000;;		var m uint64
0000000000000000000000000000000000000000;;		for len(p) > 0 {
0000000000000000000000000000000000000000;;			b := p[0]
0000000000000000000000000000000000000000;;			p = p[1:]
0000000000000000000000000000000000000000;;			i += uint64(b&127) << m
0000000000000000000000000000000000000000;;			if b&128 == 0 {
0000000000000000000000000000000000000000;;				return i, p, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m += 7
0000000000000000000000000000000000000000;;			if m >= 63 { // TODO: proper overflow check. making this up.
0000000000000000000000000000000000000000;;				return 0, origP, errVarintOverflow
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, origP, errNeedMore
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readString decodes an hpack string from p.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// wantStr is whether s will be used. If false, decompression and
0000000000000000000000000000000000000000;;	// []byte->string garbage are skipped if s will be ignored
0000000000000000000000000000000000000000;;	// anyway. This does mean that huffman decoding errors for non-indexed
0000000000000000000000000000000000000000;;	// strings past the MAX_HEADER_LIST_SIZE are ignored, but the server
0000000000000000000000000000000000000000;;	// is returning an error anyway, and because they're not indexed, the error
0000000000000000000000000000000000000000;;	// won't affect the decoding state.
0000000000000000000000000000000000000000;;	func (d *Decoder) readString(p []byte, wantStr bool) (s string, remain []byte, err error) {
0000000000000000000000000000000000000000;;		if len(p) == 0 {
0000000000000000000000000000000000000000;;			return "", p, errNeedMore
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		isHuff := p[0]&128 != 0
0000000000000000000000000000000000000000;;		strLen, p, err := readVarInt(7, p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", p, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.maxStrLen != 0 && strLen > uint64(d.maxStrLen) {
0000000000000000000000000000000000000000;;			return "", nil, ErrStringLength
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if uint64(len(p)) < strLen {
0000000000000000000000000000000000000000;;			return "", p, errNeedMore
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !isHuff {
0000000000000000000000000000000000000000;;			if wantStr {
0000000000000000000000000000000000000000;;				s = string(p[:strLen])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s, p[strLen:], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if wantStr {
0000000000000000000000000000000000000000;;			buf := bufPool.Get().(*bytes.Buffer)
0000000000000000000000000000000000000000;;			buf.Reset() // don't trust others
0000000000000000000000000000000000000000;;			defer bufPool.Put(buf)
0000000000000000000000000000000000000000;;			if err := huffmanDecode(buf, d.maxStrLen, p[:strLen]); err != nil {
0000000000000000000000000000000000000000;;				buf.Reset()
0000000000000000000000000000000000000000;;				return "", nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = buf.String()
0000000000000000000000000000000000000000;;			buf.Reset() // be nice to GC
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, p[strLen:], nil
0000000000000000000000000000000000000000;;	}
