0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/hpack/encode.go[Godeps/_workspace/src/github.com/bradfitz/http2/hpack/encode.go][vendor/golang.org/x/net/http2/hpack/encode.go];	
0000000000000000000000000000000000000000;;	package hpack
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		uint32Max              = ^uint32(0)
0000000000000000000000000000000000000000;;		initialHeaderTableSize = 4096
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Encoder struct {
0000000000000000000000000000000000000000;;		dynTab dynamicTable
0000000000000000000000000000000000000000;;		// minSize is the minimum table size set by
0000000000000000000000000000000000000000;;		// SetMaxDynamicTableSize after the previous Header Table Size
0000000000000000000000000000000000000000;;		// Update.
0000000000000000000000000000000000000000;;		minSize uint32
0000000000000000000000000000000000000000;;		// maxSizeLimit is the maximum table size this encoder
0000000000000000000000000000000000000000;;		// supports. This will protect the encoder from too large
0000000000000000000000000000000000000000;;		// size.
0000000000000000000000000000000000000000;;		maxSizeLimit uint32
0000000000000000000000000000000000000000;;		// tableSizeUpdate indicates whether "Header Table Size
0000000000000000000000000000000000000000;;		// Update" is required.
0000000000000000000000000000000000000000;;		tableSizeUpdate bool
0000000000000000000000000000000000000000;;		w               io.Writer
0000000000000000000000000000000000000000;;		buf             []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncoder returns a new Encoder which performs HPACK encoding. An
0000000000000000000000000000000000000000;;	// encoded data is written to w.
0000000000000000000000000000000000000000;;	func NewEncoder(w io.Writer) *Encoder {
0000000000000000000000000000000000000000;;		e := &Encoder{
0000000000000000000000000000000000000000;;			minSize:         uint32Max,
0000000000000000000000000000000000000000;;			maxSizeLimit:    initialHeaderTableSize,
0000000000000000000000000000000000000000;;			tableSizeUpdate: false,
0000000000000000000000000000000000000000;;			w:               w,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.dynTab.setMaxSize(initialHeaderTableSize)
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteField encodes f into a single Write to e's underlying Writer.
0000000000000000000000000000000000000000;;	// This function may also produce bytes for "Header Table Size Update"
0000000000000000000000000000000000000000;;	// if necessary.  If produced, it is done before encoding f.
0000000000000000000000000000000000000000;;	func (e *Encoder) WriteField(f HeaderField) error {
0000000000000000000000000000000000000000;;		e.buf = e.buf[:0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.tableSizeUpdate {
0000000000000000000000000000000000000000;;			e.tableSizeUpdate = false
0000000000000000000000000000000000000000;;			if e.minSize < e.dynTab.maxSize {
0000000000000000000000000000000000000000;;				e.buf = appendTableSize(e.buf, e.minSize)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.minSize = uint32Max
0000000000000000000000000000000000000000;;			e.buf = appendTableSize(e.buf, e.dynTab.maxSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		idx, nameValueMatch := e.searchTable(f)
0000000000000000000000000000000000000000;;		if nameValueMatch {
0000000000000000000000000000000000000000;;			e.buf = appendIndexed(e.buf, idx)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			indexing := e.shouldIndex(f)
0000000000000000000000000000000000000000;;			if indexing {
0000000000000000000000000000000000000000;;				e.dynTab.add(f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if idx == 0 {
0000000000000000000000000000000000000000;;				e.buf = appendNewName(e.buf, f, indexing)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.buf = appendIndexedName(e.buf, f, idx, indexing)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := e.w.Write(e.buf)
0000000000000000000000000000000000000000;;		if err == nil && n != len(e.buf) {
0000000000000000000000000000000000000000;;			err = io.ErrShortWrite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// searchTable searches f in both stable and dynamic header tables.
0000000000000000000000000000000000000000;;	// The static header table is searched first. Only when there is no
0000000000000000000000000000000000000000;;	// exact match for both name and value, the dynamic header table is
0000000000000000000000000000000000000000;;	// then searched. If there is no match, i is 0. If both name and value
0000000000000000000000000000000000000000;;	// match, i is the matched index and nameValueMatch becomes true. If
0000000000000000000000000000000000000000;;	// only name matches, i points to that index and nameValueMatch
0000000000000000000000000000000000000000;;	// becomes false.
0000000000000000000000000000000000000000;;	func (e *Encoder) searchTable(f HeaderField) (i uint64, nameValueMatch bool) {
0000000000000000000000000000000000000000;;		for idx, hf := range staticTable {
0000000000000000000000000000000000000000;;			if !constantTimeStringCompare(hf.Name, f.Name) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				i = uint64(idx + 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f.Sensitive {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !constantTimeStringCompare(hf.Value, f.Value) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = uint64(idx + 1)
0000000000000000000000000000000000000000;;			nameValueMatch = true
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j, nameValueMatch := e.dynTab.search(f)
0000000000000000000000000000000000000000;;		if nameValueMatch || (i == 0 && j != 0) {
0000000000000000000000000000000000000000;;			i = j + uint64(len(staticTable))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMaxDynamicTableSize changes the dynamic header table size to v.
0000000000000000000000000000000000000000;;	// The actual size is bounded by the value passed to
0000000000000000000000000000000000000000;;	// SetMaxDynamicTableSizeLimit.
0000000000000000000000000000000000000000;;	func (e *Encoder) SetMaxDynamicTableSize(v uint32) {
0000000000000000000000000000000000000000;;		if v > e.maxSizeLimit {
0000000000000000000000000000000000000000;;			v = e.maxSizeLimit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v < e.minSize {
0000000000000000000000000000000000000000;;			e.minSize = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.tableSizeUpdate = true
0000000000000000000000000000000000000000;;		e.dynTab.setMaxSize(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMaxDynamicTableSizeLimit changes the maximum value that can be
0000000000000000000000000000000000000000;;	// specified in SetMaxDynamicTableSize to v. By default, it is set to
0000000000000000000000000000000000000000;;	// 4096, which is the same size of the default dynamic header table
0000000000000000000000000000000000000000;;	// size described in HPACK specification. If the current maximum
0000000000000000000000000000000000000000;;	// dynamic header table size is strictly greater than v, "Header Table
0000000000000000000000000000000000000000;;	// Size Update" will be done in the next WriteField call and the
0000000000000000000000000000000000000000;;	// maximum dynamic header table size is truncated to v.
0000000000000000000000000000000000000000;;	func (e *Encoder) SetMaxDynamicTableSizeLimit(v uint32) {
0000000000000000000000000000000000000000;;		e.maxSizeLimit = v
0000000000000000000000000000000000000000;;		if e.dynTab.maxSize > v {
0000000000000000000000000000000000000000;;			e.tableSizeUpdate = true
0000000000000000000000000000000000000000;;			e.dynTab.setMaxSize(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldIndex reports whether f should be indexed.
0000000000000000000000000000000000000000;;	func (e *Encoder) shouldIndex(f HeaderField) bool {
0000000000000000000000000000000000000000;;		return !f.Sensitive && f.Size() <= e.dynTab.maxSize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendIndexed appends index i, as encoded in "Indexed Header Field"
0000000000000000000000000000000000000000;;	// representation, to dst and returns the extended buffer.
0000000000000000000000000000000000000000;;	func appendIndexed(dst []byte, i uint64) []byte {
0000000000000000000000000000000000000000;;		first := len(dst)
0000000000000000000000000000000000000000;;		dst = appendVarInt(dst, 7, i)
0000000000000000000000000000000000000000;;		dst[first] |= 0x80
0000000000000000000000000000000000000000;;		return dst
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendNewName appends f, as encoded in one of "Literal Header field
0000000000000000000000000000000000000000;;	// - New Name" representation variants, to dst and returns the
0000000000000000000000000000000000000000;;	// extended buffer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If f.Sensitive is true, "Never Indexed" representation is used. If
0000000000000000000000000000000000000000;;	// f.Sensitive is false and indexing is true, "Inremental Indexing"
0000000000000000000000000000000000000000;;	// representation is used.
0000000000000000000000000000000000000000;;	func appendNewName(dst []byte, f HeaderField, indexing bool) []byte {
0000000000000000000000000000000000000000;;		dst = append(dst, encodeTypeByte(indexing, f.Sensitive))
0000000000000000000000000000000000000000;;		dst = appendHpackString(dst, f.Name)
0000000000000000000000000000000000000000;;		return appendHpackString(dst, f.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendIndexedName appends f and index i referring indexed name
0000000000000000000000000000000000000000;;	// entry, as encoded in one of "Literal Header field - Indexed Name"
0000000000000000000000000000000000000000;;	// representation variants, to dst and returns the extended buffer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If f.Sensitive is true, "Never Indexed" representation is used. If
0000000000000000000000000000000000000000;;	// f.Sensitive is false and indexing is true, "Incremental Indexing"
0000000000000000000000000000000000000000;;	// representation is used.
0000000000000000000000000000000000000000;;	func appendIndexedName(dst []byte, f HeaderField, i uint64, indexing bool) []byte {
0000000000000000000000000000000000000000;;		first := len(dst)
0000000000000000000000000000000000000000;;		var n byte
0000000000000000000000000000000000000000;;		if indexing {
0000000000000000000000000000000000000000;;			n = 6
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			n = 4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dst = appendVarInt(dst, n, i)
0000000000000000000000000000000000000000;;		dst[first] |= encodeTypeByte(indexing, f.Sensitive)
0000000000000000000000000000000000000000;;		return appendHpackString(dst, f.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendTableSize appends v, as encoded in "Header Table Size Update"
0000000000000000000000000000000000000000;;	// representation, to dst and returns the extended buffer.
0000000000000000000000000000000000000000;;	func appendTableSize(dst []byte, v uint32) []byte {
0000000000000000000000000000000000000000;;		first := len(dst)
0000000000000000000000000000000000000000;;		dst = appendVarInt(dst, 5, uint64(v))
0000000000000000000000000000000000000000;;		dst[first] |= 0x20
0000000000000000000000000000000000000000;;		return dst
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendVarInt appends i, as encoded in variable integer form using n
0000000000000000000000000000000000000000;;	// bit prefix, to dst and returns the extended buffer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See
0000000000000000000000000000000000000000;;	// http://http2.github.io/http2-spec/compression.html#integer.representation
0000000000000000000000000000000000000000;;	func appendVarInt(dst []byte, n byte, i uint64) []byte {
0000000000000000000000000000000000000000;;		k := uint64((1 << n) - 1)
0000000000000000000000000000000000000000;;		if i < k {
0000000000000000000000000000000000000000;;			return append(dst, byte(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dst = append(dst, byte(k))
0000000000000000000000000000000000000000;;		i -= k
0000000000000000000000000000000000000000;;		for ; i >= 128; i >>= 7 {
0000000000000000000000000000000000000000;;			dst = append(dst, byte(0x80|(i&0x7f)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(dst, byte(i))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendHpackString appends s, as encoded in "String Literal"
0000000000000000000000000000000000000000;;	// representation, to dst and returns the the extended buffer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// s will be encoded in Huffman codes only when it produces strictly
0000000000000000000000000000000000000000;;	// shorter byte string.
0000000000000000000000000000000000000000;;	func appendHpackString(dst []byte, s string) []byte {
0000000000000000000000000000000000000000;;		huffmanLength := HuffmanEncodeLength(s)
0000000000000000000000000000000000000000;;		if huffmanLength < uint64(len(s)) {
0000000000000000000000000000000000000000;;			first := len(dst)
0000000000000000000000000000000000000000;;			dst = appendVarInt(dst, 7, huffmanLength)
0000000000000000000000000000000000000000;;			dst = AppendHuffmanString(dst, s)
0000000000000000000000000000000000000000;;			dst[first] |= 0x80
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dst = appendVarInt(dst, 7, uint64(len(s)))
0000000000000000000000000000000000000000;;			dst = append(dst, s...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dst
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encodeTypeByte returns type byte. If sensitive is true, type byte
0000000000000000000000000000000000000000;;	// for "Never Indexed" representation is returned. If sensitive is
0000000000000000000000000000000000000000;;	// false and indexing is true, type byte for "Incremental Indexing"
0000000000000000000000000000000000000000;;	// representation is returned. Otherwise, type byte for "Without
0000000000000000000000000000000000000000;;	// Indexing" is returned.
0000000000000000000000000000000000000000;;	func encodeTypeByte(indexing, sensitive bool) byte {
0000000000000000000000000000000000000000;;		if sensitive {
0000000000000000000000000000000000000000;;			return 0x10
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if indexing {
0000000000000000000000000000000000000000;;			return 0x40
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
