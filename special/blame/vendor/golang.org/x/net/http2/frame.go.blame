0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/frame.go[Godeps/_workspace/src/github.com/bradfitz/http2/frame.go][vendor/golang.org/x/net/http2/frame.go];	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2/hpack"
0000000000000000000000000000000000000000;;		"golang.org/x/net/lex/httplex"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const frameHeaderLen = 9
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var padZeros = make([]byte, 255) // zeros for padding
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A FrameType is a registered frame type as defined in
0000000000000000000000000000000000000000;;	// http://http2.github.io/http2-spec/#rfc.section.11.2
0000000000000000000000000000000000000000;;	type FrameType uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FrameData         FrameType = 0x0
0000000000000000000000000000000000000000;;		FrameHeaders      FrameType = 0x1
0000000000000000000000000000000000000000;;		FramePriority     FrameType = 0x2
0000000000000000000000000000000000000000;;		FrameRSTStream    FrameType = 0x3
0000000000000000000000000000000000000000;;		FrameSettings     FrameType = 0x4
0000000000000000000000000000000000000000;;		FramePushPromise  FrameType = 0x5
0000000000000000000000000000000000000000;;		FramePing         FrameType = 0x6
0000000000000000000000000000000000000000;;		FrameGoAway       FrameType = 0x7
0000000000000000000000000000000000000000;;		FrameWindowUpdate FrameType = 0x8
0000000000000000000000000000000000000000;;		FrameContinuation FrameType = 0x9
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var frameName = map[FrameType]string{
0000000000000000000000000000000000000000;;		FrameData:         "DATA",
0000000000000000000000000000000000000000;;		FrameHeaders:      "HEADERS",
0000000000000000000000000000000000000000;;		FramePriority:     "PRIORITY",
0000000000000000000000000000000000000000;;		FrameRSTStream:    "RST_STREAM",
0000000000000000000000000000000000000000;;		FrameSettings:     "SETTINGS",
0000000000000000000000000000000000000000;;		FramePushPromise:  "PUSH_PROMISE",
0000000000000000000000000000000000000000;;		FramePing:         "PING",
0000000000000000000000000000000000000000;;		FrameGoAway:       "GOAWAY",
0000000000000000000000000000000000000000;;		FrameWindowUpdate: "WINDOW_UPDATE",
0000000000000000000000000000000000000000;;		FrameContinuation: "CONTINUATION",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t FrameType) String() string {
0000000000000000000000000000000000000000;;		if s, ok := frameName[t]; ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("UNKNOWN_FRAME_TYPE_%d", uint8(t))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flags is a bitmask of HTTP/2 flags.
0000000000000000000000000000000000000000;;	// The meaning of flags varies depending on the frame type.
0000000000000000000000000000000000000000;;	type Flags uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has reports whether f contains all (0 or more) flags in v.
0000000000000000000000000000000000000000;;	func (f Flags) Has(v Flags) bool {
0000000000000000000000000000000000000000;;		return (f & v) == v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Frame-specific FrameHeader flag bits.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Data Frame
0000000000000000000000000000000000000000;;		FlagDataEndStream Flags = 0x1
0000000000000000000000000000000000000000;;		FlagDataPadded    Flags = 0x8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Headers Frame
0000000000000000000000000000000000000000;;		FlagHeadersEndStream  Flags = 0x1
0000000000000000000000000000000000000000;;		FlagHeadersEndHeaders Flags = 0x4
0000000000000000000000000000000000000000;;		FlagHeadersPadded     Flags = 0x8
0000000000000000000000000000000000000000;;		FlagHeadersPriority   Flags = 0x20
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Settings Frame
0000000000000000000000000000000000000000;;		FlagSettingsAck Flags = 0x1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ping Frame
0000000000000000000000000000000000000000;;		FlagPingAck Flags = 0x1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Continuation Frame
0000000000000000000000000000000000000000;;		FlagContinuationEndHeaders Flags = 0x4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		FlagPushPromiseEndHeaders Flags = 0x4
0000000000000000000000000000000000000000;;		FlagPushPromisePadded     Flags = 0x8
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var flagName = map[FrameType]map[Flags]string{
0000000000000000000000000000000000000000;;		FrameData: {
0000000000000000000000000000000000000000;;			FlagDataEndStream: "END_STREAM",
0000000000000000000000000000000000000000;;			FlagDataPadded:    "PADDED",
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		FrameHeaders: {
0000000000000000000000000000000000000000;;			FlagHeadersEndStream:  "END_STREAM",
0000000000000000000000000000000000000000;;			FlagHeadersEndHeaders: "END_HEADERS",
0000000000000000000000000000000000000000;;			FlagHeadersPadded:     "PADDED",
0000000000000000000000000000000000000000;;			FlagHeadersPriority:   "PRIORITY",
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		FrameSettings: {
0000000000000000000000000000000000000000;;			FlagSettingsAck: "ACK",
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		FramePing: {
0000000000000000000000000000000000000000;;			FlagPingAck: "ACK",
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		FrameContinuation: {
0000000000000000000000000000000000000000;;			FlagContinuationEndHeaders: "END_HEADERS",
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		FramePushPromise: {
0000000000000000000000000000000000000000;;			FlagPushPromiseEndHeaders: "END_HEADERS",
0000000000000000000000000000000000000000;;			FlagPushPromisePadded:     "PADDED",
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// a frameParser parses a frame given its FrameHeader and payload
0000000000000000000000000000000000000000;;	// bytes. The length of payload will always equal fh.Length (which
0000000000000000000000000000000000000000;;	// might be 0).
0000000000000000000000000000000000000000;;	type frameParser func(fh FrameHeader, payload []byte) (Frame, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var frameParsers = map[FrameType]frameParser{
0000000000000000000000000000000000000000;;		FrameData:         parseDataFrame,
0000000000000000000000000000000000000000;;		FrameHeaders:      parseHeadersFrame,
0000000000000000000000000000000000000000;;		FramePriority:     parsePriorityFrame,
0000000000000000000000000000000000000000;;		FrameRSTStream:    parseRSTStreamFrame,
0000000000000000000000000000000000000000;;		FrameSettings:     parseSettingsFrame,
0000000000000000000000000000000000000000;;		FramePushPromise:  parsePushPromise,
0000000000000000000000000000000000000000;;		FramePing:         parsePingFrame,
0000000000000000000000000000000000000000;;		FrameGoAway:       parseGoAwayFrame,
0000000000000000000000000000000000000000;;		FrameWindowUpdate: parseWindowUpdateFrame,
0000000000000000000000000000000000000000;;		FrameContinuation: parseContinuationFrame,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func typeFrameParser(t FrameType) frameParser {
0000000000000000000000000000000000000000;;		if f := frameParsers[t]; f != nil {
0000000000000000000000000000000000000000;;			return f
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parseUnknownFrame
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A FrameHeader is the 9 byte header of all HTTP/2 frames.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See http://http2.github.io/http2-spec/#FrameHeader
0000000000000000000000000000000000000000;;	type FrameHeader struct {
0000000000000000000000000000000000000000;;		valid bool // caller can access []byte fields in the Frame
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Type is the 1 byte frame type. There are ten standard frame
0000000000000000000000000000000000000000;;		// types, but extension frame types may be written by WriteRawFrame
0000000000000000000000000000000000000000;;		// and will be returned by ReadFrame (as UnknownFrame).
0000000000000000000000000000000000000000;;		Type FrameType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Flags are the 1 byte of 8 potential bit flags per frame.
0000000000000000000000000000000000000000;;		// They are specific to the frame type.
0000000000000000000000000000000000000000;;		Flags Flags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Length is the length of the frame, not including the 9 byte header.
0000000000000000000000000000000000000000;;		// The maximum size is one byte less than 16MB (uint24), but only
0000000000000000000000000000000000000000;;		// frames up to 16KB are allowed without peer agreement.
0000000000000000000000000000000000000000;;		Length uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StreamID is which stream this frame is for. Certain frames
0000000000000000000000000000000000000000;;		// are not stream-specific, in which case this field is 0.
0000000000000000000000000000000000000000;;		StreamID uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Header returns h. It exists so FrameHeaders can be embedded in other
0000000000000000000000000000000000000000;;	// specific frame types and implement the Frame interface.
0000000000000000000000000000000000000000;;	func (h FrameHeader) Header() FrameHeader { return h }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h FrameHeader) String() string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		buf.WriteString("[FrameHeader ")
0000000000000000000000000000000000000000;;		h.writeDebug(&buf)
0000000000000000000000000000000000000000;;		buf.WriteByte(']')
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h FrameHeader) writeDebug(buf *bytes.Buffer) {
0000000000000000000000000000000000000000;;		buf.WriteString(h.Type.String())
0000000000000000000000000000000000000000;;		if h.Flags != 0 {
0000000000000000000000000000000000000000;;			buf.WriteString(" flags=")
0000000000000000000000000000000000000000;;			set := 0
0000000000000000000000000000000000000000;;			for i := uint8(0); i < 8; i++ {
0000000000000000000000000000000000000000;;				if h.Flags&(1<<i) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				set++
0000000000000000000000000000000000000000;;				if set > 1 {
0000000000000000000000000000000000000000;;					buf.WriteByte('|')
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				name := flagName[h.Type][Flags(1<<i)]
0000000000000000000000000000000000000000;;				if name != "" {
0000000000000000000000000000000000000000;;					buf.WriteString(name)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Fprintf(buf, "0x%x", 1<<i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.StreamID != 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(buf, " stream=%d", h.StreamID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, " len=%d", h.Length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *FrameHeader) checkValid() {
0000000000000000000000000000000000000000;;		if !h.valid {
0000000000000000000000000000000000000000;;			panic("Frame accessor called on non-owned Frame")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *FrameHeader) invalidate() { h.valid = false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// frame header bytes.
0000000000000000000000000000000000000000;;	// Used only by ReadFrameHeader.
0000000000000000000000000000000000000000;;	var fhBytes = sync.Pool{
0000000000000000000000000000000000000000;;		New: func() interface{} {
0000000000000000000000000000000000000000;;			buf := make([]byte, frameHeaderLen)
0000000000000000000000000000000000000000;;			return &buf
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadFrameHeader reads 9 bytes from r and returns a FrameHeader.
0000000000000000000000000000000000000000;;	// Most users should use Framer.ReadFrame instead.
0000000000000000000000000000000000000000;;	func ReadFrameHeader(r io.Reader) (FrameHeader, error) {
0000000000000000000000000000000000000000;;		bufp := fhBytes.Get().(*[]byte)
0000000000000000000000000000000000000000;;		defer fhBytes.Put(bufp)
0000000000000000000000000000000000000000;;		return readFrameHeader(*bufp, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readFrameHeader(buf []byte, r io.Reader) (FrameHeader, error) {
0000000000000000000000000000000000000000;;		_, err := io.ReadFull(r, buf[:frameHeaderLen])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return FrameHeader{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return FrameHeader{
0000000000000000000000000000000000000000;;			Length:   (uint32(buf[0])<<16 | uint32(buf[1])<<8 | uint32(buf[2])),
0000000000000000000000000000000000000000;;			Type:     FrameType(buf[3]),
0000000000000000000000000000000000000000;;			Flags:    Flags(buf[4]),
0000000000000000000000000000000000000000;;			StreamID: binary.BigEndian.Uint32(buf[5:]) & (1<<31 - 1),
0000000000000000000000000000000000000000;;			valid:    true,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Frame is the base interface implemented by all frame types.
0000000000000000000000000000000000000000;;	// Callers will generally type-assert the specific frame type:
0000000000000000000000000000000000000000;;	// *HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Frames are only valid until the next call to Framer.ReadFrame.
0000000000000000000000000000000000000000;;	type Frame interface {
0000000000000000000000000000000000000000;;		Header() FrameHeader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// invalidate is called by Framer.ReadFrame to make this
0000000000000000000000000000000000000000;;		// frame's buffers as being invalid, since the subsequent
0000000000000000000000000000000000000000;;		// frame will reuse them.
0000000000000000000000000000000000000000;;		invalidate()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Framer reads and writes Frames.
0000000000000000000000000000000000000000;;	type Framer struct {
0000000000000000000000000000000000000000;;		r         io.Reader
0000000000000000000000000000000000000000;;		lastFrame Frame
0000000000000000000000000000000000000000;;		errDetail error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lastHeaderStream is non-zero if the last frame was an
0000000000000000000000000000000000000000;;		// unfinished HEADERS/CONTINUATION.
0000000000000000000000000000000000000000;;		lastHeaderStream uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxReadSize uint32
0000000000000000000000000000000000000000;;		headerBuf   [frameHeaderLen]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: let getReadBuf be configurable, and use a less memory-pinning
0000000000000000000000000000000000000000;;		// allocator in server.go to minimize memory pinned for many idle conns.
0000000000000000000000000000000000000000;;		// Will probably also need to make frame invalidation have a hook too.
0000000000000000000000000000000000000000;;		getReadBuf func(size uint32) []byte
0000000000000000000000000000000000000000;;		readBuf    []byte // cache for default getReadBuf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxWriteSize uint32 // zero means unlimited; TODO: implement
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w    io.Writer
0000000000000000000000000000000000000000;;		wbuf []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AllowIllegalWrites permits the Framer's Write methods to
0000000000000000000000000000000000000000;;		// write frames that do not conform to the HTTP/2 spec. This
0000000000000000000000000000000000000000;;		// permits using the Framer to test other HTTP/2
0000000000000000000000000000000000000000;;		// implementations' conformance to the spec.
0000000000000000000000000000000000000000;;		// If false, the Write methods will prefer to return an error
0000000000000000000000000000000000000000;;		// rather than comply.
0000000000000000000000000000000000000000;;		AllowIllegalWrites bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AllowIllegalReads permits the Framer's ReadFrame method
0000000000000000000000000000000000000000;;		// to return non-compliant frames or frame orders.
0000000000000000000000000000000000000000;;		// This is for testing and permits using the Framer to test
0000000000000000000000000000000000000000;;		// other HTTP/2 implementations' conformance to the spec.
0000000000000000000000000000000000000000;;		// It is not compatible with ReadMetaHeaders.
0000000000000000000000000000000000000000;;		AllowIllegalReads bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadMetaHeaders if non-nil causes ReadFrame to merge
0000000000000000000000000000000000000000;;		// HEADERS and CONTINUATION frames together and return
0000000000000000000000000000000000000000;;		// MetaHeadersFrame instead.
0000000000000000000000000000000000000000;;		ReadMetaHeaders *hpack.Decoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.
0000000000000000000000000000000000000000;;		// It's used only if ReadMetaHeaders is set; 0 means a sane default
0000000000000000000000000000000000000000;;		// (currently 16MB)
0000000000000000000000000000000000000000;;		// If the limit is hit, MetaHeadersFrame.Truncated is set true.
0000000000000000000000000000000000000000;;		MaxHeaderListSize uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: track which type of frame & with which flags was sent
0000000000000000000000000000000000000000;;		// last.  Then return an error (unless AllowIllegalWrites) if
0000000000000000000000000000000000000000;;		// we're in the middle of a header block and a
0000000000000000000000000000000000000000;;		// non-Continuation or Continuation on a different stream is
0000000000000000000000000000000000000000;;		// attempted to be written.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logReads, logWrites bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		debugFramer       *Framer // only use for logging written writes
0000000000000000000000000000000000000000;;		debugFramerBuf    *bytes.Buffer
0000000000000000000000000000000000000000;;		debugReadLoggerf  func(string, ...interface{})
0000000000000000000000000000000000000000;;		debugWriteLoggerf func(string, ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fr *Framer) maxHeaderListSize() uint32 {
0000000000000000000000000000000000000000;;		if fr.MaxHeaderListSize == 0 {
0000000000000000000000000000000000000000;;			return 16 << 20 // sane default, per docs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fr.MaxHeaderListSize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) startWrite(ftype FrameType, flags Flags, streamID uint32) {
0000000000000000000000000000000000000000;;		// Write the FrameHeader.
0000000000000000000000000000000000000000;;		f.wbuf = append(f.wbuf[:0],
0000000000000000000000000000000000000000;;			0, // 3 bytes of length, filled in in endWrite
0000000000000000000000000000000000000000;;			0,
0000000000000000000000000000000000000000;;			0,
0000000000000000000000000000000000000000;;			byte(ftype),
0000000000000000000000000000000000000000;;			byte(flags),
0000000000000000000000000000000000000000;;			byte(streamID>>24),
0000000000000000000000000000000000000000;;			byte(streamID>>16),
0000000000000000000000000000000000000000;;			byte(streamID>>8),
0000000000000000000000000000000000000000;;			byte(streamID))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) endWrite() error {
0000000000000000000000000000000000000000;;		// Now that we know the final size, fill in the FrameHeader in
0000000000000000000000000000000000000000;;		// the space previously reserved for it. Abuse append.
0000000000000000000000000000000000000000;;		length := len(f.wbuf) - frameHeaderLen
0000000000000000000000000000000000000000;;		if length >= (1 << 24) {
0000000000000000000000000000000000000000;;			return ErrFrameTooLarge
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_ = append(f.wbuf[:0],
0000000000000000000000000000000000000000;;			byte(length>>16),
0000000000000000000000000000000000000000;;			byte(length>>8),
0000000000000000000000000000000000000000;;			byte(length))
0000000000000000000000000000000000000000;;		if f.logWrites {
0000000000000000000000000000000000000000;;			f.logWrite()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := f.w.Write(f.wbuf)
0000000000000000000000000000000000000000;;		if err == nil && n != len(f.wbuf) {
0000000000000000000000000000000000000000;;			err = io.ErrShortWrite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) logWrite() {
0000000000000000000000000000000000000000;;		if f.debugFramer == nil {
0000000000000000000000000000000000000000;;			f.debugFramerBuf = new(bytes.Buffer)
0000000000000000000000000000000000000000;;			f.debugFramer = NewFramer(nil, f.debugFramerBuf)
0000000000000000000000000000000000000000;;			f.debugFramer.logReads = false // we log it ourselves, saying "wrote" below
0000000000000000000000000000000000000000;;			// Let us read anything, even if we accidentally wrote it
0000000000000000000000000000000000000000;;			// in the wrong order:
0000000000000000000000000000000000000000;;			f.debugFramer.AllowIllegalReads = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.debugFramerBuf.Write(f.wbuf)
0000000000000000000000000000000000000000;;		fr, err := f.debugFramer.ReadFrame()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			f.debugWriteLoggerf("http2: Framer %p: failed to decode just-written frame", f)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.debugWriteLoggerf("http2: Framer %p: wrote %v", f, summarizeFrame(fr))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) writeByte(v byte)     { f.wbuf = append(f.wbuf, v) }
0000000000000000000000000000000000000000;;	func (f *Framer) writeBytes(v []byte)  { f.wbuf = append(f.wbuf, v...) }
0000000000000000000000000000000000000000;;	func (f *Framer) writeUint16(v uint16) { f.wbuf = append(f.wbuf, byte(v>>8), byte(v)) }
0000000000000000000000000000000000000000;;	func (f *Framer) writeUint32(v uint32) {
0000000000000000000000000000000000000000;;		f.wbuf = append(f.wbuf, byte(v>>24), byte(v>>16), byte(v>>8), byte(v))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		minMaxFrameSize = 1 << 14
0000000000000000000000000000000000000000;;		maxFrameSize    = 1<<24 - 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFramer returns a Framer that writes frames to w and reads them from r.
0000000000000000000000000000000000000000;;	func NewFramer(w io.Writer, r io.Reader) *Framer {
0000000000000000000000000000000000000000;;		fr := &Framer{
0000000000000000000000000000000000000000;;			w:                 w,
0000000000000000000000000000000000000000;;			r:                 r,
0000000000000000000000000000000000000000;;			logReads:          logFrameReads,
0000000000000000000000000000000000000000;;			logWrites:         logFrameWrites,
0000000000000000000000000000000000000000;;			debugReadLoggerf:  log.Printf,
0000000000000000000000000000000000000000;;			debugWriteLoggerf: log.Printf,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fr.getReadBuf = func(size uint32) []byte {
0000000000000000000000000000000000000000;;			if cap(fr.readBuf) >= int(size) {
0000000000000000000000000000000000000000;;				return fr.readBuf[:size]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fr.readBuf = make([]byte, size)
0000000000000000000000000000000000000000;;			return fr.readBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fr.SetMaxReadFrameSize(maxFrameSize)
0000000000000000000000000000000000000000;;		return fr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMaxReadFrameSize sets the maximum size of a frame
0000000000000000000000000000000000000000;;	// that will be read by a subsequent call to ReadFrame.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility to advertise this
0000000000000000000000000000000000000000;;	// limit with a SETTINGS frame.
0000000000000000000000000000000000000000;;	func (fr *Framer) SetMaxReadFrameSize(v uint32) {
0000000000000000000000000000000000000000;;		if v > maxFrameSize {
0000000000000000000000000000000000000000;;			v = maxFrameSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fr.maxReadSize = v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorDetail returns a more detailed error of the last error
0000000000000000000000000000000000000000;;	// returned by Framer.ReadFrame. For instance, if ReadFrame
0000000000000000000000000000000000000000;;	// returns a StreamError with code PROTOCOL_ERROR, ErrorDetail
0000000000000000000000000000000000000000;;	// will say exactly what was invalid. ErrorDetail is not guaranteed
0000000000000000000000000000000000000000;;	// to return a non-nil value and like the rest of the http2 package,
0000000000000000000000000000000000000000;;	// its return value is not protected by an API compatibility promise.
0000000000000000000000000000000000000000;;	// ErrorDetail is reset after the next call to ReadFrame.
0000000000000000000000000000000000000000;;	func (fr *Framer) ErrorDetail() error {
0000000000000000000000000000000000000000;;		return fr.errDetail
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrFrameTooLarge is returned from Framer.ReadFrame when the peer
0000000000000000000000000000000000000000;;	// sends a frame that is larger than declared with SetMaxReadFrameSize.
0000000000000000000000000000000000000000;;	var ErrFrameTooLarge = errors.New("http2: frame too large")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// terminalReadFrameError reports whether err is an unrecoverable
0000000000000000000000000000000000000000;;	// error from ReadFrame and no other frames should be read.
0000000000000000000000000000000000000000;;	func terminalReadFrameError(err error) bool {
0000000000000000000000000000000000000000;;		if _, ok := err.(StreamError); ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadFrame reads a single frame. The returned Frame is only valid
0000000000000000000000000000000000000000;;	// until the next call to ReadFrame.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the frame is larger than previously set with SetMaxReadFrameSize, the
0000000000000000000000000000000000000000;;	// returned error is ErrFrameTooLarge. Other errors may be of type
0000000000000000000000000000000000000000;;	// ConnectionError, StreamError, or anything else from the underlying
0000000000000000000000000000000000000000;;	// reader.
0000000000000000000000000000000000000000;;	func (fr *Framer) ReadFrame() (Frame, error) {
0000000000000000000000000000000000000000;;		fr.errDetail = nil
0000000000000000000000000000000000000000;;		if fr.lastFrame != nil {
0000000000000000000000000000000000000000;;			fr.lastFrame.invalidate()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fh, err := readFrameHeader(fr.headerBuf[:], fr.r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fh.Length > fr.maxReadSize {
0000000000000000000000000000000000000000;;			return nil, ErrFrameTooLarge
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		payload := fr.getReadBuf(fh.Length)
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(fr.r, payload); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := typeFrameParser(fh.Type)(fh, payload)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if ce, ok := err.(connError); ok {
0000000000000000000000000000000000000000;;				return nil, fr.connError(ce.Code, ce.Reason)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := fr.checkFrameOrder(f); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fr.logReads {
0000000000000000000000000000000000000000;;			fr.debugReadLoggerf("http2: Framer %p: read %v", fr, summarizeFrame(f))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fh.Type == FrameHeaders && fr.ReadMetaHeaders != nil {
0000000000000000000000000000000000000000;;			return fr.readMetaFrame(f.(*HeadersFrame))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// connError returns ConnectionError(code) but first
0000000000000000000000000000000000000000;;	// stashes away a public reason to the caller can optionally relay it
0000000000000000000000000000000000000000;;	// to the peer before hanging up on them. This might help others debug
0000000000000000000000000000000000000000;;	// their implementations.
0000000000000000000000000000000000000000;;	func (fr *Framer) connError(code ErrCode, reason string) error {
0000000000000000000000000000000000000000;;		fr.errDetail = errors.New(reason)
0000000000000000000000000000000000000000;;		return ConnectionError(code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkFrameOrder reports an error if f is an invalid frame to return
0000000000000000000000000000000000000000;;	// next from ReadFrame. Mostly it checks whether HEADERS and
0000000000000000000000000000000000000000;;	// CONTINUATION frames are contiguous.
0000000000000000000000000000000000000000;;	func (fr *Framer) checkFrameOrder(f Frame) error {
0000000000000000000000000000000000000000;;		last := fr.lastFrame
0000000000000000000000000000000000000000;;		fr.lastFrame = f
0000000000000000000000000000000000000000;;		if fr.AllowIllegalReads {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fh := f.Header()
0000000000000000000000000000000000000000;;		if fr.lastHeaderStream != 0 {
0000000000000000000000000000000000000000;;			if fh.Type != FrameContinuation {
0000000000000000000000000000000000000000;;				return fr.connError(ErrCodeProtocol,
0000000000000000000000000000000000000000;;					fmt.Sprintf("got %s for stream %d; expected CONTINUATION following %s for stream %d",
0000000000000000000000000000000000000000;;						fh.Type, fh.StreamID,
0000000000000000000000000000000000000000;;						last.Header().Type, fr.lastHeaderStream))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fh.StreamID != fr.lastHeaderStream {
0000000000000000000000000000000000000000;;				return fr.connError(ErrCodeProtocol,
0000000000000000000000000000000000000000;;					fmt.Sprintf("got CONTINUATION for stream %d; expected stream %d",
0000000000000000000000000000000000000000;;						fh.StreamID, fr.lastHeaderStream))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if fh.Type == FrameContinuation {
0000000000000000000000000000000000000000;;			return fr.connError(ErrCodeProtocol, fmt.Sprintf("unexpected CONTINUATION for stream %d", fh.StreamID))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch fh.Type {
0000000000000000000000000000000000000000;;		case FrameHeaders, FrameContinuation:
0000000000000000000000000000000000000000;;			if fh.Flags.Has(FlagHeadersEndHeaders) {
0000000000000000000000000000000000000000;;				fr.lastHeaderStream = 0
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fr.lastHeaderStream = fh.StreamID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A DataFrame conveys arbitrary, variable-length sequences of octets
0000000000000000000000000000000000000000;;	// associated with a stream.
0000000000000000000000000000000000000000;;	// See http://http2.github.io/http2-spec/#rfc.section.6.1
0000000000000000000000000000000000000000;;	type DataFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *DataFrame) StreamEnded() bool {
0000000000000000000000000000000000000000;;		return f.FrameHeader.Flags.Has(FlagDataEndStream)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Data returns the frame's data octets, not including any padding
0000000000000000000000000000000000000000;;	// size byte or padding suffix bytes.
0000000000000000000000000000000000000000;;	// The caller must not retain the returned memory past the next
0000000000000000000000000000000000000000;;	// call to ReadFrame.
0000000000000000000000000000000000000000;;	func (f *DataFrame) Data() []byte {
0000000000000000000000000000000000000000;;		f.checkValid()
0000000000000000000000000000000000000000;;		return f.data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseDataFrame(fh FrameHeader, payload []byte) (Frame, error) {
0000000000000000000000000000000000000000;;		if fh.StreamID == 0 {
0000000000000000000000000000000000000000;;			// DATA frames MUST be associated with a stream. If a
0000000000000000000000000000000000000000;;			// DATA frame is received whose stream identifier
0000000000000000000000000000000000000000;;			// field is 0x0, the recipient MUST respond with a
0000000000000000000000000000000000000000;;			// connection error (Section 5.4.1) of type
0000000000000000000000000000000000000000;;			// PROTOCOL_ERROR.
0000000000000000000000000000000000000000;;			return nil, connError{ErrCodeProtocol, "DATA frame with stream ID 0"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f := &DataFrame{
0000000000000000000000000000000000000000;;			FrameHeader: fh,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var padSize byte
0000000000000000000000000000000000000000;;		if fh.Flags.Has(FlagDataPadded) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			payload, padSize, err = readByte(payload)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if int(padSize) > len(payload) {
0000000000000000000000000000000000000000;;			// If the length of the padding is greater than the
0000000000000000000000000000000000000000;;			// length of the frame payload, the recipient MUST
0000000000000000000000000000000000000000;;			// treat this as a connection error.
0000000000000000000000000000000000000000;;			// Filed: https://github.com/http2/http2-spec/issues/610
0000000000000000000000000000000000000000;;			return nil, connError{ErrCodeProtocol, "pad size larger than data payload"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.data = payload[:len(payload)-int(padSize)]
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errStreamID    = errors.New("invalid stream ID")
0000000000000000000000000000000000000000;;		errDepStreamID = errors.New("invalid dependent stream ID")
0000000000000000000000000000000000000000;;		errPadLength   = errors.New("pad length too large")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validStreamIDOrZero(streamID uint32) bool {
0000000000000000000000000000000000000000;;		return streamID&(1<<31) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validStreamID(streamID uint32) bool {
0000000000000000000000000000000000000000;;		return streamID != 0 && streamID&(1<<31) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteData writes a DATA frame.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will perform exactly one Write to the underlying Writer.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility not to violate the maximum frame size
0000000000000000000000000000000000000000;;	// and to not call other Write methods concurrently.
0000000000000000000000000000000000000000;;	func (f *Framer) WriteData(streamID uint32, endStream bool, data []byte) error {
0000000000000000000000000000000000000000;;		return f.WriteDataPadded(streamID, endStream, data, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteData writes a DATA frame with optional padding.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If pad is nil, the padding bit is not sent.
0000000000000000000000000000000000000000;;	// The length of pad must not exceed 255 bytes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will perform exactly one Write to the underlying Writer.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility not to violate the maximum frame size
0000000000000000000000000000000000000000;;	// and to not call other Write methods concurrently.
0000000000000000000000000000000000000000;;	func (f *Framer) WriteDataPadded(streamID uint32, endStream bool, data, pad []byte) error {
0000000000000000000000000000000000000000;;		if !validStreamID(streamID) && !f.AllowIllegalWrites {
0000000000000000000000000000000000000000;;			return errStreamID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pad) > 255 {
0000000000000000000000000000000000000000;;			return errPadLength
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var flags Flags
0000000000000000000000000000000000000000;;		if endStream {
0000000000000000000000000000000000000000;;			flags |= FlagDataEndStream
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pad != nil {
0000000000000000000000000000000000000000;;			flags |= FlagDataPadded
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.startWrite(FrameData, flags, streamID)
0000000000000000000000000000000000000000;;		if pad != nil {
0000000000000000000000000000000000000000;;			f.wbuf = append(f.wbuf, byte(len(pad)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.wbuf = append(f.wbuf, data...)
0000000000000000000000000000000000000000;;		f.wbuf = append(f.wbuf, pad...)
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A SettingsFrame conveys configuration parameters that affect how
0000000000000000000000000000000000000000;;	// endpoints communicate, such as preferences and constraints on peer
0000000000000000000000000000000000000000;;	// behavior.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See http://http2.github.io/http2-spec/#SETTINGS
0000000000000000000000000000000000000000;;	type SettingsFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;		p []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseSettingsFrame(fh FrameHeader, p []byte) (Frame, error) {
0000000000000000000000000000000000000000;;		if fh.Flags.Has(FlagSettingsAck) && fh.Length > 0 {
0000000000000000000000000000000000000000;;			// When this (ACK 0x1) bit is set, the payload of the
0000000000000000000000000000000000000000;;			// SETTINGS frame MUST be empty.  Receipt of a
0000000000000000000000000000000000000000;;			// SETTINGS frame with the ACK flag set and a length
0000000000000000000000000000000000000000;;			// field value other than 0 MUST be treated as a
0000000000000000000000000000000000000000;;			// connection error (Section 5.4.1) of type
0000000000000000000000000000000000000000;;			// FRAME_SIZE_ERROR.
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeFrameSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fh.StreamID != 0 {
0000000000000000000000000000000000000000;;			// SETTINGS frames always apply to a connection,
0000000000000000000000000000000000000000;;			// never a single stream.  The stream identifier for a
0000000000000000000000000000000000000000;;			// SETTINGS frame MUST be zero (0x0).  If an endpoint
0000000000000000000000000000000000000000;;			// receives a SETTINGS frame whose stream identifier
0000000000000000000000000000000000000000;;			// field is anything other than 0x0, the endpoint MUST
0000000000000000000000000000000000000000;;			// respond with a connection error (Section 5.4.1) of
0000000000000000000000000000000000000000;;			// type PROTOCOL_ERROR.
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p)%6 != 0 {
0000000000000000000000000000000000000000;;			// Expecting even number of 6 byte settings.
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeFrameSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f := &SettingsFrame{FrameHeader: fh, p: p}
0000000000000000000000000000000000000000;;		if v, ok := f.Value(SettingInitialWindowSize); ok && v > (1<<31)-1 {
0000000000000000000000000000000000000000;;			// Values above the maximum flow control window size of 2^31 - 1 MUST
0000000000000000000000000000000000000000;;			// be treated as a connection error (Section 5.4.1) of type
0000000000000000000000000000000000000000;;			// FLOW_CONTROL_ERROR.
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeFlowControl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *SettingsFrame) IsAck() bool {
0000000000000000000000000000000000000000;;		return f.FrameHeader.Flags.Has(FlagSettingsAck)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *SettingsFrame) Value(s SettingID) (v uint32, ok bool) {
0000000000000000000000000000000000000000;;		f.checkValid()
0000000000000000000000000000000000000000;;		buf := f.p
0000000000000000000000000000000000000000;;		for len(buf) > 0 {
0000000000000000000000000000000000000000;;			settingID := SettingID(binary.BigEndian.Uint16(buf[:2]))
0000000000000000000000000000000000000000;;			if settingID == s {
0000000000000000000000000000000000000000;;				return binary.BigEndian.Uint32(buf[2:6]), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf = buf[6:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForeachSetting runs fn for each setting.
0000000000000000000000000000000000000000;;	// It stops and returns the first error.
0000000000000000000000000000000000000000;;	func (f *SettingsFrame) ForeachSetting(fn func(Setting) error) error {
0000000000000000000000000000000000000000;;		f.checkValid()
0000000000000000000000000000000000000000;;		buf := f.p
0000000000000000000000000000000000000000;;		for len(buf) > 0 {
0000000000000000000000000000000000000000;;			if err := fn(Setting{
0000000000000000000000000000000000000000;;				SettingID(binary.BigEndian.Uint16(buf[:2])),
0000000000000000000000000000000000000000;;				binary.BigEndian.Uint32(buf[2:6]),
0000000000000000000000000000000000000000;;			}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf = buf[6:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteSettings writes a SETTINGS frame with zero or more settings
0000000000000000000000000000000000000000;;	// specified and the ACK bit not set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will perform exactly one Write to the underlying Writer.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility to not call other Write methods concurrently.
0000000000000000000000000000000000000000;;	func (f *Framer) WriteSettings(settings ...Setting) error {
0000000000000000000000000000000000000000;;		f.startWrite(FrameSettings, 0, 0)
0000000000000000000000000000000000000000;;		for _, s := range settings {
0000000000000000000000000000000000000000;;			f.writeUint16(uint16(s.ID))
0000000000000000000000000000000000000000;;			f.writeUint32(s.Val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteSettingsAck writes an empty SETTINGS frame with the ACK bit set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will perform exactly one Write to the underlying Writer.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility to not call other Write methods concurrently.
0000000000000000000000000000000000000000;;	func (f *Framer) WriteSettingsAck() error {
0000000000000000000000000000000000000000;;		f.startWrite(FrameSettings, FlagSettingsAck, 0)
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A PingFrame is a mechanism for measuring a minimal round trip time
0000000000000000000000000000000000000000;;	// from the sender, as well as determining whether an idle connection
0000000000000000000000000000000000000000;;	// is still functional.
0000000000000000000000000000000000000000;;	// See http://http2.github.io/http2-spec/#rfc.section.6.7
0000000000000000000000000000000000000000;;	type PingFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;		Data [8]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *PingFrame) IsAck() bool { return f.Flags.Has(FlagPingAck) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePingFrame(fh FrameHeader, payload []byte) (Frame, error) {
0000000000000000000000000000000000000000;;		if len(payload) != 8 {
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeFrameSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fh.StreamID != 0 {
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f := &PingFrame{FrameHeader: fh}
0000000000000000000000000000000000000000;;		copy(f.Data[:], payload)
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) WritePing(ack bool, data [8]byte) error {
0000000000000000000000000000000000000000;;		var flags Flags
0000000000000000000000000000000000000000;;		if ack {
0000000000000000000000000000000000000000;;			flags = FlagPingAck
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.startWrite(FramePing, flags, 0)
0000000000000000000000000000000000000000;;		f.writeBytes(data[:])
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A GoAwayFrame informs the remote peer to stop creating streams on this connection.
0000000000000000000000000000000000000000;;	// See http://http2.github.io/http2-spec/#rfc.section.6.8
0000000000000000000000000000000000000000;;	type GoAwayFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;		LastStreamID uint32
0000000000000000000000000000000000000000;;		ErrCode      ErrCode
0000000000000000000000000000000000000000;;		debugData    []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DebugData returns any debug data in the GOAWAY frame. Its contents
0000000000000000000000000000000000000000;;	// are not defined.
0000000000000000000000000000000000000000;;	// The caller must not retain the returned memory past the next
0000000000000000000000000000000000000000;;	// call to ReadFrame.
0000000000000000000000000000000000000000;;	func (f *GoAwayFrame) DebugData() []byte {
0000000000000000000000000000000000000000;;		f.checkValid()
0000000000000000000000000000000000000000;;		return f.debugData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseGoAwayFrame(fh FrameHeader, p []byte) (Frame, error) {
0000000000000000000000000000000000000000;;		if fh.StreamID != 0 {
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p) < 8 {
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeFrameSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &GoAwayFrame{
0000000000000000000000000000000000000000;;			FrameHeader:  fh,
0000000000000000000000000000000000000000;;			LastStreamID: binary.BigEndian.Uint32(p[:4]) & (1<<31 - 1),
0000000000000000000000000000000000000000;;			ErrCode:      ErrCode(binary.BigEndian.Uint32(p[4:8])),
0000000000000000000000000000000000000000;;			debugData:    p[8:],
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Framer) WriteGoAway(maxStreamID uint32, code ErrCode, debugData []byte) error {
0000000000000000000000000000000000000000;;		f.startWrite(FrameGoAway, 0, 0)
0000000000000000000000000000000000000000;;		f.writeUint32(maxStreamID & (1<<31 - 1))
0000000000000000000000000000000000000000;;		f.writeUint32(uint32(code))
0000000000000000000000000000000000000000;;		f.writeBytes(debugData)
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An UnknownFrame is the frame type returned when the frame type is unknown
0000000000000000000000000000000000000000;;	// or no specific frame type parser exists.
0000000000000000000000000000000000000000;;	type UnknownFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;		p []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Payload returns the frame's payload (after the header).  It is not
0000000000000000000000000000000000000000;;	// valid to call this method after a subsequent call to
0000000000000000000000000000000000000000;;	// Framer.ReadFrame, nor is it valid to retain the returned slice.
0000000000000000000000000000000000000000;;	// The memory is owned by the Framer and is invalidated when the next
0000000000000000000000000000000000000000;;	// frame is read.
0000000000000000000000000000000000000000;;	func (f *UnknownFrame) Payload() []byte {
0000000000000000000000000000000000000000;;		f.checkValid()
0000000000000000000000000000000000000000;;		return f.p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseUnknownFrame(fh FrameHeader, p []byte) (Frame, error) {
0000000000000000000000000000000000000000;;		return &UnknownFrame{fh, p}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A WindowUpdateFrame is used to implement flow control.
0000000000000000000000000000000000000000;;	// See http://http2.github.io/http2-spec/#rfc.section.6.9
0000000000000000000000000000000000000000;;	type WindowUpdateFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;		Increment uint32 // never read with high bit set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseWindowUpdateFrame(fh FrameHeader, p []byte) (Frame, error) {
0000000000000000000000000000000000000000;;		if len(p) != 4 {
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeFrameSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inc := binary.BigEndian.Uint32(p[:4]) & 0x7fffffff // mask off high reserved bit
0000000000000000000000000000000000000000;;		if inc == 0 {
0000000000000000000000000000000000000000;;			// A receiver MUST treat the receipt of a
0000000000000000000000000000000000000000;;			// WINDOW_UPDATE frame with an flow control window
0000000000000000000000000000000000000000;;			// increment of 0 as a stream error (Section 5.4.2) of
0000000000000000000000000000000000000000;;			// type PROTOCOL_ERROR; errors on the connection flow
0000000000000000000000000000000000000000;;			// control window MUST be treated as a connection
0000000000000000000000000000000000000000;;			// error (Section 5.4.1).
0000000000000000000000000000000000000000;;			if fh.StreamID == 0 {
0000000000000000000000000000000000000000;;				return nil, ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, streamError(fh.StreamID, ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &WindowUpdateFrame{
0000000000000000000000000000000000000000;;			FrameHeader: fh,
0000000000000000000000000000000000000000;;			Increment:   inc,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteWindowUpdate writes a WINDOW_UPDATE frame.
0000000000000000000000000000000000000000;;	// The increment value must be between 1 and 2,147,483,647, inclusive.
0000000000000000000000000000000000000000;;	// If the Stream ID is zero, the window update applies to the
0000000000000000000000000000000000000000;;	// connection as a whole.
0000000000000000000000000000000000000000;;	func (f *Framer) WriteWindowUpdate(streamID, incr uint32) error {
0000000000000000000000000000000000000000;;		// "The legal range for the increment to the flow control window is 1 to 2^31-1 (2,147,483,647) octets."
0000000000000000000000000000000000000000;;		if (incr < 1 || incr > 2147483647) && !f.AllowIllegalWrites {
0000000000000000000000000000000000000000;;			return errors.New("illegal window increment value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.startWrite(FrameWindowUpdate, 0, streamID)
0000000000000000000000000000000000000000;;		f.writeUint32(incr)
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A HeadersFrame is used to open a stream and additionally carries a
0000000000000000000000000000000000000000;;	// header block fragment.
0000000000000000000000000000000000000000;;	type HeadersFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Priority is set if FlagHeadersPriority is set in the FrameHeader.
0000000000000000000000000000000000000000;;		Priority PriorityParam
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headerFragBuf []byte // not owned
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *HeadersFrame) HeaderBlockFragment() []byte {
0000000000000000000000000000000000000000;;		f.checkValid()
0000000000000000000000000000000000000000;;		return f.headerFragBuf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *HeadersFrame) HeadersEnded() bool {
0000000000000000000000000000000000000000;;		return f.FrameHeader.Flags.Has(FlagHeadersEndHeaders)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *HeadersFrame) StreamEnded() bool {
0000000000000000000000000000000000000000;;		return f.FrameHeader.Flags.Has(FlagHeadersEndStream)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *HeadersFrame) HasPriority() bool {
0000000000000000000000000000000000000000;;		return f.FrameHeader.Flags.Has(FlagHeadersPriority)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseHeadersFrame(fh FrameHeader, p []byte) (_ Frame, err error) {
0000000000000000000000000000000000000000;;		hf := &HeadersFrame{
0000000000000000000000000000000000000000;;			FrameHeader: fh,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fh.StreamID == 0 {
0000000000000000000000000000000000000000;;			// HEADERS frames MUST be associated with a stream.  If a HEADERS frame
0000000000000000000000000000000000000000;;			// is received whose stream identifier field is 0x0, the recipient MUST
0000000000000000000000000000000000000000;;			// respond with a connection error (Section 5.4.1) of type
0000000000000000000000000000000000000000;;			// PROTOCOL_ERROR.
0000000000000000000000000000000000000000;;			return nil, connError{ErrCodeProtocol, "HEADERS frame with stream ID 0"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var padLength uint8
0000000000000000000000000000000000000000;;		if fh.Flags.Has(FlagHeadersPadded) {
0000000000000000000000000000000000000000;;			if p, padLength, err = readByte(p); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fh.Flags.Has(FlagHeadersPriority) {
0000000000000000000000000000000000000000;;			var v uint32
0000000000000000000000000000000000000000;;			p, v, err = readUint32(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hf.Priority.StreamDep = v & 0x7fffffff
0000000000000000000000000000000000000000;;			hf.Priority.Exclusive = (v != hf.Priority.StreamDep) // high bit was set
0000000000000000000000000000000000000000;;			p, hf.Priority.Weight, err = readByte(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p)-int(padLength) <= 0 {
0000000000000000000000000000000000000000;;			return nil, streamError(fh.StreamID, ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hf.headerFragBuf = p[:len(p)-int(padLength)]
0000000000000000000000000000000000000000;;		return hf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HeadersFrameParam are the parameters for writing a HEADERS frame.
0000000000000000000000000000000000000000;;	type HeadersFrameParam struct {
0000000000000000000000000000000000000000;;		// StreamID is the required Stream ID to initiate.
0000000000000000000000000000000000000000;;		StreamID uint32
0000000000000000000000000000000000000000;;		// BlockFragment is part (or all) of a Header Block.
0000000000000000000000000000000000000000;;		BlockFragment []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EndStream indicates that the header block is the last that
0000000000000000000000000000000000000000;;		// the endpoint will send for the identified stream. Setting
0000000000000000000000000000000000000000;;		// this flag causes the stream to enter one of "half closed"
0000000000000000000000000000000000000000;;		// states.
0000000000000000000000000000000000000000;;		EndStream bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EndHeaders indicates that this frame contains an entire
0000000000000000000000000000000000000000;;		// header block and is not followed by any
0000000000000000000000000000000000000000;;		// CONTINUATION frames.
0000000000000000000000000000000000000000;;		EndHeaders bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PadLength is the optional number of bytes of zeros to add
0000000000000000000000000000000000000000;;		// to this frame.
0000000000000000000000000000000000000000;;		PadLength uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Priority, if non-zero, includes stream priority information
0000000000000000000000000000000000000000;;		// in the HEADER frame.
0000000000000000000000000000000000000000;;		Priority PriorityParam
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteHeaders writes a single HEADERS frame.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is a low-level header writing method. Encoding headers and
0000000000000000000000000000000000000000;;	// splitting them into any necessary CONTINUATION frames is handled
0000000000000000000000000000000000000000;;	// elsewhere.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will perform exactly one Write to the underlying Writer.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility to not call other Write methods concurrently.
0000000000000000000000000000000000000000;;	func (f *Framer) WriteHeaders(p HeadersFrameParam) error {
0000000000000000000000000000000000000000;;		if !validStreamID(p.StreamID) && !f.AllowIllegalWrites {
0000000000000000000000000000000000000000;;			return errStreamID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var flags Flags
0000000000000000000000000000000000000000;;		if p.PadLength != 0 {
0000000000000000000000000000000000000000;;			flags |= FlagHeadersPadded
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.EndStream {
0000000000000000000000000000000000000000;;			flags |= FlagHeadersEndStream
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.EndHeaders {
0000000000000000000000000000000000000000;;			flags |= FlagHeadersEndHeaders
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !p.Priority.IsZero() {
0000000000000000000000000000000000000000;;			flags |= FlagHeadersPriority
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.startWrite(FrameHeaders, flags, p.StreamID)
0000000000000000000000000000000000000000;;		if p.PadLength != 0 {
0000000000000000000000000000000000000000;;			f.writeByte(p.PadLength)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !p.Priority.IsZero() {
0000000000000000000000000000000000000000;;			v := p.Priority.StreamDep
0000000000000000000000000000000000000000;;			if !validStreamIDOrZero(v) && !f.AllowIllegalWrites {
0000000000000000000000000000000000000000;;				return errDepStreamID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.Priority.Exclusive {
0000000000000000000000000000000000000000;;				v |= 1 << 31
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.writeUint32(v)
0000000000000000000000000000000000000000;;			f.writeByte(p.Priority.Weight)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.wbuf = append(f.wbuf, p.BlockFragment...)
0000000000000000000000000000000000000000;;		f.wbuf = append(f.wbuf, padZeros[:p.PadLength]...)
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A PriorityFrame specifies the sender-advised priority of a stream.
0000000000000000000000000000000000000000;;	// See http://http2.github.io/http2-spec/#rfc.section.6.3
0000000000000000000000000000000000000000;;	type PriorityFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;		PriorityParam
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PriorityParam are the stream prioritzation parameters.
0000000000000000000000000000000000000000;;	type PriorityParam struct {
0000000000000000000000000000000000000000;;		// StreamDep is a 31-bit stream identifier for the
0000000000000000000000000000000000000000;;		// stream that this stream depends on. Zero means no
0000000000000000000000000000000000000000;;		// dependency.
0000000000000000000000000000000000000000;;		StreamDep uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Exclusive is whether the dependency is exclusive.
0000000000000000000000000000000000000000;;		Exclusive bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Weight is the stream's zero-indexed weight. It should be
0000000000000000000000000000000000000000;;		// set together with StreamDep, or neither should be set.  Per
0000000000000000000000000000000000000000;;		// the spec, "Add one to the value to obtain a weight between
0000000000000000000000000000000000000000;;		// 1 and 256."
0000000000000000000000000000000000000000;;		Weight uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p PriorityParam) IsZero() bool {
0000000000000000000000000000000000000000;;		return p == PriorityParam{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePriorityFrame(fh FrameHeader, payload []byte) (Frame, error) {
0000000000000000000000000000000000000000;;		if fh.StreamID == 0 {
0000000000000000000000000000000000000000;;			return nil, connError{ErrCodeProtocol, "PRIORITY frame with stream ID 0"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(payload) != 5 {
0000000000000000000000000000000000000000;;			return nil, connError{ErrCodeFrameSize, fmt.Sprintf("PRIORITY frame payload size was %d; want 5", len(payload))}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := binary.BigEndian.Uint32(payload[:4])
0000000000000000000000000000000000000000;;		streamID := v & 0x7fffffff // mask off high bit
0000000000000000000000000000000000000000;;		return &PriorityFrame{
0000000000000000000000000000000000000000;;			FrameHeader: fh,
0000000000000000000000000000000000000000;;			PriorityParam: PriorityParam{
0000000000000000000000000000000000000000;;				Weight:    payload[4],
0000000000000000000000000000000000000000;;				StreamDep: streamID,
0000000000000000000000000000000000000000;;				Exclusive: streamID != v, // was high bit set?
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WritePriority writes a PRIORITY frame.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will perform exactly one Write to the underlying Writer.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility to not call other Write methods concurrently.
0000000000000000000000000000000000000000;;	func (f *Framer) WritePriority(streamID uint32, p PriorityParam) error {
0000000000000000000000000000000000000000;;		if !validStreamID(streamID) && !f.AllowIllegalWrites {
0000000000000000000000000000000000000000;;			return errStreamID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !validStreamIDOrZero(p.StreamDep) {
0000000000000000000000000000000000000000;;			return errDepStreamID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.startWrite(FramePriority, 0, streamID)
0000000000000000000000000000000000000000;;		v := p.StreamDep
0000000000000000000000000000000000000000;;		if p.Exclusive {
0000000000000000000000000000000000000000;;			v |= 1 << 31
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.writeUint32(v)
0000000000000000000000000000000000000000;;		f.writeByte(p.Weight)
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A RSTStreamFrame allows for abnormal termination of a stream.
0000000000000000000000000000000000000000;;	// See http://http2.github.io/http2-spec/#rfc.section.6.4
0000000000000000000000000000000000000000;;	type RSTStreamFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;		ErrCode ErrCode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseRSTStreamFrame(fh FrameHeader, p []byte) (Frame, error) {
0000000000000000000000000000000000000000;;		if len(p) != 4 {
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeFrameSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fh.StreamID == 0 {
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &RSTStreamFrame{fh, ErrCode(binary.BigEndian.Uint32(p[:4]))}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteRSTStream writes a RST_STREAM frame.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will perform exactly one Write to the underlying Writer.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility to not call other Write methods concurrently.
0000000000000000000000000000000000000000;;	func (f *Framer) WriteRSTStream(streamID uint32, code ErrCode) error {
0000000000000000000000000000000000000000;;		if !validStreamID(streamID) && !f.AllowIllegalWrites {
0000000000000000000000000000000000000000;;			return errStreamID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.startWrite(FrameRSTStream, 0, streamID)
0000000000000000000000000000000000000000;;		f.writeUint32(uint32(code))
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ContinuationFrame is used to continue a sequence of header block fragments.
0000000000000000000000000000000000000000;;	// See http://http2.github.io/http2-spec/#rfc.section.6.10
0000000000000000000000000000000000000000;;	type ContinuationFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;		headerFragBuf []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseContinuationFrame(fh FrameHeader, p []byte) (Frame, error) {
0000000000000000000000000000000000000000;;		if fh.StreamID == 0 {
0000000000000000000000000000000000000000;;			return nil, connError{ErrCodeProtocol, "CONTINUATION frame with stream ID 0"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ContinuationFrame{fh, p}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ContinuationFrame) HeaderBlockFragment() []byte {
0000000000000000000000000000000000000000;;		f.checkValid()
0000000000000000000000000000000000000000;;		return f.headerFragBuf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *ContinuationFrame) HeadersEnded() bool {
0000000000000000000000000000000000000000;;		return f.FrameHeader.Flags.Has(FlagContinuationEndHeaders)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteContinuation writes a CONTINUATION frame.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will perform exactly one Write to the underlying Writer.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility to not call other Write methods concurrently.
0000000000000000000000000000000000000000;;	func (f *Framer) WriteContinuation(streamID uint32, endHeaders bool, headerBlockFragment []byte) error {
0000000000000000000000000000000000000000;;		if !validStreamID(streamID) && !f.AllowIllegalWrites {
0000000000000000000000000000000000000000;;			return errStreamID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var flags Flags
0000000000000000000000000000000000000000;;		if endHeaders {
0000000000000000000000000000000000000000;;			flags |= FlagContinuationEndHeaders
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.startWrite(FrameContinuation, flags, streamID)
0000000000000000000000000000000000000000;;		f.wbuf = append(f.wbuf, headerBlockFragment...)
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A PushPromiseFrame is used to initiate a server stream.
0000000000000000000000000000000000000000;;	// See http://http2.github.io/http2-spec/#rfc.section.6.6
0000000000000000000000000000000000000000;;	type PushPromiseFrame struct {
0000000000000000000000000000000000000000;;		FrameHeader
0000000000000000000000000000000000000000;;		PromiseID     uint32
0000000000000000000000000000000000000000;;		headerFragBuf []byte // not owned
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *PushPromiseFrame) HeaderBlockFragment() []byte {
0000000000000000000000000000000000000000;;		f.checkValid()
0000000000000000000000000000000000000000;;		return f.headerFragBuf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *PushPromiseFrame) HeadersEnded() bool {
0000000000000000000000000000000000000000;;		return f.FrameHeader.Flags.Has(FlagPushPromiseEndHeaders)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePushPromise(fh FrameHeader, p []byte) (_ Frame, err error) {
0000000000000000000000000000000000000000;;		pp := &PushPromiseFrame{
0000000000000000000000000000000000000000;;			FrameHeader: fh,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pp.StreamID == 0 {
0000000000000000000000000000000000000000;;			// PUSH_PROMISE frames MUST be associated with an existing,
0000000000000000000000000000000000000000;;			// peer-initiated stream. The stream identifier of a
0000000000000000000000000000000000000000;;			// PUSH_PROMISE frame indicates the stream it is associated
0000000000000000000000000000000000000000;;			// with. If the stream identifier field specifies the value
0000000000000000000000000000000000000000;;			// 0x0, a recipient MUST respond with a connection error
0000000000000000000000000000000000000000;;			// (Section 5.4.1) of type PROTOCOL_ERROR.
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The PUSH_PROMISE frame includes optional padding.
0000000000000000000000000000000000000000;;		// Padding fields and flags are identical to those defined for DATA frames
0000000000000000000000000000000000000000;;		var padLength uint8
0000000000000000000000000000000000000000;;		if fh.Flags.Has(FlagPushPromisePadded) {
0000000000000000000000000000000000000000;;			if p, padLength, err = readByte(p); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p, pp.PromiseID, err = readUint32(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pp.PromiseID = pp.PromiseID & (1<<31 - 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if int(padLength) > len(p) {
0000000000000000000000000000000000000000;;			// like the DATA frame, error out if padding is longer than the body.
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pp.headerFragBuf = p[:len(p)-int(padLength)]
0000000000000000000000000000000000000000;;		return pp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PushPromiseParam are the parameters for writing a PUSH_PROMISE frame.
0000000000000000000000000000000000000000;;	type PushPromiseParam struct {
0000000000000000000000000000000000000000;;		// StreamID is the required Stream ID to initiate.
0000000000000000000000000000000000000000;;		StreamID uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PromiseID is the required Stream ID which this
0000000000000000000000000000000000000000;;		// Push Promises
0000000000000000000000000000000000000000;;		PromiseID uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BlockFragment is part (or all) of a Header Block.
0000000000000000000000000000000000000000;;		BlockFragment []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EndHeaders indicates that this frame contains an entire
0000000000000000000000000000000000000000;;		// header block and is not followed by any
0000000000000000000000000000000000000000;;		// CONTINUATION frames.
0000000000000000000000000000000000000000;;		EndHeaders bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PadLength is the optional number of bytes of zeros to add
0000000000000000000000000000000000000000;;		// to this frame.
0000000000000000000000000000000000000000;;		PadLength uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WritePushPromise writes a single PushPromise Frame.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As with Header Frames, This is the low level call for writing
0000000000000000000000000000000000000000;;	// individual frames. Continuation frames are handled elsewhere.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will perform exactly one Write to the underlying Writer.
0000000000000000000000000000000000000000;;	// It is the caller's responsibility to not call other Write methods concurrently.
0000000000000000000000000000000000000000;;	func (f *Framer) WritePushPromise(p PushPromiseParam) error {
0000000000000000000000000000000000000000;;		if !validStreamID(p.StreamID) && !f.AllowIllegalWrites {
0000000000000000000000000000000000000000;;			return errStreamID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var flags Flags
0000000000000000000000000000000000000000;;		if p.PadLength != 0 {
0000000000000000000000000000000000000000;;			flags |= FlagPushPromisePadded
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.EndHeaders {
0000000000000000000000000000000000000000;;			flags |= FlagPushPromiseEndHeaders
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.startWrite(FramePushPromise, flags, p.StreamID)
0000000000000000000000000000000000000000;;		if p.PadLength != 0 {
0000000000000000000000000000000000000000;;			f.writeByte(p.PadLength)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !validStreamID(p.PromiseID) && !f.AllowIllegalWrites {
0000000000000000000000000000000000000000;;			return errStreamID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.writeUint32(p.PromiseID)
0000000000000000000000000000000000000000;;		f.wbuf = append(f.wbuf, p.BlockFragment...)
0000000000000000000000000000000000000000;;		f.wbuf = append(f.wbuf, padZeros[:p.PadLength]...)
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteRawFrame writes a raw frame. This can be used to write
0000000000000000000000000000000000000000;;	// extension frames unknown to this package.
0000000000000000000000000000000000000000;;	func (f *Framer) WriteRawFrame(t FrameType, flags Flags, streamID uint32, payload []byte) error {
0000000000000000000000000000000000000000;;		f.startWrite(t, flags, streamID)
0000000000000000000000000000000000000000;;		f.writeBytes(payload)
0000000000000000000000000000000000000000;;		return f.endWrite()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readByte(p []byte) (remain []byte, b byte, err error) {
0000000000000000000000000000000000000000;;		if len(p) == 0 {
0000000000000000000000000000000000000000;;			return nil, 0, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p[1:], p[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readUint32(p []byte) (remain []byte, v uint32, err error) {
0000000000000000000000000000000000000000;;		if len(p) < 4 {
0000000000000000000000000000000000000000;;			return nil, 0, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p[4:], binary.BigEndian.Uint32(p[:4]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type streamEnder interface {
0000000000000000000000000000000000000000;;		StreamEnded() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type headersEnder interface {
0000000000000000000000000000000000000000;;		HeadersEnded() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type headersOrContinuation interface {
0000000000000000000000000000000000000000;;		headersEnder
0000000000000000000000000000000000000000;;		HeaderBlockFragment() []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A MetaHeadersFrame is the representation of one HEADERS frame and
0000000000000000000000000000000000000000;;	// zero or more contiguous CONTINUATION frames and the decoding of
0000000000000000000000000000000000000000;;	// their HPACK-encoded contents.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This type of frame does not appear on the wire and is only returned
0000000000000000000000000000000000000000;;	// by the Framer when Framer.ReadMetaHeaders is set.
0000000000000000000000000000000000000000;;	type MetaHeadersFrame struct {
0000000000000000000000000000000000000000;;		*HeadersFrame
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fields are the fields contained in the HEADERS and
0000000000000000000000000000000000000000;;		// CONTINUATION frames. The underlying slice is owned by the
0000000000000000000000000000000000000000;;		// Framer and must not be retained after the next call to
0000000000000000000000000000000000000000;;		// ReadFrame.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Fields are guaranteed to be in the correct http2 order and
0000000000000000000000000000000000000000;;		// not have unknown pseudo header fields or invalid header
0000000000000000000000000000000000000000;;		// field names or values. Required pseudo header fields may be
0000000000000000000000000000000000000000;;		// missing, however. Use the MetaHeadersFrame.Pseudo accessor
0000000000000000000000000000000000000000;;		// method access pseudo headers.
0000000000000000000000000000000000000000;;		Fields []hpack.HeaderField
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Truncated is whether the max header list size limit was hit
0000000000000000000000000000000000000000;;		// and Fields is incomplete. The hpack decoder state is still
0000000000000000000000000000000000000000;;		// valid, however.
0000000000000000000000000000000000000000;;		Truncated bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PseudoValue returns the given pseudo header field's value.
0000000000000000000000000000000000000000;;	// The provided pseudo field should not contain the leading colon.
0000000000000000000000000000000000000000;;	func (mh *MetaHeadersFrame) PseudoValue(pseudo string) string {
0000000000000000000000000000000000000000;;		for _, hf := range mh.Fields {
0000000000000000000000000000000000000000;;			if !hf.IsPseudo() {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hf.Name[1:] == pseudo {
0000000000000000000000000000000000000000;;				return hf.Value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegularFields returns the regular (non-pseudo) header fields of mh.
0000000000000000000000000000000000000000;;	// The caller does not own the returned slice.
0000000000000000000000000000000000000000;;	func (mh *MetaHeadersFrame) RegularFields() []hpack.HeaderField {
0000000000000000000000000000000000000000;;		for i, hf := range mh.Fields {
0000000000000000000000000000000000000000;;			if !hf.IsPseudo() {
0000000000000000000000000000000000000000;;				return mh.Fields[i:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PseudoFields returns the pseudo header fields of mh.
0000000000000000000000000000000000000000;;	// The caller does not own the returned slice.
0000000000000000000000000000000000000000;;	func (mh *MetaHeadersFrame) PseudoFields() []hpack.HeaderField {
0000000000000000000000000000000000000000;;		for i, hf := range mh.Fields {
0000000000000000000000000000000000000000;;			if !hf.IsPseudo() {
0000000000000000000000000000000000000000;;				return mh.Fields[:i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mh.Fields
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mh *MetaHeadersFrame) checkPseudos() error {
0000000000000000000000000000000000000000;;		var isRequest, isResponse bool
0000000000000000000000000000000000000000;;		pf := mh.PseudoFields()
0000000000000000000000000000000000000000;;		for i, hf := range pf {
0000000000000000000000000000000000000000;;			switch hf.Name {
0000000000000000000000000000000000000000;;			case ":method", ":path", ":scheme", ":authority":
0000000000000000000000000000000000000000;;				isRequest = true
0000000000000000000000000000000000000000;;			case ":status":
0000000000000000000000000000000000000000;;				isResponse = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return pseudoHeaderError(hf.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check for duplicates.
0000000000000000000000000000000000000000;;			// This would be a bad algorithm, but N is 4.
0000000000000000000000000000000000000000;;			// And this doesn't allocate.
0000000000000000000000000000000000000000;;			for _, hf2 := range pf[:i] {
0000000000000000000000000000000000000000;;				if hf.Name == hf2.Name {
0000000000000000000000000000000000000000;;					return duplicatePseudoHeaderError(hf.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isRequest && isResponse {
0000000000000000000000000000000000000000;;			return errMixPseudoHeaderTypes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fr *Framer) maxHeaderStringLen() int {
0000000000000000000000000000000000000000;;		v := fr.maxHeaderListSize()
0000000000000000000000000000000000000000;;		if uint32(int(v)) == v {
0000000000000000000000000000000000000000;;			return int(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// They had a crazy big number for MaxHeaderBytes anyway,
0000000000000000000000000000000000000000;;		// so give them unlimited header lengths:
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readMetaFrame returns 0 or more CONTINUATION frames from fr and
0000000000000000000000000000000000000000;;	// merge them into into the provided hf and returns a MetaHeadersFrame
0000000000000000000000000000000000000000;;	// with the decoded hpack values.
0000000000000000000000000000000000000000;;	func (fr *Framer) readMetaFrame(hf *HeadersFrame) (*MetaHeadersFrame, error) {
0000000000000000000000000000000000000000;;		if fr.AllowIllegalReads {
0000000000000000000000000000000000000000;;			return nil, errors.New("illegal use of AllowIllegalReads with ReadMetaHeaders")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mh := &MetaHeadersFrame{
0000000000000000000000000000000000000000;;			HeadersFrame: hf,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var remainSize = fr.maxHeaderListSize()
0000000000000000000000000000000000000000;;		var sawRegular bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var invalid error // pseudo header field errors
0000000000000000000000000000000000000000;;		hdec := fr.ReadMetaHeaders
0000000000000000000000000000000000000000;;		hdec.SetEmitEnabled(true)
0000000000000000000000000000000000000000;;		hdec.SetMaxStringLength(fr.maxHeaderStringLen())
0000000000000000000000000000000000000000;;		hdec.SetEmitFunc(func(hf hpack.HeaderField) {
0000000000000000000000000000000000000000;;			if VerboseLogs && fr.logReads {
0000000000000000000000000000000000000000;;				fr.debugReadLoggerf("http2: decoded hpack field %+v", hf)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !httplex.ValidHeaderFieldValue(hf.Value) {
0000000000000000000000000000000000000000;;				invalid = headerFieldValueError(hf.Value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			isPseudo := strings.HasPrefix(hf.Name, ":")
0000000000000000000000000000000000000000;;			if isPseudo {
0000000000000000000000000000000000000000;;				if sawRegular {
0000000000000000000000000000000000000000;;					invalid = errPseudoAfterRegular
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sawRegular = true
0000000000000000000000000000000000000000;;				if !validWireHeaderFieldName(hf.Name) {
0000000000000000000000000000000000000000;;					invalid = headerFieldNameError(hf.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if invalid != nil {
0000000000000000000000000000000000000000;;				hdec.SetEmitEnabled(false)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			size := hf.Size()
0000000000000000000000000000000000000000;;			if size > remainSize {
0000000000000000000000000000000000000000;;				hdec.SetEmitEnabled(false)
0000000000000000000000000000000000000000;;				mh.Truncated = true
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			remainSize -= size
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mh.Fields = append(mh.Fields, hf)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// Lose reference to MetaHeadersFrame:
0000000000000000000000000000000000000000;;		defer hdec.SetEmitFunc(func(hf hpack.HeaderField) {})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hc headersOrContinuation = hf
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			frag := hc.HeaderBlockFragment()
0000000000000000000000000000000000000000;;			if _, err := hdec.Write(frag); err != nil {
0000000000000000000000000000000000000000;;				return nil, ConnectionError(ErrCodeCompression)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hc.HeadersEnded() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f, err := fr.ReadFrame(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				hc = f.(*ContinuationFrame) // guaranteed by checkFrameOrder
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mh.HeadersFrame.headerFragBuf = nil
0000000000000000000000000000000000000000;;		mh.HeadersFrame.invalidate()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := hdec.Close(); err != nil {
0000000000000000000000000000000000000000;;			return nil, ConnectionError(ErrCodeCompression)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if invalid != nil {
0000000000000000000000000000000000000000;;			fr.errDetail = invalid
0000000000000000000000000000000000000000;;			if VerboseLogs {
0000000000000000000000000000000000000000;;				log.Printf("http2: invalid header: %v", invalid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, StreamError{mh.StreamID, ErrCodeProtocol, invalid}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := mh.checkPseudos(); err != nil {
0000000000000000000000000000000000000000;;			fr.errDetail = err
0000000000000000000000000000000000000000;;			if VerboseLogs {
0000000000000000000000000000000000000000;;				log.Printf("http2: invalid pseudo headers: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, StreamError{mh.StreamID, ErrCodeProtocol, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mh, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func summarizeFrame(f Frame) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		f.Header().writeDebug(&buf)
0000000000000000000000000000000000000000;;		switch f := f.(type) {
0000000000000000000000000000000000000000;;		case *SettingsFrame:
0000000000000000000000000000000000000000;;			n := 0
0000000000000000000000000000000000000000;;			f.ForeachSetting(func(s Setting) error {
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;				if n == 1 {
0000000000000000000000000000000000000000;;					buf.WriteString(", settings:")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprintf(&buf, " %v=%v,", s.ID, s.Val)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if n > 0 {
0000000000000000000000000000000000000000;;				buf.Truncate(buf.Len() - 1) // remove trailing comma
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *DataFrame:
0000000000000000000000000000000000000000;;			data := f.Data()
0000000000000000000000000000000000000000;;			const max = 256
0000000000000000000000000000000000000000;;			if len(data) > max {
0000000000000000000000000000000000000000;;				data = data[:max]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, " data=%q", data)
0000000000000000000000000000000000000000;;			if len(f.Data()) > max {
0000000000000000000000000000000000000000;;				fmt.Fprintf(&buf, " (%d bytes omitted)", len(f.Data())-max)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *WindowUpdateFrame:
0000000000000000000000000000000000000000;;			if f.StreamID == 0 {
0000000000000000000000000000000000000000;;				buf.WriteString(" (conn)")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, " incr=%v", f.Increment)
0000000000000000000000000000000000000000;;		case *PingFrame:
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, " ping=%q", f.Data[:])
0000000000000000000000000000000000000000;;		case *GoAwayFrame:
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, " LastStreamID=%v ErrCode=%v Debug=%q",
0000000000000000000000000000000000000000;;				f.LastStreamID, f.ErrCode, f.debugData)
0000000000000000000000000000000000000000;;		case *RSTStreamFrame:
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, " ErrCode=%v", f.ErrCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
