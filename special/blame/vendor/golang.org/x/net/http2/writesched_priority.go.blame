0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 7540, Section 5.3.5: the default weight is 16.
0000000000000000000000000000000000000000;;	const priorityDefaultWeight = 15 // 16 = 15 + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PriorityWriteSchedulerConfig configures a priorityWriteScheduler.
0000000000000000000000000000000000000000;;	type PriorityWriteSchedulerConfig struct {
0000000000000000000000000000000000000000;;		// MaxClosedNodesInTree controls the maximum number of closed streams to
0000000000000000000000000000000000000000;;		// retain in the priority tree. Setting this to zero saves a small amount
0000000000000000000000000000000000000000;;		// of memory at the cost of performance.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// See RFC 7540, Section 5.3.4:
0000000000000000000000000000000000000000;;		//   "It is possible for a stream to become closed while prioritization
0000000000000000000000000000000000000000;;		//   information ... is in transit. ... This potentially creates suboptimal
0000000000000000000000000000000000000000;;		//   prioritization, since the stream could be given a priority that is
0000000000000000000000000000000000000000;;		//   different from what is intended. To avoid these problems, an endpoint
0000000000000000000000000000000000000000;;		//   SHOULD retain stream prioritization state for a period after streams
0000000000000000000000000000000000000000;;		//   become closed. The longer state is retained, the lower the chance that
0000000000000000000000000000000000000000;;		//   streams are assigned incorrect or default priority values."
0000000000000000000000000000000000000000;;		MaxClosedNodesInTree int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxIdleNodesInTree controls the maximum number of idle streams to
0000000000000000000000000000000000000000;;		// retain in the priority tree. Setting this to zero saves a small amount
0000000000000000000000000000000000000000;;		// of memory at the cost of performance.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// See RFC 7540, Section 5.3.4:
0000000000000000000000000000000000000000;;		//   Similarly, streams that are in the "idle" state can be assigned
0000000000000000000000000000000000000000;;		//   priority or become a parent of other streams. This allows for the
0000000000000000000000000000000000000000;;		//   creation of a grouping node in the dependency tree, which enables
0000000000000000000000000000000000000000;;		//   more flexible expressions of priority. Idle streams begin with a
0000000000000000000000000000000000000000;;		//   default priority (Section 5.3.5).
0000000000000000000000000000000000000000;;		MaxIdleNodesInTree int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ThrottleOutOfOrderWrites enables write throttling to help ensure that
0000000000000000000000000000000000000000;;		// data is delivered in priority order. This works around a race where
0000000000000000000000000000000000000000;;		// stream B depends on stream A and both streams are about to call Write
0000000000000000000000000000000000000000;;		// to queue DATA frames. If B wins the race, a naive scheduler would eagerly
0000000000000000000000000000000000000000;;		// write as much data from B as possible, but this is suboptimal because A
0000000000000000000000000000000000000000;;		// is a higher-priority stream. With throttling enabled, we write a small
0000000000000000000000000000000000000000;;		// amount of data from B to minimize the amount of bandwidth that B can
0000000000000000000000000000000000000000;;		// steal from A.
0000000000000000000000000000000000000000;;		ThrottleOutOfOrderWrites bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPriorityWriteScheduler constructs a WriteScheduler that schedules
0000000000000000000000000000000000000000;;	// frames by following HTTP/2 priorities as described in RFC 7340 Section 5.3.
0000000000000000000000000000000000000000;;	// If cfg is nil, default options are used.
0000000000000000000000000000000000000000;;	func NewPriorityWriteScheduler(cfg *PriorityWriteSchedulerConfig) WriteScheduler {
0000000000000000000000000000000000000000;;		if cfg == nil {
0000000000000000000000000000000000000000;;			// For justification of these defaults, see:
0000000000000000000000000000000000000000;;			// https://docs.google.com/document/d/1oLhNg1skaWD4_DtaoCxdSRN5erEXrH-KnLrMwEpOtFY
0000000000000000000000000000000000000000;;			cfg = &PriorityWriteSchedulerConfig{
0000000000000000000000000000000000000000;;				MaxClosedNodesInTree:     10,
0000000000000000000000000000000000000000;;				MaxIdleNodesInTree:       10,
0000000000000000000000000000000000000000;;				ThrottleOutOfOrderWrites: false,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ws := &priorityWriteScheduler{
0000000000000000000000000000000000000000;;			nodes:                make(map[uint32]*priorityNode),
0000000000000000000000000000000000000000;;			maxClosedNodesInTree: cfg.MaxClosedNodesInTree,
0000000000000000000000000000000000000000;;			maxIdleNodesInTree:   cfg.MaxIdleNodesInTree,
0000000000000000000000000000000000000000;;			enableWriteThrottle:  cfg.ThrottleOutOfOrderWrites,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ws.nodes[0] = &ws.root
0000000000000000000000000000000000000000;;		if cfg.ThrottleOutOfOrderWrites {
0000000000000000000000000000000000000000;;			ws.writeThrottleLimit = 1024
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ws.writeThrottleLimit = math.MaxInt32
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ws
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type priorityNodeState int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		priorityNodeOpen priorityNodeState = iota
0000000000000000000000000000000000000000;;		priorityNodeClosed
0000000000000000000000000000000000000000;;		priorityNodeIdle
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// priorityNode is a node in an HTTP/2 priority tree.
0000000000000000000000000000000000000000;;	// Each node is associated with a single stream ID.
0000000000000000000000000000000000000000;;	// See RFC 7540, Section 5.3.
0000000000000000000000000000000000000000;;	type priorityNode struct {
0000000000000000000000000000000000000000;;		q            writeQueue        // queue of pending frames to write
0000000000000000000000000000000000000000;;		id           uint32            // id of the stream, or 0 for the root of the tree
0000000000000000000000000000000000000000;;		weight       uint8             // the actual weight is weight+1, so the value is in [1,256]
0000000000000000000000000000000000000000;;		state        priorityNodeState // open | closed | idle
0000000000000000000000000000000000000000;;		bytes        int64             // number of bytes written by this node, or 0 if closed
0000000000000000000000000000000000000000;;		subtreeBytes int64             // sum(node.bytes) of all nodes in this subtree
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These links form the priority tree.
0000000000000000000000000000000000000000;;		parent     *priorityNode
0000000000000000000000000000000000000000;;		kids       *priorityNode // start of the kids list
0000000000000000000000000000000000000000;;		prev, next *priorityNode // doubly-linked list of siblings
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *priorityNode) setParent(parent *priorityNode) {
0000000000000000000000000000000000000000;;		if n == parent {
0000000000000000000000000000000000000000;;			panic("setParent to self")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.parent == parent {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Unlink from current parent.
0000000000000000000000000000000000000000;;		if parent := n.parent; parent != nil {
0000000000000000000000000000000000000000;;			if n.prev == nil {
0000000000000000000000000000000000000000;;				parent.kids = n.next
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				n.prev.next = n.next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n.next != nil {
0000000000000000000000000000000000000000;;				n.next.prev = n.prev
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Link to new parent.
0000000000000000000000000000000000000000;;		// If parent=nil, remove n from the tree.
0000000000000000000000000000000000000000;;		// Always insert at the head of parent.kids (this is assumed by walkReadyInOrder).
0000000000000000000000000000000000000000;;		n.parent = parent
0000000000000000000000000000000000000000;;		if parent == nil {
0000000000000000000000000000000000000000;;			n.next = nil
0000000000000000000000000000000000000000;;			n.prev = nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			n.next = parent.kids
0000000000000000000000000000000000000000;;			n.prev = nil
0000000000000000000000000000000000000000;;			if n.next != nil {
0000000000000000000000000000000000000000;;				n.next.prev = n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parent.kids = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *priorityNode) addBytes(b int64) {
0000000000000000000000000000000000000000;;		n.bytes += b
0000000000000000000000000000000000000000;;		for ; n != nil; n = n.parent {
0000000000000000000000000000000000000000;;			n.subtreeBytes += b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// walkReadyInOrder iterates over the tree in priority order, calling f for each node
0000000000000000000000000000000000000000;;	// with a non-empty write queue. When f returns true, this funcion returns true and the
0000000000000000000000000000000000000000;;	// walk halts. tmp is used as scratch space for sorting.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// f(n, openParent) takes two arguments: the node to visit, n, and a bool that is true
0000000000000000000000000000000000000000;;	// if any ancestor p of n is still open (ignoring the root node).
0000000000000000000000000000000000000000;;	func (n *priorityNode) walkReadyInOrder(openParent bool, tmp *[]*priorityNode, f func(*priorityNode, bool) bool) bool {
0000000000000000000000000000000000000000;;		if !n.q.empty() && f(n, openParent) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.kids == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't consider the root "open" when updating openParent since
0000000000000000000000000000000000000000;;		// we can't send data frames on the root stream (only control frames).
0000000000000000000000000000000000000000;;		if n.id != 0 {
0000000000000000000000000000000000000000;;			openParent = openParent || (n.state == priorityNodeOpen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Common case: only one kid or all kids have the same weight.
0000000000000000000000000000000000000000;;		// Some clients don't use weights; other clients (like web browsers)
0000000000000000000000000000000000000000;;		// use mostly-linear priority trees.
0000000000000000000000000000000000000000;;		w := n.kids.weight
0000000000000000000000000000000000000000;;		needSort := false
0000000000000000000000000000000000000000;;		for k := n.kids.next; k != nil; k = k.next {
0000000000000000000000000000000000000000;;			if k.weight != w {
0000000000000000000000000000000000000000;;				needSort = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !needSort {
0000000000000000000000000000000000000000;;			for k := n.kids; k != nil; k = k.next {
0000000000000000000000000000000000000000;;				if k.walkReadyInOrder(openParent, tmp, f) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Uncommon case: sort the child nodes. We remove the kids from the parent,
0000000000000000000000000000000000000000;;		// then re-insert after sorting so we can reuse tmp for future sort calls.
0000000000000000000000000000000000000000;;		*tmp = (*tmp)[:0]
0000000000000000000000000000000000000000;;		for n.kids != nil {
0000000000000000000000000000000000000000;;			*tmp = append(*tmp, n.kids)
0000000000000000000000000000000000000000;;			n.kids.setParent(nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sortPriorityNodeSiblings(*tmp))
0000000000000000000000000000000000000000;;		for i := len(*tmp) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			(*tmp)[i].setParent(n) // setParent inserts at the head of n.kids
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k := n.kids; k != nil; k = k.next {
0000000000000000000000000000000000000000;;			if k.walkReadyInOrder(openParent, tmp, f) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortPriorityNodeSiblings []*priorityNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z sortPriorityNodeSiblings) Len() int      { return len(z) }
0000000000000000000000000000000000000000;;	func (z sortPriorityNodeSiblings) Swap(i, k int) { z[i], z[k] = z[k], z[i] }
0000000000000000000000000000000000000000;;	func (z sortPriorityNodeSiblings) Less(i, k int) bool {
0000000000000000000000000000000000000000;;		// Prefer the subtree that has sent fewer bytes relative to its weight.
0000000000000000000000000000000000000000;;		// See sections 5.3.2 and 5.3.4.
0000000000000000000000000000000000000000;;		wi, bi := float64(z[i].weight+1), float64(z[i].subtreeBytes)
0000000000000000000000000000000000000000;;		wk, bk := float64(z[k].weight+1), float64(z[k].subtreeBytes)
0000000000000000000000000000000000000000;;		if bi == 0 && bk == 0 {
0000000000000000000000000000000000000000;;			return wi >= wk
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bk == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bi/bk <= wi/wk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type priorityWriteScheduler struct {
0000000000000000000000000000000000000000;;		// root is the root of the priority tree, where root.id = 0.
0000000000000000000000000000000000000000;;		// The root queues control frames that are not associated with any stream.
0000000000000000000000000000000000000000;;		root priorityNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nodes maps stream ids to priority tree nodes.
0000000000000000000000000000000000000000;;		nodes map[uint32]*priorityNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// maxID is the maximum stream id in nodes.
0000000000000000000000000000000000000000;;		maxID uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lists of nodes that have been closed or are idle, but are kept in
0000000000000000000000000000000000000000;;		// the tree for improved prioritization. When the lengths exceed either
0000000000000000000000000000000000000000;;		// maxClosedNodesInTree or maxIdleNodesInTree, old nodes are discarded.
0000000000000000000000000000000000000000;;		closedNodes, idleNodes []*priorityNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// From the config.
0000000000000000000000000000000000000000;;		maxClosedNodesInTree int
0000000000000000000000000000000000000000;;		maxIdleNodesInTree   int
0000000000000000000000000000000000000000;;		writeThrottleLimit   int32
0000000000000000000000000000000000000000;;		enableWriteThrottle  bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// tmp is scratch space for priorityNode.walkReadyInOrder to reduce allocations.
0000000000000000000000000000000000000000;;		tmp []*priorityNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pool of empty queues for reuse.
0000000000000000000000000000000000000000;;		queuePool writeQueuePool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *priorityWriteScheduler) OpenStream(streamID uint32, options OpenStreamOptions) {
0000000000000000000000000000000000000000;;		// The stream may be currently idle but cannot be opened or closed.
0000000000000000000000000000000000000000;;		if curr := ws.nodes[streamID]; curr != nil {
0000000000000000000000000000000000000000;;			if curr.state != priorityNodeIdle {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("stream %d already opened", streamID))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			curr.state = priorityNodeOpen
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RFC 7540, Section 5.3.5:
0000000000000000000000000000000000000000;;		//  "All streams are initially assigned a non-exclusive dependency on stream 0x0.
0000000000000000000000000000000000000000;;		//  Pushed streams initially depend on their associated stream. In both cases,
0000000000000000000000000000000000000000;;		//  streams are assigned a default weight of 16."
0000000000000000000000000000000000000000;;		parent := ws.nodes[options.PusherID]
0000000000000000000000000000000000000000;;		if parent == nil {
0000000000000000000000000000000000000000;;			parent = &ws.root
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := &priorityNode{
0000000000000000000000000000000000000000;;			q:      *ws.queuePool.get(),
0000000000000000000000000000000000000000;;			id:     streamID,
0000000000000000000000000000000000000000;;			weight: priorityDefaultWeight,
0000000000000000000000000000000000000000;;			state:  priorityNodeOpen,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.setParent(parent)
0000000000000000000000000000000000000000;;		ws.nodes[streamID] = n
0000000000000000000000000000000000000000;;		if streamID > ws.maxID {
0000000000000000000000000000000000000000;;			ws.maxID = streamID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *priorityWriteScheduler) CloseStream(streamID uint32) {
0000000000000000000000000000000000000000;;		if streamID == 0 {
0000000000000000000000000000000000000000;;			panic("violation of WriteScheduler interface: cannot close stream 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ws.nodes[streamID] == nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("violation of WriteScheduler interface: unknown stream %d", streamID))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ws.nodes[streamID].state != priorityNodeOpen {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("violation of WriteScheduler interface: stream %d already closed", streamID))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := ws.nodes[streamID]
0000000000000000000000000000000000000000;;		n.state = priorityNodeClosed
0000000000000000000000000000000000000000;;		n.addBytes(-n.bytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q := n.q
0000000000000000000000000000000000000000;;		ws.queuePool.put(&q)
0000000000000000000000000000000000000000;;		n.q.s = nil
0000000000000000000000000000000000000000;;		if ws.maxClosedNodesInTree > 0 {
0000000000000000000000000000000000000000;;			ws.addClosedOrIdleNode(&ws.closedNodes, ws.maxClosedNodesInTree, n)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ws.removeNode(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *priorityWriteScheduler) AdjustStream(streamID uint32, priority PriorityParam) {
0000000000000000000000000000000000000000;;		if streamID == 0 {
0000000000000000000000000000000000000000;;			panic("adjustPriority on root")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If streamID does not exist, there are two cases:
0000000000000000000000000000000000000000;;		// - A closed stream that has been removed (this will have ID <= maxID)
0000000000000000000000000000000000000000;;		// - An idle stream that is being used for "grouping" (this will have ID > maxID)
0000000000000000000000000000000000000000;;		n := ws.nodes[streamID]
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			if streamID <= ws.maxID || ws.maxIdleNodesInTree == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ws.maxID = streamID
0000000000000000000000000000000000000000;;			n = &priorityNode{
0000000000000000000000000000000000000000;;				q:      *ws.queuePool.get(),
0000000000000000000000000000000000000000;;				id:     streamID,
0000000000000000000000000000000000000000;;				weight: priorityDefaultWeight,
0000000000000000000000000000000000000000;;				state:  priorityNodeIdle,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n.setParent(&ws.root)
0000000000000000000000000000000000000000;;			ws.nodes[streamID] = n
0000000000000000000000000000000000000000;;			ws.addClosedOrIdleNode(&ws.idleNodes, ws.maxIdleNodesInTree, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Section 5.3.1: A dependency on a stream that is not currently in the tree
0000000000000000000000000000000000000000;;		// results in that stream being given a default priority (Section 5.3.5).
0000000000000000000000000000000000000000;;		parent := ws.nodes[priority.StreamDep]
0000000000000000000000000000000000000000;;		if parent == nil {
0000000000000000000000000000000000000000;;			n.setParent(&ws.root)
0000000000000000000000000000000000000000;;			n.weight = priorityDefaultWeight
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore if the client tries to make a node its own parent.
0000000000000000000000000000000000000000;;		if n == parent {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Section 5.3.3:
0000000000000000000000000000000000000000;;		//   "If a stream is made dependent on one of its own dependencies, the
0000000000000000000000000000000000000000;;		//   formerly dependent stream is first moved to be dependent on the
0000000000000000000000000000000000000000;;		//   reprioritized stream's previous parent. The moved dependency retains
0000000000000000000000000000000000000000;;		//   its weight."
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// That is: if parent depends on n, move parent to depend on n.parent.
0000000000000000000000000000000000000000;;		for x := parent.parent; x != nil; x = x.parent {
0000000000000000000000000000000000000000;;			if x == n {
0000000000000000000000000000000000000000;;				parent.setParent(n.parent)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Section 5.3.3: The exclusive flag causes the stream to become the sole
0000000000000000000000000000000000000000;;		// dependency of its parent stream, causing other dependencies to become
0000000000000000000000000000000000000000;;		// dependent on the exclusive stream.
0000000000000000000000000000000000000000;;		if priority.Exclusive {
0000000000000000000000000000000000000000;;			k := parent.kids
0000000000000000000000000000000000000000;;			for k != nil {
0000000000000000000000000000000000000000;;				next := k.next
0000000000000000000000000000000000000000;;				if k != n {
0000000000000000000000000000000000000000;;					k.setParent(n)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				k = next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.setParent(parent)
0000000000000000000000000000000000000000;;		n.weight = priority.Weight
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *priorityWriteScheduler) Push(wr FrameWriteRequest) {
0000000000000000000000000000000000000000;;		var n *priorityNode
0000000000000000000000000000000000000000;;		if id := wr.StreamID(); id == 0 {
0000000000000000000000000000000000000000;;			n = &ws.root
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			n = ws.nodes[id]
0000000000000000000000000000000000000000;;			if n == nil {
0000000000000000000000000000000000000000;;				// id is an idle or closed stream. wr should not be a HEADERS or
0000000000000000000000000000000000000000;;				// DATA frame. However, wr can be a RST_STREAM. In this case, we
0000000000000000000000000000000000000000;;				// push wr onto the root, rather than creating a new priorityNode,
0000000000000000000000000000000000000000;;				// since RST_STREAM is tiny and the stream's priority is unknown
0000000000000000000000000000000000000000;;				// anyway. See issue #17919.
0000000000000000000000000000000000000000;;				if wr.DataSize() > 0 {
0000000000000000000000000000000000000000;;					panic("add DATA on non-open stream")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n = &ws.root
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.q.push(wr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *priorityWriteScheduler) Pop() (wr FrameWriteRequest, ok bool) {
0000000000000000000000000000000000000000;;		ws.root.walkReadyInOrder(false, &ws.tmp, func(n *priorityNode, openParent bool) bool {
0000000000000000000000000000000000000000;;			limit := int32(math.MaxInt32)
0000000000000000000000000000000000000000;;			if openParent {
0000000000000000000000000000000000000000;;				limit = ws.writeThrottleLimit
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wr, ok = n.q.consume(limit)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n.addBytes(int64(wr.DataSize()))
0000000000000000000000000000000000000000;;			// If B depends on A and B continuously has data available but A
0000000000000000000000000000000000000000;;			// does not, gradually increase the throttling limit to allow B to
0000000000000000000000000000000000000000;;			// steal more and more bandwidth from A.
0000000000000000000000000000000000000000;;			if openParent {
0000000000000000000000000000000000000000;;				ws.writeThrottleLimit += 1024
0000000000000000000000000000000000000000;;				if ws.writeThrottleLimit < 0 {
0000000000000000000000000000000000000000;;					ws.writeThrottleLimit = math.MaxInt32
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if ws.enableWriteThrottle {
0000000000000000000000000000000000000000;;				ws.writeThrottleLimit = 1024
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return wr, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *priorityWriteScheduler) addClosedOrIdleNode(list *[]*priorityNode, maxSize int, n *priorityNode) {
0000000000000000000000000000000000000000;;		if maxSize == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(*list) == maxSize {
0000000000000000000000000000000000000000;;			// Remove the oldest node, then shift left.
0000000000000000000000000000000000000000;;			ws.removeNode((*list)[0])
0000000000000000000000000000000000000000;;			x := (*list)[1:]
0000000000000000000000000000000000000000;;			copy(*list, x)
0000000000000000000000000000000000000000;;			*list = (*list)[:len(x)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*list = append(*list, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ws *priorityWriteScheduler) removeNode(n *priorityNode) {
0000000000000000000000000000000000000000;;		for k := n.kids; k != nil; k = k.next {
0000000000000000000000000000000000000000;;			k.setParent(n.parent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.setParent(nil)
0000000000000000000000000000000000000000;;		delete(ws.nodes, n.id)
0000000000000000000000000000000000000000;;	}
