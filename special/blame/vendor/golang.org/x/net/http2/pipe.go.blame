0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/pipe.go[Godeps/_workspace/src/github.com/bradfitz/http2/pipe.go][vendor/golang.org/x/net/http2/pipe.go];	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pipe is a goroutine-safe io.Reader/io.Writer pair.  It's like
0000000000000000000000000000000000000000;;	// io.Pipe except there are no PipeReader/PipeWriter halves, and the
0000000000000000000000000000000000000000;;	// underlying buffer is an interface. (io.Pipe is always unbuffered)
0000000000000000000000000000000000000000;;	type pipe struct {
0000000000000000000000000000000000000000;;		mu       sync.Mutex
0000000000000000000000000000000000000000;;		c        sync.Cond // c.L lazily initialized to &p.mu
0000000000000000000000000000000000000000;;		b        pipeBuffer
0000000000000000000000000000000000000000;;		err      error         // read error once empty. non-nil means closed.
0000000000000000000000000000000000000000;;		breakErr error         // immediate read error (caller doesn't see rest of b)
0000000000000000000000000000000000000000;;		donec    chan struct{} // closed on error
0000000000000000000000000000000000000000;;		readFn   func()        // optional code to run in Read before error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pipeBuffer interface {
0000000000000000000000000000000000000000;;		Len() int
0000000000000000000000000000000000000000;;		io.Writer
0000000000000000000000000000000000000000;;		io.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *pipe) Len() int {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		return p.b.Len()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read waits until data is available and copies bytes
0000000000000000000000000000000000000000;;	// from the buffer into p.
0000000000000000000000000000000000000000;;	func (p *pipe) Read(d []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		if p.c.L == nil {
0000000000000000000000000000000000000000;;			p.c.L = &p.mu
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if p.breakErr != nil {
0000000000000000000000000000000000000000;;				return 0, p.breakErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.b.Len() > 0 {
0000000000000000000000000000000000000000;;				return p.b.Read(d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.err != nil {
0000000000000000000000000000000000000000;;				if p.readFn != nil {
0000000000000000000000000000000000000000;;					p.readFn()     // e.g. copy trailers
0000000000000000000000000000000000000000;;					p.readFn = nil // not sticky like p.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return 0, p.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.c.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errClosedPipeWrite = errors.New("write on closed buffer")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write copies bytes from p into the buffer and wakes a reader.
0000000000000000000000000000000000000000;;	// It is an error to write more data than the buffer can hold.
0000000000000000000000000000000000000000;;	func (p *pipe) Write(d []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		if p.c.L == nil {
0000000000000000000000000000000000000000;;			p.c.L = &p.mu
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer p.c.Signal()
0000000000000000000000000000000000000000;;		if p.err != nil {
0000000000000000000000000000000000000000;;			return 0, errClosedPipeWrite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.b.Write(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseWithError causes the next Read (waking up a current blocked
0000000000000000000000000000000000000000;;	// Read if needed) to return the provided err after all data has been
0000000000000000000000000000000000000000;;	// read.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The error must be non-nil.
0000000000000000000000000000000000000000;;	func (p *pipe) CloseWithError(err error) { p.closeWithError(&p.err, err, nil) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BreakWithError causes the next Read (waking up a current blocked
0000000000000000000000000000000000000000;;	// Read if needed) to return the provided err immediately, without
0000000000000000000000000000000000000000;;	// waiting for unread data.
0000000000000000000000000000000000000000;;	func (p *pipe) BreakWithError(err error) { p.closeWithError(&p.breakErr, err, nil) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// closeWithErrorAndCode is like CloseWithError but also sets some code to run
0000000000000000000000000000000000000000;;	// in the caller's goroutine before returning the error.
0000000000000000000000000000000000000000;;	func (p *pipe) closeWithErrorAndCode(err error, fn func()) { p.closeWithError(&p.err, err, fn) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *pipe) closeWithError(dst *error, err error, fn func()) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			panic("err must be non-nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		if p.c.L == nil {
0000000000000000000000000000000000000000;;			p.c.L = &p.mu
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer p.c.Signal()
0000000000000000000000000000000000000000;;		if *dst != nil {
0000000000000000000000000000000000000000;;			// Already been done.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.readFn = fn
0000000000000000000000000000000000000000;;		*dst = err
0000000000000000000000000000000000000000;;		p.closeDoneLocked()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requires p.mu be held.
0000000000000000000000000000000000000000;;	func (p *pipe) closeDoneLocked() {
0000000000000000000000000000000000000000;;		if p.donec == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Close if unclosed. This isn't racy since we always
0000000000000000000000000000000000000000;;		// hold p.mu while closing.
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-p.donec:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			close(p.donec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Err returns the error (if any) first set by BreakWithError or CloseWithError.
0000000000000000000000000000000000000000;;	func (p *pipe) Err() error {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		if p.breakErr != nil {
0000000000000000000000000000000000000000;;			return p.breakErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Done returns a channel which is closed if and when this pipe is closed
0000000000000000000000000000000000000000;;	// with CloseWithError.
0000000000000000000000000000000000000000;;	func (p *pipe) Done() <-chan struct{} {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		if p.donec == nil {
0000000000000000000000000000000000000000;;			p.donec = make(chan struct{})
0000000000000000000000000000000000000000;;			if p.err != nil || p.breakErr != nil {
0000000000000000000000000000000000000000;;				// Already hit an error.
0000000000000000000000000000000000000000;;				p.closeDoneLocked()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.donec
0000000000000000000000000000000000000000;;	}
