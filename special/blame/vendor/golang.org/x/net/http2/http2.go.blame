0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/http2.go[Godeps/_workspace/src/github.com/bradfitz/http2/http2.go][vendor/golang.org/x/net/http2/http2.go];	
0000000000000000000000000000000000000000;;	// Package http2 implements the HTTP/2 protocol.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This package is low-level and intended to be used directly by very
0000000000000000000000000000000000000000;;	// few people. Most users will use it indirectly through the automatic
0000000000000000000000000000000000000000;;	// use by the net/http package (from Go 1.6 and later).
0000000000000000000000000000000000000000;;	// For use in earlier Go versions see ConfigureServer. (Transport support
0000000000000000000000000000000000000000;;	// requires Go 1.6 or later)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://http2.github.io/ for more information on HTTP/2.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://http2.golang.org/ for a test server running this code.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/lex/httplex"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		VerboseLogs    bool
0000000000000000000000000000000000000000;;		logFrameWrites bool
0000000000000000000000000000000000000000;;		logFrameReads  bool
0000000000000000000000000000000000000000;;		inTests        bool
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		e := os.Getenv("GODEBUG")
0000000000000000000000000000000000000000;;		if strings.Contains(e, "http2debug=1") {
0000000000000000000000000000000000000000;;			VerboseLogs = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(e, "http2debug=2") {
0000000000000000000000000000000000000000;;			VerboseLogs = true
0000000000000000000000000000000000000000;;			logFrameWrites = true
0000000000000000000000000000000000000000;;			logFrameReads = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ClientPreface is the string that must be sent by new
0000000000000000000000000000000000000000;;		// connections from clients.
0000000000000000000000000000000000000000;;		ClientPreface = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SETTINGS_MAX_FRAME_SIZE default
0000000000000000000000000000000000000000;;		// http://http2.github.io/http2-spec/#rfc.section.6.5.2
0000000000000000000000000000000000000000;;		initialMaxFrameSize = 16384
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NextProtoTLS is the NPN/ALPN protocol negotiated during
0000000000000000000000000000000000000000;;		// HTTP/2's TLS setup.
0000000000000000000000000000000000000000;;		NextProtoTLS = "h2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// http://http2.github.io/http2-spec/#SettingValues
0000000000000000000000000000000000000000;;		initialHeaderTableSize = 4096
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		initialWindowSize = 65535 // 6.9.2 Initial Flow Control Window Size
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultMaxReadFrameSize = 1 << 20
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		clientPreface = []byte(ClientPreface)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type streamState int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTP/2 stream states.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See http://tools.ietf.org/html/rfc7540#section-5.1.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For simplicity, the server code merges "reserved (local)" into
0000000000000000000000000000000000000000;;	// "half-closed (remote)". This is one less state transition to track.
0000000000000000000000000000000000000000;;	// The only downside is that we send PUSH_PROMISEs slightly less
0000000000000000000000000000000000000000;;	// liberally than allowable. More discussion here:
0000000000000000000000000000000000000000;;	// https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0599.html
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// "reserved (remote)" is omitted since the client code does not
0000000000000000000000000000000000000000;;	// support server push.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		stateIdle streamState = iota
0000000000000000000000000000000000000000;;		stateOpen
0000000000000000000000000000000000000000;;		stateHalfClosedLocal
0000000000000000000000000000000000000000;;		stateHalfClosedRemote
0000000000000000000000000000000000000000;;		stateClosed
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var stateName = [...]string{
0000000000000000000000000000000000000000;;		stateIdle:             "Idle",
0000000000000000000000000000000000000000;;		stateOpen:             "Open",
0000000000000000000000000000000000000000;;		stateHalfClosedLocal:  "HalfClosedLocal",
0000000000000000000000000000000000000000;;		stateHalfClosedRemote: "HalfClosedRemote",
0000000000000000000000000000000000000000;;		stateClosed:           "Closed",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (st streamState) String() string {
0000000000000000000000000000000000000000;;		return stateName[st]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Setting is a setting parameter: which setting it is, and its value.
0000000000000000000000000000000000000000;;	type Setting struct {
0000000000000000000000000000000000000000;;		// ID is which setting is being set.
0000000000000000000000000000000000000000;;		// See http://http2.github.io/http2-spec/#SettingValues
0000000000000000000000000000000000000000;;		ID SettingID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Val is the value.
0000000000000000000000000000000000000000;;		Val uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s Setting) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("[%v = %d]", s.ID, s.Val)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid reports whether the setting is valid.
0000000000000000000000000000000000000000;;	func (s Setting) Valid() error {
0000000000000000000000000000000000000000;;		// Limits and error codes from 6.5.2 Defined SETTINGS Parameters
0000000000000000000000000000000000000000;;		switch s.ID {
0000000000000000000000000000000000000000;;		case SettingEnablePush:
0000000000000000000000000000000000000000;;			if s.Val != 1 && s.Val != 0 {
0000000000000000000000000000000000000000;;				return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case SettingInitialWindowSize:
0000000000000000000000000000000000000000;;			if s.Val > 1<<31-1 {
0000000000000000000000000000000000000000;;				return ConnectionError(ErrCodeFlowControl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case SettingMaxFrameSize:
0000000000000000000000000000000000000000;;			if s.Val < 16384 || s.Val > 1<<24-1 {
0000000000000000000000000000000000000000;;				return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A SettingID is an HTTP/2 setting as defined in
0000000000000000000000000000000000000000;;	// http://http2.github.io/http2-spec/#iana-settings
0000000000000000000000000000000000000000;;	type SettingID uint16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SettingHeaderTableSize      SettingID = 0x1
0000000000000000000000000000000000000000;;		SettingEnablePush           SettingID = 0x2
0000000000000000000000000000000000000000;;		SettingMaxConcurrentStreams SettingID = 0x3
0000000000000000000000000000000000000000;;		SettingInitialWindowSize    SettingID = 0x4
0000000000000000000000000000000000000000;;		SettingMaxFrameSize         SettingID = 0x5
0000000000000000000000000000000000000000;;		SettingMaxHeaderListSize    SettingID = 0x6
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var settingName = map[SettingID]string{
0000000000000000000000000000000000000000;;		SettingHeaderTableSize:      "HEADER_TABLE_SIZE",
0000000000000000000000000000000000000000;;		SettingEnablePush:           "ENABLE_PUSH",
0000000000000000000000000000000000000000;;		SettingMaxConcurrentStreams: "MAX_CONCURRENT_STREAMS",
0000000000000000000000000000000000000000;;		SettingInitialWindowSize:    "INITIAL_WINDOW_SIZE",
0000000000000000000000000000000000000000;;		SettingMaxFrameSize:         "MAX_FRAME_SIZE",
0000000000000000000000000000000000000000;;		SettingMaxHeaderListSize:    "MAX_HEADER_LIST_SIZE",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SettingID) String() string {
0000000000000000000000000000000000000000;;		if v, ok := settingName[s]; ok {
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("UNKNOWN_SETTING_%d", uint16(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errInvalidHeaderFieldName  = errors.New("http2: invalid header field name")
0000000000000000000000000000000000000000;;		errInvalidHeaderFieldValue = errors.New("http2: invalid header field value")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validWireHeaderFieldName reports whether v is a valid header field
0000000000000000000000000000000000000000;;	// name (key). See httplex.ValidHeaderName for the base rules.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Further, http2 says:
0000000000000000000000000000000000000000;;	//   "Just as in HTTP/1.x, header field names are strings of ASCII
0000000000000000000000000000000000000000;;	//   characters that are compared in a case-insensitive
0000000000000000000000000000000000000000;;	//   fashion. However, header field names MUST be converted to
0000000000000000000000000000000000000000;;	//   lowercase prior to their encoding in HTTP/2. "
0000000000000000000000000000000000000000;;	func validWireHeaderFieldName(v string) bool {
0000000000000000000000000000000000000000;;		if len(v) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, r := range v {
0000000000000000000000000000000000000000;;			if !httplex.IsTokenRune(r) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if 'A' <= r && r <= 'Z' {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var httpCodeStringCommon = map[int]string{} // n -> strconv.Itoa(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		for i := 100; i <= 999; i++ {
0000000000000000000000000000000000000000;;			if v := http.StatusText(i); v != "" {
0000000000000000000000000000000000000000;;				httpCodeStringCommon[i] = strconv.Itoa(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func httpCodeString(code int) string {
0000000000000000000000000000000000000000;;		if s, ok := httpCodeStringCommon[code]; ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.Itoa(code)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// from pkg io
0000000000000000000000000000000000000000;;	type stringWriter interface {
0000000000000000000000000000000000000000;;		WriteString(s string) (n int, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A gate lets two goroutines coordinate their activities.
0000000000000000000000000000000000000000;;	type gate chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g gate) Done() { g <- struct{}{} }
0000000000000000000000000000000000000000;;	func (g gate) Wait() { <-g }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A closeWaiter is like a sync.WaitGroup but only goes 1 to 0 (open to closed).
0000000000000000000000000000000000000000;;	type closeWaiter chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init makes a closeWaiter usable.
0000000000000000000000000000000000000000;;	// It exists because so a closeWaiter value can be placed inside a
0000000000000000000000000000000000000000;;	// larger struct and have the Mutex and Cond's memory in the same
0000000000000000000000000000000000000000;;	// allocation.
0000000000000000000000000000000000000000;;	func (cw *closeWaiter) Init() {
0000000000000000000000000000000000000000;;		*cw = make(chan struct{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close marks the closeWaiter as closed and unblocks any waiters.
0000000000000000000000000000000000000000;;	func (cw closeWaiter) Close() {
0000000000000000000000000000000000000000;;		close(cw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait waits for the closeWaiter to become closed.
0000000000000000000000000000000000000000;;	func (cw closeWaiter) Wait() {
0000000000000000000000000000000000000000;;		<-cw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bufferedWriter is a buffered writer that writes to w.
0000000000000000000000000000000000000000;;	// Its buffered writer is lazily allocated as needed, to minimize
0000000000000000000000000000000000000000;;	// idle memory usage with many connections.
0000000000000000000000000000000000000000;;	type bufferedWriter struct {
0000000000000000000000000000000000000000;;		w  io.Writer     // immutable
0000000000000000000000000000000000000000;;		bw *bufio.Writer // non-nil when data is buffered
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBufferedWriter(w io.Writer) *bufferedWriter {
0000000000000000000000000000000000000000;;		return &bufferedWriter{w: w}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bufWriterPoolBufferSize is the size of bufio.Writer's
0000000000000000000000000000000000000000;;	// buffers created using bufWriterPool.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: pick a less arbitrary value? this is a bit under
0000000000000000000000000000000000000000;;	// (3 x typical 1500 byte MTU) at least. Other than that,
0000000000000000000000000000000000000000;;	// not much thought went into it.
0000000000000000000000000000000000000000;;	const bufWriterPoolBufferSize = 4 << 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bufWriterPool = sync.Pool{
0000000000000000000000000000000000000000;;		New: func() interface{} {
0000000000000000000000000000000000000000;;			return bufio.NewWriterSize(nil, bufWriterPoolBufferSize)
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *bufferedWriter) Available() int {
0000000000000000000000000000000000000000;;		if w.bw == nil {
0000000000000000000000000000000000000000;;			return bufWriterPoolBufferSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.bw.Available()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *bufferedWriter) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if w.bw == nil {
0000000000000000000000000000000000000000;;			bw := bufWriterPool.Get().(*bufio.Writer)
0000000000000000000000000000000000000000;;			bw.Reset(w.w)
0000000000000000000000000000000000000000;;			w.bw = bw
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.bw.Write(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *bufferedWriter) Flush() error {
0000000000000000000000000000000000000000;;		bw := w.bw
0000000000000000000000000000000000000000;;		if bw == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := bw.Flush()
0000000000000000000000000000000000000000;;		bw.Reset(nil)
0000000000000000000000000000000000000000;;		bufWriterPool.Put(bw)
0000000000000000000000000000000000000000;;		w.bw = nil
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mustUint31(v int32) uint32 {
0000000000000000000000000000000000000000;;		if v < 0 || v > 2147483647 {
0000000000000000000000000000000000000000;;			panic("out of range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint32(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bodyAllowedForStatus reports whether a given response status code
0000000000000000000000000000000000000000;;	// permits a body. See RFC 2616, section 4.4.
0000000000000000000000000000000000000000;;	func bodyAllowedForStatus(status int) bool {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case status >= 100 && status <= 199:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case status == 204:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case status == 304:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type httpError struct {
0000000000000000000000000000000000000000;;		msg     string
0000000000000000000000000000000000000000;;		timeout bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *httpError) Error() string   { return e.msg }
0000000000000000000000000000000000000000;;	func (e *httpError) Timeout() bool   { return e.timeout }
0000000000000000000000000000000000000000;;	func (e *httpError) Temporary() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errTimeout error = &httpError{msg: "http2: timeout awaiting response headers", timeout: true}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type connectionStater interface {
0000000000000000000000000000000000000000;;		ConnectionState() tls.ConnectionState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var sorterPool = sync.Pool{New: func() interface{} { return new(sorter) }}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sorter struct {
0000000000000000000000000000000000000000;;		v []string // owned by sorter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sorter) Len() int           { return len(s.v) }
0000000000000000000000000000000000000000;;	func (s *sorter) Swap(i, j int)      { s.v[i], s.v[j] = s.v[j], s.v[i] }
0000000000000000000000000000000000000000;;	func (s *sorter) Less(i, j int) bool { return s.v[i] < s.v[j] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns the sorted keys of h.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The returned slice is only valid until s used again or returned to
0000000000000000000000000000000000000000;;	// its pool.
0000000000000000000000000000000000000000;;	func (s *sorter) Keys(h http.Header) []string {
0000000000000000000000000000000000000000;;		keys := s.v[:0]
0000000000000000000000000000000000000000;;		for k := range h {
0000000000000000000000000000000000000000;;			keys = append(keys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.v = keys
0000000000000000000000000000000000000000;;		sort.Sort(s)
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sorter) SortStrings(ss []string) {
0000000000000000000000000000000000000000;;		// Our sorter works on s.v, which sorter owns, so
0000000000000000000000000000000000000000;;		// stash it away while we sort the user's buffer.
0000000000000000000000000000000000000000;;		save := s.v
0000000000000000000000000000000000000000;;		s.v = ss
0000000000000000000000000000000000000000;;		sort.Sort(s)
0000000000000000000000000000000000000000;;		s.v = save
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validPseudoPath reports whether v is a valid :path pseudo-header
0000000000000000000000000000000000000000;;	// value. It must be either:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     *) a non-empty string starting with '/', but not with with "//",
0000000000000000000000000000000000000000;;	//     *) the string '*', for OPTIONS requests.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For now this is only used a quick check for deciding when to clean
0000000000000000000000000000000000000000;;	// up Opaque URLs before sending requests from the Transport.
0000000000000000000000000000000000000000;;	// See golang.org/issue/16847
0000000000000000000000000000000000000000;;	func validPseudoPath(v string) bool {
0000000000000000000000000000000000000000;;		return (len(v) > 0 && v[0] == '/' && (len(v) == 1 || v[1] != '/')) || v == "*"
0000000000000000000000000000000000000000;;	}
