0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/buffer.go[Godeps/_workspace/src/github.com/bradfitz/http2/buffer.go][vendor/golang.org/x/net/http2/fixed_buffer.go];	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fixedBuffer is an io.ReadWriter backed by a fixed size buffer.
0000000000000000000000000000000000000000;;	// It never allocates, but moves old data as new data is written.
0000000000000000000000000000000000000000;;	type fixedBuffer struct {
0000000000000000000000000000000000000000;;		buf  []byte
0000000000000000000000000000000000000000;;		r, w int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errReadEmpty = errors.New("read from empty fixedBuffer")
0000000000000000000000000000000000000000;;		errWriteFull = errors.New("write on full fixedBuffer")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read copies bytes from the buffer into p.
0000000000000000000000000000000000000000;;	// It is an error to read when no data is available.
0000000000000000000000000000000000000000;;	func (b *fixedBuffer) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if b.r == b.w {
0000000000000000000000000000000000000000;;			return 0, errReadEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n = copy(p, b.buf[b.r:b.w])
0000000000000000000000000000000000000000;;		b.r += n
0000000000000000000000000000000000000000;;		if b.r == b.w {
0000000000000000000000000000000000000000;;			b.r = 0
0000000000000000000000000000000000000000;;			b.w = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of bytes of the unread portion of the buffer.
0000000000000000000000000000000000000000;;	func (b *fixedBuffer) Len() int {
0000000000000000000000000000000000000000;;		return b.w - b.r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write copies bytes from p into the buffer.
0000000000000000000000000000000000000000;;	// It is an error to write more data than the buffer can hold.
0000000000000000000000000000000000000000;;	func (b *fixedBuffer) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		// Slide existing data to beginning.
0000000000000000000000000000000000000000;;		if b.r > 0 && len(p) > len(b.buf)-b.w {
0000000000000000000000000000000000000000;;			copy(b.buf, b.buf[b.r:b.w])
0000000000000000000000000000000000000000;;			b.w -= b.r
0000000000000000000000000000000000000000;;			b.r = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write new data.
0000000000000000000000000000000000000000;;		n = copy(b.buf[b.w:], p)
0000000000000000000000000000000000000000;;		b.w += n
0000000000000000000000000000000000000000;;		if n < len(p) {
0000000000000000000000000000000000000000;;			err = errWriteFull
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
