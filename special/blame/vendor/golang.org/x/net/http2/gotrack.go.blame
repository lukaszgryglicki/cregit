0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/gotrack.go[Godeps/_workspace/src/github.com/bradfitz/http2/gotrack.go][vendor/golang.org/x/net/http2/gotrack.go];	
0000000000000000000000000000000000000000;;	// Defensive debug-only utility to track that functions run on the
0000000000000000000000000000000000000000;;	// goroutine that they're supposed to.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var DebugGoroutines = os.Getenv("DEBUG_HTTP2_GOROUTINES") == "1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type goroutineLock uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newGoroutineLock() goroutineLock {
0000000000000000000000000000000000000000;;		if !DebugGoroutines {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return goroutineLock(curGoroutineID())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g goroutineLock) check() {
0000000000000000000000000000000000000000;;		if !DebugGoroutines {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if curGoroutineID() != uint64(g) {
0000000000000000000000000000000000000000;;			panic("running on the wrong goroutine")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g goroutineLock) checkNotOn() {
0000000000000000000000000000000000000000;;		if !DebugGoroutines {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if curGoroutineID() == uint64(g) {
0000000000000000000000000000000000000000;;			panic("running on the wrong goroutine")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var goroutineSpace = []byte("goroutine ")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func curGoroutineID() uint64 {
0000000000000000000000000000000000000000;;		bp := littleBuf.Get().(*[]byte)
0000000000000000000000000000000000000000;;		defer littleBuf.Put(bp)
0000000000000000000000000000000000000000;;		b := *bp
0000000000000000000000000000000000000000;;		b = b[:runtime.Stack(b, false)]
0000000000000000000000000000000000000000;;		// Parse the 4707 out of "goroutine 4707 ["
0000000000000000000000000000000000000000;;		b = bytes.TrimPrefix(b, goroutineSpace)
0000000000000000000000000000000000000000;;		i := bytes.IndexByte(b, ' ')
0000000000000000000000000000000000000000;;		if i < 0 {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("No space found in %q", b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b = b[:i]
0000000000000000000000000000000000000000;;		n, err := parseUintBytes(b, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("Failed to parse goroutine ID out of %q: %v", b, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var littleBuf = sync.Pool{
0000000000000000000000000000000000000000;;		New: func() interface{} {
0000000000000000000000000000000000000000;;			buf := make([]byte, 64)
0000000000000000000000000000000000000000;;			return &buf
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseUintBytes is like strconv.ParseUint, but using a []byte.
0000000000000000000000000000000000000000;;	func parseUintBytes(s []byte, base int, bitSize int) (n uint64, err error) {
0000000000000000000000000000000000000000;;		var cutoff, maxVal uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bitSize == 0 {
0000000000000000000000000000000000000000;;			bitSize = int(strconv.IntSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s0 := s
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(s) < 1:
0000000000000000000000000000000000000000;;			err = strconv.ErrSyntax
0000000000000000000000000000000000000000;;			goto Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 2 <= base && base <= 36:
0000000000000000000000000000000000000000;;			// valid base; nothing to do
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case base == 0:
0000000000000000000000000000000000000000;;			// Look for octal, hex prefix.
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X'):
0000000000000000000000000000000000000000;;				base = 16
0000000000000000000000000000000000000000;;				s = s[2:]
0000000000000000000000000000000000000000;;				if len(s) < 1 {
0000000000000000000000000000000000000000;;					err = strconv.ErrSyntax
0000000000000000000000000000000000000000;;					goto Error
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case s[0] == '0':
0000000000000000000000000000000000000000;;				base = 8
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				base = 10
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = errors.New("invalid base " + strconv.Itoa(base))
0000000000000000000000000000000000000000;;			goto Error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n = 0
0000000000000000000000000000000000000000;;		cutoff = cutoff64(base)
0000000000000000000000000000000000000000;;		maxVal = 1<<uint(bitSize) - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			var v byte
0000000000000000000000000000000000000000;;			d := s[i]
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case '0' <= d && d <= '9':
0000000000000000000000000000000000000000;;				v = d - '0'
0000000000000000000000000000000000000000;;			case 'a' <= d && d <= 'z':
0000000000000000000000000000000000000000;;				v = d - 'a' + 10
0000000000000000000000000000000000000000;;			case 'A' <= d && d <= 'Z':
0000000000000000000000000000000000000000;;				v = d - 'A' + 10
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				n = 0
0000000000000000000000000000000000000000;;				err = strconv.ErrSyntax
0000000000000000000000000000000000000000;;				goto Error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if int(v) >= base {
0000000000000000000000000000000000000000;;				n = 0
0000000000000000000000000000000000000000;;				err = strconv.ErrSyntax
0000000000000000000000000000000000000000;;				goto Error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if n >= cutoff {
0000000000000000000000000000000000000000;;				// n*base overflows
0000000000000000000000000000000000000000;;				n = 1<<64 - 1
0000000000000000000000000000000000000000;;				err = strconv.ErrRange
0000000000000000000000000000000000000000;;				goto Error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n *= uint64(base)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n1 := n + uint64(v)
0000000000000000000000000000000000000000;;			if n1 < n || n1 > maxVal {
0000000000000000000000000000000000000000;;				// n+v overflows
0000000000000000000000000000000000000000;;				n = 1<<64 - 1
0000000000000000000000000000000000000000;;				err = strconv.ErrRange
0000000000000000000000000000000000000000;;				goto Error
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n = n1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Error:
0000000000000000000000000000000000000000;;		return n, &strconv.NumError{Func: "ParseUint", Num: string(s0), Err: err}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return the first number n such that n*base >= 1<<64.
0000000000000000000000000000000000000000;;	func cutoff64(base int) uint64 {
0000000000000000000000000000000000000000;;		if base < 2 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (1<<64-1)/uint64(base) + 1
0000000000000000000000000000000000000000;;	}
