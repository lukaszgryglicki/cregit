0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
9bf82937ec2c61ef2f0dca3af92c234867d12038;;	
0000000000000000000000000000000000000000;;	// Transport code's client connection pooling.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConnPool manages a pool of HTTP/2 client connections.
0000000000000000000000000000000000000000;;	type ClientConnPool interface {
0000000000000000000000000000000000000000;;		GetClientConn(req *http.Request, addr string) (*ClientConn, error)
0000000000000000000000000000000000000000;;		MarkDead(*ClientConn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientConnPoolIdleCloser is the interface implemented by ClientConnPool
0000000000000000000000000000000000000000;;	// implementations which can close their idle connections.
0000000000000000000000000000000000000000;;	type clientConnPoolIdleCloser interface {
0000000000000000000000000000000000000000;;		ClientConnPool
0000000000000000000000000000000000000000;;		closeIdleConnections()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ clientConnPoolIdleCloser = (*clientConnPool)(nil)
0000000000000000000000000000000000000000;;		_ clientConnPoolIdleCloser = noDialClientConnPool{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: use singleflight for dialing and addConnCalls?
0000000000000000000000000000000000000000;;	type clientConnPool struct {
0000000000000000000000000000000000000000;;		t *Transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu sync.Mutex // TODO: maybe switch to RWMutex
0000000000000000000000000000000000000000;;		// TODO: add support for sharing conns based on cert names
0000000000000000000000000000000000000000;;		// (e.g. share conn for googleapis.com and appspot.com)
0000000000000000000000000000000000000000;;		conns        map[string][]*ClientConn // key is host:port
0000000000000000000000000000000000000000;;		dialing      map[string]*dialCall     // currently in-flight dials
0000000000000000000000000000000000000000;;		keys         map[*ClientConn][]string
0000000000000000000000000000000000000000;;		addConnCalls map[string]*addConnCall // in-flight addConnIfNeede calls
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *clientConnPool) GetClientConn(req *http.Request, addr string) (*ClientConn, error) {
0000000000000000000000000000000000000000;;		return p.getClientConn(req, addr, dialOnMiss)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		dialOnMiss   = true
0000000000000000000000000000000000000000;;		noDialOnMiss = false
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *clientConnPool) getClientConn(req *http.Request, addr string, dialOnMiss bool) (*ClientConn, error) {
0000000000000000000000000000000000000000;;		if isConnectionCloseRequest(req) && dialOnMiss {
0000000000000000000000000000000000000000;;			// It gets its own connection.
0000000000000000000000000000000000000000;;			const singleUse = true
0000000000000000000000000000000000000000;;			cc, err := p.t.dialClientConn(addr, singleUse)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		for _, cc := range p.conns[addr] {
0000000000000000000000000000000000000000;;			if cc.CanTakeNewRequest() {
0000000000000000000000000000000000000000;;				p.mu.Unlock()
0000000000000000000000000000000000000000;;				return cc, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !dialOnMiss {
0000000000000000000000000000000000000000;;			p.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil, ErrNoCachedConn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		call := p.getStartDialLocked(addr)
0000000000000000000000000000000000000000;;		p.mu.Unlock()
0000000000000000000000000000000000000000;;		<-call.done
0000000000000000000000000000000000000000;;		return call.res, call.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dialCall is an in-flight Transport dial call to a host.
0000000000000000000000000000000000000000;;	type dialCall struct {
0000000000000000000000000000000000000000;;		p    *clientConnPool
0000000000000000000000000000000000000000;;		done chan struct{} // closed when done
0000000000000000000000000000000000000000;;		res  *ClientConn   // valid after done is closed
0000000000000000000000000000000000000000;;		err  error         // valid after done is closed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requires p.mu is held.
0000000000000000000000000000000000000000;;	func (p *clientConnPool) getStartDialLocked(addr string) *dialCall {
0000000000000000000000000000000000000000;;		if call, ok := p.dialing[addr]; ok {
0000000000000000000000000000000000000000;;			// A dial is already in-flight. Don't start another.
0000000000000000000000000000000000000000;;			return call
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		call := &dialCall{p: p, done: make(chan struct{})}
0000000000000000000000000000000000000000;;		if p.dialing == nil {
0000000000000000000000000000000000000000;;			p.dialing = make(map[string]*dialCall)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.dialing[addr] = call
0000000000000000000000000000000000000000;;		go call.dial(addr)
0000000000000000000000000000000000000000;;		return call
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// run in its own goroutine.
0000000000000000000000000000000000000000;;	func (c *dialCall) dial(addr string) {
0000000000000000000000000000000000000000;;		const singleUse = false // shared conn
0000000000000000000000000000000000000000;;		c.res, c.err = c.p.t.dialClientConn(addr, singleUse)
0000000000000000000000000000000000000000;;		close(c.done)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.p.mu.Lock()
0000000000000000000000000000000000000000;;		delete(c.p.dialing, addr)
0000000000000000000000000000000000000000;;		if c.err == nil {
0000000000000000000000000000000000000000;;			c.p.addConnLocked(addr, c.res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.p.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addConnIfNeeded makes a NewClientConn out of c if a connection for key doesn't
0000000000000000000000000000000000000000;;	// already exist. It coalesces concurrent calls with the same key.
0000000000000000000000000000000000000000;;	// This is used by the http1 Transport code when it creates a new connection. Because
0000000000000000000000000000000000000000;;	// the http1 Transport doesn't de-dup TCP dials to outbound hosts (because it doesn't know
0000000000000000000000000000000000000000;;	// the protocol), it can get into a situation where it has multiple TLS connections.
0000000000000000000000000000000000000000;;	// This code decides which ones live or die.
0000000000000000000000000000000000000000;;	// The return value used is whether c was used.
0000000000000000000000000000000000000000;;	// c is never closed.
0000000000000000000000000000000000000000;;	func (p *clientConnPool) addConnIfNeeded(key string, t *Transport, c *tls.Conn) (used bool, err error) {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		for _, cc := range p.conns[key] {
0000000000000000000000000000000000000000;;			if cc.CanTakeNewRequest() {
0000000000000000000000000000000000000000;;				p.mu.Unlock()
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		call, dup := p.addConnCalls[key]
0000000000000000000000000000000000000000;;		if !dup {
0000000000000000000000000000000000000000;;			if p.addConnCalls == nil {
0000000000000000000000000000000000000000;;				p.addConnCalls = make(map[string]*addConnCall)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			call = &addConnCall{
0000000000000000000000000000000000000000;;				p:    p,
0000000000000000000000000000000000000000;;				done: make(chan struct{}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.addConnCalls[key] = call
0000000000000000000000000000000000000000;;			go call.run(t, key, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-call.done
0000000000000000000000000000000000000000;;		if call.err != nil {
0000000000000000000000000000000000000000;;			return false, call.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return !dup, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type addConnCall struct {
0000000000000000000000000000000000000000;;		p    *clientConnPool
0000000000000000000000000000000000000000;;		done chan struct{} // closed when done
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *addConnCall) run(t *Transport, key string, tc *tls.Conn) {
0000000000000000000000000000000000000000;;		cc, err := t.NewClientConn(tc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := c.p
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			c.err = err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.addConnLocked(key, cc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(p.addConnCalls, key)
0000000000000000000000000000000000000000;;		p.mu.Unlock()
0000000000000000000000000000000000000000;;		close(c.done)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *clientConnPool) addConn(key string, cc *ClientConn) {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		p.addConnLocked(key, cc)
0000000000000000000000000000000000000000;;		p.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// p.mu must be held
0000000000000000000000000000000000000000;;	func (p *clientConnPool) addConnLocked(key string, cc *ClientConn) {
0000000000000000000000000000000000000000;;		for _, v := range p.conns[key] {
0000000000000000000000000000000000000000;;			if v == cc {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.conns == nil {
0000000000000000000000000000000000000000;;			p.conns = make(map[string][]*ClientConn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.keys == nil {
0000000000000000000000000000000000000000;;			p.keys = make(map[*ClientConn][]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.conns[key] = append(p.conns[key], cc)
0000000000000000000000000000000000000000;;		p.keys[cc] = append(p.keys[cc], key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *clientConnPool) MarkDead(cc *ClientConn) {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		for _, key := range p.keys[cc] {
0000000000000000000000000000000000000000;;			vv, ok := p.conns[key]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newList := filterOutClientConn(vv, cc)
0000000000000000000000000000000000000000;;			if len(newList) > 0 {
0000000000000000000000000000000000000000;;				p.conns[key] = newList
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				delete(p.conns, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(p.keys, cc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *clientConnPool) closeIdleConnections() {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		// TODO: don't close a cc if it was just added to the pool
0000000000000000000000000000000000000000;;		// milliseconds ago and has never been used. There's currently
0000000000000000000000000000000000000000;;		// a small race window with the HTTP/1 Transport's integration
0000000000000000000000000000000000000000;;		// where it can add an idle conn just before using it, and
0000000000000000000000000000000000000000;;		// somebody else can concurrently call CloseIdleConns and
0000000000000000000000000000000000000000;;		// break some caller's RoundTrip.
0000000000000000000000000000000000000000;;		for _, vv := range p.conns {
0000000000000000000000000000000000000000;;			for _, cc := range vv {
0000000000000000000000000000000000000000;;				cc.closeIfIdle()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func filterOutClientConn(in []*ClientConn, exclude *ClientConn) []*ClientConn {
0000000000000000000000000000000000000000;;		out := in[:0]
0000000000000000000000000000000000000000;;		for _, v := range in {
0000000000000000000000000000000000000000;;			if v != exclude {
0000000000000000000000000000000000000000;;				out = append(out, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we filtered it out, zero out the last item to prevent
0000000000000000000000000000000000000000;;		// the GC from seeing it.
0000000000000000000000000000000000000000;;		if len(in) != len(out) {
0000000000000000000000000000000000000000;;			in[len(in)-1] = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// noDialClientConnPool is an implementation of http2.ClientConnPool
0000000000000000000000000000000000000000;;	// which never dials.  We let the HTTP/1.1 client dial and use its TLS
0000000000000000000000000000000000000000;;	// connection instead.
0000000000000000000000000000000000000000;;	type noDialClientConnPool struct{ *clientConnPool }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p noDialClientConnPool) GetClientConn(req *http.Request, addr string) (*ClientConn, error) {
0000000000000000000000000000000000000000;;		return p.getClientConn(req, addr, noDialOnMiss)
0000000000000000000000000000000000000000;;	}
