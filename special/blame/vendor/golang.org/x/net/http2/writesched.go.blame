0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/writesched.go[Godeps/_workspace/src/github.com/bradfitz/http2/writesched.go][vendor/golang.org/x/net/http2/writesched.go];	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteScheduler is the interface implemented by HTTP/2 write schedulers.
0000000000000000000000000000000000000000;;	// Methods are never called concurrently.
0000000000000000000000000000000000000000;;	type WriteScheduler interface {
0000000000000000000000000000000000000000;;		// OpenStream opens a new stream in the write scheduler.
0000000000000000000000000000000000000000;;		// It is illegal to call this with streamID=0 or with a streamID that is
0000000000000000000000000000000000000000;;		// already open -- the call may panic.
0000000000000000000000000000000000000000;;		OpenStream(streamID uint32, options OpenStreamOptions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CloseStream closes a stream in the write scheduler. Any frames queued on
0000000000000000000000000000000000000000;;		// this stream should be discarded. It is illegal to call this on a stream
0000000000000000000000000000000000000000;;		// that is not open -- the call may panic.
0000000000000000000000000000000000000000;;		CloseStream(streamID uint32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AdjustStream adjusts the priority of the given stream. This may be called
0000000000000000000000000000000000000000;;		// on a stream that has not yet been opened or has been closed. Note that
0000000000000000000000000000000000000000;;		// RFC 7540 allows PRIORITY frames to be sent on streams in any state. See:
0000000000000000000000000000000000000000;;		// https://tools.ietf.org/html/rfc7540#section-5.1
0000000000000000000000000000000000000000;;		AdjustStream(streamID uint32, priority PriorityParam)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Push queues a frame in the scheduler. In most cases, this will not be
0000000000000000000000000000000000000000;;		// called with wr.StreamID()!=0 unless that stream is currently open. The one
0000000000000000000000000000000000000000;;		// exception is RST_STREAM frames, which may be sent on idle or closed streams.
0000000000000000000000000000000000000000;;		Push(wr FrameWriteRequest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pop dequeues the next frame to write. Returns false if no frames can
0000000000000000000000000000000000000000;;		// be written. Frames with a given wr.StreamID() are Pop'd in the same
0000000000000000000000000000000000000000;;		// order they are Push'd.
0000000000000000000000000000000000000000;;		Pop() (wr FrameWriteRequest, ok bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenStreamOptions specifies extra options for WriteScheduler.OpenStream.
0000000000000000000000000000000000000000;;	type OpenStreamOptions struct {
0000000000000000000000000000000000000000;;		// PusherID is zero if the stream was initiated by the client. Otherwise,
0000000000000000000000000000000000000000;;		// PusherID names the stream that pushed the newly opened stream.
0000000000000000000000000000000000000000;;		PusherID uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FrameWriteRequest is a request to write a frame.
0000000000000000000000000000000000000000;;	type FrameWriteRequest struct {
0000000000000000000000000000000000000000;;		// write is the interface value that does the writing, once the
0000000000000000000000000000000000000000;;		// WriteScheduler has selected this frame to write. The write
0000000000000000000000000000000000000000;;		// functions are all defined in write.go.
0000000000000000000000000000000000000000;;		write writeFramer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// stream is the stream on which this frame will be written.
0000000000000000000000000000000000000000;;		// nil for non-stream frames like PING and SETTINGS.
0000000000000000000000000000000000000000;;		stream *stream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// done, if non-nil, must be a buffered channel with space for
0000000000000000000000000000000000000000;;		// 1 message and is sent the return value from write (or an
0000000000000000000000000000000000000000;;		// earlier error) when the frame has been written.
0000000000000000000000000000000000000000;;		done chan error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamID returns the id of the stream this frame will be written to.
0000000000000000000000000000000000000000;;	// 0 is used for non-stream frames such as PING and SETTINGS.
0000000000000000000000000000000000000000;;	func (wr FrameWriteRequest) StreamID() uint32 {
0000000000000000000000000000000000000000;;		if wr.stream == nil {
0000000000000000000000000000000000000000;;			if se, ok := wr.write.(StreamError); ok {
0000000000000000000000000000000000000000;;				// (*serverConn).resetStream doesn't set
0000000000000000000000000000000000000000;;				// stream because it doesn't necessarily have
0000000000000000000000000000000000000000;;				// one. So special case this type of write
0000000000000000000000000000000000000000;;				// message.
0000000000000000000000000000000000000000;;				return se.StreamID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wr.stream.id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DataSize returns the number of flow control bytes that must be consumed
0000000000000000000000000000000000000000;;	// to write this entire frame. This is 0 for non-DATA frames.
0000000000000000000000000000000000000000;;	func (wr FrameWriteRequest) DataSize() int {
0000000000000000000000000000000000000000;;		if wd, ok := wr.write.(*writeData); ok {
0000000000000000000000000000000000000000;;			return len(wd.p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Consume consumes min(n, available) bytes from this frame, where available
0000000000000000000000000000000000000000;;	// is the number of flow control bytes available on the stream. Consume returns
0000000000000000000000000000000000000000;;	// 0, 1, or 2 frames, where the integer return value gives the number of frames
0000000000000000000000000000000000000000;;	// returned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If flow control prevents consuming any bytes, this returns (_, _, 0). If
0000000000000000000000000000000000000000;;	// the entire frame was consumed, this returns (wr, _, 1). Otherwise, this
0000000000000000000000000000000000000000;;	// returns (consumed, rest, 2), where 'consumed' contains the consumed bytes and
0000000000000000000000000000000000000000;;	// 'rest' contains the remaining bytes. The consumed bytes are deducted from the
0000000000000000000000000000000000000000;;	// underlying stream's flow control budget.
0000000000000000000000000000000000000000;;	func (wr FrameWriteRequest) Consume(n int32) (FrameWriteRequest, FrameWriteRequest, int) {
0000000000000000000000000000000000000000;;		var empty FrameWriteRequest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Non-DATA frames are always consumed whole.
0000000000000000000000000000000000000000;;		wd, ok := wr.write.(*writeData)
0000000000000000000000000000000000000000;;		if !ok || len(wd.p) == 0 {
0000000000000000000000000000000000000000;;			return wr, empty, 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Might need to split after applying limits.
0000000000000000000000000000000000000000;;		allowed := wr.stream.flow.available()
0000000000000000000000000000000000000000;;		if n < allowed {
0000000000000000000000000000000000000000;;			allowed = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wr.stream.sc.maxFrameSize < allowed {
0000000000000000000000000000000000000000;;			allowed = wr.stream.sc.maxFrameSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if allowed <= 0 {
0000000000000000000000000000000000000000;;			return empty, empty, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(wd.p) > int(allowed) {
0000000000000000000000000000000000000000;;			wr.stream.flow.take(allowed)
0000000000000000000000000000000000000000;;			consumed := FrameWriteRequest{
0000000000000000000000000000000000000000;;				stream: wr.stream,
0000000000000000000000000000000000000000;;				write: &writeData{
0000000000000000000000000000000000000000;;					streamID: wd.streamID,
0000000000000000000000000000000000000000;;					p:        wd.p[:allowed],
0000000000000000000000000000000000000000;;					// Even if the original had endStream set, there
0000000000000000000000000000000000000000;;					// are bytes remaining because len(wd.p) > allowed,
0000000000000000000000000000000000000000;;					// so we know endStream is false.
0000000000000000000000000000000000000000;;					endStream: false,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// Our caller is blocking on the final DATA frame, not
0000000000000000000000000000000000000000;;				// this intermediate frame, so no need to wait.
0000000000000000000000000000000000000000;;				done: nil,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rest := FrameWriteRequest{
0000000000000000000000000000000000000000;;				stream: wr.stream,
0000000000000000000000000000000000000000;;				write: &writeData{
0000000000000000000000000000000000000000;;					streamID:  wd.streamID,
0000000000000000000000000000000000000000;;					p:         wd.p[allowed:],
0000000000000000000000000000000000000000;;					endStream: wd.endStream,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				done: wr.done,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return consumed, rest, 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The frame is consumed whole.
0000000000000000000000000000000000000000;;		// NB: This cast cannot overflow because allowed is <= math.MaxInt32.
0000000000000000000000000000000000000000;;		wr.stream.flow.take(int32(len(wd.p)))
0000000000000000000000000000000000000000;;		return wr, empty, 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String is for debugging only.
0000000000000000000000000000000000000000;;	func (wr FrameWriteRequest) String() string {
0000000000000000000000000000000000000000;;		var des string
0000000000000000000000000000000000000000;;		if s, ok := wr.write.(fmt.Stringer); ok {
0000000000000000000000000000000000000000;;			des = s.String()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			des = fmt.Sprintf("%T", wr.write)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("[FrameWriteRequest stream=%d, ch=%v, writer=%v]", wr.StreamID(), wr.done != nil, des)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// replyToWriter sends err to wr.done and panics if the send must block
0000000000000000000000000000000000000000;;	// This does nothing if wr.done is nil.
0000000000000000000000000000000000000000;;	func (wr *FrameWriteRequest) replyToWriter(err error) {
0000000000000000000000000000000000000000;;		if wr.done == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case wr.done <- err:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unbuffered done channel passed in for type %T", wr.write))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wr.write = nil // prevent use (assume it's tainted after wr.done send)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeQueue is used by implementations of WriteScheduler.
0000000000000000000000000000000000000000;;	type writeQueue struct {
0000000000000000000000000000000000000000;;		s []FrameWriteRequest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *writeQueue) empty() bool { return len(q.s) == 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *writeQueue) push(wr FrameWriteRequest) {
0000000000000000000000000000000000000000;;		q.s = append(q.s, wr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *writeQueue) shift() FrameWriteRequest {
0000000000000000000000000000000000000000;;		if len(q.s) == 0 {
0000000000000000000000000000000000000000;;			panic("invalid use of queue")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wr := q.s[0]
0000000000000000000000000000000000000000;;		// TODO: less copy-happy queue.
0000000000000000000000000000000000000000;;		copy(q.s, q.s[1:])
0000000000000000000000000000000000000000;;		q.s[len(q.s)-1] = FrameWriteRequest{}
0000000000000000000000000000000000000000;;		q.s = q.s[:len(q.s)-1]
0000000000000000000000000000000000000000;;		return wr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// consume consumes up to n bytes from q.s[0]. If the frame is
0000000000000000000000000000000000000000;;	// entirely consumed, it is removed from the queue. If the frame
0000000000000000000000000000000000000000;;	// is partially consumed, the frame is kept with the consumed
0000000000000000000000000000000000000000;;	// bytes removed. Returns true iff any bytes were consumed.
0000000000000000000000000000000000000000;;	func (q *writeQueue) consume(n int32) (FrameWriteRequest, bool) {
0000000000000000000000000000000000000000;;		if len(q.s) == 0 {
0000000000000000000000000000000000000000;;			return FrameWriteRequest{}, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		consumed, rest, numresult := q.s[0].Consume(n)
0000000000000000000000000000000000000000;;		switch numresult {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return FrameWriteRequest{}, false
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			q.shift()
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			q.s[0] = rest
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return consumed, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type writeQueuePool []*writeQueue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// put inserts an unused writeQueue into the pool.
0000000000000000000000000000000000000000;;	func (p *writeQueuePool) put(q *writeQueue) {
0000000000000000000000000000000000000000;;		for i := range q.s {
0000000000000000000000000000000000000000;;			q.s[i] = FrameWriteRequest{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.s = q.s[:0]
0000000000000000000000000000000000000000;;		*p = append(*p, q)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get returns an empty writeQueue.
0000000000000000000000000000000000000000;;	func (p *writeQueuePool) get() *writeQueue {
0000000000000000000000000000000000000000;;		ln := len(*p)
0000000000000000000000000000000000000000;;		if ln == 0 {
0000000000000000000000000000000000000000;;			return new(writeQueue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := ln - 1
0000000000000000000000000000000000000000;;		q := (*p)[x]
0000000000000000000000000000000000000000;;		(*p)[x] = nil
0000000000000000000000000000000000000000;;		*p = (*p)[:x]
0000000000000000000000000000000000000000;;		return q
0000000000000000000000000000000000000000;;	}
