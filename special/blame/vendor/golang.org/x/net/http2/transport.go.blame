0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/bradfitz/http2/transport.go[Godeps/_workspace/src/github.com/bradfitz/http2/transport.go][vendor/golang.org/x/net/http2/transport.go];	
0000000000000000000000000000000000000000;;	// Transport code.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package http2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2/hpack"
0000000000000000000000000000000000000000;;		"golang.org/x/net/idna"
0000000000000000000000000000000000000000;;		"golang.org/x/net/lex/httplex"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// transportDefaultConnFlow is how many connection-level flow control
0000000000000000000000000000000000000000;;		// tokens we give the server at start-up, past the default 64k.
0000000000000000000000000000000000000000;;		transportDefaultConnFlow = 1 << 30
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// transportDefaultStreamFlow is how many stream-level flow
0000000000000000000000000000000000000000;;		// control tokens we announce to the peer, and how many bytes
0000000000000000000000000000000000000000;;		// we buffer per stream.
0000000000000000000000000000000000000000;;		transportDefaultStreamFlow = 4 << 20
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// transportDefaultStreamMinRefresh is the minimum number of bytes we'll send
0000000000000000000000000000000000000000;;		// a stream-level WINDOW_UPDATE for at a time.
0000000000000000000000000000000000000000;;		transportDefaultStreamMinRefresh = 4 << 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultUserAgent = "Go-http-client/2.0"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transport is an HTTP/2 Transport.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A Transport internally caches connections to servers. It is safe
0000000000000000000000000000000000000000;;	// for concurrent use by multiple goroutines.
0000000000000000000000000000000000000000;;	type Transport struct {
0000000000000000000000000000000000000000;;		// DialTLS specifies an optional dial function for creating
0000000000000000000000000000000000000000;;		// TLS connections for requests.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If DialTLS is nil, tls.Dial is used.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the returned net.Conn has a ConnectionState method like tls.Conn,
0000000000000000000000000000000000000000;;		// it will be used to set http.Response.TLS.
0000000000000000000000000000000000000000;;		DialTLS func(network, addr string, cfg *tls.Config) (net.Conn, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLSClientConfig specifies the TLS configuration to use with
0000000000000000000000000000000000000000;;		// tls.Client. If nil, the default configuration is used.
0000000000000000000000000000000000000000;;		TLSClientConfig *tls.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConnPool optionally specifies an alternate connection pool to use.
0000000000000000000000000000000000000000;;		// If nil, the default is used.
0000000000000000000000000000000000000000;;		ConnPool ClientConnPool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DisableCompression, if true, prevents the Transport from
0000000000000000000000000000000000000000;;		// requesting compression with an "Accept-Encoding: gzip"
0000000000000000000000000000000000000000;;		// request header when the Request contains no existing
0000000000000000000000000000000000000000;;		// Accept-Encoding value. If the Transport requests gzip on
0000000000000000000000000000000000000000;;		// its own and gets a gzipped response, it's transparently
0000000000000000000000000000000000000000;;		// decoded in the Response.Body. However, if the user
0000000000000000000000000000000000000000;;		// explicitly requested gzip it is not automatically
0000000000000000000000000000000000000000;;		// uncompressed.
0000000000000000000000000000000000000000;;		DisableCompression bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AllowHTTP, if true, permits HTTP/2 requests using the insecure,
0000000000000000000000000000000000000000;;		// plain-text "http" scheme. Note that this does not enable h2c support.
0000000000000000000000000000000000000000;;		AllowHTTP bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxHeaderListSize is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to
0000000000000000000000000000000000000000;;		// send in the initial settings frame. It is how many bytes
0000000000000000000000000000000000000000;;		// of response headers are allow. Unlike the http2 spec, zero here
0000000000000000000000000000000000000000;;		// means to use a default limit (currently 10MB). If you actually
0000000000000000000000000000000000000000;;		// want to advertise an ulimited value to the peer, Transport
0000000000000000000000000000000000000000;;		// interprets the highest possible value here (0xffffffff or 1<<32-1)
0000000000000000000000000000000000000000;;		// to mean no limit.
0000000000000000000000000000000000000000;;		MaxHeaderListSize uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// t1, if non-nil, is the standard library Transport using
0000000000000000000000000000000000000000;;		// this transport. Its settings are used (but not its
0000000000000000000000000000000000000000;;		// RoundTrip method, etc).
0000000000000000000000000000000000000000;;		t1 *http.Transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		connPoolOnce  sync.Once
0000000000000000000000000000000000000000;;		connPoolOrDef ClientConnPool // non-nil version of ConnPool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) maxHeaderListSize() uint32 {
0000000000000000000000000000000000000000;;		if t.MaxHeaderListSize == 0 {
0000000000000000000000000000000000000000;;			return 10 << 20
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.MaxHeaderListSize == 0xffffffff {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.MaxHeaderListSize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) disableCompression() bool {
0000000000000000000000000000000000000000;;		return t.DisableCompression || (t.t1 != nil && t.t1.DisableCompression)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errTransportVersion = errors.New("http2: ConfigureTransport is only supported starting at Go 1.6")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigureTransport configures a net/http HTTP/1 Transport to use HTTP/2.
0000000000000000000000000000000000000000;;	// It requires Go 1.6 or later and returns an error if the net/http package is too old
0000000000000000000000000000000000000000;;	// or if t1 has already been HTTP/2-enabled.
0000000000000000000000000000000000000000;;	func ConfigureTransport(t1 *http.Transport) error {
0000000000000000000000000000000000000000;;		_, err := configureTransport(t1) // in configure_transport.go (go1.6) or not_go16.go
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) connPool() ClientConnPool {
0000000000000000000000000000000000000000;;		t.connPoolOnce.Do(t.initConnPool)
0000000000000000000000000000000000000000;;		return t.connPoolOrDef
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) initConnPool() {
0000000000000000000000000000000000000000;;		if t.ConnPool != nil {
0000000000000000000000000000000000000000;;			t.connPoolOrDef = t.ConnPool
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.connPoolOrDef = &clientConnPool{t: t}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConn is the state of a single HTTP/2 client connection to an
0000000000000000000000000000000000000000;;	// HTTP/2 server.
0000000000000000000000000000000000000000;;	type ClientConn struct {
0000000000000000000000000000000000000000;;		t         *Transport
0000000000000000000000000000000000000000;;		tconn     net.Conn             // usually *tls.Conn, except specialized impls
0000000000000000000000000000000000000000;;		tlsState  *tls.ConnectionState // nil only for specialized impls
0000000000000000000000000000000000000000;;		singleUse bool                 // whether being used for a single http.Request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readLoop goroutine fields:
0000000000000000000000000000000000000000;;		readerDone chan struct{} // closed on error
0000000000000000000000000000000000000000;;		readerErr  error         // set before readerDone is closed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		idleTimeout time.Duration // or 0 for never
0000000000000000000000000000000000000000;;		idleTimer   *time.Timer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu              sync.Mutex // guards following
0000000000000000000000000000000000000000;;		cond            *sync.Cond // hold mu; broadcast on flow/closed changes
0000000000000000000000000000000000000000;;		flow            flow       // our conn-level flow control quota (cs.flow is per stream)
0000000000000000000000000000000000000000;;		inflow          flow       // peer's conn-level flow control
0000000000000000000000000000000000000000;;		closed          bool
0000000000000000000000000000000000000000;;		wantSettingsAck bool                     // we sent a SETTINGS frame and haven't heard back
0000000000000000000000000000000000000000;;		goAway          *GoAwayFrame             // if non-nil, the GoAwayFrame we received
0000000000000000000000000000000000000000;;		goAwayDebug     string                   // goAway frame's debug data, retained as a string
0000000000000000000000000000000000000000;;		streams         map[uint32]*clientStream // client-initiated
0000000000000000000000000000000000000000;;		nextStreamID    uint32
0000000000000000000000000000000000000000;;		pings           map[[8]byte]chan struct{} // in flight ping data to notification channel
0000000000000000000000000000000000000000;;		bw              *bufio.Writer
0000000000000000000000000000000000000000;;		br              *bufio.Reader
0000000000000000000000000000000000000000;;		fr              *Framer
0000000000000000000000000000000000000000;;		lastActive      time.Time
0000000000000000000000000000000000000000;;		// Settings from peer: (also guarded by mu)
0000000000000000000000000000000000000000;;		maxFrameSize         uint32
0000000000000000000000000000000000000000;;		maxConcurrentStreams uint32
0000000000000000000000000000000000000000;;		initialWindowSize    uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hbuf    bytes.Buffer // HPACK encoder writes into this
0000000000000000000000000000000000000000;;		henc    *hpack.Encoder
0000000000000000000000000000000000000000;;		freeBuf [][]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wmu  sync.Mutex // held while writing; acquire AFTER mu if holding both
0000000000000000000000000000000000000000;;		werr error      // first write error that has occurred
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientStream is the state for a single HTTP/2 stream. One of these
0000000000000000000000000000000000000000;;	// is created for each Transport.RoundTrip call.
0000000000000000000000000000000000000000;;	type clientStream struct {
0000000000000000000000000000000000000000;;		cc            *ClientConn
0000000000000000000000000000000000000000;;		req           *http.Request
0000000000000000000000000000000000000000;;		trace         *clientTrace // or nil
0000000000000000000000000000000000000000;;		ID            uint32
0000000000000000000000000000000000000000;;		resc          chan resAndError
0000000000000000000000000000000000000000;;		bufPipe       pipe // buffered pipe with the flow-controlled response payload
0000000000000000000000000000000000000000;;		startedWrite  bool // started request body write; guarded by cc.mu
0000000000000000000000000000000000000000;;		requestedGzip bool
0000000000000000000000000000000000000000;;		on100         func() // optional code to run if get a 100 continue response
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flow        flow  // guarded by cc.mu
0000000000000000000000000000000000000000;;		inflow      flow  // guarded by cc.mu
0000000000000000000000000000000000000000;;		bytesRemain int64 // -1 means unknown; owned by transportResponseBody.Read
0000000000000000000000000000000000000000;;		readErr     error // sticky read error; owned by transportResponseBody.Read
0000000000000000000000000000000000000000;;		stopReqBody error // if non-nil, stop writing req body; guarded by cc.mu
0000000000000000000000000000000000000000;;		didReset    bool  // whether we sent a RST_STREAM to the server; guarded by cc.mu
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		peerReset chan struct{} // closed on peer reset
0000000000000000000000000000000000000000;;		resetErr  error         // populated before peerReset is closed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		done chan struct{} // closed when stream remove from cc.streams map; close calls guarded by cc.mu
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// owned by clientConnReadLoop:
0000000000000000000000000000000000000000;;		firstByte    bool // got the first response byte
0000000000000000000000000000000000000000;;		pastHeaders  bool // got first MetaHeadersFrame (actual headers)
0000000000000000000000000000000000000000;;		pastTrailers bool // got optional second MetaHeadersFrame (trailers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trailer    http.Header  // accumulated trailers
0000000000000000000000000000000000000000;;		resTrailer *http.Header // client's Response.Trailer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// awaitRequestCancel runs in its own goroutine and waits for the user
0000000000000000000000000000000000000000;;	// to cancel a RoundTrip request, its context to expire, or for the
0000000000000000000000000000000000000000;;	// request to be done (any way it might be removed from the cc.streams
0000000000000000000000000000000000000000;;	// map: peer reset, successful completion, TCP connection breakage,
0000000000000000000000000000000000000000;;	// etc)
0000000000000000000000000000000000000000;;	func (cs *clientStream) awaitRequestCancel(req *http.Request) {
0000000000000000000000000000000000000000;;		ctx := reqContext(req)
0000000000000000000000000000000000000000;;		if req.Cancel == nil && ctx.Done() == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-req.Cancel:
0000000000000000000000000000000000000000;;			cs.cancelStream()
0000000000000000000000000000000000000000;;			cs.bufPipe.CloseWithError(errRequestCanceled)
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			cs.cancelStream()
0000000000000000000000000000000000000000;;			cs.bufPipe.CloseWithError(ctx.Err())
0000000000000000000000000000000000000000;;		case <-cs.done:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) cancelStream() {
0000000000000000000000000000000000000000;;		cs.cc.mu.Lock()
0000000000000000000000000000000000000000;;		didReset := cs.didReset
0000000000000000000000000000000000000000;;		cs.didReset = true
0000000000000000000000000000000000000000;;		cs.cc.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !didReset {
0000000000000000000000000000000000000000;;			cs.cc.writeStreamReset(cs.ID, ErrCodeCancel, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkResetOrDone reports any error sent in a RST_STREAM frame by the
0000000000000000000000000000000000000000;;	// server, or errStreamClosed if the stream is complete.
0000000000000000000000000000000000000000;;	func (cs *clientStream) checkResetOrDone() error {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-cs.peerReset:
0000000000000000000000000000000000000000;;			return cs.resetErr
0000000000000000000000000000000000000000;;		case <-cs.done:
0000000000000000000000000000000000000000;;			return errStreamClosed
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) abortRequestBodyWrite(err error) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			panic("nil error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc := cs.cc
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		cs.stopReqBody = err
0000000000000000000000000000000000000000;;		cc.cond.Broadcast()
0000000000000000000000000000000000000000;;		cc.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stickyErrWriter struct {
0000000000000000000000000000000000000000;;		w   io.Writer
0000000000000000000000000000000000000000;;		err *error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sew stickyErrWriter) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if *sew.err != nil {
0000000000000000000000000000000000000000;;			return 0, *sew.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = sew.w.Write(p)
0000000000000000000000000000000000000000;;		*sew.err = err
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrNoCachedConn = errors.New("http2: no cached connection was available")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTripOpt are options for the Transport.RoundTripOpt method.
0000000000000000000000000000000000000000;;	type RoundTripOpt struct {
0000000000000000000000000000000000000000;;		// OnlyCachedConn controls whether RoundTripOpt may
0000000000000000000000000000000000000000;;		// create a new TCP connection. If set true and
0000000000000000000000000000000000000000;;		// no cached connection is available, RoundTripOpt
0000000000000000000000000000000000000000;;		// will return ErrNoCachedConn.
0000000000000000000000000000000000000000;;		OnlyCachedConn bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return t.RoundTripOpt(req, RoundTripOpt{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// authorityAddr returns a given authority (a host/IP, or host:port / ip:port)
0000000000000000000000000000000000000000;;	// and returns a host:port. The port 443 is added if needed.
0000000000000000000000000000000000000000;;	func authorityAddr(scheme string, authority string) (addr string) {
0000000000000000000000000000000000000000;;		host, port, err := net.SplitHostPort(authority)
0000000000000000000000000000000000000000;;		if err != nil { // authority didn't have a port
0000000000000000000000000000000000000000;;			port = "443"
0000000000000000000000000000000000000000;;			if scheme == "http" {
0000000000000000000000000000000000000000;;				port = "80"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			host = authority
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a, err := idna.ToASCII(host); err == nil {
0000000000000000000000000000000000000000;;			host = a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// IPv6 address literal, without a port:
0000000000000000000000000000000000000000;;		if strings.HasPrefix(host, "[") && strings.HasSuffix(host, "]") {
0000000000000000000000000000000000000000;;			return host + ":" + port
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return net.JoinHostPort(host, port)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTripOpt is like RoundTrip, but takes options.
0000000000000000000000000000000000000000;;	func (t *Transport) RoundTripOpt(req *http.Request, opt RoundTripOpt) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if !(req.URL.Scheme == "https" || (req.URL.Scheme == "http" && t.AllowHTTP)) {
0000000000000000000000000000000000000000;;			return nil, errors.New("http2: unsupported scheme")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addr := authorityAddr(req.URL.Scheme, req.URL.Host)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			cc, err := t.connPool().GetClientConn(req, addr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.vlogf("http2: Transport failed to get client conn for %s: %v", addr, err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			traceGotConn(req, cc)
0000000000000000000000000000000000000000;;			res, err := cc.RoundTrip(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if req, err = shouldRetryRequest(req, err); err == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.vlogf("RoundTrip failure: %v", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return res, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseIdleConnections closes any connections which were previously
0000000000000000000000000000000000000000;;	// connected from previous requests but are now sitting idle.
0000000000000000000000000000000000000000;;	// It does not interrupt any connections currently in use.
0000000000000000000000000000000000000000;;	func (t *Transport) CloseIdleConnections() {
0000000000000000000000000000000000000000;;		if cp, ok := t.connPool().(clientConnPoolIdleCloser); ok {
0000000000000000000000000000000000000000;;			cp.closeIdleConnections()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errClientConnClosed   = errors.New("http2: client conn is closed")
0000000000000000000000000000000000000000;;		errClientConnUnusable = errors.New("http2: client conn not usable")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errClientConnGotGoAway                 = errors.New("http2: Transport received Server's graceful shutdown GOAWAY")
0000000000000000000000000000000000000000;;		errClientConnGotGoAwayAfterSomeReqBody = errors.New("http2: Transport received Server's graceful shutdown GOAWAY; some request body already written")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldRetryRequest is called by RoundTrip when a request fails to get
0000000000000000000000000000000000000000;;	// response headers. It is always called with a non-nil error.
0000000000000000000000000000000000000000;;	// It returns either a request to retry (either the same request, or a
0000000000000000000000000000000000000000;;	// modified clone), or an error if the request can't be replayed.
0000000000000000000000000000000000000000;;	func shouldRetryRequest(req *http.Request, err error) (*http.Request, error) {
0000000000000000000000000000000000000000;;		switch err {
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		case errClientConnUnusable, errClientConnGotGoAway:
0000000000000000000000000000000000000000;;			return req, nil
0000000000000000000000000000000000000000;;		case errClientConnGotGoAwayAfterSomeReqBody:
0000000000000000000000000000000000000000;;			// If the Body is nil (or http.NoBody), it's safe to reuse
0000000000000000000000000000000000000000;;			// this request and its Body.
0000000000000000000000000000000000000000;;			if req.Body == nil || reqBodyIsNoBody(req.Body) {
0000000000000000000000000000000000000000;;				return req, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Otherwise we depend on the Request having its GetBody
0000000000000000000000000000000000000000;;			// func defined.
0000000000000000000000000000000000000000;;			getBody := reqGetBody(req) // Go 1.8: getBody = req.GetBody
0000000000000000000000000000000000000000;;			if getBody == nil {
0000000000000000000000000000000000000000;;				return nil, errors.New("http2: Transport: peer server initiated graceful shutdown after some of Request.Body was written; define Request.GetBody to avoid this error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			body, err := getBody()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newReq := *req
0000000000000000000000000000000000000000;;			newReq.Body = body
0000000000000000000000000000000000000000;;			return &newReq, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) dialClientConn(addr string, singleUse bool) (*ClientConn, error) {
0000000000000000000000000000000000000000;;		host, _, err := net.SplitHostPort(addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tconn, err := t.dialTLS()("tcp", addr, t.newTLSConfig(host))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.newClientConn(tconn, singleUse)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) newTLSConfig(host string) *tls.Config {
0000000000000000000000000000000000000000;;		cfg := new(tls.Config)
0000000000000000000000000000000000000000;;		if t.TLSClientConfig != nil {
0000000000000000000000000000000000000000;;			*cfg = *cloneTLSConfig(t.TLSClientConfig)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strSliceContains(cfg.NextProtos, NextProtoTLS) {
0000000000000000000000000000000000000000;;			cfg.NextProtos = append([]string{NextProtoTLS}, cfg.NextProtos...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.ServerName == "" {
0000000000000000000000000000000000000000;;			cfg.ServerName = host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) dialTLS() func(string, string, *tls.Config) (net.Conn, error) {
0000000000000000000000000000000000000000;;		if t.DialTLS != nil {
0000000000000000000000000000000000000000;;			return t.DialTLS
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.dialTLSDefault
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) dialTLSDefault(network, addr string, cfg *tls.Config) (net.Conn, error) {
0000000000000000000000000000000000000000;;		cn, err := tls.Dial(network, addr, cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := cn.Handshake(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cfg.InsecureSkipVerify {
0000000000000000000000000000000000000000;;			if err := cn.VerifyHostname(cfg.ServerName); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		state := cn.ConnectionState()
0000000000000000000000000000000000000000;;		if p := state.NegotiatedProtocol; p != NextProtoTLS {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("http2: unexpected ALPN protocol %q; want %q", p, NextProtoTLS)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !state.NegotiatedProtocolIsMutual {
0000000000000000000000000000000000000000;;			return nil, errors.New("http2: could not negotiate protocol mutually")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// disableKeepAlives reports whether connections should be closed as
0000000000000000000000000000000000000000;;	// soon as possible after handling the first request.
0000000000000000000000000000000000000000;;	func (t *Transport) disableKeepAlives() bool {
0000000000000000000000000000000000000000;;		return t.t1 != nil && t.t1.DisableKeepAlives
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) expectContinueTimeout() time.Duration {
0000000000000000000000000000000000000000;;		if t.t1 == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return transportExpectContinueTimeout(t.t1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) NewClientConn(c net.Conn) (*ClientConn, error) {
0000000000000000000000000000000000000000;;		return t.newClientConn(c, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) newClientConn(c net.Conn, singleUse bool) (*ClientConn, error) {
0000000000000000000000000000000000000000;;		cc := &ClientConn{
0000000000000000000000000000000000000000;;			t:                    t,
0000000000000000000000000000000000000000;;			tconn:                c,
0000000000000000000000000000000000000000;;			readerDone:           make(chan struct{}),
0000000000000000000000000000000000000000;;			nextStreamID:         1,
0000000000000000000000000000000000000000;;			maxFrameSize:         16 << 10, // spec default
0000000000000000000000000000000000000000;;			initialWindowSize:    65535,    // spec default
0000000000000000000000000000000000000000;;			maxConcurrentStreams: 1000,     // "infinite", per spec. 1000 seems good enough.
0000000000000000000000000000000000000000;;			streams:              make(map[uint32]*clientStream),
0000000000000000000000000000000000000000;;			singleUse:            singleUse,
0000000000000000000000000000000000000000;;			wantSettingsAck:      true,
0000000000000000000000000000000000000000;;			pings:                make(map[[8]byte]chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d := t.idleConnTimeout(); d != 0 {
0000000000000000000000000000000000000000;;			cc.idleTimeout = d
0000000000000000000000000000000000000000;;			cc.idleTimer = time.AfterFunc(d, cc.onIdleTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if VerboseLogs {
0000000000000000000000000000000000000000;;			t.vlogf("http2: Transport creating client conn %p to %v", cc, c.RemoteAddr())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.cond = sync.NewCond(&cc.mu)
0000000000000000000000000000000000000000;;		cc.flow.add(int32(initialWindowSize))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: adjust this writer size to account for frame size +
0000000000000000000000000000000000000000;;		// MTU + crypto/tls record padding.
0000000000000000000000000000000000000000;;		cc.bw = bufio.NewWriter(stickyErrWriter{c, &cc.werr})
0000000000000000000000000000000000000000;;		cc.br = bufio.NewReader(c)
0000000000000000000000000000000000000000;;		cc.fr = NewFramer(cc.bw, cc.br)
0000000000000000000000000000000000000000;;		cc.fr.ReadMetaHeaders = hpack.NewDecoder(initialHeaderTableSize, nil)
0000000000000000000000000000000000000000;;		cc.fr.MaxHeaderListSize = t.maxHeaderListSize()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: SetMaxDynamicTableSize, SetMaxDynamicTableSizeLimit on
0000000000000000000000000000000000000000;;		// henc in response to SETTINGS frames?
0000000000000000000000000000000000000000;;		cc.henc = hpack.NewEncoder(&cc.hbuf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cs, ok := c.(connectionStater); ok {
0000000000000000000000000000000000000000;;			state := cs.ConnectionState()
0000000000000000000000000000000000000000;;			cc.tlsState = &state
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		initialSettings := []Setting{
0000000000000000000000000000000000000000;;			{ID: SettingEnablePush, Val: 0},
0000000000000000000000000000000000000000;;			{ID: SettingInitialWindowSize, Val: transportDefaultStreamFlow},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if max := t.maxHeaderListSize(); max != 0 {
0000000000000000000000000000000000000000;;			initialSettings = append(initialSettings, Setting{ID: SettingMaxHeaderListSize, Val: max})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.bw.Write(clientPreface)
0000000000000000000000000000000000000000;;		cc.fr.WriteSettings(initialSettings...)
0000000000000000000000000000000000000000;;		cc.fr.WriteWindowUpdate(0, transportDefaultConnFlow)
0000000000000000000000000000000000000000;;		cc.inflow.add(transportDefaultConnFlow + initialWindowSize)
0000000000000000000000000000000000000000;;		cc.bw.Flush()
0000000000000000000000000000000000000000;;		if cc.werr != nil {
0000000000000000000000000000000000000000;;			return nil, cc.werr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go cc.readLoop()
0000000000000000000000000000000000000000;;		return cc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) setGoAway(f *GoAwayFrame) {
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		defer cc.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		old := cc.goAway
0000000000000000000000000000000000000000;;		cc.goAway = f
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Merge the previous and current GoAway error frames.
0000000000000000000000000000000000000000;;		if cc.goAwayDebug == "" {
0000000000000000000000000000000000000000;;			cc.goAwayDebug = string(f.DebugData())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if old != nil && old.ErrCode != ErrCodeNo {
0000000000000000000000000000000000000000;;			cc.goAway.ErrCode = old.ErrCode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		last := f.LastStreamID
0000000000000000000000000000000000000000;;		for streamID, cs := range cc.streams {
0000000000000000000000000000000000000000;;			if streamID > last {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case cs.resc <- resAndError{err: errClientConnGotGoAway}:
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) CanTakeNewRequest() bool {
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		defer cc.mu.Unlock()
0000000000000000000000000000000000000000;;		return cc.canTakeNewRequestLocked()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) canTakeNewRequestLocked() bool {
0000000000000000000000000000000000000000;;		if cc.singleUse && cc.nextStreamID > 1 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cc.goAway == nil && !cc.closed &&
0000000000000000000000000000000000000000;;			int64(len(cc.streams)+1) < int64(cc.maxConcurrentStreams) &&
0000000000000000000000000000000000000000;;			cc.nextStreamID < math.MaxInt32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// onIdleTimeout is called from a time.AfterFunc goroutine.  It will
0000000000000000000000000000000000000000;;	// only be called when we're idle, but because we're coming from a new
0000000000000000000000000000000000000000;;	// goroutine, there could be a new request coming in at the same time,
0000000000000000000000000000000000000000;;	// so this simply calls the synchronized closeIfIdle to shut down this
0000000000000000000000000000000000000000;;	// connection. The timer could just call closeIfIdle, but this is more
0000000000000000000000000000000000000000;;	// clear.
0000000000000000000000000000000000000000;;	func (cc *ClientConn) onIdleTimeout() {
0000000000000000000000000000000000000000;;		cc.closeIfIdle()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) closeIfIdle() {
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		if len(cc.streams) > 0 {
0000000000000000000000000000000000000000;;			cc.mu.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.closed = true
0000000000000000000000000000000000000000;;		nextID := cc.nextStreamID
0000000000000000000000000000000000000000;;		// TODO: do clients send GOAWAY too? maybe? Just Close:
0000000000000000000000000000000000000000;;		cc.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if VerboseLogs {
0000000000000000000000000000000000000000;;			cc.vlogf("http2: Transport closing idle conn %p (forSingleUse=%v, maxStream=%v)", cc, cc.singleUse, nextID-2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.tconn.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxAllocFrameSize = 512 << 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// frameBuffer returns a scratch buffer suitable for writing DATA frames.
0000000000000000000000000000000000000000;;	// They're capped at the min of the peer's max frame size or 512KB
0000000000000000000000000000000000000000;;	// (kinda arbitrarily), but definitely capped so we don't allocate 4GB
0000000000000000000000000000000000000000;;	// bufers.
0000000000000000000000000000000000000000;;	func (cc *ClientConn) frameScratchBuffer() []byte {
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		size := cc.maxFrameSize
0000000000000000000000000000000000000000;;		if size > maxAllocFrameSize {
0000000000000000000000000000000000000000;;			size = maxAllocFrameSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, buf := range cc.freeBuf {
0000000000000000000000000000000000000000;;			if len(buf) >= int(size) {
0000000000000000000000000000000000000000;;				cc.freeBuf[i] = nil
0000000000000000000000000000000000000000;;				cc.mu.Unlock()
0000000000000000000000000000000000000000;;				return buf[:size]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.mu.Unlock()
0000000000000000000000000000000000000000;;		return make([]byte, size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) putFrameScratchBuffer(buf []byte) {
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		defer cc.mu.Unlock()
0000000000000000000000000000000000000000;;		const maxBufs = 4 // arbitrary; 4 concurrent requests per conn? investigate.
0000000000000000000000000000000000000000;;		if len(cc.freeBuf) < maxBufs {
0000000000000000000000000000000000000000;;			cc.freeBuf = append(cc.freeBuf, buf)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, old := range cc.freeBuf {
0000000000000000000000000000000000000000;;			if old == nil {
0000000000000000000000000000000000000000;;				cc.freeBuf[i] = buf
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// forget about it.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errRequestCanceled is a copy of net/http's errRequestCanceled because it's not
0000000000000000000000000000000000000000;;	// exported. At least they'll be DeepEqual for h1-vs-h2 comparisons tests.
0000000000000000000000000000000000000000;;	var errRequestCanceled = errors.New("net/http: request canceled")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func commaSeparatedTrailers(req *http.Request) (string, error) {
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(req.Trailer))
0000000000000000000000000000000000000000;;		for k := range req.Trailer {
0000000000000000000000000000000000000000;;			k = http.CanonicalHeaderKey(k)
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case "Transfer-Encoding", "Trailer", "Content-Length":
0000000000000000000000000000000000000000;;				return "", &badStringError{"invalid Trailer key", k}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keys = append(keys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(keys) > 0 {
0000000000000000000000000000000000000000;;			sort.Strings(keys)
0000000000000000000000000000000000000000;;			return strings.Join(keys, ","), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) responseHeaderTimeout() time.Duration {
0000000000000000000000000000000000000000;;		if cc.t.t1 != nil {
0000000000000000000000000000000000000000;;			return cc.t.t1.ResponseHeaderTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// No way to do this (yet?) with just an http2.Transport. Probably
0000000000000000000000000000000000000000;;		// no need. Request.Cancel this is the new way. We only need to support
0000000000000000000000000000000000000000;;		// this for compatibility with the old http.Transport fields when
0000000000000000000000000000000000000000;;		// we're doing transparent http2.
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkConnHeaders checks whether req has any invalid connection-level headers.
0000000000000000000000000000000000000000;;	// per RFC 7540 section 8.1.2.2: Connection-Specific Header Fields.
0000000000000000000000000000000000000000;;	// Certain headers are special-cased as okay but not transmitted later.
0000000000000000000000000000000000000000;;	func checkConnHeaders(req *http.Request) error {
0000000000000000000000000000000000000000;;		if v := req.Header.Get("Upgrade"); v != "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("http2: invalid Upgrade request header: %q", req.Header["Upgrade"])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vv := req.Header["Transfer-Encoding"]; len(vv) > 0 && (len(vv) > 1 || vv[0] != "" && vv[0] != "chunked") {
0000000000000000000000000000000000000000;;			return fmt.Errorf("http2: invalid Transfer-Encoding request header: %q", vv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vv := req.Header["Connection"]; len(vv) > 0 && (len(vv) > 1 || vv[0] != "" && vv[0] != "close" && vv[0] != "keep-alive") {
0000000000000000000000000000000000000000;;			return fmt.Errorf("http2: invalid Connection request header: %q", vv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// actualContentLength returns a sanitized version of
0000000000000000000000000000000000000000;;	// req.ContentLength, where 0 actually means zero (not unknown) and -1
0000000000000000000000000000000000000000;;	// means unknown.
0000000000000000000000000000000000000000;;	func actualContentLength(req *http.Request) int64 {
0000000000000000000000000000000000000000;;		if req.Body == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if req.ContentLength != 0 {
0000000000000000000000000000000000000000;;			return req.ContentLength
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if err := checkConnHeaders(req); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cc.idleTimer != nil {
0000000000000000000000000000000000000000;;			cc.idleTimer.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trailers, err := commaSeparatedTrailers(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hasTrailers := trailers != ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		cc.lastActive = time.Now()
0000000000000000000000000000000000000000;;		if cc.closed || !cc.canTakeNewRequestLocked() {
0000000000000000000000000000000000000000;;			cc.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil, errClientConnUnusable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body := req.Body
0000000000000000000000000000000000000000;;		hasBody := body != nil
0000000000000000000000000000000000000000;;		contentLen := actualContentLength(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(bradfitz): this is a copy of the logic in net/http. Unify somewhere?
0000000000000000000000000000000000000000;;		var requestedGzip bool
0000000000000000000000000000000000000000;;		if !cc.t.disableCompression() &&
0000000000000000000000000000000000000000;;			req.Header.Get("Accept-Encoding") == "" &&
0000000000000000000000000000000000000000;;			req.Header.Get("Range") == "" &&
0000000000000000000000000000000000000000;;			req.Method != "HEAD" {
0000000000000000000000000000000000000000;;			// Request gzip only, not deflate. Deflate is ambiguous and
0000000000000000000000000000000000000000;;			// not as universally supported anyway.
0000000000000000000000000000000000000000;;			// See: http://www.gzip.org/zlib/zlib_faq.html#faq38
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Note that we don't request this for HEAD requests,
0000000000000000000000000000000000000000;;			// due to a bug in nginx:
0000000000000000000000000000000000000000;;			//   http://trac.nginx.org/nginx/ticket/358
0000000000000000000000000000000000000000;;			//   https://golang.org/issue/5522
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// We don't request gzip if the request is for a range, since
0000000000000000000000000000000000000000;;			// auto-decoding a portion of a gzipped document will just fail
0000000000000000000000000000000000000000;;			// anyway. See https://golang.org/issue/8923
0000000000000000000000000000000000000000;;			requestedGzip = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we send: HEADERS{1}, CONTINUATION{0,} + DATA{0,} (DATA is
0000000000000000000000000000000000000000;;		// sent by writeRequestBody below, along with any Trailers,
0000000000000000000000000000000000000000;;		// again in form HEADERS{1}, CONTINUATION{0,})
0000000000000000000000000000000000000000;;		hdrs, err := cc.encodeHeaders(req, requestedGzip, trailers, contentLen)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			cc.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cs := cc.newStream()
0000000000000000000000000000000000000000;;		cs.req = req
0000000000000000000000000000000000000000;;		cs.trace = requestTrace(req)
0000000000000000000000000000000000000000;;		cs.requestedGzip = requestedGzip
0000000000000000000000000000000000000000;;		bodyWriter := cc.t.getBodyWriterState(cs, body)
0000000000000000000000000000000000000000;;		cs.on100 = bodyWriter.on100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.wmu.Lock()
0000000000000000000000000000000000000000;;		endStream := !hasBody && !hasTrailers
0000000000000000000000000000000000000000;;		werr := cc.writeHeaders(cs.ID, endStream, hdrs)
0000000000000000000000000000000000000000;;		cc.wmu.Unlock()
0000000000000000000000000000000000000000;;		traceWroteHeaders(cs.trace)
0000000000000000000000000000000000000000;;		cc.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if werr != nil {
0000000000000000000000000000000000000000;;			if hasBody {
0000000000000000000000000000000000000000;;				req.Body.Close() // per RoundTripper contract
0000000000000000000000000000000000000000;;				bodyWriter.cancel()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.forgetStreamID(cs.ID)
0000000000000000000000000000000000000000;;			// Don't bother sending a RST_STREAM (our write already failed;
0000000000000000000000000000000000000000;;			// no need to keep writing)
0000000000000000000000000000000000000000;;			traceWroteRequest(cs.trace, werr)
0000000000000000000000000000000000000000;;			return nil, werr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var respHeaderTimer <-chan time.Time
0000000000000000000000000000000000000000;;		if hasBody {
0000000000000000000000000000000000000000;;			bodyWriter.scheduleBodyWrite()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			traceWroteRequest(cs.trace, nil)
0000000000000000000000000000000000000000;;			if d := cc.responseHeaderTimeout(); d != 0 {
0000000000000000000000000000000000000000;;				timer := time.NewTimer(d)
0000000000000000000000000000000000000000;;				defer timer.Stop()
0000000000000000000000000000000000000000;;				respHeaderTimer = timer.C
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		readLoopResCh := cs.resc
0000000000000000000000000000000000000000;;		bodyWritten := false
0000000000000000000000000000000000000000;;		ctx := reqContext(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handleReadLoopResponse := func(re resAndError) (*http.Response, error) {
0000000000000000000000000000000000000000;;			res := re.res
0000000000000000000000000000000000000000;;			if re.err != nil || res.StatusCode > 299 {
0000000000000000000000000000000000000000;;				// On error or status code 3xx, 4xx, 5xx, etc abort any
0000000000000000000000000000000000000000;;				// ongoing write, assuming that the server doesn't care
0000000000000000000000000000000000000000;;				// about our request body. If the server replied with 1xx or
0000000000000000000000000000000000000000;;				// 2xx, however, then assume the server DOES potentially
0000000000000000000000000000000000000000;;				// want our body (e.g. full-duplex streaming:
0000000000000000000000000000000000000000;;				// golang.org/issue/13444). If it turns out the server
0000000000000000000000000000000000000000;;				// doesn't, they'll RST_STREAM us soon enough.  This is a
0000000000000000000000000000000000000000;;				// heuristic to avoid adding knobs to Transport.  Hopefully
0000000000000000000000000000000000000000;;				// we can keep it.
0000000000000000000000000000000000000000;;				bodyWriter.cancel()
0000000000000000000000000000000000000000;;				cs.abortRequestBodyWrite(errStopReqBodyWrite)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if re.err != nil {
0000000000000000000000000000000000000000;;				if re.err == errClientConnGotGoAway {
0000000000000000000000000000000000000000;;					cc.mu.Lock()
0000000000000000000000000000000000000000;;					if cs.startedWrite {
0000000000000000000000000000000000000000;;						re.err = errClientConnGotGoAwayAfterSomeReqBody
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					cc.mu.Unlock()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cc.forgetStreamID(cs.ID)
0000000000000000000000000000000000000000;;				return nil, re.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res.Request = req
0000000000000000000000000000000000000000;;			res.TLS = cc.tlsState
0000000000000000000000000000000000000000;;			return res, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case re := <-readLoopResCh:
0000000000000000000000000000000000000000;;				return handleReadLoopResponse(re)
0000000000000000000000000000000000000000;;			case <-respHeaderTimer:
0000000000000000000000000000000000000000;;				cc.forgetStreamID(cs.ID)
0000000000000000000000000000000000000000;;				if !hasBody || bodyWritten {
0000000000000000000000000000000000000000;;					cc.writeStreamReset(cs.ID, ErrCodeCancel, nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					bodyWriter.cancel()
0000000000000000000000000000000000000000;;					cs.abortRequestBodyWrite(errStopReqBodyWriteAndCancel)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, errTimeout
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				cc.forgetStreamID(cs.ID)
0000000000000000000000000000000000000000;;				if !hasBody || bodyWritten {
0000000000000000000000000000000000000000;;					cc.writeStreamReset(cs.ID, ErrCodeCancel, nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					bodyWriter.cancel()
0000000000000000000000000000000000000000;;					cs.abortRequestBodyWrite(errStopReqBodyWriteAndCancel)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, ctx.Err()
0000000000000000000000000000000000000000;;			case <-req.Cancel:
0000000000000000000000000000000000000000;;				cc.forgetStreamID(cs.ID)
0000000000000000000000000000000000000000;;				if !hasBody || bodyWritten {
0000000000000000000000000000000000000000;;					cc.writeStreamReset(cs.ID, ErrCodeCancel, nil)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					bodyWriter.cancel()
0000000000000000000000000000000000000000;;					cs.abortRequestBodyWrite(errStopReqBodyWriteAndCancel)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, errRequestCanceled
0000000000000000000000000000000000000000;;			case <-cs.peerReset:
0000000000000000000000000000000000000000;;				// processResetStream already removed the
0000000000000000000000000000000000000000;;				// stream from the streams map; no need for
0000000000000000000000000000000000000000;;				// forgetStreamID.
0000000000000000000000000000000000000000;;				return nil, cs.resetErr
0000000000000000000000000000000000000000;;			case err := <-bodyWriter.resc:
0000000000000000000000000000000000000000;;				// Prefer the read loop's response, if available. Issue 16102.
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case re := <-readLoopResCh:
0000000000000000000000000000000000000000;;					return handleReadLoopResponse(re)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bodyWritten = true
0000000000000000000000000000000000000000;;				if d := cc.responseHeaderTimeout(); d != 0 {
0000000000000000000000000000000000000000;;					timer := time.NewTimer(d)
0000000000000000000000000000000000000000;;					defer timer.Stop()
0000000000000000000000000000000000000000;;					respHeaderTimer = timer.C
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requires cc.wmu be held
0000000000000000000000000000000000000000;;	func (cc *ClientConn) writeHeaders(streamID uint32, endStream bool, hdrs []byte) error {
0000000000000000000000000000000000000000;;		first := true // first frame written (HEADERS is first, then CONTINUATION)
0000000000000000000000000000000000000000;;		frameSize := int(cc.maxFrameSize)
0000000000000000000000000000000000000000;;		for len(hdrs) > 0 && cc.werr == nil {
0000000000000000000000000000000000000000;;			chunk := hdrs
0000000000000000000000000000000000000000;;			if len(chunk) > frameSize {
0000000000000000000000000000000000000000;;				chunk = chunk[:frameSize]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hdrs = hdrs[len(chunk):]
0000000000000000000000000000000000000000;;			endHeaders := len(hdrs) == 0
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				cc.fr.WriteHeaders(HeadersFrameParam{
0000000000000000000000000000000000000000;;					StreamID:      streamID,
0000000000000000000000000000000000000000;;					BlockFragment: chunk,
0000000000000000000000000000000000000000;;					EndStream:     endStream,
0000000000000000000000000000000000000000;;					EndHeaders:    endHeaders,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				first = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				cc.fr.WriteContinuation(streamID, endHeaders, chunk)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(bradfitz): this Flush could potentially block (as
0000000000000000000000000000000000000000;;		// could the WriteHeaders call(s) above), which means they
0000000000000000000000000000000000000000;;		// wouldn't respond to Request.Cancel being readable. That's
0000000000000000000000000000000000000000;;		// rare, but this should probably be in a goroutine.
0000000000000000000000000000000000000000;;		cc.bw.Flush()
0000000000000000000000000000000000000000;;		return cc.werr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// internal error values; they don't escape to callers
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// abort request body write; don't send cancel
0000000000000000000000000000000000000000;;		errStopReqBodyWrite = errors.New("http2: aborting request body write")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// abort request body write, but send stream reset of cancel.
0000000000000000000000000000000000000000;;		errStopReqBodyWriteAndCancel = errors.New("http2: canceling request")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) writeRequestBody(body io.Reader, bodyCloser io.Closer) (err error) {
0000000000000000000000000000000000000000;;		cc := cs.cc
0000000000000000000000000000000000000000;;		sentEnd := false // whether we sent the final DATA frame w/ END_STREAM
0000000000000000000000000000000000000000;;		buf := cc.frameScratchBuffer()
0000000000000000000000000000000000000000;;		defer cc.putFrameScratchBuffer(buf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			traceWroteRequest(cs.trace, err)
0000000000000000000000000000000000000000;;			// TODO: write h12Compare test showing whether
0000000000000000000000000000000000000000;;			// Request.Body is closed by the Transport,
0000000000000000000000000000000000000000;;			// and in multiple cases: server replies <=299 and >299
0000000000000000000000000000000000000000;;			// while still writing request body
0000000000000000000000000000000000000000;;			cerr := bodyCloser.Close()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				err = cerr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := cs.req
0000000000000000000000000000000000000000;;		hasTrailers := req.Trailer != nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var sawEOF bool
0000000000000000000000000000000000000000;;		for !sawEOF {
0000000000000000000000000000000000000000;;			n, err := body.Read(buf)
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				sawEOF = true
0000000000000000000000000000000000000000;;				err = nil
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			remain := buf[:n]
0000000000000000000000000000000000000000;;			for len(remain) > 0 && err == nil {
0000000000000000000000000000000000000000;;				var allowed int32
0000000000000000000000000000000000000000;;				allowed, err = cs.awaitFlowControl(len(remain))
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case err == errStopReqBodyWrite:
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				case err == errStopReqBodyWriteAndCancel:
0000000000000000000000000000000000000000;;					cc.writeStreamReset(cs.ID, ErrCodeCancel, nil)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				case err != nil:
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cc.wmu.Lock()
0000000000000000000000000000000000000000;;				data := remain[:allowed]
0000000000000000000000000000000000000000;;				remain = remain[allowed:]
0000000000000000000000000000000000000000;;				sentEnd = sawEOF && len(remain) == 0 && !hasTrailers
0000000000000000000000000000000000000000;;				err = cc.fr.WriteData(cs.ID, sentEnd, data)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					// TODO(bradfitz): this flush is for latency, not bandwidth.
0000000000000000000000000000000000000000;;					// Most requests won't need this. Make this opt-in or
0000000000000000000000000000000000000000;;					// opt-out?  Use some heuristic on the body type? Nagel-like
0000000000000000000000000000000000000000;;					// timers?  Based on 'n'? Only last chunk of this for loop,
0000000000000000000000000000000000000000;;					// unless flow control tokens are low? For now, always.
0000000000000000000000000000000000000000;;					// If we change this, see comment below.
0000000000000000000000000000000000000000;;					err = cc.bw.Flush()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cc.wmu.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sentEnd {
0000000000000000000000000000000000000000;;			// Already sent END_STREAM (which implies we have no
0000000000000000000000000000000000000000;;			// trailers) and flushed, because currently all
0000000000000000000000000000000000000000;;			// WriteData frames above get a flush. So we're done.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var trls []byte
0000000000000000000000000000000000000000;;		if hasTrailers {
0000000000000000000000000000000000000000;;			cc.mu.Lock()
0000000000000000000000000000000000000000;;			defer cc.mu.Unlock()
0000000000000000000000000000000000000000;;			trls = cc.encodeTrailers(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.wmu.Lock()
0000000000000000000000000000000000000000;;		defer cc.wmu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Two ways to send END_STREAM: either with trailers, or
0000000000000000000000000000000000000000;;		// with an empty DATA frame.
0000000000000000000000000000000000000000;;		if len(trls) > 0 {
0000000000000000000000000000000000000000;;			err = cc.writeHeaders(cs.ID, true, trls)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			err = cc.fr.WriteData(cs.ID, true, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ferr := cc.bw.Flush(); ferr != nil && err == nil {
0000000000000000000000000000000000000000;;			err = ferr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// awaitFlowControl waits for [1, min(maxBytes, cc.cs.maxFrameSize)] flow
0000000000000000000000000000000000000000;;	// control tokens from the server.
0000000000000000000000000000000000000000;;	// It returns either the non-zero number of tokens taken or an error
0000000000000000000000000000000000000000;;	// if the stream is dead.
0000000000000000000000000000000000000000;;	func (cs *clientStream) awaitFlowControl(maxBytes int) (taken int32, err error) {
0000000000000000000000000000000000000000;;		cc := cs.cc
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		defer cc.mu.Unlock()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if cc.closed {
0000000000000000000000000000000000000000;;				return 0, errClientConnClosed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cs.stopReqBody != nil {
0000000000000000000000000000000000000000;;				return 0, cs.stopReqBody
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := cs.checkResetOrDone(); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if a := cs.flow.available(); a > 0 {
0000000000000000000000000000000000000000;;				take := a
0000000000000000000000000000000000000000;;				if int(take) > maxBytes {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					take = int32(maxBytes) // can't truncate int; take is int32
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if take > int32(cc.maxFrameSize) {
0000000000000000000000000000000000000000;;					take = int32(cc.maxFrameSize)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cs.flow.take(take)
0000000000000000000000000000000000000000;;				return take, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.cond.Wait()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type badStringError struct {
0000000000000000000000000000000000000000;;		what string
0000000000000000000000000000000000000000;;		str  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *badStringError) Error() string { return fmt.Sprintf("%s %q", e.what, e.str) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requires cc.mu be held.
0000000000000000000000000000000000000000;;	func (cc *ClientConn) encodeHeaders(req *http.Request, addGzipHeader bool, trailers string, contentLength int64) ([]byte, error) {
0000000000000000000000000000000000000000;;		cc.hbuf.Reset()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host := req.Host
0000000000000000000000000000000000000000;;		if host == "" {
0000000000000000000000000000000000000000;;			host = req.URL.Host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		host, err := httplex.PunycodeHostPort(host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var path string
0000000000000000000000000000000000000000;;		if req.Method != "CONNECT" {
0000000000000000000000000000000000000000;;			path = req.URL.RequestURI()
0000000000000000000000000000000000000000;;			if !validPseudoPath(path) {
0000000000000000000000000000000000000000;;				orig := path
0000000000000000000000000000000000000000;;				path = strings.TrimPrefix(path, req.URL.Scheme+"://"+host)
0000000000000000000000000000000000000000;;				if !validPseudoPath(path) {
0000000000000000000000000000000000000000;;					if req.URL.Opaque != "" {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("invalid request :path %q from URL.Opaque = %q", orig, req.URL.Opaque)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("invalid request :path %q", orig)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for any invalid headers and return an error before we
0000000000000000000000000000000000000000;;		// potentially pollute our hpack state. (We want to be able to
0000000000000000000000000000000000000000;;		// continue to reuse the hpack encoder for future requests)
0000000000000000000000000000000000000000;;		for k, vv := range req.Header {
0000000000000000000000000000000000000000;;			if !httplex.ValidHeaderFieldName(k) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid HTTP header name %q", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, v := range vv {
0000000000000000000000000000000000000000;;				if !httplex.ValidHeaderFieldValue(v) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("invalid HTTP header value %q for header %q", v, k)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 8.1.2.3 Request Pseudo-Header Fields
0000000000000000000000000000000000000000;;		// The :path pseudo-header field includes the path and query parts of the
0000000000000000000000000000000000000000;;		// target URI (the path-absolute production and optionally a '?' character
0000000000000000000000000000000000000000;;		// followed by the query production (see Sections 3.3 and 3.4 of
0000000000000000000000000000000000000000;;		// [RFC3986]).
0000000000000000000000000000000000000000;;		cc.writeHeader(":authority", host)
0000000000000000000000000000000000000000;;		cc.writeHeader(":method", req.Method)
0000000000000000000000000000000000000000;;		if req.Method != "CONNECT" {
0000000000000000000000000000000000000000;;			cc.writeHeader(":path", path)
0000000000000000000000000000000000000000;;			cc.writeHeader(":scheme", req.URL.Scheme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if trailers != "" {
0000000000000000000000000000000000000000;;			cc.writeHeader("trailer", trailers)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var didUA bool
0000000000000000000000000000000000000000;;		for k, vv := range req.Header {
0000000000000000000000000000000000000000;;			lowKey := strings.ToLower(k)
0000000000000000000000000000000000000000;;			switch lowKey {
0000000000000000000000000000000000000000;;			case "host", "content-length":
0000000000000000000000000000000000000000;;				// Host is :authority, already sent.
0000000000000000000000000000000000000000;;				// Content-Length is automatic, set below.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case "connection", "proxy-connection", "transfer-encoding", "upgrade", "keep-alive":
0000000000000000000000000000000000000000;;				// Per 8.1.2.2 Connection-Specific Header
0000000000000000000000000000000000000000;;				// Fields, don't send connection-specific
0000000000000000000000000000000000000000;;				// fields. We have already checked if any
0000000000000000000000000000000000000000;;				// are error-worthy so just ignore the rest.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case "user-agent":
0000000000000000000000000000000000000000;;				// Match Go's http1 behavior: at most one
0000000000000000000000000000000000000000;;				// User-Agent. If set to nil or empty string,
0000000000000000000000000000000000000000;;				// then omit it. Otherwise if not mentioned,
0000000000000000000000000000000000000000;;				// include the default (below).
0000000000000000000000000000000000000000;;				didUA = true
0000000000000000000000000000000000000000;;				if len(vv) < 1 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				vv = vv[:1]
0000000000000000000000000000000000000000;;				if vv[0] == "" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, v := range vv {
0000000000000000000000000000000000000000;;				cc.writeHeader(lowKey, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if shouldSendReqContentLength(req.Method, contentLength) {
0000000000000000000000000000000000000000;;			cc.writeHeader("content-length", strconv.FormatInt(contentLength, 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if addGzipHeader {
0000000000000000000000000000000000000000;;			cc.writeHeader("accept-encoding", "gzip")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !didUA {
0000000000000000000000000000000000000000;;			cc.writeHeader("user-agent", defaultUserAgent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cc.hbuf.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldSendReqContentLength reports whether the http2.Transport should send
0000000000000000000000000000000000000000;;	// a "content-length" request header. This logic is basically a copy of the net/http
0000000000000000000000000000000000000000;;	// transferWriter.shouldSendContentLength.
0000000000000000000000000000000000000000;;	// The contentLength is the corrected contentLength (so 0 means actually 0, not unknown).
0000000000000000000000000000000000000000;;	// -1 means unknown.
0000000000000000000000000000000000000000;;	func shouldSendReqContentLength(method string, contentLength int64) bool {
0000000000000000000000000000000000000000;;		if contentLength > 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if contentLength < 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// For zero bodies, whether we send a content-length depends on the method.
0000000000000000000000000000000000000000;;		// It also kinda doesn't matter for http2 either way, with END_STREAM.
0000000000000000000000000000000000000000;;		switch method {
0000000000000000000000000000000000000000;;		case "POST", "PUT", "PATCH":
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requires cc.mu be held.
0000000000000000000000000000000000000000;;	func (cc *ClientConn) encodeTrailers(req *http.Request) []byte {
0000000000000000000000000000000000000000;;		cc.hbuf.Reset()
0000000000000000000000000000000000000000;;		for k, vv := range req.Trailer {
0000000000000000000000000000000000000000;;			// Transfer-Encoding, etc.. have already been filter at the
0000000000000000000000000000000000000000;;			// start of RoundTrip
0000000000000000000000000000000000000000;;			lowKey := strings.ToLower(k)
0000000000000000000000000000000000000000;;			for _, v := range vv {
0000000000000000000000000000000000000000;;				cc.writeHeader(lowKey, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cc.hbuf.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) writeHeader(name, value string) {
0000000000000000000000000000000000000000;;		if VerboseLogs {
0000000000000000000000000000000000000000;;			log.Printf("http2: Transport encoding header %q = %q", name, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.henc.WriteField(hpack.HeaderField{Name: name, Value: value})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type resAndError struct {
0000000000000000000000000000000000000000;;		res *http.Response
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requires cc.mu be held.
0000000000000000000000000000000000000000;;	func (cc *ClientConn) newStream() *clientStream {
0000000000000000000000000000000000000000;;		cs := &clientStream{
0000000000000000000000000000000000000000;;			cc:        cc,
0000000000000000000000000000000000000000;;			ID:        cc.nextStreamID,
0000000000000000000000000000000000000000;;			resc:      make(chan resAndError, 1),
0000000000000000000000000000000000000000;;			peerReset: make(chan struct{}),
0000000000000000000000000000000000000000;;			done:      make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs.flow.add(int32(cc.initialWindowSize))
0000000000000000000000000000000000000000;;		cs.flow.setConnFlow(&cc.flow)
0000000000000000000000000000000000000000;;		cs.inflow.add(transportDefaultStreamFlow)
0000000000000000000000000000000000000000;;		cs.inflow.setConnFlow(&cc.inflow)
0000000000000000000000000000000000000000;;		cc.nextStreamID += 2
0000000000000000000000000000000000000000;;		cc.streams[cs.ID] = cs
0000000000000000000000000000000000000000;;		return cs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) forgetStreamID(id uint32) {
0000000000000000000000000000000000000000;;		cc.streamByID(id, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) streamByID(id uint32, andRemove bool) *clientStream {
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		defer cc.mu.Unlock()
0000000000000000000000000000000000000000;;		cs := cc.streams[id]
0000000000000000000000000000000000000000;;		if andRemove && cs != nil && !cc.closed {
0000000000000000000000000000000000000000;;			cc.lastActive = time.Now()
0000000000000000000000000000000000000000;;			delete(cc.streams, id)
0000000000000000000000000000000000000000;;			if len(cc.streams) == 0 && cc.idleTimer != nil {
0000000000000000000000000000000000000000;;				cc.idleTimer.Reset(cc.idleTimeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(cs.done)
0000000000000000000000000000000000000000;;			cc.cond.Broadcast() // wake up checkResetOrDone via clientStream.awaitFlowControl
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientConnReadLoop is the state owned by the clientConn's frame-reading readLoop.
0000000000000000000000000000000000000000;;	type clientConnReadLoop struct {
0000000000000000000000000000000000000000;;		cc            *ClientConn
0000000000000000000000000000000000000000;;		activeRes     map[uint32]*clientStream // keyed by streamID
0000000000000000000000000000000000000000;;		closeWhenIdle bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readLoop runs in its own goroutine and reads and dispatches frames.
0000000000000000000000000000000000000000;;	func (cc *ClientConn) readLoop() {
0000000000000000000000000000000000000000;;		rl := &clientConnReadLoop{
0000000000000000000000000000000000000000;;			cc:        cc,
0000000000000000000000000000000000000000;;			activeRes: make(map[uint32]*clientStream),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer rl.cleanup()
0000000000000000000000000000000000000000;;		cc.readerErr = rl.run()
0000000000000000000000000000000000000000;;		if ce, ok := cc.readerErr.(ConnectionError); ok {
0000000000000000000000000000000000000000;;			cc.wmu.Lock()
0000000000000000000000000000000000000000;;			cc.fr.WriteGoAway(0, ErrCode(ce), nil)
0000000000000000000000000000000000000000;;			cc.wmu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GoAwayError is returned by the Transport when the server closes the
0000000000000000000000000000000000000000;;	// TCP connection after sending a GOAWAY frame.
0000000000000000000000000000000000000000;;	type GoAwayError struct {
0000000000000000000000000000000000000000;;		LastStreamID uint32
0000000000000000000000000000000000000000;;		ErrCode      ErrCode
0000000000000000000000000000000000000000;;		DebugData    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e GoAwayError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("http2: server sent GOAWAY and closed the connection; LastStreamID=%v, ErrCode=%v, debug=%q",
0000000000000000000000000000000000000000;;			e.LastStreamID, e.ErrCode, e.DebugData)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isEOFOrNetReadError(err error) bool {
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ne, ok := err.(*net.OpError)
0000000000000000000000000000000000000000;;		return ok && ne.Op == "read"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) cleanup() {
0000000000000000000000000000000000000000;;		cc := rl.cc
0000000000000000000000000000000000000000;;		defer cc.tconn.Close()
0000000000000000000000000000000000000000;;		defer cc.t.connPool().MarkDead(cc)
0000000000000000000000000000000000000000;;		defer close(cc.readerDone)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cc.idleTimer != nil {
0000000000000000000000000000000000000000;;			cc.idleTimer.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close any response bodies if the server closes prematurely.
0000000000000000000000000000000000000000;;		// TODO: also do this if we've written the headers but not
0000000000000000000000000000000000000000;;		// gotten a response yet.
0000000000000000000000000000000000000000;;		err := cc.readerErr
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		if cc.goAway != nil && isEOFOrNetReadError(err) {
0000000000000000000000000000000000000000;;			err = GoAwayError{
0000000000000000000000000000000000000000;;				LastStreamID: cc.goAway.LastStreamID,
0000000000000000000000000000000000000000;;				ErrCode:      cc.goAway.ErrCode,
0000000000000000000000000000000000000000;;				DebugData:    cc.goAwayDebug,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if err == io.EOF {
0000000000000000000000000000000000000000;;			err = io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, cs := range rl.activeRes {
0000000000000000000000000000000000000000;;			cs.bufPipe.CloseWithError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, cs := range cc.streams {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case cs.resc <- resAndError{err: err}:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(cs.done)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.closed = true
0000000000000000000000000000000000000000;;		cc.cond.Broadcast()
0000000000000000000000000000000000000000;;		cc.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) run() error {
0000000000000000000000000000000000000000;;		cc := rl.cc
0000000000000000000000000000000000000000;;		rl.closeWhenIdle = cc.t.disableKeepAlives() || cc.singleUse
0000000000000000000000000000000000000000;;		gotReply := false // ever saw a HEADERS reply
0000000000000000000000000000000000000000;;		gotSettings := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			f, err := cc.fr.ReadFrame()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				cc.vlogf("http2: Transport readFrame error on conn %p: (%T) %v", cc, err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if se, ok := err.(StreamError); ok {
0000000000000000000000000000000000000000;;				if cs := cc.streamByID(se.StreamID, true /*ended; remove it*/); cs != nil {
0000000000000000000000000000000000000000;;					cs.cc.writeStreamReset(cs.ID, se.Code, err)
0000000000000000000000000000000000000000;;					if se.Cause == nil {
0000000000000000000000000000000000000000;;						se.Cause = cc.fr.errDetail
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rl.endStreamError(cs, se)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if VerboseLogs {
0000000000000000000000000000000000000000;;				cc.vlogf("http2: Transport received %s", summarizeFrame(f))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !gotSettings {
0000000000000000000000000000000000000000;;				if _, ok := f.(*SettingsFrame); !ok {
0000000000000000000000000000000000000000;;					cc.logf("protocol error: received %T before a SETTINGS frame", f)
0000000000000000000000000000000000000000;;					return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gotSettings = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			maybeIdle := false // whether frame might transition us to idle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch f := f.(type) {
0000000000000000000000000000000000000000;;			case *MetaHeadersFrame:
0000000000000000000000000000000000000000;;				err = rl.processHeaders(f)
0000000000000000000000000000000000000000;;				maybeIdle = true
0000000000000000000000000000000000000000;;				gotReply = true
0000000000000000000000000000000000000000;;			case *DataFrame:
0000000000000000000000000000000000000000;;				err = rl.processData(f)
0000000000000000000000000000000000000000;;				maybeIdle = true
0000000000000000000000000000000000000000;;			case *GoAwayFrame:
0000000000000000000000000000000000000000;;				err = rl.processGoAway(f)
0000000000000000000000000000000000000000;;				maybeIdle = true
0000000000000000000000000000000000000000;;			case *RSTStreamFrame:
0000000000000000000000000000000000000000;;				err = rl.processResetStream(f)
0000000000000000000000000000000000000000;;				maybeIdle = true
0000000000000000000000000000000000000000;;			case *SettingsFrame:
0000000000000000000000000000000000000000;;				err = rl.processSettings(f)
0000000000000000000000000000000000000000;;			case *PushPromiseFrame:
0000000000000000000000000000000000000000;;				err = rl.processPushPromise(f)
0000000000000000000000000000000000000000;;			case *WindowUpdateFrame:
0000000000000000000000000000000000000000;;				err = rl.processWindowUpdate(f)
0000000000000000000000000000000000000000;;			case *PingFrame:
0000000000000000000000000000000000000000;;				err = rl.processPing(f)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				cc.logf("Transport: unhandled response frame type %T", f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if VerboseLogs {
0000000000000000000000000000000000000000;;					cc.vlogf("http2: Transport conn %p received error from processing frame %v: %v", cc, summarizeFrame(f), err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rl.closeWhenIdle && gotReply && maybeIdle && len(rl.activeRes) == 0 {
0000000000000000000000000000000000000000;;				cc.closeIfIdle()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) processHeaders(f *MetaHeadersFrame) error {
0000000000000000000000000000000000000000;;		cc := rl.cc
0000000000000000000000000000000000000000;;		cs := cc.streamByID(f.StreamID, f.StreamEnded())
0000000000000000000000000000000000000000;;		if cs == nil {
0000000000000000000000000000000000000000;;			// We'd get here if we canceled a request while the
0000000000000000000000000000000000000000;;			// server had its response still in flight. So if this
0000000000000000000000000000000000000000;;			// was just something we canceled, ignore it.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cs.firstByte {
0000000000000000000000000000000000000000;;			if cs.trace != nil {
0000000000000000000000000000000000000000;;				// TODO(bradfitz): move first response byte earlier,
0000000000000000000000000000000000000000;;				// when we first read the 9 byte header, not waiting
0000000000000000000000000000000000000000;;				// until all the HEADERS+CONTINUATION frames have been
0000000000000000000000000000000000000000;;				// merged. This works for now.
0000000000000000000000000000000000000000;;				traceFirstResponseByte(cs.trace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cs.firstByte = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cs.pastHeaders {
0000000000000000000000000000000000000000;;			cs.pastHeaders = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return rl.processTrailers(cs, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := rl.handleResponse(cs, f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, ok := err.(ConnectionError); ok {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Any other error type is a stream error.
0000000000000000000000000000000000000000;;			cs.cc.writeStreamReset(f.StreamID, ErrCodeProtocol, err)
0000000000000000000000000000000000000000;;			cs.resc <- resAndError{err: err}
0000000000000000000000000000000000000000;;			return nil // return nil from process* funcs to keep conn alive
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res == nil {
0000000000000000000000000000000000000000;;			// (nil, nil) special case. See handleResponse docs.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.Body != noBody {
0000000000000000000000000000000000000000;;			rl.activeRes[cs.ID] = cs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs.resTrailer = &res.Trailer
0000000000000000000000000000000000000000;;		cs.resc <- resAndError{res: res}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// may return error types nil, or ConnectionError. Any other error value
0000000000000000000000000000000000000000;;	// is a StreamError of type ErrCodeProtocol. The returned error in that case
0000000000000000000000000000000000000000;;	// is the detail.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As a special case, handleResponse may return (nil, nil) to skip the
0000000000000000000000000000000000000000;;	// frame (currently only used for 100 expect continue). This special
0000000000000000000000000000000000000000;;	// case is going away after Issue 13851 is fixed.
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) handleResponse(cs *clientStream, f *MetaHeadersFrame) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if f.Truncated {
0000000000000000000000000000000000000000;;			return nil, errResponseHeaderListSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := f.PseudoValue("status")
0000000000000000000000000000000000000000;;		if status == "" {
0000000000000000000000000000000000000000;;			return nil, errors.New("missing status pseudo header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		statusCode, err := strconv.Atoi(status)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("malformed non-numeric status pseudo header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if statusCode == 100 {
0000000000000000000000000000000000000000;;			traceGot100Continue(cs.trace)
0000000000000000000000000000000000000000;;			if cs.on100 != nil {
0000000000000000000000000000000000000000;;				cs.on100() // forces any write delay timer to fire
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cs.pastHeaders = false // do it all again
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		header := make(http.Header)
0000000000000000000000000000000000000000;;		res := &http.Response{
0000000000000000000000000000000000000000;;			Proto:      "HTTP/2.0",
0000000000000000000000000000000000000000;;			ProtoMajor: 2,
0000000000000000000000000000000000000000;;			Header:     header,
0000000000000000000000000000000000000000;;			StatusCode: statusCode,
0000000000000000000000000000000000000000;;			Status:     status + " " + http.StatusText(statusCode),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, hf := range f.RegularFields() {
0000000000000000000000000000000000000000;;			key := http.CanonicalHeaderKey(hf.Name)
0000000000000000000000000000000000000000;;			if key == "Trailer" {
0000000000000000000000000000000000000000;;				t := res.Trailer
0000000000000000000000000000000000000000;;				if t == nil {
0000000000000000000000000000000000000000;;					t = make(http.Header)
0000000000000000000000000000000000000000;;					res.Trailer = t
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				foreachHeaderElement(hf.Value, func(v string) {
0000000000000000000000000000000000000000;;					t[http.CanonicalHeaderKey(v)] = nil
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				header[key] = append(header[key], hf.Value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamEnded := f.StreamEnded()
0000000000000000000000000000000000000000;;		isHead := cs.req.Method == "HEAD"
0000000000000000000000000000000000000000;;		if !streamEnded || isHead {
0000000000000000000000000000000000000000;;			res.ContentLength = -1
0000000000000000000000000000000000000000;;			if clens := res.Header["Content-Length"]; len(clens) == 1 {
0000000000000000000000000000000000000000;;				if clen64, err := strconv.ParseInt(clens[0], 10, 64); err == nil {
0000000000000000000000000000000000000000;;					res.ContentLength = clen64
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// TODO: care? unlike http/1, it won't mess up our framing, so it's
0000000000000000000000000000000000000000;;					// more safe smuggling-wise to ignore.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if len(clens) > 1 {
0000000000000000000000000000000000000000;;				// TODO: care? unlike http/1, it won't mess up our framing, so it's
0000000000000000000000000000000000000000;;				// more safe smuggling-wise to ignore.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if streamEnded || isHead {
0000000000000000000000000000000000000000;;			res.Body = noBody
0000000000000000000000000000000000000000;;			return res, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer) // TODO(bradfitz): recycle this garbage
0000000000000000000000000000000000000000;;		cs.bufPipe = pipe{b: buf}
0000000000000000000000000000000000000000;;		cs.bytesRemain = res.ContentLength
0000000000000000000000000000000000000000;;		res.Body = transportResponseBody{cs}
0000000000000000000000000000000000000000;;		go cs.awaitRequestCancel(cs.req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cs.requestedGzip && res.Header.Get("Content-Encoding") == "gzip" {
0000000000000000000000000000000000000000;;			res.Header.Del("Content-Encoding")
0000000000000000000000000000000000000000;;			res.Header.Del("Content-Length")
0000000000000000000000000000000000000000;;			res.ContentLength = -1
0000000000000000000000000000000000000000;;			res.Body = &gzipReader{body: res.Body}
0000000000000000000000000000000000000000;;			setResponseUncompressed(res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) processTrailers(cs *clientStream, f *MetaHeadersFrame) error {
0000000000000000000000000000000000000000;;		if cs.pastTrailers {
0000000000000000000000000000000000000000;;			// Too many HEADERS frames for this stream.
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs.pastTrailers = true
0000000000000000000000000000000000000000;;		if !f.StreamEnded() {
0000000000000000000000000000000000000000;;			// We expect that any headers for trailers also
0000000000000000000000000000000000000000;;			// has END_STREAM.
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(f.PseudoFields()) > 0 {
0000000000000000000000000000000000000000;;			// No pseudo header fields are defined for trailers.
0000000000000000000000000000000000000000;;			// TODO: ConnectionError might be overly harsh? Check.
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trailer := make(http.Header)
0000000000000000000000000000000000000000;;		for _, hf := range f.RegularFields() {
0000000000000000000000000000000000000000;;			key := http.CanonicalHeaderKey(hf.Name)
0000000000000000000000000000000000000000;;			trailer[key] = append(trailer[key], hf.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs.trailer = trailer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rl.endStream(cs)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transportResponseBody is the concrete type of Transport.RoundTrip's
0000000000000000000000000000000000000000;;	// Response.Body. It is an io.ReadCloser. On Read, it reads from cs.body.
0000000000000000000000000000000000000000;;	// On Close it sends RST_STREAM if EOF wasn't already seen.
0000000000000000000000000000000000000000;;	type transportResponseBody struct {
0000000000000000000000000000000000000000;;		cs *clientStream
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b transportResponseBody) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		cs := b.cs
0000000000000000000000000000000000000000;;		cc := cs.cc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cs.readErr != nil {
0000000000000000000000000000000000000000;;			return 0, cs.readErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = b.cs.bufPipe.Read(p)
0000000000000000000000000000000000000000;;		if cs.bytesRemain != -1 {
0000000000000000000000000000000000000000;;			if int64(n) > cs.bytesRemain {
0000000000000000000000000000000000000000;;				n = int(cs.bytesRemain)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					err = errors.New("net/http: server replied with more than declared Content-Length; truncated")
0000000000000000000000000000000000000000;;					cc.writeStreamReset(cs.ID, ErrCodeProtocol, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cs.readErr = err
0000000000000000000000000000000000000000;;				return int(cs.bytesRemain), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cs.bytesRemain -= int64(n)
0000000000000000000000000000000000000000;;			if err == io.EOF && cs.bytesRemain > 0 {
0000000000000000000000000000000000000000;;				err = io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;				cs.readErr = err
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			// No flow control tokens to send back.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		defer cc.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var connAdd, streamAdd int32
0000000000000000000000000000000000000000;;		// Check the conn-level first, before the stream-level.
0000000000000000000000000000000000000000;;		if v := cc.inflow.available(); v < transportDefaultConnFlow/2 {
0000000000000000000000000000000000000000;;			connAdd = transportDefaultConnFlow - v
0000000000000000000000000000000000000000;;			cc.inflow.add(connAdd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil { // No need to refresh if the stream is over or failed.
0000000000000000000000000000000000000000;;			// Consider any buffered body data (read from the conn but not
0000000000000000000000000000000000000000;;			// consumed by the client) when computing flow control for this
0000000000000000000000000000000000000000;;			// stream.
0000000000000000000000000000000000000000;;			v := int(cs.inflow.available()) + cs.bufPipe.Len()
0000000000000000000000000000000000000000;;			if v < transportDefaultStreamFlow-transportDefaultStreamMinRefresh {
0000000000000000000000000000000000000000;;				streamAdd = int32(transportDefaultStreamFlow - v)
0000000000000000000000000000000000000000;;				cs.inflow.add(streamAdd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if connAdd != 0 || streamAdd != 0 {
0000000000000000000000000000000000000000;;			cc.wmu.Lock()
0000000000000000000000000000000000000000;;			defer cc.wmu.Unlock()
0000000000000000000000000000000000000000;;			if connAdd != 0 {
0000000000000000000000000000000000000000;;				cc.fr.WriteWindowUpdate(0, mustUint31(connAdd))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if streamAdd != 0 {
0000000000000000000000000000000000000000;;				cc.fr.WriteWindowUpdate(cs.ID, mustUint31(streamAdd))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.bw.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errClosedResponseBody = errors.New("http2: response body closed")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b transportResponseBody) Close() error {
0000000000000000000000000000000000000000;;		cs := b.cs
0000000000000000000000000000000000000000;;		cc := cs.cc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverSentStreamEnd := cs.bufPipe.Err() == io.EOF
0000000000000000000000000000000000000000;;		unread := cs.bufPipe.Len()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if unread > 0 || !serverSentStreamEnd {
0000000000000000000000000000000000000000;;			cc.mu.Lock()
0000000000000000000000000000000000000000;;			cc.wmu.Lock()
0000000000000000000000000000000000000000;;			if !serverSentStreamEnd {
0000000000000000000000000000000000000000;;				cc.fr.WriteRSTStream(cs.ID, ErrCodeCancel)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Return connection-level flow control.
0000000000000000000000000000000000000000;;			if unread > 0 {
0000000000000000000000000000000000000000;;				cc.inflow.add(int32(unread))
0000000000000000000000000000000000000000;;				cc.fr.WriteWindowUpdate(0, uint32(unread))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.bw.Flush()
0000000000000000000000000000000000000000;;			cc.wmu.Unlock()
0000000000000000000000000000000000000000;;			cc.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cs.bufPipe.BreakWithError(errClosedResponseBody)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) processData(f *DataFrame) error {
0000000000000000000000000000000000000000;;		cc := rl.cc
0000000000000000000000000000000000000000;;		cs := cc.streamByID(f.StreamID, f.StreamEnded())
0000000000000000000000000000000000000000;;		data := f.Data()
0000000000000000000000000000000000000000;;		if cs == nil {
0000000000000000000000000000000000000000;;			cc.mu.Lock()
0000000000000000000000000000000000000000;;			neverSent := cc.nextStreamID
0000000000000000000000000000000000000000;;			cc.mu.Unlock()
0000000000000000000000000000000000000000;;			if f.StreamID >= neverSent {
0000000000000000000000000000000000000000;;				// We never asked for this.
0000000000000000000000000000000000000000;;				cc.logf("http2: Transport received unsolicited DATA frame; closing connection")
0000000000000000000000000000000000000000;;				return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We probably did ask for this, but canceled. Just ignore it.
0000000000000000000000000000000000000000;;			// TODO: be stricter here? only silently ignore things which
0000000000000000000000000000000000000000;;			// we canceled, but not things which were closed normally
0000000000000000000000000000000000000000;;			// by the peer? Tough without accumulating too much state.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// But at least return their flow control:
0000000000000000000000000000000000000000;;			if f.Length > 0 {
0000000000000000000000000000000000000000;;				cc.mu.Lock()
0000000000000000000000000000000000000000;;				cc.inflow.add(int32(f.Length))
0000000000000000000000000000000000000000;;				cc.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				cc.wmu.Lock()
0000000000000000000000000000000000000000;;				cc.fr.WriteWindowUpdate(0, uint32(f.Length))
0000000000000000000000000000000000000000;;				cc.bw.Flush()
0000000000000000000000000000000000000000;;				cc.wmu.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.Length > 0 {
0000000000000000000000000000000000000000;;			if len(data) > 0 && cs.bufPipe.b == nil {
0000000000000000000000000000000000000000;;				// Data frame after it's already closed?
0000000000000000000000000000000000000000;;				cc.logf("http2: Transport received DATA frame for closed stream; closing connection")
0000000000000000000000000000000000000000;;				return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check connection-level flow control.
0000000000000000000000000000000000000000;;			cc.mu.Lock()
0000000000000000000000000000000000000000;;			if cs.inflow.available() >= int32(f.Length) {
0000000000000000000000000000000000000000;;				cs.inflow.take(int32(f.Length))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				cc.mu.Unlock()
0000000000000000000000000000000000000000;;				return ConnectionError(ErrCodeFlowControl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Return any padded flow control now, since we won't
0000000000000000000000000000000000000000;;			// refund it later on body reads.
0000000000000000000000000000000000000000;;			if pad := int32(f.Length) - int32(len(data)); pad > 0 {
0000000000000000000000000000000000000000;;				cs.inflow.add(pad)
0000000000000000000000000000000000000000;;				cc.inflow.add(pad)
0000000000000000000000000000000000000000;;				cc.wmu.Lock()
0000000000000000000000000000000000000000;;				cc.fr.WriteWindowUpdate(0, uint32(pad))
0000000000000000000000000000000000000000;;				cc.fr.WriteWindowUpdate(cs.ID, uint32(pad))
0000000000000000000000000000000000000000;;				cc.bw.Flush()
0000000000000000000000000000000000000000;;				cc.wmu.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			didReset := cs.didReset
0000000000000000000000000000000000000000;;			cc.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(data) > 0 && !didReset {
0000000000000000000000000000000000000000;;				if _, err := cs.bufPipe.Write(data); err != nil {
0000000000000000000000000000000000000000;;					rl.endStreamError(cs, err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.StreamEnded() {
0000000000000000000000000000000000000000;;			rl.endStream(cs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errInvalidTrailers = errors.New("http2: invalid trailers")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) endStream(cs *clientStream) {
0000000000000000000000000000000000000000;;		// TODO: check that any declared content-length matches, like
0000000000000000000000000000000000000000;;		// server.go's (*stream).endStream method.
0000000000000000000000000000000000000000;;		rl.endStreamError(cs, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) endStreamError(cs *clientStream, err error) {
0000000000000000000000000000000000000000;;		var code func()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = io.EOF
0000000000000000000000000000000000000000;;			code = cs.copyTrailers
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs.bufPipe.closeWithErrorAndCode(err, code)
0000000000000000000000000000000000000000;;		delete(rl.activeRes, cs.ID)
0000000000000000000000000000000000000000;;		if isConnectionCloseRequest(cs.req) {
0000000000000000000000000000000000000000;;			rl.closeWhenIdle = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case cs.resc <- resAndError{err: err}:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs *clientStream) copyTrailers() {
0000000000000000000000000000000000000000;;		for k, vv := range cs.trailer {
0000000000000000000000000000000000000000;;			t := cs.resTrailer
0000000000000000000000000000000000000000;;			if *t == nil {
0000000000000000000000000000000000000000;;				*t = make(http.Header)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			(*t)[k] = vv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) processGoAway(f *GoAwayFrame) error {
0000000000000000000000000000000000000000;;		cc := rl.cc
0000000000000000000000000000000000000000;;		cc.t.connPool().MarkDead(cc)
0000000000000000000000000000000000000000;;		if f.ErrCode != 0 {
0000000000000000000000000000000000000000;;			// TODO: deal with GOAWAY more. particularly the error code
0000000000000000000000000000000000000000;;			cc.vlogf("transport got GOAWAY with error code = %v", f.ErrCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.setGoAway(f)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) processSettings(f *SettingsFrame) error {
0000000000000000000000000000000000000000;;		cc := rl.cc
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		defer cc.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.IsAck() {
0000000000000000000000000000000000000000;;			if cc.wantSettingsAck {
0000000000000000000000000000000000000000;;				cc.wantSettingsAck = false
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := f.ForeachSetting(func(s Setting) error {
0000000000000000000000000000000000000000;;			switch s.ID {
0000000000000000000000000000000000000000;;			case SettingMaxFrameSize:
0000000000000000000000000000000000000000;;				cc.maxFrameSize = s.Val
0000000000000000000000000000000000000000;;			case SettingMaxConcurrentStreams:
0000000000000000000000000000000000000000;;				cc.maxConcurrentStreams = s.Val
0000000000000000000000000000000000000000;;			case SettingInitialWindowSize:
0000000000000000000000000000000000000000;;				// Values above the maximum flow-control
0000000000000000000000000000000000000000;;				// window size of 2^31-1 MUST be treated as a
0000000000000000000000000000000000000000;;				// connection error (Section 5.4.1) of type
0000000000000000000000000000000000000000;;				// FLOW_CONTROL_ERROR.
0000000000000000000000000000000000000000;;				if s.Val > math.MaxInt32 {
0000000000000000000000000000000000000000;;					return ConnectionError(ErrCodeFlowControl)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Adjust flow control of currently-open
0000000000000000000000000000000000000000;;				// frames by the difference of the old initial
0000000000000000000000000000000000000000;;				// window size and this one.
0000000000000000000000000000000000000000;;				delta := int32(s.Val) - int32(cc.initialWindowSize)
0000000000000000000000000000000000000000;;				for _, cs := range cc.streams {
0000000000000000000000000000000000000000;;					cs.flow.add(delta)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cc.cond.Broadcast()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				cc.initialWindowSize = s.Val
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// TODO(bradfitz): handle more settings? SETTINGS_HEADER_TABLE_SIZE probably.
0000000000000000000000000000000000000000;;				cc.vlogf("Unhandled Setting: %v", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.wmu.Lock()
0000000000000000000000000000000000000000;;		defer cc.wmu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.fr.WriteSettingsAck()
0000000000000000000000000000000000000000;;		cc.bw.Flush()
0000000000000000000000000000000000000000;;		return cc.werr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) processWindowUpdate(f *WindowUpdateFrame) error {
0000000000000000000000000000000000000000;;		cc := rl.cc
0000000000000000000000000000000000000000;;		cs := cc.streamByID(f.StreamID, false)
0000000000000000000000000000000000000000;;		if f.StreamID != 0 && cs == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cc.mu.Lock()
0000000000000000000000000000000000000000;;		defer cc.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fl := &cc.flow
0000000000000000000000000000000000000000;;		if cs != nil {
0000000000000000000000000000000000000000;;			fl = &cs.flow
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !fl.add(int32(f.Increment)) {
0000000000000000000000000000000000000000;;			return ConnectionError(ErrCodeFlowControl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.cond.Broadcast()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) processResetStream(f *RSTStreamFrame) error {
0000000000000000000000000000000000000000;;		cs := rl.cc.streamByID(f.StreamID, true)
0000000000000000000000000000000000000000;;		if cs == nil {
0000000000000000000000000000000000000000;;			// TODO: return error if server tries to RST_STEAM an idle stream
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-cs.peerReset:
0000000000000000000000000000000000000000;;			// Already reset.
0000000000000000000000000000000000000000;;			// This is the only goroutine
0000000000000000000000000000000000000000;;			// which closes this, so there
0000000000000000000000000000000000000000;;			// isn't a race.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err := streamError(cs.ID, f.ErrCode)
0000000000000000000000000000000000000000;;			cs.resetErr = err
0000000000000000000000000000000000000000;;			close(cs.peerReset)
0000000000000000000000000000000000000000;;			cs.bufPipe.CloseWithError(err)
0000000000000000000000000000000000000000;;			cs.cc.cond.Broadcast() // wake up checkResetOrDone via clientStream.awaitFlowControl
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(rl.activeRes, cs.ID)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ping sends a PING frame to the server and waits for the ack.
0000000000000000000000000000000000000000;;	// Public implementation is in go17.go and not_go17.go
0000000000000000000000000000000000000000;;	func (cc *ClientConn) ping(ctx contextContext) error {
0000000000000000000000000000000000000000;;		c := make(chan struct{})
0000000000000000000000000000000000000000;;		// Generate a random payload
0000000000000000000000000000000000000000;;		var p [8]byte
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if _, err := rand.Read(p[:]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.mu.Lock()
0000000000000000000000000000000000000000;;			// check for dup before insert
0000000000000000000000000000000000000000;;			if _, found := cc.pings[p]; !found {
0000000000000000000000000000000000000000;;				cc.pings[p] = c
0000000000000000000000000000000000000000;;				cc.mu.Unlock()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cc.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.wmu.Lock()
0000000000000000000000000000000000000000;;		if err := cc.fr.WritePing(false, p); err != nil {
0000000000000000000000000000000000000000;;			cc.wmu.Unlock()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := cc.bw.Flush(); err != nil {
0000000000000000000000000000000000000000;;			cc.wmu.Unlock()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc.wmu.Unlock()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-c:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			return ctx.Err()
0000000000000000000000000000000000000000;;		case <-cc.readerDone:
0000000000000000000000000000000000000000;;			// connection closed
0000000000000000000000000000000000000000;;			return cc.readerErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) processPing(f *PingFrame) error {
0000000000000000000000000000000000000000;;		if f.IsAck() {
0000000000000000000000000000000000000000;;			cc := rl.cc
0000000000000000000000000000000000000000;;			cc.mu.Lock()
0000000000000000000000000000000000000000;;			defer cc.mu.Unlock()
0000000000000000000000000000000000000000;;			// If ack, notify listener if any
0000000000000000000000000000000000000000;;			if c, ok := cc.pings[f.Data]; ok {
0000000000000000000000000000000000000000;;				close(c)
0000000000000000000000000000000000000000;;				delete(cc.pings, f.Data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cc := rl.cc
0000000000000000000000000000000000000000;;		cc.wmu.Lock()
0000000000000000000000000000000000000000;;		defer cc.wmu.Unlock()
0000000000000000000000000000000000000000;;		if err := cc.fr.WritePing(true, f.Data); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cc.bw.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rl *clientConnReadLoop) processPushPromise(f *PushPromiseFrame) error {
0000000000000000000000000000000000000000;;		// We told the peer we don't want them.
0000000000000000000000000000000000000000;;		// Spec says:
0000000000000000000000000000000000000000;;		// "PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH
0000000000000000000000000000000000000000;;		// setting of the peer endpoint is set to 0. An endpoint that
0000000000000000000000000000000000000000;;		// has set this setting and has received acknowledgement MUST
0000000000000000000000000000000000000000;;		// treat the receipt of a PUSH_PROMISE frame as a connection
0000000000000000000000000000000000000000;;		// error (Section 5.4.1) of type PROTOCOL_ERROR."
0000000000000000000000000000000000000000;;		return ConnectionError(ErrCodeProtocol)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) writeStreamReset(streamID uint32, code ErrCode, err error) {
0000000000000000000000000000000000000000;;		// TODO: map err to more interesting error codes, once the
0000000000000000000000000000000000000000;;		// HTTP community comes up with some. But currently for
0000000000000000000000000000000000000000;;		// RST_STREAM there's no equivalent to GOAWAY frame's debug
0000000000000000000000000000000000000000;;		// data, and the error codes are all pretty vague ("cancel").
0000000000000000000000000000000000000000;;		cc.wmu.Lock()
0000000000000000000000000000000000000000;;		cc.fr.WriteRSTStream(streamID, code)
0000000000000000000000000000000000000000;;		cc.bw.Flush()
0000000000000000000000000000000000000000;;		cc.wmu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errResponseHeaderListSize = errors.New("http2: response header list larger than advertised limit")
0000000000000000000000000000000000000000;;		errPseudoTrailers         = errors.New("http2: invalid pseudo header in trailers")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) logf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		cc.t.logf(format, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cc *ClientConn) vlogf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		cc.t.vlogf(format, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) vlogf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if VerboseLogs {
0000000000000000000000000000000000000000;;			t.logf(format, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) logf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		log.Printf(format, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var noBody io.ReadCloser = ioutil.NopCloser(bytes.NewReader(nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func strSliceContains(ss []string, s string) bool {
0000000000000000000000000000000000000000;;		for _, v := range ss {
0000000000000000000000000000000000000000;;			if v == s {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type erringRoundTripper struct{ err error }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt erringRoundTripper) RoundTrip(*http.Request) (*http.Response, error) { return nil, rt.err }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gzipReader wraps a response body so it can lazily
0000000000000000000000000000000000000000;;	// call gzip.NewReader on the first call to Read
0000000000000000000000000000000000000000;;	type gzipReader struct {
0000000000000000000000000000000000000000;;		body io.ReadCloser // underlying Response.Body
0000000000000000000000000000000000000000;;		zr   *gzip.Reader  // lazily-initialized gzip reader
0000000000000000000000000000000000000000;;		zerr error         // sticky error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gz *gzipReader) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if gz.zerr != nil {
0000000000000000000000000000000000000000;;			return 0, gz.zerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gz.zr == nil {
0000000000000000000000000000000000000000;;			gz.zr, err = gzip.NewReader(gz.body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				gz.zerr = err
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gz.zr.Read(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gz *gzipReader) Close() error {
0000000000000000000000000000000000000000;;		return gz.body.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errorReader struct{ err error }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r errorReader) Read(p []byte) (int, error) { return 0, r.err }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bodyWriterState encapsulates various state around the Transport's writing
0000000000000000000000000000000000000000;;	// of the request body, particularly regarding doing delayed writes of the body
0000000000000000000000000000000000000000;;	// when the request contains "Expect: 100-continue".
0000000000000000000000000000000000000000;;	type bodyWriterState struct {
0000000000000000000000000000000000000000;;		cs     *clientStream
0000000000000000000000000000000000000000;;		timer  *time.Timer   // if non-nil, we're doing a delayed write
0000000000000000000000000000000000000000;;		fnonce *sync.Once    // to call fn with
0000000000000000000000000000000000000000;;		fn     func()        // the code to run in the goroutine, writing the body
0000000000000000000000000000000000000000;;		resc   chan error    // result of fn's execution
0000000000000000000000000000000000000000;;		delay  time.Duration // how long we should delay a delayed write for
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) getBodyWriterState(cs *clientStream, body io.Reader) (s bodyWriterState) {
0000000000000000000000000000000000000000;;		s.cs = cs
0000000000000000000000000000000000000000;;		if body == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resc := make(chan error, 1)
0000000000000000000000000000000000000000;;		s.resc = resc
0000000000000000000000000000000000000000;;		s.fn = func() {
0000000000000000000000000000000000000000;;			cs.cc.mu.Lock()
0000000000000000000000000000000000000000;;			cs.startedWrite = true
0000000000000000000000000000000000000000;;			cs.cc.mu.Unlock()
0000000000000000000000000000000000000000;;			resc <- cs.writeRequestBody(body, cs.req.Body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.delay = t.expectContinueTimeout()
0000000000000000000000000000000000000000;;		if s.delay == 0 ||
0000000000000000000000000000000000000000;;			!httplex.HeaderValuesContainsToken(
0000000000000000000000000000000000000000;;				cs.req.Header["Expect"],
0000000000000000000000000000000000000000;;				"100-continue") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.fnonce = new(sync.Once)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Arm the timer with a very large duration, which we'll
0000000000000000000000000000000000000000;;		// intentionally lower later. It has to be large now because
0000000000000000000000000000000000000000;;		// we need a handle to it before writing the headers, but the
0000000000000000000000000000000000000000;;		// s.delay value is defined to not start until after the
0000000000000000000000000000000000000000;;		// request headers were written.
0000000000000000000000000000000000000000;;		const hugeDuration = 365 * 24 * time.Hour
0000000000000000000000000000000000000000;;		s.timer = time.AfterFunc(hugeDuration, func() {
0000000000000000000000000000000000000000;;			s.fnonce.Do(s.fn)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s bodyWriterState) cancel() {
0000000000000000000000000000000000000000;;		if s.timer != nil {
0000000000000000000000000000000000000000;;			s.timer.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s bodyWriterState) on100() {
0000000000000000000000000000000000000000;;		if s.timer == nil {
0000000000000000000000000000000000000000;;			// If we didn't do a delayed write, ignore the server's
0000000000000000000000000000000000000000;;			// bogus 100 continue response.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.timer.Stop()
0000000000000000000000000000000000000000;;		go func() { s.fnonce.Do(s.fn) }()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scheduleBodyWrite starts writing the body, either immediately (in
0000000000000000000000000000000000000000;;	// the common case) or after the delay timeout. It should not be
0000000000000000000000000000000000000000;;	// called until after the headers have been written.
0000000000000000000000000000000000000000;;	func (s bodyWriterState) scheduleBodyWrite() {
0000000000000000000000000000000000000000;;		if s.timer == nil {
0000000000000000000000000000000000000000;;			// We're not doing a delayed write (see
0000000000000000000000000000000000000000;;			// getBodyWriterState), so just start the writing
0000000000000000000000000000000000000000;;			// goroutine immediately.
0000000000000000000000000000000000000000;;			go s.fn()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		traceWait100Continue(s.cs.trace)
0000000000000000000000000000000000000000;;		if s.timer.Stop() {
0000000000000000000000000000000000000000;;			s.timer.Reset(s.delay)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isConnectionCloseRequest reports whether req should use its own
0000000000000000000000000000000000000000;;	// connection for a single request and then close the connection.
0000000000000000000000000000000000000000;;	func isConnectionCloseRequest(req *http.Request) bool {
0000000000000000000000000000000000000000;;		return req.Close || httplex.HeaderValuesContainsToken(req.Header["Connection"], "close")
0000000000000000000000000000000000000000;;	}
