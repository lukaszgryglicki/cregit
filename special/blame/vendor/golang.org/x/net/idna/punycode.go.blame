0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package idna
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file implements the Punycode algorithm from RFC 3492.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These parameter values are specified in section 5.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All computation is done with int32s, so that overflow behavior is identical
0000000000000000000000000000000000000000;;	// regardless of whether int is 32-bit or 64-bit.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		base        int32 = 36
0000000000000000000000000000000000000000;;		damp        int32 = 700
0000000000000000000000000000000000000000;;		initialBias int32 = 72
0000000000000000000000000000000000000000;;		initialN    int32 = 128
0000000000000000000000000000000000000000;;		skew        int32 = 38
0000000000000000000000000000000000000000;;		tmax        int32 = 26
0000000000000000000000000000000000000000;;		tmin        int32 = 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decode decodes a string as specified in section 6.2.
0000000000000000000000000000000000000000;;	func decode(encoded string) (string, error) {
0000000000000000000000000000000000000000;;		if encoded == "" {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pos := 1 + strings.LastIndex(encoded, "-")
0000000000000000000000000000000000000000;;		if pos == 1 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("idna: invalid label %q", encoded)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pos == len(encoded) {
0000000000000000000000000000000000000000;;			return encoded[:len(encoded)-1], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output := make([]rune, 0, len(encoded))
0000000000000000000000000000000000000000;;		if pos != 0 {
0000000000000000000000000000000000000000;;			for _, r := range encoded[:pos-1] {
0000000000000000000000000000000000000000;;				output = append(output, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, n, bias := int32(0), initialN, initialBias
0000000000000000000000000000000000000000;;		for pos < len(encoded) {
0000000000000000000000000000000000000000;;			oldI, w := i, int32(1)
0000000000000000000000000000000000000000;;			for k := base; ; k += base {
0000000000000000000000000000000000000000;;				if pos == len(encoded) {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("idna: invalid label %q", encoded)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				digit, ok := decodeDigit(encoded[pos])
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("idna: invalid label %q", encoded)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pos++
0000000000000000000000000000000000000000;;				i += digit * w
0000000000000000000000000000000000000000;;				if i < 0 {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("idna: invalid label %q", encoded)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t := k - bias
0000000000000000000000000000000000000000;;				if t < tmin {
0000000000000000000000000000000000000000;;					t = tmin
0000000000000000000000000000000000000000;;				} else if t > tmax {
0000000000000000000000000000000000000000;;					t = tmax
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if digit < t {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w *= base - t
0000000000000000000000000000000000000000;;				if w >= math.MaxInt32/base {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("idna: invalid label %q", encoded)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x := int32(len(output) + 1)
0000000000000000000000000000000000000000;;			bias = adapt(i-oldI, x, oldI == 0)
0000000000000000000000000000000000000000;;			n += i / x
0000000000000000000000000000000000000000;;			i %= x
0000000000000000000000000000000000000000;;			if n > utf8.MaxRune || len(output) >= 1024 {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("idna: invalid label %q", encoded)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			output = append(output, 0)
0000000000000000000000000000000000000000;;			copy(output[i+1:], output[i:])
0000000000000000000000000000000000000000;;			output[i] = n
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(output), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encode encodes a string as specified in section 6.3 and prepends prefix to
0000000000000000000000000000000000000000;;	// the result.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The "while h < length(input)" line in the specification becomes "for
0000000000000000000000000000000000000000;;	// remaining != 0" in the Go code, because len(s) in Go is in bytes, not runes.
0000000000000000000000000000000000000000;;	func encode(prefix, s string) (string, error) {
0000000000000000000000000000000000000000;;		output := make([]byte, len(prefix), len(prefix)+1+2*len(s))
0000000000000000000000000000000000000000;;		copy(output, prefix)
0000000000000000000000000000000000000000;;		delta, n, bias := int32(0), initialN, initialBias
0000000000000000000000000000000000000000;;		b, remaining := int32(0), int32(0)
0000000000000000000000000000000000000000;;		for _, r := range s {
0000000000000000000000000000000000000000;;			if r < 0x80 {
0000000000000000000000000000000000000000;;				b++
0000000000000000000000000000000000000000;;				output = append(output, byte(r))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				remaining++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := b
0000000000000000000000000000000000000000;;		if b > 0 {
0000000000000000000000000000000000000000;;			output = append(output, '-')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for remaining != 0 {
0000000000000000000000000000000000000000;;			m := int32(0x7fffffff)
0000000000000000000000000000000000000000;;			for _, r := range s {
0000000000000000000000000000000000000000;;				if m > r && r >= n {
0000000000000000000000000000000000000000;;					m = r
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delta += (m - n) * (h + 1)
0000000000000000000000000000000000000000;;			if delta < 0 {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("idna: invalid label %q", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n = m
0000000000000000000000000000000000000000;;			for _, r := range s {
0000000000000000000000000000000000000000;;				if r < n {
0000000000000000000000000000000000000000;;					delta++
0000000000000000000000000000000000000000;;					if delta < 0 {
0000000000000000000000000000000000000000;;						return "", fmt.Errorf("idna: invalid label %q", s)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if r > n {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				q := delta
0000000000000000000000000000000000000000;;				for k := base; ; k += base {
0000000000000000000000000000000000000000;;					t := k - bias
0000000000000000000000000000000000000000;;					if t < tmin {
0000000000000000000000000000000000000000;;						t = tmin
0000000000000000000000000000000000000000;;					} else if t > tmax {
0000000000000000000000000000000000000000;;						t = tmax
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if q < t {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					output = append(output, encodeDigit(t+(q-t)%(base-t)))
0000000000000000000000000000000000000000;;					q = (q - t) / (base - t)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				output = append(output, encodeDigit(q))
0000000000000000000000000000000000000000;;				bias = adapt(delta, h+1, h == b)
0000000000000000000000000000000000000000;;				delta = 0
0000000000000000000000000000000000000000;;				h++
0000000000000000000000000000000000000000;;				remaining--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delta++
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(output), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeDigit(x byte) (digit int32, ok bool) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case '0' <= x && x <= '9':
0000000000000000000000000000000000000000;;			return int32(x - ('0' - 26)), true
0000000000000000000000000000000000000000;;		case 'A' <= x && x <= 'Z':
0000000000000000000000000000000000000000;;			return int32(x - 'A'), true
0000000000000000000000000000000000000000;;		case 'a' <= x && x <= 'z':
0000000000000000000000000000000000000000;;			return int32(x - 'a'), true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeDigit(digit int32) byte {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case 0 <= digit && digit < 26:
0000000000000000000000000000000000000000;;			return byte(digit + 'a')
0000000000000000000000000000000000000000;;		case 26 <= digit && digit < 36:
0000000000000000000000000000000000000000;;			return byte(digit + ('0' - 26))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("idna: internal error in punycode encoding")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// adapt is the bias adaptation function specified in section 6.1.
0000000000000000000000000000000000000000;;	func adapt(delta, numPoints int32, firstTime bool) int32 {
0000000000000000000000000000000000000000;;		if firstTime {
0000000000000000000000000000000000000000;;			delta /= damp
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			delta /= 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delta += delta / numPoints
0000000000000000000000000000000000000000;;		k := int32(0)
0000000000000000000000000000000000000000;;		for delta > ((base-tmin)*tmax)/2 {
0000000000000000000000000000000000000000;;			delta /= base - tmin
0000000000000000000000000000000000000000;;			k += base
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k + (base-tmin+1)*delta/(delta+skew)
0000000000000000000000000000000000000000;;	}
