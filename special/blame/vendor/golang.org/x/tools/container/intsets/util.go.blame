0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
bbc36ee0615f4d3c102c811dd48ffc85f957293f;;	
0000000000000000000000000000000000000000;;	package intsets
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// From Hacker's Delight, fig 5.2.
0000000000000000000000000000000000000000;;	func popcountHD(x uint32) int {
0000000000000000000000000000000000000000;;		x -= (x >> 1) & 0x55555555
0000000000000000000000000000000000000000;;		x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
0000000000000000000000000000000000000000;;		x = (x + (x >> 4)) & 0x0f0f0f0f
0000000000000000000000000000000000000000;;		x = x + (x >> 8)
0000000000000000000000000000000000000000;;		x = x + (x >> 16)
0000000000000000000000000000000000000000;;		return int(x & 0x0000003f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var a [1 << 8]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		for i := range a {
0000000000000000000000000000000000000000;;			var n byte
0000000000000000000000000000000000000000;;			for x := i; x != 0; x >>= 1 {
0000000000000000000000000000000000000000;;				if x&1 != 0 {
0000000000000000000000000000000000000000;;					n++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a[i] = n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func popcountTable(x word) int {
0000000000000000000000000000000000000000;;		return int(a[byte(x>>(0*8))] +
0000000000000000000000000000000000000000;;			a[byte(x>>(1*8))] +
0000000000000000000000000000000000000000;;			a[byte(x>>(2*8))] +
0000000000000000000000000000000000000000;;			a[byte(x>>(3*8))] +
0000000000000000000000000000000000000000;;			a[byte(x>>(4*8))] +
0000000000000000000000000000000000000000;;			a[byte(x>>(5*8))] +
0000000000000000000000000000000000000000;;			a[byte(x>>(6*8))] +
0000000000000000000000000000000000000000;;			a[byte(x>>(7*8))])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nlz returns the number of leading zeros of x.
0000000000000000000000000000000000000000;;	// From Hacker's Delight, fig 5.11.
0000000000000000000000000000000000000000;;	func nlz(x word) int {
0000000000000000000000000000000000000000;;		x |= (x >> 1)
0000000000000000000000000000000000000000;;		x |= (x >> 2)
0000000000000000000000000000000000000000;;		x |= (x >> 4)
0000000000000000000000000000000000000000;;		x |= (x >> 8)
0000000000000000000000000000000000000000;;		x |= (x >> 16)
0000000000000000000000000000000000000000;;		x |= (x >> 32)
0000000000000000000000000000000000000000;;		return popcount(^x)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ntz returns the number of trailing zeros of x.
0000000000000000000000000000000000000000;;	// From Hacker's Delight, fig 5.13.
0000000000000000000000000000000000000000;;	func ntz(x word) int {
0000000000000000000000000000000000000000;;		if x == 0 {
0000000000000000000000000000000000000000;;			return bitsPerWord
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := 1
0000000000000000000000000000000000000000;;		if bitsPerWord == 64 {
0000000000000000000000000000000000000000;;			if (x & 0xffffffff) == 0 {
0000000000000000000000000000000000000000;;				n = n + 32
0000000000000000000000000000000000000000;;				x = x >> 32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (x & 0x0000ffff) == 0 {
0000000000000000000000000000000000000000;;			n = n + 16
0000000000000000000000000000000000000000;;			x = x >> 16
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (x & 0x000000ff) == 0 {
0000000000000000000000000000000000000000;;			n = n + 8
0000000000000000000000000000000000000000;;			x = x >> 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (x & 0x0000000f) == 0 {
0000000000000000000000000000000000000000;;			n = n + 4
0000000000000000000000000000000000000000;;			x = x >> 4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (x & 0x00000003) == 0 {
0000000000000000000000000000000000000000;;			n = n + 2
0000000000000000000000000000000000000000;;			x = x >> 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n - int(x&1)
0000000000000000000000000000000000000000;;	}
