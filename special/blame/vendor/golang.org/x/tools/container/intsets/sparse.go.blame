0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
bbc36ee0615f4d3c102c811dd48ffc85f957293f;;	
0000000000000000000000000000000000000000;;	// Package intsets provides Sparse, a compact and fast representation
0000000000000000000000000000000000000000;;	// for sparse sets of int values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The time complexity of the operations Len, Insert, Remove and Has
0000000000000000000000000000000000000000;;	// is in O(n) but in practice those methods are faster and more
0000000000000000000000000000000000000000;;	// space-efficient than equivalent operations on sets based on the Go
0000000000000000000000000000000000000000;;	// map type.  The IsEmpty, Min, Max, Clear and TakeMin operations
0000000000000000000000000000000000000000;;	// require constant time.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package intsets
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(adonovan):
0000000000000000000000000000000000000000;;	// - Add InsertAll(...int), RemoveAll(...int)
0000000000000000000000000000000000000000;;	// - Add 'bool changed' results for {Intersection,Difference}With too.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO(adonovan): implement Dense, a dense bit vector with a similar API.
0000000000000000000000000000000000000000;;	// The space usage would be proportional to Max(), not Len(), and the
0000000000000000000000000000000000000000;;	// implementation would be based upon big.Int.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO(adonovan): experiment with making the root block indirect (nil
0000000000000000000000000000000000000000;;	// iff IsEmpty).  This would reduce the memory usage when empty and
0000000000000000000000000000000000000000;;	// might simplify the aliasing invariants.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO(adonovan): opt: make UnionWith and Difference faster.
0000000000000000000000000000000000000000;;	// These are the hot-spots for go/pointer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Sparse is a set of int values.
0000000000000000000000000000000000000000;;	// Sparse operations (even queries) are not concurrency-safe.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The zero value for Sparse is a valid empty set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Sparse sets must be copied using the Copy method, not by assigning
0000000000000000000000000000000000000000;;	// a Sparse value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Sparse struct {
0000000000000000000000000000000000000000;;		// An uninitialized Sparse represents an empty set.
0000000000000000000000000000000000000000;;		// An empty set may also be represented by
0000000000000000000000000000000000000000;;		//  root.next == root.prev == &root.
0000000000000000000000000000000000000000;;		// In a non-empty set, root.next points to the first block and
0000000000000000000000000000000000000000;;		// root.prev to the last.
0000000000000000000000000000000000000000;;		// root.offset and root.bits are unused.
0000000000000000000000000000000000000000;;		root block
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type word uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_m            = ^word(0)
0000000000000000000000000000000000000000;;		bitsPerWord   = 8 << (_m>>8&1 + _m>>16&1 + _m>>32&1)
0000000000000000000000000000000000000000;;		bitsPerBlock  = 256 // optimal value for go/pointer solver performance
0000000000000000000000000000000000000000;;		wordsPerBlock = bitsPerBlock / bitsPerWord
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Limit values of implementation-specific int type.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MaxInt = int(^uint(0) >> 1)
0000000000000000000000000000000000000000;;		MinInt = -MaxInt - 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -- block ------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A set is represented as a circular doubly-linked list of blocks,
0000000000000000000000000000000000000000;;	// each containing an offset and a bit array of fixed size
0000000000000000000000000000000000000000;;	// bitsPerBlock; the blocks are ordered by increasing offset.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The set contains an element x iff the block whose offset is x - (x
0000000000000000000000000000000000000000;;	// mod bitsPerBlock) has the bit (x mod bitsPerBlock) set, where mod
0000000000000000000000000000000000000000;;	// is the Euclidean remainder.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A block may only be empty transiently.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type block struct {
0000000000000000000000000000000000000000;;		offset     int                 // offset mod bitsPerBlock == 0
0000000000000000000000000000000000000000;;		bits       [wordsPerBlock]word // contains at least one set bit
0000000000000000000000000000000000000000;;		next, prev *block              // doubly-linked list of blocks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wordMask returns the word index (in block.bits)
0000000000000000000000000000000000000000;;	// and single-bit mask for the block's ith bit.
0000000000000000000000000000000000000000;;	func wordMask(i uint) (w uint, mask word) {
0000000000000000000000000000000000000000;;		w = i / bitsPerWord
0000000000000000000000000000000000000000;;		mask = 1 << (i % bitsPerWord)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insert sets the block b's ith bit and
0000000000000000000000000000000000000000;;	// returns true if it was not already set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (b *block) insert(i uint) bool {
0000000000000000000000000000000000000000;;		w, mask := wordMask(i)
0000000000000000000000000000000000000000;;		if b.bits[w]&mask == 0 {
0000000000000000000000000000000000000000;;			b.bits[w] |= mask
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// remove clears the block's ith bit and
0000000000000000000000000000000000000000;;	// returns true if the bit was previously set.
0000000000000000000000000000000000000000;;	// NB: may leave the block empty.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (b *block) remove(i uint) bool {
0000000000000000000000000000000000000000;;		w, mask := wordMask(i)
0000000000000000000000000000000000000000;;		if b.bits[w]&mask != 0 {
0000000000000000000000000000000000000000;;			b.bits[w] &^= mask
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// has reports whether the block's ith bit is set.
0000000000000000000000000000000000000000;;	func (b *block) has(i uint) bool {
0000000000000000000000000000000000000000;;		w, mask := wordMask(i)
0000000000000000000000000000000000000000;;		return b.bits[w]&mask != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// empty reports whether b.len()==0, but more efficiently.
0000000000000000000000000000000000000000;;	func (b *block) empty() bool {
0000000000000000000000000000000000000000;;		for _, w := range b.bits {
0000000000000000000000000000000000000000;;			if w != 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// len returns the number of set bits in block b.
0000000000000000000000000000000000000000;;	func (b *block) len() int {
0000000000000000000000000000000000000000;;		var l int
0000000000000000000000000000000000000000;;		for _, w := range b.bits {
0000000000000000000000000000000000000000;;			l += popcount(w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// max returns the maximum element of the block.
0000000000000000000000000000000000000000;;	// The block must not be empty.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (b *block) max() int {
0000000000000000000000000000000000000000;;		bi := b.offset + bitsPerBlock
0000000000000000000000000000000000000000;;		// Decrement bi by number of high zeros in last.bits.
0000000000000000000000000000000000000000;;		for i := len(b.bits) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			if w := b.bits[i]; w != 0 {
0000000000000000000000000000000000000000;;				return bi - nlz(w) - 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bi -= bitsPerWord
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("BUG: empty block")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// min returns the minimum element of the block,
0000000000000000000000000000000000000000;;	// and also removes it if take is set.
0000000000000000000000000000000000000000;;	// The block must not be initially empty.
0000000000000000000000000000000000000000;;	// NB: may leave the block empty.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (b *block) min(take bool) int {
0000000000000000000000000000000000000000;;		for i, w := range b.bits {
0000000000000000000000000000000000000000;;			if w != 0 {
0000000000000000000000000000000000000000;;				tz := ntz(w)
0000000000000000000000000000000000000000;;				if take {
0000000000000000000000000000000000000000;;					b.bits[i] = w &^ (1 << uint(tz))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return b.offset + int(i*bitsPerWord) + tz
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("BUG: empty block")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// forEach calls f for each element of block b.
0000000000000000000000000000000000000000;;	// f must not mutate b's enclosing Sparse.
0000000000000000000000000000000000000000;;	func (b *block) forEach(f func(int)) {
0000000000000000000000000000000000000000;;		for i, w := range b.bits {
0000000000000000000000000000000000000000;;			offset := b.offset + i*bitsPerWord
0000000000000000000000000000000000000000;;			for bi := 0; w != 0 && bi < bitsPerWord; bi++ {
0000000000000000000000000000000000000000;;				if w&1 != 0 {
0000000000000000000000000000000000000000;;					f(offset)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				offset++
0000000000000000000000000000000000000000;;				w >>= 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// offsetAndBitIndex returns the offset of the block that would
0000000000000000000000000000000000000000;;	// contain x and the bit index of x within that block.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func offsetAndBitIndex(x int) (int, uint) {
0000000000000000000000000000000000000000;;		mod := x % bitsPerBlock
0000000000000000000000000000000000000000;;		if mod < 0 {
0000000000000000000000000000000000000000;;			// Euclidean (non-negative) remainder
0000000000000000000000000000000000000000;;			mod += bitsPerBlock
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x - mod, uint(mod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -- Sparse --------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// start returns the root's next block, which is the root block
0000000000000000000000000000000000000000;;	// (if s.IsEmpty()) or the first true block otherwise.
0000000000000000000000000000000000000000;;	// start has the side effect of ensuring that s is properly
0000000000000000000000000000000000000000;;	// initialized.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *Sparse) start() *block {
0000000000000000000000000000000000000000;;		root := &s.root
0000000000000000000000000000000000000000;;		if root.next == nil {
0000000000000000000000000000000000000000;;			root.next = root
0000000000000000000000000000000000000000;;			root.prev = root
0000000000000000000000000000000000000000;;		} else if root.next.prev != root {
0000000000000000000000000000000000000000;;			// Copying a Sparse x leads to pernicious corruption: the
0000000000000000000000000000000000000000;;			// new Sparse y shares the old linked list, but iteration
0000000000000000000000000000000000000000;;			// on y will never encounter &y.root so it goes into a
0000000000000000000000000000000000000000;;			// loop.  Fail fast before this occurs.
0000000000000000000000000000000000000000;;			panic("A Sparse has been copied without (*Sparse).Copy()")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return root.next
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty reports whether the set s is empty.
0000000000000000000000000000000000000000;;	func (s *Sparse) IsEmpty() bool {
0000000000000000000000000000000000000000;;		return s.start() == &s.root
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of elements in the set s.
0000000000000000000000000000000000000000;;	func (s *Sparse) Len() int {
0000000000000000000000000000000000000000;;		var l int
0000000000000000000000000000000000000000;;		for b := s.start(); b != &s.root; b = b.next {
0000000000000000000000000000000000000000;;			l += b.len()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Max returns the maximum element of the set s, or MinInt if s is empty.
0000000000000000000000000000000000000000;;	func (s *Sparse) Max() int {
0000000000000000000000000000000000000000;;		if s.IsEmpty() {
0000000000000000000000000000000000000000;;			return MinInt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.root.prev.max()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Min returns the minimum element of the set s, or MaxInt if s is empty.
0000000000000000000000000000000000000000;;	func (s *Sparse) Min() int {
0000000000000000000000000000000000000000;;		if s.IsEmpty() {
0000000000000000000000000000000000000000;;			return MaxInt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.root.next.min(false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// block returns the block that would contain offset,
0000000000000000000000000000000000000000;;	// or nil if s contains no such block.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *Sparse) block(offset int) *block {
0000000000000000000000000000000000000000;;		b := s.start()
0000000000000000000000000000000000000000;;		for b != &s.root && b.offset <= offset {
0000000000000000000000000000000000000000;;			if b.offset == offset {
0000000000000000000000000000000000000000;;				return b
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b = b.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert adds x to the set s, and reports whether the set grew.
0000000000000000000000000000000000000000;;	func (s *Sparse) Insert(x int) bool {
0000000000000000000000000000000000000000;;		offset, i := offsetAndBitIndex(x)
0000000000000000000000000000000000000000;;		b := s.start()
0000000000000000000000000000000000000000;;		for b != &s.root && b.offset <= offset {
0000000000000000000000000000000000000000;;			if b.offset == offset {
0000000000000000000000000000000000000000;;				return b.insert(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b = b.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Insert new block before b.
0000000000000000000000000000000000000000;;		new := &block{offset: offset}
0000000000000000000000000000000000000000;;		new.next = b
0000000000000000000000000000000000000000;;		new.prev = b.prev
0000000000000000000000000000000000000000;;		new.prev.next = new
0000000000000000000000000000000000000000;;		new.next.prev = new
0000000000000000000000000000000000000000;;		return new.insert(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Sparse) removeBlock(b *block) {
0000000000000000000000000000000000000000;;		b.prev.next = b.next
0000000000000000000000000000000000000000;;		b.next.prev = b.prev
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes x from the set s, and reports whether the set shrank.
0000000000000000000000000000000000000000;;	func (s *Sparse) Remove(x int) bool {
0000000000000000000000000000000000000000;;		offset, i := offsetAndBitIndex(x)
0000000000000000000000000000000000000000;;		if b := s.block(offset); b != nil {
0000000000000000000000000000000000000000;;			if !b.remove(i) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b.empty() {
0000000000000000000000000000000000000000;;				s.removeBlock(b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clear removes all elements from the set s.
0000000000000000000000000000000000000000;;	func (s *Sparse) Clear() {
0000000000000000000000000000000000000000;;		s.root.next = &s.root
0000000000000000000000000000000000000000;;		s.root.prev = &s.root
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If set s is non-empty, TakeMin sets *p to the minimum element of
0000000000000000000000000000000000000000;;	// the set s, removes that element from the set and returns true.
0000000000000000000000000000000000000000;;	// Otherwise, it returns false and *p is undefined.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method may be used for iteration over a worklist like so:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 	var x int
0000000000000000000000000000000000000000;;	// 	for worklist.TakeMin(&x) { use(x) }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *Sparse) TakeMin(p *int) bool {
0000000000000000000000000000000000000000;;		head := s.start()
0000000000000000000000000000000000000000;;		if head == &s.root {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*p = head.min(true)
0000000000000000000000000000000000000000;;		if head.empty() {
0000000000000000000000000000000000000000;;			s.removeBlock(head)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has reports whether x is an element of the set s.
0000000000000000000000000000000000000000;;	func (s *Sparse) Has(x int) bool {
0000000000000000000000000000000000000000;;		offset, i := offsetAndBitIndex(x)
0000000000000000000000000000000000000000;;		if b := s.block(offset); b != nil {
0000000000000000000000000000000000000000;;			return b.has(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// forEach applies function f to each element of the set s in order.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// f must not mutate s.  Consequently, forEach is not safe to expose
0000000000000000000000000000000000000000;;	// to clients.  In any case, using "range s.AppendTo()" allows more
0000000000000000000000000000000000000000;;	// natural control flow with continue/break/return.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *Sparse) forEach(f func(int)) {
0000000000000000000000000000000000000000;;		for b := s.start(); b != &s.root; b = b.next {
0000000000000000000000000000000000000000;;			b.forEach(f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy sets s to the value of x.
0000000000000000000000000000000000000000;;	func (s *Sparse) Copy(x *Sparse) {
0000000000000000000000000000000000000000;;		if s == x {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		for xb != &x.root {
0000000000000000000000000000000000000000;;			if sb == &s.root {
0000000000000000000000000000000000000000;;				sb = s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sb.offset = xb.offset
0000000000000000000000000000000000000000;;			sb.bits = xb.bits
0000000000000000000000000000000000000000;;			xb = xb.next
0000000000000000000000000000000000000000;;			sb = sb.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.discardTail(sb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertBlockBefore returns a new block, inserting it before next.
0000000000000000000000000000000000000000;;	func (s *Sparse) insertBlockBefore(next *block) *block {
0000000000000000000000000000000000000000;;		b := new(block)
0000000000000000000000000000000000000000;;		b.next = next
0000000000000000000000000000000000000000;;		b.prev = next.prev
0000000000000000000000000000000000000000;;		b.prev.next = b
0000000000000000000000000000000000000000;;		next.prev = b
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// discardTail removes block b and all its successors from s.
0000000000000000000000000000000000000000;;	func (s *Sparse) discardTail(b *block) {
0000000000000000000000000000000000000000;;		if b != &s.root {
0000000000000000000000000000000000000000;;			b.prev.next = &s.root
0000000000000000000000000000000000000000;;			s.root.prev = b.prev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntersectionWith sets s to the intersection s ∩ x.
0000000000000000000000000000000000000000;;	func (s *Sparse) IntersectionWith(x *Sparse) {
0000000000000000000000000000000000000000;;		if s == x {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		for xb != &x.root && sb != &s.root {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case xb.offset < sb.offset:
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case xb.offset > sb.offset:
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;				s.removeBlock(sb.prev)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				var sum word
0000000000000000000000000000000000000000;;				for i := range sb.bits {
0000000000000000000000000000000000000000;;					r := xb.bits[i] & sb.bits[i]
0000000000000000000000000000000000000000;;					sb.bits[i] = r
0000000000000000000000000000000000000000;;					sum |= r
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if sum != 0 {
0000000000000000000000000000000000000000;;					sb = sb.next
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// sb will be overwritten or removed
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.discardTail(sb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Intersection sets s to the intersection x ∩ y.
0000000000000000000000000000000000000000;;	func (s *Sparse) Intersection(x, y *Sparse) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case s == x:
0000000000000000000000000000000000000000;;			s.IntersectionWith(y)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case s == y:
0000000000000000000000000000000000000000;;			s.IntersectionWith(x)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case x == y:
0000000000000000000000000000000000000000;;			s.Copy(x)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		yb := y.start()
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		for xb != &x.root && yb != &y.root {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case xb.offset < yb.offset:
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case xb.offset > yb.offset:
0000000000000000000000000000000000000000;;				yb = yb.next
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if sb == &s.root {
0000000000000000000000000000000000000000;;				sb = s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sb.offset = xb.offset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var sum word
0000000000000000000000000000000000000000;;			for i := range sb.bits {
0000000000000000000000000000000000000000;;				r := xb.bits[i] & yb.bits[i]
0000000000000000000000000000000000000000;;				sb.bits[i] = r
0000000000000000000000000000000000000000;;				sum |= r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sum != 0 {
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// sb will be overwritten or removed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			xb = xb.next
0000000000000000000000000000000000000000;;			yb = yb.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.discardTail(sb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Intersects reports whether s ∩ x ≠ ∅.
0000000000000000000000000000000000000000;;	func (s *Sparse) Intersects(x *Sparse) bool {
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		for sb != &s.root && xb != &x.root {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case xb.offset < sb.offset:
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;			case xb.offset > sb.offset:
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				for i := range sb.bits {
0000000000000000000000000000000000000000;;					if sb.bits[i]&xb.bits[i] != 0 {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnionWith sets s to the union s ∪ x, and reports whether s grew.
0000000000000000000000000000000000000000;;	func (s *Sparse) UnionWith(x *Sparse) bool {
0000000000000000000000000000000000000000;;		if s == x {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var changed bool
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		for xb != &x.root {
0000000000000000000000000000000000000000;;			if sb != &s.root && sb.offset == xb.offset {
0000000000000000000000000000000000000000;;				for i := range xb.bits {
0000000000000000000000000000000000000000;;					if sb.bits[i] != xb.bits[i] {
0000000000000000000000000000000000000000;;						sb.bits[i] |= xb.bits[i]
0000000000000000000000000000000000000000;;						changed = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;			} else if sb == &s.root || sb.offset > xb.offset {
0000000000000000000000000000000000000000;;				sb = s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;				sb.offset = xb.offset
0000000000000000000000000000000000000000;;				sb.bits = xb.bits
0000000000000000000000000000000000000000;;				changed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sb = sb.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return changed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Union sets s to the union x ∪ y.
0000000000000000000000000000000000000000;;	func (s *Sparse) Union(x, y *Sparse) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case x == y:
0000000000000000000000000000000000000000;;			s.Copy(x)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case s == x:
0000000000000000000000000000000000000000;;			s.UnionWith(y)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case s == y:
0000000000000000000000000000000000000000;;			s.UnionWith(x)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		yb := y.start()
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		for xb != &x.root || yb != &y.root {
0000000000000000000000000000000000000000;;			if sb == &s.root {
0000000000000000000000000000000000000000;;				sb = s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case yb == &y.root || (xb != &x.root && xb.offset < yb.offset):
0000000000000000000000000000000000000000;;				sb.offset = xb.offset
0000000000000000000000000000000000000000;;				sb.bits = xb.bits
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case xb == &x.root || (yb != &y.root && yb.offset < xb.offset):
0000000000000000000000000000000000000000;;				sb.offset = yb.offset
0000000000000000000000000000000000000000;;				sb.bits = yb.bits
0000000000000000000000000000000000000000;;				yb = yb.next
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				sb.offset = xb.offset
0000000000000000000000000000000000000000;;				for i := range xb.bits {
0000000000000000000000000000000000000000;;					sb.bits[i] = xb.bits[i] | yb.bits[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;				yb = yb.next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sb = sb.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.discardTail(sb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DifferenceWith sets s to the difference s ∖ x.
0000000000000000000000000000000000000000;;	func (s *Sparse) DifferenceWith(x *Sparse) {
0000000000000000000000000000000000000000;;		if s == x {
0000000000000000000000000000000000000000;;			s.Clear()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		for xb != &x.root && sb != &s.root {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case xb.offset > sb.offset:
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case xb.offset < sb.offset:
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				var sum word
0000000000000000000000000000000000000000;;				for i := range sb.bits {
0000000000000000000000000000000000000000;;					r := sb.bits[i] & ^xb.bits[i]
0000000000000000000000000000000000000000;;					sb.bits[i] = r
0000000000000000000000000000000000000000;;					sum |= r
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if sum == 0 {
0000000000000000000000000000000000000000;;					s.removeBlock(sb.prev)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Difference sets s to the difference x ∖ y.
0000000000000000000000000000000000000000;;	func (s *Sparse) Difference(x, y *Sparse) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case x == y:
0000000000000000000000000000000000000000;;			s.Clear()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case s == x:
0000000000000000000000000000000000000000;;			s.DifferenceWith(y)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case s == y:
0000000000000000000000000000000000000000;;			var y2 Sparse
0000000000000000000000000000000000000000;;			y2.Copy(y)
0000000000000000000000000000000000000000;;			s.Difference(x, &y2)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		yb := y.start()
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		for xb != &x.root && yb != &y.root {
0000000000000000000000000000000000000000;;			if xb.offset > yb.offset {
0000000000000000000000000000000000000000;;				// y has block, x has none
0000000000000000000000000000000000000000;;				yb = yb.next
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if sb == &s.root {
0000000000000000000000000000000000000000;;				sb = s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sb.offset = xb.offset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case xb.offset < yb.offset:
0000000000000000000000000000000000000000;;				// x has block, y has none
0000000000000000000000000000000000000000;;				sb.bits = xb.bits
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// x and y have corresponding blocks
0000000000000000000000000000000000000000;;				var sum word
0000000000000000000000000000000000000000;;				for i := range sb.bits {
0000000000000000000000000000000000000000;;					r := xb.bits[i] & ^yb.bits[i]
0000000000000000000000000000000000000000;;					sb.bits[i] = r
0000000000000000000000000000000000000000;;					sum |= r
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if sum != 0 {
0000000000000000000000000000000000000000;;					sb = sb.next
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// sb will be overwritten or removed
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				yb = yb.next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			xb = xb.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for xb != &x.root {
0000000000000000000000000000000000000000;;			if sb == &s.root {
0000000000000000000000000000000000000000;;				sb = s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sb.offset = xb.offset
0000000000000000000000000000000000000000;;			sb.bits = xb.bits
0000000000000000000000000000000000000000;;			sb = sb.next
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			xb = xb.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.discardTail(sb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SymmetricDifferenceWith sets s to the symmetric difference s ∆ x.
0000000000000000000000000000000000000000;;	func (s *Sparse) SymmetricDifferenceWith(x *Sparse) {
0000000000000000000000000000000000000000;;		if s == x {
0000000000000000000000000000000000000000;;			s.Clear()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		for xb != &x.root && sb != &s.root {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case sb.offset < xb.offset:
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;			case xb.offset < sb.offset:
0000000000000000000000000000000000000000;;				nb := s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;				nb.offset = xb.offset
0000000000000000000000000000000000000000;;				nb.bits = xb.bits
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				var sum word
0000000000000000000000000000000000000000;;				for i := range sb.bits {
0000000000000000000000000000000000000000;;					r := sb.bits[i] ^ xb.bits[i]
0000000000000000000000000000000000000000;;					sb.bits[i] = r
0000000000000000000000000000000000000000;;					sum |= r
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;				if sum == 0 {
0000000000000000000000000000000000000000;;					s.removeBlock(sb.prev)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for xb != &x.root { // append the tail of x to s
0000000000000000000000000000000000000000;;			sb = s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;			sb.offset = xb.offset
0000000000000000000000000000000000000000;;			sb.bits = xb.bits
0000000000000000000000000000000000000000;;			sb = sb.next
0000000000000000000000000000000000000000;;			xb = xb.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SymmetricDifference sets s to the symmetric difference x ∆ y.
0000000000000000000000000000000000000000;;	func (s *Sparse) SymmetricDifference(x, y *Sparse) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case x == y:
0000000000000000000000000000000000000000;;			s.Clear()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case s == x:
0000000000000000000000000000000000000000;;			s.SymmetricDifferenceWith(y)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case s == y:
0000000000000000000000000000000000000000;;			s.SymmetricDifferenceWith(x)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		yb := y.start()
0000000000000000000000000000000000000000;;		for xb != &x.root && yb != &y.root {
0000000000000000000000000000000000000000;;			if sb == &s.root {
0000000000000000000000000000000000000000;;				sb = s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case yb.offset < xb.offset:
0000000000000000000000000000000000000000;;				sb.offset = yb.offset
0000000000000000000000000000000000000000;;				sb.bits = yb.bits
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;				yb = yb.next
0000000000000000000000000000000000000000;;			case xb.offset < yb.offset:
0000000000000000000000000000000000000000;;				sb.offset = xb.offset
0000000000000000000000000000000000000000;;				sb.bits = xb.bits
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				var sum word
0000000000000000000000000000000000000000;;				for i := range sb.bits {
0000000000000000000000000000000000000000;;					r := xb.bits[i] ^ yb.bits[i]
0000000000000000000000000000000000000000;;					sb.bits[i] = r
0000000000000000000000000000000000000000;;					sum |= r
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if sum != 0 {
0000000000000000000000000000000000000000;;					sb.offset = xb.offset
0000000000000000000000000000000000000000;;					sb = sb.next
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;				yb = yb.next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for xb != &x.root { // append the tail of x to s
0000000000000000000000000000000000000000;;			if sb == &s.root {
0000000000000000000000000000000000000000;;				sb = s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sb.offset = xb.offset
0000000000000000000000000000000000000000;;			sb.bits = xb.bits
0000000000000000000000000000000000000000;;			sb = sb.next
0000000000000000000000000000000000000000;;			xb = xb.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for yb != &y.root { // append the tail of y to s
0000000000000000000000000000000000000000;;			if sb == &s.root {
0000000000000000000000000000000000000000;;				sb = s.insertBlockBefore(sb)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sb.offset = yb.offset
0000000000000000000000000000000000000000;;			sb.bits = yb.bits
0000000000000000000000000000000000000000;;			sb = sb.next
0000000000000000000000000000000000000000;;			yb = yb.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.discardTail(sb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SubsetOf reports whether s ∖ x = ∅.
0000000000000000000000000000000000000000;;	func (s *Sparse) SubsetOf(x *Sparse) bool {
0000000000000000000000000000000000000000;;		if s == x {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		xb := x.start()
0000000000000000000000000000000000000000;;		for sb != &s.root {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case xb == &x.root || xb.offset > sb.offset:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			case xb.offset < sb.offset:
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				for i := range sb.bits {
0000000000000000000000000000000000000000;;					if sb.bits[i]&^xb.bits[i] != 0 {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sb = sb.next
0000000000000000000000000000000000000000;;				xb = xb.next
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equals reports whether the sets s and t have the same elements.
0000000000000000000000000000000000000000;;	func (s *Sparse) Equals(t *Sparse) bool {
0000000000000000000000000000000000000000;;		if s == t {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sb := s.start()
0000000000000000000000000000000000000000;;		tb := t.start()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case sb == &s.root && tb == &t.root:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case sb == &s.root || tb == &t.root:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			case sb.offset != tb.offset:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			case sb.bits != tb.bits:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sb = sb.next
0000000000000000000000000000000000000000;;			tb = tb.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a human-readable description of the set s.
0000000000000000000000000000000000000000;;	func (s *Sparse) String() string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		buf.WriteByte('{')
0000000000000000000000000000000000000000;;		s.forEach(func(x int) {
0000000000000000000000000000000000000000;;			if buf.Len() > 1 {
0000000000000000000000000000000000000000;;				buf.WriteByte(' ')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "%d", x)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		buf.WriteByte('}')
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BitString returns the set as a string of 1s and 0s denoting the sum
0000000000000000000000000000000000000000;;	// of the i'th powers of 2, for each i in s.  A radix point, always
0000000000000000000000000000000000000000;;	// preceded by a digit, appears if the sum is non-integral.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Examples:
0000000000000000000000000000000000000000;;	//              {}.BitString() =      "0"
0000000000000000000000000000000000000000;;	//           {4,5}.BitString() = "110000"
0000000000000000000000000000000000000000;;	//            {-3}.BitString() =      "0.001"
0000000000000000000000000000000000000000;;	//      {-3,0,4,5}.BitString() = "110001.001"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *Sparse) BitString() string {
0000000000000000000000000000000000000000;;		if s.IsEmpty() {
0000000000000000000000000000000000000000;;			return "0"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		min, max := s.Min(), s.Max()
0000000000000000000000000000000000000000;;		var nbytes int
0000000000000000000000000000000000000000;;		if max > 0 {
0000000000000000000000000000000000000000;;			nbytes = max
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nbytes++ // zero bit
0000000000000000000000000000000000000000;;		radix := nbytes
0000000000000000000000000000000000000000;;		if min < 0 {
0000000000000000000000000000000000000000;;			nbytes += len(".") - min
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := make([]byte, nbytes)
0000000000000000000000000000000000000000;;		for i := range b {
0000000000000000000000000000000000000000;;			b[i] = '0'
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if radix < nbytes {
0000000000000000000000000000000000000000;;			b[radix] = '.'
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.forEach(func(x int) {
0000000000000000000000000000000000000000;;			if x >= 0 {
0000000000000000000000000000000000000000;;				x += len(".")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b[radix-x] = '1'
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return string(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GoString returns a string showing the internal representation of
0000000000000000000000000000000000000000;;	// the set s.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *Sparse) GoString() string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		for b := s.start(); b != &s.root; b = b.next {
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "block %p {offset=%d next=%p prev=%p",
0000000000000000000000000000000000000000;;				b, b.offset, b.next, b.prev)
0000000000000000000000000000000000000000;;			for _, w := range b.bits {
0000000000000000000000000000000000000000;;				fmt.Fprintf(&buf, " 0%016x", w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "}\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppendTo returns the result of appending the elements of s to slice
0000000000000000000000000000000000000000;;	// in order.
0000000000000000000000000000000000000000;;	func (s *Sparse) AppendTo(slice []int) []int {
0000000000000000000000000000000000000000;;		s.forEach(func(x int) {
0000000000000000000000000000000000000000;;			slice = append(slice, x)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return slice
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -- Testing/debugging ------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// check returns an error if the representation invariants of s are violated.
0000000000000000000000000000000000000000;;	func (s *Sparse) check() error {
0000000000000000000000000000000000000000;;		if !s.root.empty() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("non-empty root block")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.root.offset != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("root block has non-zero offset %d", s.root.offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for b := s.start(); b != &s.root; b = b.next {
0000000000000000000000000000000000000000;;			if b.offset%bitsPerBlock != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("bad offset modulo: %d", b.offset)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b.empty() {
0000000000000000000000000000000000000000;;				return fmt.Errorf("empty block")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b.prev.next != b {
0000000000000000000000000000000000000000;;				return fmt.Errorf("bad prev.next link")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b.next.prev != b {
0000000000000000000000000000000000000000;;				return fmt.Errorf("bad next.prev link")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b.prev != &s.root {
0000000000000000000000000000000000000000;;				if b.offset <= b.prev.offset {
0000000000000000000000000000000000000000;;					return fmt.Errorf("bad offset order: b.offset=%d, prev.offset=%d",
0000000000000000000000000000000000000000;;						b.offset, b.prev.offset)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
