0000000000000000000000000000000000000000;;	// Copyright 2009,2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
12a86164cdbf8548dc1c57ea2633daf61c4daab0;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_freebsd.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_freebsd.go][vendor/golang.org/x/sys/unix/syscall_freebsd.go];	
0000000000000000000000000000000000000000;;	// FreeBSD system calls.
0000000000000000000000000000000000000000;;	// This file is compiled as ordinary Go code,
0000000000000000000000000000000000000000;;	// but it is also input to mksyscall,
0000000000000000000000000000000000000000;;	// which parses the //sys lines and generates system call stubs.
0000000000000000000000000000000000000000;;	// Note that sometimes we use a lowercase //sys name and wrap
0000000000000000000000000000000000000000;;	// it in our own nicer implementation, either here or in
0000000000000000000000000000000000000000;;	// syscall_bsd.go or syscall_unix.go.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unix
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrDatalink struct {
0000000000000000000000000000000000000000;;		Len    uint8
0000000000000000000000000000000000000000;;		Family uint8
0000000000000000000000000000000000000000;;		Index  uint16
0000000000000000000000000000000000000000;;		Type   uint8
0000000000000000000000000000000000000000;;		Nlen   uint8
0000000000000000000000000000000000000000;;		Alen   uint8
0000000000000000000000000000000000000000;;		Slen   uint8
0000000000000000000000000000000000000000;;		Data   [46]int8
0000000000000000000000000000000000000000;;		raw    RawSockaddrDatalink
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Translate "kern.hostname" to []_C_int{0,1,2,3}.
0000000000000000000000000000000000000000;;	func nametomib(name string) (mib []_C_int, err error) {
0000000000000000000000000000000000000000;;		const siz = unsafe.Sizeof(mib[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NOTE(rsc): It seems strange to set the buffer to have
0000000000000000000000000000000000000000;;		// size CTL_MAXNAME+2 but use only CTL_MAXNAME
0000000000000000000000000000000000000000;;		// as the size.  I don't know why the +2 is here, but the
0000000000000000000000000000000000000000;;		// kernel uses +2 for its own implementation of this function.
0000000000000000000000000000000000000000;;		// I am scared that if we don't include the +2 here, the kernel
0000000000000000000000000000000000000000;;		// will silently write 2 words farther than we specify
0000000000000000000000000000000000000000;;		// and we'll get memory corruption.
0000000000000000000000000000000000000000;;		var buf [CTL_MAXNAME + 2]_C_int
0000000000000000000000000000000000000000;;		n := uintptr(CTL_MAXNAME) * siz
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := (*byte)(unsafe.Pointer(&buf[0]))
0000000000000000000000000000000000000000;;		bytes, err := ByteSliceFromString(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Magic sysctl: "setting" 0.3 to a string name
0000000000000000000000000000000000000000;;		// lets you read back the array of integers form.
0000000000000000000000000000000000000000;;		if err = sysctl([]_C_int{0, 3}, p, &n, &bytes[0], uintptr(len(name))); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf[0 : n/siz], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseDirent parses up to max directory entries in buf,
0000000000000000000000000000000000000000;;	// appending the names to names.  It returns the number
0000000000000000000000000000000000000000;;	// bytes consumed from buf, the number of entries added
0000000000000000000000000000000000000000;;	// to names, and the new names slice.
0000000000000000000000000000000000000000;;	func ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string) {
0000000000000000000000000000000000000000;;		origlen := len(buf)
0000000000000000000000000000000000000000;;		for max != 0 && len(buf) > 0 {
0000000000000000000000000000000000000000;;			dirent := (*Dirent)(unsafe.Pointer(&buf[0]))
0000000000000000000000000000000000000000;;			if dirent.Reclen == 0 {
0000000000000000000000000000000000000000;;				buf = nil
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf = buf[dirent.Reclen:]
0000000000000000000000000000000000000000;;			if dirent.Fileno == 0 { // File absent in directory.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bytes := (*[10000]byte)(unsafe.Pointer(&dirent.Name[0]))
0000000000000000000000000000000000000000;;			var name = string(bytes[0:dirent.Namlen])
0000000000000000000000000000000000000000;;			if name == "." || name == ".." { // Useless names
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			max--
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			names = append(names, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return origlen - len(buf), count, names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb pipe() (r int, w int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Pipe(p []int) (err error) {
0000000000000000000000000000000000000000;;		if len(p) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p[0], p[1], err = pipe()
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error) {
0000000000000000000000000000000000000000;;		var value IPMreqn
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofIPMreqn)
0000000000000000000000000000000000000000;;		errno := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, errno
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error) {
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(mreq), unsafe.Sizeof(*mreq))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Accept4(fd, flags int) (nfd int, sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		var len _Socklen = SizeofSockaddrAny
0000000000000000000000000000000000000000;;		nfd, err = accept4(fd, &rsa, &len, flags)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len > SizeofSockaddrAny {
0000000000000000000000000000000000000000;;			panic("RawSockaddrAny too small")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa, err = anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Close(nfd)
0000000000000000000000000000000000000000;;			nfd = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getfsstat(buf []Statfs_t, flags int) (n int, err error) {
0000000000000000000000000000000000000000;;		var _p0 unsafe.Pointer
0000000000000000000000000000000000000000;;		var bufsize uintptr
0000000000000000000000000000000000000000;;		if len(buf) > 0 {
0000000000000000000000000000000000000000;;			_p0 = unsafe.Pointer(&buf[0])
0000000000000000000000000000000000000000;;			bufsize = unsafe.Sizeof(Statfs_t{}) * uintptr(len(buf))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(_p0), bufsize, uintptr(flags))
0000000000000000000000000000000000000000;;		use(unsafe.Pointer(_p0))
0000000000000000000000000000000000000000;;		n = int(r0)
0000000000000000000000000000000000000000;;		if e1 != 0 {
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Derive extattr namespace and attribute name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func xattrnamespace(fullattr string) (ns int, attr string, err error) {
0000000000000000000000000000000000000000;;		s := -1
0000000000000000000000000000000000000000;;		for idx, val := range fullattr {
0000000000000000000000000000000000000000;;			if val == '.' {
0000000000000000000000000000000000000000;;				s = idx
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s == -1 {
0000000000000000000000000000000000000000;;			return -1, "", ENOATTR
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespace := fullattr[0:s]
0000000000000000000000000000000000000000;;		attr = fullattr[s+1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch namespace {
0000000000000000000000000000000000000000;;		case "user":
0000000000000000000000000000000000000000;;			return EXTATTR_NAMESPACE_USER, attr, nil
0000000000000000000000000000000000000000;;		case "system":
0000000000000000000000000000000000000000;;			return EXTATTR_NAMESPACE_SYSTEM, attr, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return -1, "", ENOATTR
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initxattrdest(dest []byte, idx int) (d unsafe.Pointer) {
0000000000000000000000000000000000000000;;		if len(dest) > idx {
0000000000000000000000000000000000000000;;			return unsafe.Pointer(&dest[idx])
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return unsafe.Pointer(_zero)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FreeBSD implements its own syscalls to handle extended attributes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getxattr(file string, attr string, dest []byte) (sz int, err error) {
0000000000000000000000000000000000000000;;		d := initxattrdest(dest, 0)
0000000000000000000000000000000000000000;;		destsize := len(dest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsid, a, err := xattrnamespace(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ExtattrGetFile(file, nsid, a, uintptr(d), destsize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Fgetxattr(fd int, attr string, dest []byte) (sz int, err error) {
0000000000000000000000000000000000000000;;		d := initxattrdest(dest, 0)
0000000000000000000000000000000000000000;;		destsize := len(dest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsid, a, err := xattrnamespace(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ExtattrGetFd(fd, nsid, a, uintptr(d), destsize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Lgetxattr(link string, attr string, dest []byte) (sz int, err error) {
0000000000000000000000000000000000000000;;		d := initxattrdest(dest, 0)
0000000000000000000000000000000000000000;;		destsize := len(dest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsid, a, err := xattrnamespace(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ExtattrGetLink(link, nsid, a, uintptr(d), destsize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flags are unused on FreeBSD
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Fsetxattr(fd int, attr string, data []byte, flags int) (err error) {
0000000000000000000000000000000000000000;;		d := unsafe.Pointer(&data[0])
0000000000000000000000000000000000000000;;		datasiz := len(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsid, a, err := xattrnamespace(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = ExtattrSetFd(fd, nsid, a, uintptr(d), datasiz)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Setxattr(file string, attr string, data []byte, flags int) (err error) {
0000000000000000000000000000000000000000;;		d := unsafe.Pointer(&data[0])
0000000000000000000000000000000000000000;;		datasiz := len(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsid, a, err := xattrnamespace(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = ExtattrSetFile(file, nsid, a, uintptr(d), datasiz)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Lsetxattr(link string, attr string, data []byte, flags int) (err error) {
0000000000000000000000000000000000000000;;		d := unsafe.Pointer(&data[0])
0000000000000000000000000000000000000000;;		datasiz := len(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nsid, a, err := xattrnamespace(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = ExtattrSetLink(link, nsid, a, uintptr(d), datasiz)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Removexattr(file string, attr string) (err error) {
0000000000000000000000000000000000000000;;		nsid, a, err := xattrnamespace(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = ExtattrDeleteFile(file, nsid, a)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Fremovexattr(fd int, attr string) (err error) {
0000000000000000000000000000000000000000;;		nsid, a, err := xattrnamespace(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = ExtattrDeleteFd(fd, nsid, a)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Lremovexattr(link string, attr string) (err error) {
0000000000000000000000000000000000000000;;		nsid, a, err := xattrnamespace(attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = ExtattrDeleteLink(link, nsid, a)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Listxattr(file string, dest []byte) (sz int, err error) {
0000000000000000000000000000000000000000;;		d := initxattrdest(dest, 0)
0000000000000000000000000000000000000000;;		destsiz := len(dest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FreeBSD won't allow you to list xattrs from multiple namespaces
0000000000000000000000000000000000000000;;		s := 0
0000000000000000000000000000000000000000;;		var e error
0000000000000000000000000000000000000000;;		for _, nsid := range [...]int{EXTATTR_NAMESPACE_USER, EXTATTR_NAMESPACE_SYSTEM} {
0000000000000000000000000000000000000000;;			stmp, e := ExtattrListFile(file, nsid, uintptr(d), destsiz)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			/* Errors accessing system attrs are ignored so that
0000000000000000000000000000000000000000;;			 * we can implement the Linux-like behavior of omitting errors that
0000000000000000000000000000000000000000;;			 * we don't have read permissions on
0000000000000000000000000000000000000000;;			 *
0000000000000000000000000000000000000000;;			 * Linux will still error if we ask for user attributes on a file that
0000000000000000000000000000000000000000;;			 * we don't have read permissions on, so don't ignore those errors
0000000000000000000000000000000000000000;;			 */
0000000000000000000000000000000000000000;;			if e != nil && e == EPERM && nsid != EXTATTR_NAMESPACE_USER {
0000000000000000000000000000000000000000;;				e = nil
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if e != nil {
0000000000000000000000000000000000000000;;				return s, e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s += stmp
0000000000000000000000000000000000000000;;			destsiz -= s
0000000000000000000000000000000000000000;;			if destsiz < 0 {
0000000000000000000000000000000000000000;;				destsiz = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d = initxattrdest(dest, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Flistxattr(fd int, dest []byte) (sz int, err error) {
0000000000000000000000000000000000000000;;		d := initxattrdest(dest, 0)
0000000000000000000000000000000000000000;;		destsiz := len(dest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := 0
0000000000000000000000000000000000000000;;		var e error
0000000000000000000000000000000000000000;;		for _, nsid := range [...]int{EXTATTR_NAMESPACE_USER, EXTATTR_NAMESPACE_SYSTEM} {
0000000000000000000000000000000000000000;;			stmp, e := ExtattrListFd(fd, nsid, uintptr(d), destsiz)
0000000000000000000000000000000000000000;;			if e != nil && e == EPERM && nsid != EXTATTR_NAMESPACE_USER {
0000000000000000000000000000000000000000;;				e = nil
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if e != nil {
0000000000000000000000000000000000000000;;				return s, e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s += stmp
0000000000000000000000000000000000000000;;			destsiz -= s
0000000000000000000000000000000000000000;;			if destsiz < 0 {
0000000000000000000000000000000000000000;;				destsiz = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d = initxattrdest(dest, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Llistxattr(link string, dest []byte) (sz int, err error) {
0000000000000000000000000000000000000000;;		d := initxattrdest(dest, 0)
0000000000000000000000000000000000000000;;		destsiz := len(dest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := 0
0000000000000000000000000000000000000000;;		var e error
0000000000000000000000000000000000000000;;		for _, nsid := range [...]int{EXTATTR_NAMESPACE_USER, EXTATTR_NAMESPACE_SYSTEM} {
0000000000000000000000000000000000000000;;			stmp, e := ExtattrListLink(link, nsid, uintptr(d), destsiz)
0000000000000000000000000000000000000000;;			if e != nil && e == EPERM && nsid != EXTATTR_NAMESPACE_USER {
0000000000000000000000000000000000000000;;				e = nil
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if e != nil {
0000000000000000000000000000000000000000;;				return s, e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s += stmp
0000000000000000000000000000000000000000;;			destsiz -= s
0000000000000000000000000000000000000000;;			if destsiz < 0 {
0000000000000000000000000000000000000000;;				destsiz = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d = initxattrdest(dest, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Exposed directly
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	//sys	Access(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sys	Chdir(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Chflags(path string, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Chmod(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Chown(path string, uid int, gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Chroot(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Close(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Dup(fd int) (nfd int, err error)
0000000000000000000000000000000000000000;;	//sys	Dup2(from int, to int) (err error)
0000000000000000000000000000000000000000;;	//sys	Exit(code int)
0000000000000000000000000000000000000000;;	//sys	ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error)
0000000000000000000000000000000000000000;;	//sys	ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error)
0000000000000000000000000000000000000000;;	//sys	Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_POSIX_FADVISE
0000000000000000000000000000000000000000;;	//sys	Fchdir(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchflags(fd int, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchmod(fd int, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchown(fd int, uid int, gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Flock(fd int, how int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fpathconf(fd int, name int) (val int, err error)
0000000000000000000000000000000000000000;;	//sys	Fstat(fd int, stat *Stat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Fstatfs(fd int, stat *Statfs_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Fsync(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Ftruncate(fd int, length int64) (err error)
0000000000000000000000000000000000000000;;	//sys	Getdirentries(fd int, buf []byte, basep *uintptr) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Getdtablesize() (size int)
0000000000000000000000000000000000000000;;	//sysnb	Getegid() (egid int)
0000000000000000000000000000000000000000;;	//sysnb	Geteuid() (uid int)
0000000000000000000000000000000000000000;;	//sysnb	Getgid() (gid int)
0000000000000000000000000000000000000000;;	//sysnb	Getpgid(pid int) (pgid int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Getpgrp() (pgrp int)
0000000000000000000000000000000000000000;;	//sysnb	Getpid() (pid int)
0000000000000000000000000000000000000000;;	//sysnb	Getppid() (ppid int)
0000000000000000000000000000000000000000;;	//sys	Getpriority(which int, who int) (prio int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Getrusage(who int, rusage *Rusage) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Getsid(pid int) (sid int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Gettimeofday(tv *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Getuid() (uid int)
0000000000000000000000000000000000000000;;	//sys	Issetugid() (tainted bool)
0000000000000000000000000000000000000000;;	//sys	Kill(pid int, signum syscall.Signal) (err error)
0000000000000000000000000000000000000000;;	//sys	Kqueue() (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	Lchown(path string, uid int, gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Link(path string, link string) (err error)
0000000000000000000000000000000000000000;;	//sys	Listen(s int, backlog int) (err error)
0000000000000000000000000000000000000000;;	//sys	Lstat(path string, stat *Stat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Mkdir(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Mkfifo(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Mknod(path string, mode uint32, dev int) (err error)
0000000000000000000000000000000000000000;;	//sys	Mlock(b []byte) (err error)
0000000000000000000000000000000000000000;;	//sys	Mlockall(flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Mprotect(b []byte, prot int) (err error)
0000000000000000000000000000000000000000;;	//sys	Munlock(b []byte) (err error)
0000000000000000000000000000000000000000;;	//sys	Munlockall() (err error)
0000000000000000000000000000000000000000;;	//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
0000000000000000000000000000000000000000;;	//sys	Open(path string, mode int, perm uint32) (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	Pathconf(path string, name int) (val int, err error)
0000000000000000000000000000000000000000;;	//sys	Pread(fd int, p []byte, offset int64) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Pwrite(fd int, p []byte, offset int64) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	read(fd int, p []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Readlink(path string, buf []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Rename(from string, to string) (err error)
0000000000000000000000000000000000000000;;	//sys	Revoke(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Rmdir(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK
0000000000000000000000000000000000000000;;	//sys	Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setegid(egid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Seteuid(euid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setgid(gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Setlogin(name string) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setpgid(pid int, pgid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Setpriority(which int, who int, prio int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setregid(rgid int, egid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setreuid(ruid int, euid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setresgid(rgid int, egid int, sgid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setresuid(ruid int, euid int, suid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setrlimit(which int, lim *Rlimit) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setsid() (pid int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Settimeofday(tp *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setuid(uid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Stat(path string, stat *Stat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Statfs(path string, stat *Statfs_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Symlink(path string, link string) (err error)
0000000000000000000000000000000000000000;;	//sys	Sync() (err error)
0000000000000000000000000000000000000000;;	//sys	Truncate(path string, length int64) (err error)
0000000000000000000000000000000000000000;;	//sys	Umask(newmask int) (oldmask int)
0000000000000000000000000000000000000000;;	//sys	Undelete(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Unlink(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Unmount(path string, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	write(fd int, p []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys   mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
0000000000000000000000000000000000000000;;	//sys   munmap(addr uintptr, length uintptr) (err error)
0000000000000000000000000000000000000000;;	//sys	readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ
0000000000000000000000000000000000000000;;	//sys	writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE
0000000000000000000000000000000000000000;;	//sys	accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Unimplemented
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	// Profil
0000000000000000000000000000000000000000;;	// Sigaction
0000000000000000000000000000000000000000;;	// Sigprocmask
0000000000000000000000000000000000000000;;	// Getlogin
0000000000000000000000000000000000000000;;	// Sigpending
0000000000000000000000000000000000000000;;	// Sigaltstack
0000000000000000000000000000000000000000;;	// Ioctl
0000000000000000000000000000000000000000;;	// Reboot
0000000000000000000000000000000000000000;;	// Execve
0000000000000000000000000000000000000000;;	// Vfork
0000000000000000000000000000000000000000;;	// Sbrk
0000000000000000000000000000000000000000;;	// Sstk
0000000000000000000000000000000000000000;;	// Ovadvise
0000000000000000000000000000000000000000;;	// Mincore
0000000000000000000000000000000000000000;;	// Setitimer
0000000000000000000000000000000000000000;;	// Swapon
0000000000000000000000000000000000000000;;	// Select
0000000000000000000000000000000000000000;;	// Sigsuspend
0000000000000000000000000000000000000000;;	// Readv
0000000000000000000000000000000000000000;;	// Writev
0000000000000000000000000000000000000000;;	// Nfssvc
0000000000000000000000000000000000000000;;	// Getfh
0000000000000000000000000000000000000000;;	// Quotactl
0000000000000000000000000000000000000000;;	// Mount
0000000000000000000000000000000000000000;;	// Csops
0000000000000000000000000000000000000000;;	// Waitid
0000000000000000000000000000000000000000;;	// Add_profil
0000000000000000000000000000000000000000;;	// Kdebug_trace
0000000000000000000000000000000000000000;;	// Sigreturn
0000000000000000000000000000000000000000;;	// Mmap
0000000000000000000000000000000000000000;;	// Mlock
0000000000000000000000000000000000000000;;	// Munlock
0000000000000000000000000000000000000000;;	// Atsocket
0000000000000000000000000000000000000000;;	// Kqueue_from_portset_np
0000000000000000000000000000000000000000;;	// Kqueue_portset
0000000000000000000000000000000000000000;;	// Getattrlist
0000000000000000000000000000000000000000;;	// Setattrlist
0000000000000000000000000000000000000000;;	// Getdirentriesattr
0000000000000000000000000000000000000000;;	// Searchfs
0000000000000000000000000000000000000000;;	// Delete
0000000000000000000000000000000000000000;;	// Copyfile
0000000000000000000000000000000000000000;;	// Poll
0000000000000000000000000000000000000000;;	// Watchevent
0000000000000000000000000000000000000000;;	// Waitevent
0000000000000000000000000000000000000000;;	// Modwatch
0000000000000000000000000000000000000000;;	// Getxattr
0000000000000000000000000000000000000000;;	// Fgetxattr
0000000000000000000000000000000000000000;;	// Setxattr
0000000000000000000000000000000000000000;;	// Fsetxattr
0000000000000000000000000000000000000000;;	// Removexattr
0000000000000000000000000000000000000000;;	// Fremovexattr
0000000000000000000000000000000000000000;;	// Listxattr
0000000000000000000000000000000000000000;;	// Flistxattr
0000000000000000000000000000000000000000;;	// Fsctl
0000000000000000000000000000000000000000;;	// Initgroups
0000000000000000000000000000000000000000;;	// Posix_spawn
0000000000000000000000000000000000000000;;	// Nfsclnt
0000000000000000000000000000000000000000;;	// Fhopen
0000000000000000000000000000000000000000;;	// Minherit
0000000000000000000000000000000000000000;;	// Semsys
0000000000000000000000000000000000000000;;	// Msgsys
0000000000000000000000000000000000000000;;	// Shmsys
0000000000000000000000000000000000000000;;	// Semctl
0000000000000000000000000000000000000000;;	// Semget
0000000000000000000000000000000000000000;;	// Semop
0000000000000000000000000000000000000000;;	// Msgctl
0000000000000000000000000000000000000000;;	// Msgget
0000000000000000000000000000000000000000;;	// Msgsnd
0000000000000000000000000000000000000000;;	// Msgrcv
0000000000000000000000000000000000000000;;	// Shmat
0000000000000000000000000000000000000000;;	// Shmctl
0000000000000000000000000000000000000000;;	// Shmdt
0000000000000000000000000000000000000000;;	// Shmget
0000000000000000000000000000000000000000;;	// Shm_open
0000000000000000000000000000000000000000;;	// Shm_unlink
0000000000000000000000000000000000000000;;	// Sem_open
0000000000000000000000000000000000000000;;	// Sem_close
0000000000000000000000000000000000000000;;	// Sem_unlink
0000000000000000000000000000000000000000;;	// Sem_wait
0000000000000000000000000000000000000000;;	// Sem_trywait
0000000000000000000000000000000000000000;;	// Sem_post
0000000000000000000000000000000000000000;;	// Sem_getvalue
0000000000000000000000000000000000000000;;	// Sem_init
0000000000000000000000000000000000000000;;	// Sem_destroy
0000000000000000000000000000000000000000;;	// Open_extended
0000000000000000000000000000000000000000;;	// Umask_extended
0000000000000000000000000000000000000000;;	// Stat_extended
0000000000000000000000000000000000000000;;	// Lstat_extended
0000000000000000000000000000000000000000;;	// Fstat_extended
0000000000000000000000000000000000000000;;	// Chmod_extended
0000000000000000000000000000000000000000;;	// Fchmod_extended
0000000000000000000000000000000000000000;;	// Access_extended
0000000000000000000000000000000000000000;;	// Settid
0000000000000000000000000000000000000000;;	// Gettid
0000000000000000000000000000000000000000;;	// Setsgroups
0000000000000000000000000000000000000000;;	// Getsgroups
0000000000000000000000000000000000000000;;	// Setwgroups
0000000000000000000000000000000000000000;;	// Getwgroups
0000000000000000000000000000000000000000;;	// Mkfifo_extended
0000000000000000000000000000000000000000;;	// Mkdir_extended
0000000000000000000000000000000000000000;;	// Identitysvc
0000000000000000000000000000000000000000;;	// Shared_region_check_np
0000000000000000000000000000000000000000;;	// Shared_region_map_np
0000000000000000000000000000000000000000;;	// __pthread_mutex_destroy
0000000000000000000000000000000000000000;;	// __pthread_mutex_init
0000000000000000000000000000000000000000;;	// __pthread_mutex_lock
0000000000000000000000000000000000000000;;	// __pthread_mutex_trylock
0000000000000000000000000000000000000000;;	// __pthread_mutex_unlock
0000000000000000000000000000000000000000;;	// __pthread_cond_init
0000000000000000000000000000000000000000;;	// __pthread_cond_destroy
0000000000000000000000000000000000000000;;	// __pthread_cond_broadcast
0000000000000000000000000000000000000000;;	// __pthread_cond_signal
0000000000000000000000000000000000000000;;	// Setsid_with_pid
0000000000000000000000000000000000000000;;	// __pthread_cond_timedwait
0000000000000000000000000000000000000000;;	// Aio_fsync
0000000000000000000000000000000000000000;;	// Aio_return
0000000000000000000000000000000000000000;;	// Aio_suspend
0000000000000000000000000000000000000000;;	// Aio_cancel
0000000000000000000000000000000000000000;;	// Aio_error
0000000000000000000000000000000000000000;;	// Aio_read
0000000000000000000000000000000000000000;;	// Aio_write
0000000000000000000000000000000000000000;;	// Lio_listio
0000000000000000000000000000000000000000;;	// __pthread_cond_wait
0000000000000000000000000000000000000000;;	// Iopolicysys
0000000000000000000000000000000000000000;;	// Mlockall
0000000000000000000000000000000000000000;;	// Munlockall
0000000000000000000000000000000000000000;;	// __pthread_kill
0000000000000000000000000000000000000000;;	// __pthread_sigmask
0000000000000000000000000000000000000000;;	// __sigwait
0000000000000000000000000000000000000000;;	// __disable_threadsignal
0000000000000000000000000000000000000000;;	// __pthread_markcancel
0000000000000000000000000000000000000000;;	// __pthread_canceled
0000000000000000000000000000000000000000;;	// __semwait_signal
0000000000000000000000000000000000000000;;	// Proc_info
0000000000000000000000000000000000000000;;	// Stat64_extended
0000000000000000000000000000000000000000;;	// Lstat64_extended
0000000000000000000000000000000000000000;;	// Fstat64_extended
0000000000000000000000000000000000000000;;	// __pthread_chdir
0000000000000000000000000000000000000000;;	// __pthread_fchdir
0000000000000000000000000000000000000000;;	// Audit
0000000000000000000000000000000000000000;;	// Auditon
0000000000000000000000000000000000000000;;	// Getauid
0000000000000000000000000000000000000000;;	// Setauid
0000000000000000000000000000000000000000;;	// Getaudit
0000000000000000000000000000000000000000;;	// Setaudit
0000000000000000000000000000000000000000;;	// Getaudit_addr
0000000000000000000000000000000000000000;;	// Setaudit_addr
0000000000000000000000000000000000000000;;	// Auditctl
0000000000000000000000000000000000000000;;	// Bsdthread_create
0000000000000000000000000000000000000000;;	// Bsdthread_terminate
0000000000000000000000000000000000000000;;	// Stack_snapshot
0000000000000000000000000000000000000000;;	// Bsdthread_register
0000000000000000000000000000000000000000;;	// Workq_open
0000000000000000000000000000000000000000;;	// Workq_ops
0000000000000000000000000000000000000000;;	// __mac_execve
0000000000000000000000000000000000000000;;	// __mac_syscall
0000000000000000000000000000000000000000;;	// __mac_get_file
0000000000000000000000000000000000000000;;	// __mac_set_file
0000000000000000000000000000000000000000;;	// __mac_get_link
0000000000000000000000000000000000000000;;	// __mac_set_link
0000000000000000000000000000000000000000;;	// __mac_get_proc
0000000000000000000000000000000000000000;;	// __mac_set_proc
0000000000000000000000000000000000000000;;	// __mac_get_fd
0000000000000000000000000000000000000000;;	// __mac_set_fd
0000000000000000000000000000000000000000;;	// __mac_get_pid
0000000000000000000000000000000000000000;;	// __mac_get_lcid
0000000000000000000000000000000000000000;;	// __mac_get_lctx
0000000000000000000000000000000000000000;;	// __mac_set_lctx
0000000000000000000000000000000000000000;;	// Setlcid
0000000000000000000000000000000000000000;;	// Read_nocancel
0000000000000000000000000000000000000000;;	// Write_nocancel
0000000000000000000000000000000000000000;;	// Open_nocancel
0000000000000000000000000000000000000000;;	// Close_nocancel
0000000000000000000000000000000000000000;;	// Wait4_nocancel
0000000000000000000000000000000000000000;;	// Recvmsg_nocancel
0000000000000000000000000000000000000000;;	// Sendmsg_nocancel
0000000000000000000000000000000000000000;;	// Recvfrom_nocancel
0000000000000000000000000000000000000000;;	// Accept_nocancel
0000000000000000000000000000000000000000;;	// Msync_nocancel
0000000000000000000000000000000000000000;;	// Fcntl_nocancel
0000000000000000000000000000000000000000;;	// Select_nocancel
0000000000000000000000000000000000000000;;	// Fsync_nocancel
0000000000000000000000000000000000000000;;	// Connect_nocancel
0000000000000000000000000000000000000000;;	// Sigsuspend_nocancel
0000000000000000000000000000000000000000;;	// Readv_nocancel
0000000000000000000000000000000000000000;;	// Writev_nocancel
0000000000000000000000000000000000000000;;	// Sendto_nocancel
0000000000000000000000000000000000000000;;	// Pread_nocancel
0000000000000000000000000000000000000000;;	// Pwrite_nocancel
0000000000000000000000000000000000000000;;	// Waitid_nocancel
0000000000000000000000000000000000000000;;	// Poll_nocancel
0000000000000000000000000000000000000000;;	// Msgsnd_nocancel
0000000000000000000000000000000000000000;;	// Msgrcv_nocancel
0000000000000000000000000000000000000000;;	// Sem_wait_nocancel
0000000000000000000000000000000000000000;;	// Aio_suspend_nocancel
0000000000000000000000000000000000000000;;	// __sigwait_nocancel
0000000000000000000000000000000000000000;;	// __semwait_signal_nocancel
0000000000000000000000000000000000000000;;	// __mac_mount
0000000000000000000000000000000000000000;;	// __mac_get_mount
0000000000000000000000000000000000000000;;	// __mac_getfsstat
