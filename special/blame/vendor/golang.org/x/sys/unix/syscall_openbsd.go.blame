0000000000000000000000000000000000000000;;	// Copyright 2009,2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
12a86164cdbf8548dc1c57ea2633daf61c4daab0;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_openbsd.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_openbsd.go][vendor/golang.org/x/sys/unix/syscall_openbsd.go];	
0000000000000000000000000000000000000000;;	// OpenBSD system calls.
0000000000000000000000000000000000000000;;	// This file is compiled as ordinary Go code,
0000000000000000000000000000000000000000;;	// but it is also input to mksyscall,
0000000000000000000000000000000000000000;;	// which parses the //sys lines and generates system call stubs.
0000000000000000000000000000000000000000;;	// Note that sometimes we use a lowercase //sys name and wrap
0000000000000000000000000000000000000000;;	// it in our own nicer implementation, either here or in
0000000000000000000000000000000000000000;;	// syscall_bsd.go or syscall_unix.go.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unix
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrDatalink struct {
0000000000000000000000000000000000000000;;		Len    uint8
0000000000000000000000000000000000000000;;		Family uint8
0000000000000000000000000000000000000000;;		Index  uint16
0000000000000000000000000000000000000000;;		Type   uint8
0000000000000000000000000000000000000000;;		Nlen   uint8
0000000000000000000000000000000000000000;;		Alen   uint8
0000000000000000000000000000000000000000;;		Slen   uint8
0000000000000000000000000000000000000000;;		Data   [24]int8
0000000000000000000000000000000000000000;;		raw    RawSockaddrDatalink
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nametomib(name string) (mib []_C_int, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform lookup via a binary search
0000000000000000000000000000000000000000;;		left := 0
0000000000000000000000000000000000000000;;		right := len(sysctlMib) - 1
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			idx := left + (right-left)/2
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case name == sysctlMib[idx].ctlname:
0000000000000000000000000000000000000000;;				return sysctlMib[idx].ctloid, nil
0000000000000000000000000000000000000000;;			case name > sysctlMib[idx].ctlname:
0000000000000000000000000000000000000000;;				left = idx + 1
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				right = idx - 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if left > right {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, EINVAL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseDirent parses up to max directory entries in buf,
0000000000000000000000000000000000000000;;	// appending the names to names. It returns the number
0000000000000000000000000000000000000000;;	// bytes consumed from buf, the number of entries added
0000000000000000000000000000000000000000;;	// to names, and the new names slice.
0000000000000000000000000000000000000000;;	func ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string) {
0000000000000000000000000000000000000000;;		origlen := len(buf)
0000000000000000000000000000000000000000;;		for max != 0 && len(buf) > 0 {
0000000000000000000000000000000000000000;;			dirent := (*Dirent)(unsafe.Pointer(&buf[0]))
0000000000000000000000000000000000000000;;			if dirent.Reclen == 0 {
0000000000000000000000000000000000000000;;				buf = nil
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf = buf[dirent.Reclen:]
0000000000000000000000000000000000000000;;			if dirent.Fileno == 0 { // File absent in directory.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bytes := (*[10000]byte)(unsafe.Pointer(&dirent.Name[0]))
0000000000000000000000000000000000000000;;			var name = string(bytes[0:dirent.Namlen])
0000000000000000000000000000000000000000;;			if name == "." || name == ".." { // Useless names
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			max--
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			names = append(names, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return origlen - len(buf), count, names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb pipe(p *[2]_C_int) (err error)
0000000000000000000000000000000000000000;;	func Pipe(p []int) (err error) {
0000000000000000000000000000000000000000;;		if len(p) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var pp [2]_C_int
0000000000000000000000000000000000000000;;		err = pipe(&pp)
0000000000000000000000000000000000000000;;		p[0] = int(pp[0])
0000000000000000000000000000000000000000;;		p[1] = int(pp[1])
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys getdents(fd int, buf []byte) (n int, err error)
0000000000000000000000000000000000000000;;	func Getdirentries(fd int, buf []byte, basep *uintptr) (n int, err error) {
0000000000000000000000000000000000000000;;		return getdents(fd, buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO
0000000000000000000000000000000000000000;;	func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
0000000000000000000000000000000000000000;;		return -1, ENOSYS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getfsstat(buf []Statfs_t, flags int) (n int, err error) {
0000000000000000000000000000000000000000;;		var _p0 unsafe.Pointer
0000000000000000000000000000000000000000;;		var bufsize uintptr
0000000000000000000000000000000000000000;;		if len(buf) > 0 {
0000000000000000000000000000000000000000;;			_p0 = unsafe.Pointer(&buf[0])
0000000000000000000000000000000000000000;;			bufsize = unsafe.Sizeof(Statfs_t{}) * uintptr(len(buf))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(_p0), bufsize, uintptr(flags))
0000000000000000000000000000000000000000;;		use(unsafe.Pointer(_p0))
0000000000000000000000000000000000000000;;		n = int(r0)
0000000000000000000000000000000000000000;;		if e1 != 0 {
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Exposed directly
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	//sys	Access(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sys	Chdir(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Chflags(path string, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Chmod(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Chown(path string, uid int, gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Chroot(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Close(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Dup(fd int) (nfd int, err error)
0000000000000000000000000000000000000000;;	//sys	Dup2(from int, to int) (err error)
0000000000000000000000000000000000000000;;	//sys	Exit(code int)
0000000000000000000000000000000000000000;;	//sys	Fchdir(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchflags(fd int, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchmod(fd int, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchown(fd int, uid int, gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Flock(fd int, how int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fpathconf(fd int, name int) (val int, err error)
0000000000000000000000000000000000000000;;	//sys	Fstat(fd int, stat *Stat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Fstatfs(fd int, stat *Statfs_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Fsync(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Ftruncate(fd int, length int64) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Getegid() (egid int)
0000000000000000000000000000000000000000;;	//sysnb	Geteuid() (uid int)
0000000000000000000000000000000000000000;;	//sysnb	Getgid() (gid int)
0000000000000000000000000000000000000000;;	//sysnb	Getpgid(pid int) (pgid int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Getpgrp() (pgrp int)
0000000000000000000000000000000000000000;;	//sysnb	Getpid() (pid int)
0000000000000000000000000000000000000000;;	//sysnb	Getppid() (ppid int)
0000000000000000000000000000000000000000;;	//sys	Getpriority(which int, who int) (prio int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Getrusage(who int, rusage *Rusage) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Getsid(pid int) (sid int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Gettimeofday(tv *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Getuid() (uid int)
0000000000000000000000000000000000000000;;	//sys	Issetugid() (tainted bool)
0000000000000000000000000000000000000000;;	//sys	Kill(pid int, signum syscall.Signal) (err error)
0000000000000000000000000000000000000000;;	//sys	Kqueue() (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	Lchown(path string, uid int, gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Link(path string, link string) (err error)
0000000000000000000000000000000000000000;;	//sys	Listen(s int, backlog int) (err error)
0000000000000000000000000000000000000000;;	//sys	Lstat(path string, stat *Stat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Mkdir(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Mkfifo(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Mknod(path string, mode uint32, dev int) (err error)
0000000000000000000000000000000000000000;;	//sys	Mlock(b []byte) (err error)
0000000000000000000000000000000000000000;;	//sys	Mlockall(flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Mprotect(b []byte, prot int) (err error)
0000000000000000000000000000000000000000;;	//sys	Munlock(b []byte) (err error)
0000000000000000000000000000000000000000;;	//sys	Munlockall() (err error)
0000000000000000000000000000000000000000;;	//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
0000000000000000000000000000000000000000;;	//sys	Open(path string, mode int, perm uint32) (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	Pathconf(path string, name int) (val int, err error)
0000000000000000000000000000000000000000;;	//sys	Pread(fd int, p []byte, offset int64) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Pwrite(fd int, p []byte, offset int64) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	read(fd int, p []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Readlink(path string, buf []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Rename(from string, to string) (err error)
0000000000000000000000000000000000000000;;	//sys	Revoke(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Rmdir(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK
0000000000000000000000000000000000000000;;	//sys	Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setegid(egid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Seteuid(euid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setgid(gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Setlogin(name string) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setpgid(pid int, pgid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Setpriority(which int, who int, prio int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setregid(rgid int, egid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setreuid(ruid int, euid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setresgid(rgid int, egid int, sgid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setresuid(ruid int, euid int, suid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setrlimit(which int, lim *Rlimit) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setsid() (pid int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Settimeofday(tp *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setuid(uid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Stat(path string, stat *Stat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Statfs(path string, stat *Statfs_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Symlink(path string, link string) (err error)
0000000000000000000000000000000000000000;;	//sys	Sync() (err error)
0000000000000000000000000000000000000000;;	//sys	Truncate(path string, length int64) (err error)
0000000000000000000000000000000000000000;;	//sys	Umask(newmask int) (oldmask int)
0000000000000000000000000000000000000000;;	//sys	Unlink(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Unmount(path string, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	write(fd int, p []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
0000000000000000000000000000000000000000;;	//sys	munmap(addr uintptr, length uintptr) (err error)
0000000000000000000000000000000000000000;;	//sys	readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ
0000000000000000000000000000000000000000;;	//sys	writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Unimplemented
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	// __getcwd
0000000000000000000000000000000000000000;;	// __semctl
0000000000000000000000000000000000000000;;	// __syscall
0000000000000000000000000000000000000000;;	// __sysctl
0000000000000000000000000000000000000000;;	// adjfreq
0000000000000000000000000000000000000000;;	// break
0000000000000000000000000000000000000000;;	// clock_getres
0000000000000000000000000000000000000000;;	// clock_gettime
0000000000000000000000000000000000000000;;	// clock_settime
0000000000000000000000000000000000000000;;	// closefrom
0000000000000000000000000000000000000000;;	// execve
0000000000000000000000000000000000000000;;	// faccessat
0000000000000000000000000000000000000000;;	// fchmodat
0000000000000000000000000000000000000000;;	// fchownat
0000000000000000000000000000000000000000;;	// fcntl
0000000000000000000000000000000000000000;;	// fhopen
0000000000000000000000000000000000000000;;	// fhstat
0000000000000000000000000000000000000000;;	// fhstatfs
0000000000000000000000000000000000000000;;	// fork
0000000000000000000000000000000000000000;;	// fstatat
0000000000000000000000000000000000000000;;	// futimens
0000000000000000000000000000000000000000;;	// getfh
0000000000000000000000000000000000000000;;	// getgid
0000000000000000000000000000000000000000;;	// getitimer
0000000000000000000000000000000000000000;;	// getlogin
0000000000000000000000000000000000000000;;	// getresgid
0000000000000000000000000000000000000000;;	// getresuid
0000000000000000000000000000000000000000;;	// getrtable
0000000000000000000000000000000000000000;;	// getthrid
0000000000000000000000000000000000000000;;	// ioctl
0000000000000000000000000000000000000000;;	// ktrace
0000000000000000000000000000000000000000;;	// lfs_bmapv
0000000000000000000000000000000000000000;;	// lfs_markv
0000000000000000000000000000000000000000;;	// lfs_segclean
0000000000000000000000000000000000000000;;	// lfs_segwait
0000000000000000000000000000000000000000;;	// linkat
0000000000000000000000000000000000000000;;	// mincore
0000000000000000000000000000000000000000;;	// minherit
0000000000000000000000000000000000000000;;	// mkdirat
0000000000000000000000000000000000000000;;	// mkfifoat
0000000000000000000000000000000000000000;;	// mknodat
0000000000000000000000000000000000000000;;	// mount
0000000000000000000000000000000000000000;;	// mquery
0000000000000000000000000000000000000000;;	// msgctl
0000000000000000000000000000000000000000;;	// msgget
0000000000000000000000000000000000000000;;	// msgrcv
0000000000000000000000000000000000000000;;	// msgsnd
0000000000000000000000000000000000000000;;	// nfssvc
0000000000000000000000000000000000000000;;	// nnpfspioctl
0000000000000000000000000000000000000000;;	// openat
0000000000000000000000000000000000000000;;	// poll
0000000000000000000000000000000000000000;;	// preadv
0000000000000000000000000000000000000000;;	// profil
0000000000000000000000000000000000000000;;	// pwritev
0000000000000000000000000000000000000000;;	// quotactl
0000000000000000000000000000000000000000;;	// readlinkat
0000000000000000000000000000000000000000;;	// readv
0000000000000000000000000000000000000000;;	// reboot
0000000000000000000000000000000000000000;;	// renameat
0000000000000000000000000000000000000000;;	// rfork
0000000000000000000000000000000000000000;;	// sched_yield
0000000000000000000000000000000000000000;;	// semget
0000000000000000000000000000000000000000;;	// semop
0000000000000000000000000000000000000000;;	// setgroups
0000000000000000000000000000000000000000;;	// setitimer
0000000000000000000000000000000000000000;;	// setrtable
0000000000000000000000000000000000000000;;	// setsockopt
0000000000000000000000000000000000000000;;	// shmat
0000000000000000000000000000000000000000;;	// shmctl
0000000000000000000000000000000000000000;;	// shmdt
0000000000000000000000000000000000000000;;	// shmget
0000000000000000000000000000000000000000;;	// sigaction
0000000000000000000000000000000000000000;;	// sigaltstack
0000000000000000000000000000000000000000;;	// sigpending
0000000000000000000000000000000000000000;;	// sigprocmask
0000000000000000000000000000000000000000;;	// sigreturn
0000000000000000000000000000000000000000;;	// sigsuspend
0000000000000000000000000000000000000000;;	// symlinkat
0000000000000000000000000000000000000000;;	// sysarch
0000000000000000000000000000000000000000;;	// syscall
0000000000000000000000000000000000000000;;	// threxit
0000000000000000000000000000000000000000;;	// thrsigdivert
0000000000000000000000000000000000000000;;	// thrsleep
0000000000000000000000000000000000000000;;	// thrwakeup
0000000000000000000000000000000000000000;;	// unlinkat
0000000000000000000000000000000000000000;;	// utimensat
0000000000000000000000000000000000000000;;	// vfork
0000000000000000000000000000000000000000;;	// writev
