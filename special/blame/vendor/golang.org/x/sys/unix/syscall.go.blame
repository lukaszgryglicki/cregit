0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
12a86164cdbf8548dc1c57ea2633daf61c4daab0;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall.go][vendor/golang.org/x/sys/unix/syscall.go];	
0000000000000000000000000000000000000000;;	// +build darwin dragonfly freebsd linux netbsd openbsd solaris
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package unix contains an interface to the low-level operating system
0000000000000000000000000000000000000000;;	// primitives.  OS details vary depending on the underlying system, and
0000000000000000000000000000000000000000;;	// by default, godoc will display OS-specific documentation for the current
0000000000000000000000000000000000000000;;	// system.  If you want godoc to display OS documentation for another
0000000000000000000000000000000000000000;;	// system, set $GOOS and $GOARCH to the desired system.  For example, if
0000000000000000000000000000000000000000;;	// you want to view documentation for freebsd/arm on linux/amd64, set $GOOS
0000000000000000000000000000000000000000;;	// to freebsd and $GOARCH to arm.
0000000000000000000000000000000000000000;;	// The primary use of this package is inside other packages that provide a more
0000000000000000000000000000000000000000;;	// portable interface to the system, such as "os", "time" and "net".  Use
0000000000000000000000000000000000000000;;	// those packages rather than this one if you can.
0000000000000000000000000000000000000000;;	// For details of the functions and data types in this package consult
0000000000000000000000000000000000000000;;	// the manuals for the appropriate operating system.
0000000000000000000000000000000000000000;;	// These calls return err == nil to indicate success; otherwise
0000000000000000000000000000000000000000;;	// err represents an operating system error describing the failure and
0000000000000000000000000000000000000000;;	// holds a value of type syscall.Errno.
0000000000000000000000000000000000000000;;	package unix
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByteSliceFromString returns a NUL-terminated slice of bytes
0000000000000000000000000000000000000000;;	// containing the text of s. If s contains a NUL byte at any
0000000000000000000000000000000000000000;;	// location, it returns (nil, EINVAL).
0000000000000000000000000000000000000000;;	func ByteSliceFromString(s string) ([]byte, error) {
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			if s[i] == 0 {
0000000000000000000000000000000000000000;;				return nil, EINVAL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a := make([]byte, len(s)+1)
0000000000000000000000000000000000000000;;		copy(a, s)
0000000000000000000000000000000000000000;;		return a, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BytePtrFromString returns a pointer to a NUL-terminated array of
0000000000000000000000000000000000000000;;	// bytes containing the text of s. If s contains a NUL byte at any
0000000000000000000000000000000000000000;;	// location, it returns (nil, EINVAL).
0000000000000000000000000000000000000000;;	func BytePtrFromString(s string) (*byte, error) {
0000000000000000000000000000000000000000;;		a, err := ByteSliceFromString(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &a[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Single-word zero for use when we need a valid pointer to 0 bytes.
0000000000000000000000000000000000000000;;	// See mkunix.pl.
0000000000000000000000000000000000000000;;	var _zero uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *Timespec) Unix() (sec int64, nsec int64) {
0000000000000000000000000000000000000000;;		return int64(ts.Sec), int64(ts.Nsec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tv *Timeval) Unix() (sec int64, nsec int64) {
0000000000000000000000000000000000000000;;		return int64(tv.Sec), int64(tv.Usec) * 1000
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *Timespec) Nano() int64 {
0000000000000000000000000000000000000000;;		return int64(ts.Sec)*1e9 + int64(ts.Nsec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tv *Timeval) Nano() int64 {
0000000000000000000000000000000000000000;;		return int64(tv.Sec)*1e9 + int64(tv.Usec)*1000
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TimevalToNsec(tv Timeval) int64 { return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// use is a no-op, but the compiler cannot see that it is.
0000000000000000000000000000000000000000;;	// Calling use(p) ensures that p is kept live until that point.
0000000000000000000000000000000000000000;;	//go:noescape
0000000000000000000000000000000000000000;;	func use(p unsafe.Pointer)
