0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
12a86164cdbf8548dc1c57ea2633daf61c4daab0;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_linux_386.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_linux_386.go][vendor/golang.org/x/sys/unix/syscall_linux_386.go];	
0000000000000000000000000000000000000000;;	// TODO(rsc): Rewrite all nn(SP) references into name+(nn-8)(FP)
0000000000000000000000000000000000000000;;	// so that go vet can check that they are correct.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +build 386,linux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unix
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getpagesize() int { return 4096 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NsecToTimespec(nsec int64) (ts Timespec) {
0000000000000000000000000000000000000000;;		ts.Sec = int32(nsec / 1e9)
0000000000000000000000000000000000000000;;		ts.Nsec = int32(nsec % 1e9)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NsecToTimeval(nsec int64) (tv Timeval) {
0000000000000000000000000000000000000000;;		nsec += 999 // round up to microsecond
0000000000000000000000000000000000000000;;		tv.Sec = int32(nsec / 1e9)
0000000000000000000000000000000000000000;;		tv.Usec = int32(nsec % 1e9 / 1e3)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb	pipe(p *[2]_C_int) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Pipe(p []int) (err error) {
0000000000000000000000000000000000000000;;		if len(p) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var pp [2]_C_int
0000000000000000000000000000000000000000;;		err = pipe(&pp)
0000000000000000000000000000000000000000;;		p[0] = int(pp[0])
0000000000000000000000000000000000000000;;		p[1] = int(pp[1])
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb pipe2(p *[2]_C_int, flags int) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Pipe2(p []int, flags int) (err error) {
0000000000000000000000000000000000000000;;		if len(p) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var pp [2]_C_int
0000000000000000000000000000000000000000;;		err = pipe2(&pp, flags)
0000000000000000000000000000000000000000;;		p[0] = int(pp[0])
0000000000000000000000000000000000000000;;		p[1] = int(pp[1])
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// 64-bit file system and 32-bit uid calls
0000000000000000000000000000000000000000;;	// (386 default is 32-bit file system and 16-bit uid).
0000000000000000000000000000000000000000;;	//sys	Dup2(oldfd int, newfd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64_64
0000000000000000000000000000000000000000;;	//sys	Fchown(fd int, uid int, gid int) (err error) = SYS_FCHOWN32
0000000000000000000000000000000000000000;;	//sys	Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64
0000000000000000000000000000000000000000;;	//sys	Ftruncate(fd int, length int64) (err error) = SYS_FTRUNCATE64
0000000000000000000000000000000000000000;;	//sysnb	Getegid() (egid int) = SYS_GETEGID32
0000000000000000000000000000000000000000;;	//sysnb	Geteuid() (euid int) = SYS_GETEUID32
0000000000000000000000000000000000000000;;	//sysnb	Getgid() (gid int) = SYS_GETGID32
0000000000000000000000000000000000000000;;	//sysnb	Getuid() (uid int) = SYS_GETUID32
0000000000000000000000000000000000000000;;	//sysnb	InotifyInit() (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	Ioperm(from int, num int, on int) (err error)
0000000000000000000000000000000000000000;;	//sys	Iopl(level int) (err error)
0000000000000000000000000000000000000000;;	//sys	Lchown(path string, uid int, gid int) (err error) = SYS_LCHOWN32
0000000000000000000000000000000000000000;;	//sys	Lstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64
0000000000000000000000000000000000000000;;	//sys	Pread(fd int, p []byte, offset int64) (n int, err error) = SYS_PREAD64
0000000000000000000000000000000000000000;;	//sys	Pwrite(fd int, p []byte, offset int64) (n int, err error) = SYS_PWRITE64
0000000000000000000000000000000000000000;;	//sys	sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = SYS_SENDFILE64
0000000000000000000000000000000000000000;;	//sys	Setfsgid(gid int) (err error) = SYS_SETFSGID32
0000000000000000000000000000000000000000;;	//sys	Setfsuid(uid int) (err error) = SYS_SETFSUID32
0000000000000000000000000000000000000000;;	//sysnb	Setregid(rgid int, egid int) (err error) = SYS_SETREGID32
0000000000000000000000000000000000000000;;	//sysnb	Setresgid(rgid int, egid int, sgid int) (err error) = SYS_SETRESGID32
0000000000000000000000000000000000000000;;	//sysnb	Setresuid(ruid int, euid int, suid int) (err error) = SYS_SETRESUID32
0000000000000000000000000000000000000000;;	//sysnb	Setreuid(ruid int, euid int) (err error) = SYS_SETREUID32
0000000000000000000000000000000000000000;;	//sys	Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Stat(path string, stat *Stat_t) (err error) = SYS_STAT64
0000000000000000000000000000000000000000;;	//sys	SyncFileRange(fd int, off int64, n int64, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Truncate(path string, length int64) (err error) = SYS_TRUNCATE64
0000000000000000000000000000000000000000;;	//sysnb	getgroups(n int, list *_Gid_t) (nn int, err error) = SYS_GETGROUPS32
0000000000000000000000000000000000000000;;	//sysnb	setgroups(n int, list *_Gid_t) (err error) = SYS_SETGROUPS32
0000000000000000000000000000000000000000;;	//sys	Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error)
0000000000000000000000000000000000000000;;	//sys	EpollWait(epfd int, events []EpollEvent, msec int) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Pause() (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) {
0000000000000000000000000000000000000000;;		page := uintptr(offset / 4096)
0000000000000000000000000000000000000000;;		if offset != int64(page)*4096 {
0000000000000000000000000000000000000000;;			return 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mmap2(addr, length, prot, flags, fd, page)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rlimit32 struct {
0000000000000000000000000000000000000000;;		Cur uint32
0000000000000000000000000000000000000000;;		Max uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb getrlimit(resource int, rlim *rlimit32) (err error) = SYS_GETRLIMIT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const rlimInf32 = ^uint32(0)
0000000000000000000000000000000000000000;;	const rlimInf64 = ^uint64(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getrlimit(resource int, rlim *Rlimit) (err error) {
0000000000000000000000000000000000000000;;		err = prlimit(0, resource, nil, rlim)
0000000000000000000000000000000000000000;;		if err != ENOSYS {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rl := rlimit32{}
0000000000000000000000000000000000000000;;		err = getrlimit(resource, &rl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rl.Cur == rlimInf32 {
0000000000000000000000000000000000000000;;			rlim.Cur = rlimInf64
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rlim.Cur = uint64(rl.Cur)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rl.Max == rlimInf32 {
0000000000000000000000000000000000000000;;			rlim.Max = rlimInf64
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rlim.Max = uint64(rl.Max)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb setrlimit(resource int, rlim *rlimit32) (err error) = SYS_SETRLIMIT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Setrlimit(resource int, rlim *Rlimit) (err error) {
0000000000000000000000000000000000000000;;		err = prlimit(0, resource, rlim, nil)
0000000000000000000000000000000000000000;;		if err != ENOSYS {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rl := rlimit32{}
0000000000000000000000000000000000000000;;		if rlim.Cur == rlimInf64 {
0000000000000000000000000000000000000000;;			rl.Cur = rlimInf32
0000000000000000000000000000000000000000;;		} else if rlim.Cur < uint64(rlimInf32) {
0000000000000000000000000000000000000000;;			rl.Cur = uint32(rlim.Cur)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rlim.Max == rlimInf64 {
0000000000000000000000000000000000000000;;			rl.Max = rlimInf32
0000000000000000000000000000000000000000;;		} else if rlim.Max < uint64(rlimInf32) {
0000000000000000000000000000000000000000;;			rl.Max = uint32(rlim.Max)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return setrlimit(resource, &rl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Underlying system call writes to newoffset via pointer.
0000000000000000000000000000000000000000;;	// Implemented in assembly to avoid allocation.
0000000000000000000000000000000000000000;;	func seek(fd int, offset int64, whence int) (newoffset int64, err syscall.Errno)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Seek(fd int, offset int64, whence int) (newoffset int64, err error) {
0000000000000000000000000000000000000000;;		newoffset, errno := seek(fd, offset, whence)
0000000000000000000000000000000000000000;;		if errno != 0 {
0000000000000000000000000000000000000000;;			return 0, errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newoffset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Vsyscalls on amd64.
0000000000000000000000000000000000000000;;	//sysnb	Gettimeofday(tv *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Time(t *Time_t) (tt Time_t, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	Utime(path string, buf *Utimbuf) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// On x86 Linux, all the socket calls go through an extra indirection,
0000000000000000000000000000000000000000;;	// I think because the 5-register system call interface can't handle
0000000000000000000000000000000000000000;;	// the 6-argument calls like sendto and recvfrom.  Instead the
0000000000000000000000000000000000000000;;	// arguments to the underlying system call are the number below
0000000000000000000000000000000000000000;;	// and a pointer to an array of uintptr.  We hide the pointer in the
0000000000000000000000000000000000000000;;	// socketcall assembly to avoid allocation on every system call.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// see linux/net.h
0000000000000000000000000000000000000000;;		_SOCKET      = 1
0000000000000000000000000000000000000000;;		_BIND        = 2
0000000000000000000000000000000000000000;;		_CONNECT     = 3
0000000000000000000000000000000000000000;;		_LISTEN      = 4
0000000000000000000000000000000000000000;;		_ACCEPT      = 5
0000000000000000000000000000000000000000;;		_GETSOCKNAME = 6
0000000000000000000000000000000000000000;;		_GETPEERNAME = 7
0000000000000000000000000000000000000000;;		_SOCKETPAIR  = 8
0000000000000000000000000000000000000000;;		_SEND        = 9
0000000000000000000000000000000000000000;;		_RECV        = 10
0000000000000000000000000000000000000000;;		_SENDTO      = 11
0000000000000000000000000000000000000000;;		_RECVFROM    = 12
0000000000000000000000000000000000000000;;		_SHUTDOWN    = 13
0000000000000000000000000000000000000000;;		_SETSOCKOPT  = 14
0000000000000000000000000000000000000000;;		_GETSOCKOPT  = 15
0000000000000000000000000000000000000000;;		_SENDMSG     = 16
0000000000000000000000000000000000000000;;		_RECVMSG     = 17
0000000000000000000000000000000000000000;;		_ACCEPT4     = 18
0000000000000000000000000000000000000000;;		_RECVMMSG    = 19
0000000000000000000000000000000000000000;;		_SENDMMSG    = 20
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func socketcall(call int, a0, a1, a2, a3, a4, a5 uintptr) (n int, err syscall.Errno)
0000000000000000000000000000000000000000;;	func rawsocketcall(call int, a0, a1, a2, a3, a4, a5 uintptr) (n int, err syscall.Errno)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) {
0000000000000000000000000000000000000000;;		fd, e := socketcall(_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
0000000000000000000000000000000000000000;;		fd, e := socketcall(_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getsockname(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
0000000000000000000000000000000000000000;;		_, e := rawsocketcall(_GETSOCKNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getpeername(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
0000000000000000000000000000000000000000;;		_, e := rawsocketcall(_GETPEERNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func socketpair(domain int, typ int, flags int, fd *[2]int32) (err error) {
0000000000000000000000000000000000000000;;		_, e := rawsocketcall(_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(flags), uintptr(unsafe.Pointer(fd)), 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
0000000000000000000000000000000000000000;;		_, e := socketcall(_BIND, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
0000000000000000000000000000000000000000;;		_, e := socketcall(_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func socket(domain int, typ int, proto int) (fd int, err error) {
0000000000000000000000000000000000000000;;		fd, e := rawsocketcall(_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto), 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
0000000000000000000000000000000000000000;;		_, e := socketcall(_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
0000000000000000000000000000000000000000;;		_, e := socketcall(_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), vallen, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recvfrom(s int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) {
0000000000000000000000000000000000000000;;		var base uintptr
0000000000000000000000000000000000000000;;		if len(p) > 0 {
0000000000000000000000000000000000000000;;			base = uintptr(unsafe.Pointer(&p[0]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, e := socketcall(_RECVFROM, uintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sendto(s int, p []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) {
0000000000000000000000000000000000000000;;		var base uintptr
0000000000000000000000000000000000000000;;		if len(p) > 0 {
0000000000000000000000000000000000000000;;			base = uintptr(unsafe.Pointer(&p[0]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, e := socketcall(_SENDTO, uintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(to), uintptr(addrlen))
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recvmsg(s int, msg *Msghdr, flags int) (n int, err error) {
0000000000000000000000000000000000000000;;		n, e := socketcall(_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags), 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sendmsg(s int, msg *Msghdr, flags int) (n int, err error) {
0000000000000000000000000000000000000000;;		n, e := socketcall(_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags), 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Listen(s int, n int) (err error) {
0000000000000000000000000000000000000000;;		_, e := socketcall(_LISTEN, uintptr(s), uintptr(n), 0, 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Shutdown(s, how int) (err error) {
0000000000000000000000000000000000000000;;		_, e := socketcall(_SHUTDOWN, uintptr(s), uintptr(how), 0, 0, 0, 0)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Fstatfs(fd int, buf *Statfs_t) (err error) {
0000000000000000000000000000000000000000;;		_, _, e := Syscall(SYS_FSTATFS64, uintptr(fd), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Statfs(path string, buf *Statfs_t) (err error) {
0000000000000000000000000000000000000000;;		pathp, err := BytePtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, e := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(pathp)), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PtraceRegs) PC() uint64 { return uint64(uint32(r.Eip)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PtraceRegs) SetPC(pc uint64) { r.Eip = int32(pc) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (iov *Iovec) SetLen(length int) {
0000000000000000000000000000000000000000;;		iov.Len = uint32(length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (msghdr *Msghdr) SetControllen(length int) {
0000000000000000000000000000000000000000;;		msghdr.Controllen = uint32(length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cmsg *Cmsghdr) SetLen(length int) {
0000000000000000000000000000000000000000;;		cmsg.Len = uint32(length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	poll(fds *PollFd, nfds int, timeout int) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Poll(fds []PollFd, timeout int) (n int, err error) {
0000000000000000000000000000000000000000;;		if len(fds) == 0 {
0000000000000000000000000000000000000000;;			return poll(nil, 0, timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return poll(&fds[0], len(fds), timeout)
0000000000000000000000000000000000000000;;	}
