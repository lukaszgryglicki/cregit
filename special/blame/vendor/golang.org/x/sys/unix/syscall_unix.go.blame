0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
12a86164cdbf8548dc1c57ea2633daf61c4daab0;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_unix.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_unix.go][vendor/golang.org/x/sys/unix/syscall_unix.go];	
0000000000000000000000000000000000000000;;	// +build darwin dragonfly freebsd linux netbsd openbsd solaris
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unix
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		Stdin  = 0
0000000000000000000000000000000000000000;;		Stdout = 1
0000000000000000000000000000000000000000;;		Stderr = 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		darwin64Bit    = runtime.GOOS == "darwin" && sizeofPtr == 8
0000000000000000000000000000000000000000;;		dragonfly64Bit = runtime.GOOS == "dragonfly" && sizeofPtr == 8
0000000000000000000000000000000000000000;;		netbsd32Bit    = runtime.GOOS == "netbsd" && sizeofPtr == 4
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do the interface allocations only once for common
0000000000000000000000000000000000000000;;	// Errno values.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errEAGAIN error = syscall.EAGAIN
0000000000000000000000000000000000000000;;		errEINVAL error = syscall.EINVAL
0000000000000000000000000000000000000000;;		errENOENT error = syscall.ENOENT
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errnoErr returns common boxed Errno values, to prevent
0000000000000000000000000000000000000000;;	// allocations at runtime.
0000000000000000000000000000000000000000;;	func errnoErr(e syscall.Errno) error {
0000000000000000000000000000000000000000;;		switch e {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case EAGAIN:
0000000000000000000000000000000000000000;;			return errEAGAIN
0000000000000000000000000000000000000000;;		case EINVAL:
0000000000000000000000000000000000000000;;			return errEINVAL
0000000000000000000000000000000000000000;;		case ENOENT:
0000000000000000000000000000000000000000;;			return errENOENT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)
0000000000000000000000000000000000000000;;	func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)
0000000000000000000000000000000000000000;;	func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)
0000000000000000000000000000000000000000;;	func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mmap manager, for use by operating system-specific implementations.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mmapper struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		active map[*byte][]byte // active mappings; key is last byte in mapping
0000000000000000000000000000000000000000;;		mmap   func(addr, length uintptr, prot, flags, fd int, offset int64) (uintptr, error)
0000000000000000000000000000000000000000;;		munmap func(addr uintptr, length uintptr) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mmapper) Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error) {
0000000000000000000000000000000000000000;;		if length <= 0 {
0000000000000000000000000000000000000000;;			return nil, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map the requested memory.
0000000000000000000000000000000000000000;;		addr, errno := m.mmap(0, uintptr(length), prot, flags, fd, offset)
0000000000000000000000000000000000000000;;		if errno != nil {
0000000000000000000000000000000000000000;;			return nil, errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Slice memory layout
0000000000000000000000000000000000000000;;		var sl = struct {
0000000000000000000000000000000000000000;;			addr uintptr
0000000000000000000000000000000000000000;;			len  int
0000000000000000000000000000000000000000;;			cap  int
0000000000000000000000000000000000000000;;		}{addr, length, length}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use unsafe to turn sl into a []byte.
0000000000000000000000000000000000000000;;		b := *(*[]byte)(unsafe.Pointer(&sl))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register mapping in m and return it.
0000000000000000000000000000000000000000;;		p := &b[cap(b)-1]
0000000000000000000000000000000000000000;;		m.Lock()
0000000000000000000000000000000000000000;;		defer m.Unlock()
0000000000000000000000000000000000000000;;		m.active[p] = b
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *mmapper) Munmap(data []byte) (err error) {
0000000000000000000000000000000000000000;;		if len(data) == 0 || len(data) != cap(data) {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the base of the mapping.
0000000000000000000000000000000000000000;;		p := &data[cap(data)-1]
0000000000000000000000000000000000000000;;		m.Lock()
0000000000000000000000000000000000000000;;		defer m.Unlock()
0000000000000000000000000000000000000000;;		b := m.active[p]
0000000000000000000000000000000000000000;;		if b == nil || &b[0] != &data[0] {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unmap the memory and update m.
0000000000000000000000000000000000000000;;		if errno := m.munmap(uintptr(unsafe.Pointer(&b[0])), uintptr(len(b))); errno != nil {
0000000000000000000000000000000000000000;;			return errno
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(m.active, p)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Read(fd int, p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		n, err = read(fd, p)
0000000000000000000000000000000000000000;;		if raceenabled {
0000000000000000000000000000000000000000;;			if n > 0 {
0000000000000000000000000000000000000000;;				raceWriteRange(unsafe.Pointer(&p[0]), n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				raceAcquire(unsafe.Pointer(&ioSync))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Write(fd int, p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if raceenabled {
0000000000000000000000000000000000000000;;			raceReleaseMerge(unsafe.Pointer(&ioSync))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = write(fd, p)
0000000000000000000000000000000000000000;;		if raceenabled && n > 0 {
0000000000000000000000000000000000000000;;			raceReadRange(unsafe.Pointer(&p[0]), n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For testing: clients can set this flag to force
0000000000000000000000000000000000000000;;	// creation of IPv6 sockets to return EAFNOSUPPORT.
0000000000000000000000000000000000000000;;	var SocketDisableIPv6 bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Sockaddr interface {
0000000000000000000000000000000000000000;;		sockaddr() (ptr unsafe.Pointer, len _Socklen, err error) // lowercase; only we can define Sockaddrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrInet4 struct {
0000000000000000000000000000000000000000;;		Port int
0000000000000000000000000000000000000000;;		Addr [4]byte
0000000000000000000000000000000000000000;;		raw  RawSockaddrInet4
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrInet6 struct {
0000000000000000000000000000000000000000;;		Port   int
0000000000000000000000000000000000000000;;		ZoneId uint32
0000000000000000000000000000000000000000;;		Addr   [16]byte
0000000000000000000000000000000000000000;;		raw    RawSockaddrInet6
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrUnix struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		raw  RawSockaddrUnix
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Bind(fd int, sa Sockaddr) (err error) {
0000000000000000000000000000000000000000;;		ptr, n, err := sa.sockaddr()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bind(fd, ptr, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Connect(fd int, sa Sockaddr) (err error) {
0000000000000000000000000000000000000000;;		ptr, n, err := sa.sockaddr()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return connect(fd, ptr, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getpeername(fd int) (sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		var len _Socklen = SizeofSockaddrAny
0000000000000000000000000000000000000000;;		if err = getpeername(fd, &rsa, &len); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptInt(fd, level, opt int) (value int, err error) {
0000000000000000000000000000000000000000;;		var n int32
0000000000000000000000000000000000000000;;		vallen := _Socklen(4)
0000000000000000000000000000000000000000;;		err = getsockopt(fd, level, opt, unsafe.Pointer(&n), &vallen)
0000000000000000000000000000000000000000;;		return int(n), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		var len _Socklen = SizeofSockaddrAny
0000000000000000000000000000000000000000;;		if n, err = recvfrom(fd, p, flags, &rsa, &len); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rsa.Addr.Family != AF_UNSPEC {
0000000000000000000000000000000000000000;;			from, err = anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Sendto(fd int, p []byte, flags int, to Sockaddr) (err error) {
0000000000000000000000000000000000000000;;		ptr, n, err := to.sockaddr()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sendto(fd, p, flags, ptr, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptByte(fd, level, opt int, value byte) (err error) {
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(&value), 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptInt(fd, level, opt int, value int) (err error) {
0000000000000000000000000000000000000000;;		var n = int32(value)
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(&n), 4)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (err error) {
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(&value[0]), 4)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error) {
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(mreq), SizeofIPMreq)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error) {
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(mreq), SizeofIPv6Mreq)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptICMPv6Filter(fd, level, opt int, filter *ICMPv6Filter) error {
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(filter), SizeofICMPv6Filter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptLinger(fd, level, opt int, l *Linger) (err error) {
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(l), SizeofLinger)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptString(fd, level, opt int, s string) (err error) {
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(&[]byte(s)[0]), uintptr(len(s)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (err error) {
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(tv), unsafe.Sizeof(*tv))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Socket(domain, typ, proto int) (fd int, err error) {
0000000000000000000000000000000000000000;;		if domain == AF_INET6 && SocketDisableIPv6 {
0000000000000000000000000000000000000000;;			return -1, EAFNOSUPPORT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fd, err = socket(domain, typ, proto)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Socketpair(domain, typ, proto int) (fd [2]int, err error) {
0000000000000000000000000000000000000000;;		var fdx [2]int32
0000000000000000000000000000000000000000;;		err = socketpair(domain, typ, proto, &fdx)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			fd[0] = int(fdx[0])
0000000000000000000000000000000000000000;;			fd[1] = int(fdx[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
0000000000000000000000000000000000000000;;		if raceenabled {
0000000000000000000000000000000000000000;;			raceReleaseMerge(unsafe.Pointer(&ioSync))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sendfile(outfd, infd, offset, count)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ioSync int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CloseOnExec(fd int) { fcntl(fd, F_SETFD, FD_CLOEXEC) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetNonblock(fd int, nonblocking bool) (err error) {
0000000000000000000000000000000000000000;;		flag, err := fcntl(fd, F_GETFL, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if nonblocking {
0000000000000000000000000000000000000000;;			flag |= O_NONBLOCK
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			flag &= ^O_NONBLOCK
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = fcntl(fd, F_SETFL, flag)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
