0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
12a86164cdbf8548dc1c57ea2633daf61c4daab0;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/sockcmsg_unix.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/sockcmsg_unix.go][vendor/golang.org/x/sys/unix/sockcmsg_unix.go];	
0000000000000000000000000000000000000000;;	// +build darwin dragonfly freebsd linux netbsd openbsd solaris
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Socket control messages
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unix
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Round the length of a raw sockaddr up to align it properly.
0000000000000000000000000000000000000000;;	func cmsgAlignOf(salen int) int {
0000000000000000000000000000000000000000;;		salign := sizeofPtr
0000000000000000000000000000000000000000;;		// NOTE: It seems like 64-bit Darwin and DragonFly BSD kernels
0000000000000000000000000000000000000000;;		// still require 32-bit aligned access to network subsystem.
0000000000000000000000000000000000000000;;		if darwin64Bit || dragonfly64Bit {
0000000000000000000000000000000000000000;;			salign = 4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (salen + salign - 1) & ^(salign - 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CmsgLen returns the value to store in the Len field of the Cmsghdr
0000000000000000000000000000000000000000;;	// structure, taking into account any necessary alignment.
0000000000000000000000000000000000000000;;	func CmsgLen(datalen int) int {
0000000000000000000000000000000000000000;;		return cmsgAlignOf(SizeofCmsghdr) + datalen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CmsgSpace returns the number of bytes an ancillary element with
0000000000000000000000000000000000000000;;	// payload of the passed data length occupies.
0000000000000000000000000000000000000000;;	func CmsgSpace(datalen int) int {
0000000000000000000000000000000000000000;;		return cmsgAlignOf(SizeofCmsghdr) + cmsgAlignOf(datalen)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cmsgData(h *Cmsghdr) unsafe.Pointer {
0000000000000000000000000000000000000000;;		return unsafe.Pointer(uintptr(unsafe.Pointer(h)) + uintptr(cmsgAlignOf(SizeofCmsghdr)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SocketControlMessage represents a socket control message.
0000000000000000000000000000000000000000;;	type SocketControlMessage struct {
0000000000000000000000000000000000000000;;		Header Cmsghdr
0000000000000000000000000000000000000000;;		Data   []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseSocketControlMessage parses b as an array of socket control
0000000000000000000000000000000000000000;;	// messages.
0000000000000000000000000000000000000000;;	func ParseSocketControlMessage(b []byte) ([]SocketControlMessage, error) {
0000000000000000000000000000000000000000;;		var msgs []SocketControlMessage
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for i+CmsgLen(0) <= len(b) {
0000000000000000000000000000000000000000;;			h, dbuf, err := socketControlMessageHeaderAndData(b[i:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m := SocketControlMessage{Header: *h, Data: dbuf}
0000000000000000000000000000000000000000;;			msgs = append(msgs, m)
0000000000000000000000000000000000000000;;			i += cmsgAlignOf(int(h.Len))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msgs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func socketControlMessageHeaderAndData(b []byte) (*Cmsghdr, []byte, error) {
0000000000000000000000000000000000000000;;		h := (*Cmsghdr)(unsafe.Pointer(&b[0]))
0000000000000000000000000000000000000000;;		if h.Len < SizeofCmsghdr || uint64(h.Len) > uint64(len(b)) {
0000000000000000000000000000000000000000;;			return nil, nil, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h, b[cmsgAlignOf(SizeofCmsghdr):h.Len], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnixRights encodes a set of open file descriptors into a socket
0000000000000000000000000000000000000000;;	// control message for sending to another process.
0000000000000000000000000000000000000000;;	func UnixRights(fds ...int) []byte {
0000000000000000000000000000000000000000;;		datalen := len(fds) * 4
0000000000000000000000000000000000000000;;		b := make([]byte, CmsgSpace(datalen))
0000000000000000000000000000000000000000;;		h := (*Cmsghdr)(unsafe.Pointer(&b[0]))
0000000000000000000000000000000000000000;;		h.Level = SOL_SOCKET
0000000000000000000000000000000000000000;;		h.Type = SCM_RIGHTS
0000000000000000000000000000000000000000;;		h.SetLen(CmsgLen(datalen))
0000000000000000000000000000000000000000;;		data := cmsgData(h)
0000000000000000000000000000000000000000;;		for _, fd := range fds {
0000000000000000000000000000000000000000;;			*(*int32)(data) = int32(fd)
0000000000000000000000000000000000000000;;			data = unsafe.Pointer(uintptr(data) + 4)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseUnixRights decodes a socket control message that contains an
0000000000000000000000000000000000000000;;	// integer array of open file descriptors from another process.
0000000000000000000000000000000000000000;;	func ParseUnixRights(m *SocketControlMessage) ([]int, error) {
0000000000000000000000000000000000000000;;		if m.Header.Level != SOL_SOCKET {
0000000000000000000000000000000000000000;;			return nil, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Header.Type != SCM_RIGHTS {
0000000000000000000000000000000000000000;;			return nil, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fds := make([]int, len(m.Data)>>2)
0000000000000000000000000000000000000000;;		for i, j := 0, 0; i < len(m.Data); i += 4 {
0000000000000000000000000000000000000000;;			fds[j] = int(*(*int32)(unsafe.Pointer(&m.Data[i])))
0000000000000000000000000000000000000000;;			j++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fds, nil
0000000000000000000000000000000000000000;;	}
