0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
12a86164cdbf8548dc1c57ea2633daf61c4daab0;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_bsd.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_bsd.go][vendor/golang.org/x/sys/unix/syscall_bsd.go];	
0000000000000000000000000000000000000000;;	// +build darwin dragonfly freebsd netbsd openbsd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BSD system call wrappers shared by *BSD based systems
0000000000000000000000000000000000000000;;	// including OS X (Darwin) and FreeBSD.  Like the other
0000000000000000000000000000000000000000;;	// syscall_*.go files it is compiled as Go code but also
0000000000000000000000000000000000000000;;	// used as input to mksyscall which parses the //sys
0000000000000000000000000000000000000000;;	// lines and generates system call stubs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unix
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Wrapped
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb	getgroups(ngid int, gid *_Gid_t) (n int, err error)
0000000000000000000000000000000000000000;;	//sysnb	setgroups(ngid int, gid *_Gid_t) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getgroups() (gids []int, err error) {
0000000000000000000000000000000000000000;;		n, err := getgroups(0, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sanity check group count.  Max is 16 on BSD.
0000000000000000000000000000000000000000;;		if n < 0 || n > 1000 {
0000000000000000000000000000000000000000;;			return nil, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := make([]_Gid_t, n)
0000000000000000000000000000000000000000;;		n, err = getgroups(n, &a[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gids = make([]int, n)
0000000000000000000000000000000000000000;;		for i, v := range a[0:n] {
0000000000000000000000000000000000000000;;			gids[i] = int(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Setgroups(gids []int) (err error) {
0000000000000000000000000000000000000000;;		if len(gids) == 0 {
0000000000000000000000000000000000000000;;			return setgroups(0, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := make([]_Gid_t, len(gids))
0000000000000000000000000000000000000000;;		for i, v := range gids {
0000000000000000000000000000000000000000;;			a[i] = _Gid_t(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return setgroups(len(a), &a[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReadDirent(fd int, buf []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		// Final argument is (basep *uintptr) and the syscall doesn't take nil.
0000000000000000000000000000000000000000;;		// 64 bits should be enough. (32 bits isn't even on 386). Since the
0000000000000000000000000000000000000000;;		// actual system call is getdirentries64, 64 is a good guess.
0000000000000000000000000000000000000000;;		// TODO(rsc): Can we use a single global basep for all calls?
0000000000000000000000000000000000000000;;		var base = (*uintptr)(unsafe.Pointer(new(uint64)))
0000000000000000000000000000000000000000;;		return Getdirentries(fd, buf, base)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait status is 7 bits at bottom, either 0 (exited),
0000000000000000000000000000000000000000;;	// 0x7F (stopped), or a signal number that caused an exit.
0000000000000000000000000000000000000000;;	// The 0x80 bit is whether there was a core dump.
0000000000000000000000000000000000000000;;	// An extra number (exit code, signal causing a stop)
0000000000000000000000000000000000000000;;	// is in the high bits.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WaitStatus uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		mask  = 0x7F
0000000000000000000000000000000000000000;;		core  = 0x80
0000000000000000000000000000000000000000;;		shift = 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exited  = 0
0000000000000000000000000000000000000000;;		stopped = 0x7F
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Exited() bool { return w&mask == exited }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) ExitStatus() int {
0000000000000000000000000000000000000000;;		if w&mask != exited {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(w >> shift)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Signaled() bool { return w&mask != stopped && w&mask != 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Signal() syscall.Signal {
0000000000000000000000000000000000000000;;		sig := syscall.Signal(w & mask)
0000000000000000000000000000000000000000;;		if sig == stopped || sig == 0 {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) CoreDump() bool { return w.Signaled() && w&core != 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Stopped() bool { return w&mask == stopped && syscall.Signal(w>>shift) != SIGSTOP }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Continued() bool { return w&mask == stopped && syscall.Signal(w>>shift) == SIGSTOP }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) StopSignal() syscall.Signal {
0000000000000000000000000000000000000000;;		if !w.Stopped() {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Signal(w>>shift) & 0xFF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) TrapCause() int { return -1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) {
0000000000000000000000000000000000000000;;		var status _C_int
0000000000000000000000000000000000000000;;		wpid, err = wait4(pid, &status, options, rusage)
0000000000000000000000000000000000000000;;		if wstatus != nil {
0000000000000000000000000000000000000000;;			*wstatus = WaitStatus(status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
0000000000000000000000000000000000000000;;	//sys	connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)
0000000000000000000000000000000000000000;;	//sysnb	socket(domain int, typ int, proto int) (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)
0000000000000000000000000000000000000000;;	//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)
0000000000000000000000000000000000000000;;	//sysnb	getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)
0000000000000000000000000000000000000000;;	//sysnb	getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)
0000000000000000000000000000000000000000;;	//sys	Shutdown(s int, how int) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		if sa.Port < 0 || sa.Port > 0xFFFF {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Len = SizeofSockaddrInet4
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_INET
0000000000000000000000000000000000000000;;		p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
0000000000000000000000000000000000000000;;		p[0] = byte(sa.Port >> 8)
0000000000000000000000000000000000000000;;		p[1] = byte(sa.Port)
0000000000000000000000000000000000000000;;		for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;			sa.raw.Addr[i] = sa.Addr[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), _Socklen(sa.raw.Len), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		if sa.Port < 0 || sa.Port > 0xFFFF {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Len = SizeofSockaddrInet6
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_INET6
0000000000000000000000000000000000000000;;		p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
0000000000000000000000000000000000000000;;		p[0] = byte(sa.Port >> 8)
0000000000000000000000000000000000000000;;		p[1] = byte(sa.Port)
0000000000000000000000000000000000000000;;		sa.raw.Scope_id = sa.ZoneId
0000000000000000000000000000000000000000;;		for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;			sa.raw.Addr[i] = sa.Addr[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), _Socklen(sa.raw.Len), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		name := sa.Name
0000000000000000000000000000000000000000;;		n := len(name)
0000000000000000000000000000000000000000;;		if n >= len(sa.raw.Path) || n == 0 {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Len = byte(3 + n) // 2 for Family, Len; 1 for NUL
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_UNIX
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			sa.raw.Path[i] = int8(name[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), _Socklen(sa.raw.Len), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrDatalink) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		if sa.Index == 0 {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Len = sa.Len
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_LINK
0000000000000000000000000000000000000000;;		sa.raw.Index = sa.Index
0000000000000000000000000000000000000000;;		sa.raw.Type = sa.Type
0000000000000000000000000000000000000000;;		sa.raw.Nlen = sa.Nlen
0000000000000000000000000000000000000000;;		sa.raw.Alen = sa.Alen
0000000000000000000000000000000000000000;;		sa.raw.Slen = sa.Slen
0000000000000000000000000000000000000000;;		for i := 0; i < len(sa.raw.Data); i++ {
0000000000000000000000000000000000000000;;			sa.raw.Data[i] = sa.Data[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), SizeofSockaddrDatalink, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, error) {
0000000000000000000000000000000000000000;;		switch rsa.Addr.Family {
0000000000000000000000000000000000000000;;		case AF_LINK:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrDatalink)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrDatalink)
0000000000000000000000000000000000000000;;			sa.Len = pp.Len
0000000000000000000000000000000000000000;;			sa.Family = pp.Family
0000000000000000000000000000000000000000;;			sa.Index = pp.Index
0000000000000000000000000000000000000000;;			sa.Type = pp.Type
0000000000000000000000000000000000000000;;			sa.Nlen = pp.Nlen
0000000000000000000000000000000000000000;;			sa.Alen = pp.Alen
0000000000000000000000000000000000000000;;			sa.Slen = pp.Slen
0000000000000000000000000000000000000000;;			for i := 0; i < len(sa.Data); i++ {
0000000000000000000000000000000000000000;;				sa.Data[i] = pp.Data[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_UNIX:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			if pp.Len < 2 || pp.Len > SizeofSockaddrUnix {
0000000000000000000000000000000000000000;;				return nil, EINVAL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sa := new(SockaddrUnix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Some BSDs include the trailing NUL in the length, whereas
0000000000000000000000000000000000000000;;			// others do not. Work around this by subtracting the leading
0000000000000000000000000000000000000000;;			// family and len. The path is then scanned to see if a NUL
0000000000000000000000000000000000000000;;			// terminator still exists within the length.
0000000000000000000000000000000000000000;;			n := int(pp.Len) - 2 // subtract leading Family, Len
0000000000000000000000000000000000000000;;			for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;				if pp.Path[i] == 0 {
0000000000000000000000000000000000000000;;					// found early NUL; assume Len included the NUL
0000000000000000000000000000000000000000;;					// or was overestimating.
0000000000000000000000000000000000000000;;					n = i
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bytes := (*[10000]byte)(unsafe.Pointer(&pp.Path[0]))[0:n]
0000000000000000000000000000000000000000;;			sa.Name = string(bytes)
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_INET:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrInet4)
0000000000000000000000000000000000000000;;			p := (*[2]byte)(unsafe.Pointer(&pp.Port))
0000000000000000000000000000000000000000;;			sa.Port = int(p[0])<<8 + int(p[1])
0000000000000000000000000000000000000000;;			for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;				sa.Addr[i] = pp.Addr[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_INET6:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrInet6)
0000000000000000000000000000000000000000;;			p := (*[2]byte)(unsafe.Pointer(&pp.Port))
0000000000000000000000000000000000000000;;			sa.Port = int(p[0])<<8 + int(p[1])
0000000000000000000000000000000000000000;;			sa.ZoneId = pp.Scope_id
0000000000000000000000000000000000000000;;			for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;				sa.Addr[i] = pp.Addr[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, EAFNOSUPPORT
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Accept(fd int) (nfd int, sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		var len _Socklen = SizeofSockaddrAny
0000000000000000000000000000000000000000;;		nfd, err = accept(fd, &rsa, &len)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if runtime.GOOS == "darwin" && len == 0 {
0000000000000000000000000000000000000000;;			// Accepted socket has no address.
0000000000000000000000000000000000000000;;			// This is likely due to a bug in xnu kernels,
0000000000000000000000000000000000000000;;			// where instead of ECONNABORTED error socket
0000000000000000000000000000000000000000;;			// is accepted, but has no address.
0000000000000000000000000000000000000000;;			Close(nfd)
0000000000000000000000000000000000000000;;			return 0, nil, ECONNABORTED
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa, err = anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Close(nfd)
0000000000000000000000000000000000000000;;			nfd = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getsockname(fd int) (sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		var len _Socklen = SizeofSockaddrAny
0000000000000000000000000000000000000000;;		if err = getsockname(fd, &rsa, &len); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(jsing): DragonFly has a "bug" (see issue 3349), which should be
0000000000000000000000000000000000000000;;		// reported upstream.
0000000000000000000000000000000000000000;;		if runtime.GOOS == "dragonfly" && rsa.Addr.Family == AF_UNSPEC && rsa.Addr.Len == 0 {
0000000000000000000000000000000000000000;;			rsa.Addr.Family = AF_UNIX
0000000000000000000000000000000000000000;;			rsa.Addr.Len = SizeofSockaddrUnix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb socketpair(domain int, typ int, proto int, fd *[2]int32) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptByte(fd, level, opt int) (value byte, err error) {
0000000000000000000000000000000000000000;;		var n byte
0000000000000000000000000000000000000000;;		vallen := _Socklen(1)
0000000000000000000000000000000000000000;;		err = getsockopt(fd, level, opt, unsafe.Pointer(&n), &vallen)
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, err error) {
0000000000000000000000000000000000000000;;		vallen := _Socklen(4)
0000000000000000000000000000000000000000;;		err = getsockopt(fd, level, opt, unsafe.Pointer(&value[0]), &vallen)
0000000000000000000000000000000000000000;;		return value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error) {
0000000000000000000000000000000000000000;;		var value IPMreq
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofIPMreq)
0000000000000000000000000000000000000000;;		err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error) {
0000000000000000000000000000000000000000;;		var value IPv6Mreq
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofIPv6Mreq)
0000000000000000000000000000000000000000;;		err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptIPv6MTUInfo(fd, level, opt int) (*IPv6MTUInfo, error) {
0000000000000000000000000000000000000000;;		var value IPv6MTUInfo
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofIPv6MTUInfo)
0000000000000000000000000000000000000000;;		err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptICMPv6Filter(fd, level, opt int) (*ICMPv6Filter, error) {
0000000000000000000000000000000000000000;;		var value ICMPv6Filter
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofICMPv6Filter)
0000000000000000000000000000000000000000;;		err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys   recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)
0000000000000000000000000000000000000000;;	//sys   sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)
0000000000000000000000000000000000000000;;	//sys	recvmsg(s int, msg *Msghdr, flags int) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var msg Msghdr
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		msg.Name = (*byte)(unsafe.Pointer(&rsa))
0000000000000000000000000000000000000000;;		msg.Namelen = uint32(SizeofSockaddrAny)
0000000000000000000000000000000000000000;;		var iov Iovec
0000000000000000000000000000000000000000;;		if len(p) > 0 {
0000000000000000000000000000000000000000;;			iov.Base = (*byte)(unsafe.Pointer(&p[0]))
0000000000000000000000000000000000000000;;			iov.SetLen(len(p))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var dummy byte
0000000000000000000000000000000000000000;;		if len(oob) > 0 {
0000000000000000000000000000000000000000;;			// receive at least one normal byte
0000000000000000000000000000000000000000;;			if len(p) == 0 {
0000000000000000000000000000000000000000;;				iov.Base = &dummy
0000000000000000000000000000000000000000;;				iov.SetLen(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg.Control = (*byte)(unsafe.Pointer(&oob[0]))
0000000000000000000000000000000000000000;;			msg.SetControllen(len(oob))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Iov = &iov
0000000000000000000000000000000000000000;;		msg.Iovlen = 1
0000000000000000000000000000000000000000;;		if n, err = recvmsg(fd, &msg, flags); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oobn = int(msg.Controllen)
0000000000000000000000000000000000000000;;		recvflags = int(msg.Flags)
0000000000000000000000000000000000000000;;		// source address is only specified if the socket is unconnected
0000000000000000000000000000000000000000;;		if rsa.Addr.Family != AF_UNSPEC {
0000000000000000000000000000000000000000;;			from, err = anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	sendmsg(s int, msg *Msghdr, flags int) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (err error) {
0000000000000000000000000000000000000000;;		_, err = SendmsgN(fd, p, oob, to, flags)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SendmsgN(fd int, p, oob []byte, to Sockaddr, flags int) (n int, err error) {
0000000000000000000000000000000000000000;;		var ptr unsafe.Pointer
0000000000000000000000000000000000000000;;		var salen _Socklen
0000000000000000000000000000000000000000;;		if to != nil {
0000000000000000000000000000000000000000;;			ptr, salen, err = to.sockaddr()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var msg Msghdr
0000000000000000000000000000000000000000;;		msg.Name = (*byte)(unsafe.Pointer(ptr))
0000000000000000000000000000000000000000;;		msg.Namelen = uint32(salen)
0000000000000000000000000000000000000000;;		var iov Iovec
0000000000000000000000000000000000000000;;		if len(p) > 0 {
0000000000000000000000000000000000000000;;			iov.Base = (*byte)(unsafe.Pointer(&p[0]))
0000000000000000000000000000000000000000;;			iov.SetLen(len(p))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var dummy byte
0000000000000000000000000000000000000000;;		if len(oob) > 0 {
0000000000000000000000000000000000000000;;			// send at least one normal byte
0000000000000000000000000000000000000000;;			if len(p) == 0 {
0000000000000000000000000000000000000000;;				iov.Base = &dummy
0000000000000000000000000000000000000000;;				iov.SetLen(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg.Control = (*byte)(unsafe.Pointer(&oob[0]))
0000000000000000000000000000000000000000;;			msg.SetControllen(len(oob))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Iov = &iov
0000000000000000000000000000000000000000;;		msg.Iovlen = 1
0000000000000000000000000000000000000000;;		if n, err = sendmsg(fd, &msg, flags); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(oob) > 0 && len(p) == 0 {
0000000000000000000000000000000000000000;;			n = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Kevent(kq int, changes, events []Kevent_t, timeout *Timespec) (n int, err error) {
0000000000000000000000000000000000000000;;		var change, event unsafe.Pointer
0000000000000000000000000000000000000000;;		if len(changes) > 0 {
0000000000000000000000000000000000000000;;			change = unsafe.Pointer(&changes[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(events) > 0 {
0000000000000000000000000000000000000000;;			event = unsafe.Pointer(&events[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return kevent(kq, change, len(changes), event, len(events), timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	sysctl(mib []_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS___SYSCTL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sysctlmib translates name to mib number and appends any additional args.
0000000000000000000000000000000000000000;;	func sysctlmib(name string, args ...int) ([]_C_int, error) {
0000000000000000000000000000000000000000;;		// Translate name to mib number.
0000000000000000000000000000000000000000;;		mib, err := nametomib(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, a := range args {
0000000000000000000000000000000000000000;;			mib = append(mib, _C_int(a))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mib, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Sysctl(name string) (string, error) {
0000000000000000000000000000000000000000;;		return SysctlArgs(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SysctlArgs(name string, args ...int) (string, error) {
0000000000000000000000000000000000000000;;		mib, err := sysctlmib(name, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find size.
0000000000000000000000000000000000000000;;		n := uintptr(0)
0000000000000000000000000000000000000000;;		if err := sysctl(mib, nil, &n, nil, 0); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read into buffer of that size.
0000000000000000000000000000000000000000;;		buf := make([]byte, n)
0000000000000000000000000000000000000000;;		if err := sysctl(mib, &buf[0], &n, nil, 0); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Throw away terminating NUL.
0000000000000000000000000000000000000000;;		if n > 0 && buf[n-1] == '\x00' {
0000000000000000000000000000000000000000;;			n--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf[0:n]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SysctlUint32(name string) (uint32, error) {
0000000000000000000000000000000000000000;;		return SysctlUint32Args(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SysctlUint32Args(name string, args ...int) (uint32, error) {
0000000000000000000000000000000000000000;;		mib, err := sysctlmib(name, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := uintptr(4)
0000000000000000000000000000000000000000;;		buf := make([]byte, 4)
0000000000000000000000000000000000000000;;		if err := sysctl(mib, &buf[0], &n, nil, 0); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != 4 {
0000000000000000000000000000000000000000;;			return 0, EIO
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *(*uint32)(unsafe.Pointer(&buf[0])), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SysctlUint64(name string, args ...int) (uint64, error) {
0000000000000000000000000000000000000000;;		mib, err := sysctlmib(name, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := uintptr(8)
0000000000000000000000000000000000000000;;		buf := make([]byte, 8)
0000000000000000000000000000000000000000;;		if err := sysctl(mib, &buf[0], &n, nil, 0); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != 8 {
0000000000000000000000000000000000000000;;			return 0, EIO
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *(*uint64)(unsafe.Pointer(&buf[0])), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SysctlRaw(name string, args ...int) ([]byte, error) {
0000000000000000000000000000000000000000;;		mib, err := sysctlmib(name, args...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find size.
0000000000000000000000000000000000000000;;		n := uintptr(0)
0000000000000000000000000000000000000000;;		if err := sysctl(mib, nil, &n, nil, 0); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read into buffer of that size.
0000000000000000000000000000000000000000;;		buf := make([]byte, n)
0000000000000000000000000000000000000000;;		if err := sysctl(mib, &buf[0], &n, nil, 0); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The actual call may return less than the original reported required
0000000000000000000000000000000000000000;;		// size so ensure we deal with that.
0000000000000000000000000000000000000000;;		return buf[:n], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	utimes(path string, timeval *[2]Timeval) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Utimes(path string, tv []Timeval) error {
0000000000000000000000000000000000000000;;		if tv == nil {
0000000000000000000000000000000000000000;;			return utimes(path, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tv) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UtimesNano(path string, ts []Timespec) error {
0000000000000000000000000000000000000000;;		if ts == nil {
0000000000000000000000000000000000000000;;			return utimes(path, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: The BSDs can do utimensat with SYS_UTIMENSAT but it
0000000000000000000000000000000000000000;;		// isn't supported by darwin so this uses utimes instead
0000000000000000000000000000000000000000;;		if len(ts) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Not as efficient as it could be because Timespec and
0000000000000000000000000000000000000000;;		// Timeval have different types in the different OSes
0000000000000000000000000000000000000000;;		tv := [2]Timeval{
0000000000000000000000000000000000000000;;			NsecToTimeval(TimespecToNsec(ts[0])),
0000000000000000000000000000000000000000;;			NsecToTimeval(TimespecToNsec(ts[1])),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	futimes(fd int, timeval *[2]Timeval) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Futimes(fd int, tv []Timeval) error {
0000000000000000000000000000000000000000;;		if tv == nil {
0000000000000000000000000000000000000000;;			return futimes(fd, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tv) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return futimes(fd, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	fcntl(fd int, cmd int, arg int) (val int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: wrap
0000000000000000000000000000000000000000;;	//	Acct(name nil-string) (err error)
0000000000000000000000000000000000000000;;	//	Gethostuuid(uuid *byte, timeout *Timespec) (err error)
0000000000000000000000000000000000000000;;	//	Madvise(addr *byte, len int, behav int) (err error)
0000000000000000000000000000000000000000;;	//	Mprotect(addr *byte, len int, prot int) (err error)
0000000000000000000000000000000000000000;;	//	Msync(addr *byte, len int, flags int) (err error)
0000000000000000000000000000000000000000;;	//	Ptrace(req int, pid int, addr uintptr, data int) (ret uintptr, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var mapper = &mmapper{
0000000000000000000000000000000000000000;;		active: make(map[*byte][]byte),
0000000000000000000000000000000000000000;;		mmap:   mmap,
0000000000000000000000000000000000000000;;		munmap: munmap,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error) {
0000000000000000000000000000000000000000;;		return mapper.Mmap(fd, offset, length, prot, flags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Munmap(b []byte) (err error) {
0000000000000000000000000000000000000000;;		return mapper.Munmap(b)
0000000000000000000000000000000000000000;;	}
