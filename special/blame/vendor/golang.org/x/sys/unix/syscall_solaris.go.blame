0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
12a86164cdbf8548dc1c57ea2633daf61c4daab0;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_solaris.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_solaris.go][vendor/golang.org/x/sys/unix/syscall_solaris.go];	
0000000000000000000000000000000000000000;;	// Solaris system calls.
0000000000000000000000000000000000000000;;	// This file is compiled as ordinary Go code,
0000000000000000000000000000000000000000;;	// but it is also input to mksyscall,
0000000000000000000000000000000000000000;;	// which parses the //sys lines and generates system call stubs.
0000000000000000000000000000000000000000;;	// Note that sometimes we use a lowercase //sys name and wrap
0000000000000000000000000000000000000000;;	// it in our own nicer implementation, either here or in
0000000000000000000000000000000000000000;;	// syscall_solaris.go or syscall_unix.go.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unix
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implemented in runtime/syscall_solaris.go.
0000000000000000000000000000000000000000;;	type syscallFunc uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rawSysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)
0000000000000000000000000000000000000000;;	func sysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrDatalink struct {
0000000000000000000000000000000000000000;;		Family uint16
0000000000000000000000000000000000000000;;		Index  uint16
0000000000000000000000000000000000000000;;		Type   uint8
0000000000000000000000000000000000000000;;		Nlen   uint8
0000000000000000000000000000000000000000;;		Alen   uint8
0000000000000000000000000000000000000000;;		Slen   uint8
0000000000000000000000000000000000000000;;		Data   [244]int8
0000000000000000000000000000000000000000;;		raw    RawSockaddrDatalink
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func clen(n []byte) int {
0000000000000000000000000000000000000000;;		for i := 0; i < len(n); i++ {
0000000000000000000000000000000000000000;;			if n[i] == 0 {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseDirent parses up to max directory entries in buf,
0000000000000000000000000000000000000000;;	// appending the names to names.  It returns the number
0000000000000000000000000000000000000000;;	// bytes consumed from buf, the number of entries added
0000000000000000000000000000000000000000;;	// to names, and the new names slice.
0000000000000000000000000000000000000000;;	func ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string) {
0000000000000000000000000000000000000000;;		origlen := len(buf)
0000000000000000000000000000000000000000;;		for max != 0 && len(buf) > 0 {
0000000000000000000000000000000000000000;;			dirent := (*Dirent)(unsafe.Pointer(&buf[0]))
0000000000000000000000000000000000000000;;			if dirent.Reclen == 0 {
0000000000000000000000000000000000000000;;				buf = nil
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf = buf[dirent.Reclen:]
0000000000000000000000000000000000000000;;			if dirent.Ino == 0 { // File absent in directory.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bytes := (*[10000]byte)(unsafe.Pointer(&dirent.Name[0]))
0000000000000000000000000000000000000000;;			var name = string(bytes[0:clen(bytes[:])])
0000000000000000000000000000000000000000;;			if name == "." || name == ".." { // Useless names
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			max--
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			names = append(names, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return origlen - len(buf), count, names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb	pipe(p *[2]_C_int) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Pipe(p []int) (err error) {
0000000000000000000000000000000000000000;;		if len(p) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var pp [2]_C_int
0000000000000000000000000000000000000000;;		n, err := pipe(&pp)
0000000000000000000000000000000000000000;;		if n != 0 {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p[0] = int(pp[0])
0000000000000000000000000000000000000000;;		p[1] = int(pp[1])
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		if sa.Port < 0 || sa.Port > 0xFFFF {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_INET
0000000000000000000000000000000000000000;;		p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
0000000000000000000000000000000000000000;;		p[0] = byte(sa.Port >> 8)
0000000000000000000000000000000000000000;;		p[1] = byte(sa.Port)
0000000000000000000000000000000000000000;;		for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;			sa.raw.Addr[i] = sa.Addr[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), SizeofSockaddrInet4, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		if sa.Port < 0 || sa.Port > 0xFFFF {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_INET6
0000000000000000000000000000000000000000;;		p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
0000000000000000000000000000000000000000;;		p[0] = byte(sa.Port >> 8)
0000000000000000000000000000000000000000;;		p[1] = byte(sa.Port)
0000000000000000000000000000000000000000;;		sa.raw.Scope_id = sa.ZoneId
0000000000000000000000000000000000000000;;		for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;			sa.raw.Addr[i] = sa.Addr[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), SizeofSockaddrInet6, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		name := sa.Name
0000000000000000000000000000000000000000;;		n := len(name)
0000000000000000000000000000000000000000;;		if n >= len(sa.raw.Path) {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_UNIX
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			sa.raw.Path[i] = int8(name[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// length is family (uint16), name, NUL.
0000000000000000000000000000000000000000;;		sl := _Socklen(2)
0000000000000000000000000000000000000000;;		if n > 0 {
0000000000000000000000000000000000000000;;			sl += _Socklen(n) + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sa.raw.Path[0] == '@' {
0000000000000000000000000000000000000000;;			sa.raw.Path[0] = 0
0000000000000000000000000000000000000000;;			// Don't count trailing NUL for abstract address.
0000000000000000000000000000000000000000;;			sl--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), sl, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) = libsocket.getsockname
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getsockname(fd int) (sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		var len _Socklen = SizeofSockaddrAny
0000000000000000000000000000000000000000;;		if err = getsockname(fd, &rsa, &len); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const ImplementsGetwd = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	Getcwd(buf []byte) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getwd() (wd string, err error) {
0000000000000000000000000000000000000000;;		var buf [PathMax]byte
0000000000000000000000000000000000000000;;		// Getcwd will return an error if it failed for any reason.
0000000000000000000000000000000000000000;;		_, err = Getcwd(buf[0:])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := clen(buf[:])
0000000000000000000000000000000000000000;;		if n < 1 {
0000000000000000000000000000000000000000;;			return "", EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf[:n]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Wrapped
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb	getgroups(ngid int, gid *_Gid_t) (n int, err error)
0000000000000000000000000000000000000000;;	//sysnb	setgroups(ngid int, gid *_Gid_t) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getgroups() (gids []int, err error) {
0000000000000000000000000000000000000000;;		n, err := getgroups(0, nil)
0000000000000000000000000000000000000000;;		// Check for error and sanity check group count.  Newer versions of
0000000000000000000000000000000000000000;;		// Solaris allow up to 1024 (NGROUPS_MAX).
0000000000000000000000000000000000000000;;		if n < 0 || n > 1024 {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, EINVAL
0000000000000000000000000000000000000000;;		} else if n == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := make([]_Gid_t, n)
0000000000000000000000000000000000000000;;		n, err = getgroups(n, &a[0])
0000000000000000000000000000000000000000;;		if n == -1 {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gids = make([]int, n)
0000000000000000000000000000000000000000;;		for i, v := range a[0:n] {
0000000000000000000000000000000000000000;;			gids[i] = int(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Setgroups(gids []int) (err error) {
0000000000000000000000000000000000000000;;		if len(gids) == 0 {
0000000000000000000000000000000000000000;;			return setgroups(0, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := make([]_Gid_t, len(gids))
0000000000000000000000000000000000000000;;		for i, v := range gids {
0000000000000000000000000000000000000000;;			a[i] = _Gid_t(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return setgroups(len(a), &a[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReadDirent(fd int, buf []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		// Final argument is (basep *uintptr) and the syscall doesn't take nil.
0000000000000000000000000000000000000000;;		// TODO(rsc): Can we use a single global basep for all calls?
0000000000000000000000000000000000000000;;		return Getdents(fd, buf, new(uintptr))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait status is 7 bits at bottom, either 0 (exited),
0000000000000000000000000000000000000000;;	// 0x7F (stopped), or a signal number that caused an exit.
0000000000000000000000000000000000000000;;	// The 0x80 bit is whether there was a core dump.
0000000000000000000000000000000000000000;;	// An extra number (exit code, signal causing a stop)
0000000000000000000000000000000000000000;;	// is in the high bits.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WaitStatus uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		mask  = 0x7F
0000000000000000000000000000000000000000;;		core  = 0x80
0000000000000000000000000000000000000000;;		shift = 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exited  = 0
0000000000000000000000000000000000000000;;		stopped = 0x7F
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Exited() bool { return w&mask == exited }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) ExitStatus() int {
0000000000000000000000000000000000000000;;		if w&mask != exited {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(w >> shift)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Signaled() bool { return w&mask != stopped && w&mask != 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Signal() syscall.Signal {
0000000000000000000000000000000000000000;;		sig := syscall.Signal(w & mask)
0000000000000000000000000000000000000000;;		if sig == stopped || sig == 0 {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) CoreDump() bool { return w.Signaled() && w&core != 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Stopped() bool { return w&mask == stopped && syscall.Signal(w>>shift) != SIGSTOP }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Continued() bool { return w&mask == stopped && syscall.Signal(w>>shift) == SIGSTOP }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) StopSignal() syscall.Signal {
0000000000000000000000000000000000000000;;		if !w.Stopped() {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Signal(w>>shift) & 0xFF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) TrapCause() int { return -1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	wait4(pid int32, statusp *_C_int, options int, rusage *Rusage) (wpid int32, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (int, error) {
0000000000000000000000000000000000000000;;		var status _C_int
0000000000000000000000000000000000000000;;		rpid, err := wait4(int32(pid), &status, options, rusage)
0000000000000000000000000000000000000000;;		wpid := int(rpid)
0000000000000000000000000000000000000000;;		if wpid == -1 {
0000000000000000000000000000000000000000;;			return wpid, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wstatus != nil {
0000000000000000000000000000000000000000;;			*wstatus = WaitStatus(status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wpid, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	gethostname(buf []byte) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Gethostname() (name string, err error) {
0000000000000000000000000000000000000000;;		var buf [MaxHostNameLen]byte
0000000000000000000000000000000000000000;;		n, err := gethostname(buf[:])
0000000000000000000000000000000000000000;;		if n != 0 {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n = clen(buf[:])
0000000000000000000000000000000000000000;;		if n < 1 {
0000000000000000000000000000000000000000;;			return "", EFAULT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf[:n]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	utimes(path string, times *[2]Timeval) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Utimes(path string, tv []Timeval) (err error) {
0000000000000000000000000000000000000000;;		if tv == nil {
0000000000000000000000000000000000000000;;			return utimes(path, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tv) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	utimensat(fd int, path string, times *[2]Timespec, flag int) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UtimesNano(path string, ts []Timespec) error {
0000000000000000000000000000000000000000;;		if ts == nil {
0000000000000000000000000000000000000000;;			return utimensat(AT_FDCWD, path, nil, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ts) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utimensat(AT_FDCWD, path, (*[2]Timespec)(unsafe.Pointer(&ts[0])), 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UtimesNanoAt(dirfd int, path string, ts []Timespec, flags int) error {
0000000000000000000000000000000000000000;;		if ts == nil {
0000000000000000000000000000000000000000;;			return utimensat(dirfd, path, nil, flags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ts) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utimensat(dirfd, path, (*[2]Timespec)(unsafe.Pointer(&ts[0])), flags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	fcntl(fd int, cmd int, arg int) (val int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.
0000000000000000000000000000000000000000;;	func FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error {
0000000000000000000000000000000000000000;;		_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procfcntl)), 3, uintptr(fd), uintptr(cmd), uintptr(unsafe.Pointer(lk)), 0, 0, 0)
0000000000000000000000000000000000000000;;		if e1 != 0 {
0000000000000000000000000000000000000000;;			return e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	futimesat(fildes int, path *byte, times *[2]Timeval) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Futimesat(dirfd int, path string, tv []Timeval) error {
0000000000000000000000000000000000000000;;		pathp, err := BytePtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tv == nil {
0000000000000000000000000000000000000000;;			return futimesat(dirfd, pathp, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tv) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return futimesat(dirfd, pathp, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Solaris doesn't have an futimes function because it allows NULL to be
0000000000000000000000000000000000000000;;	// specified as the path for futimesat.  However, Go doesn't like
0000000000000000000000000000000000000000;;	// NULL-style string interfaces, so this simple wrapper is provided.
0000000000000000000000000000000000000000;;	func Futimes(fd int, tv []Timeval) error {
0000000000000000000000000000000000000000;;		if tv == nil {
0000000000000000000000000000000000000000;;			return futimesat(fd, nil, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tv) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return futimesat(fd, nil, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, error) {
0000000000000000000000000000000000000000;;		switch rsa.Addr.Family {
0000000000000000000000000000000000000000;;		case AF_UNIX:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrUnix)
0000000000000000000000000000000000000000;;			// Assume path ends at NUL.
0000000000000000000000000000000000000000;;			// This is not technically the Solaris semantics for
0000000000000000000000000000000000000000;;			// abstract Unix domain sockets -- they are supposed
0000000000000000000000000000000000000000;;			// to be uninterpreted fixed-size binary blobs -- but
0000000000000000000000000000000000000000;;			// everyone uses this convention.
0000000000000000000000000000000000000000;;			n := 0
0000000000000000000000000000000000000000;;			for n < len(pp.Path) && pp.Path[n] != 0 {
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bytes := (*[10000]byte)(unsafe.Pointer(&pp.Path[0]))[0:n]
0000000000000000000000000000000000000000;;			sa.Name = string(bytes)
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_INET:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrInet4)
0000000000000000000000000000000000000000;;			p := (*[2]byte)(unsafe.Pointer(&pp.Port))
0000000000000000000000000000000000000000;;			sa.Port = int(p[0])<<8 + int(p[1])
0000000000000000000000000000000000000000;;			for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;				sa.Addr[i] = pp.Addr[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_INET6:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrInet6)
0000000000000000000000000000000000000000;;			p := (*[2]byte)(unsafe.Pointer(&pp.Port))
0000000000000000000000000000000000000000;;			sa.Port = int(p[0])<<8 + int(p[1])
0000000000000000000000000000000000000000;;			sa.ZoneId = pp.Scope_id
0000000000000000000000000000000000000000;;			for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;				sa.Addr[i] = pp.Addr[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, EAFNOSUPPORT
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) = libsocket.accept
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Accept(fd int) (nfd int, sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		var len _Socklen = SizeofSockaddrAny
0000000000000000000000000000000000000000;;		nfd, err = accept(fd, &rsa, &len)
0000000000000000000000000000000000000000;;		if nfd == -1 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa, err = anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Close(nfd)
0000000000000000000000000000000000000000;;			nfd = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	recvmsg(s int, msg *Msghdr, flags int) (n int, err error) = libsocket.recvmsg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var msg Msghdr
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		msg.Name = (*byte)(unsafe.Pointer(&rsa))
0000000000000000000000000000000000000000;;		msg.Namelen = uint32(SizeofSockaddrAny)
0000000000000000000000000000000000000000;;		var iov Iovec
0000000000000000000000000000000000000000;;		if len(p) > 0 {
0000000000000000000000000000000000000000;;			iov.Base = (*int8)(unsafe.Pointer(&p[0]))
0000000000000000000000000000000000000000;;			iov.SetLen(len(p))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var dummy int8
0000000000000000000000000000000000000000;;		if len(oob) > 0 {
0000000000000000000000000000000000000000;;			// receive at least one normal byte
0000000000000000000000000000000000000000;;			if len(p) == 0 {
0000000000000000000000000000000000000000;;				iov.Base = &dummy
0000000000000000000000000000000000000000;;				iov.SetLen(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg.Accrights = (*int8)(unsafe.Pointer(&oob[0]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Iov = &iov
0000000000000000000000000000000000000000;;		msg.Iovlen = 1
0000000000000000000000000000000000000000;;		if n, err = recvmsg(fd, &msg, flags); n == -1 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oobn = int(msg.Accrightslen)
0000000000000000000000000000000000000000;;		// source address is only specified if the socket is unconnected
0000000000000000000000000000000000000000;;		if rsa.Addr.Family != AF_UNSPEC {
0000000000000000000000000000000000000000;;			from, err = anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (err error) {
0000000000000000000000000000000000000000;;		_, err = SendmsgN(fd, p, oob, to, flags)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	sendmsg(s int, msg *Msghdr, flags int) (n int, err error) = libsocket.sendmsg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SendmsgN(fd int, p, oob []byte, to Sockaddr, flags int) (n int, err error) {
0000000000000000000000000000000000000000;;		var ptr unsafe.Pointer
0000000000000000000000000000000000000000;;		var salen _Socklen
0000000000000000000000000000000000000000;;		if to != nil {
0000000000000000000000000000000000000000;;			ptr, salen, err = to.sockaddr()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var msg Msghdr
0000000000000000000000000000000000000000;;		msg.Name = (*byte)(unsafe.Pointer(ptr))
0000000000000000000000000000000000000000;;		msg.Namelen = uint32(salen)
0000000000000000000000000000000000000000;;		var iov Iovec
0000000000000000000000000000000000000000;;		if len(p) > 0 {
0000000000000000000000000000000000000000;;			iov.Base = (*int8)(unsafe.Pointer(&p[0]))
0000000000000000000000000000000000000000;;			iov.SetLen(len(p))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var dummy int8
0000000000000000000000000000000000000000;;		if len(oob) > 0 {
0000000000000000000000000000000000000000;;			// send at least one normal byte
0000000000000000000000000000000000000000;;			if len(p) == 0 {
0000000000000000000000000000000000000000;;				iov.Base = &dummy
0000000000000000000000000000000000000000;;				iov.SetLen(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg.Accrights = (*int8)(unsafe.Pointer(&oob[0]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Iov = &iov
0000000000000000000000000000000000000000;;		msg.Iovlen = 1
0000000000000000000000000000000000000000;;		if n, err = sendmsg(fd, &msg, flags); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(oob) > 0 && len(p) == 0 {
0000000000000000000000000000000000000000;;			n = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	acct(path *byte) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Acct(path string) (err error) {
0000000000000000000000000000000000000000;;		if len(path) == 0 {
0000000000000000000000000000000000000000;;			// Assume caller wants to disable accounting.
0000000000000000000000000000000000000000;;			return acct(nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pathp, err := BytePtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return acct(pathp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Expose the ioctl function
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	ioctl(fd int, req int, arg uintptr) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IoctlSetInt(fd int, req int, value int) (err error) {
0000000000000000000000000000000000000000;;		return ioctl(fd, req, uintptr(value))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IoctlSetWinsize(fd int, req int, value *Winsize) (err error) {
0000000000000000000000000000000000000000;;		return ioctl(fd, req, uintptr(unsafe.Pointer(value)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IoctlSetTermios(fd int, req int, value *Termios) (err error) {
0000000000000000000000000000000000000000;;		return ioctl(fd, req, uintptr(unsafe.Pointer(value)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IoctlSetTermio(fd int, req int, value *Termio) (err error) {
0000000000000000000000000000000000000000;;		return ioctl(fd, req, uintptr(unsafe.Pointer(value)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IoctlGetInt(fd int, req int) (int, error) {
0000000000000000000000000000000000000000;;		var value int
0000000000000000000000000000000000000000;;		err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))
0000000000000000000000000000000000000000;;		return value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IoctlGetWinsize(fd int, req int) (*Winsize, error) {
0000000000000000000000000000000000000000;;		var value Winsize
0000000000000000000000000000000000000000;;		err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IoctlGetTermios(fd int, req int) (*Termios, error) {
0000000000000000000000000000000000000000;;		var value Termios
0000000000000000000000000000000000000000;;		err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IoctlGetTermio(fd int, req int) (*Termio, error) {
0000000000000000000000000000000000000000;;		var value Termio
0000000000000000000000000000000000000000;;		err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Exposed directly
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	//sys	Access(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Adjtime(delta *Timeval, olddelta *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sys	Chdir(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Chmod(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Chown(path string, uid int, gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Chroot(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Close(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Creat(path string, mode uint32) (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	Dup(fd int) (nfd int, err error)
0000000000000000000000000000000000000000;;	//sys	Dup2(oldfd int, newfd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Exit(code int)
0000000000000000000000000000000000000000;;	//sys	Fchdir(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchmod(fd int, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchown(fd int, uid int, gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fdatasync(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fpathconf(fd int, name int) (val int, err error)
0000000000000000000000000000000000000000;;	//sys	Fstat(fd int, stat *Stat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Getdents(fd int, buf []byte, basep *uintptr) (n int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Getgid() (gid int)
0000000000000000000000000000000000000000;;	//sysnb	Getpid() (pid int)
0000000000000000000000000000000000000000;;	//sysnb	Getpgid(pid int) (pgid int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Getpgrp() (pgid int, err error)
0000000000000000000000000000000000000000;;	//sys	Geteuid() (euid int)
0000000000000000000000000000000000000000;;	//sys	Getegid() (egid int)
0000000000000000000000000000000000000000;;	//sys	Getppid() (ppid int)
0000000000000000000000000000000000000000;;	//sys	Getpriority(which int, who int) (n int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Getrlimit(which int, lim *Rlimit) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Getrusage(who int, rusage *Rusage) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Gettimeofday(tv *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Getuid() (uid int)
0000000000000000000000000000000000000000;;	//sys	Kill(pid int, signum syscall.Signal) (err error)
0000000000000000000000000000000000000000;;	//sys	Lchown(path string, uid int, gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Link(path string, link string) (err error)
0000000000000000000000000000000000000000;;	//sys	Listen(s int, backlog int) (err error) = libsocket.listen
0000000000000000000000000000000000000000;;	//sys	Lstat(path string, stat *Stat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Madvise(b []byte, advice int) (err error)
0000000000000000000000000000000000000000;;	//sys	Mkdir(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Mkfifo(path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Mkfifoat(dirfd int, path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Mknod(path string, mode uint32, dev int) (err error)
0000000000000000000000000000000000000000;;	//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
0000000000000000000000000000000000000000;;	//sys	Mlock(b []byte) (err error)
0000000000000000000000000000000000000000;;	//sys	Mlockall(flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Mprotect(b []byte, prot int) (err error)
0000000000000000000000000000000000000000;;	//sys	Munlock(b []byte) (err error)
0000000000000000000000000000000000000000;;	//sys	Munlockall() (err error)
0000000000000000000000000000000000000000;;	//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
0000000000000000000000000000000000000000;;	//sys	Open(path string, mode int, perm uint32) (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	Pathconf(path string, name int) (val int, err error)
0000000000000000000000000000000000000000;;	//sys	Pause() (err error)
0000000000000000000000000000000000000000;;	//sys	Pread(fd int, p []byte, offset int64) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Pwrite(fd int, p []byte, offset int64) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	read(fd int, p []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Readlink(path string, buf []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Rename(from string, to string) (err error)
0000000000000000000000000000000000000000;;	//sys	Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
0000000000000000000000000000000000000000;;	//sys	Rmdir(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Seek(fd int, offset int64, whence int) (newoffset int64, err error) = lseek
0000000000000000000000000000000000000000;;	//sysnb	Setegid(egid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Seteuid(euid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setgid(gid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Sethostname(p []byte) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setpgid(pid int, pgid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Setpriority(which int, who int, prio int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setregid(rgid int, egid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setreuid(ruid int, euid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setrlimit(which int, lim *Rlimit) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setsid() (pid int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Setuid(uid int) (err error)
0000000000000000000000000000000000000000;;	//sys	Shutdown(s int, how int) (err error) = libsocket.shutdown
0000000000000000000000000000000000000000;;	//sys	Stat(path string, stat *Stat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Symlink(path string, link string) (err error)
0000000000000000000000000000000000000000;;	//sys	Sync() (err error)
0000000000000000000000000000000000000000;;	//sysnb	Times(tms *Tms) (ticks uintptr, err error)
0000000000000000000000000000000000000000;;	//sys	Truncate(path string, length int64) (err error)
0000000000000000000000000000000000000000;;	//sys	Fsync(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Ftruncate(fd int, length int64) (err error)
0000000000000000000000000000000000000000;;	//sys	Umask(mask int) (oldmask int)
0000000000000000000000000000000000000000;;	//sysnb	Uname(buf *Utsname) (err error)
0000000000000000000000000000000000000000;;	//sys	Unmount(target string, flags int) (err error) = libc.umount
0000000000000000000000000000000000000000;;	//sys	Unlink(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Unlinkat(dirfd int, path string, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Ustat(dev int, ubuf *Ustat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Utime(path string, buf *Utimbuf) (err error)
0000000000000000000000000000000000000000;;	//sys	bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.bind
0000000000000000000000000000000000000000;;	//sys	connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.connect
0000000000000000000000000000000000000000;;	//sys	mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)
0000000000000000000000000000000000000000;;	//sys	munmap(addr uintptr, length uintptr) (err error)
0000000000000000000000000000000000000000;;	//sys	sendto(s int, buf []byte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.sendto
0000000000000000000000000000000000000000;;	//sys	socket(domain int, typ int, proto int) (fd int, err error) = libsocket.socket
0000000000000000000000000000000000000000;;	//sysnb	socketpair(domain int, typ int, proto int, fd *[2]int32) (err error) = libsocket.socketpair
0000000000000000000000000000000000000000;;	//sys	write(fd int, p []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) = libsocket.getsockopt
0000000000000000000000000000000000000000;;	//sysnb	getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) = libsocket.getpeername
0000000000000000000000000000000000000000;;	//sys	setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) = libsocket.setsockopt
0000000000000000000000000000000000000000;;	//sys	recvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) = libsocket.recvfrom
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readlen(fd int, buf *byte, nbuf int) (n int, err error) {
0000000000000000000000000000000000000000;;		r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procread)), 3, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf), 0, 0, 0)
0000000000000000000000000000000000000000;;		n = int(r0)
0000000000000000000000000000000000000000;;		if e1 != 0 {
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writelen(fd int, buf *byte, nbuf int) (n int, err error) {
0000000000000000000000000000000000000000;;		r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procwrite)), 3, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf), 0, 0, 0)
0000000000000000000000000000000000000000;;		n = int(r0)
0000000000000000000000000000000000000000;;		if e1 != 0 {
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var mapper = &mmapper{
0000000000000000000000000000000000000000;;		active: make(map[*byte][]byte),
0000000000000000000000000000000000000000;;		mmap:   mmap,
0000000000000000000000000000000000000000;;		munmap: munmap,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error) {
0000000000000000000000000000000000000000;;		return mapper.Mmap(fd, offset, length, prot, flags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Munmap(b []byte) (err error) {
0000000000000000000000000000000000000000;;		return mapper.Munmap(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	sysconf(name int) (n int64, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pageSize caches the value of Getpagesize, since it can't change
0000000000000000000000000000000000000000;;	// once the system is booted.
0000000000000000000000000000000000000000;;	var pageSize int64 // accessed atomically
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getpagesize() int {
0000000000000000000000000000000000000000;;		n := atomic.LoadInt64(&pageSize)
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			n, _ = sysconf(_SC_PAGESIZE)
0000000000000000000000000000000000000000;;			atomic.StoreInt64(&pageSize, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(n)
0000000000000000000000000000000000000000;;	}
