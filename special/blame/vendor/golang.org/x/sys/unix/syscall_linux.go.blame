0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
12a86164cdbf8548dc1c57ea2633daf61c4daab0;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_linux.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/external/golang.org/x/sys/unix/syscall_linux.go][vendor/golang.org/x/sys/unix/syscall_linux.go];	
0000000000000000000000000000000000000000;;	// Linux system calls.
0000000000000000000000000000000000000000;;	// This file is compiled as ordinary Go code,
0000000000000000000000000000000000000000;;	// but it is also input to mksyscall,
0000000000000000000000000000000000000000;;	// which parses the //sys lines and generates system call stubs.
0000000000000000000000000000000000000000;;	// Note that sometimes we use a lowercase //sys name and
0000000000000000000000000000000000000000;;	// wrap it in our own nicer implementation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unix
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Wrapped
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Access(path string, mode uint32) (err error) {
0000000000000000000000000000000000000000;;		return Faccessat(AT_FDCWD, path, mode, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Chmod(path string, mode uint32) (err error) {
0000000000000000000000000000000000000000;;		return Fchmodat(AT_FDCWD, path, mode, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Chown(path string, uid int, gid int) (err error) {
0000000000000000000000000000000000000000;;		return Fchownat(AT_FDCWD, path, uid, gid, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Creat(path string, mode uint32) (fd int, err error) {
0000000000000000000000000000000000000000;;		return Open(path, O_CREAT|O_WRONLY|O_TRUNC, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Link(oldpath string, newpath string) (err error) {
0000000000000000000000000000000000000000;;		return Linkat(AT_FDCWD, oldpath, AT_FDCWD, newpath, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Mkdir(path string, mode uint32) (err error) {
0000000000000000000000000000000000000000;;		return Mkdirat(AT_FDCWD, path, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Mknod(path string, mode uint32, dev int) (err error) {
0000000000000000000000000000000000000000;;		return Mknodat(AT_FDCWD, path, mode, dev)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Open(path string, mode int, perm uint32) (fd int, err error) {
0000000000000000000000000000000000000000;;		return openat(AT_FDCWD, path, mode|O_LARGEFILE, perm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) {
0000000000000000000000000000000000000000;;		return openat(dirfd, path, flags|O_LARGEFILE, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Ppoll(fds []PollFd, timeout *Timespec, sigmask *Sigset_t) (n int, err error) {
0000000000000000000000000000000000000000;;		if len(fds) == 0 {
0000000000000000000000000000000000000000;;			return ppoll(nil, 0, timeout, sigmask)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ppoll(&fds[0], len(fds), timeout, sigmask)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	readlinkat(dirfd int, path string, buf []byte) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Readlink(path string, buf []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		return readlinkat(AT_FDCWD, path, buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Rename(oldpath string, newpath string) (err error) {
0000000000000000000000000000000000000000;;		return Renameat(AT_FDCWD, oldpath, AT_FDCWD, newpath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Rmdir(path string) error {
0000000000000000000000000000000000000000;;		return unlinkat(AT_FDCWD, path, AT_REMOVEDIR)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	symlinkat(oldpath string, newdirfd int, newpath string) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Symlink(oldpath string, newpath string) (err error) {
0000000000000000000000000000000000000000;;		return symlinkat(oldpath, AT_FDCWD, newpath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Unlink(path string) error {
0000000000000000000000000000000000000000;;		return unlinkat(AT_FDCWD, path, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	unlinkat(dirfd int, path string, flags int) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Unlinkat(dirfd int, path string, flags int) error {
0000000000000000000000000000000000000000;;		return unlinkat(dirfd, path, flags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	utimes(path string, times *[2]Timeval) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Utimes(path string, tv []Timeval) error {
0000000000000000000000000000000000000000;;		if tv == nil {
0000000000000000000000000000000000000000;;			err := utimensat(AT_FDCWD, path, nil, 0)
0000000000000000000000000000000000000000;;			if err != ENOSYS {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return utimes(path, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tv) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ts [2]Timespec
0000000000000000000000000000000000000000;;		ts[0] = NsecToTimespec(TimevalToNsec(tv[0]))
0000000000000000000000000000000000000000;;		ts[1] = NsecToTimespec(TimevalToNsec(tv[1]))
0000000000000000000000000000000000000000;;		err := utimensat(AT_FDCWD, path, (*[2]Timespec)(unsafe.Pointer(&ts[0])), 0)
0000000000000000000000000000000000000000;;		if err != ENOSYS {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	utimensat(dirfd int, path string, times *[2]Timespec, flags int) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UtimesNano(path string, ts []Timespec) error {
0000000000000000000000000000000000000000;;		if ts == nil {
0000000000000000000000000000000000000000;;			err := utimensat(AT_FDCWD, path, nil, 0)
0000000000000000000000000000000000000000;;			if err != ENOSYS {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return utimes(path, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ts) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := utimensat(AT_FDCWD, path, (*[2]Timespec)(unsafe.Pointer(&ts[0])), 0)
0000000000000000000000000000000000000000;;		if err != ENOSYS {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the utimensat syscall isn't available (utimensat was added to Linux
0000000000000000000000000000000000000000;;		// in 2.6.22, Released, 8 July 2007) then fall back to utimes
0000000000000000000000000000000000000000;;		var tv [2]Timeval
0000000000000000000000000000000000000000;;		for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;			tv[i].Sec = ts[i].Sec
0000000000000000000000000000000000000000;;			tv[i].Usec = ts[i].Nsec / 1000
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UtimesNanoAt(dirfd int, path string, ts []Timespec, flags int) error {
0000000000000000000000000000000000000000;;		if ts == nil {
0000000000000000000000000000000000000000;;			return utimensat(dirfd, path, nil, flags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ts) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utimensat(dirfd, path, (*[2]Timespec)(unsafe.Pointer(&ts[0])), flags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	futimesat(dirfd int, path *byte, times *[2]Timeval) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Futimesat(dirfd int, path string, tv []Timeval) error {
0000000000000000000000000000000000000000;;		pathp, err := BytePtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tv == nil {
0000000000000000000000000000000000000000;;			return futimesat(dirfd, pathp, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tv) != 2 {
0000000000000000000000000000000000000000;;			return EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return futimesat(dirfd, pathp, (*[2]Timeval)(unsafe.Pointer(&tv[0])))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Futimes(fd int, tv []Timeval) (err error) {
0000000000000000000000000000000000000000;;		// Believe it or not, this is the best we can do on Linux
0000000000000000000000000000000000000000;;		// (and is what glibc does).
0000000000000000000000000000000000000000;;		return Utimes("/proc/self/fd/"+itoa(fd), tv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const ImplementsGetwd = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	Getcwd(buf []byte) (n int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getwd() (wd string, err error) {
0000000000000000000000000000000000000000;;		var buf [PathMax]byte
0000000000000000000000000000000000000000;;		n, err := Getcwd(buf[0:])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Getcwd returns the number of bytes written to buf, including the NUL.
0000000000000000000000000000000000000000;;		if n < 1 || n > len(buf) || buf[n-1] != 0 {
0000000000000000000000000000000000000000;;			return "", EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf[0 : n-1]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getgroups() (gids []int, err error) {
0000000000000000000000000000000000000000;;		n, err := getgroups(0, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sanity check group count.  Max is 1<<16 on Linux.
0000000000000000000000000000000000000000;;		if n < 0 || n > 1<<20 {
0000000000000000000000000000000000000000;;			return nil, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := make([]_Gid_t, n)
0000000000000000000000000000000000000000;;		n, err = getgroups(n, &a[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gids = make([]int, n)
0000000000000000000000000000000000000000;;		for i, v := range a[0:n] {
0000000000000000000000000000000000000000;;			gids[i] = int(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Setgroups(gids []int) (err error) {
0000000000000000000000000000000000000000;;		if len(gids) == 0 {
0000000000000000000000000000000000000000;;			return setgroups(0, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := make([]_Gid_t, len(gids))
0000000000000000000000000000000000000000;;		for i, v := range gids {
0000000000000000000000000000000000000000;;			a[i] = _Gid_t(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return setgroups(len(a), &a[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WaitStatus uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait status is 7 bits at bottom, either 0 (exited),
0000000000000000000000000000000000000000;;	// 0x7F (stopped), or a signal number that caused an exit.
0000000000000000000000000000000000000000;;	// The 0x80 bit is whether there was a core dump.
0000000000000000000000000000000000000000;;	// An extra number (exit code, signal causing a stop)
0000000000000000000000000000000000000000;;	// is in the high bits.  At least that's the idea.
0000000000000000000000000000000000000000;;	// There are various irregularities.  For example, the
0000000000000000000000000000000000000000;;	// "continued" status is 0xFFFF, distinguishing itself
0000000000000000000000000000000000000000;;	// from stopped via the core dump bit.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		mask    = 0x7F
0000000000000000000000000000000000000000;;		core    = 0x80
0000000000000000000000000000000000000000;;		exited  = 0x00
0000000000000000000000000000000000000000;;		stopped = 0x7F
0000000000000000000000000000000000000000;;		shift   = 8
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Exited() bool { return w&mask == exited }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Signaled() bool { return w&mask != stopped && w&mask != exited }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Stopped() bool { return w&0xFF == stopped }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Continued() bool { return w == 0xFFFF }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) CoreDump() bool { return w.Signaled() && w&core != 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) ExitStatus() int {
0000000000000000000000000000000000000000;;		if !w.Exited() {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(w>>shift) & 0xFF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Signal() syscall.Signal {
0000000000000000000000000000000000000000;;		if !w.Signaled() {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Signal(w & mask)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) StopSignal() syscall.Signal {
0000000000000000000000000000000000000000;;		if !w.Stopped() {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Signal(w>>shift) & 0xFF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) TrapCause() int {
0000000000000000000000000000000000000000;;		if w.StopSignal() != SIGTRAP {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(w>>shift) >> 8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) {
0000000000000000000000000000000000000000;;		var status _C_int
0000000000000000000000000000000000000000;;		wpid, err = wait4(pid, &status, options, rusage)
0000000000000000000000000000000000000000;;		if wstatus != nil {
0000000000000000000000000000000000000000;;			*wstatus = WaitStatus(status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Mkfifo(path string, mode uint32) (err error) {
0000000000000000000000000000000000000000;;		return Mknod(path, mode|S_IFIFO, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		if sa.Port < 0 || sa.Port > 0xFFFF {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_INET
0000000000000000000000000000000000000000;;		p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
0000000000000000000000000000000000000000;;		p[0] = byte(sa.Port >> 8)
0000000000000000000000000000000000000000;;		p[1] = byte(sa.Port)
0000000000000000000000000000000000000000;;		for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;			sa.raw.Addr[i] = sa.Addr[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), SizeofSockaddrInet4, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		if sa.Port < 0 || sa.Port > 0xFFFF {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_INET6
0000000000000000000000000000000000000000;;		p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
0000000000000000000000000000000000000000;;		p[0] = byte(sa.Port >> 8)
0000000000000000000000000000000000000000;;		p[1] = byte(sa.Port)
0000000000000000000000000000000000000000;;		sa.raw.Scope_id = sa.ZoneId
0000000000000000000000000000000000000000;;		for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;			sa.raw.Addr[i] = sa.Addr[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), SizeofSockaddrInet6, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		name := sa.Name
0000000000000000000000000000000000000000;;		n := len(name)
0000000000000000000000000000000000000000;;		if n >= len(sa.raw.Path) {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_UNIX
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			sa.raw.Path[i] = int8(name[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// length is family (uint16), name, NUL.
0000000000000000000000000000000000000000;;		sl := _Socklen(2)
0000000000000000000000000000000000000000;;		if n > 0 {
0000000000000000000000000000000000000000;;			sl += _Socklen(n) + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sa.raw.Path[0] == '@' {
0000000000000000000000000000000000000000;;			sa.raw.Path[0] = 0
0000000000000000000000000000000000000000;;			// Don't count trailing NUL for abstract address.
0000000000000000000000000000000000000000;;			sl--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), sl, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrLinklayer struct {
0000000000000000000000000000000000000000;;		Protocol uint16
0000000000000000000000000000000000000000;;		Ifindex  int
0000000000000000000000000000000000000000;;		Hatype   uint16
0000000000000000000000000000000000000000;;		Pkttype  uint8
0000000000000000000000000000000000000000;;		Halen    uint8
0000000000000000000000000000000000000000;;		Addr     [8]byte
0000000000000000000000000000000000000000;;		raw      RawSockaddrLinklayer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrLinklayer) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		if sa.Ifindex < 0 || sa.Ifindex > 0x7fffffff {
0000000000000000000000000000000000000000;;			return nil, 0, EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_PACKET
0000000000000000000000000000000000000000;;		sa.raw.Protocol = sa.Protocol
0000000000000000000000000000000000000000;;		sa.raw.Ifindex = int32(sa.Ifindex)
0000000000000000000000000000000000000000;;		sa.raw.Hatype = sa.Hatype
0000000000000000000000000000000000000000;;		sa.raw.Pkttype = sa.Pkttype
0000000000000000000000000000000000000000;;		sa.raw.Halen = sa.Halen
0000000000000000000000000000000000000000;;		for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;			sa.raw.Addr[i] = sa.Addr[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), SizeofSockaddrLinklayer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrNetlink struct {
0000000000000000000000000000000000000000;;		Family uint16
0000000000000000000000000000000000000000;;		Pad    uint16
0000000000000000000000000000000000000000;;		Pid    uint32
0000000000000000000000000000000000000000;;		Groups uint32
0000000000000000000000000000000000000000;;		raw    RawSockaddrNetlink
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrNetlink) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_NETLINK
0000000000000000000000000000000000000000;;		sa.raw.Pad = sa.Pad
0000000000000000000000000000000000000000;;		sa.raw.Pid = sa.Pid
0000000000000000000000000000000000000000;;		sa.raw.Groups = sa.Groups
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), SizeofSockaddrNetlink, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrHCI struct {
0000000000000000000000000000000000000000;;		Dev     uint16
0000000000000000000000000000000000000000;;		Channel uint16
0000000000000000000000000000000000000000;;		raw     RawSockaddrHCI
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrHCI) sockaddr() (unsafe.Pointer, _Socklen, error) {
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_BLUETOOTH
0000000000000000000000000000000000000000;;		sa.raw.Dev = sa.Dev
0000000000000000000000000000000000000000;;		sa.raw.Channel = sa.Channel
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), SizeofSockaddrHCI, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, error) {
0000000000000000000000000000000000000000;;		switch rsa.Addr.Family {
0000000000000000000000000000000000000000;;		case AF_NETLINK:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrNetlink)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrNetlink)
0000000000000000000000000000000000000000;;			sa.Family = pp.Family
0000000000000000000000000000000000000000;;			sa.Pad = pp.Pad
0000000000000000000000000000000000000000;;			sa.Pid = pp.Pid
0000000000000000000000000000000000000000;;			sa.Groups = pp.Groups
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_PACKET:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrLinklayer)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrLinklayer)
0000000000000000000000000000000000000000;;			sa.Protocol = pp.Protocol
0000000000000000000000000000000000000000;;			sa.Ifindex = int(pp.Ifindex)
0000000000000000000000000000000000000000;;			sa.Hatype = pp.Hatype
0000000000000000000000000000000000000000;;			sa.Pkttype = pp.Pkttype
0000000000000000000000000000000000000000;;			sa.Halen = pp.Halen
0000000000000000000000000000000000000000;;			for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;				sa.Addr[i] = pp.Addr[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_UNIX:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrUnix)
0000000000000000000000000000000000000000;;			if pp.Path[0] == 0 {
0000000000000000000000000000000000000000;;				// "Abstract" Unix domain socket.
0000000000000000000000000000000000000000;;				// Rewrite leading NUL as @ for textual display.
0000000000000000000000000000000000000000;;				// (This is the standard convention.)
0000000000000000000000000000000000000000;;				// Not friendly to overwrite in place,
0000000000000000000000000000000000000000;;				// but the callers below don't care.
0000000000000000000000000000000000000000;;				pp.Path[0] = '@'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Assume path ends at NUL.
0000000000000000000000000000000000000000;;			// This is not technically the Linux semantics for
0000000000000000000000000000000000000000;;			// abstract Unix domain sockets--they are supposed
0000000000000000000000000000000000000000;;			// to be uninterpreted fixed-size binary blobs--but
0000000000000000000000000000000000000000;;			// everyone uses this convention.
0000000000000000000000000000000000000000;;			n := 0
0000000000000000000000000000000000000000;;			for n < len(pp.Path) && pp.Path[n] != 0 {
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bytes := (*[10000]byte)(unsafe.Pointer(&pp.Path[0]))[0:n]
0000000000000000000000000000000000000000;;			sa.Name = string(bytes)
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_INET:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrInet4)
0000000000000000000000000000000000000000;;			p := (*[2]byte)(unsafe.Pointer(&pp.Port))
0000000000000000000000000000000000000000;;			sa.Port = int(p[0])<<8 + int(p[1])
0000000000000000000000000000000000000000;;			for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;				sa.Addr[i] = pp.Addr[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_INET6:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrInet6)
0000000000000000000000000000000000000000;;			p := (*[2]byte)(unsafe.Pointer(&pp.Port))
0000000000000000000000000000000000000000;;			sa.Port = int(p[0])<<8 + int(p[1])
0000000000000000000000000000000000000000;;			sa.ZoneId = pp.Scope_id
0000000000000000000000000000000000000000;;			for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;				sa.Addr[i] = pp.Addr[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, EAFNOSUPPORT
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Accept(fd int) (nfd int, sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		var len _Socklen = SizeofSockaddrAny
0000000000000000000000000000000000000000;;		nfd, err = accept(fd, &rsa, &len)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa, err = anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Close(nfd)
0000000000000000000000000000000000000000;;			nfd = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		var len _Socklen = SizeofSockaddrAny
0000000000000000000000000000000000000000;;		nfd, err = accept4(fd, &rsa, &len, flags)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len > SizeofSockaddrAny {
0000000000000000000000000000000000000000;;			panic("RawSockaddrAny too small")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa, err = anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			Close(nfd)
0000000000000000000000000000000000000000;;			nfd = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getsockname(fd int) (sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		var len _Socklen = SizeofSockaddrAny
0000000000000000000000000000000000000000;;		if err = getsockname(fd, &rsa, &len); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, err error) {
0000000000000000000000000000000000000000;;		vallen := _Socklen(4)
0000000000000000000000000000000000000000;;		err = getsockopt(fd, level, opt, unsafe.Pointer(&value[0]), &vallen)
0000000000000000000000000000000000000000;;		return value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error) {
0000000000000000000000000000000000000000;;		var value IPMreq
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofIPMreq)
0000000000000000000000000000000000000000;;		err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error) {
0000000000000000000000000000000000000000;;		var value IPMreqn
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofIPMreqn)
0000000000000000000000000000000000000000;;		err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error) {
0000000000000000000000000000000000000000;;		var value IPv6Mreq
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofIPv6Mreq)
0000000000000000000000000000000000000000;;		err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptIPv6MTUInfo(fd, level, opt int) (*IPv6MTUInfo, error) {
0000000000000000000000000000000000000000;;		var value IPv6MTUInfo
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofIPv6MTUInfo)
0000000000000000000000000000000000000000;;		err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptICMPv6Filter(fd, level, opt int) (*ICMPv6Filter, error) {
0000000000000000000000000000000000000000;;		var value ICMPv6Filter
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofICMPv6Filter)
0000000000000000000000000000000000000000;;		err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptUcred(fd, level, opt int) (*Ucred, error) {
0000000000000000000000000000000000000000;;		var value Ucred
0000000000000000000000000000000000000000;;		vallen := _Socklen(SizeofUcred)
0000000000000000000000000000000000000000;;		err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)
0000000000000000000000000000000000000000;;		return &value, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error) {
0000000000000000000000000000000000000000;;		return setsockopt(fd, level, opt, unsafe.Pointer(mreq), unsafe.Sizeof(*mreq))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var msg Msghdr
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		msg.Name = (*byte)(unsafe.Pointer(&rsa))
0000000000000000000000000000000000000000;;		msg.Namelen = uint32(SizeofSockaddrAny)
0000000000000000000000000000000000000000;;		var iov Iovec
0000000000000000000000000000000000000000;;		if len(p) > 0 {
0000000000000000000000000000000000000000;;			iov.Base = (*byte)(unsafe.Pointer(&p[0]))
0000000000000000000000000000000000000000;;			iov.SetLen(len(p))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var dummy byte
0000000000000000000000000000000000000000;;		if len(oob) > 0 {
0000000000000000000000000000000000000000;;			// receive at least one normal byte
0000000000000000000000000000000000000000;;			if len(p) == 0 {
0000000000000000000000000000000000000000;;				iov.Base = &dummy
0000000000000000000000000000000000000000;;				iov.SetLen(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg.Control = (*byte)(unsafe.Pointer(&oob[0]))
0000000000000000000000000000000000000000;;			msg.SetControllen(len(oob))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Iov = &iov
0000000000000000000000000000000000000000;;		msg.Iovlen = 1
0000000000000000000000000000000000000000;;		if n, err = recvmsg(fd, &msg, flags); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oobn = int(msg.Controllen)
0000000000000000000000000000000000000000;;		recvflags = int(msg.Flags)
0000000000000000000000000000000000000000;;		// source address is only specified if the socket is unconnected
0000000000000000000000000000000000000000;;		if rsa.Addr.Family != AF_UNSPEC {
0000000000000000000000000000000000000000;;			from, err = anyToSockaddr(&rsa)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (err error) {
0000000000000000000000000000000000000000;;		_, err = SendmsgN(fd, p, oob, to, flags)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SendmsgN(fd int, p, oob []byte, to Sockaddr, flags int) (n int, err error) {
0000000000000000000000000000000000000000;;		var ptr unsafe.Pointer
0000000000000000000000000000000000000000;;		var salen _Socklen
0000000000000000000000000000000000000000;;		if to != nil {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			ptr, salen, err = to.sockaddr()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var msg Msghdr
0000000000000000000000000000000000000000;;		msg.Name = (*byte)(unsafe.Pointer(ptr))
0000000000000000000000000000000000000000;;		msg.Namelen = uint32(salen)
0000000000000000000000000000000000000000;;		var iov Iovec
0000000000000000000000000000000000000000;;		if len(p) > 0 {
0000000000000000000000000000000000000000;;			iov.Base = (*byte)(unsafe.Pointer(&p[0]))
0000000000000000000000000000000000000000;;			iov.SetLen(len(p))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var dummy byte
0000000000000000000000000000000000000000;;		if len(oob) > 0 {
0000000000000000000000000000000000000000;;			// send at least one normal byte
0000000000000000000000000000000000000000;;			if len(p) == 0 {
0000000000000000000000000000000000000000;;				iov.Base = &dummy
0000000000000000000000000000000000000000;;				iov.SetLen(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg.Control = (*byte)(unsafe.Pointer(&oob[0]))
0000000000000000000000000000000000000000;;			msg.SetControllen(len(oob))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Iov = &iov
0000000000000000000000000000000000000000;;		msg.Iovlen = 1
0000000000000000000000000000000000000000;;		if n, err = sendmsg(fd, &msg, flags); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(oob) > 0 && len(p) == 0 {
0000000000000000000000000000000000000000;;			n = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BindToDevice binds the socket associated with fd to device.
0000000000000000000000000000000000000000;;	func BindToDevice(fd int, device string) (err error) {
0000000000000000000000000000000000000000;;		return SetsockoptString(fd, SOL_SOCKET, SO_BINDTODEVICE, device)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	ptrace(request int, pid int, addr uintptr, data uintptr) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, err error) {
0000000000000000000000000000000000000000;;		// The peek requests are machine-size oriented, so we wrap it
0000000000000000000000000000000000000000;;		// to retrieve arbitrary-length data.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The ptrace syscall differs from glibc's ptrace.
0000000000000000000000000000000000000000;;		// Peeks returns the word in *data, not as the return value.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buf [sizeofPtr]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Leading edge.  PEEKTEXT/PEEKDATA don't require aligned
0000000000000000000000000000000000000000;;		// access (PEEKUSER warns that it might), but if we don't
0000000000000000000000000000000000000000;;		// align our reads, we might straddle an unmapped page
0000000000000000000000000000000000000000;;		// boundary and not get the bytes leading up to the page
0000000000000000000000000000000000000000;;		// boundary.
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		if addr%sizeofPtr != 0 {
0000000000000000000000000000000000000000;;			err = ptrace(req, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += copy(out, buf[addr%sizeofPtr:])
0000000000000000000000000000000000000000;;			out = out[n:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remainder.
0000000000000000000000000000000000000000;;		for len(out) > 0 {
0000000000000000000000000000000000000000;;			// We use an internal buffer to guarantee alignment.
0000000000000000000000000000000000000000;;			// It's not documented if this is necessary, but we're paranoid.
0000000000000000000000000000000000000000;;			err = ptrace(req, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copied := copy(out, buf[0:])
0000000000000000000000000000000000000000;;			n += copied
0000000000000000000000000000000000000000;;			out = out[copied:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtracePeekText(pid int, addr uintptr, out []byte) (count int, err error) {
0000000000000000000000000000000000000000;;		return ptracePeek(PTRACE_PEEKTEXT, pid, addr, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtracePeekData(pid int, addr uintptr, out []byte) (count int, err error) {
0000000000000000000000000000000000000000;;		return ptracePeek(PTRACE_PEEKDATA, pid, addr, out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (count int, err error) {
0000000000000000000000000000000000000000;;		// As for ptracePeek, we need to align our accesses to deal
0000000000000000000000000000000000000000;;		// with the possibility of straddling an invalid page.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Leading edge.
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		if addr%sizeofPtr != 0 {
0000000000000000000000000000000000000000;;			var buf [sizeofPtr]byte
0000000000000000000000000000000000000000;;			err = ptrace(peekReq, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += copy(buf[addr%sizeofPtr:], data)
0000000000000000000000000000000000000000;;			word := *((*uintptr)(unsafe.Pointer(&buf[0])))
0000000000000000000000000000000000000000;;			err = ptrace(pokeReq, pid, addr-addr%sizeofPtr, word)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data = data[n:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Interior.
0000000000000000000000000000000000000000;;		for len(data) > sizeofPtr {
0000000000000000000000000000000000000000;;			word := *((*uintptr)(unsafe.Pointer(&data[0])))
0000000000000000000000000000000000000000;;			err = ptrace(pokeReq, pid, addr+uintptr(n), word)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += sizeofPtr
0000000000000000000000000000000000000000;;			data = data[sizeofPtr:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Trailing edge.
0000000000000000000000000000000000000000;;		if len(data) > 0 {
0000000000000000000000000000000000000000;;			var buf [sizeofPtr]byte
0000000000000000000000000000000000000000;;			err = ptrace(peekReq, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy(buf[0:], data)
0000000000000000000000000000000000000000;;			word := *((*uintptr)(unsafe.Pointer(&buf[0])))
0000000000000000000000000000000000000000;;			err = ptrace(pokeReq, pid, addr+uintptr(n), word)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += len(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtracePokeText(pid int, addr uintptr, data []byte) (count int, err error) {
0000000000000000000000000000000000000000;;		return ptracePoke(PTRACE_POKETEXT, PTRACE_PEEKTEXT, pid, addr, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtracePokeData(pid int, addr uintptr, data []byte) (count int, err error) {
0000000000000000000000000000000000000000;;		return ptracePoke(PTRACE_POKEDATA, PTRACE_PEEKDATA, pid, addr, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error) {
0000000000000000000000000000000000000000;;		return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtraceSetRegs(pid int, regs *PtraceRegs) (err error) {
0000000000000000000000000000000000000000;;		return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtraceSetOptions(pid int, options int) (err error) {
0000000000000000000000000000000000000000;;		return ptrace(PTRACE_SETOPTIONS, pid, 0, uintptr(options))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtraceGetEventMsg(pid int) (msg uint, err error) {
0000000000000000000000000000000000000000;;		var data _C_long
0000000000000000000000000000000000000000;;		err = ptrace(PTRACE_GETEVENTMSG, pid, 0, uintptr(unsafe.Pointer(&data)))
0000000000000000000000000000000000000000;;		msg = uint(data)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtraceCont(pid int, signal int) (err error) {
0000000000000000000000000000000000000000;;		return ptrace(PTRACE_CONT, pid, 0, uintptr(signal))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtraceSyscall(pid int, signal int) (err error) {
0000000000000000000000000000000000000000;;		return ptrace(PTRACE_SYSCALL, pid, 0, uintptr(signal))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtraceSingleStep(pid int) (err error) { return ptrace(PTRACE_SINGLESTEP, pid, 0, 0) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtraceAttach(pid int) (err error) { return ptrace(PTRACE_ATTACH, pid, 0, 0) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PtraceDetach(pid int) (err error) { return ptrace(PTRACE_DETACH, pid, 0, 0) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Reboot(cmd int) (err error) {
0000000000000000000000000000000000000000;;		return reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, cmd, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func clen(n []byte) int {
0000000000000000000000000000000000000000;;		for i := 0; i < len(n); i++ {
0000000000000000000000000000000000000000;;			if n[i] == 0 {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ReadDirent(fd int, buf []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		return Getdents(fd, buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParseDirent(buf []byte, max int, names []string) (consumed int, count int, newnames []string) {
0000000000000000000000000000000000000000;;		origlen := len(buf)
0000000000000000000000000000000000000000;;		count = 0
0000000000000000000000000000000000000000;;		for max != 0 && len(buf) > 0 {
0000000000000000000000000000000000000000;;			dirent := (*Dirent)(unsafe.Pointer(&buf[0]))
0000000000000000000000000000000000000000;;			buf = buf[dirent.Reclen:]
0000000000000000000000000000000000000000;;			if dirent.Ino == 0 { // File absent in directory.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bytes := (*[10000]byte)(unsafe.Pointer(&dirent.Name[0]))
0000000000000000000000000000000000000000;;			var name = string(bytes[0:clen(bytes[:])])
0000000000000000000000000000000000000000;;			if name == "." || name == ".." { // Useless names
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			max--
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			names = append(names, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return origlen - len(buf), count, names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	mount(source string, target string, fstype string, flags uintptr, data *byte) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Mount(source string, target string, fstype string, flags uintptr, data string) (err error) {
0000000000000000000000000000000000000000;;		// Certain file systems get rather angry and EINVAL if you give
0000000000000000000000000000000000000000;;		// them an empty string of data, rather than NULL.
0000000000000000000000000000000000000000;;		if data == "" {
0000000000000000000000000000000000000000;;			return mount(source, target, fstype, flags, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		datap, err := BytePtrFromString(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mount(source, target, fstype, flags, datap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sendto
0000000000000000000000000000000000000000;;	// Recvfrom
0000000000000000000000000000000000000000;;	// Socketpair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Direct access
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	//sys	Acct(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Adjtimex(buf *Timex) (state int, err error)
0000000000000000000000000000000000000000;;	//sys	Chdir(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	Chroot(path string) (err error)
0000000000000000000000000000000000000000;;	//sys	ClockGettime(clockid int32, time *Timespec) (err error)
0000000000000000000000000000000000000000;;	//sys	Close(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Dup(oldfd int) (fd int, err error)
0000000000000000000000000000000000000000;;	//sys	Dup3(oldfd int, newfd int, flags int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	EpollCreate(size int) (fd int, err error)
0000000000000000000000000000000000000000;;	//sysnb	EpollCreate1(flag int) (fd int, err error)
0000000000000000000000000000000000000000;;	//sysnb	EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)
0000000000000000000000000000000000000000;;	//sys	Exit(code int) = SYS_EXIT_GROUP
0000000000000000000000000000000000000000;;	//sys	Faccessat(dirfd int, path string, mode uint32, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fallocate(fd int, mode uint32, off int64, len int64) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchdir(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchmod(fd int, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	fcntl(fd int, cmd int, arg int) (val int, err error)
0000000000000000000000000000000000000000;;	//sys	Fdatasync(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Flock(fd int, how int) (err error)
0000000000000000000000000000000000000000;;	//sys	Fsync(fd int) (err error)
0000000000000000000000000000000000000000;;	//sys	Getdents(fd int, buf []byte) (n int, err error) = SYS_GETDENTS64
0000000000000000000000000000000000000000;;	//sysnb	Getpgid(pid int) (pgid int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getpgrp() (pid int) {
0000000000000000000000000000000000000000;;		pid, _ = Getpgid(0)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sysnb	Getpid() (pid int)
0000000000000000000000000000000000000000;;	//sysnb	Getppid() (ppid int)
0000000000000000000000000000000000000000;;	//sys	Getpriority(which int, who int) (prio int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Getrusage(who int, rusage *Rusage) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Gettid() (tid int)
0000000000000000000000000000000000000000;;	//sys	Getxattr(path string, attr string, dest []byte) (sz int, err error)
0000000000000000000000000000000000000000;;	//sys	InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)
0000000000000000000000000000000000000000;;	//sysnb	InotifyInit1(flags int) (fd int, err error)
0000000000000000000000000000000000000000;;	//sysnb	InotifyRmWatch(fd int, watchdesc uint32) (success int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Kill(pid int, sig syscall.Signal) (err error)
0000000000000000000000000000000000000000;;	//sys	Klogctl(typ int, buf []byte) (n int, err error) = SYS_SYSLOG
0000000000000000000000000000000000000000;;	//sys	Listxattr(path string, dest []byte) (sz int, err error)
0000000000000000000000000000000000000000;;	//sys	Mkdirat(dirfd int, path string, mode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	Mknodat(dirfd int, path string, mode uint32, dev int) (err error)
0000000000000000000000000000000000000000;;	//sys	Nanosleep(time *Timespec, leftover *Timespec) (err error)
0000000000000000000000000000000000000000;;	//sys	PivotRoot(newroot string, putold string) (err error) = SYS_PIVOT_ROOT
0000000000000000000000000000000000000000;;	//sysnb prlimit(pid int, resource int, old *Rlimit, newlimit *Rlimit) (err error) = SYS_PRLIMIT64
0000000000000000000000000000000000000000;;	//sys   Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error)
0000000000000000000000000000000000000000;;	//sys	read(fd int, p []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	Removexattr(path string, attr string) (err error)
0000000000000000000000000000000000000000;;	//sys	Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)
0000000000000000000000000000000000000000;;	//sys	Setdomainname(p []byte) (err error)
0000000000000000000000000000000000000000;;	//sys	Sethostname(p []byte) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setpgid(pid int, pgid int) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Setsid() (pid int, err error)
0000000000000000000000000000000000000000;;	//sysnb	Settimeofday(tv *Timeval) (err error)
0000000000000000000000000000000000000000;;	//sys	Setns(fd int, nstype int) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// issue 1435.
0000000000000000000000000000000000000000;;	// On linux Setuid and Setgid only affects the current thread, not the process.
0000000000000000000000000000000000000000;;	// This does not match what most callers expect so we must return an error
0000000000000000000000000000000000000000;;	// here rather than letting the caller think that the call succeeded.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Setuid(uid int) (err error) {
0000000000000000000000000000000000000000;;		return EOPNOTSUPP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Setgid(uid int) (err error) {
0000000000000000000000000000000000000000;;		return EOPNOTSUPP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	Setpriority(which int, who int, prio int) (err error)
0000000000000000000000000000000000000000;;	//sys	Setxattr(path string, attr string, data []byte, flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Sync()
0000000000000000000000000000000000000000;;	//sysnb	Sysinfo(info *Sysinfo_t) (err error)
0000000000000000000000000000000000000000;;	//sys	Tee(rfd int, wfd int, len int, flags int) (n int64, err error)
0000000000000000000000000000000000000000;;	//sysnb	Tgkill(tgid int, tid int, sig syscall.Signal) (err error)
0000000000000000000000000000000000000000;;	//sysnb	Times(tms *Tms) (ticks uintptr, err error)
0000000000000000000000000000000000000000;;	//sysnb	Umask(mask int) (oldmask int)
0000000000000000000000000000000000000000;;	//sysnb	Uname(buf *Utsname) (err error)
0000000000000000000000000000000000000000;;	//sys	Unmount(target string, flags int) (err error) = SYS_UMOUNT2
0000000000000000000000000000000000000000;;	//sys	Unshare(flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Ustat(dev int, ubuf *Ustat_t) (err error)
0000000000000000000000000000000000000000;;	//sys	write(fd int, p []byte) (n int, err error)
0000000000000000000000000000000000000000;;	//sys	exitThread(code int) (err error) = SYS_EXIT
0000000000000000000000000000000000000000;;	//sys	readlen(fd int, p *byte, np int) (n int, err error) = SYS_READ
0000000000000000000000000000000000000000;;	//sys	writelen(fd int, p *byte, np int) (n int, err error) = SYS_WRITE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mmap varies by architecture; see syscall_linux_*.go.
0000000000000000000000000000000000000000;;	//sys	munmap(addr uintptr, length uintptr) (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var mapper = &mmapper{
0000000000000000000000000000000000000000;;		active: make(map[*byte][]byte),
0000000000000000000000000000000000000000;;		mmap:   mmap,
0000000000000000000000000000000000000000;;		munmap: munmap,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error) {
0000000000000000000000000000000000000000;;		return mapper.Mmap(fd, offset, length, prot, flags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Munmap(b []byte) (err error) {
0000000000000000000000000000000000000000;;		return mapper.Munmap(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	Madvise(b []byte, advice int) (err error)
0000000000000000000000000000000000000000;;	//sys	Mprotect(b []byte, prot int) (err error)
0000000000000000000000000000000000000000;;	//sys	Mlock(b []byte) (err error)
0000000000000000000000000000000000000000;;	//sys	Munlock(b []byte) (err error)
0000000000000000000000000000000000000000;;	//sys	Mlockall(flags int) (err error)
0000000000000000000000000000000000000000;;	//sys	Munlockall() (err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Unimplemented
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	// AddKey
0000000000000000000000000000000000000000;;	// AfsSyscall
0000000000000000000000000000000000000000;;	// Alarm
0000000000000000000000000000000000000000;;	// ArchPrctl
0000000000000000000000000000000000000000;;	// Brk
0000000000000000000000000000000000000000;;	// Capget
0000000000000000000000000000000000000000;;	// Capset
0000000000000000000000000000000000000000;;	// ClockGetres
0000000000000000000000000000000000000000;;	// ClockNanosleep
0000000000000000000000000000000000000000;;	// ClockSettime
0000000000000000000000000000000000000000;;	// Clone
0000000000000000000000000000000000000000;;	// CreateModule
0000000000000000000000000000000000000000;;	// DeleteModule
0000000000000000000000000000000000000000;;	// EpollCtlOld
0000000000000000000000000000000000000000;;	// EpollPwait
0000000000000000000000000000000000000000;;	// EpollWaitOld
0000000000000000000000000000000000000000;;	// Eventfd
0000000000000000000000000000000000000000;;	// Execve
0000000000000000000000000000000000000000;;	// Fgetxattr
0000000000000000000000000000000000000000;;	// Flistxattr
0000000000000000000000000000000000000000;;	// Fork
0000000000000000000000000000000000000000;;	// Fremovexattr
0000000000000000000000000000000000000000;;	// Fsetxattr
0000000000000000000000000000000000000000;;	// Futex
0000000000000000000000000000000000000000;;	// GetKernelSyms
0000000000000000000000000000000000000000;;	// GetMempolicy
0000000000000000000000000000000000000000;;	// GetRobustList
0000000000000000000000000000000000000000;;	// GetThreadArea
0000000000000000000000000000000000000000;;	// Getitimer
0000000000000000000000000000000000000000;;	// Getpmsg
0000000000000000000000000000000000000000;;	// IoCancel
0000000000000000000000000000000000000000;;	// IoDestroy
0000000000000000000000000000000000000000;;	// IoGetevents
0000000000000000000000000000000000000000;;	// IoSetup
0000000000000000000000000000000000000000;;	// IoSubmit
0000000000000000000000000000000000000000;;	// Ioctl
0000000000000000000000000000000000000000;;	// IoprioGet
0000000000000000000000000000000000000000;;	// IoprioSet
0000000000000000000000000000000000000000;;	// KexecLoad
0000000000000000000000000000000000000000;;	// Keyctl
0000000000000000000000000000000000000000;;	// Lgetxattr
0000000000000000000000000000000000000000;;	// Llistxattr
0000000000000000000000000000000000000000;;	// LookupDcookie
0000000000000000000000000000000000000000;;	// Lremovexattr
0000000000000000000000000000000000000000;;	// Lsetxattr
0000000000000000000000000000000000000000;;	// Mbind
0000000000000000000000000000000000000000;;	// MigratePages
0000000000000000000000000000000000000000;;	// Mincore
0000000000000000000000000000000000000000;;	// ModifyLdt
0000000000000000000000000000000000000000;;	// Mount
0000000000000000000000000000000000000000;;	// MovePages
0000000000000000000000000000000000000000;;	// Mprotect
0000000000000000000000000000000000000000;;	// MqGetsetattr
0000000000000000000000000000000000000000;;	// MqNotify
0000000000000000000000000000000000000000;;	// MqOpen
0000000000000000000000000000000000000000;;	// MqTimedreceive
0000000000000000000000000000000000000000;;	// MqTimedsend
0000000000000000000000000000000000000000;;	// MqUnlink
0000000000000000000000000000000000000000;;	// Mremap
0000000000000000000000000000000000000000;;	// Msgctl
0000000000000000000000000000000000000000;;	// Msgget
0000000000000000000000000000000000000000;;	// Msgrcv
0000000000000000000000000000000000000000;;	// Msgsnd
0000000000000000000000000000000000000000;;	// Msync
0000000000000000000000000000000000000000;;	// Newfstatat
0000000000000000000000000000000000000000;;	// Nfsservctl
0000000000000000000000000000000000000000;;	// Personality
0000000000000000000000000000000000000000;;	// Pselect6
0000000000000000000000000000000000000000;;	// Ptrace
0000000000000000000000000000000000000000;;	// Putpmsg
0000000000000000000000000000000000000000;;	// QueryModule
0000000000000000000000000000000000000000;;	// Quotactl
0000000000000000000000000000000000000000;;	// Readahead
0000000000000000000000000000000000000000;;	// Readv
0000000000000000000000000000000000000000;;	// RemapFilePages
0000000000000000000000000000000000000000;;	// RequestKey
0000000000000000000000000000000000000000;;	// RestartSyscall
0000000000000000000000000000000000000000;;	// RtSigaction
0000000000000000000000000000000000000000;;	// RtSigpending
0000000000000000000000000000000000000000;;	// RtSigprocmask
0000000000000000000000000000000000000000;;	// RtSigqueueinfo
0000000000000000000000000000000000000000;;	// RtSigreturn
0000000000000000000000000000000000000000;;	// RtSigsuspend
0000000000000000000000000000000000000000;;	// RtSigtimedwait
0000000000000000000000000000000000000000;;	// SchedGetPriorityMax
0000000000000000000000000000000000000000;;	// SchedGetPriorityMin
0000000000000000000000000000000000000000;;	// SchedGetaffinity
0000000000000000000000000000000000000000;;	// SchedGetparam
0000000000000000000000000000000000000000;;	// SchedGetscheduler
0000000000000000000000000000000000000000;;	// SchedRrGetInterval
0000000000000000000000000000000000000000;;	// SchedSetaffinity
0000000000000000000000000000000000000000;;	// SchedSetparam
0000000000000000000000000000000000000000;;	// SchedYield
0000000000000000000000000000000000000000;;	// Security
0000000000000000000000000000000000000000;;	// Semctl
0000000000000000000000000000000000000000;;	// Semget
0000000000000000000000000000000000000000;;	// Semop
0000000000000000000000000000000000000000;;	// Semtimedop
0000000000000000000000000000000000000000;;	// SetMempolicy
0000000000000000000000000000000000000000;;	// SetRobustList
0000000000000000000000000000000000000000;;	// SetThreadArea
0000000000000000000000000000000000000000;;	// SetTidAddress
0000000000000000000000000000000000000000;;	// Shmat
0000000000000000000000000000000000000000;;	// Shmctl
0000000000000000000000000000000000000000;;	// Shmdt
0000000000000000000000000000000000000000;;	// Shmget
0000000000000000000000000000000000000000;;	// Sigaltstack
0000000000000000000000000000000000000000;;	// Signalfd
0000000000000000000000000000000000000000;;	// Swapoff
0000000000000000000000000000000000000000;;	// Swapon
0000000000000000000000000000000000000000;;	// Sysfs
0000000000000000000000000000000000000000;;	// TimerCreate
0000000000000000000000000000000000000000;;	// TimerDelete
0000000000000000000000000000000000000000;;	// TimerGetoverrun
0000000000000000000000000000000000000000;;	// TimerGettime
0000000000000000000000000000000000000000;;	// TimerSettime
0000000000000000000000000000000000000000;;	// Timerfd
0000000000000000000000000000000000000000;;	// Tkill (obsolete)
0000000000000000000000000000000000000000;;	// Tuxcall
0000000000000000000000000000000000000000;;	// Umount2
0000000000000000000000000000000000000000;;	// Uselib
0000000000000000000000000000000000000000;;	// Utimensat
0000000000000000000000000000000000000000;;	// Vfork
0000000000000000000000000000000000000000;;	// Vhangup
0000000000000000000000000000000000000000;;	// Vmsplice
0000000000000000000000000000000000000000;;	// Vserver
0000000000000000000000000000000000000000;;	// Waitid
0000000000000000000000000000000000000000;;	// _Sysctl
