0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
372f1bceb3e2da05404dc30071e64aebe6b55b42;;	
0000000000000000000000000000000000000000;;	// Windows system calls.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package windows
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		errorspkg "errors"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unicode/utf16"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Handle uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const InvalidHandle = ^Handle(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringToUTF16 is deprecated. Use UTF16FromString instead.
0000000000000000000000000000000000000000;;	// If s contains a NUL byte this function panics instead of
0000000000000000000000000000000000000000;;	// returning an error.
0000000000000000000000000000000000000000;;	func StringToUTF16(s string) []uint16 {
0000000000000000000000000000000000000000;;		a, err := UTF16FromString(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("windows: string with NUL passed to StringToUTF16")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UTF16FromString returns the UTF-16 encoding of the UTF-8 string
0000000000000000000000000000000000000000;;	// s, with a terminating NUL added. If s contains a NUL byte at any
0000000000000000000000000000000000000000;;	// location, it returns (nil, syscall.EINVAL).
0000000000000000000000000000000000000000;;	func UTF16FromString(s string) ([]uint16, error) {
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			if s[i] == 0 {
0000000000000000000000000000000000000000;;				return nil, syscall.EINVAL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utf16.Encode([]rune(s + "\x00")), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UTF16ToString returns the UTF-8 encoding of the UTF-16 sequence s,
0000000000000000000000000000000000000000;;	// with a terminating NUL removed.
0000000000000000000000000000000000000000;;	func UTF16ToString(s []uint16) string {
0000000000000000000000000000000000000000;;		for i, v := range s {
0000000000000000000000000000000000000000;;			if v == 0 {
0000000000000000000000000000000000000000;;				s = s[0:i]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(utf16.Decode(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringToUTF16Ptr is deprecated. Use UTF16PtrFromString instead.
0000000000000000000000000000000000000000;;	// If s contains a NUL byte this function panics instead of
0000000000000000000000000000000000000000;;	// returning an error.
0000000000000000000000000000000000000000;;	func StringToUTF16Ptr(s string) *uint16 { return &StringToUTF16(s)[0] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UTF16PtrFromString returns pointer to the UTF-16 encoding of
0000000000000000000000000000000000000000;;	// the UTF-8 string s, with a terminating NUL added. If s
0000000000000000000000000000000000000000;;	// contains a NUL byte at any location, it returns (nil, syscall.EINVAL).
0000000000000000000000000000000000000000;;	func UTF16PtrFromString(s string) (*uint16, error) {
0000000000000000000000000000000000000000;;		a, err := UTF16FromString(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &a[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getpagesize() int { return 4096 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converts a Go function to a function pointer conforming
0000000000000000000000000000000000000000;;	// to the stdcall or cdecl calling convention.  This is useful when
0000000000000000000000000000000000000000;;	// interoperating with Windows code requiring callbacks.
0000000000000000000000000000000000000000;;	// Implemented in runtime/syscall_windows.goc
0000000000000000000000000000000000000000;;	func NewCallback(fn interface{}) uintptr
0000000000000000000000000000000000000000;;	func NewCallbackCDecl(fn interface{}) uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// windows api calls
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	GetLastError() (lasterr error)
0000000000000000000000000000000000000000;;	//sys	LoadLibrary(libname string) (handle Handle, err error) = LoadLibraryW
0000000000000000000000000000000000000000;;	//sys	LoadLibraryEx(libname string, zero Handle, flags uintptr) (handle Handle, err error) = LoadLibraryExW
0000000000000000000000000000000000000000;;	//sys	FreeLibrary(handle Handle) (err error)
0000000000000000000000000000000000000000;;	//sys	GetProcAddress(module Handle, procname string) (proc uintptr, err error)
0000000000000000000000000000000000000000;;	//sys	GetVersion() (ver uint32, err error)
0000000000000000000000000000000000000000;;	//sys	FormatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, err error) = FormatMessageW
0000000000000000000000000000000000000000;;	//sys	ExitProcess(exitcode uint32)
0000000000000000000000000000000000000000;;	//sys	CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle Handle, err error) [failretval==InvalidHandle] = CreateFileW
0000000000000000000000000000000000000000;;	//sys	ReadFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error)
0000000000000000000000000000000000000000;;	//sys	WriteFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error)
0000000000000000000000000000000000000000;;	//sys	SetFilePointer(handle Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error) [failretval==0xffffffff]
0000000000000000000000000000000000000000;;	//sys	CloseHandle(handle Handle) (err error)
0000000000000000000000000000000000000000;;	//sys	GetStdHandle(stdhandle int) (handle Handle, err error) [failretval==InvalidHandle]
0000000000000000000000000000000000000000;;	//sys	findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) [failretval==InvalidHandle] = FindFirstFileW
0000000000000000000000000000000000000000;;	//sys	findNextFile1(handle Handle, data *win32finddata1) (err error) = FindNextFileW
0000000000000000000000000000000000000000;;	//sys	FindClose(handle Handle) (err error)
0000000000000000000000000000000000000000;;	//sys	GetFileInformationByHandle(handle Handle, data *ByHandleFileInformation) (err error)
0000000000000000000000000000000000000000;;	//sys	GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) = GetCurrentDirectoryW
0000000000000000000000000000000000000000;;	//sys	SetCurrentDirectory(path *uint16) (err error) = SetCurrentDirectoryW
0000000000000000000000000000000000000000;;	//sys	CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) = CreateDirectoryW
0000000000000000000000000000000000000000;;	//sys	RemoveDirectory(path *uint16) (err error) = RemoveDirectoryW
0000000000000000000000000000000000000000;;	//sys	DeleteFile(path *uint16) (err error) = DeleteFileW
0000000000000000000000000000000000000000;;	//sys	MoveFile(from *uint16, to *uint16) (err error) = MoveFileW
0000000000000000000000000000000000000000;;	//sys	MoveFileEx(from *uint16, to *uint16, flags uint32) (err error) = MoveFileExW
0000000000000000000000000000000000000000;;	//sys	GetComputerName(buf *uint16, n *uint32) (err error) = GetComputerNameW
0000000000000000000000000000000000000000;;	//sys	GetComputerNameEx(nametype uint32, buf *uint16, n *uint32) (err error) = GetComputerNameExW
0000000000000000000000000000000000000000;;	//sys	SetEndOfFile(handle Handle) (err error)
0000000000000000000000000000000000000000;;	//sys	GetSystemTimeAsFileTime(time *Filetime)
0000000000000000000000000000000000000000;;	//sys	GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, err error) [failretval==0xffffffff]
0000000000000000000000000000000000000000;;	//sys	CreateIoCompletionPort(filehandle Handle, cphandle Handle, key uint32, threadcnt uint32) (handle Handle, err error)
0000000000000000000000000000000000000000;;	//sys	GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	PostQueuedCompletionStatus(cphandle Handle, qty uint32, key uint32, overlapped *Overlapped) (err error)
0000000000000000000000000000000000000000;;	//sys	CancelIo(s Handle) (err error)
0000000000000000000000000000000000000000;;	//sys	CancelIoEx(s Handle, o *Overlapped) (err error)
0000000000000000000000000000000000000000;;	//sys	CreateProcess(appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) = CreateProcessW
0000000000000000000000000000000000000000;;	//sys	OpenProcess(da uint32, inheritHandle bool, pid uint32) (handle Handle, err error)
0000000000000000000000000000000000000000;;	//sys	TerminateProcess(handle Handle, exitcode uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	GetExitCodeProcess(handle Handle, exitcode *uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	GetStartupInfo(startupInfo *StartupInfo) (err error) = GetStartupInfoW
0000000000000000000000000000000000000000;;	//sys	GetCurrentProcess() (pseudoHandle Handle, err error)
0000000000000000000000000000000000000000;;	//sys	GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error)
0000000000000000000000000000000000000000;;	//sys	DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) [failretval==0xffffffff]
0000000000000000000000000000000000000000;;	//sys	GetTempPath(buflen uint32, buf *uint16) (n uint32, err error) = GetTempPathW
0000000000000000000000000000000000000000;;	//sys	CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	GetFileType(filehandle Handle) (n uint32, err error)
0000000000000000000000000000000000000000;;	//sys	CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) = advapi32.CryptAcquireContextW
0000000000000000000000000000000000000000;;	//sys	CryptReleaseContext(provhandle Handle, flags uint32) (err error) = advapi32.CryptReleaseContext
0000000000000000000000000000000000000000;;	//sys	CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (err error) = advapi32.CryptGenRandom
0000000000000000000000000000000000000000;;	//sys	GetEnvironmentStrings() (envs *uint16, err error) [failretval==nil] = kernel32.GetEnvironmentStringsW
0000000000000000000000000000000000000000;;	//sys	FreeEnvironmentStrings(envs *uint16) (err error) = kernel32.FreeEnvironmentStringsW
0000000000000000000000000000000000000000;;	//sys	GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) = kernel32.GetEnvironmentVariableW
0000000000000000000000000000000000000000;;	//sys	SetEnvironmentVariable(name *uint16, value *uint16) (err error) = kernel32.SetEnvironmentVariableW
0000000000000000000000000000000000000000;;	//sys	SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error)
0000000000000000000000000000000000000000;;	//sys	GetFileAttributes(name *uint16) (attrs uint32, err error) [failretval==INVALID_FILE_ATTRIBUTES] = kernel32.GetFileAttributesW
0000000000000000000000000000000000000000;;	//sys	SetFileAttributes(name *uint16, attrs uint32) (err error) = kernel32.SetFileAttributesW
0000000000000000000000000000000000000000;;	//sys	GetFileAttributesEx(name *uint16, level uint32, info *byte) (err error) = kernel32.GetFileAttributesExW
0000000000000000000000000000000000000000;;	//sys	GetCommandLine() (cmd *uint16) = kernel32.GetCommandLineW
0000000000000000000000000000000000000000;;	//sys	CommandLineToArgv(cmd *uint16, argc *int32) (argv *[8192]*[8192]uint16, err error) [failretval==nil] = shell32.CommandLineToArgvW
0000000000000000000000000000000000000000;;	//sys	LocalFree(hmem Handle) (handle Handle, err error) [failretval!=0]
0000000000000000000000000000000000000000;;	//sys	SetHandleInformation(handle Handle, mask uint32, flags uint32) (err error)
0000000000000000000000000000000000000000;;	//sys	FlushFileBuffers(handle Handle) (err error)
0000000000000000000000000000000000000000;;	//sys	GetFullPathName(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, err error) = kernel32.GetFullPathNameW
0000000000000000000000000000000000000000;;	//sys	GetLongPathName(path *uint16, buf *uint16, buflen uint32) (n uint32, err error) = kernel32.GetLongPathNameW
0000000000000000000000000000000000000000;;	//sys	GetShortPathName(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error) = kernel32.GetShortPathNameW
0000000000000000000000000000000000000000;;	//sys	CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, err error) = kernel32.CreateFileMappingW
0000000000000000000000000000000000000000;;	//sys	MapViewOfFile(handle Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error)
0000000000000000000000000000000000000000;;	//sys	UnmapViewOfFile(addr uintptr) (err error)
0000000000000000000000000000000000000000;;	//sys	FlushViewOfFile(addr uintptr, length uintptr) (err error)
0000000000000000000000000000000000000000;;	//sys	VirtualLock(addr uintptr, length uintptr) (err error)
0000000000000000000000000000000000000000;;	//sys	VirtualUnlock(addr uintptr, length uintptr) (err error)
0000000000000000000000000000000000000000;;	//sys	TransmitFile(s Handle, handle Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *Overlapped, transmitFileBuf *TransmitFileBuffers, flags uint32) (err error) = mswsock.TransmitFile
0000000000000000000000000000000000000000;;	//sys	ReadDirectoryChanges(handle Handle, buf *byte, buflen uint32, watchSubTree bool, mask uint32, retlen *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) = kernel32.ReadDirectoryChangesW
0000000000000000000000000000000000000000;;	//sys	CertOpenSystemStore(hprov Handle, name *uint16) (store Handle, err error) = crypt32.CertOpenSystemStoreW
0000000000000000000000000000000000000000;;	//sys   CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) [failretval==InvalidHandle] = crypt32.CertOpenStore
0000000000000000000000000000000000000000;;	//sys	CertEnumCertificatesInStore(store Handle, prevContext *CertContext) (context *CertContext, err error) [failretval==nil] = crypt32.CertEnumCertificatesInStore
0000000000000000000000000000000000000000;;	//sys   CertAddCertificateContextToStore(store Handle, certContext *CertContext, addDisposition uint32, storeContext **CertContext) (err error) = crypt32.CertAddCertificateContextToStore
0000000000000000000000000000000000000000;;	//sys	CertCloseStore(store Handle, flags uint32) (err error) = crypt32.CertCloseStore
0000000000000000000000000000000000000000;;	//sys   CertGetCertificateChain(engine Handle, leaf *CertContext, time *Filetime, additionalStore Handle, para *CertChainPara, flags uint32, reserved uintptr, chainCtx **CertChainContext) (err error) = crypt32.CertGetCertificateChain
0000000000000000000000000000000000000000;;	//sys   CertFreeCertificateChain(ctx *CertChainContext) = crypt32.CertFreeCertificateChain
0000000000000000000000000000000000000000;;	//sys   CertCreateCertificateContext(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *CertContext, err error) [failretval==nil] = crypt32.CertCreateCertificateContext
0000000000000000000000000000000000000000;;	//sys   CertFreeCertificateContext(ctx *CertContext) (err error) = crypt32.CertFreeCertificateContext
0000000000000000000000000000000000000000;;	//sys   CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) = crypt32.CertVerifyCertificateChainPolicy
0000000000000000000000000000000000000000;;	//sys	RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) = advapi32.RegOpenKeyExW
0000000000000000000000000000000000000000;;	//sys	RegCloseKey(key Handle) (regerrno error) = advapi32.RegCloseKey
0000000000000000000000000000000000000000;;	//sys	RegQueryInfoKey(key Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *Filetime) (regerrno error) = advapi32.RegQueryInfoKeyW
0000000000000000000000000000000000000000;;	//sys	RegEnumKeyEx(key Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *Filetime) (regerrno error) = advapi32.RegEnumKeyExW
0000000000000000000000000000000000000000;;	//sys	RegQueryValueEx(key Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error) = advapi32.RegQueryValueExW
0000000000000000000000000000000000000000;;	//sys	getCurrentProcessId() (pid uint32) = kernel32.GetCurrentProcessId
0000000000000000000000000000000000000000;;	//sys	GetConsoleMode(console Handle, mode *uint32) (err error) = kernel32.GetConsoleMode
0000000000000000000000000000000000000000;;	//sys	WriteConsole(console Handle, buf *uint16, towrite uint32, written *uint32, reserved *byte) (err error) = kernel32.WriteConsoleW
0000000000000000000000000000000000000000;;	//sys	ReadConsole(console Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error) = kernel32.ReadConsoleW
0000000000000000000000000000000000000000;;	//sys	CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) [failretval==InvalidHandle] = kernel32.CreateToolhelp32Snapshot
0000000000000000000000000000000000000000;;	//sys	Process32First(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32FirstW
0000000000000000000000000000000000000000;;	//sys	Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32NextW
0000000000000000000000000000000000000000;;	//sys	DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error)
0000000000000000000000000000000000000000;;	// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.
0000000000000000000000000000000000000000;;	//sys	CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) [failretval&0xff==0] = CreateSymbolicLinkW
0000000000000000000000000000000000000000;;	//sys	CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) [failretval&0xff==0] = CreateHardLinkW
0000000000000000000000000000000000000000;;	//sys	GetCurrentThreadId() (id uint32)
0000000000000000000000000000000000000000;;	//sys	CreateEvent(eventAttrs *syscall.SecurityAttributes, manualReset uint32, initialState uint32, name *uint16) (handle Handle, err error) = kernel32.CreateEventW
0000000000000000000000000000000000000000;;	//sys	SetEvent(event Handle) (err error) = kernel32.SetEvent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syscall interface implementation for other packages
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Exit(code int) { ExitProcess(uint32(code)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeInheritSa() *SecurityAttributes {
0000000000000000000000000000000000000000;;		var sa SecurityAttributes
0000000000000000000000000000000000000000;;		sa.Length = uint32(unsafe.Sizeof(sa))
0000000000000000000000000000000000000000;;		sa.InheritHandle = 1
0000000000000000000000000000000000000000;;		return &sa
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Open(path string, mode int, perm uint32) (fd Handle, err error) {
0000000000000000000000000000000000000000;;		if len(path) == 0 {
0000000000000000000000000000000000000000;;			return InvalidHandle, ERROR_FILE_NOT_FOUND
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pathp, err := UTF16PtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return InvalidHandle, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var access uint32
0000000000000000000000000000000000000000;;		switch mode & (O_RDONLY | O_WRONLY | O_RDWR) {
0000000000000000000000000000000000000000;;		case O_RDONLY:
0000000000000000000000000000000000000000;;			access = GENERIC_READ
0000000000000000000000000000000000000000;;		case O_WRONLY:
0000000000000000000000000000000000000000;;			access = GENERIC_WRITE
0000000000000000000000000000000000000000;;		case O_RDWR:
0000000000000000000000000000000000000000;;			access = GENERIC_READ | GENERIC_WRITE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mode&O_CREAT != 0 {
0000000000000000000000000000000000000000;;			access |= GENERIC_WRITE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mode&O_APPEND != 0 {
0000000000000000000000000000000000000000;;			access &^= GENERIC_WRITE
0000000000000000000000000000000000000000;;			access |= FILE_APPEND_DATA
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sharemode := uint32(FILE_SHARE_READ | FILE_SHARE_WRITE)
0000000000000000000000000000000000000000;;		var sa *SecurityAttributes
0000000000000000000000000000000000000000;;		if mode&O_CLOEXEC == 0 {
0000000000000000000000000000000000000000;;			sa = makeInheritSa()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var createmode uint32
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case mode&(O_CREAT|O_EXCL) == (O_CREAT | O_EXCL):
0000000000000000000000000000000000000000;;			createmode = CREATE_NEW
0000000000000000000000000000000000000000;;		case mode&(O_CREAT|O_TRUNC) == (O_CREAT | O_TRUNC):
0000000000000000000000000000000000000000;;			createmode = CREATE_ALWAYS
0000000000000000000000000000000000000000;;		case mode&O_CREAT == O_CREAT:
0000000000000000000000000000000000000000;;			createmode = OPEN_ALWAYS
0000000000000000000000000000000000000000;;		case mode&O_TRUNC == O_TRUNC:
0000000000000000000000000000000000000000;;			createmode = TRUNCATE_EXISTING
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			createmode = OPEN_EXISTING
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h, e := CreateFile(pathp, access, sharemode, sa, createmode, FILE_ATTRIBUTE_NORMAL, 0)
0000000000000000000000000000000000000000;;		return h, e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Read(fd Handle, p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		var done uint32
0000000000000000000000000000000000000000;;		e := ReadFile(fd, p, &done, nil)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			if e == ERROR_BROKEN_PIPE {
0000000000000000000000000000000000000000;;				// NOTE(brainman): work around ERROR_BROKEN_PIPE is returned on reading EOF from stdin
0000000000000000000000000000000000000000;;				return 0, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if raceenabled {
0000000000000000000000000000000000000000;;			if done > 0 {
0000000000000000000000000000000000000000;;				raceWriteRange(unsafe.Pointer(&p[0]), int(done))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			raceAcquire(unsafe.Pointer(&ioSync))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(done), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Write(fd Handle, p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if raceenabled {
0000000000000000000000000000000000000000;;			raceReleaseMerge(unsafe.Pointer(&ioSync))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var done uint32
0000000000000000000000000000000000000000;;		e := WriteFile(fd, p, &done, nil)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return 0, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if raceenabled && done > 0 {
0000000000000000000000000000000000000000;;			raceReadRange(unsafe.Pointer(&p[0]), int(done))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(done), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ioSync int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Seek(fd Handle, offset int64, whence int) (newoffset int64, err error) {
0000000000000000000000000000000000000000;;		var w uint32
0000000000000000000000000000000000000000;;		switch whence {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			w = FILE_BEGIN
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			w = FILE_CURRENT
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			w = FILE_END
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hi := int32(offset >> 32)
0000000000000000000000000000000000000000;;		lo := int32(offset)
0000000000000000000000000000000000000000;;		// use GetFileType to check pipe, pipe can't do seek
0000000000000000000000000000000000000000;;		ft, _ := GetFileType(fd)
0000000000000000000000000000000000000000;;		if ft == FILE_TYPE_PIPE {
0000000000000000000000000000000000000000;;			return 0, syscall.EPIPE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rlo, e := SetFilePointer(fd, lo, &hi, w)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return 0, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int64(hi)<<32 + int64(rlo), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Close(fd Handle) (err error) {
0000000000000000000000000000000000000000;;		return CloseHandle(fd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		Stdin  = getStdHandle(STD_INPUT_HANDLE)
0000000000000000000000000000000000000000;;		Stdout = getStdHandle(STD_OUTPUT_HANDLE)
0000000000000000000000000000000000000000;;		Stderr = getStdHandle(STD_ERROR_HANDLE)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getStdHandle(h int) (fd Handle) {
0000000000000000000000000000000000000000;;		r, _ := GetStdHandle(h)
0000000000000000000000000000000000000000;;		CloseOnExec(r)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const ImplementsGetwd = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getwd() (wd string, err error) {
0000000000000000000000000000000000000000;;		b := make([]uint16, 300)
0000000000000000000000000000000000000000;;		n, e := GetCurrentDirectory(uint32(len(b)), &b[0])
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return "", e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(utf16.Decode(b[0:n])), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Chdir(path string) (err error) {
0000000000000000000000000000000000000000;;		pathp, err := UTF16PtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return SetCurrentDirectory(pathp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Mkdir(path string, mode uint32) (err error) {
0000000000000000000000000000000000000000;;		pathp, err := UTF16PtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return CreateDirectory(pathp, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Rmdir(path string) (err error) {
0000000000000000000000000000000000000000;;		pathp, err := UTF16PtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return RemoveDirectory(pathp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Unlink(path string) (err error) {
0000000000000000000000000000000000000000;;		pathp, err := UTF16PtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return DeleteFile(pathp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Rename(oldpath, newpath string) (err error) {
0000000000000000000000000000000000000000;;		from, err := UTF16PtrFromString(oldpath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		to, err := UTF16PtrFromString(newpath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return MoveFileEx(from, to, MOVEFILE_REPLACE_EXISTING)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ComputerName() (name string, err error) {
0000000000000000000000000000000000000000;;		var n uint32 = MAX_COMPUTERNAME_LENGTH + 1
0000000000000000000000000000000000000000;;		b := make([]uint16, n)
0000000000000000000000000000000000000000;;		e := GetComputerName(&b[0], &n)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return "", e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(utf16.Decode(b[0:n])), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Ftruncate(fd Handle, length int64) (err error) {
0000000000000000000000000000000000000000;;		curoffset, e := Seek(fd, 0, 1)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer Seek(fd, curoffset, 0)
0000000000000000000000000000000000000000;;		_, e = Seek(fd, length, 0)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e = SetEndOfFile(fd)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Gettimeofday(tv *Timeval) (err error) {
0000000000000000000000000000000000000000;;		var ft Filetime
0000000000000000000000000000000000000000;;		GetSystemTimeAsFileTime(&ft)
0000000000000000000000000000000000000000;;		*tv = NsecToTimeval(ft.Nanoseconds())
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Pipe(p []Handle) (err error) {
0000000000000000000000000000000000000000;;		if len(p) != 2 {
0000000000000000000000000000000000000000;;			return syscall.EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var r, w Handle
0000000000000000000000000000000000000000;;		e := CreatePipe(&r, &w, makeInheritSa(), 0)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p[0] = r
0000000000000000000000000000000000000000;;		p[1] = w
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Utimes(path string, tv []Timeval) (err error) {
0000000000000000000000000000000000000000;;		if len(tv) != 2 {
0000000000000000000000000000000000000000;;			return syscall.EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pathp, e := UTF16PtrFromString(path)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h, e := CreateFile(pathp,
0000000000000000000000000000000000000000;;			FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nil,
0000000000000000000000000000000000000000;;			OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer Close(h)
0000000000000000000000000000000000000000;;		a := NsecToFiletime(tv[0].Nanoseconds())
0000000000000000000000000000000000000000;;		w := NsecToFiletime(tv[1].Nanoseconds())
0000000000000000000000000000000000000000;;		return SetFileTime(h, nil, &a, &w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func UtimesNano(path string, ts []Timespec) (err error) {
0000000000000000000000000000000000000000;;		if len(ts) != 2 {
0000000000000000000000000000000000000000;;			return syscall.EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pathp, e := UTF16PtrFromString(path)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h, e := CreateFile(pathp,
0000000000000000000000000000000000000000;;			FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nil,
0000000000000000000000000000000000000000;;			OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer Close(h)
0000000000000000000000000000000000000000;;		a := NsecToFiletime(TimespecToNsec(ts[0]))
0000000000000000000000000000000000000000;;		w := NsecToFiletime(TimespecToNsec(ts[1]))
0000000000000000000000000000000000000000;;		return SetFileTime(h, nil, &a, &w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Fsync(fd Handle) (err error) {
0000000000000000000000000000000000000000;;		return FlushFileBuffers(fd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Chmod(path string, mode uint32) (err error) {
0000000000000000000000000000000000000000;;		if mode == 0 {
0000000000000000000000000000000000000000;;			return syscall.EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, e := UTF16PtrFromString(path)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs, e := GetFileAttributes(p)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mode&S_IWRITE != 0 {
0000000000000000000000000000000000000000;;			attrs &^= FILE_ATTRIBUTE_READONLY
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			attrs |= FILE_ATTRIBUTE_READONLY
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return SetFileAttributes(p, attrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LoadCancelIoEx() error {
0000000000000000000000000000000000000000;;		return procCancelIoEx.Find()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LoadSetFileCompletionNotificationModes() error {
0000000000000000000000000000000000000000;;		return procSetFileCompletionNotificationModes.Find()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// net api calls
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const socket_error = uintptr(^uint32(0))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	WSAStartup(verreq uint32, data *WSAData) (sockerr error) = ws2_32.WSAStartup
0000000000000000000000000000000000000000;;	//sys	WSACleanup() (err error) [failretval==socket_error] = ws2_32.WSACleanup
0000000000000000000000000000000000000000;;	//sys	WSAIoctl(s Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) [failretval==socket_error] = ws2_32.WSAIoctl
0000000000000000000000000000000000000000;;	//sys	socket(af int32, typ int32, protocol int32) (handle Handle, err error) [failretval==InvalidHandle] = ws2_32.socket
0000000000000000000000000000000000000000;;	//sys	Setsockopt(s Handle, level int32, optname int32, optval *byte, optlen int32) (err error) [failretval==socket_error] = ws2_32.setsockopt
0000000000000000000000000000000000000000;;	//sys	Getsockopt(s Handle, level int32, optname int32, optval *byte, optlen *int32) (err error) [failretval==socket_error] = ws2_32.getsockopt
0000000000000000000000000000000000000000;;	//sys	bind(s Handle, name unsafe.Pointer, namelen int32) (err error) [failretval==socket_error] = ws2_32.bind
0000000000000000000000000000000000000000;;	//sys	connect(s Handle, name unsafe.Pointer, namelen int32) (err error) [failretval==socket_error] = ws2_32.connect
0000000000000000000000000000000000000000;;	//sys	getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) [failretval==socket_error] = ws2_32.getsockname
0000000000000000000000000000000000000000;;	//sys	getpeername(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) [failretval==socket_error] = ws2_32.getpeername
0000000000000000000000000000000000000000;;	//sys	listen(s Handle, backlog int32) (err error) [failretval==socket_error] = ws2_32.listen
0000000000000000000000000000000000000000;;	//sys	shutdown(s Handle, how int32) (err error) [failretval==socket_error] = ws2_32.shutdown
0000000000000000000000000000000000000000;;	//sys	Closesocket(s Handle) (err error) [failretval==socket_error] = ws2_32.closesocket
0000000000000000000000000000000000000000;;	//sys	AcceptEx(ls Handle, as Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (err error) = mswsock.AcceptEx
0000000000000000000000000000000000000000;;	//sys	GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) = mswsock.GetAcceptExSockaddrs
0000000000000000000000000000000000000000;;	//sys	WSARecv(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *Overlapped, croutine *byte) (err error) [failretval==socket_error] = ws2_32.WSARecv
0000000000000000000000000000000000000000;;	//sys	WSASend(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *Overlapped, croutine *byte) (err error) [failretval==socket_error] = ws2_32.WSASend
0000000000000000000000000000000000000000;;	//sys	WSARecvFrom(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32,  from *RawSockaddrAny, fromlen *int32, overlapped *Overlapped, croutine *byte) (err error) [failretval==socket_error] = ws2_32.WSARecvFrom
0000000000000000000000000000000000000000;;	//sys	WSASendTo(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *RawSockaddrAny, tolen int32,  overlapped *Overlapped, croutine *byte) (err error) [failretval==socket_error] = ws2_32.WSASendTo
0000000000000000000000000000000000000000;;	//sys	GetHostByName(name string) (h *Hostent, err error) [failretval==nil] = ws2_32.gethostbyname
0000000000000000000000000000000000000000;;	//sys	GetServByName(name string, proto string) (s *Servent, err error) [failretval==nil] = ws2_32.getservbyname
0000000000000000000000000000000000000000;;	//sys	Ntohs(netshort uint16) (u uint16) = ws2_32.ntohs
0000000000000000000000000000000000000000;;	//sys	GetProtoByName(name string) (p *Protoent, err error) [failretval==nil] = ws2_32.getprotobyname
0000000000000000000000000000000000000000;;	//sys	DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) = dnsapi.DnsQuery_W
0000000000000000000000000000000000000000;;	//sys	DnsRecordListFree(rl *DNSRecord, freetype uint32) = dnsapi.DnsRecordListFree
0000000000000000000000000000000000000000;;	//sys	DnsNameCompare(name1 *uint16, name2 *uint16) (same bool) = dnsapi.DnsNameCompare_W
0000000000000000000000000000000000000000;;	//sys	GetAddrInfoW(nodename *uint16, servicename *uint16, hints *AddrinfoW, result **AddrinfoW) (sockerr error) = ws2_32.GetAddrInfoW
0000000000000000000000000000000000000000;;	//sys	FreeAddrInfoW(addrinfo *AddrinfoW) = ws2_32.FreeAddrInfoW
0000000000000000000000000000000000000000;;	//sys	GetIfEntry(pIfRow *MibIfRow) (errcode error) = iphlpapi.GetIfEntry
0000000000000000000000000000000000000000;;	//sys	GetAdaptersInfo(ai *IpAdapterInfo, ol *uint32) (errcode error) = iphlpapi.GetAdaptersInfo
0000000000000000000000000000000000000000;;	//sys	SetFileCompletionNotificationModes(handle Handle, flags uint8) (err error) = kernel32.SetFileCompletionNotificationModes
0000000000000000000000000000000000000000;;	//sys	WSAEnumProtocols(protocols *int32, protocolBuffer *WSAProtocolInfo, bufferLength *uint32) (n int32, err error) [failretval==-1] = ws2_32.WSAEnumProtocolsW
0000000000000000000000000000000000000000;;	//sys	GetAdaptersAddresses(family uint32, flags uint32, reserved uintptr, adapterAddresses *IpAdapterAddresses, sizePointer *uint32) (errcode error) = iphlpapi.GetAdaptersAddresses
0000000000000000000000000000000000000000;;	//sys	GetACP() (acp uint32) = kernel32.GetACP
0000000000000000000000000000000000000000;;	//sys	MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) = kernel32.MultiByteToWideChar
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For testing: clients can set this flag to force
0000000000000000000000000000000000000000;;	// creation of IPv6 sockets to return EAFNOSUPPORT.
0000000000000000000000000000000000000000;;	var SocketDisableIPv6 bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RawSockaddrInet4 struct {
0000000000000000000000000000000000000000;;		Family uint16
0000000000000000000000000000000000000000;;		Port   uint16
0000000000000000000000000000000000000000;;		Addr   [4]byte /* in_addr */
0000000000000000000000000000000000000000;;		Zero   [8]uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RawSockaddrInet6 struct {
0000000000000000000000000000000000000000;;		Family   uint16
0000000000000000000000000000000000000000;;		Port     uint16
0000000000000000000000000000000000000000;;		Flowinfo uint32
0000000000000000000000000000000000000000;;		Addr     [16]byte /* in6_addr */
0000000000000000000000000000000000000000;;		Scope_id uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RawSockaddr struct {
0000000000000000000000000000000000000000;;		Family uint16
0000000000000000000000000000000000000000;;		Data   [14]int8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RawSockaddrAny struct {
0000000000000000000000000000000000000000;;		Addr RawSockaddr
0000000000000000000000000000000000000000;;		Pad  [96]int8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Sockaddr interface {
0000000000000000000000000000000000000000;;		sockaddr() (ptr unsafe.Pointer, len int32, err error) // lowercase; only we can define Sockaddrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrInet4 struct {
0000000000000000000000000000000000000000;;		Port int
0000000000000000000000000000000000000000;;		Addr [4]byte
0000000000000000000000000000000000000000;;		raw  RawSockaddrInet4
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, int32, error) {
0000000000000000000000000000000000000000;;		if sa.Port < 0 || sa.Port > 0xFFFF {
0000000000000000000000000000000000000000;;			return nil, 0, syscall.EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_INET
0000000000000000000000000000000000000000;;		p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
0000000000000000000000000000000000000000;;		p[0] = byte(sa.Port >> 8)
0000000000000000000000000000000000000000;;		p[1] = byte(sa.Port)
0000000000000000000000000000000000000000;;		for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;			sa.raw.Addr[i] = sa.Addr[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), int32(unsafe.Sizeof(sa.raw)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrInet6 struct {
0000000000000000000000000000000000000000;;		Port   int
0000000000000000000000000000000000000000;;		ZoneId uint32
0000000000000000000000000000000000000000;;		Addr   [16]byte
0000000000000000000000000000000000000000;;		raw    RawSockaddrInet6
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, int32, error) {
0000000000000000000000000000000000000000;;		if sa.Port < 0 || sa.Port > 0xFFFF {
0000000000000000000000000000000000000000;;			return nil, 0, syscall.EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sa.raw.Family = AF_INET6
0000000000000000000000000000000000000000;;		p := (*[2]byte)(unsafe.Pointer(&sa.raw.Port))
0000000000000000000000000000000000000000;;		p[0] = byte(sa.Port >> 8)
0000000000000000000000000000000000000000;;		p[1] = byte(sa.Port)
0000000000000000000000000000000000000000;;		sa.raw.Scope_id = sa.ZoneId
0000000000000000000000000000000000000000;;		for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;			sa.raw.Addr[i] = sa.Addr[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unsafe.Pointer(&sa.raw), int32(unsafe.Sizeof(sa.raw)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SockaddrUnix struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, int32, error) {
0000000000000000000000000000000000000000;;		// TODO(brainman): implement SockaddrUnix.sockaddr()
0000000000000000000000000000000000000000;;		return nil, 0, syscall.EWINDOWS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rsa *RawSockaddrAny) Sockaddr() (Sockaddr, error) {
0000000000000000000000000000000000000000;;		switch rsa.Addr.Family {
0000000000000000000000000000000000000000;;		case AF_UNIX:
0000000000000000000000000000000000000000;;			return nil, syscall.EWINDOWS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_INET:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrInet4)
0000000000000000000000000000000000000000;;			p := (*[2]byte)(unsafe.Pointer(&pp.Port))
0000000000000000000000000000000000000000;;			sa.Port = int(p[0])<<8 + int(p[1])
0000000000000000000000000000000000000000;;			for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;				sa.Addr[i] = pp.Addr[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case AF_INET6:
0000000000000000000000000000000000000000;;			pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))
0000000000000000000000000000000000000000;;			sa := new(SockaddrInet6)
0000000000000000000000000000000000000000;;			p := (*[2]byte)(unsafe.Pointer(&pp.Port))
0000000000000000000000000000000000000000;;			sa.Port = int(p[0])<<8 + int(p[1])
0000000000000000000000000000000000000000;;			sa.ZoneId = pp.Scope_id
0000000000000000000000000000000000000000;;			for i := 0; i < len(sa.Addr); i++ {
0000000000000000000000000000000000000000;;				sa.Addr[i] = pp.Addr[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sa, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, syscall.EAFNOSUPPORT
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Socket(domain, typ, proto int) (fd Handle, err error) {
0000000000000000000000000000000000000000;;		if domain == AF_INET6 && SocketDisableIPv6 {
0000000000000000000000000000000000000000;;			return InvalidHandle, syscall.EAFNOSUPPORT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return socket(int32(domain), int32(typ), int32(proto))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptInt(fd Handle, level, opt int, value int) (err error) {
0000000000000000000000000000000000000000;;		v := int32(value)
0000000000000000000000000000000000000000;;		return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&v)), int32(unsafe.Sizeof(v)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Bind(fd Handle, sa Sockaddr) (err error) {
0000000000000000000000000000000000000000;;		ptr, n, err := sa.sockaddr()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bind(fd, ptr, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Connect(fd Handle, sa Sockaddr) (err error) {
0000000000000000000000000000000000000000;;		ptr, n, err := sa.sockaddr()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return connect(fd, ptr, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getsockname(fd Handle) (sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		l := int32(unsafe.Sizeof(rsa))
0000000000000000000000000000000000000000;;		if err = getsockname(fd, &rsa, &l); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rsa.Sockaddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getpeername(fd Handle) (sa Sockaddr, err error) {
0000000000000000000000000000000000000000;;		var rsa RawSockaddrAny
0000000000000000000000000000000000000000;;		l := int32(unsafe.Sizeof(rsa))
0000000000000000000000000000000000000000;;		if err = getpeername(fd, &rsa, &l); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rsa.Sockaddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Listen(s Handle, n int) (err error) {
0000000000000000000000000000000000000000;;		return listen(s, int32(n))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Shutdown(fd Handle, how int) (err error) {
0000000000000000000000000000000000000000;;		return shutdown(fd, int32(how))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WSASendto(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to Sockaddr, overlapped *Overlapped, croutine *byte) (err error) {
0000000000000000000000000000000000000000;;		rsa, l, err := to.sockaddr()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return WSASendTo(s, bufs, bufcnt, sent, flags, (*RawSockaddrAny)(unsafe.Pointer(rsa)), l, overlapped, croutine)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LoadGetAddrInfo() error {
0000000000000000000000000000000000000000;;		return procGetAddrInfoW.Find()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var connectExFunc struct {
0000000000000000000000000000000000000000;;		once sync.Once
0000000000000000000000000000000000000000;;		addr uintptr
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LoadConnectEx() error {
0000000000000000000000000000000000000000;;		connectExFunc.once.Do(func() {
0000000000000000000000000000000000000000;;			var s Handle
0000000000000000000000000000000000000000;;			s, connectExFunc.err = Socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)
0000000000000000000000000000000000000000;;			if connectExFunc.err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer CloseHandle(s)
0000000000000000000000000000000000000000;;			var n uint32
0000000000000000000000000000000000000000;;			connectExFunc.err = WSAIoctl(s,
0000000000000000000000000000000000000000;;				SIO_GET_EXTENSION_FUNCTION_POINTER,
0000000000000000000000000000000000000000;;				(*byte)(unsafe.Pointer(&WSAID_CONNECTEX)),
0000000000000000000000000000000000000000;;				uint32(unsafe.Sizeof(WSAID_CONNECTEX)),
0000000000000000000000000000000000000000;;				(*byte)(unsafe.Pointer(&connectExFunc.addr)),
0000000000000000000000000000000000000000;;				uint32(unsafe.Sizeof(connectExFunc.addr)),
0000000000000000000000000000000000000000;;				&n, nil, 0)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return connectExFunc.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func connectEx(s Handle, name unsafe.Pointer, namelen int32, sendBuf *byte, sendDataLen uint32, bytesSent *uint32, overlapped *Overlapped) (err error) {
0000000000000000000000000000000000000000;;		r1, _, e1 := syscall.Syscall9(connectExFunc.addr, 7, uintptr(s), uintptr(name), uintptr(namelen), uintptr(unsafe.Pointer(sendBuf)), uintptr(sendDataLen), uintptr(unsafe.Pointer(bytesSent)), uintptr(unsafe.Pointer(overlapped)), 0, 0)
0000000000000000000000000000000000000000;;		if r1 == 0 {
0000000000000000000000000000000000000000;;			if e1 != 0 {
0000000000000000000000000000000000000000;;				err = error(e1)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = syscall.EINVAL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ConnectEx(fd Handle, sa Sockaddr, sendBuf *byte, sendDataLen uint32, bytesSent *uint32, overlapped *Overlapped) error {
0000000000000000000000000000000000000000;;		err := LoadConnectEx()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return errorspkg.New("failed to find ConnectEx: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ptr, n, err := sa.sockaddr()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return connectEx(fd, ptr, n, sendBuf, sendDataLen, bytesSent, overlapped)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Invented structures to support what package os expects.
0000000000000000000000000000000000000000;;	type Rusage struct {
0000000000000000000000000000000000000000;;		CreationTime Filetime
0000000000000000000000000000000000000000;;		ExitTime     Filetime
0000000000000000000000000000000000000000;;		KernelTime   Filetime
0000000000000000000000000000000000000000;;		UserTime     Filetime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WaitStatus struct {
0000000000000000000000000000000000000000;;		ExitCode uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Exited() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) ExitStatus() int { return int(w.ExitCode) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Signal() Signal { return -1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) CoreDump() bool { return false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Stopped() bool { return false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Continued() bool { return false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) StopSignal() Signal { return -1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) Signaled() bool { return false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w WaitStatus) TrapCause() int { return -1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Timespec is an invented structure on Windows, but here for
0000000000000000000000000000000000000000;;	// consistency with the corresponding package for other operating systems.
0000000000000000000000000000000000000000;;	type Timespec struct {
0000000000000000000000000000000000000000;;		Sec  int64
0000000000000000000000000000000000000000;;		Nsec int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NsecToTimespec(nsec int64) (ts Timespec) {
0000000000000000000000000000000000000000;;		ts.Sec = nsec / 1e9
0000000000000000000000000000000000000000;;		ts.Nsec = nsec % 1e9
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(brainman): fix all needed for net
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Accept(fd Handle) (nfd Handle, sa Sockaddr, err error) { return 0, nil, syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	func Recvfrom(fd Handle, p []byte, flags int) (n int, from Sockaddr, err error) {
0000000000000000000000000000000000000000;;		return 0, nil, syscall.EWINDOWS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func Sendto(fd Handle, p []byte, flags int, to Sockaddr) (err error)       { return syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	func SetsockoptTimeval(fd Handle, level, opt int, tv *Timeval) (err error) { return syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Linger struct is wrong but we only noticed after Go 1.
0000000000000000000000000000000000000000;;	// sysLinger is the real system call structure.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BUG(brainman): The definition of Linger is not appropriate for direct use
0000000000000000000000000000000000000000;;	// with Setsockopt and Getsockopt.
0000000000000000000000000000000000000000;;	// Use SetsockoptLinger instead.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Linger struct {
0000000000000000000000000000000000000000;;		Onoff  int32
0000000000000000000000000000000000000000;;		Linger int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sysLinger struct {
0000000000000000000000000000000000000000;;		Onoff  uint16
0000000000000000000000000000000000000000;;		Linger uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type IPMreq struct {
0000000000000000000000000000000000000000;;		Multiaddr [4]byte /* in_addr */
0000000000000000000000000000000000000000;;		Interface [4]byte /* in_addr */
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type IPv6Mreq struct {
0000000000000000000000000000000000000000;;		Multiaddr [16]byte /* in6_addr */
0000000000000000000000000000000000000000;;		Interface uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetsockoptInt(fd Handle, level, opt int) (int, error) { return -1, syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptLinger(fd Handle, level, opt int, l *Linger) (err error) {
0000000000000000000000000000000000000000;;		sys := sysLinger{Onoff: uint16(l.Onoff), Linger: uint16(l.Linger)}
0000000000000000000000000000000000000000;;		return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&sys)), int32(unsafe.Sizeof(sys)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetsockoptInet4Addr(fd Handle, level, opt int, value [4]byte) (err error) {
0000000000000000000000000000000000000000;;		return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&value[0])), 4)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func SetsockoptIPMreq(fd Handle, level, opt int, mreq *IPMreq) (err error) {
0000000000000000000000000000000000000000;;		return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(mreq)), int32(unsafe.Sizeof(*mreq)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func SetsockoptIPv6Mreq(fd Handle, level, opt int, mreq *IPv6Mreq) (err error) {
0000000000000000000000000000000000000000;;		return syscall.EWINDOWS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getpid() (pid int) { return int(getCurrentProcessId()) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FindFirstFile(name *uint16, data *Win32finddata) (handle Handle, err error) {
0000000000000000000000000000000000000000;;		// NOTE(rsc): The Win32finddata struct is wrong for the system call:
0000000000000000000000000000000000000000;;		// the two paths are each one uint16 short. Use the correct struct,
0000000000000000000000000000000000000000;;		// a win32finddata1, and then copy the results out.
0000000000000000000000000000000000000000;;		// There is no loss of expressivity here, because the final
0000000000000000000000000000000000000000;;		// uint16, if it is used, is supposed to be a NUL, and Go doesn't need that.
0000000000000000000000000000000000000000;;		// For Go 1.1, we might avoid the allocation of win32finddata1 here
0000000000000000000000000000000000000000;;		// by adding a final Bug [2]uint16 field to the struct and then
0000000000000000000000000000000000000000;;		// adjusting the fields in the result directly.
0000000000000000000000000000000000000000;;		var data1 win32finddata1
0000000000000000000000000000000000000000;;		handle, err = findFirstFile1(name, &data1)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			copyFindData(data, &data1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FindNextFile(handle Handle, data *Win32finddata) (err error) {
0000000000000000000000000000000000000000;;		var data1 win32finddata1
0000000000000000000000000000000000000000;;		err = findNextFile1(handle, &data1)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			copyFindData(data, &data1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getProcessEntry(pid int) (*ProcessEntry32, error) {
0000000000000000000000000000000000000000;;		snapshot, err := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer CloseHandle(snapshot)
0000000000000000000000000000000000000000;;		var procEntry ProcessEntry32
0000000000000000000000000000000000000000;;		procEntry.Size = uint32(unsafe.Sizeof(procEntry))
0000000000000000000000000000000000000000;;		if err = Process32First(snapshot, &procEntry); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if procEntry.ProcessID == uint32(pid) {
0000000000000000000000000000000000000000;;				return &procEntry, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = Process32Next(snapshot, &procEntry)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getppid() (ppid int) {
0000000000000000000000000000000000000000;;		pe, err := getProcessEntry(Getpid())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(pe.ParentProcessID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(brainman): fix all needed for os
0000000000000000000000000000000000000000;;	func Fchdir(fd Handle) (err error)             { return syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	func Link(oldpath, newpath string) (err error) { return syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	func Symlink(path, link string) (err error)    { return syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Fchmod(fd Handle, mode uint32) (err error)        { return syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	func Chown(path string, uid int, gid int) (err error)  { return syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	func Lchown(path string, uid int, gid int) (err error) { return syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	func Fchown(fd Handle, uid int, gid int) (err error)   { return syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Getuid() (uid int)                  { return -1 }
0000000000000000000000000000000000000000;;	func Geteuid() (euid int)                { return -1 }
0000000000000000000000000000000000000000;;	func Getgid() (gid int)                  { return -1 }
0000000000000000000000000000000000000000;;	func Getegid() (egid int)                { return -1 }
0000000000000000000000000000000000000000;;	func Getgroups() (gids []int, err error) { return nil, syscall.EWINDOWS }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Signal int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s Signal) Signal() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s Signal) String() string {
0000000000000000000000000000000000000000;;		if 0 <= s && int(s) < len(signals) {
0000000000000000000000000000000000000000;;			str := signals[s]
0000000000000000000000000000000000000000;;			if str != "" {
0000000000000000000000000000000000000000;;				return str
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "signal " + itoa(int(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LoadCreateSymbolicLink() error {
0000000000000000000000000000000000000000;;		return procCreateSymbolicLinkW.Find()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Readlink returns the destination of the named symbolic link.
0000000000000000000000000000000000000000;;	func Readlink(path string, buf []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		fd, err := CreateFile(StringToUTF16Ptr(path), GENERIC_READ, 0, nil, OPEN_EXISTING,
0000000000000000000000000000000000000000;;			FILE_FLAG_OPEN_REPARSE_POINT|FILE_FLAG_BACKUP_SEMANTICS, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer CloseHandle(fd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rdbbuf := make([]byte, MAXIMUM_REPARSE_DATA_BUFFER_SIZE)
0000000000000000000000000000000000000000;;		var bytesReturned uint32
0000000000000000000000000000000000000000;;		err = DeviceIoControl(fd, FSCTL_GET_REPARSE_POINT, nil, 0, &rdbbuf[0], uint32(len(rdbbuf)), &bytesReturned, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rdb := (*reparseDataBuffer)(unsafe.Pointer(&rdbbuf[0]))
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		switch rdb.ReparseTag {
0000000000000000000000000000000000000000;;		case IO_REPARSE_TAG_SYMLINK:
0000000000000000000000000000000000000000;;			data := (*symbolicLinkReparseBuffer)(unsafe.Pointer(&rdb.reparseBuffer))
0000000000000000000000000000000000000000;;			p := (*[0xffff]uint16)(unsafe.Pointer(&data.PathBuffer[0]))
0000000000000000000000000000000000000000;;			s = UTF16ToString(p[data.PrintNameOffset/2 : (data.PrintNameLength-data.PrintNameOffset)/2])
0000000000000000000000000000000000000000;;		case IO_REPARSE_TAG_MOUNT_POINT:
0000000000000000000000000000000000000000;;			data := (*mountPointReparseBuffer)(unsafe.Pointer(&rdb.reparseBuffer))
0000000000000000000000000000000000000000;;			p := (*[0xffff]uint16)(unsafe.Pointer(&data.PathBuffer[0]))
0000000000000000000000000000000000000000;;			s = UTF16ToString(p[data.PrintNameOffset/2 : (data.PrintNameLength-data.PrintNameOffset)/2])
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// the path is not a symlink or junction but another type of reparse
0000000000000000000000000000000000000000;;			// point
0000000000000000000000000000000000000000;;			return -1, syscall.ENOENT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n = copy(buf, []byte(s))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
