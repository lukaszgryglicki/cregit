0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
372f1bceb3e2da05404dc30071e64aebe6b55b42;;	
0000000000000000000000000000000000000000;;	// Fork, exec, wait, etc.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package windows
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EscapeArg rewrites command line argument s as prescribed
0000000000000000000000000000000000000000;;	// in http://msdn.microsoft.com/en-us/library/ms880421.
0000000000000000000000000000000000000000;;	// This function returns "" (2 double quotes) if s is empty.
0000000000000000000000000000000000000000;;	// Alternatively, these transformations are done:
0000000000000000000000000000000000000000;;	// - every back slash (\) is doubled, but only if immediately
0000000000000000000000000000000000000000;;	//   followed by double quote (");
0000000000000000000000000000000000000000;;	// - every double quote (") is escaped by back slash (\);
0000000000000000000000000000000000000000;;	// - finally, s is wrapped with double quotes (arg -> "arg"),
0000000000000000000000000000000000000000;;	//   but only if there is space or tab inside s.
0000000000000000000000000000000000000000;;	func EscapeArg(s string) string {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return "\"\""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := len(s)
0000000000000000000000000000000000000000;;		hasSpace := false
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			switch s[i] {
0000000000000000000000000000000000000000;;			case '"', '\\':
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;			case ' ', '\t':
0000000000000000000000000000000000000000;;				hasSpace = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasSpace {
0000000000000000000000000000000000000000;;			n += 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n == len(s) {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		qs := make([]byte, n)
0000000000000000000000000000000000000000;;		j := 0
0000000000000000000000000000000000000000;;		if hasSpace {
0000000000000000000000000000000000000000;;			qs[j] = '"'
0000000000000000000000000000000000000000;;			j++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		slashes := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			switch s[i] {
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				slashes = 0
0000000000000000000000000000000000000000;;				qs[j] = s[i]
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				slashes++
0000000000000000000000000000000000000000;;				qs[j] = s[i]
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				for ; slashes > 0; slashes-- {
0000000000000000000000000000000000000000;;					qs[j] = '\\'
0000000000000000000000000000000000000000;;					j++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				qs[j] = '\\'
0000000000000000000000000000000000000000;;				j++
0000000000000000000000000000000000000000;;				qs[j] = s[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			j++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasSpace {
0000000000000000000000000000000000000000;;			for ; slashes > 0; slashes-- {
0000000000000000000000000000000000000000;;				qs[j] = '\\'
0000000000000000000000000000000000000000;;				j++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			qs[j] = '"'
0000000000000000000000000000000000000000;;			j++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(qs[:j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CloseOnExec(fd Handle) {
0000000000000000000000000000000000000000;;		SetHandleInformation(Handle(fd), HANDLE_FLAG_INHERIT, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FullPath retrieves the full path of the specified file.
0000000000000000000000000000000000000000;;	func FullPath(name string) (path string, err error) {
0000000000000000000000000000000000000000;;		p, err := UTF16PtrFromString(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := uint32(100)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			buf := make([]uint16, n)
0000000000000000000000000000000000000000;;			n, err = GetFullPathName(p, uint32(len(buf)), &buf[0], nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n <= uint32(len(buf)) {
0000000000000000000000000000000000000000;;				return UTF16ToString(buf[:n]), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
