0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
372f1bceb3e2da05404dc30071e64aebe6b55b42;;	
0000000000000000000000000000000000000000;;	package windows
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DLLError describes reasons for DLL load failures.
0000000000000000000000000000000000000000;;	type DLLError struct {
0000000000000000000000000000000000000000;;		Err     error
0000000000000000000000000000000000000000;;		ObjName string
0000000000000000000000000000000000000000;;		Msg     string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *DLLError) Error() string { return e.Msg }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implemented in runtime/syscall_windows.goc; we provide jumps to them in our assembly file.
0000000000000000000000000000000000000000;;	func loadlibrary(filename *uint16) (handle uintptr, err syscall.Errno)
0000000000000000000000000000000000000000;;	func getprocaddress(handle uintptr, procname *uint8) (proc uintptr, err syscall.Errno)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A DLL implements access to a single DLL.
0000000000000000000000000000000000000000;;	type DLL struct {
0000000000000000000000000000000000000000;;		Name   string
0000000000000000000000000000000000000000;;		Handle Handle
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadDLL loads DLL file into memory.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Warning: using LoadDLL without an absolute path name is subject to
0000000000000000000000000000000000000000;;	// DLL preloading attacks. To safely load a system DLL, use LazyDLL
0000000000000000000000000000000000000000;;	// with System set to true, or use LoadLibraryEx directly.
0000000000000000000000000000000000000000;;	func LoadDLL(name string) (dll *DLL, err error) {
0000000000000000000000000000000000000000;;		namep, err := UTF16PtrFromString(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h, e := loadlibrary(namep)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			return nil, &DLLError{
0000000000000000000000000000000000000000;;				Err:     e,
0000000000000000000000000000000000000000;;				ObjName: name,
0000000000000000000000000000000000000000;;				Msg:     "Failed to load " + name + ": " + e.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d := &DLL{
0000000000000000000000000000000000000000;;			Name:   name,
0000000000000000000000000000000000000000;;			Handle: Handle(h),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustLoadDLL is like LoadDLL but panics if load operation failes.
0000000000000000000000000000000000000000;;	func MustLoadDLL(name string) *DLL {
0000000000000000000000000000000000000000;;		d, e := LoadDLL(name)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			panic(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindProc searches DLL d for procedure named name and returns *Proc
0000000000000000000000000000000000000000;;	// if found. It returns an error if search fails.
0000000000000000000000000000000000000000;;	func (d *DLL) FindProc(name string) (proc *Proc, err error) {
0000000000000000000000000000000000000000;;		namep, err := BytePtrFromString(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a, e := getprocaddress(uintptr(d.Handle), namep)
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			return nil, &DLLError{
0000000000000000000000000000000000000000;;				Err:     e,
0000000000000000000000000000000000000000;;				ObjName: name,
0000000000000000000000000000000000000000;;				Msg:     "Failed to find " + name + " procedure in " + d.Name + ": " + e.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := &Proc{
0000000000000000000000000000000000000000;;			Dll:  d,
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;			addr: a,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustFindProc is like FindProc but panics if search fails.
0000000000000000000000000000000000000000;;	func (d *DLL) MustFindProc(name string) *Proc {
0000000000000000000000000000000000000000;;		p, e := d.FindProc(name)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			panic(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Release unloads DLL d from memory.
0000000000000000000000000000000000000000;;	func (d *DLL) Release() (err error) {
0000000000000000000000000000000000000000;;		return FreeLibrary(d.Handle)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Proc implements access to a procedure inside a DLL.
0000000000000000000000000000000000000000;;	type Proc struct {
0000000000000000000000000000000000000000;;		Dll  *DLL
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		addr uintptr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Addr returns the address of the procedure represented by p.
0000000000000000000000000000000000000000;;	// The return value can be passed to Syscall to run the procedure.
0000000000000000000000000000000000000000;;	func (p *Proc) Addr() uintptr {
0000000000000000000000000000000000000000;;		return p.addr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:uintptrescapes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Call executes procedure p with arguments a. It will panic, if more then 15 arguments
0000000000000000000000000000000000000000;;	// are supplied.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The returned error is always non-nil, constructed from the result of GetLastError.
0000000000000000000000000000000000000000;;	// Callers must inspect the primary return value to decide whether an error occurred
0000000000000000000000000000000000000000;;	// (according to the semantics of the specific function being called) before consulting
0000000000000000000000000000000000000000;;	// the error. The error will be guaranteed to contain windows.Errno.
0000000000000000000000000000000000000000;;	func (p *Proc) Call(a ...uintptr) (r1, r2 uintptr, lastErr error) {
0000000000000000000000000000000000000000;;		switch len(a) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return syscall.Syscall(p.Addr(), uintptr(len(a)), 0, 0, 0)
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			return syscall.Syscall(p.Addr(), uintptr(len(a)), a[0], 0, 0)
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			return syscall.Syscall(p.Addr(), uintptr(len(a)), a[0], a[1], 0)
0000000000000000000000000000000000000000;;		case 3:
0000000000000000000000000000000000000000;;			return syscall.Syscall(p.Addr(), uintptr(len(a)), a[0], a[1], a[2])
0000000000000000000000000000000000000000;;		case 4:
0000000000000000000000000000000000000000;;			return syscall.Syscall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], 0, 0)
0000000000000000000000000000000000000000;;		case 5:
0000000000000000000000000000000000000000;;			return syscall.Syscall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], 0)
0000000000000000000000000000000000000000;;		case 6:
0000000000000000000000000000000000000000;;			return syscall.Syscall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5])
0000000000000000000000000000000000000000;;		case 7:
0000000000000000000000000000000000000000;;			return syscall.Syscall9(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], 0, 0)
0000000000000000000000000000000000000000;;		case 8:
0000000000000000000000000000000000000000;;			return syscall.Syscall9(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], 0)
0000000000000000000000000000000000000000;;		case 9:
0000000000000000000000000000000000000000;;			return syscall.Syscall9(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])
0000000000000000000000000000000000000000;;		case 10:
0000000000000000000000000000000000000000;;			return syscall.Syscall12(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], 0, 0)
0000000000000000000000000000000000000000;;		case 11:
0000000000000000000000000000000000000000;;			return syscall.Syscall12(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], 0)
0000000000000000000000000000000000000000;;		case 12:
0000000000000000000000000000000000000000;;			return syscall.Syscall12(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11])
0000000000000000000000000000000000000000;;		case 13:
0000000000000000000000000000000000000000;;			return syscall.Syscall15(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], 0, 0)
0000000000000000000000000000000000000000;;		case 14:
0000000000000000000000000000000000000000;;			return syscall.Syscall15(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], 0)
0000000000000000000000000000000000000000;;		case 15:
0000000000000000000000000000000000000000;;			return syscall.Syscall15(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14])
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("Call " + p.Name + " with too many arguments " + itoa(len(a)) + ".")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A LazyDLL implements access to a single DLL.
0000000000000000000000000000000000000000;;	// It will delay the load of the DLL until the first
0000000000000000000000000000000000000000;;	// call to its Handle method or to one of its
0000000000000000000000000000000000000000;;	// LazyProc's Addr method.
0000000000000000000000000000000000000000;;	type LazyDLL struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// System determines whether the DLL must be loaded from the
0000000000000000000000000000000000000000;;		// Windows System directory, bypassing the normal DLL search
0000000000000000000000000000000000000000;;		// path.
0000000000000000000000000000000000000000;;		System bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu  sync.Mutex
0000000000000000000000000000000000000000;;		dll *DLL // non nil once DLL is loaded
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Load loads DLL file d.Name into memory. It returns an error if fails.
0000000000000000000000000000000000000000;;	// Load will not try to load DLL, if it is already loaded into memory.
0000000000000000000000000000000000000000;;	func (d *LazyDLL) Load() error {
0000000000000000000000000000000000000000;;		// Non-racy version of:
0000000000000000000000000000000000000000;;		// if d.dll != nil {
0000000000000000000000000000000000000000;;		if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&d.dll))) != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.mu.Lock()
0000000000000000000000000000000000000000;;		defer d.mu.Unlock()
0000000000000000000000000000000000000000;;		if d.dll != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// kernel32.dll is special, since it's where LoadLibraryEx comes from.
0000000000000000000000000000000000000000;;		// The kernel already special-cases its name, so it's always
0000000000000000000000000000000000000000;;		// loaded from system32.
0000000000000000000000000000000000000000;;		var dll *DLL
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if d.Name == "kernel32.dll" {
0000000000000000000000000000000000000000;;			dll, err = LoadDLL(d.Name)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dll, err = loadLibraryEx(d.Name, d.System)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Non-racy version of:
0000000000000000000000000000000000000000;;		// d.dll = dll
0000000000000000000000000000000000000000;;		atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&d.dll)), unsafe.Pointer(dll))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mustLoad is like Load but panics if search fails.
0000000000000000000000000000000000000000;;	func (d *LazyDLL) mustLoad() {
0000000000000000000000000000000000000000;;		e := d.Load()
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			panic(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handle returns d's module handle.
0000000000000000000000000000000000000000;;	func (d *LazyDLL) Handle() uintptr {
0000000000000000000000000000000000000000;;		d.mustLoad()
0000000000000000000000000000000000000000;;		return uintptr(d.dll.Handle)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProc returns a LazyProc for accessing the named procedure in the DLL d.
0000000000000000000000000000000000000000;;	func (d *LazyDLL) NewProc(name string) *LazyProc {
0000000000000000000000000000000000000000;;		return &LazyProc{l: d, Name: name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLazyDLL creates new LazyDLL associated with DLL file.
0000000000000000000000000000000000000000;;	func NewLazyDLL(name string) *LazyDLL {
0000000000000000000000000000000000000000;;		return &LazyDLL{Name: name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLazySystemDLL is like NewLazyDLL, but will only
0000000000000000000000000000000000000000;;	// search Windows System directory for the DLL if name is
0000000000000000000000000000000000000000;;	// a base name (like "advapi32.dll").
0000000000000000000000000000000000000000;;	func NewLazySystemDLL(name string) *LazyDLL {
0000000000000000000000000000000000000000;;		return &LazyDLL{Name: name, System: true}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A LazyProc implements access to a procedure inside a LazyDLL.
0000000000000000000000000000000000000000;;	// It delays the lookup until the Addr method is called.
0000000000000000000000000000000000000000;;	type LazyProc struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu   sync.Mutex
0000000000000000000000000000000000000000;;		l    *LazyDLL
0000000000000000000000000000000000000000;;		proc *Proc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find searches DLL for procedure named p.Name. It returns
0000000000000000000000000000000000000000;;	// an error if search fails. Find will not search procedure,
0000000000000000000000000000000000000000;;	// if it is already found and loaded into memory.
0000000000000000000000000000000000000000;;	func (p *LazyProc) Find() error {
0000000000000000000000000000000000000000;;		// Non-racy version of:
0000000000000000000000000000000000000000;;		// if p.proc == nil {
0000000000000000000000000000000000000000;;		if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc))) == nil {
0000000000000000000000000000000000000000;;			p.mu.Lock()
0000000000000000000000000000000000000000;;			defer p.mu.Unlock()
0000000000000000000000000000000000000000;;			if p.proc == nil {
0000000000000000000000000000000000000000;;				e := p.l.Load()
0000000000000000000000000000000000000000;;				if e != nil {
0000000000000000000000000000000000000000;;					return e
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				proc, e := p.l.dll.FindProc(p.Name)
0000000000000000000000000000000000000000;;				if e != nil {
0000000000000000000000000000000000000000;;					return e
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Non-racy version of:
0000000000000000000000000000000000000000;;				// p.proc = proc
0000000000000000000000000000000000000000;;				atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc)), unsafe.Pointer(proc))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mustFind is like Find but panics if search fails.
0000000000000000000000000000000000000000;;	func (p *LazyProc) mustFind() {
0000000000000000000000000000000000000000;;		e := p.Find()
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			panic(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Addr returns the address of the procedure represented by p.
0000000000000000000000000000000000000000;;	// The return value can be passed to Syscall to run the procedure.
0000000000000000000000000000000000000000;;	func (p *LazyProc) Addr() uintptr {
0000000000000000000000000000000000000000;;		p.mustFind()
0000000000000000000000000000000000000000;;		return p.proc.Addr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:uintptrescapes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Call executes procedure p with arguments a. It will panic, if more then 15 arguments
0000000000000000000000000000000000000000;;	// are supplied.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The returned error is always non-nil, constructed from the result of GetLastError.
0000000000000000000000000000000000000000;;	// Callers must inspect the primary return value to decide whether an error occurred
0000000000000000000000000000000000000000;;	// (according to the semantics of the specific function being called) before consulting
0000000000000000000000000000000000000000;;	// the error. The error will be guaranteed to contain windows.Errno.
0000000000000000000000000000000000000000;;	func (p *LazyProc) Call(a ...uintptr) (r1, r2 uintptr, lastErr error) {
0000000000000000000000000000000000000000;;		p.mustFind()
0000000000000000000000000000000000000000;;		return p.proc.Call(a...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var canDoSearchSystem32Once struct {
0000000000000000000000000000000000000000;;		sync.Once
0000000000000000000000000000000000000000;;		v bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initCanDoSearchSystem32() {
0000000000000000000000000000000000000000;;		// https://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx says:
0000000000000000000000000000000000000000;;		// "Windows 7, Windows Server 2008 R2, Windows Vista, and Windows
0000000000000000000000000000000000000000;;		// Server 2008: The LOAD_LIBRARY_SEARCH_* flags are available on
0000000000000000000000000000000000000000;;		// systems that have KB2533623 installed. To determine whether the
0000000000000000000000000000000000000000;;		// flags are available, use GetProcAddress to get the address of the
0000000000000000000000000000000000000000;;		// AddDllDirectory, RemoveDllDirectory, or SetDefaultDllDirectories
0000000000000000000000000000000000000000;;		// function. If GetProcAddress succeeds, the LOAD_LIBRARY_SEARCH_*
0000000000000000000000000000000000000000;;		// flags can be used with LoadLibraryEx."
0000000000000000000000000000000000000000;;		canDoSearchSystem32Once.v = (modkernel32.NewProc("AddDllDirectory").Find() == nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func canDoSearchSystem32() bool {
0000000000000000000000000000000000000000;;		canDoSearchSystem32Once.Do(initCanDoSearchSystem32)
0000000000000000000000000000000000000000;;		return canDoSearchSystem32Once.v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isBaseName(name string) bool {
0000000000000000000000000000000000000000;;		for _, c := range name {
0000000000000000000000000000000000000000;;			if c == ':' || c == '/' || c == '\\' {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loadLibraryEx wraps the Windows LoadLibraryEx function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If name is not an absolute path, LoadLibraryEx searches for the DLL
0000000000000000000000000000000000000000;;	// in a variety of automatic locations unless constrained by flags.
0000000000000000000000000000000000000000;;	// See: https://msdn.microsoft.com/en-us/library/ff919712%28VS.85%29.aspx
0000000000000000000000000000000000000000;;	func loadLibraryEx(name string, system bool) (*DLL, error) {
0000000000000000000000000000000000000000;;		loadDLL := name
0000000000000000000000000000000000000000;;		var flags uintptr
0000000000000000000000000000000000000000;;		if system {
0000000000000000000000000000000000000000;;			if canDoSearchSystem32() {
0000000000000000000000000000000000000000;;				const LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
0000000000000000000000000000000000000000;;				flags = LOAD_LIBRARY_SEARCH_SYSTEM32
0000000000000000000000000000000000000000;;			} else if isBaseName(name) {
0000000000000000000000000000000000000000;;				// WindowsXP or unpatched Windows machine
0000000000000000000000000000000000000000;;				// trying to load "foo.dll" out of the system
0000000000000000000000000000000000000000;;				// folder, but LoadLibraryEx doesn't support
0000000000000000000000000000000000000000;;				// that yet on their system, so emulate it.
0000000000000000000000000000000000000000;;				windir, _ := Getenv("WINDIR") // old var; apparently works on XP
0000000000000000000000000000000000000000;;				if windir == "" {
0000000000000000000000000000000000000000;;					return nil, errString("%WINDIR% not defined")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				loadDLL = windir + "\\System32\\" + name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h, err := LoadLibraryEx(loadDLL, 0, flags)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &DLL{Name: name, Handle: h}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errString string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s errString) Error() string { return string(s) }
