0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
372f1bceb3e2da05404dc30071e64aebe6b55b42;;	
0000000000000000000000000000000000000000;;	package windows
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		STANDARD_RIGHTS_REQUIRED = 0xf0000
0000000000000000000000000000000000000000;;		STANDARD_RIGHTS_READ     = 0x20000
0000000000000000000000000000000000000000;;		STANDARD_RIGHTS_WRITE    = 0x20000
0000000000000000000000000000000000000000;;		STANDARD_RIGHTS_EXECUTE  = 0x20000
0000000000000000000000000000000000000000;;		STANDARD_RIGHTS_ALL      = 0x1F0000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NameUnknown          = 0
0000000000000000000000000000000000000000;;		NameFullyQualifiedDN = 1
0000000000000000000000000000000000000000;;		NameSamCompatible    = 2
0000000000000000000000000000000000000000;;		NameDisplay          = 3
0000000000000000000000000000000000000000;;		NameUniqueId         = 6
0000000000000000000000000000000000000000;;		NameCanonical        = 7
0000000000000000000000000000000000000000;;		NameUserPrincipal    = 8
0000000000000000000000000000000000000000;;		NameCanonicalEx      = 9
0000000000000000000000000000000000000000;;		NameServicePrincipal = 10
0000000000000000000000000000000000000000;;		NameDnsDomain        = 12
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.
0000000000000000000000000000000000000000;;	// http://blogs.msdn.com/b/drnick/archive/2007/12/19/windows-and-upn-format-credentials.aspx
0000000000000000000000000000000000000000;;	//sys	TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) [failretval&0xff==0] = secur32.TranslateNameW
0000000000000000000000000000000000000000;;	//sys	GetUserNameEx(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error) [failretval&0xff==0] = secur32.GetUserNameExW
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TranslateAccountName converts a directory service
0000000000000000000000000000000000000000;;	// object name from one format to another.
0000000000000000000000000000000000000000;;	func TranslateAccountName(username string, from, to uint32, initSize int) (string, error) {
0000000000000000000000000000000000000000;;		u, e := UTF16PtrFromString(username)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return "", e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := uint32(50)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			b := make([]uint16, n)
0000000000000000000000000000000000000000;;			e = TranslateName(u, from, to, &b[0], &n)
0000000000000000000000000000000000000000;;			if e == nil {
0000000000000000000000000000000000000000;;				return UTF16ToString(b[:n]), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e != ERROR_INSUFFICIENT_BUFFER {
0000000000000000000000000000000000000000;;				return "", e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n <= uint32(len(b)) {
0000000000000000000000000000000000000000;;				return "", e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// do not reorder
0000000000000000000000000000000000000000;;		NetSetupUnknownStatus = iota
0000000000000000000000000000000000000000;;		NetSetupUnjoined
0000000000000000000000000000000000000000;;		NetSetupWorkgroupName
0000000000000000000000000000000000000000;;		NetSetupDomainName
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UserInfo10 struct {
0000000000000000000000000000000000000000;;		Name       *uint16
0000000000000000000000000000000000000000;;		Comment    *uint16
0000000000000000000000000000000000000000;;		UsrComment *uint16
0000000000000000000000000000000000000000;;		FullName   *uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	NetUserGetInfo(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error) = netapi32.NetUserGetInfo
0000000000000000000000000000000000000000;;	//sys	NetGetJoinInformation(server *uint16, name **uint16, bufType *uint32) (neterr error) = netapi32.NetGetJoinInformation
0000000000000000000000000000000000000000;;	//sys	NetApiBufferFree(buf *byte) (neterr error) = netapi32.NetApiBufferFree
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// do not reorder
0000000000000000000000000000000000000000;;		SidTypeUser = 1 + iota
0000000000000000000000000000000000000000;;		SidTypeGroup
0000000000000000000000000000000000000000;;		SidTypeDomain
0000000000000000000000000000000000000000;;		SidTypeAlias
0000000000000000000000000000000000000000;;		SidTypeWellKnownGroup
0000000000000000000000000000000000000000;;		SidTypeDeletedAccount
0000000000000000000000000000000000000000;;		SidTypeInvalid
0000000000000000000000000000000000000000;;		SidTypeUnknown
0000000000000000000000000000000000000000;;		SidTypeComputer
0000000000000000000000000000000000000000;;		SidTypeLabel
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SidIdentifierAuthority struct {
0000000000000000000000000000000000000000;;		Value [6]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		SECURITY_NULL_SID_AUTHORITY        = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 0}}
0000000000000000000000000000000000000000;;		SECURITY_WORLD_SID_AUTHORITY       = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 1}}
0000000000000000000000000000000000000000;;		SECURITY_LOCAL_SID_AUTHORITY       = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 2}}
0000000000000000000000000000000000000000;;		SECURITY_CREATOR_SID_AUTHORITY     = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 3}}
0000000000000000000000000000000000000000;;		SECURITY_NON_UNIQUE_AUTHORITY      = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 4}}
0000000000000000000000000000000000000000;;		SECURITY_NT_AUTHORITY              = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 5}}
0000000000000000000000000000000000000000;;		SECURITY_MANDATORY_LABEL_AUTHORITY = SidIdentifierAuthority{[6]byte{0, 0, 0, 0, 0, 16}}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SECURITY_NULL_RID                   = 0
0000000000000000000000000000000000000000;;		SECURITY_WORLD_RID                  = 0
0000000000000000000000000000000000000000;;		SECURITY_LOCAL_RID                  = 0
0000000000000000000000000000000000000000;;		SECURITY_CREATOR_OWNER_RID          = 0
0000000000000000000000000000000000000000;;		SECURITY_CREATOR_GROUP_RID          = 1
0000000000000000000000000000000000000000;;		SECURITY_DIALUP_RID                 = 1
0000000000000000000000000000000000000000;;		SECURITY_NETWORK_RID                = 2
0000000000000000000000000000000000000000;;		SECURITY_BATCH_RID                  = 3
0000000000000000000000000000000000000000;;		SECURITY_INTERACTIVE_RID            = 4
0000000000000000000000000000000000000000;;		SECURITY_LOGON_IDS_RID              = 5
0000000000000000000000000000000000000000;;		SECURITY_SERVICE_RID                = 6
0000000000000000000000000000000000000000;;		SECURITY_LOCAL_SYSTEM_RID           = 18
0000000000000000000000000000000000000000;;		SECURITY_BUILTIN_DOMAIN_RID         = 32
0000000000000000000000000000000000000000;;		SECURITY_PRINCIPAL_SELF_RID         = 10
0000000000000000000000000000000000000000;;		SECURITY_CREATOR_OWNER_SERVER_RID   = 0x2
0000000000000000000000000000000000000000;;		SECURITY_CREATOR_GROUP_SERVER_RID   = 0x3
0000000000000000000000000000000000000000;;		SECURITY_LOGON_IDS_RID_COUNT        = 0x3
0000000000000000000000000000000000000000;;		SECURITY_ANONYMOUS_LOGON_RID        = 0x7
0000000000000000000000000000000000000000;;		SECURITY_PROXY_RID                  = 0x8
0000000000000000000000000000000000000000;;		SECURITY_ENTERPRISE_CONTROLLERS_RID = 0x9
0000000000000000000000000000000000000000;;		SECURITY_SERVER_LOGON_RID           = SECURITY_ENTERPRISE_CONTROLLERS_RID
0000000000000000000000000000000000000000;;		SECURITY_AUTHENTICATED_USER_RID     = 0xb
0000000000000000000000000000000000000000;;		SECURITY_RESTRICTED_CODE_RID        = 0xc
0000000000000000000000000000000000000000;;		SECURITY_NT_NON_UNIQUE_RID          = 0x15
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountSidW
0000000000000000000000000000000000000000;;	//sys	LookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountNameW
0000000000000000000000000000000000000000;;	//sys	ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) = advapi32.ConvertSidToStringSidW
0000000000000000000000000000000000000000;;	//sys	ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) = advapi32.ConvertStringSidToSidW
0000000000000000000000000000000000000000;;	//sys	GetLengthSid(sid *SID) (len uint32) = advapi32.GetLengthSid
0000000000000000000000000000000000000000;;	//sys	CopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error) = advapi32.CopySid
0000000000000000000000000000000000000000;;	//sys	AllocateAndInitializeSid(identAuth *SidIdentifierAuthority, subAuth byte, subAuth0 uint32, subAuth1 uint32, subAuth2 uint32, subAuth3 uint32, subAuth4 uint32, subAuth5 uint32, subAuth6 uint32, subAuth7 uint32, sid **SID) (err error) = advapi32.AllocateAndInitializeSid
0000000000000000000000000000000000000000;;	//sys	FreeSid(sid *SID) (err error) [failretval!=0] = advapi32.FreeSid
0000000000000000000000000000000000000000;;	//sys	EqualSid(sid1 *SID, sid2 *SID) (isEqual bool) = advapi32.EqualSid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The security identifier (SID) structure is a variable-length
0000000000000000000000000000000000000000;;	// structure used to uniquely identify users or groups.
0000000000000000000000000000000000000000;;	type SID struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringToSid converts a string-format security identifier
0000000000000000000000000000000000000000;;	// sid into a valid, functional sid.
0000000000000000000000000000000000000000;;	func StringToSid(s string) (*SID, error) {
0000000000000000000000000000000000000000;;		var sid *SID
0000000000000000000000000000000000000000;;		p, e := UTF16PtrFromString(s)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e = ConvertStringSidToSid(p, &sid)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer LocalFree((Handle)(unsafe.Pointer(sid)))
0000000000000000000000000000000000000000;;		return sid.Copy()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupSID retrieves a security identifier sid for the account
0000000000000000000000000000000000000000;;	// and the name of the domain on which the account was found.
0000000000000000000000000000000000000000;;	// System specify target computer to search.
0000000000000000000000000000000000000000;;	func LookupSID(system, account string) (sid *SID, domain string, accType uint32, err error) {
0000000000000000000000000000000000000000;;		if len(account) == 0 {
0000000000000000000000000000000000000000;;			return nil, "", 0, syscall.EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		acc, e := UTF16PtrFromString(account)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, "", 0, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var sys *uint16
0000000000000000000000000000000000000000;;		if len(system) > 0 {
0000000000000000000000000000000000000000;;			sys, e = UTF16PtrFromString(system)
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				return nil, "", 0, e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := uint32(50)
0000000000000000000000000000000000000000;;		dn := uint32(50)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			b := make([]byte, n)
0000000000000000000000000000000000000000;;			db := make([]uint16, dn)
0000000000000000000000000000000000000000;;			sid = (*SID)(unsafe.Pointer(&b[0]))
0000000000000000000000000000000000000000;;			e = LookupAccountName(sys, acc, sid, &n, &db[0], &dn, &accType)
0000000000000000000000000000000000000000;;			if e == nil {
0000000000000000000000000000000000000000;;				return sid, UTF16ToString(db), accType, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e != ERROR_INSUFFICIENT_BUFFER {
0000000000000000000000000000000000000000;;				return nil, "", 0, e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n <= uint32(len(b)) {
0000000000000000000000000000000000000000;;				return nil, "", 0, e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String converts sid to a string format
0000000000000000000000000000000000000000;;	// suitable for display, storage, or transmission.
0000000000000000000000000000000000000000;;	func (sid *SID) String() (string, error) {
0000000000000000000000000000000000000000;;		var s *uint16
0000000000000000000000000000000000000000;;		e := ConvertSidToStringSid(sid, &s)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return "", e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer LocalFree((Handle)(unsafe.Pointer(s)))
0000000000000000000000000000000000000000;;		return UTF16ToString((*[256]uint16)(unsafe.Pointer(s))[:]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the length, in bytes, of a valid security identifier sid.
0000000000000000000000000000000000000000;;	func (sid *SID) Len() int {
0000000000000000000000000000000000000000;;		return int(GetLengthSid(sid))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy creates a duplicate of security identifier sid.
0000000000000000000000000000000000000000;;	func (sid *SID) Copy() (*SID, error) {
0000000000000000000000000000000000000000;;		b := make([]byte, sid.Len())
0000000000000000000000000000000000000000;;		sid2 := (*SID)(unsafe.Pointer(&b[0]))
0000000000000000000000000000000000000000;;		e := CopySid(uint32(len(b)), sid2, sid)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sid2, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupAccount retrieves the name of the account for this sid
0000000000000000000000000000000000000000;;	// and the name of the first domain on which this sid is found.
0000000000000000000000000000000000000000;;	// System specify target computer to search for.
0000000000000000000000000000000000000000;;	func (sid *SID) LookupAccount(system string) (account, domain string, accType uint32, err error) {
0000000000000000000000000000000000000000;;		var sys *uint16
0000000000000000000000000000000000000000;;		if len(system) > 0 {
0000000000000000000000000000000000000000;;			sys, err = UTF16PtrFromString(system)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", "", 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := uint32(50)
0000000000000000000000000000000000000000;;		dn := uint32(50)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			b := make([]uint16, n)
0000000000000000000000000000000000000000;;			db := make([]uint16, dn)
0000000000000000000000000000000000000000;;			e := LookupAccountSid(sys, sid, &b[0], &n, &db[0], &dn, &accType)
0000000000000000000000000000000000000000;;			if e == nil {
0000000000000000000000000000000000000000;;				return UTF16ToString(b), UTF16ToString(db), accType, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e != ERROR_INSUFFICIENT_BUFFER {
0000000000000000000000000000000000000000;;				return "", "", 0, e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n <= uint32(len(b)) {
0000000000000000000000000000000000000000;;				return "", "", 0, e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// do not reorder
0000000000000000000000000000000000000000;;		TOKEN_ASSIGN_PRIMARY = 1 << iota
0000000000000000000000000000000000000000;;		TOKEN_DUPLICATE
0000000000000000000000000000000000000000;;		TOKEN_IMPERSONATE
0000000000000000000000000000000000000000;;		TOKEN_QUERY
0000000000000000000000000000000000000000;;		TOKEN_QUERY_SOURCE
0000000000000000000000000000000000000000;;		TOKEN_ADJUST_PRIVILEGES
0000000000000000000000000000000000000000;;		TOKEN_ADJUST_GROUPS
0000000000000000000000000000000000000000;;		TOKEN_ADJUST_DEFAULT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED |
0000000000000000000000000000000000000000;;			TOKEN_ASSIGN_PRIMARY |
0000000000000000000000000000000000000000;;			TOKEN_DUPLICATE |
0000000000000000000000000000000000000000;;			TOKEN_IMPERSONATE |
0000000000000000000000000000000000000000;;			TOKEN_QUERY |
0000000000000000000000000000000000000000;;			TOKEN_QUERY_SOURCE |
0000000000000000000000000000000000000000;;			TOKEN_ADJUST_PRIVILEGES |
0000000000000000000000000000000000000000;;			TOKEN_ADJUST_GROUPS |
0000000000000000000000000000000000000000;;			TOKEN_ADJUST_DEFAULT
0000000000000000000000000000000000000000;;		TOKEN_READ  = STANDARD_RIGHTS_READ | TOKEN_QUERY
0000000000000000000000000000000000000000;;		TOKEN_WRITE = STANDARD_RIGHTS_WRITE |
0000000000000000000000000000000000000000;;			TOKEN_ADJUST_PRIVILEGES |
0000000000000000000000000000000000000000;;			TOKEN_ADJUST_GROUPS |
0000000000000000000000000000000000000000;;			TOKEN_ADJUST_DEFAULT
0000000000000000000000000000000000000000;;		TOKEN_EXECUTE = STANDARD_RIGHTS_EXECUTE
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// do not reorder
0000000000000000000000000000000000000000;;		TokenUser = 1 + iota
0000000000000000000000000000000000000000;;		TokenGroups
0000000000000000000000000000000000000000;;		TokenPrivileges
0000000000000000000000000000000000000000;;		TokenOwner
0000000000000000000000000000000000000000;;		TokenPrimaryGroup
0000000000000000000000000000000000000000;;		TokenDefaultDacl
0000000000000000000000000000000000000000;;		TokenSource
0000000000000000000000000000000000000000;;		TokenType
0000000000000000000000000000000000000000;;		TokenImpersonationLevel
0000000000000000000000000000000000000000;;		TokenStatistics
0000000000000000000000000000000000000000;;		TokenRestrictedSids
0000000000000000000000000000000000000000;;		TokenSessionId
0000000000000000000000000000000000000000;;		TokenGroupsAndPrivileges
0000000000000000000000000000000000000000;;		TokenSessionReference
0000000000000000000000000000000000000000;;		TokenSandBoxInert
0000000000000000000000000000000000000000;;		TokenAuditPolicy
0000000000000000000000000000000000000000;;		TokenOrigin
0000000000000000000000000000000000000000;;		TokenElevationType
0000000000000000000000000000000000000000;;		TokenLinkedToken
0000000000000000000000000000000000000000;;		TokenElevation
0000000000000000000000000000000000000000;;		TokenHasRestrictions
0000000000000000000000000000000000000000;;		TokenAccessInformation
0000000000000000000000000000000000000000;;		TokenVirtualizationAllowed
0000000000000000000000000000000000000000;;		TokenVirtualizationEnabled
0000000000000000000000000000000000000000;;		TokenIntegrityLevel
0000000000000000000000000000000000000000;;		TokenUIAccess
0000000000000000000000000000000000000000;;		TokenMandatoryPolicy
0000000000000000000000000000000000000000;;		TokenLogonSid
0000000000000000000000000000000000000000;;		MaxTokenInfoClass
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SIDAndAttributes struct {
0000000000000000000000000000000000000000;;		Sid        *SID
0000000000000000000000000000000000000000;;		Attributes uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Tokenuser struct {
0000000000000000000000000000000000000000;;		User SIDAndAttributes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Tokenprimarygroup struct {
0000000000000000000000000000000000000000;;		PrimaryGroup *SID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Tokengroups struct {
0000000000000000000000000000000000000000;;		GroupCount uint32
0000000000000000000000000000000000000000;;		Groups     [1]SIDAndAttributes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys	OpenProcessToken(h Handle, access uint32, token *Token) (err error) = advapi32.OpenProcessToken
0000000000000000000000000000000000000000;;	//sys	GetTokenInformation(t Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) = advapi32.GetTokenInformation
0000000000000000000000000000000000000000;;	//sys	GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) = userenv.GetUserProfileDirectoryW
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An access token contains the security information for a logon session.
0000000000000000000000000000000000000000;;	// The system creates an access token when a user logs on, and every
0000000000000000000000000000000000000000;;	// process executed on behalf of the user has a copy of the token.
0000000000000000000000000000000000000000;;	// The token identifies the user, the user's groups, and the user's
0000000000000000000000000000000000000000;;	// privileges. The system uses the token to control access to securable
0000000000000000000000000000000000000000;;	// objects and to control the ability of the user to perform various
0000000000000000000000000000000000000000;;	// system-related operations on the local computer.
0000000000000000000000000000000000000000;;	type Token Handle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenCurrentProcessToken opens the access token
0000000000000000000000000000000000000000;;	// associated with current process.
0000000000000000000000000000000000000000;;	func OpenCurrentProcessToken() (Token, error) {
0000000000000000000000000000000000000000;;		p, e := GetCurrentProcess()
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return 0, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var t Token
0000000000000000000000000000000000000000;;		e = OpenProcessToken(p, TOKEN_QUERY, &t)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return 0, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close releases access to access token.
0000000000000000000000000000000000000000;;	func (t Token) Close() error {
0000000000000000000000000000000000000000;;		return CloseHandle(Handle(t))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getInfo retrieves a specified type of information about an access token.
0000000000000000000000000000000000000000;;	func (t Token) getInfo(class uint32, initSize int) (unsafe.Pointer, error) {
0000000000000000000000000000000000000000;;		n := uint32(initSize)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			b := make([]byte, n)
0000000000000000000000000000000000000000;;			e := GetTokenInformation(t, class, &b[0], uint32(len(b)), &n)
0000000000000000000000000000000000000000;;			if e == nil {
0000000000000000000000000000000000000000;;				return unsafe.Pointer(&b[0]), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e != ERROR_INSUFFICIENT_BUFFER {
0000000000000000000000000000000000000000;;				return nil, e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n <= uint32(len(b)) {
0000000000000000000000000000000000000000;;				return nil, e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTokenUser retrieves access token t user account information.
0000000000000000000000000000000000000000;;	func (t Token) GetTokenUser() (*Tokenuser, error) {
0000000000000000000000000000000000000000;;		i, e := t.getInfo(TokenUser, 50)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (*Tokenuser)(i), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTokenGroups retrieves group accounts associated with access token t.
0000000000000000000000000000000000000000;;	func (t Token) GetTokenGroups() (*Tokengroups, error) {
0000000000000000000000000000000000000000;;		i, e := t.getInfo(TokenGroups, 50)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (*Tokengroups)(i), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTokenPrimaryGroup retrieves access token t primary group information.
0000000000000000000000000000000000000000;;	// A pointer to a SID structure representing a group that will become
0000000000000000000000000000000000000000;;	// the primary group of any objects created by a process using this access token.
0000000000000000000000000000000000000000;;	func (t Token) GetTokenPrimaryGroup() (*Tokenprimarygroup, error) {
0000000000000000000000000000000000000000;;		i, e := t.getInfo(TokenPrimaryGroup, 50)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (*Tokenprimarygroup)(i), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUserProfileDirectory retrieves path to the
0000000000000000000000000000000000000000;;	// root directory of the access token t user's profile.
0000000000000000000000000000000000000000;;	func (t Token) GetUserProfileDirectory() (string, error) {
0000000000000000000000000000000000000000;;		n := uint32(100)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			b := make([]uint16, n)
0000000000000000000000000000000000000000;;			e := GetUserProfileDirectory(t, &b[0], &n)
0000000000000000000000000000000000000000;;			if e == nil {
0000000000000000000000000000000000000000;;				return UTF16ToString(b), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e != ERROR_INSUFFICIENT_BUFFER {
0000000000000000000000000000000000000000;;				return "", e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n <= uint32(len(b)) {
0000000000000000000000000000000000000000;;				return "", e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
