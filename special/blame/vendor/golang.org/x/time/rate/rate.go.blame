0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	// Package rate provides a rate limiter.
0000000000000000000000000000000000000000;;	package rate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Limit defines the maximum frequency of some events.
0000000000000000000000000000000000000000;;	// Limit is represented as number of events per second.
0000000000000000000000000000000000000000;;	// A zero Limit allows no events.
0000000000000000000000000000000000000000;;	type Limit float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Inf is the infinite rate limit; it allows all events (even if burst is zero).
0000000000000000000000000000000000000000;;	const Inf = Limit(math.MaxFloat64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Every converts a minimum time interval between events to a Limit.
0000000000000000000000000000000000000000;;	func Every(interval time.Duration) Limit {
0000000000000000000000000000000000000000;;		if interval <= 0 {
0000000000000000000000000000000000000000;;			return Inf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 1 / Limit(interval.Seconds())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Limiter controls how frequently events are allowed to happen.
0000000000000000000000000000000000000000;;	// It implements a "token bucket" of size b, initially full and refilled
0000000000000000000000000000000000000000;;	// at rate r tokens per second.
0000000000000000000000000000000000000000;;	// Informally, in any large enough time interval, the Limiter limits the
0000000000000000000000000000000000000000;;	// rate to r tokens per second, with a maximum burst size of b events.
0000000000000000000000000000000000000000;;	// As a special case, if r == Inf (the infinite rate), b is ignored.
0000000000000000000000000000000000000000;;	// See https://en.wikipedia.org/wiki/Token_bucket for more about token buckets.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The zero value is a valid Limiter, but it will reject all events.
0000000000000000000000000000000000000000;;	// Use NewLimiter to create non-zero Limiters.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Limiter has three main methods, Allow, Reserve, and Wait.
0000000000000000000000000000000000000000;;	// Most callers should use Wait.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Each of the three methods consumes a single token.
0000000000000000000000000000000000000000;;	// They differ in their behavior when no token is available.
0000000000000000000000000000000000000000;;	// If no token is available, Allow returns false.
0000000000000000000000000000000000000000;;	// If no token is available, Reserve returns a reservation for a future token
0000000000000000000000000000000000000000;;	// and the amount of time the caller must wait before using it.
0000000000000000000000000000000000000000;;	// If no token is available, Wait blocks until one can be obtained
0000000000000000000000000000000000000000;;	// or its associated context.Context is canceled.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The methods AllowN, ReserveN, and WaitN consume n tokens.
0000000000000000000000000000000000000000;;	type Limiter struct {
0000000000000000000000000000000000000000;;		limit Limit
0000000000000000000000000000000000000000;;		burst int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu     sync.Mutex
0000000000000000000000000000000000000000;;		tokens float64
0000000000000000000000000000000000000000;;		// last is the last time the limiter's tokens field was updated
0000000000000000000000000000000000000000;;		last time.Time
0000000000000000000000000000000000000000;;		// lastEvent is the latest time of a rate-limited event (past or future)
0000000000000000000000000000000000000000;;		lastEvent time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Limit returns the maximum overall event rate.
0000000000000000000000000000000000000000;;	func (lim *Limiter) Limit() Limit {
0000000000000000000000000000000000000000;;		lim.mu.Lock()
0000000000000000000000000000000000000000;;		defer lim.mu.Unlock()
0000000000000000000000000000000000000000;;		return lim.limit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Burst returns the maximum burst size. Burst is the maximum number of tokens
0000000000000000000000000000000000000000;;	// that can be consumed in a single call to Allow, Reserve, or Wait, so higher
0000000000000000000000000000000000000000;;	// Burst values allow more events to happen at once.
0000000000000000000000000000000000000000;;	// A zero Burst allows no events, unless limit == Inf.
0000000000000000000000000000000000000000;;	func (lim *Limiter) Burst() int {
0000000000000000000000000000000000000000;;		return lim.burst
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLimiter returns a new Limiter that allows events up to rate r and permits
0000000000000000000000000000000000000000;;	// bursts of at most b tokens.
0000000000000000000000000000000000000000;;	func NewLimiter(r Limit, b int) *Limiter {
0000000000000000000000000000000000000000;;		return &Limiter{
0000000000000000000000000000000000000000;;			limit: r,
0000000000000000000000000000000000000000;;			burst: b,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Allow is shorthand for AllowN(time.Now(), 1).
0000000000000000000000000000000000000000;;	func (lim *Limiter) Allow() bool {
0000000000000000000000000000000000000000;;		return lim.AllowN(time.Now(), 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllowN reports whether n events may happen at time now.
0000000000000000000000000000000000000000;;	// Use this method if you intend to drop / skip events that exceed the rate limit.
0000000000000000000000000000000000000000;;	// Otherwise use Reserve or Wait.
0000000000000000000000000000000000000000;;	func (lim *Limiter) AllowN(now time.Time, n int) bool {
0000000000000000000000000000000000000000;;		return lim.reserveN(now, n, 0).ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Reservation holds information about events that are permitted by a Limiter to happen after a delay.
0000000000000000000000000000000000000000;;	// A Reservation may be canceled, which may enable the Limiter to permit additional events.
0000000000000000000000000000000000000000;;	type Reservation struct {
0000000000000000000000000000000000000000;;		ok        bool
0000000000000000000000000000000000000000;;		lim       *Limiter
0000000000000000000000000000000000000000;;		tokens    int
0000000000000000000000000000000000000000;;		timeToAct time.Time
0000000000000000000000000000000000000000;;		// This is the Limit at reservation time, it can change later.
0000000000000000000000000000000000000000;;		limit Limit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OK returns whether the limiter can provide the requested number of tokens
0000000000000000000000000000000000000000;;	// within the maximum wait time.  If OK is false, Delay returns InfDuration, and
0000000000000000000000000000000000000000;;	// Cancel does nothing.
0000000000000000000000000000000000000000;;	func (r *Reservation) OK() bool {
0000000000000000000000000000000000000000;;		return r.ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delay is shorthand for DelayFrom(time.Now()).
0000000000000000000000000000000000000000;;	func (r *Reservation) Delay() time.Duration {
0000000000000000000000000000000000000000;;		return r.DelayFrom(time.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InfDuration is the duration returned by Delay when a Reservation is not OK.
0000000000000000000000000000000000000000;;	const InfDuration = time.Duration(1<<63 - 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelayFrom returns the duration for which the reservation holder must wait
0000000000000000000000000000000000000000;;	// before taking the reserved action.  Zero duration means act immediately.
0000000000000000000000000000000000000000;;	// InfDuration means the limiter cannot grant the tokens requested in this
0000000000000000000000000000000000000000;;	// Reservation within the maximum wait time.
0000000000000000000000000000000000000000;;	func (r *Reservation) DelayFrom(now time.Time) time.Duration {
0000000000000000000000000000000000000000;;		if !r.ok {
0000000000000000000000000000000000000000;;			return InfDuration
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delay := r.timeToAct.Sub(now)
0000000000000000000000000000000000000000;;		if delay < 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return delay
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cancel is shorthand for CancelAt(time.Now()).
0000000000000000000000000000000000000000;;	func (r *Reservation) Cancel() {
0000000000000000000000000000000000000000;;		r.CancelAt(time.Now())
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CancelAt indicates that the reservation holder will not perform the reserved action
0000000000000000000000000000000000000000;;	// and reverses the effects of this Reservation on the rate limit as much as possible,
0000000000000000000000000000000000000000;;	// considering that other reservations may have already been made.
0000000000000000000000000000000000000000;;	func (r *Reservation) CancelAt(now time.Time) {
0000000000000000000000000000000000000000;;		if !r.ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.lim.mu.Lock()
0000000000000000000000000000000000000000;;		defer r.lim.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.lim.limit == Inf || r.tokens == 0 || r.timeToAct.Before(now) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// calculate tokens to restore
0000000000000000000000000000000000000000;;		// The duration between lim.lastEvent and r.timeToAct tells us how many tokens were reserved
0000000000000000000000000000000000000000;;		// after r was obtained. These tokens should not be restored.
0000000000000000000000000000000000000000;;		restoreTokens := float64(r.tokens) - r.limit.tokensFromDuration(r.lim.lastEvent.Sub(r.timeToAct))
0000000000000000000000000000000000000000;;		if restoreTokens <= 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// advance time to now
0000000000000000000000000000000000000000;;		now, _, tokens := r.lim.advance(now)
0000000000000000000000000000000000000000;;		// calculate new number of tokens
0000000000000000000000000000000000000000;;		tokens += restoreTokens
0000000000000000000000000000000000000000;;		if burst := float64(r.lim.burst); tokens > burst {
0000000000000000000000000000000000000000;;			tokens = burst
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// update state
0000000000000000000000000000000000000000;;		r.lim.last = now
0000000000000000000000000000000000000000;;		r.lim.tokens = tokens
0000000000000000000000000000000000000000;;		if r.timeToAct == r.lim.lastEvent {
0000000000000000000000000000000000000000;;			prevEvent := r.timeToAct.Add(r.limit.durationFromTokens(float64(-r.tokens)))
0000000000000000000000000000000000000000;;			if !prevEvent.Before(now) {
0000000000000000000000000000000000000000;;				r.lim.lastEvent = prevEvent
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reserve is shorthand for ReserveN(time.Now(), 1).
0000000000000000000000000000000000000000;;	func (lim *Limiter) Reserve() *Reservation {
0000000000000000000000000000000000000000;;		return lim.ReserveN(time.Now(), 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReserveN returns a Reservation that indicates how long the caller must wait before n events happen.
0000000000000000000000000000000000000000;;	// The Limiter takes this Reservation into account when allowing future events.
0000000000000000000000000000000000000000;;	// ReserveN returns false if n exceeds the Limiter's burst size.
0000000000000000000000000000000000000000;;	// Usage example:
0000000000000000000000000000000000000000;;	//   r := lim.ReserveN(time.Now(), 1)
0000000000000000000000000000000000000000;;	//   if !r.OK() {
0000000000000000000000000000000000000000;;	//     // Not allowed to act! Did you remember to set lim.burst to be > 0 ?
0000000000000000000000000000000000000000;;	//     return
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//   time.Sleep(r.Delay())
0000000000000000000000000000000000000000;;	//   Act()
0000000000000000000000000000000000000000;;	// Use this method if you wish to wait and slow down in accordance with the rate limit without dropping events.
0000000000000000000000000000000000000000;;	// If you need to respect a deadline or cancel the delay, use Wait instead.
0000000000000000000000000000000000000000;;	// To drop or skip events exceeding rate limit, use Allow instead.
0000000000000000000000000000000000000000;;	func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation {
0000000000000000000000000000000000000000;;		r := lim.reserveN(now, n, InfDuration)
0000000000000000000000000000000000000000;;		return &r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait is shorthand for WaitN(ctx, 1).
0000000000000000000000000000000000000000;;	func (lim *Limiter) Wait(ctx context.Context) (err error) {
0000000000000000000000000000000000000000;;		return lim.WaitN(ctx, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitN blocks until lim permits n events to happen.
0000000000000000000000000000000000000000;;	// It returns an error if n exceeds the Limiter's burst size, the Context is
0000000000000000000000000000000000000000;;	// canceled, or the expected wait time exceeds the Context's Deadline.
0000000000000000000000000000000000000000;;	// The burst limit is ignored if the rate limit is Inf.
0000000000000000000000000000000000000000;;	func (lim *Limiter) WaitN(ctx context.Context, n int) (err error) {
0000000000000000000000000000000000000000;;		if n > lim.burst && lim.limit != Inf {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rate: Wait(n=%d) exceeds limiter's burst %d", n, lim.burst)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Check if ctx is already cancelled
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			return ctx.Err()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Determine wait limit
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		waitLimit := InfDuration
0000000000000000000000000000000000000000;;		if deadline, ok := ctx.Deadline(); ok {
0000000000000000000000000000000000000000;;			waitLimit = deadline.Sub(now)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Reserve
0000000000000000000000000000000000000000;;		r := lim.reserveN(now, n, waitLimit)
0000000000000000000000000000000000000000;;		if !r.ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rate: Wait(n=%d) would exceed context deadline", n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Wait
0000000000000000000000000000000000000000;;		t := time.NewTimer(r.DelayFrom(now))
0000000000000000000000000000000000000000;;		defer t.Stop()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-t.C:
0000000000000000000000000000000000000000;;			// We can proceed.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			// Context was canceled before we could proceed.  Cancel the
0000000000000000000000000000000000000000;;			// reservation, which may permit other events to proceed sooner.
0000000000000000000000000000000000000000;;			r.Cancel()
0000000000000000000000000000000000000000;;			return ctx.Err()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetLimit is shorthand for SetLimitAt(time.Now(), newLimit).
0000000000000000000000000000000000000000;;	func (lim *Limiter) SetLimit(newLimit Limit) {
0000000000000000000000000000000000000000;;		lim.SetLimitAt(time.Now(), newLimit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetLimitAt sets a new Limit for the limiter. The new Limit, and Burst, may be violated
0000000000000000000000000000000000000000;;	// or underutilized by those which reserved (using Reserve or Wait) but did not yet act
0000000000000000000000000000000000000000;;	// before SetLimitAt was called.
0000000000000000000000000000000000000000;;	func (lim *Limiter) SetLimitAt(now time.Time, newLimit Limit) {
0000000000000000000000000000000000000000;;		lim.mu.Lock()
0000000000000000000000000000000000000000;;		defer lim.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now, _, tokens := lim.advance(now)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lim.last = now
0000000000000000000000000000000000000000;;		lim.tokens = tokens
0000000000000000000000000000000000000000;;		lim.limit = newLimit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reserveN is a helper method for AllowN, ReserveN, and WaitN.
0000000000000000000000000000000000000000;;	// maxFutureReserve specifies the maximum reservation wait duration allowed.
0000000000000000000000000000000000000000;;	// reserveN returns Reservation, not *Reservation, to avoid allocation in AllowN and WaitN.
0000000000000000000000000000000000000000;;	func (lim *Limiter) reserveN(now time.Time, n int, maxFutureReserve time.Duration) Reservation {
0000000000000000000000000000000000000000;;		lim.mu.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lim.limit == Inf {
0000000000000000000000000000000000000000;;			lim.mu.Unlock()
0000000000000000000000000000000000000000;;			return Reservation{
0000000000000000000000000000000000000000;;				ok:        true,
0000000000000000000000000000000000000000;;				lim:       lim,
0000000000000000000000000000000000000000;;				tokens:    n,
0000000000000000000000000000000000000000;;				timeToAct: now,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now, last, tokens := lim.advance(now)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Calculate the remaining number of tokens resulting from the request.
0000000000000000000000000000000000000000;;		tokens -= float64(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Calculate the wait duration
0000000000000000000000000000000000000000;;		var waitDuration time.Duration
0000000000000000000000000000000000000000;;		if tokens < 0 {
0000000000000000000000000000000000000000;;			waitDuration = lim.limit.durationFromTokens(-tokens)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decide result
0000000000000000000000000000000000000000;;		ok := n <= lim.burst && waitDuration <= maxFutureReserve
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prepare reservation
0000000000000000000000000000000000000000;;		r := Reservation{
0000000000000000000000000000000000000000;;			ok:    ok,
0000000000000000000000000000000000000000;;			lim:   lim,
0000000000000000000000000000000000000000;;			limit: lim.limit,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			r.tokens = n
0000000000000000000000000000000000000000;;			r.timeToAct = now.Add(waitDuration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update state
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			lim.last = now
0000000000000000000000000000000000000000;;			lim.tokens = tokens
0000000000000000000000000000000000000000;;			lim.lastEvent = r.timeToAct
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			lim.last = last
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lim.mu.Unlock()
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// advance calculates and returns an updated state for lim resulting from the passage of time.
0000000000000000000000000000000000000000;;	// lim is not changed.
0000000000000000000000000000000000000000;;	func (lim *Limiter) advance(now time.Time) (newNow time.Time, newLast time.Time, newTokens float64) {
0000000000000000000000000000000000000000;;		last := lim.last
0000000000000000000000000000000000000000;;		if now.Before(last) {
0000000000000000000000000000000000000000;;			last = now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Avoid making delta overflow below when last is very old.
0000000000000000000000000000000000000000;;		maxElapsed := lim.limit.durationFromTokens(float64(lim.burst) - lim.tokens)
0000000000000000000000000000000000000000;;		elapsed := now.Sub(last)
0000000000000000000000000000000000000000;;		if elapsed > maxElapsed {
0000000000000000000000000000000000000000;;			elapsed = maxElapsed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Calculate the new number of tokens, due to time that passed.
0000000000000000000000000000000000000000;;		delta := lim.limit.tokensFromDuration(elapsed)
0000000000000000000000000000000000000000;;		tokens := lim.tokens + delta
0000000000000000000000000000000000000000;;		if burst := float64(lim.burst); tokens > burst {
0000000000000000000000000000000000000000;;			tokens = burst
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return now, last, tokens
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// durationFromTokens is a unit conversion function from the number of tokens to the duration
0000000000000000000000000000000000000000;;	// of time it takes to accumulate them at a rate of limit tokens per second.
0000000000000000000000000000000000000000;;	func (limit Limit) durationFromTokens(tokens float64) time.Duration {
0000000000000000000000000000000000000000;;		seconds := tokens / float64(limit)
0000000000000000000000000000000000000000;;		return time.Nanosecond * time.Duration(1e9*seconds)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tokensFromDuration is a unit conversion function from a time duration to the number of tokens
0000000000000000000000000000000000000000;;	// which could be accumulated during that duration at a rate of limit tokens per second.
0000000000000000000000000000000000000000;;	func (limit Limit) tokensFromDuration(d time.Duration) float64 {
0000000000000000000000000000000000000000;;		return d.Seconds() * float64(limit)
0000000000000000000000000000000000000000;;	}
