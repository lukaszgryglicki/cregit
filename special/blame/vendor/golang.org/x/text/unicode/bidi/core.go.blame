0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package bidi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "log"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This implementation is a port based on the reference implementation found at:
0000000000000000000000000000000000000000;;	// http://www.unicode.org/Public/PROGRAMS/BidiReferenceJava/
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// described in Unicode Bidirectional Algorithm (UAX #9).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Input:
0000000000000000000000000000000000000000;;	// There are two levels of input to the algorithm, since clients may prefer to
0000000000000000000000000000000000000000;;	// supply some information from out-of-band sources rather than relying on the
0000000000000000000000000000000000000000;;	// default behavior.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - Bidi class array
0000000000000000000000000000000000000000;;	// - Bidi class array, with externally supplied base line direction
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Output:
0000000000000000000000000000000000000000;;	// Output is separated into several stages:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  - levels array over entire paragraph
0000000000000000000000000000000000000000;;	//  - reordering array over entire paragraph
0000000000000000000000000000000000000000;;	//  - levels array over line
0000000000000000000000000000000000000000;;	//  - reordering array over line
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that for conformance to the Unicode Bidirectional Algorithm,
0000000000000000000000000000000000000000;;	// implementations are only required to generate correct reordering and
0000000000000000000000000000000000000000;;	// character directionality (odd or even levels) over a line. Generating
0000000000000000000000000000000000000000;;	// identical level arrays over a line is not required. Bidi explicit format
0000000000000000000000000000000000000000;;	// codes (LRE, RLE, LRO, RLO, PDF) and BN can be assigned arbitrary levels and
0000000000000000000000000000000000000000;;	// positions as long as the rest of the input is properly reordered.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As the algorithm is defined to operate on a single paragraph at a time, this
0000000000000000000000000000000000000000;;	// implementation is written to handle single paragraphs. Thus rule P1 is
0000000000000000000000000000000000000000;;	// presumed by this implementation-- the data provided to the implementation is
0000000000000000000000000000000000000000;;	// assumed to be a single paragraph, and either contains no 'B' codes, or a
0000000000000000000000000000000000000000;;	// single 'B' code at the end of the input. 'B' is allowed as input to
0000000000000000000000000000000000000000;;	// illustrate how the algorithm assigns it a level.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Also note that rules L3 and L4 depend on the rendering engine that uses the
0000000000000000000000000000000000000000;;	// result of the bidi algorithm. This implementation assumes that the rendering
0000000000000000000000000000000000000000;;	// engine expects combining marks in visual order (e.g. to the left of their
0000000000000000000000000000000000000000;;	// base character in RTL runs) and that it adjusts the glyphs used to render
0000000000000000000000000000000000000000;;	// mirrored characters that are in RTL runs so that they render appropriately.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// level is the embedding level of a character. Even embedding levels indicate
0000000000000000000000000000000000000000;;	// left-to-right order and odd levels indicate right-to-left order. The special
0000000000000000000000000000000000000000;;	// level of -1 is reserved for undefined order.
0000000000000000000000000000000000000000;;	type level int8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const implicitLevel level = -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// in returns if x is equal to any of the values in set.
0000000000000000000000000000000000000000;;	func (c Class) in(set ...Class) bool {
0000000000000000000000000000000000000000;;		for _, s := range set {
0000000000000000000000000000000000000000;;			if c == s {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A paragraph contains the state of a paragraph.
0000000000000000000000000000000000000000;;	type paragraph struct {
0000000000000000000000000000000000000000;;		initialTypes []Class
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Arrays of properties needed for paired bracket evaluation in N0
0000000000000000000000000000000000000000;;		pairTypes  []bracketType // paired Bracket types for paragraph
0000000000000000000000000000000000000000;;		pairValues []rune        // rune for opening bracket or pbOpen and pbClose; 0 for pbNone
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		embeddingLevel level // default: = implicitLevel;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// at the paragraph levels
0000000000000000000000000000000000000000;;		resultTypes  []Class
0000000000000000000000000000000000000000;;		resultLevels []level
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Index of matching PDI for isolate initiator characters. For other
0000000000000000000000000000000000000000;;		// characters, the value of matchingPDI will be set to -1. For isolate
0000000000000000000000000000000000000000;;		// initiators with no matching PDI, matchingPDI will be set to the length of
0000000000000000000000000000000000000000;;		// the input string.
0000000000000000000000000000000000000000;;		matchingPDI []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Index of matching isolate initiator for PDI characters. For other
0000000000000000000000000000000000000000;;		// characters, and for PDIs with no matching isolate initiator, the value of
0000000000000000000000000000000000000000;;		// matchingIsolateInitiator will be set to -1.
0000000000000000000000000000000000000000;;		matchingIsolateInitiator []int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newParagraph initializes a paragraph. The user needs to supply a few arrays
0000000000000000000000000000000000000000;;	// corresponding to the preprocessed text input. The types correspond to the
0000000000000000000000000000000000000000;;	// Unicode BiDi classes for each rune. pairTypes indicates the bracket type for
0000000000000000000000000000000000000000;;	// each rune. pairValues provides a unique bracket class identifier for each
0000000000000000000000000000000000000000;;	// rune (suggested is the rune of the open bracket for opening and matching
0000000000000000000000000000000000000000;;	// close brackets, after normalization). The embedding levels are optional, but
0000000000000000000000000000000000000000;;	// may be supplied to encode embedding levels of styled text.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: return an error.
0000000000000000000000000000000000000000;;	func newParagraph(types []Class, pairTypes []bracketType, pairValues []rune, levels level) *paragraph {
0000000000000000000000000000000000000000;;		validateTypes(types)
0000000000000000000000000000000000000000;;		validatePbTypes(pairTypes)
0000000000000000000000000000000000000000;;		validatePbValues(pairValues, pairTypes)
0000000000000000000000000000000000000000;;		validateParagraphEmbeddingLevel(levels)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := &paragraph{
0000000000000000000000000000000000000000;;			initialTypes:   append([]Class(nil), types...),
0000000000000000000000000000000000000000;;			embeddingLevel: levels,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pairTypes:  pairTypes,
0000000000000000000000000000000000000000;;			pairValues: pairValues,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resultTypes: append([]Class(nil), types...),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.run()
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *paragraph) Len() int { return len(p.initialTypes) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The algorithm. Does not include line-based processing (Rules L1, L2).
0000000000000000000000000000000000000000;;	// These are applied later in the line-based phase of the algorithm.
0000000000000000000000000000000000000000;;	func (p *paragraph) run() {
0000000000000000000000000000000000000000;;		p.determineMatchingIsolates()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1) determining the paragraph level
0000000000000000000000000000000000000000;;		// Rule P1 is the requirement for entering this algorithm.
0000000000000000000000000000000000000000;;		// Rules P2, P3.
0000000000000000000000000000000000000000;;		// If no externally supplied paragraph embedding level, use default.
0000000000000000000000000000000000000000;;		if p.embeddingLevel == implicitLevel {
0000000000000000000000000000000000000000;;			p.embeddingLevel = p.determineParagraphEmbeddingLevel(0, p.Len())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize result levels to paragraph embedding level.
0000000000000000000000000000000000000000;;		p.resultLevels = make([]level, p.Len())
0000000000000000000000000000000000000000;;		setLevels(p.resultLevels, p.embeddingLevel)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2) Explicit levels and directions
0000000000000000000000000000000000000000;;		// Rules X1-X8.
0000000000000000000000000000000000000000;;		p.determineExplicitEmbeddingLevels()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule X9.
0000000000000000000000000000000000000000;;		// We do not remove the embeddings, the overrides, the PDFs, and the BNs
0000000000000000000000000000000000000000;;		// from the string explicitly. But they are not copied into isolating run
0000000000000000000000000000000000000000;;		// sequences when they are created, so they are removed for all
0000000000000000000000000000000000000000;;		// practical purposes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule X10.
0000000000000000000000000000000000000000;;		// Run remainder of algorithm one isolating run sequence at a time
0000000000000000000000000000000000000000;;		for _, seq := range p.determineIsolatingRunSequences() {
0000000000000000000000000000000000000000;;			// 3) resolving weak types
0000000000000000000000000000000000000000;;			// Rules W1-W7.
0000000000000000000000000000000000000000;;			seq.resolveWeakTypes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// 4a) resolving paired brackets
0000000000000000000000000000000000000000;;			// Rule N0
0000000000000000000000000000000000000000;;			resolvePairedBrackets(seq)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// 4b) resolving neutral types
0000000000000000000000000000000000000000;;			// Rules N1-N3.
0000000000000000000000000000000000000000;;			seq.resolveNeutralTypes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// 5) resolving implicit embedding levels
0000000000000000000000000000000000000000;;			// Rules I1, I2.
0000000000000000000000000000000000000000;;			seq.resolveImplicitLevels()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Apply the computed levels and types
0000000000000000000000000000000000000000;;			seq.applyLevelsAndTypes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assign appropriate levels to 'hide' LREs, RLEs, LROs, RLOs, PDFs, and
0000000000000000000000000000000000000000;;		// BNs. This is for convenience, so the resulting level array will have
0000000000000000000000000000000000000000;;		// a value for every character.
0000000000000000000000000000000000000000;;		p.assignLevelsToCharactersRemovedByX9()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// determineMatchingIsolates determines the matching PDI for each isolate
0000000000000000000000000000000000000000;;	// initiator and vice versa.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Definition BD9.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// At the end of this function:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  - The member variable matchingPDI is set to point to the index of the
0000000000000000000000000000000000000000;;	//    matching PDI character for each isolate initiator character. If there is
0000000000000000000000000000000000000000;;	//    no matching PDI, it is set to the length of the input text. For other
0000000000000000000000000000000000000000;;	//    characters, it is set to -1.
0000000000000000000000000000000000000000;;	//  - The member variable matchingIsolateInitiator is set to point to the
0000000000000000000000000000000000000000;;	//    index of the matching isolate initiator character for each PDI character.
0000000000000000000000000000000000000000;;	//    If there is no matching isolate initiator, or the character is not a PDI,
0000000000000000000000000000000000000000;;	//    it is set to -1.
0000000000000000000000000000000000000000;;	func (p *paragraph) determineMatchingIsolates() {
0000000000000000000000000000000000000000;;		p.matchingPDI = make([]int, p.Len())
0000000000000000000000000000000000000000;;		p.matchingIsolateInitiator = make([]int, p.Len())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range p.matchingIsolateInitiator {
0000000000000000000000000000000000000000;;			p.matchingIsolateInitiator[i] = -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range p.matchingPDI {
0000000000000000000000000000000000000000;;			p.matchingPDI[i] = -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t := p.resultTypes[i]; t.in(LRI, RLI, FSI) {
0000000000000000000000000000000000000000;;				depthCounter := 1
0000000000000000000000000000000000000000;;				for j := i + 1; j < p.Len(); j++ {
0000000000000000000000000000000000000000;;					if u := p.resultTypes[j]; u.in(LRI, RLI, FSI) {
0000000000000000000000000000000000000000;;						depthCounter++
0000000000000000000000000000000000000000;;					} else if u == PDI {
0000000000000000000000000000000000000000;;						if depthCounter--; depthCounter == 0 {
0000000000000000000000000000000000000000;;							p.matchingPDI[i] = j
0000000000000000000000000000000000000000;;							p.matchingIsolateInitiator[j] = i
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if p.matchingPDI[i] == -1 {
0000000000000000000000000000000000000000;;					p.matchingPDI[i] = p.Len()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// determineParagraphEmbeddingLevel reports the resolved paragraph direction of
0000000000000000000000000000000000000000;;	// the substring limited by the given range [start, end).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Determines the paragraph level based on rules P2, P3. This is also used
0000000000000000000000000000000000000000;;	// in rule X5c to find if an FSI should resolve to LRI or RLI.
0000000000000000000000000000000000000000;;	func (p *paragraph) determineParagraphEmbeddingLevel(start, end int) level {
0000000000000000000000000000000000000000;;		var strongType Class = unknownClass
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule P2.
0000000000000000000000000000000000000000;;		for i := start; i < end; i++ {
0000000000000000000000000000000000000000;;			if t := p.resultTypes[i]; t.in(L, AL, R) {
0000000000000000000000000000000000000000;;				strongType = t
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if t.in(FSI, LRI, RLI) {
0000000000000000000000000000000000000000;;				i = p.matchingPDI[i] // skip over to the matching PDI
0000000000000000000000000000000000000000;;				if i > end {
0000000000000000000000000000000000000000;;					log.Panic("assert (i <= end)")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Rule P3.
0000000000000000000000000000000000000000;;		switch strongType {
0000000000000000000000000000000000000000;;		case unknownClass: // none found
0000000000000000000000000000000000000000;;			// default embedding level when no strong types found is 0.
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		case L:
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		default: // AL, R
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxDepth = 125
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This stack will store the embedding levels and override and isolated
0000000000000000000000000000000000000000;;	// statuses
0000000000000000000000000000000000000000;;	type directionalStatusStack struct {
0000000000000000000000000000000000000000;;		stackCounter        int
0000000000000000000000000000000000000000;;		embeddingLevelStack [maxDepth + 1]level
0000000000000000000000000000000000000000;;		overrideStatusStack [maxDepth + 1]Class
0000000000000000000000000000000000000000;;		isolateStatusStack  [maxDepth + 1]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *directionalStatusStack) empty()     { s.stackCounter = 0 }
0000000000000000000000000000000000000000;;	func (s *directionalStatusStack) pop()       { s.stackCounter-- }
0000000000000000000000000000000000000000;;	func (s *directionalStatusStack) depth() int { return s.stackCounter }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *directionalStatusStack) push(level level, overrideStatus Class, isolateStatus bool) {
0000000000000000000000000000000000000000;;		s.embeddingLevelStack[s.stackCounter] = level
0000000000000000000000000000000000000000;;		s.overrideStatusStack[s.stackCounter] = overrideStatus
0000000000000000000000000000000000000000;;		s.isolateStatusStack[s.stackCounter] = isolateStatus
0000000000000000000000000000000000000000;;		s.stackCounter++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *directionalStatusStack) lastEmbeddingLevel() level {
0000000000000000000000000000000000000000;;		return s.embeddingLevelStack[s.stackCounter-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *directionalStatusStack) lastDirectionalOverrideStatus() Class {
0000000000000000000000000000000000000000;;		return s.overrideStatusStack[s.stackCounter-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *directionalStatusStack) lastDirectionalIsolateStatus() bool {
0000000000000000000000000000000000000000;;		return s.isolateStatusStack[s.stackCounter-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Determine explicit levels using rules X1 - X8
0000000000000000000000000000000000000000;;	func (p *paragraph) determineExplicitEmbeddingLevels() {
0000000000000000000000000000000000000000;;		var stack directionalStatusStack
0000000000000000000000000000000000000000;;		var overflowIsolateCount, overflowEmbeddingCount, validIsolateCount int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule X1.
0000000000000000000000000000000000000000;;		stack.push(p.embeddingLevel, ON, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, t := range p.resultTypes {
0000000000000000000000000000000000000000;;			// Rules X2, X3, X4, X5, X5a, X5b, X5c
0000000000000000000000000000000000000000;;			switch t {
0000000000000000000000000000000000000000;;			case RLE, LRE, RLO, LRO, RLI, LRI, FSI:
0000000000000000000000000000000000000000;;				isIsolate := t.in(RLI, LRI, FSI)
0000000000000000000000000000000000000000;;				isRTL := t.in(RLE, RLO, RLI)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// override if this is an FSI that resolves to RLI
0000000000000000000000000000000000000000;;				if t == FSI {
0000000000000000000000000000000000000000;;					isRTL = (p.determineParagraphEmbeddingLevel(i+1, p.matchingPDI[i]) == 1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isIsolate {
0000000000000000000000000000000000000000;;					p.resultLevels[i] = stack.lastEmbeddingLevel()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var newLevel level
0000000000000000000000000000000000000000;;				if isRTL {
0000000000000000000000000000000000000000;;					// least greater odd
0000000000000000000000000000000000000000;;					newLevel = (stack.lastEmbeddingLevel() + 1) | 1
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// least greater even
0000000000000000000000000000000000000000;;					newLevel = (stack.lastEmbeddingLevel() + 2) &^ 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if newLevel <= maxDepth && overflowIsolateCount == 0 && overflowEmbeddingCount == 0 {
0000000000000000000000000000000000000000;;					if isIsolate {
0000000000000000000000000000000000000000;;						validIsolateCount++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Push new embedding level, override status, and isolated
0000000000000000000000000000000000000000;;					// status.
0000000000000000000000000000000000000000;;					// No check for valid stack counter, since the level check
0000000000000000000000000000000000000000;;					// suffices.
0000000000000000000000000000000000000000;;					switch t {
0000000000000000000000000000000000000000;;					case LRO:
0000000000000000000000000000000000000000;;						stack.push(newLevel, L, isIsolate)
0000000000000000000000000000000000000000;;					case RLO:
0000000000000000000000000000000000000000;;						stack.push(newLevel, R, isIsolate)
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						stack.push(newLevel, ON, isIsolate)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Not really part of the spec
0000000000000000000000000000000000000000;;					if !isIsolate {
0000000000000000000000000000000000000000;;						p.resultLevels[i] = newLevel
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// This is an invalid explicit formatting character,
0000000000000000000000000000000000000000;;					// so apply the "Otherwise" part of rules X2-X5b.
0000000000000000000000000000000000000000;;					if isIsolate {
0000000000000000000000000000000000000000;;						overflowIsolateCount++
0000000000000000000000000000000000000000;;					} else { // !isIsolate
0000000000000000000000000000000000000000;;						if overflowIsolateCount == 0 {
0000000000000000000000000000000000000000;;							overflowEmbeddingCount++
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Rule X6a
0000000000000000000000000000000000000000;;			case PDI:
0000000000000000000000000000000000000000;;				if overflowIsolateCount > 0 {
0000000000000000000000000000000000000000;;					overflowIsolateCount--
0000000000000000000000000000000000000000;;				} else if validIsolateCount == 0 {
0000000000000000000000000000000000000000;;					// do nothing
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					overflowEmbeddingCount = 0
0000000000000000000000000000000000000000;;					for !stack.lastDirectionalIsolateStatus() {
0000000000000000000000000000000000000000;;						stack.pop()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					stack.pop()
0000000000000000000000000000000000000000;;					validIsolateCount--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.resultLevels[i] = stack.lastEmbeddingLevel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Rule X7
0000000000000000000000000000000000000000;;			case PDF:
0000000000000000000000000000000000000000;;				// Not really part of the spec
0000000000000000000000000000000000000000;;				p.resultLevels[i] = stack.lastEmbeddingLevel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if overflowIsolateCount > 0 {
0000000000000000000000000000000000000000;;					// do nothing
0000000000000000000000000000000000000000;;				} else if overflowEmbeddingCount > 0 {
0000000000000000000000000000000000000000;;					overflowEmbeddingCount--
0000000000000000000000000000000000000000;;				} else if !stack.lastDirectionalIsolateStatus() && stack.depth() >= 2 {
0000000000000000000000000000000000000000;;					stack.pop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case B: // paragraph separator.
0000000000000000000000000000000000000000;;				// Rule X8.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// These values are reset for clarity, in this implementation B
0000000000000000000000000000000000000000;;				// can only occur as the last code in the array.
0000000000000000000000000000000000000000;;				stack.empty()
0000000000000000000000000000000000000000;;				overflowIsolateCount = 0
0000000000000000000000000000000000000000;;				overflowEmbeddingCount = 0
0000000000000000000000000000000000000000;;				validIsolateCount = 0
0000000000000000000000000000000000000000;;				p.resultLevels[i] = p.embeddingLevel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				p.resultLevels[i] = stack.lastEmbeddingLevel()
0000000000000000000000000000000000000000;;				if stack.lastDirectionalOverrideStatus() != ON {
0000000000000000000000000000000000000000;;					p.resultTypes[i] = stack.lastDirectionalOverrideStatus()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type isolatingRunSequence struct {
0000000000000000000000000000000000000000;;		p *paragraph
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indexes []int // indexes to the original string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		types          []Class // type of each character using the index
0000000000000000000000000000000000000000;;		resolvedLevels []level // resolved levels after application of rules
0000000000000000000000000000000000000000;;		level          level
0000000000000000000000000000000000000000;;		sos, eos       Class
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *isolatingRunSequence) Len() int { return len(i.indexes) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func maxLevel(a, b level) level {
0000000000000000000000000000000000000000;;		if a > b {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rule X10, second bullet: Determine the start-of-sequence (sos) and end-of-sequence (eos) types,
0000000000000000000000000000000000000000;;	// 			 either L or R, for each isolating run sequence.
0000000000000000000000000000000000000000;;	func (p *paragraph) isolatingRunSequence(indexes []int) *isolatingRunSequence {
0000000000000000000000000000000000000000;;		length := len(indexes)
0000000000000000000000000000000000000000;;		types := make([]Class, length)
0000000000000000000000000000000000000000;;		for i, x := range indexes {
0000000000000000000000000000000000000000;;			types[i] = p.resultTypes[x]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// assign level, sos and eos
0000000000000000000000000000000000000000;;		prevChar := indexes[0] - 1
0000000000000000000000000000000000000000;;		for prevChar >= 0 && isRemovedByX9(p.initialTypes[prevChar]) {
0000000000000000000000000000000000000000;;			prevChar--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prevLevel := p.embeddingLevel
0000000000000000000000000000000000000000;;		if prevChar >= 0 {
0000000000000000000000000000000000000000;;			prevLevel = p.resultLevels[prevChar]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var succLevel level
0000000000000000000000000000000000000000;;		lastType := types[length-1]
0000000000000000000000000000000000000000;;		if lastType.in(LRI, RLI, FSI) {
0000000000000000000000000000000000000000;;			succLevel = p.embeddingLevel
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// the first character after the end of run sequence
0000000000000000000000000000000000000000;;			limit := indexes[length-1] + 1
0000000000000000000000000000000000000000;;			for ; limit < p.Len() && isRemovedByX9(p.initialTypes[limit]); limit++ {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			succLevel = p.embeddingLevel
0000000000000000000000000000000000000000;;			if limit < p.Len() {
0000000000000000000000000000000000000000;;				succLevel = p.resultLevels[limit]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		level := p.resultLevels[indexes[0]]
0000000000000000000000000000000000000000;;		return &isolatingRunSequence{
0000000000000000000000000000000000000000;;			p:       p,
0000000000000000000000000000000000000000;;			indexes: indexes,
0000000000000000000000000000000000000000;;			types:   types,
0000000000000000000000000000000000000000;;			level:   level,
0000000000000000000000000000000000000000;;			sos:     typeForLevel(maxLevel(prevLevel, level)),
0000000000000000000000000000000000000000;;			eos:     typeForLevel(maxLevel(succLevel, level)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resolving weak types Rules W1-W7.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that some weak types (EN, AN) remain after this processing is
0000000000000000000000000000000000000000;;	// complete.
0000000000000000000000000000000000000000;;	func (s *isolatingRunSequence) resolveWeakTypes() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// on entry, only these types remain
0000000000000000000000000000000000000000;;		s.assertOnly(L, R, AL, EN, ES, ET, AN, CS, B, S, WS, ON, NSM, LRI, RLI, FSI, PDI)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule W1.
0000000000000000000000000000000000000000;;		// Changes all NSMs.
0000000000000000000000000000000000000000;;		preceedingCharacterType := s.sos
0000000000000000000000000000000000000000;;		for i, t := range s.types {
0000000000000000000000000000000000000000;;			if t == NSM {
0000000000000000000000000000000000000000;;				s.types[i] = preceedingCharacterType
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if t.in(LRI, RLI, FSI, PDI) {
0000000000000000000000000000000000000000;;					preceedingCharacterType = ON
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				preceedingCharacterType = t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule W2.
0000000000000000000000000000000000000000;;		// EN does not change at the start of the run, because sos != AL.
0000000000000000000000000000000000000000;;		for i, t := range s.types {
0000000000000000000000000000000000000000;;			if t == EN {
0000000000000000000000000000000000000000;;				for j := i - 1; j >= 0; j-- {
0000000000000000000000000000000000000000;;					if t := s.types[j]; t.in(L, R, AL) {
0000000000000000000000000000000000000000;;						if t == AL {
0000000000000000000000000000000000000000;;							s.types[i] = AN
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule W3.
0000000000000000000000000000000000000000;;		for i, t := range s.types {
0000000000000000000000000000000000000000;;			if t == AL {
0000000000000000000000000000000000000000;;				s.types[i] = R
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule W4.
0000000000000000000000000000000000000000;;		// Since there must be values on both sides for this rule to have an
0000000000000000000000000000000000000000;;		// effect, the scan skips the first and last value.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Although the scan proceeds left to right, and changes the type
0000000000000000000000000000000000000000;;		// values in a way that would appear to affect the computations
0000000000000000000000000000000000000000;;		// later in the scan, there is actually no problem. A change in the
0000000000000000000000000000000000000000;;		// current value can only affect the value to its immediate right,
0000000000000000000000000000000000000000;;		// and only affect it if it is ES or CS. But the current value can
0000000000000000000000000000000000000000;;		// only change if the value to its right is not ES or CS. Thus
0000000000000000000000000000000000000000;;		// either the current value will not change, or its change will have
0000000000000000000000000000000000000000;;		// no effect on the remainder of the analysis.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 1; i < s.Len()-1; i++ {
0000000000000000000000000000000000000000;;			t := s.types[i]
0000000000000000000000000000000000000000;;			if t == ES || t == CS {
0000000000000000000000000000000000000000;;				prevSepType := s.types[i-1]
0000000000000000000000000000000000000000;;				succSepType := s.types[i+1]
0000000000000000000000000000000000000000;;				if prevSepType == EN && succSepType == EN {
0000000000000000000000000000000000000000;;					s.types[i] = EN
0000000000000000000000000000000000000000;;				} else if s.types[i] == CS && prevSepType == AN && succSepType == AN {
0000000000000000000000000000000000000000;;					s.types[i] = AN
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule W5.
0000000000000000000000000000000000000000;;		for i, t := range s.types {
0000000000000000000000000000000000000000;;			if t == ET {
0000000000000000000000000000000000000000;;				// locate end of sequence
0000000000000000000000000000000000000000;;				runStart := i
0000000000000000000000000000000000000000;;				runEnd := s.findRunLimit(runStart, ET)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check values at ends of sequence
0000000000000000000000000000000000000000;;				t := s.sos
0000000000000000000000000000000000000000;;				if runStart > 0 {
0000000000000000000000000000000000000000;;					t = s.types[runStart-1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if t != EN {
0000000000000000000000000000000000000000;;					t = s.eos
0000000000000000000000000000000000000000;;					if runEnd < len(s.types) {
0000000000000000000000000000000000000000;;						t = s.types[runEnd]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if t == EN {
0000000000000000000000000000000000000000;;					setTypes(s.types[runStart:runEnd], EN)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// continue at end of sequence
0000000000000000000000000000000000000000;;				i = runEnd
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule W6.
0000000000000000000000000000000000000000;;		for i, t := range s.types {
0000000000000000000000000000000000000000;;			if t.in(ES, ET, CS) {
0000000000000000000000000000000000000000;;				s.types[i] = ON
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule W7.
0000000000000000000000000000000000000000;;		for i, t := range s.types {
0000000000000000000000000000000000000000;;			if t == EN {
0000000000000000000000000000000000000000;;				// set default if we reach start of run
0000000000000000000000000000000000000000;;				prevStrongType := s.sos
0000000000000000000000000000000000000000;;				for j := i - 1; j >= 0; j-- {
0000000000000000000000000000000000000000;;					t = s.types[j]
0000000000000000000000000000000000000000;;					if t == L || t == R { // AL's have been changed to R
0000000000000000000000000000000000000000;;						prevStrongType = t
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if prevStrongType == L {
0000000000000000000000000000000000000000;;					s.types[i] = L
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// 6) resolving neutral types Rules N1-N2.
0000000000000000000000000000000000000000;;	func (s *isolatingRunSequence) resolveNeutralTypes() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// on entry, only these types can be in resultTypes
0000000000000000000000000000000000000000;;		s.assertOnly(L, R, EN, AN, B, S, WS, ON, RLI, LRI, FSI, PDI)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, t := range s.types {
0000000000000000000000000000000000000000;;			switch t {
0000000000000000000000000000000000000000;;			case WS, ON, B, S, RLI, LRI, FSI, PDI:
0000000000000000000000000000000000000000;;				// find bounds of run of neutrals
0000000000000000000000000000000000000000;;				runStart := i
0000000000000000000000000000000000000000;;				runEnd := s.findRunLimit(runStart, B, S, WS, ON, RLI, LRI, FSI, PDI)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// determine effective types at ends of run
0000000000000000000000000000000000000000;;				var leadType, trailType Class
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Note that the character found can only be L, R, AN, or
0000000000000000000000000000000000000000;;				// EN.
0000000000000000000000000000000000000000;;				if runStart == 0 {
0000000000000000000000000000000000000000;;					leadType = s.sos
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					leadType = s.types[runStart-1]
0000000000000000000000000000000000000000;;					if leadType.in(AN, EN) {
0000000000000000000000000000000000000000;;						leadType = R
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if runEnd == len(s.types) {
0000000000000000000000000000000000000000;;					trailType = s.eos
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					trailType = s.types[runEnd]
0000000000000000000000000000000000000000;;					if trailType.in(AN, EN) {
0000000000000000000000000000000000000000;;						trailType = R
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var resolvedType Class
0000000000000000000000000000000000000000;;				if leadType == trailType {
0000000000000000000000000000000000000000;;					// Rule N1.
0000000000000000000000000000000000000000;;					resolvedType = leadType
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Rule N2.
0000000000000000000000000000000000000000;;					// Notice the embedding level of the run is used, not
0000000000000000000000000000000000000000;;					// the paragraph embedding level.
0000000000000000000000000000000000000000;;					resolvedType = typeForLevel(s.level)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				setTypes(s.types[runStart:runEnd], resolvedType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// skip over run of (former) neutrals
0000000000000000000000000000000000000000;;				i = runEnd
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setLevels(levels []level, newLevel level) {
0000000000000000000000000000000000000000;;		for i := range levels {
0000000000000000000000000000000000000000;;			levels[i] = newLevel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setTypes(types []Class, newType Class) {
0000000000000000000000000000000000000000;;		for i := range types {
0000000000000000000000000000000000000000;;			types[i] = newType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// 7) resolving implicit embedding levels Rules I1, I2.
0000000000000000000000000000000000000000;;	func (s *isolatingRunSequence) resolveImplicitLevels() {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// on entry, only these types can be in resultTypes
0000000000000000000000000000000000000000;;		s.assertOnly(L, R, EN, AN)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.resolvedLevels = make([]level, len(s.types))
0000000000000000000000000000000000000000;;		setLevels(s.resolvedLevels, s.level)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if (s.level & 1) == 0 { // even level
0000000000000000000000000000000000000000;;			for i, t := range s.types {
0000000000000000000000000000000000000000;;				// Rule I1.
0000000000000000000000000000000000000000;;				if t == L {
0000000000000000000000000000000000000000;;					// no change
0000000000000000000000000000000000000000;;				} else if t == R {
0000000000000000000000000000000000000000;;					s.resolvedLevels[i] += 1
0000000000000000000000000000000000000000;;				} else { // t == AN || t == EN
0000000000000000000000000000000000000000;;					s.resolvedLevels[i] += 2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else { // odd level
0000000000000000000000000000000000000000;;			for i, t := range s.types {
0000000000000000000000000000000000000000;;				// Rule I2.
0000000000000000000000000000000000000000;;				if t == R {
0000000000000000000000000000000000000000;;					// no change
0000000000000000000000000000000000000000;;				} else { // t == L || t == AN || t == EN
0000000000000000000000000000000000000000;;					s.resolvedLevels[i] += 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Applies the levels and types resolved in rules W1-I2 to the
0000000000000000000000000000000000000000;;	// resultLevels array.
0000000000000000000000000000000000000000;;	func (s *isolatingRunSequence) applyLevelsAndTypes() {
0000000000000000000000000000000000000000;;		for i, x := range s.indexes {
0000000000000000000000000000000000000000;;			s.p.resultTypes[x] = s.types[i]
0000000000000000000000000000000000000000;;			s.p.resultLevels[x] = s.resolvedLevels[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return the limit of the run consisting only of the types in validSet
0000000000000000000000000000000000000000;;	// starting at index. This checks the value at index, and will return
0000000000000000000000000000000000000000;;	// index if that value is not in validSet.
0000000000000000000000000000000000000000;;	func (s *isolatingRunSequence) findRunLimit(index int, validSet ...Class) int {
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for ; index < len(s.types); index++ {
0000000000000000000000000000000000000000;;			t := s.types[index]
0000000000000000000000000000000000000000;;			for _, valid := range validSet {
0000000000000000000000000000000000000000;;				if t == valid {
0000000000000000000000000000000000000000;;					continue loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return index // didn't find a match in validSet
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(s.types)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Algorithm validation. Assert that all values in types are in the
0000000000000000000000000000000000000000;;	// provided set.
0000000000000000000000000000000000000000;;	func (s *isolatingRunSequence) assertOnly(codes ...Class) {
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for i, t := range s.types {
0000000000000000000000000000000000000000;;			for _, c := range codes {
0000000000000000000000000000000000000000;;				if t == c {
0000000000000000000000000000000000000000;;					continue loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			log.Panicf("invalid bidi code %s present in assertOnly at position %d", t, s.indexes[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// determineLevelRuns returns an array of level runs. Each level run is
0000000000000000000000000000000000000000;;	// described as an array of indexes into the input string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Determines the level runs. Rule X9 will be applied in determining the
0000000000000000000000000000000000000000;;	// runs, in the way that makes sure the characters that are supposed to be
0000000000000000000000000000000000000000;;	// removed are not included in the runs.
0000000000000000000000000000000000000000;;	func (p *paragraph) determineLevelRuns() [][]int {
0000000000000000000000000000000000000000;;		run := []int{}
0000000000000000000000000000000000000000;;		allRuns := [][]int{}
0000000000000000000000000000000000000000;;		currentLevel := implicitLevel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range p.initialTypes {
0000000000000000000000000000000000000000;;			if !isRemovedByX9(p.initialTypes[i]) {
0000000000000000000000000000000000000000;;				if p.resultLevels[i] != currentLevel {
0000000000000000000000000000000000000000;;					// we just encountered a new run; wrap up last run
0000000000000000000000000000000000000000;;					if currentLevel >= 0 { // only wrap it up if there was a run
0000000000000000000000000000000000000000;;						allRuns = append(allRuns, run)
0000000000000000000000000000000000000000;;						run = nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Start new run
0000000000000000000000000000000000000000;;					currentLevel = p.resultLevels[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				run = append(run, i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Wrap up the final run, if any
0000000000000000000000000000000000000000;;		if len(run) > 0 {
0000000000000000000000000000000000000000;;			allRuns = append(allRuns, run)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allRuns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Definition BD13. Determine isolating run sequences.
0000000000000000000000000000000000000000;;	func (p *paragraph) determineIsolatingRunSequences() []*isolatingRunSequence {
0000000000000000000000000000000000000000;;		levelRuns := p.determineLevelRuns()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compute the run that each character belongs to
0000000000000000000000000000000000000000;;		runForCharacter := make([]int, p.Len())
0000000000000000000000000000000000000000;;		for i, run := range levelRuns {
0000000000000000000000000000000000000000;;			for _, index := range run {
0000000000000000000000000000000000000000;;				runForCharacter[index] = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sequences := []*isolatingRunSequence{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var currentRunSequence []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, run := range levelRuns {
0000000000000000000000000000000000000000;;			first := run[0]
0000000000000000000000000000000000000000;;			if p.initialTypes[first] != PDI || p.matchingIsolateInitiator[first] == -1 {
0000000000000000000000000000000000000000;;				currentRunSequence = nil
0000000000000000000000000000000000000000;;				// int run = i;
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					// Copy this level run into currentRunSequence
0000000000000000000000000000000000000000;;					currentRunSequence = append(currentRunSequence, run...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					last := currentRunSequence[len(currentRunSequence)-1]
0000000000000000000000000000000000000000;;					lastT := p.initialTypes[last]
0000000000000000000000000000000000000000;;					if lastT.in(LRI, RLI, FSI) && p.matchingPDI[last] != p.Len() {
0000000000000000000000000000000000000000;;						run = levelRuns[runForCharacter[p.matchingPDI[last]]]
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sequences = append(sequences, p.isolatingRunSequence(currentRunSequence))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sequences
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assign level information to characters removed by rule X9. This is for
0000000000000000000000000000000000000000;;	// ease of relating the level information to the original input data. Note
0000000000000000000000000000000000000000;;	// that the levels assigned to these codes are arbitrary, they're chosen so
0000000000000000000000000000000000000000;;	// as to avoid breaking level runs.
0000000000000000000000000000000000000000;;	func (p *paragraph) assignLevelsToCharactersRemovedByX9() {
0000000000000000000000000000000000000000;;		for i, t := range p.initialTypes {
0000000000000000000000000000000000000000;;			if t.in(LRE, RLE, LRO, RLO, PDF, BN) {
0000000000000000000000000000000000000000;;				p.resultTypes[i] = t
0000000000000000000000000000000000000000;;				p.resultLevels[i] = -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// now propagate forward the levels information (could have
0000000000000000000000000000000000000000;;		// propagated backward, the main thing is not to introduce a level
0000000000000000000000000000000000000000;;		// break where one doesn't already exist).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.resultLevels[0] == -1 {
0000000000000000000000000000000000000000;;			p.resultLevels[0] = p.embeddingLevel
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 1; i < len(p.initialTypes); i++ {
0000000000000000000000000000000000000000;;			if p.resultLevels[i] == -1 {
0000000000000000000000000000000000000000;;				p.resultLevels[i] = p.resultLevels[i-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Embedding information is for informational purposes only so need not be
0000000000000000000000000000000000000000;;		// adjusted.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Output
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLevels computes levels array breaking lines at offsets in linebreaks.
0000000000000000000000000000000000000000;;	// Rule L1.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The linebreaks array must include at least one value. The values must be
0000000000000000000000000000000000000000;;	// in strictly increasing order (no duplicates) between 1 and the length of
0000000000000000000000000000000000000000;;	// the text, inclusive. The last value must be the length of the text.
0000000000000000000000000000000000000000;;	func (p *paragraph) getLevels(linebreaks []int) []level {
0000000000000000000000000000000000000000;;		// Note that since the previous processing has removed all
0000000000000000000000000000000000000000;;		// P, S, and WS values from resultTypes, the values referred to
0000000000000000000000000000000000000000;;		// in these rules are the initial types, before any processing
0000000000000000000000000000000000000000;;		// has been applied (including processing of overrides).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This example implementation has reinserted explicit format codes
0000000000000000000000000000000000000000;;		// and BN, in order that the levels array correspond to the
0000000000000000000000000000000000000000;;		// initial text. Their final placement is not normative.
0000000000000000000000000000000000000000;;		// These codes are treated like WS in this implementation,
0000000000000000000000000000000000000000;;		// so they don't interrupt sequences of WS.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validateLineBreaks(linebreaks, p.Len())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := append([]level(nil), p.resultLevels...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// don't worry about linebreaks since if there is a break within
0000000000000000000000000000000000000000;;		// a series of WS values preceding S, the linebreak itself
0000000000000000000000000000000000000000;;		// causes the reset.
0000000000000000000000000000000000000000;;		for i, t := range p.initialTypes {
0000000000000000000000000000000000000000;;			if t.in(B, S) {
0000000000000000000000000000000000000000;;				// Rule L1, clauses one and two.
0000000000000000000000000000000000000000;;				result[i] = p.embeddingLevel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Rule L1, clause three.
0000000000000000000000000000000000000000;;				for j := i - 1; j >= 0; j-- {
0000000000000000000000000000000000000000;;					if isWhitespace(p.initialTypes[j]) { // including format codes
0000000000000000000000000000000000000000;;						result[j] = p.embeddingLevel
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rule L1, clause four.
0000000000000000000000000000000000000000;;		start := 0
0000000000000000000000000000000000000000;;		for _, limit := range linebreaks {
0000000000000000000000000000000000000000;;			for j := limit - 1; j >= start; j-- {
0000000000000000000000000000000000000000;;				if isWhitespace(p.initialTypes[j]) { // including format codes
0000000000000000000000000000000000000000;;					result[j] = p.embeddingLevel
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			start = limit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getReordering returns the reordering of lines from a visual index to a
0000000000000000000000000000000000000000;;	// logical index for line breaks at the given offsets.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Lines are concatenated from left to right. So for example, the fifth
0000000000000000000000000000000000000000;;	// character from the left on the third line is
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 		getReordering(linebreaks)[linebreaks[1] + 4]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// (linebreaks[1] is the position after the last character of the second
0000000000000000000000000000000000000000;;	// line, which is also the index of the first character on the third line,
0000000000000000000000000000000000000000;;	// and adding four gets the fifth character from the left).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The linebreaks array must include at least one value. The values must be
0000000000000000000000000000000000000000;;	// in strictly increasing order (no duplicates) between 1 and the length of
0000000000000000000000000000000000000000;;	// the text, inclusive. The last value must be the length of the text.
0000000000000000000000000000000000000000;;	func (p *paragraph) getReordering(linebreaks []int) []int {
0000000000000000000000000000000000000000;;		validateLineBreaks(linebreaks, p.Len())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return computeMultilineReordering(p.getLevels(linebreaks), linebreaks)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return multiline reordering array for a given level array. Reordering
0000000000000000000000000000000000000000;;	// does not occur across a line break.
0000000000000000000000000000000000000000;;	func computeMultilineReordering(levels []level, linebreaks []int) []int {
0000000000000000000000000000000000000000;;		result := make([]int, len(levels))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start := 0
0000000000000000000000000000000000000000;;		for _, limit := range linebreaks {
0000000000000000000000000000000000000000;;			tempLevels := make([]level, limit-start)
0000000000000000000000000000000000000000;;			copy(tempLevels, levels[start:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for j, order := range computeReordering(tempLevels) {
0000000000000000000000000000000000000000;;				result[start+j] = order + start
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			start = limit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return reordering array for a given level array. This reorders a single
0000000000000000000000000000000000000000;;	// line. The reordering is a visual to logical map. For example, the
0000000000000000000000000000000000000000;;	// leftmost char is string.charAt(order[0]). Rule L2.
0000000000000000000000000000000000000000;;	func computeReordering(levels []level) []int {
0000000000000000000000000000000000000000;;		result := make([]int, len(levels))
0000000000000000000000000000000000000000;;		// initialize order
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			result[i] = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// locate highest level found on line.
0000000000000000000000000000000000000000;;		// Note the rules say text, but no reordering across line bounds is
0000000000000000000000000000000000000000;;		// performed, so this is sufficient.
0000000000000000000000000000000000000000;;		highestLevel := level(0)
0000000000000000000000000000000000000000;;		lowestOddLevel := level(maxDepth + 2)
0000000000000000000000000000000000000000;;		for _, level := range levels {
0000000000000000000000000000000000000000;;			if level > highestLevel {
0000000000000000000000000000000000000000;;				highestLevel = level
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if level&1 != 0 && level < lowestOddLevel {
0000000000000000000000000000000000000000;;				lowestOddLevel = level
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for level := highestLevel; level >= lowestOddLevel; level-- {
0000000000000000000000000000000000000000;;			for i := 0; i < len(levels); i++ {
0000000000000000000000000000000000000000;;				if levels[i] >= level {
0000000000000000000000000000000000000000;;					// find range of text at or above this level
0000000000000000000000000000000000000000;;					start := i
0000000000000000000000000000000000000000;;					limit := i + 1
0000000000000000000000000000000000000000;;					for limit < len(levels) && levels[limit] >= level {
0000000000000000000000000000000000000000;;						limit++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for j, k := start, limit-1; j < k; j, k = j+1, k-1 {
0000000000000000000000000000000000000000;;						result[j], result[k] = result[k], result[j]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// skip to end of level run
0000000000000000000000000000000000000000;;					i = limit
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isWhitespace reports whether the type is considered a whitespace type for the
0000000000000000000000000000000000000000;;	// line break rules.
0000000000000000000000000000000000000000;;	func isWhitespace(c Class) bool {
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case LRE, RLE, LRO, RLO, PDF, LRI, RLI, FSI, PDI, BN, WS:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isRemovedByX9 reports whether the type is one of the types removed in X9.
0000000000000000000000000000000000000000;;	func isRemovedByX9(c Class) bool {
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case LRE, RLE, LRO, RLO, PDF, BN:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// typeForLevel reports the strong type (L or R) corresponding to the level.
0000000000000000000000000000000000000000;;	func typeForLevel(level level) Class {
0000000000000000000000000000000000000000;;		if (level & 0x1) == 0 {
0000000000000000000000000000000000000000;;			return L
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return R
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: change validation to not panic
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateTypes(types []Class) {
0000000000000000000000000000000000000000;;		if len(types) == 0 {
0000000000000000000000000000000000000000;;			log.Panic("types is null")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, t := range types[:len(types)-1] {
0000000000000000000000000000000000000000;;			if t == B {
0000000000000000000000000000000000000000;;				log.Panicf("B type before end of paragraph at index: %d", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateParagraphEmbeddingLevel(embeddingLevel level) {
0000000000000000000000000000000000000000;;		if embeddingLevel != implicitLevel &&
0000000000000000000000000000000000000000;;			embeddingLevel != 0 &&
0000000000000000000000000000000000000000;;			embeddingLevel != 1 {
0000000000000000000000000000000000000000;;			log.Panicf("illegal paragraph embedding level: %d", embeddingLevel)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateLineBreaks(linebreaks []int, textLength int) {
0000000000000000000000000000000000000000;;		prev := 0
0000000000000000000000000000000000000000;;		for i, next := range linebreaks {
0000000000000000000000000000000000000000;;			if next <= prev {
0000000000000000000000000000000000000000;;				log.Panicf("bad linebreak: %d at index: %d", next, i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prev = next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if prev != textLength {
0000000000000000000000000000000000000000;;			log.Panicf("last linebreak was %d, want %d", prev, textLength)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePbTypes(pairTypes []bracketType) {
0000000000000000000000000000000000000000;;		if len(pairTypes) == 0 {
0000000000000000000000000000000000000000;;			log.Panic("pairTypes is null")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, pt := range pairTypes {
0000000000000000000000000000000000000000;;			switch pt {
0000000000000000000000000000000000000000;;			case bpNone, bpOpen, bpClose:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				log.Panicf("illegal pairType value at %d: %v", i, pairTypes[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validatePbValues(pairValues []rune, pairTypes []bracketType) {
0000000000000000000000000000000000000000;;		if pairValues == nil {
0000000000000000000000000000000000000000;;			log.Panic("pairValues is null")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pairTypes) != len(pairValues) {
0000000000000000000000000000000000000000;;			log.Panic("pairTypes is different length from pairValues")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
