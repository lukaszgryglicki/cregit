0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package bidi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Properties provides access to BiDi properties of runes.
0000000000000000000000000000000000000000;;	type Properties struct {
0000000000000000000000000000000000000000;;		entry uint8
0000000000000000000000000000000000000000;;		last  uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var trie = newBidiTrie(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: using this for bidirule reduces the running time by about 5%. Consider
0000000000000000000000000000000000000000;;	// if this is worth exposing or if we can find a way to speed up the Class
0000000000000000000000000000000000000000;;	// method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// // CompactClass is like Class, but maps all of the BiDi control classes
0000000000000000000000000000000000000000;;	// // (LRO, RLO, LRE, RLE, PDF, LRI, RLI, FSI, PDI) to the class Control.
0000000000000000000000000000000000000000;;	// func (p Properties) CompactClass() Class {
0000000000000000000000000000000000000000;;	// 	return Class(p.entry & 0x0F)
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Class returns the Bidi class for p.
0000000000000000000000000000000000000000;;	func (p Properties) Class() Class {
0000000000000000000000000000000000000000;;		c := Class(p.entry & 0x0F)
0000000000000000000000000000000000000000;;		if c == Control {
0000000000000000000000000000000000000000;;			c = controlByteToClass[p.last&0xF]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsBracket reports whether the rune is a bracket.
0000000000000000000000000000000000000000;;	func (p Properties) IsBracket() bool { return p.entry&0xF0 != 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsOpeningBracket reports whether the rune is an opening bracket.
0000000000000000000000000000000000000000;;	// IsBracket must return true.
0000000000000000000000000000000000000000;;	func (p Properties) IsOpeningBracket() bool { return p.entry&openMask != 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: find a better API and expose.
0000000000000000000000000000000000000000;;	func (p Properties) reverseBracket(r rune) rune {
0000000000000000000000000000000000000000;;		return xorMasks[p.entry>>xorMaskShift] ^ r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var controlByteToClass = [16]Class{
0000000000000000000000000000000000000000;;		0xD: LRO, // U+202D LeftToRightOverride,
0000000000000000000000000000000000000000;;		0xE: RLO, // U+202E RightToLeftOverride,
0000000000000000000000000000000000000000;;		0xA: LRE, // U+202A LeftToRightEmbedding,
0000000000000000000000000000000000000000;;		0xB: RLE, // U+202B RightToLeftEmbedding,
0000000000000000000000000000000000000000;;		0xC: PDF, // U+202C PopDirectionalFormat,
0000000000000000000000000000000000000000;;		0x6: LRI, // U+2066 LeftToRightIsolate,
0000000000000000000000000000000000000000;;		0x7: RLI, // U+2067 RightToLeftIsolate,
0000000000000000000000000000000000000000;;		0x8: FSI, // U+2068 FirstStrongIsolate,
0000000000000000000000000000000000000000;;		0x9: PDI, // U+2069 PopDirectionalIsolate,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupRune returns properties for r.
0000000000000000000000000000000000000000;;	func LookupRune(r rune) (p Properties, size int) {
0000000000000000000000000000000000000000;;		var buf [4]byte
0000000000000000000000000000000000000000;;		n := utf8.EncodeRune(buf[:], r)
0000000000000000000000000000000000000000;;		return Lookup(buf[:n])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: these lookup methods are based on the generated trie code. The returned
0000000000000000000000000000000000000000;;	// sizes have slightly different semantics from the generated code, in that it
0000000000000000000000000000000000000000;;	// always returns size==1 for an illegal UTF-8 byte (instead of the length
0000000000000000000000000000000000000000;;	// of the maximum invalid subsequence). Most Transformers, like unicode/norm,
0000000000000000000000000000000000000000;;	// leave invalid UTF-8 untouched, in which case it has performance benefits to
0000000000000000000000000000000000000000;;	// do so (without changing the semantics). Bidi requires the semantics used here
0000000000000000000000000000000000000000;;	// for the bidirule implementation to be compatible with the Go semantics.
0000000000000000000000000000000000000000;;	//  They ultimately should perhaps be adopted by all trie implementations, for
0000000000000000000000000000000000000000;;	// convenience sake.
0000000000000000000000000000000000000000;;	// This unrolled code also boosts performance of the secure/bidirule package by
0000000000000000000000000000000000000000;;	// about 30%.
0000000000000000000000000000000000000000;;	// So, to remove this code:
0000000000000000000000000000000000000000;;	//   - add option to trie generator to define return type.
0000000000000000000000000000000000000000;;	//   - always return 1 byte size for ill-formed UTF-8 runes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lookup returns properties for the first rune in s and the width in bytes of
0000000000000000000000000000000000000000;;	// its encoding. The size will be 0 if s does not hold enough bytes to complete
0000000000000000000000000000000000000000;;	// the encoding.
0000000000000000000000000000000000000000;;	func Lookup(s []byte) (p Properties, sz int) {
0000000000000000000000000000000000000000;;		c0 := s[0]
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case c0 < 0x80: // is ASCII
0000000000000000000000000000000000000000;;			return Properties{entry: bidiValues[c0]}, 1
0000000000000000000000000000000000000000;;		case c0 < 0xC2:
0000000000000000000000000000000000000000;;			return Properties{}, 1
0000000000000000000000000000000000000000;;		case c0 < 0xE0: // 2-byte UTF-8
0000000000000000000000000000000000000000;;			if len(s) < 2 {
0000000000000000000000000000000000000000;;				return Properties{}, 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i := bidiIndex[c0]
0000000000000000000000000000000000000000;;			c1 := s[1]
0000000000000000000000000000000000000000;;			if c1 < 0x80 || 0xC0 <= c1 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Properties{entry: trie.lookupValue(uint32(i), c1)}, 2
0000000000000000000000000000000000000000;;		case c0 < 0xF0: // 3-byte UTF-8
0000000000000000000000000000000000000000;;			if len(s) < 3 {
0000000000000000000000000000000000000000;;				return Properties{}, 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i := bidiIndex[c0]
0000000000000000000000000000000000000000;;			c1 := s[1]
0000000000000000000000000000000000000000;;			if c1 < 0x80 || 0xC0 <= c1 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o := uint32(i)<<6 + uint32(c1)
0000000000000000000000000000000000000000;;			i = bidiIndex[o]
0000000000000000000000000000000000000000;;			c2 := s[2]
0000000000000000000000000000000000000000;;			if c2 < 0x80 || 0xC0 <= c2 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Properties{entry: trie.lookupValue(uint32(i), c2), last: c2}, 3
0000000000000000000000000000000000000000;;		case c0 < 0xF8: // 4-byte UTF-8
0000000000000000000000000000000000000000;;			if len(s) < 4 {
0000000000000000000000000000000000000000;;				return Properties{}, 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i := bidiIndex[c0]
0000000000000000000000000000000000000000;;			c1 := s[1]
0000000000000000000000000000000000000000;;			if c1 < 0x80 || 0xC0 <= c1 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o := uint32(i)<<6 + uint32(c1)
0000000000000000000000000000000000000000;;			i = bidiIndex[o]
0000000000000000000000000000000000000000;;			c2 := s[2]
0000000000000000000000000000000000000000;;			if c2 < 0x80 || 0xC0 <= c2 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o = uint32(i)<<6 + uint32(c2)
0000000000000000000000000000000000000000;;			i = bidiIndex[o]
0000000000000000000000000000000000000000;;			c3 := s[3]
0000000000000000000000000000000000000000;;			if c3 < 0x80 || 0xC0 <= c3 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Properties{entry: trie.lookupValue(uint32(i), c3)}, 4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Illegal rune
0000000000000000000000000000000000000000;;		return Properties{}, 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupString returns properties for the first rune in s and the width in
0000000000000000000000000000000000000000;;	// bytes of its encoding. The size will be 0 if s does not hold enough bytes to
0000000000000000000000000000000000000000;;	// complete the encoding.
0000000000000000000000000000000000000000;;	func LookupString(s string) (p Properties, sz int) {
0000000000000000000000000000000000000000;;		c0 := s[0]
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case c0 < 0x80: // is ASCII
0000000000000000000000000000000000000000;;			return Properties{entry: bidiValues[c0]}, 1
0000000000000000000000000000000000000000;;		case c0 < 0xC2:
0000000000000000000000000000000000000000;;			return Properties{}, 1
0000000000000000000000000000000000000000;;		case c0 < 0xE0: // 2-byte UTF-8
0000000000000000000000000000000000000000;;			if len(s) < 2 {
0000000000000000000000000000000000000000;;				return Properties{}, 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i := bidiIndex[c0]
0000000000000000000000000000000000000000;;			c1 := s[1]
0000000000000000000000000000000000000000;;			if c1 < 0x80 || 0xC0 <= c1 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Properties{entry: trie.lookupValue(uint32(i), c1)}, 2
0000000000000000000000000000000000000000;;		case c0 < 0xF0: // 3-byte UTF-8
0000000000000000000000000000000000000000;;			if len(s) < 3 {
0000000000000000000000000000000000000000;;				return Properties{}, 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i := bidiIndex[c0]
0000000000000000000000000000000000000000;;			c1 := s[1]
0000000000000000000000000000000000000000;;			if c1 < 0x80 || 0xC0 <= c1 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o := uint32(i)<<6 + uint32(c1)
0000000000000000000000000000000000000000;;			i = bidiIndex[o]
0000000000000000000000000000000000000000;;			c2 := s[2]
0000000000000000000000000000000000000000;;			if c2 < 0x80 || 0xC0 <= c2 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Properties{entry: trie.lookupValue(uint32(i), c2), last: c2}, 3
0000000000000000000000000000000000000000;;		case c0 < 0xF8: // 4-byte UTF-8
0000000000000000000000000000000000000000;;			if len(s) < 4 {
0000000000000000000000000000000000000000;;				return Properties{}, 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i := bidiIndex[c0]
0000000000000000000000000000000000000000;;			c1 := s[1]
0000000000000000000000000000000000000000;;			if c1 < 0x80 || 0xC0 <= c1 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o := uint32(i)<<6 + uint32(c1)
0000000000000000000000000000000000000000;;			i = bidiIndex[o]
0000000000000000000000000000000000000000;;			c2 := s[2]
0000000000000000000000000000000000000000;;			if c2 < 0x80 || 0xC0 <= c2 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o = uint32(i)<<6 + uint32(c2)
0000000000000000000000000000000000000000;;			i = bidiIndex[o]
0000000000000000000000000000000000000000;;			c3 := s[3]
0000000000000000000000000000000000000000;;			if c3 < 0x80 || 0xC0 <= c3 {
0000000000000000000000000000000000000000;;				return Properties{}, 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Properties{entry: trie.lookupValue(uint32(i), c3)}, 4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Illegal rune
0000000000000000000000000000000000000000;;		return Properties{}, 1
0000000000000000000000000000000000000000;;	}
