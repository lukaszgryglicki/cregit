0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package bidi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/list"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains a port of the reference implementation of the
0000000000000000000000000000000000000000;;	// Bidi Parentheses Algorithm:
0000000000000000000000000000000000000000;;	// http://www.unicode.org/Public/PROGRAMS/BidiReferenceJava/BidiPBAReference.java
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The implementation in this file covers definitions BD14-BD16 and rule N0
0000000000000000000000000000000000000000;;	// of UAX#9.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some preprocessing is done for each rune before data is passed to this
0000000000000000000000000000000000000000;;	// algorithm:
0000000000000000000000000000000000000000;;	//  - opening and closing brackets are identified
0000000000000000000000000000000000000000;;	//  - a bracket pair type, like '(' and ')' is assigned a unique identifier that
0000000000000000000000000000000000000000;;	//    is identical for the opening and closing bracket. It is left to do these
0000000000000000000000000000000000000000;;	//    mappings.
0000000000000000000000000000000000000000;;	//  - The BPA algorithm requires that bracket characters that are canonical
0000000000000000000000000000000000000000;;	//    equivalents of each other be able to be substituted for each other.
0000000000000000000000000000000000000000;;	//    It is the responsibility of the caller to do this canonicalization.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In implementing BD16, this implementation departs slightly from the "logical"
0000000000000000000000000000000000000000;;	// algorithm defined in UAX#9. In particular, the stack referenced there
0000000000000000000000000000000000000000;;	// supports operations that go beyond a "basic" stack. An equivalent
0000000000000000000000000000000000000000;;	// implementation based on a linked list is used here.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bidi_Paired_Bracket_Type
0000000000000000000000000000000000000000;;	// BD14. An opening paired bracket is a character whose
0000000000000000000000000000000000000000;;	// Bidi_Paired_Bracket_Type property value is Open.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// BD15. A closing paired bracket is a character whose
0000000000000000000000000000000000000000;;	// Bidi_Paired_Bracket_Type property value is Close.
0000000000000000000000000000000000000000;;	type bracketType byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bpNone bracketType = iota
0000000000000000000000000000000000000000;;		bpOpen
0000000000000000000000000000000000000000;;		bpClose
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bracketPair holds a pair of index values for opening and closing bracket
0000000000000000000000000000000000000000;;	// location of a bracket pair.
0000000000000000000000000000000000000000;;	type bracketPair struct {
0000000000000000000000000000000000000000;;		opener int
0000000000000000000000000000000000000000;;		closer int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *bracketPair) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("(%v, %v)", b.opener, b.closer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bracketPairs is a slice of bracketPairs with a sort.Interface implementation.
0000000000000000000000000000000000000000;;	type bracketPairs []bracketPair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b bracketPairs) Len() int           { return len(b) }
0000000000000000000000000000000000000000;;	func (b bracketPairs) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }
0000000000000000000000000000000000000000;;	func (b bracketPairs) Less(i, j int) bool { return b[i].opener < b[j].opener }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolvePairedBrackets runs the paired bracket part of the UBA algorithm.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For each rune, it takes the indexes into the original string, the class the
0000000000000000000000000000000000000000;;	// bracket type (in pairTypes) and the bracket identifier (pairValues). It also
0000000000000000000000000000000000000000;;	// takes the direction type for the start-of-sentence and the embedding level.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The identifiers for bracket types are the rune of the canonicalized opening
0000000000000000000000000000000000000000;;	// bracket for brackets (open or close) or 0 for runes that are not brackets.
0000000000000000000000000000000000000000;;	func resolvePairedBrackets(s *isolatingRunSequence) {
0000000000000000000000000000000000000000;;		p := bracketPairer{
0000000000000000000000000000000000000000;;			sos:              s.sos,
0000000000000000000000000000000000000000;;			openers:          list.New(),
0000000000000000000000000000000000000000;;			codesIsolatedRun: s.types,
0000000000000000000000000000000000000000;;			indexes:          s.indexes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dirEmbed := L
0000000000000000000000000000000000000000;;		if s.level&1 != 0 {
0000000000000000000000000000000000000000;;			dirEmbed = R
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.locateBrackets(s.p.pairTypes, s.p.pairValues)
0000000000000000000000000000000000000000;;		p.resolveBrackets(dirEmbed)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bracketPairer struct {
0000000000000000000000000000000000000000;;		sos Class // direction corresponding to start of sequence
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The following is a restatement of BD 16 using non-algorithmic language.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// A bracket pair is a pair of characters consisting of an opening
0000000000000000000000000000000000000000;;		// paired bracket and a closing paired bracket such that the
0000000000000000000000000000000000000000;;		// Bidi_Paired_Bracket property value of the former equals the latter,
0000000000000000000000000000000000000000;;		// subject to the following constraints.
0000000000000000000000000000000000000000;;		// - both characters of a pair occur in the same isolating run sequence
0000000000000000000000000000000000000000;;		// - the closing character of a pair follows the opening character
0000000000000000000000000000000000000000;;		// - any bracket character can belong at most to one pair, the earliest possible one
0000000000000000000000000000000000000000;;		// - any bracket character not part of a pair is treated like an ordinary character
0000000000000000000000000000000000000000;;		// - pairs may nest properly, but their spans may not overlap otherwise
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bracket characters with canonical decompositions are supposed to be
0000000000000000000000000000000000000000;;		// treated as if they had been normalized, to allow normalized and non-
0000000000000000000000000000000000000000;;		// normalized text to give the same result. In this implementation that step
0000000000000000000000000000000000000000;;		// is pushed out to the caller. The caller has to ensure that the pairValue
0000000000000000000000000000000000000000;;		// slices contain the rune of the opening bracket after normalization for
0000000000000000000000000000000000000000;;		// any opening or closing bracket.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		openers *list.List // list of positions for opening brackets
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// bracket pair positions sorted by location of opening bracket
0000000000000000000000000000000000000000;;		pairPositions bracketPairs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codesIsolatedRun []Class // directional bidi codes for an isolated run
0000000000000000000000000000000000000000;;		indexes          []int   // array of index values into the original string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matchOpener reports whether characters at given positions form a matching
0000000000000000000000000000000000000000;;	// bracket pair.
0000000000000000000000000000000000000000;;	func (p *bracketPairer) matchOpener(pairValues []rune, opener, closer int) bool {
0000000000000000000000000000000000000000;;		return pairValues[p.indexes[opener]] == pairValues[p.indexes[closer]]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// locateBrackets locates matching bracket pairs according to BD16.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This implementation uses a linked list instead of a stack, because, while
0000000000000000000000000000000000000000;;	// elements are added at the front (like a push) they are not generally removed
0000000000000000000000000000000000000000;;	// in atomic 'pop' operations, reducing the benefit of the stack archetype.
0000000000000000000000000000000000000000;;	func (p *bracketPairer) locateBrackets(pairTypes []bracketType, pairValues []rune) {
0000000000000000000000000000000000000000;;		// traverse the run
0000000000000000000000000000000000000000;;		// do that explicitly (not in a for-each) so we can record position
0000000000000000000000000000000000000000;;		for i, index := range p.indexes {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// look at the bracket type for each character
0000000000000000000000000000000000000000;;			switch pairTypes[index] {
0000000000000000000000000000000000000000;;			case bpNone:
0000000000000000000000000000000000000000;;				// continue scanning
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case bpOpen:
0000000000000000000000000000000000000000;;				// remember opener location, most recent first
0000000000000000000000000000000000000000;;				p.openers.PushFront(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case bpClose:
0000000000000000000000000000000000000000;;				// see if there is a match
0000000000000000000000000000000000000000;;				count := 0
0000000000000000000000000000000000000000;;				for elem := p.openers.Front(); elem != nil; elem = elem.Next() {
0000000000000000000000000000000000000000;;					count++
0000000000000000000000000000000000000000;;					opener := elem.Value.(int)
0000000000000000000000000000000000000000;;					if p.matchOpener(pairValues, opener, i) {
0000000000000000000000000000000000000000;;						// if the opener matches, add nested pair to the ordered list
0000000000000000000000000000000000000000;;						p.pairPositions = append(p.pairPositions, bracketPair{opener, i})
0000000000000000000000000000000000000000;;						// remove up to and including matched opener
0000000000000000000000000000000000000000;;						for ; count > 0; count-- {
0000000000000000000000000000000000000000;;							p.openers.Remove(p.openers.Front())
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(p.pairPositions)
0000000000000000000000000000000000000000;;				// if we get here, the closing bracket matched no openers
0000000000000000000000000000000000000000;;				// and gets ignored
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bracket pairs within an isolating run sequence are processed as units so
0000000000000000000000000000000000000000;;	// that both the opening and the closing paired bracket in a pair resolve to
0000000000000000000000000000000000000000;;	// the same direction.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// N0. Process bracket pairs in an isolating run sequence sequentially in
0000000000000000000000000000000000000000;;	// the logical order of the text positions of the opening paired brackets
0000000000000000000000000000000000000000;;	// using the logic given below. Within this scope, bidirectional types EN
0000000000000000000000000000000000000000;;	// and AN are treated as R.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Identify the bracket pairs in the current isolating run sequence
0000000000000000000000000000000000000000;;	// according to BD16. For each bracket-pair element in the list of pairs of
0000000000000000000000000000000000000000;;	// text positions:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// a Inspect the bidirectional types of the characters enclosed within the
0000000000000000000000000000000000000000;;	// bracket pair.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// b If any strong type (either L or R) matching the embedding direction is
0000000000000000000000000000000000000000;;	// found, set the type for both brackets in the pair to match the embedding
0000000000000000000000000000000000000000;;	// direction.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// o [ e ] o -> o e e e o
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// o [ o e ] -> o e o e e
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// o [ NI e ] -> o e NI e e
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// c Otherwise, if a strong type (opposite the embedding direction) is
0000000000000000000000000000000000000000;;	// found, test for adjacent strong types as follows: 1 First, check
0000000000000000000000000000000000000000;;	// backwards before the opening paired bracket until the first strong type
0000000000000000000000000000000000000000;;	// (L, R, or sos) is found. If that first preceding strong type is opposite
0000000000000000000000000000000000000000;;	// the embedding direction, then set the type for both brackets in the pair
0000000000000000000000000000000000000000;;	// to that type. 2 Otherwise, set the type for both brackets in the pair to
0000000000000000000000000000000000000000;;	// the embedding direction.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// o [ o ] e -> o o o o e
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// o [ o NI ] o -> o o o NI o o
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// e [ o ] o -> e e o e o
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// e [ o ] e -> e e o e e
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// e ( o [ o ] NI ) e -> e e o o o o NI e e
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// d Otherwise, do not set the type for the current bracket pair. Note that
0000000000000000000000000000000000000000;;	// if the enclosed text contains no strong types the paired brackets will
0000000000000000000000000000000000000000;;	// both resolve to the same level when resolved individually using rules N1
0000000000000000000000000000000000000000;;	// and N2.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// e ( NI ) o -> e ( NI ) o
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getStrongTypeN0 maps character's directional code to strong type as required
0000000000000000000000000000000000000000;;	// by rule N0.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: have separate type for "strong" directionality.
0000000000000000000000000000000000000000;;	func (p *bracketPairer) getStrongTypeN0(index int) Class {
0000000000000000000000000000000000000000;;		switch p.codesIsolatedRun[index] {
0000000000000000000000000000000000000000;;		// in the scope of N0, number types are treated as R
0000000000000000000000000000000000000000;;		case EN, AN, AL, R:
0000000000000000000000000000000000000000;;			return R
0000000000000000000000000000000000000000;;		case L:
0000000000000000000000000000000000000000;;			return L
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ON
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// classifyPairContent reports the strong types contained inside a Bracket Pair,
0000000000000000000000000000000000000000;;	// assuming the given embedding direction.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It returns ON if no strong type is found. If a single strong type is found,
0000000000000000000000000000000000000000;;	// it returns this this type. Otherwise it returns the embedding direction.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: use separate type for "strong" directionality.
0000000000000000000000000000000000000000;;	func (p *bracketPairer) classifyPairContent(loc bracketPair, dirEmbed Class) Class {
0000000000000000000000000000000000000000;;		dirOpposite := ON
0000000000000000000000000000000000000000;;		for i := loc.opener + 1; i < loc.closer; i++ {
0000000000000000000000000000000000000000;;			dir := p.getStrongTypeN0(i)
0000000000000000000000000000000000000000;;			if dir == ON {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if dir == dirEmbed {
0000000000000000000000000000000000000000;;				return dir // type matching embedding direction found
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dirOpposite = dir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// return ON if no strong type found, or class opposite to dirEmbed
0000000000000000000000000000000000000000;;		return dirOpposite
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// classBeforePair determines which strong types are present before a Bracket
0000000000000000000000000000000000000000;;	// Pair. Return R or L if strong type found, otherwise ON.
0000000000000000000000000000000000000000;;	func (p *bracketPairer) classBeforePair(loc bracketPair) Class {
0000000000000000000000000000000000000000;;		for i := loc.opener - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			if dir := p.getStrongTypeN0(i); dir != ON {
0000000000000000000000000000000000000000;;				return dir
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// no strong types found, return sos
0000000000000000000000000000000000000000;;		return p.sos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignBracketType implements rule N0 for a single bracket pair.
0000000000000000000000000000000000000000;;	func (p *bracketPairer) assignBracketType(loc bracketPair, dirEmbed Class) {
0000000000000000000000000000000000000000;;		// rule "N0, a", inspect contents of pair
0000000000000000000000000000000000000000;;		dirPair := p.classifyPairContent(loc, dirEmbed)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// dirPair is now L, R, or N (no strong type found)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the following logical tests are performed out of order compared to
0000000000000000000000000000000000000000;;		// the statement of the rules but yield the same results
0000000000000000000000000000000000000000;;		if dirPair == ON {
0000000000000000000000000000000000000000;;			return // case "d" - nothing to do
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dirPair != dirEmbed {
0000000000000000000000000000000000000000;;			// case "c": strong type found, opposite - check before (c.1)
0000000000000000000000000000000000000000;;			dirPair = p.classBeforePair(loc)
0000000000000000000000000000000000000000;;			if dirPair == dirEmbed || dirPair == ON {
0000000000000000000000000000000000000000;;				// no strong opposite type found before - use embedding (c.2)
0000000000000000000000000000000000000000;;				dirPair = dirEmbed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// else: case "b", strong type found matching embedding,
0000000000000000000000000000000000000000;;		// no explicit action needed, as dirPair is already set to embedding
0000000000000000000000000000000000000000;;		// direction
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set the bracket types to the type found
0000000000000000000000000000000000000000;;		p.codesIsolatedRun[loc.opener] = dirPair
0000000000000000000000000000000000000000;;		p.codesIsolatedRun[loc.closer] = dirPair
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolveBrackets implements rule N0 for a list of pairs.
0000000000000000000000000000000000000000;;	func (p *bracketPairer) resolveBrackets(dirEmbed Class) {
0000000000000000000000000000000000000000;;		for _, loc := range p.pairPositions {
0000000000000000000000000000000000000000;;			p.assignBracketType(loc, dirEmbed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
