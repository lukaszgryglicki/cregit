0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// +build ignore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Normalization table generator.
0000000000000000000000000000000000000000;;	// Data read from the web.
0000000000000000000000000000000000000000;;	// See forminfo.go for a description of the trie values associated with each rune.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/gen"
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/triegen"
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/ucd"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		gen.Init()
0000000000000000000000000000000000000000;;		loadUnicodeData()
0000000000000000000000000000000000000000;;		compactCCC()
0000000000000000000000000000000000000000;;		loadCompositionExclusions()
0000000000000000000000000000000000000000;;		completeCharFields(FCanonical)
0000000000000000000000000000000000000000;;		completeCharFields(FCompatibility)
0000000000000000000000000000000000000000;;		computeNonStarterCounts()
0000000000000000000000000000000000000000;;		verifyComputed()
0000000000000000000000000000000000000000;;		printChars()
0000000000000000000000000000000000000000;;		if *test {
0000000000000000000000000000000000000000;;			testDerived()
0000000000000000000000000000000000000000;;			printTestdata()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			makeTables()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		tablelist = flag.String("tables",
0000000000000000000000000000000000000000;;			"all",
0000000000000000000000000000000000000000;;			"comma-separated list of which tables to generate; "+
0000000000000000000000000000000000000000;;				"can be 'decomp', 'recomp', 'info' and 'all'")
0000000000000000000000000000000000000000;;		test = flag.Bool("test",
0000000000000000000000000000000000000000;;			false,
0000000000000000000000000000000000000000;;			"test existing tables against DerivedNormalizationProps and generate test data for regression testing")
0000000000000000000000000000000000000000;;		verbose = flag.Bool("verbose",
0000000000000000000000000000000000000000;;			false,
0000000000000000000000000000000000000000;;			"write data to stdout as it is parsed")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const MaxChar = 0x10FFFF // anything above this shouldn't exist
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Quick Check properties of runes allow us to quickly
0000000000000000000000000000000000000000;;	// determine whether a rune may occur in a normal form.
0000000000000000000000000000000000000000;;	// For a given normal form, a rune may be guaranteed to occur
0000000000000000000000000000000000000000;;	// verbatim (QC=Yes), may or may not combine with another
0000000000000000000000000000000000000000;;	// rune (QC=Maybe), or may not occur (QC=No).
0000000000000000000000000000000000000000;;	type QCResult int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		QCUnknown QCResult = iota
0000000000000000000000000000000000000000;;		QCYes
0000000000000000000000000000000000000000;;		QCNo
0000000000000000000000000000000000000000;;		QCMaybe
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r QCResult) String() string {
0000000000000000000000000000000000000000;;		switch r {
0000000000000000000000000000000000000000;;		case QCYes:
0000000000000000000000000000000000000000;;			return "Yes"
0000000000000000000000000000000000000000;;		case QCNo:
0000000000000000000000000000000000000000;;			return "No"
0000000000000000000000000000000000000000;;		case QCMaybe:
0000000000000000000000000000000000000000;;			return "Maybe"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "***UNKNOWN***"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FCanonical     = iota // NFC or NFD
0000000000000000000000000000000000000000;;		FCompatibility        // NFKC or NFKD
0000000000000000000000000000000000000000;;		FNumberOfFormTypes
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MComposed   = iota // NFC or NFKC
0000000000000000000000000000000000000000;;		MDecomposed        // NFD or NFKD
0000000000000000000000000000000000000000;;		MNumberOfModes
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This contains only the properties we're interested in.
0000000000000000000000000000000000000000;;	type Char struct {
0000000000000000000000000000000000000000;;		name          string
0000000000000000000000000000000000000000;;		codePoint     rune  // if zero, this index is not a valid code point.
0000000000000000000000000000000000000000;;		ccc           uint8 // canonical combining class
0000000000000000000000000000000000000000;;		origCCC       uint8
0000000000000000000000000000000000000000;;		excludeInComp bool // from CompositionExclusions.txt
0000000000000000000000000000000000000000;;		compatDecomp  bool // it has a compatibility expansion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nTrailingNonStarters uint8
0000000000000000000000000000000000000000;;		nLeadingNonStarters  uint8 // must be equal to trailing if non-zero
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		forms [FNumberOfFormTypes]FormInfo // For FCanonical and FCompatibility
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state State
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var chars = make([]Char, MaxChar+1)
0000000000000000000000000000000000000000;;	var cccMap = make(map[uint8]uint8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Char) String() string {
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "%U [%s]:\n", c.codePoint, c.name)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "  ccc: %v\n", c.ccc)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "  excludeInComp: %v\n", c.excludeInComp)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "  compatDecomp: %v\n", c.compatDecomp)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "  state: %v\n", c.state)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "  NFC:\n")
0000000000000000000000000000000000000000;;		fmt.Fprint(buf, c.forms[FCanonical])
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "  NFKC:\n")
0000000000000000000000000000000000000000;;		fmt.Fprint(buf, c.forms[FCompatibility])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// In UnicodeData.txt, some ranges are marked like this:
0000000000000000000000000000000000000000;;	//	3400;<CJK Ideograph Extension A, First>;Lo;0;L;;;;;N;;;;;
0000000000000000000000000000000000000000;;	//	4DB5;<CJK Ideograph Extension A, Last>;Lo;0;L;;;;;N;;;;;
0000000000000000000000000000000000000000;;	// parseCharacter keeps a state variable indicating the weirdness.
0000000000000000000000000000000000000000;;	type State int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SNormal State = iota // known to be zero for the type
0000000000000000000000000000000000000000;;		SFirst
0000000000000000000000000000000000000000;;		SLast
0000000000000000000000000000000000000000;;		SMissing
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var lastChar = rune('\u0000')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Char) isValid() bool {
0000000000000000000000000000000000000000;;		return c.codePoint != 0 && c.state != SMissing
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FormInfo struct {
0000000000000000000000000000000000000000;;		quickCheck [MNumberOfModes]QCResult // index: MComposed or MDecomposed
0000000000000000000000000000000000000000;;		verified   [MNumberOfModes]bool     // index: MComposed or MDecomposed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		combinesForward  bool // May combine with rune on the right
0000000000000000000000000000000000000000;;		combinesBackward bool // May combine with rune on the left
0000000000000000000000000000000000000000;;		isOneWay         bool // Never appears in result
0000000000000000000000000000000000000000;;		inDecomp         bool // Some decompositions result in this char.
0000000000000000000000000000000000000000;;		decomp           Decomposition
0000000000000000000000000000000000000000;;		expandedDecomp   Decomposition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f FormInfo) String() string {
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(make([]byte, 0))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "    quickCheck[C]: %v\n", f.quickCheck[MComposed])
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "    quickCheck[D]: %v\n", f.quickCheck[MDecomposed])
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "    cmbForward: %v\n", f.combinesForward)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "    cmbBackward: %v\n", f.combinesBackward)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "    isOneWay: %v\n", f.isOneWay)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "    inDecomp: %v\n", f.inDecomp)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "    decomposition: %X\n", f.decomp)
0000000000000000000000000000000000000000;;		fmt.Fprintf(buf, "    expandedDecomp: %X\n", f.expandedDecomp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Decomposition []rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseDecomposition(s string, skipfirst bool) (a []rune, err error) {
0000000000000000000000000000000000000000;;		decomp := strings.Split(s, " ")
0000000000000000000000000000000000000000;;		if len(decomp) > 0 && skipfirst {
0000000000000000000000000000000000000000;;			decomp = decomp[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, d := range decomp {
0000000000000000000000000000000000000000;;			point, err := strconv.ParseUint(d, 16, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return a, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a = append(a, rune(point))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadUnicodeData() {
0000000000000000000000000000000000000000;;		f := gen.OpenUCDFile("UnicodeData.txt")
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		p := ucd.New(f)
0000000000000000000000000000000000000000;;		for p.Next() {
0000000000000000000000000000000000000000;;			r := p.Rune(ucd.CodePoint)
0000000000000000000000000000000000000000;;			char := &chars[r]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			char.ccc = uint8(p.Uint(ucd.CanonicalCombiningClass))
0000000000000000000000000000000000000000;;			decmap := p.String(ucd.DecompMapping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			exp, err := parseDecomposition(decmap, false)
0000000000000000000000000000000000000000;;			isCompat := false
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if len(decmap) > 0 {
0000000000000000000000000000000000000000;;					exp, err = parseDecomposition(decmap, true)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						log.Fatalf(`%U: bad decomp |%v|: "%s"`, r, decmap, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					isCompat = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			char.name = p.String(ucd.Name)
0000000000000000000000000000000000000000;;			char.codePoint = r
0000000000000000000000000000000000000000;;			char.forms[FCompatibility].decomp = exp
0000000000000000000000000000000000000000;;			if !isCompat {
0000000000000000000000000000000000000000;;				char.forms[FCanonical].decomp = exp
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				char.compatDecomp = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(decmap) > 0 {
0000000000000000000000000000000000000000;;				char.forms[FCompatibility].decomp = exp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := p.Err(); err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compactCCC converts the sparse set of CCC values to a continguous one,
0000000000000000000000000000000000000000;;	// reducing the number of bits needed from 8 to 6.
0000000000000000000000000000000000000000;;	func compactCCC() {
0000000000000000000000000000000000000000;;		m := make(map[uint8]uint8)
0000000000000000000000000000000000000000;;		for i := range chars {
0000000000000000000000000000000000000000;;			c := &chars[i]
0000000000000000000000000000000000000000;;			m[c.ccc] = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cccs := []int{}
0000000000000000000000000000000000000000;;		for v, _ := range m {
0000000000000000000000000000000000000000;;			cccs = append(cccs, int(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Ints(cccs)
0000000000000000000000000000000000000000;;		for i, c := range cccs {
0000000000000000000000000000000000000000;;			cccMap[uint8(i)] = uint8(c)
0000000000000000000000000000000000000000;;			m[uint8(c)] = uint8(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range chars {
0000000000000000000000000000000000000000;;			c := &chars[i]
0000000000000000000000000000000000000000;;			c.origCCC = c.ccc
0000000000000000000000000000000000000000;;			c.ccc = m[c.ccc]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(m) >= 1<<6 {
0000000000000000000000000000000000000000;;			log.Fatalf("too many difference CCC values: %d >= 64", len(m))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompositionExclusions.txt has form:
0000000000000000000000000000000000000000;;	// 0958    # ...
0000000000000000000000000000000000000000;;	// See http://unicode.org/reports/tr44/ for full explanation
0000000000000000000000000000000000000000;;	func loadCompositionExclusions() {
0000000000000000000000000000000000000000;;		f := gen.OpenUCDFile("CompositionExclusions.txt")
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		p := ucd.New(f)
0000000000000000000000000000000000000000;;		for p.Next() {
0000000000000000000000000000000000000000;;			c := &chars[p.Rune(0)]
0000000000000000000000000000000000000000;;			if c.excludeInComp {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: Duplicate entry in exclusions.", c.codePoint)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.excludeInComp = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e := p.Err(); e != nil {
0000000000000000000000000000000000000000;;			log.Fatal(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasCompatDecomp returns true if any of the recursive
0000000000000000000000000000000000000000;;	// decompositions contains a compatibility expansion.
0000000000000000000000000000000000000000;;	// In this case, the character may not occur in NFK*.
0000000000000000000000000000000000000000;;	func hasCompatDecomp(r rune) bool {
0000000000000000000000000000000000000000;;		c := &chars[r]
0000000000000000000000000000000000000000;;		if c.compatDecomp {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, d := range c.forms[FCompatibility].decomp {
0000000000000000000000000000000000000000;;			if hasCompatDecomp(d) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Hangul related constants.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		HangulBase = 0xAC00
0000000000000000000000000000000000000000;;		HangulEnd  = 0xD7A4 // hangulBase + Jamo combinations (19 * 21 * 28)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		JamoLBase = 0x1100
0000000000000000000000000000000000000000;;		JamoLEnd  = 0x1113
0000000000000000000000000000000000000000;;		JamoVBase = 0x1161
0000000000000000000000000000000000000000;;		JamoVEnd  = 0x1176
0000000000000000000000000000000000000000;;		JamoTBase = 0x11A8
0000000000000000000000000000000000000000;;		JamoTEnd  = 0x11C3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		JamoLVTCount = 19 * 21 * 28
0000000000000000000000000000000000000000;;		JamoTCount   = 28
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isHangul(r rune) bool {
0000000000000000000000000000000000000000;;		return HangulBase <= r && r < HangulEnd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isHangulWithoutJamoT(r rune) bool {
0000000000000000000000000000000000000000;;		if !isHangul(r) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r -= HangulBase
0000000000000000000000000000000000000000;;		return r < JamoLVTCount && r%JamoTCount == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ccc(r rune) uint8 {
0000000000000000000000000000000000000000;;		return chars[r].ccc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Insert a rune in a buffer, ordered by Canonical Combining Class.
0000000000000000000000000000000000000000;;	func insertOrdered(b Decomposition, r rune) Decomposition {
0000000000000000000000000000000000000000;;		n := len(b)
0000000000000000000000000000000000000000;;		b = append(b, 0)
0000000000000000000000000000000000000000;;		cc := ccc(r)
0000000000000000000000000000000000000000;;		if cc > 0 {
0000000000000000000000000000000000000000;;			// Use bubble sort.
0000000000000000000000000000000000000000;;			for ; n > 0; n-- {
0000000000000000000000000000000000000000;;				if ccc(b[n-1]) <= cc {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b[n] = b[n-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b[n] = r
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recursively decompose.
0000000000000000000000000000000000000000;;	func decomposeRecursive(form int, r rune, d Decomposition) Decomposition {
0000000000000000000000000000000000000000;;		dcomp := chars[r].forms[form].decomp
0000000000000000000000000000000000000000;;		if len(dcomp) == 0 {
0000000000000000000000000000000000000000;;			return insertOrdered(d, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range dcomp {
0000000000000000000000000000000000000000;;			d = decomposeRecursive(form, c, d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func completeCharFields(form int) {
0000000000000000000000000000000000000000;;		// Phase 0: pre-expand decomposition.
0000000000000000000000000000000000000000;;		for i := range chars {
0000000000000000000000000000000000000000;;			f := &chars[i].forms[form]
0000000000000000000000000000000000000000;;			if len(f.decomp) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			exp := make(Decomposition, 0)
0000000000000000000000000000000000000000;;			for _, c := range f.decomp {
0000000000000000000000000000000000000000;;				exp = decomposeRecursive(form, c, exp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.expandedDecomp = exp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Phase 1: composition exclusion, mark decomposition.
0000000000000000000000000000000000000000;;		for i := range chars {
0000000000000000000000000000000000000000;;			c := &chars[i]
0000000000000000000000000000000000000000;;			f := &c.forms[form]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Marks script-specific exclusions and version restricted.
0000000000000000000000000000000000000000;;			f.isOneWay = c.excludeInComp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Singletons
0000000000000000000000000000000000000000;;			f.isOneWay = f.isOneWay || len(f.decomp) == 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Non-starter decompositions
0000000000000000000000000000000000000000;;			if len(f.decomp) > 1 {
0000000000000000000000000000000000000000;;				chk := c.ccc != 0 || chars[f.decomp[0]].ccc != 0
0000000000000000000000000000000000000000;;				f.isOneWay = f.isOneWay || chk
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Runes that decompose into more than two runes.
0000000000000000000000000000000000000000;;			f.isOneWay = f.isOneWay || len(f.decomp) > 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if form == FCompatibility {
0000000000000000000000000000000000000000;;				f.isOneWay = f.isOneWay || hasCompatDecomp(c.codePoint)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, r := range f.decomp {
0000000000000000000000000000000000000000;;				chars[r].forms[form].inDecomp = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Phase 2: forward and backward combining.
0000000000000000000000000000000000000000;;		for i := range chars {
0000000000000000000000000000000000000000;;			c := &chars[i]
0000000000000000000000000000000000000000;;			f := &c.forms[form]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !f.isOneWay && len(f.decomp) == 2 {
0000000000000000000000000000000000000000;;				f0 := &chars[f.decomp[0]].forms[form]
0000000000000000000000000000000000000000;;				f1 := &chars[f.decomp[1]].forms[form]
0000000000000000000000000000000000000000;;				if !f0.isOneWay {
0000000000000000000000000000000000000000;;					f0.combinesForward = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !f1.isOneWay {
0000000000000000000000000000000000000000;;					f1.combinesBackward = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isHangulWithoutJamoT(rune(i)) {
0000000000000000000000000000000000000000;;				f.combinesForward = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Phase 3: quick check values.
0000000000000000000000000000000000000000;;		for i := range chars {
0000000000000000000000000000000000000000;;			c := &chars[i]
0000000000000000000000000000000000000000;;			f := &c.forms[form]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case len(f.decomp) > 0:
0000000000000000000000000000000000000000;;				f.quickCheck[MDecomposed] = QCNo
0000000000000000000000000000000000000000;;			case isHangul(rune(i)):
0000000000000000000000000000000000000000;;				f.quickCheck[MDecomposed] = QCNo
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				f.quickCheck[MDecomposed] = QCYes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case f.isOneWay:
0000000000000000000000000000000000000000;;				f.quickCheck[MComposed] = QCNo
0000000000000000000000000000000000000000;;			case (i & 0xffff00) == JamoLBase:
0000000000000000000000000000000000000000;;				f.quickCheck[MComposed] = QCYes
0000000000000000000000000000000000000000;;				if JamoLBase <= i && i < JamoLEnd {
0000000000000000000000000000000000000000;;					f.combinesForward = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if JamoVBase <= i && i < JamoVEnd {
0000000000000000000000000000000000000000;;					f.quickCheck[MComposed] = QCMaybe
0000000000000000000000000000000000000000;;					f.combinesBackward = true
0000000000000000000000000000000000000000;;					f.combinesForward = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if JamoTBase <= i && i < JamoTEnd {
0000000000000000000000000000000000000000;;					f.quickCheck[MComposed] = QCMaybe
0000000000000000000000000000000000000000;;					f.combinesBackward = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case !f.combinesBackward:
0000000000000000000000000000000000000000;;				f.quickCheck[MComposed] = QCYes
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				f.quickCheck[MComposed] = QCMaybe
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func computeNonStarterCounts() {
0000000000000000000000000000000000000000;;		// Phase 4: leading and trailing non-starter count
0000000000000000000000000000000000000000;;		for i := range chars {
0000000000000000000000000000000000000000;;			c := &chars[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			runes := []rune{rune(i)}
0000000000000000000000000000000000000000;;			// We always use FCompatibility so that the CGJ insertion points do not
0000000000000000000000000000000000000000;;			// change for repeated normalizations with different forms.
0000000000000000000000000000000000000000;;			if exp := c.forms[FCompatibility].expandedDecomp; len(exp) > 0 {
0000000000000000000000000000000000000000;;				runes = exp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We consider runes that combine backwards to be non-starters for the
0000000000000000000000000000000000000000;;			// purpose of Stream-Safe Text Processing.
0000000000000000000000000000000000000000;;			for _, r := range runes {
0000000000000000000000000000000000000000;;				if cr := &chars[r]; cr.ccc == 0 && !cr.forms[FCompatibility].combinesBackward {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c.nLeadingNonStarters++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := len(runes) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;				if cr := &chars[runes[i]]; cr.ccc == 0 && !cr.forms[FCompatibility].combinesBackward {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c.nTrailingNonStarters++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.nTrailingNonStarters > 3 {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: Decomposition with more than 3 (%d) trailing modifiers (%U)", i, c.nTrailingNonStarters, runes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isHangul(rune(i)) {
0000000000000000000000000000000000000000;;				c.nTrailingNonStarters = 2
0000000000000000000000000000000000000000;;				if isHangulWithoutJamoT(rune(i)) {
0000000000000000000000000000000000000000;;					c.nTrailingNonStarters = 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l, t := c.nLeadingNonStarters, c.nTrailingNonStarters; l > 0 && l != t {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: number of leading and trailing non-starters should be equal (%d vs %d)", i, l, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t := c.nTrailingNonStarters; t > 3 {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: number of trailing non-starters is %d > 3", t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printBytes(w io.Writer, b []byte, name string) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "// %s: %d bytes\n", name, len(b))
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "var %s = [...]byte {", name)
0000000000000000000000000000000000000000;;		for i, c := range b {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case i%64 == 0:
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "\n// Bytes %x - %x\n", i, i+63)
0000000000000000000000000000000000000000;;			case i%8 == 0:
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "0x%.2X, ", c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprint(w, "\n}\n\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See forminfo.go for format.
0000000000000000000000000000000000000000;;	func makeEntry(f *FormInfo, c *Char) uint16 {
0000000000000000000000000000000000000000;;		e := uint16(0)
0000000000000000000000000000000000000000;;		if r := c.codePoint; HangulBase <= r && r < HangulEnd {
0000000000000000000000000000000000000000;;			e |= 0x40
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.combinesForward {
0000000000000000000000000000000000000000;;			e |= 0x20
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.quickCheck[MDecomposed] == QCNo {
0000000000000000000000000000000000000000;;			e |= 0x4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch f.quickCheck[MComposed] {
0000000000000000000000000000000000000000;;		case QCYes:
0000000000000000000000000000000000000000;;		case QCNo:
0000000000000000000000000000000000000000;;			e |= 0x10
0000000000000000000000000000000000000000;;		case QCMaybe:
0000000000000000000000000000000000000000;;			e |= 0x18
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			log.Fatalf("Illegal quickcheck value %v.", f.quickCheck[MComposed])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e |= uint16(c.nTrailingNonStarters)
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decompSet keeps track of unique decompositions, grouped by whether
0000000000000000000000000000000000000000;;	// the decomposition is followed by a trailing and/or leading CCC.
0000000000000000000000000000000000000000;;	type decompSet [7]map[string]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		normalDecomp = iota
0000000000000000000000000000000000000000;;		firstMulti
0000000000000000000000000000000000000000;;		firstCCC
0000000000000000000000000000000000000000;;		endMulti
0000000000000000000000000000000000000000;;		firstLeadingCCC
0000000000000000000000000000000000000000;;		firstCCCZeroExcept
0000000000000000000000000000000000000000;;		firstStarterWithNLead
0000000000000000000000000000000000000000;;		lastDecomp
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cname = []string{"firstMulti", "firstCCC", "endMulti", "firstLeadingCCC", "firstCCCZeroExcept", "firstStarterWithNLead", "lastDecomp"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeDecompSet() decompSet {
0000000000000000000000000000000000000000;;		m := decompSet{}
0000000000000000000000000000000000000000;;		for i := range m {
0000000000000000000000000000000000000000;;			m[i] = make(map[string]bool)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (m *decompSet) insert(key int, s string) {
0000000000000000000000000000000000000000;;		m[key][s] = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printCharInfoTables(w io.Writer) int {
0000000000000000000000000000000000000000;;		mkstr := func(r rune, f *FormInfo) (int, string) {
0000000000000000000000000000000000000000;;			d := f.expandedDecomp
0000000000000000000000000000000000000000;;			s := string([]rune(d))
0000000000000000000000000000000000000000;;			if max := 1 << 6; len(s) >= max {
0000000000000000000000000000000000000000;;				const msg = "%U: too many bytes in decomposition: %d >= %d"
0000000000000000000000000000000000000000;;				log.Fatalf(msg, r, len(s), max)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			head := uint8(len(s))
0000000000000000000000000000000000000000;;			if f.quickCheck[MComposed] != QCYes {
0000000000000000000000000000000000000000;;				head |= 0x40
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f.combinesForward {
0000000000000000000000000000000000000000;;				head |= 0x80
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = string([]byte{head}) + s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lccc := ccc(d[0])
0000000000000000000000000000000000000000;;			tccc := ccc(d[len(d)-1])
0000000000000000000000000000000000000000;;			cc := ccc(r)
0000000000000000000000000000000000000000;;			if cc != 0 && lccc == 0 && tccc == 0 {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: trailing and leading ccc are 0 for non-zero ccc %d", r, cc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tccc < lccc && lccc != 0 {
0000000000000000000000000000000000000000;;				const msg = "%U: lccc (%d) must be <= tcc (%d)"
0000000000000000000000000000000000000000;;				log.Fatalf(msg, r, lccc, tccc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			index := normalDecomp
0000000000000000000000000000000000000000;;			nTrail := chars[r].nTrailingNonStarters
0000000000000000000000000000000000000000;;			if tccc > 0 || lccc > 0 || nTrail > 0 {
0000000000000000000000000000000000000000;;				tccc <<= 2
0000000000000000000000000000000000000000;;				tccc |= nTrail
0000000000000000000000000000000000000000;;				s += string([]byte{tccc})
0000000000000000000000000000000000000000;;				index = endMulti
0000000000000000000000000000000000000000;;				for _, r := range d[1:] {
0000000000000000000000000000000000000000;;					if ccc(r) == 0 {
0000000000000000000000000000000000000000;;						index = firstCCC
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if lccc > 0 {
0000000000000000000000000000000000000000;;					s += string([]byte{lccc})
0000000000000000000000000000000000000000;;					if index == firstCCC {
0000000000000000000000000000000000000000;;						log.Fatalf("%U: multi-segment decomposition not supported for decompositions with leading CCC != 0", r)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					index = firstLeadingCCC
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cc != lccc {
0000000000000000000000000000000000000000;;					if cc != 0 {
0000000000000000000000000000000000000000;;						log.Fatalf("%U: for lccc != ccc, expected ccc to be 0; was %d", r, cc)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					index = firstCCCZeroExcept
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if len(d) > 1 {
0000000000000000000000000000000000000000;;				index = firstMulti
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return index, s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decompSet := makeDecompSet()
0000000000000000000000000000000000000000;;		const nLeadStr = "\x00\x01" // 0-byte length and tccc with nTrail.
0000000000000000000000000000000000000000;;		decompSet.insert(firstStarterWithNLead, nLeadStr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Store the uniqued decompositions in a byte buffer,
0000000000000000000000000000000000000000;;		// preceded by their byte length.
0000000000000000000000000000000000000000;;		for _, c := range chars {
0000000000000000000000000000000000000000;;			for _, f := range c.forms {
0000000000000000000000000000000000000000;;				if len(f.expandedDecomp) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if f.combinesBackward {
0000000000000000000000000000000000000000;;					log.Fatalf("%U: combinesBackward and decompose", c.codePoint)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				index, s := mkstr(c.codePoint, &f)
0000000000000000000000000000000000000000;;				decompSet.insert(index, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decompositions := bytes.NewBuffer(make([]byte, 0, 10000))
0000000000000000000000000000000000000000;;		size := 0
0000000000000000000000000000000000000000;;		positionMap := make(map[string]uint16)
0000000000000000000000000000000000000000;;		decompositions.WriteString("\000")
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "const (")
0000000000000000000000000000000000000000;;		for i, m := range decompSet {
0000000000000000000000000000000000000000;;			sa := []string{}
0000000000000000000000000000000000000000;;			for s := range m {
0000000000000000000000000000000000000000;;				sa = append(sa, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(sa)
0000000000000000000000000000000000000000;;			for _, s := range sa {
0000000000000000000000000000000000000000;;				p := decompositions.Len()
0000000000000000000000000000000000000000;;				decompositions.WriteString(s)
0000000000000000000000000000000000000000;;				positionMap[s] = uint16(p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cname[i] != "" {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "%s = 0x%X\n", cname[i], decompositions.Len())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "maxDecomp = 0x8000")
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, ")")
0000000000000000000000000000000000000000;;		b := decompositions.Bytes()
0000000000000000000000000000000000000000;;		printBytes(w, b, "decomps")
0000000000000000000000000000000000000000;;		size += len(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		varnames := []string{"nfc", "nfkc"}
0000000000000000000000000000000000000000;;		for i := 0; i < FNumberOfFormTypes; i++ {
0000000000000000000000000000000000000000;;			trie := triegen.NewTrie(varnames[i])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for r, c := range chars {
0000000000000000000000000000000000000000;;				f := c.forms[i]
0000000000000000000000000000000000000000;;				d := f.expandedDecomp
0000000000000000000000000000000000000000;;				if len(d) != 0 {
0000000000000000000000000000000000000000;;					_, key := mkstr(c.codePoint, &f)
0000000000000000000000000000000000000000;;					trie.Insert(rune(r), uint64(positionMap[key]))
0000000000000000000000000000000000000000;;					if c.ccc != ccc(d[0]) {
0000000000000000000000000000000000000000;;						// We assume the lead ccc of a decomposition !=0 in this case.
0000000000000000000000000000000000000000;;						if ccc(d[0]) == 0 {
0000000000000000000000000000000000000000;;							log.Fatalf("Expected leading CCC to be non-zero; ccc is %d", c.ccc)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if c.nLeadingNonStarters > 0 && len(f.expandedDecomp) == 0 && c.ccc == 0 && !f.combinesBackward {
0000000000000000000000000000000000000000;;					// Handle cases where it can't be detected that the nLead should be equal
0000000000000000000000000000000000000000;;					// to nTrail.
0000000000000000000000000000000000000000;;					trie.Insert(c.codePoint, uint64(positionMap[nLeadStr]))
0000000000000000000000000000000000000000;;				} else if v := makeEntry(&f, &c)<<8 | uint16(c.ccc); v != 0 {
0000000000000000000000000000000000000000;;					trie.Insert(c.codePoint, uint64(0x8000|v))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sz, err := trie.Gen(w, triegen.Compact(&normCompacter{name: varnames[i]}))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			size += sz
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(sa []string, s string) bool {
0000000000000000000000000000000000000000;;		for _, a := range sa {
0000000000000000000000000000000000000000;;			if a == s {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeTables() {
0000000000000000000000000000000000000000;;		w := &bytes.Buffer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size := 0
0000000000000000000000000000000000000000;;		if *tablelist == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list := strings.Split(*tablelist, ",")
0000000000000000000000000000000000000000;;		if *tablelist == "all" {
0000000000000000000000000000000000000000;;			list = []string{"recomp", "info"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compute maximum decomposition size.
0000000000000000000000000000000000000000;;		max := 0
0000000000000000000000000000000000000000;;		for _, c := range chars {
0000000000000000000000000000000000000000;;			if n := len(string(c.forms[FCompatibility].expandedDecomp)); n > max {
0000000000000000000000000000000000000000;;				max = n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "const (")
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\t// Version is the Unicode edition from which the tables are derived.")
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "\tVersion = %q\n", gen.UnicodeVersion())
0000000000000000000000000000000000000000;;		fmt.Fprintln(w)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\t// MaxTransformChunkSize indicates the maximum number of bytes that Transform")
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\t// may need to write atomically for any Form. Making a destination buffer at")
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\t// least this size ensures that Transform can always make progress and that")
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\t// the user does not need to grow the buffer on an ErrShortDst.")
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "\tMaxTransformChunkSize = %d+maxNonStarters*4\n", len(string(0x034F))+max)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, ")\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Print the CCC remap table.
0000000000000000000000000000000000000000;;		size += len(cccMap)
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "var ccc = [%d]uint8{", len(cccMap))
0000000000000000000000000000000000000000;;		for i := 0; i < len(cccMap); i++ {
0000000000000000000000000000000000000000;;			if i%8 == 0 {
0000000000000000000000000000000000000000;;				fmt.Fprintln(w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%3d, ", cccMap[uint8(i)])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\n}\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if contains(list, "info") {
0000000000000000000000000000000000000000;;			size += printCharInfoTables(w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if contains(list, "recomp") {
0000000000000000000000000000000000000000;;			// Note that we use 32 bit keys, instead of 64 bit.
0000000000000000000000000000000000000000;;			// This clips the bits of three entries, but we know
0000000000000000000000000000000000000000;;			// this won't cause a collision. The compiler will catch
0000000000000000000000000000000000000000;;			// any changes made to UnicodeData.txt that introduces
0000000000000000000000000000000000000000;;			// a collision.
0000000000000000000000000000000000000000;;			// Note that the recomposition map for NFC and NFKC
0000000000000000000000000000000000000000;;			// are identical.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Recomposition map
0000000000000000000000000000000000000000;;			nrentries := 0
0000000000000000000000000000000000000000;;			for _, c := range chars {
0000000000000000000000000000000000000000;;				f := c.forms[FCanonical]
0000000000000000000000000000000000000000;;				if !f.isOneWay && len(f.decomp) > 0 {
0000000000000000000000000000000000000000;;					nrentries++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sz := nrentries * 8
0000000000000000000000000000000000000000;;			size += sz
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "// recompMap: %d bytes (entries only)\n", sz)
0000000000000000000000000000000000000000;;			fmt.Fprintln(w, "var recompMap = map[uint32]rune{")
0000000000000000000000000000000000000000;;			for i, c := range chars {
0000000000000000000000000000000000000000;;				f := c.forms[FCanonical]
0000000000000000000000000000000000000000;;				d := f.decomp
0000000000000000000000000000000000000000;;				if !f.isOneWay && len(d) > 0 {
0000000000000000000000000000000000000000;;					key := uint32(uint16(d[0]))<<16 + uint32(uint16(d[1]))
0000000000000000000000000000000000000000;;					fmt.Fprintf(w, "0x%.8X: 0x%.4X,\n", key, i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "}\n\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "// Total size of tables: %dKB (%d bytes)\n", (size+512)/1024, size)
0000000000000000000000000000000000000000;;		gen.WriteGoFile("tables.go", "norm", w.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printChars() {
0000000000000000000000000000000000000000;;		if *verbose {
0000000000000000000000000000000000000000;;			for _, c := range chars {
0000000000000000000000000000000000000000;;				if !c.isValid() || c.state == SMissing {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Println(c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyComputed does various consistency tests.
0000000000000000000000000000000000000000;;	func verifyComputed() {
0000000000000000000000000000000000000000;;		for i, c := range chars {
0000000000000000000000000000000000000000;;			for _, f := range c.forms {
0000000000000000000000000000000000000000;;				isNo := (f.quickCheck[MDecomposed] == QCNo)
0000000000000000000000000000000000000000;;				if (len(f.decomp) > 0) != isNo && !isHangul(rune(i)) {
0000000000000000000000000000000000000000;;					log.Fatalf("%U: NF*D QC must be No if rune decomposes", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				isMaybe := f.quickCheck[MComposed] == QCMaybe
0000000000000000000000000000000000000000;;				if f.combinesBackward != isMaybe {
0000000000000000000000000000000000000000;;					log.Fatalf("%U: NF*C QC must be Maybe if combinesBackward", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(f.decomp) > 0 && f.combinesForward && isMaybe {
0000000000000000000000000000000000000000;;					log.Fatalf("%U: NF*C QC must be Yes or No if combinesForward and decomposes", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(f.expandedDecomp) != 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if a, b := c.nLeadingNonStarters > 0, (c.ccc > 0 || f.combinesBackward); a != b {
0000000000000000000000000000000000000000;;					// We accept these runes to be treated differently (it only affects
0000000000000000000000000000000000000000;;					// segment breaking in iteration, most likely on improper use), but
0000000000000000000000000000000000000000;;					// reconsider if more characters are added.
0000000000000000000000000000000000000000;;					// U+FF9E HALFWIDTH KATAKANA VOICED SOUND MARK;Lm;0;L;<narrow> 3099;;;;N;;;;;
0000000000000000000000000000000000000000;;					// U+FF9F HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK;Lm;0;L;<narrow> 309A;;;;N;;;;;
0000000000000000000000000000000000000000;;					// U+3133 HANGUL LETTER KIYEOK-SIOS;Lo;0;L;<compat> 11AA;;;;N;HANGUL LETTER GIYEOG SIOS;;;;
0000000000000000000000000000000000000000;;					// U+318E HANGUL LETTER ARAEAE;Lo;0;L;<compat> 11A1;;;;N;HANGUL LETTER ALAE AE;;;;
0000000000000000000000000000000000000000;;					// U+FFA3 HALFWIDTH HANGUL LETTER KIYEOK-SIOS;Lo;0;L;<narrow> 3133;;;;N;HALFWIDTH HANGUL LETTER GIYEOG SIOS;;;;
0000000000000000000000000000000000000000;;					// U+FFDC HALFWIDTH HANGUL LETTER I;Lo;0;L;<narrow> 3163;;;;N;;;;;
0000000000000000000000000000000000000000;;					if i != 0xFF9E && i != 0xFF9F && !(0x3133 <= i && i <= 0x318E) && !(0xFFA3 <= i && i <= 0xFFDC) {
0000000000000000000000000000000000000000;;						log.Fatalf("%U: nLead was %v; want %v", i, a, b)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nfc := c.forms[FCanonical]
0000000000000000000000000000000000000000;;			nfkc := c.forms[FCompatibility]
0000000000000000000000000000000000000000;;			if nfc.combinesBackward != nfkc.combinesBackward {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: Cannot combine combinesBackward\n", c.codePoint)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Use values in DerivedNormalizationProps.txt to compare against the
0000000000000000000000000000000000000000;;	// values we computed.
0000000000000000000000000000000000000000;;	// DerivedNormalizationProps.txt has form:
0000000000000000000000000000000000000000;;	// 00C0..00C5    ; NFD_QC; N # ...
0000000000000000000000000000000000000000;;	// 0374          ; NFD_QC; N # ...
0000000000000000000000000000000000000000;;	// See http://unicode.org/reports/tr44/ for full explanation
0000000000000000000000000000000000000000;;	func testDerived() {
0000000000000000000000000000000000000000;;		f := gen.OpenUCDFile("DerivedNormalizationProps.txt")
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;		p := ucd.New(f)
0000000000000000000000000000000000000000;;		for p.Next() {
0000000000000000000000000000000000000000;;			r := p.Rune(0)
0000000000000000000000000000000000000000;;			c := &chars[r]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var ftype, mode int
0000000000000000000000000000000000000000;;			qt := p.String(1)
0000000000000000000000000000000000000000;;			switch qt {
0000000000000000000000000000000000000000;;			case "NFC_QC":
0000000000000000000000000000000000000000;;				ftype, mode = FCanonical, MComposed
0000000000000000000000000000000000000000;;			case "NFD_QC":
0000000000000000000000000000000000000000;;				ftype, mode = FCanonical, MDecomposed
0000000000000000000000000000000000000000;;			case "NFKC_QC":
0000000000000000000000000000000000000000;;				ftype, mode = FCompatibility, MComposed
0000000000000000000000000000000000000000;;			case "NFKD_QC":
0000000000000000000000000000000000000000;;				ftype, mode = FCompatibility, MDecomposed
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var qr QCResult
0000000000000000000000000000000000000000;;			switch p.String(2) {
0000000000000000000000000000000000000000;;			case "Y":
0000000000000000000000000000000000000000;;				qr = QCYes
0000000000000000000000000000000000000000;;			case "N":
0000000000000000000000000000000000000000;;				qr = QCNo
0000000000000000000000000000000000000000;;			case "M":
0000000000000000000000000000000000000000;;				qr = QCMaybe
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				log.Fatalf(`Unexpected quick check value "%s"`, p.String(2))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if got := c.forms[ftype].quickCheck[mode]; got != qr {
0000000000000000000000000000000000000000;;				log.Printf("%U: FAILED %s (was %v need %v)\n", r, qt, got, qr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.forms[ftype].verified[mode] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := p.Err(); err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Any unspecified value must be QCYes. Verify this.
0000000000000000000000000000000000000000;;		for i, c := range chars {
0000000000000000000000000000000000000000;;			for j, fd := range c.forms {
0000000000000000000000000000000000000000;;				for k, qr := range fd.quickCheck {
0000000000000000000000000000000000000000;;					if !fd.verified[k] && qr != QCYes {
0000000000000000000000000000000000000000;;						m := "%U: FAIL F:%d M:%d (was %v need Yes) %s\n"
0000000000000000000000000000000000000000;;						log.Printf(m, i, j, k, qr, c.name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var testHeader = `const (
0000000000000000000000000000000000000000;;		Yes = iota
0000000000000000000000000000000000000000;;		No
0000000000000000000000000000000000000000;;		Maybe
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type formData struct {
0000000000000000000000000000000000000000;;		qc              uint8
0000000000000000000000000000000000000000;;		combinesForward bool
0000000000000000000000000000000000000000;;		decomposition   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type runeData struct {
0000000000000000000000000000000000000000;;		r      rune
0000000000000000000000000000000000000000;;		ccc    uint8
0000000000000000000000000000000000000000;;		nLead  uint8
0000000000000000000000000000000000000000;;		nTrail uint8
0000000000000000000000000000000000000000;;		f      [2]formData // 0: canonical; 1: compatibility
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func f(qc uint8, cf bool, dec string) [2]formData {
0000000000000000000000000000000000000000;;		return [2]formData{{qc, cf, dec}, {qc, cf, dec}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func g(qc, qck uint8, cf, cfk bool, d, dk string) [2]formData {
0000000000000000000000000000000000000000;;		return [2]formData{{qc, cf, d}, {qck, cfk, dk}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var testData = []runeData{
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printTestdata() {
0000000000000000000000000000000000000000;;		type lastInfo struct {
0000000000000000000000000000000000000000;;			ccc    uint8
0000000000000000000000000000000000000000;;			nLead  uint8
0000000000000000000000000000000000000000;;			nTrail uint8
0000000000000000000000000000000000000000;;			f      string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		last := lastInfo{}
0000000000000000000000000000000000000000;;		w := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, testHeader)
0000000000000000000000000000000000000000;;		for r, c := range chars {
0000000000000000000000000000000000000000;;			f := c.forms[FCanonical]
0000000000000000000000000000000000000000;;			qc, cf, d := f.quickCheck[MComposed], f.combinesForward, string(f.expandedDecomp)
0000000000000000000000000000000000000000;;			f = c.forms[FCompatibility]
0000000000000000000000000000000000000000;;			qck, cfk, dk := f.quickCheck[MComposed], f.combinesForward, string(f.expandedDecomp)
0000000000000000000000000000000000000000;;			s := ""
0000000000000000000000000000000000000000;;			if d == dk && qc == qck && cf == cfk {
0000000000000000000000000000000000000000;;				s = fmt.Sprintf("f(%s, %v, %q)", qc, cf, d)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s = fmt.Sprintf("g(%s, %s, %v, %v, %q, %q)", qc, qck, cf, cfk, d, dk)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			current := lastInfo{c.ccc, c.nLeadingNonStarters, c.nTrailingNonStarters, s}
0000000000000000000000000000000000000000;;			if last != current {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "\t{0x%x, %d, %d, %d, %s},\n", r, c.origCCC, c.nLeadingNonStarters, c.nTrailingNonStarters, s)
0000000000000000000000000000000000000000;;				last = current
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "}")
0000000000000000000000000000000000000000;;		gen.WriteGoFile("data_test.go", "norm", w.Bytes())
0000000000000000000000000000000000000000;;	}
