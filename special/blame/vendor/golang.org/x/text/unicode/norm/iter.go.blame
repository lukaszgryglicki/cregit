0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package norm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxSegmentSize is the maximum size of a byte buffer needed to consider any
0000000000000000000000000000000000000000;;	// sequence of starter and non-starter runes for the purpose of normalization.
0000000000000000000000000000000000000000;;	const MaxSegmentSize = maxByteBufferSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Iter iterates over a string or byte slice, while normalizing it
0000000000000000000000000000000000000000;;	// to a given Form.
0000000000000000000000000000000000000000;;	type Iter struct {
0000000000000000000000000000000000000000;;		rb     reorderBuffer
0000000000000000000000000000000000000000;;		buf    [maxByteBufferSize]byte
0000000000000000000000000000000000000000;;		info   Properties // first character saved from previous iteration
0000000000000000000000000000000000000000;;		next   iterFunc   // implementation of next depends on form
0000000000000000000000000000000000000000;;		asciiF iterFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p        int    // current position in input source
0000000000000000000000000000000000000000;;		multiSeg []byte // remainder of multi-segment decomposition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type iterFunc func(*Iter) []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init initializes i to iterate over src after normalizing it to Form f.
0000000000000000000000000000000000000000;;	func (i *Iter) Init(f Form, src []byte) {
0000000000000000000000000000000000000000;;		i.p = 0
0000000000000000000000000000000000000000;;		if len(src) == 0 {
0000000000000000000000000000000000000000;;			i.setDone()
0000000000000000000000000000000000000000;;			i.rb.nsrc = 0
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.multiSeg = nil
0000000000000000000000000000000000000000;;		i.rb.init(f, src)
0000000000000000000000000000000000000000;;		i.next = i.rb.f.nextMain
0000000000000000000000000000000000000000;;		i.asciiF = nextASCIIBytes
0000000000000000000000000000000000000000;;		i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InitString initializes i to iterate over src after normalizing it to Form f.
0000000000000000000000000000000000000000;;	func (i *Iter) InitString(f Form, src string) {
0000000000000000000000000000000000000000;;		i.p = 0
0000000000000000000000000000000000000000;;		if len(src) == 0 {
0000000000000000000000000000000000000000;;			i.setDone()
0000000000000000000000000000000000000000;;			i.rb.nsrc = 0
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.multiSeg = nil
0000000000000000000000000000000000000000;;		i.rb.initString(f, src)
0000000000000000000000000000000000000000;;		i.next = i.rb.f.nextMain
0000000000000000000000000000000000000000;;		i.asciiF = nextASCIIString
0000000000000000000000000000000000000000;;		i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Seek sets the segment to be returned by the next call to Next to start
0000000000000000000000000000000000000000;;	// at position p.  It is the responsibility of the caller to set p to the
0000000000000000000000000000000000000000;;	// start of a UTF8 rune.
0000000000000000000000000000000000000000;;	func (i *Iter) Seek(offset int64, whence int) (int64, error) {
0000000000000000000000000000000000000000;;		var abs int64
0000000000000000000000000000000000000000;;		switch whence {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			abs = offset
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			abs = int64(i.p) + offset
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			abs = int64(i.rb.nsrc) + offset
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("norm: invalid whence")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if abs < 0 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("norm: negative position")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if int(abs) >= i.rb.nsrc {
0000000000000000000000000000000000000000;;			i.setDone()
0000000000000000000000000000000000000000;;			return int64(i.p), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.p = int(abs)
0000000000000000000000000000000000000000;;		i.multiSeg = nil
0000000000000000000000000000000000000000;;		i.next = i.rb.f.nextMain
0000000000000000000000000000000000000000;;		i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;		return abs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returnSlice returns a slice of the underlying input type as a byte slice.
0000000000000000000000000000000000000000;;	// If the underlying is of type []byte, it will simply return a slice.
0000000000000000000000000000000000000000;;	// If the underlying is of type string, it will copy the slice to the buffer
0000000000000000000000000000000000000000;;	// and return that.
0000000000000000000000000000000000000000;;	func (i *Iter) returnSlice(a, b int) []byte {
0000000000000000000000000000000000000000;;		if i.rb.src.bytes == nil {
0000000000000000000000000000000000000000;;			return i.buf[:copy(i.buf[:], i.rb.src.str[a:b])]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i.rb.src.bytes[a:b]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pos returns the byte position at which the next call to Next will commence processing.
0000000000000000000000000000000000000000;;	func (i *Iter) Pos() int {
0000000000000000000000000000000000000000;;		return i.p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *Iter) setDone() {
0000000000000000000000000000000000000000;;		i.next = nextDone
0000000000000000000000000000000000000000;;		i.p = i.rb.nsrc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Done returns true if there is no more input to process.
0000000000000000000000000000000000000000;;	func (i *Iter) Done() bool {
0000000000000000000000000000000000000000;;		return i.p >= i.rb.nsrc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Next returns f(i.input[i.Pos():n]), where n is a boundary of i.input.
0000000000000000000000000000000000000000;;	// For any input a and b for which f(a) == f(b), subsequent calls
0000000000000000000000000000000000000000;;	// to Next will return the same segments.
0000000000000000000000000000000000000000;;	// Modifying runes are grouped together with the preceding starter, if such a starter exists.
0000000000000000000000000000000000000000;;	// Although not guaranteed, n will typically be the smallest possible n.
0000000000000000000000000000000000000000;;	func (i *Iter) Next() []byte {
0000000000000000000000000000000000000000;;		return i.next(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nextASCIIBytes(i *Iter) []byte {
0000000000000000000000000000000000000000;;		p := i.p + 1
0000000000000000000000000000000000000000;;		if p >= i.rb.nsrc {
0000000000000000000000000000000000000000;;			i.setDone()
0000000000000000000000000000000000000000;;			return i.rb.src.bytes[i.p:p]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i.rb.src.bytes[p] < utf8.RuneSelf {
0000000000000000000000000000000000000000;;			p0 := i.p
0000000000000000000000000000000000000000;;			i.p = p
0000000000000000000000000000000000000000;;			return i.rb.src.bytes[p0:p]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;		i.next = i.rb.f.nextMain
0000000000000000000000000000000000000000;;		return i.next(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nextASCIIString(i *Iter) []byte {
0000000000000000000000000000000000000000;;		p := i.p + 1
0000000000000000000000000000000000000000;;		if p >= i.rb.nsrc {
0000000000000000000000000000000000000000;;			i.buf[0] = i.rb.src.str[i.p]
0000000000000000000000000000000000000000;;			i.setDone()
0000000000000000000000000000000000000000;;			return i.buf[:1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i.rb.src.str[p] < utf8.RuneSelf {
0000000000000000000000000000000000000000;;			i.buf[0] = i.rb.src.str[i.p]
0000000000000000000000000000000000000000;;			i.p = p
0000000000000000000000000000000000000000;;			return i.buf[:1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;		i.next = i.rb.f.nextMain
0000000000000000000000000000000000000000;;		return i.next(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nextHangul(i *Iter) []byte {
0000000000000000000000000000000000000000;;		p := i.p
0000000000000000000000000000000000000000;;		next := p + hangulUTF8Size
0000000000000000000000000000000000000000;;		if next >= i.rb.nsrc {
0000000000000000000000000000000000000000;;			i.setDone()
0000000000000000000000000000000000000000;;		} else if i.rb.src.hangul(next) == 0 {
0000000000000000000000000000000000000000;;			i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;			i.next = i.rb.f.nextMain
0000000000000000000000000000000000000000;;			return i.next(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.p = next
0000000000000000000000000000000000000000;;		return i.buf[:decomposeHangul(i.buf[:], i.rb.src.hangul(p))]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nextDone(i *Iter) []byte {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextMulti is used for iterating over multi-segment decompositions
0000000000000000000000000000000000000000;;	// for decomposing normal forms.
0000000000000000000000000000000000000000;;	func nextMulti(i *Iter) []byte {
0000000000000000000000000000000000000000;;		j := 0
0000000000000000000000000000000000000000;;		d := i.multiSeg
0000000000000000000000000000000000000000;;		// skip first rune
0000000000000000000000000000000000000000;;		for j = 1; j < len(d) && !utf8.RuneStart(d[j]); j++ {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for j < len(d) {
0000000000000000000000000000000000000000;;			info := i.rb.f.info(input{bytes: d}, j)
0000000000000000000000000000000000000000;;			if info.BoundaryBefore() {
0000000000000000000000000000000000000000;;				i.multiSeg = d[j:]
0000000000000000000000000000000000000000;;				return d[:j]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			j += int(info.size)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// treat last segment as normal decomposition
0000000000000000000000000000000000000000;;		i.next = i.rb.f.nextMain
0000000000000000000000000000000000000000;;		return i.next(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextMultiNorm is used for iterating over multi-segment decompositions
0000000000000000000000000000000000000000;;	// for composing normal forms.
0000000000000000000000000000000000000000;;	func nextMultiNorm(i *Iter) []byte {
0000000000000000000000000000000000000000;;		j := 0
0000000000000000000000000000000000000000;;		d := i.multiSeg
0000000000000000000000000000000000000000;;		for j < len(d) {
0000000000000000000000000000000000000000;;			info := i.rb.f.info(input{bytes: d}, j)
0000000000000000000000000000000000000000;;			if info.BoundaryBefore() {
0000000000000000000000000000000000000000;;				i.rb.compose()
0000000000000000000000000000000000000000;;				seg := i.buf[:i.rb.flushCopy(i.buf[:])]
0000000000000000000000000000000000000000;;				i.rb.ss.first(info)
0000000000000000000000000000000000000000;;				i.rb.insertUnsafe(input{bytes: d}, j, info)
0000000000000000000000000000000000000000;;				i.multiSeg = d[j+int(info.size):]
0000000000000000000000000000000000000000;;				return seg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i.rb.ss.next(info)
0000000000000000000000000000000000000000;;			i.rb.insertUnsafe(input{bytes: d}, j, info)
0000000000000000000000000000000000000000;;			j += int(info.size)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.multiSeg = nil
0000000000000000000000000000000000000000;;		i.next = nextComposed
0000000000000000000000000000000000000000;;		return doNormComposed(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextDecomposed is the implementation of Next for forms NFD and NFKD.
0000000000000000000000000000000000000000;;	func nextDecomposed(i *Iter) (next []byte) {
0000000000000000000000000000000000000000;;		outp := 0
0000000000000000000000000000000000000000;;		inCopyStart, outCopyStart := i.p, 0
0000000000000000000000000000000000000000;;		ss := mkStreamSafe(i.info)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if sz := int(i.info.size); sz <= 1 {
0000000000000000000000000000000000000000;;				p := i.p
0000000000000000000000000000000000000000;;				i.p++ // ASCII or illegal byte.  Either way, advance by 1.
0000000000000000000000000000000000000000;;				if i.p >= i.rb.nsrc {
0000000000000000000000000000000000000000;;					i.setDone()
0000000000000000000000000000000000000000;;					return i.returnSlice(p, i.p)
0000000000000000000000000000000000000000;;				} else if i.rb.src._byte(i.p) < utf8.RuneSelf {
0000000000000000000000000000000000000000;;					i.next = i.asciiF
0000000000000000000000000000000000000000;;					return i.returnSlice(p, i.p)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				outp++
0000000000000000000000000000000000000000;;			} else if d := i.info.Decomposition(); d != nil {
0000000000000000000000000000000000000000;;				// Note: If leading CCC != 0, then len(d) == 2 and last is also non-zero.
0000000000000000000000000000000000000000;;				// Case 1: there is a leftover to copy.  In this case the decomposition
0000000000000000000000000000000000000000;;				// must begin with a modifier and should always be appended.
0000000000000000000000000000000000000000;;				// Case 2: no leftover. Simply return d if followed by a ccc == 0 value.
0000000000000000000000000000000000000000;;				p := outp + len(d)
0000000000000000000000000000000000000000;;				if outp > 0 {
0000000000000000000000000000000000000000;;					i.rb.src.copySlice(i.buf[outCopyStart:], inCopyStart, i.p)
0000000000000000000000000000000000000000;;					if p > len(i.buf) {
0000000000000000000000000000000000000000;;						return i.buf[:outp]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if i.info.multiSegment() {
0000000000000000000000000000000000000000;;					// outp must be 0 as multi-segment decompositions always
0000000000000000000000000000000000000000;;					// start a new segment.
0000000000000000000000000000000000000000;;					if i.multiSeg == nil {
0000000000000000000000000000000000000000;;						i.multiSeg = d
0000000000000000000000000000000000000000;;						i.next = nextMulti
0000000000000000000000000000000000000000;;						return nextMulti(i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// We are in the last segment.  Treat as normal decomposition.
0000000000000000000000000000000000000000;;					d = i.multiSeg
0000000000000000000000000000000000000000;;					i.multiSeg = nil
0000000000000000000000000000000000000000;;					p = len(d)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				prevCC := i.info.tccc
0000000000000000000000000000000000000000;;				if i.p += sz; i.p >= i.rb.nsrc {
0000000000000000000000000000000000000000;;					i.setDone()
0000000000000000000000000000000000000000;;					i.info = Properties{} // Force BoundaryBefore to succeed.
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch ss.next(i.info) {
0000000000000000000000000000000000000000;;				case ssOverflow:
0000000000000000000000000000000000000000;;					i.next = nextCGJDecompose
0000000000000000000000000000000000000000;;					fallthrough
0000000000000000000000000000000000000000;;				case ssStarter:
0000000000000000000000000000000000000000;;					if outp > 0 {
0000000000000000000000000000000000000000;;						copy(i.buf[outp:], d)
0000000000000000000000000000000000000000;;						return i.buf[:p]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return d
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				copy(i.buf[outp:], d)
0000000000000000000000000000000000000000;;				outp = p
0000000000000000000000000000000000000000;;				inCopyStart, outCopyStart = i.p, outp
0000000000000000000000000000000000000000;;				if i.info.ccc < prevCC {
0000000000000000000000000000000000000000;;					goto doNorm
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if r := i.rb.src.hangul(i.p); r != 0 {
0000000000000000000000000000000000000000;;				outp = decomposeHangul(i.buf[:], r)
0000000000000000000000000000000000000000;;				i.p += hangulUTF8Size
0000000000000000000000000000000000000000;;				inCopyStart, outCopyStart = i.p, outp
0000000000000000000000000000000000000000;;				if i.p >= i.rb.nsrc {
0000000000000000000000000000000000000000;;					i.setDone()
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				} else if i.rb.src.hangul(i.p) != 0 {
0000000000000000000000000000000000000000;;					i.next = nextHangul
0000000000000000000000000000000000000000;;					return i.buf[:outp]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p := outp + sz
0000000000000000000000000000000000000000;;				if p > len(i.buf) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				outp = p
0000000000000000000000000000000000000000;;				i.p += sz
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i.p >= i.rb.nsrc {
0000000000000000000000000000000000000000;;				i.setDone()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prevCC := i.info.tccc
0000000000000000000000000000000000000000;;			i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;			if v := ss.next(i.info); v == ssStarter {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if v == ssOverflow {
0000000000000000000000000000000000000000;;				i.next = nextCGJDecompose
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i.info.ccc < prevCC {
0000000000000000000000000000000000000000;;				goto doNorm
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if outCopyStart == 0 {
0000000000000000000000000000000000000000;;			return i.returnSlice(inCopyStart, i.p)
0000000000000000000000000000000000000000;;		} else if inCopyStart < i.p {
0000000000000000000000000000000000000000;;			i.rb.src.copySlice(i.buf[outCopyStart:], inCopyStart, i.p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i.buf[:outp]
0000000000000000000000000000000000000000;;	doNorm:
0000000000000000000000000000000000000000;;		// Insert what we have decomposed so far in the reorderBuffer.
0000000000000000000000000000000000000000;;		// As we will only reorder, there will always be enough room.
0000000000000000000000000000000000000000;;		i.rb.src.copySlice(i.buf[outCopyStart:], inCopyStart, i.p)
0000000000000000000000000000000000000000;;		i.rb.insertDecomposed(i.buf[0:outp])
0000000000000000000000000000000000000000;;		return doNormDecomposed(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doNormDecomposed(i *Iter) []byte {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if s := i.rb.ss.next(i.info); s == ssOverflow {
0000000000000000000000000000000000000000;;				i.next = nextCGJDecompose
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i.rb.insertUnsafe(i.rb.src, i.p, i.info)
0000000000000000000000000000000000000000;;			if i.p += int(i.info.size); i.p >= i.rb.nsrc {
0000000000000000000000000000000000000000;;				i.setDone()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;			if i.info.ccc == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// new segment or too many combining characters: exit normalization
0000000000000000000000000000000000000000;;		return i.buf[:i.rb.flushCopy(i.buf[:])]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nextCGJDecompose(i *Iter) []byte {
0000000000000000000000000000000000000000;;		i.rb.ss = 0
0000000000000000000000000000000000000000;;		i.rb.insertCGJ()
0000000000000000000000000000000000000000;;		i.next = nextDecomposed
0000000000000000000000000000000000000000;;		buf := doNormDecomposed(i)
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextComposed is the implementation of Next for forms NFC and NFKC.
0000000000000000000000000000000000000000;;	func nextComposed(i *Iter) []byte {
0000000000000000000000000000000000000000;;		outp, startp := 0, i.p
0000000000000000000000000000000000000000;;		var prevCC uint8
0000000000000000000000000000000000000000;;		ss := mkStreamSafe(i.info)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if !i.info.isYesC() {
0000000000000000000000000000000000000000;;				goto doNorm
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prevCC = i.info.tccc
0000000000000000000000000000000000000000;;			sz := int(i.info.size)
0000000000000000000000000000000000000000;;			if sz == 0 {
0000000000000000000000000000000000000000;;				sz = 1 // illegal rune: copy byte-by-byte
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p := outp + sz
0000000000000000000000000000000000000000;;			if p > len(i.buf) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			outp = p
0000000000000000000000000000000000000000;;			i.p += sz
0000000000000000000000000000000000000000;;			if i.p >= i.rb.nsrc {
0000000000000000000000000000000000000000;;				i.setDone()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if i.rb.src._byte(i.p) < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				i.next = i.asciiF
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;			if v := ss.next(i.info); v == ssStarter {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if v == ssOverflow {
0000000000000000000000000000000000000000;;				i.next = nextCGJCompose
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i.info.ccc < prevCC {
0000000000000000000000000000000000000000;;				goto doNorm
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i.returnSlice(startp, i.p)
0000000000000000000000000000000000000000;;	doNorm:
0000000000000000000000000000000000000000;;		i.p = startp
0000000000000000000000000000000000000000;;		i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;		if i.info.multiSegment() {
0000000000000000000000000000000000000000;;			d := i.info.Decomposition()
0000000000000000000000000000000000000000;;			info := i.rb.f.info(input{bytes: d}, 0)
0000000000000000000000000000000000000000;;			i.rb.insertUnsafe(input{bytes: d}, 0, info)
0000000000000000000000000000000000000000;;			i.multiSeg = d[int(info.size):]
0000000000000000000000000000000000000000;;			i.next = nextMultiNorm
0000000000000000000000000000000000000000;;			return nextMultiNorm(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.rb.ss.first(i.info)
0000000000000000000000000000000000000000;;		i.rb.insertUnsafe(i.rb.src, i.p, i.info)
0000000000000000000000000000000000000000;;		return doNormComposed(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doNormComposed(i *Iter) []byte {
0000000000000000000000000000000000000000;;		// First rune should already be inserted.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if i.p += int(i.info.size); i.p >= i.rb.nsrc {
0000000000000000000000000000000000000000;;				i.setDone()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i.info = i.rb.f.info(i.rb.src, i.p)
0000000000000000000000000000000000000000;;			if s := i.rb.ss.next(i.info); s == ssStarter {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if s == ssOverflow {
0000000000000000000000000000000000000000;;				i.next = nextCGJCompose
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i.rb.insertUnsafe(i.rb.src, i.p, i.info)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i.rb.compose()
0000000000000000000000000000000000000000;;		seg := i.buf[:i.rb.flushCopy(i.buf[:])]
0000000000000000000000000000000000000000;;		return seg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nextCGJCompose(i *Iter) []byte {
0000000000000000000000000000000000000000;;		i.rb.ss = 0 // instead of first
0000000000000000000000000000000000000000;;		i.rb.insertCGJ()
0000000000000000000000000000000000000000;;		i.next = nextComposed
0000000000000000000000000000000000000000;;		// Note that we treat any rune with nLeadingNonStarters > 0 as a non-starter,
0000000000000000000000000000000000000000;;		// even if they are not. This is particularly dubious for U+FF9E and UFF9A.
0000000000000000000000000000000000000000;;		// If we ever change that, insert a check here.
0000000000000000000000000000000000000000;;		i.rb.ss.first(i.info)
0000000000000000000000000000000000000000;;		i.rb.insertUnsafe(i.rb.src, i.p, i.info)
0000000000000000000000000000000000000000;;		return doNormComposed(i)
0000000000000000000000000000000000000000;;	}
