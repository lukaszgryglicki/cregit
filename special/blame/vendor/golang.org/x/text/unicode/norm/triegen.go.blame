0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// +build ignore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Trie table generator.
0000000000000000000000000000000000000000;;	// Used by make*tables tools to generate a go file with trie data structures
0000000000000000000000000000000000000000;;	// for mapping UTF-8 to a 16-bit value. All but the last byte in a UTF-8 byte
0000000000000000000000000000000000000000;;	// sequence are used to lookup offsets in the index table to be used for the
0000000000000000000000000000000000000000;;	// next byte. The last byte is used to index into a table with 16-bit values.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxSparseEntries = 16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type normCompacter struct {
0000000000000000000000000000000000000000;;		sparseBlocks [][]uint64
0000000000000000000000000000000000000000;;		sparseOffset []uint16
0000000000000000000000000000000000000000;;		sparseCount  int
0000000000000000000000000000000000000000;;		name         string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mostFrequentStride(a []uint64) int {
0000000000000000000000000000000000000000;;		counts := make(map[int]int)
0000000000000000000000000000000000000000;;		var v int
0000000000000000000000000000000000000000;;		for _, x := range a {
0000000000000000000000000000000000000000;;			if stride := int(x) - v; v != 0 && stride >= 0 {
0000000000000000000000000000000000000000;;				counts[stride]++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = int(x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var maxs, maxc int
0000000000000000000000000000000000000000;;		for stride, cnt := range counts {
0000000000000000000000000000000000000000;;			if cnt > maxc || (cnt == maxc && stride < maxs) {
0000000000000000000000000000000000000000;;				maxs, maxc = stride, cnt
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return maxs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func countSparseEntries(a []uint64) int {
0000000000000000000000000000000000000000;;		stride := mostFrequentStride(a)
0000000000000000000000000000000000000000;;		var v, count int
0000000000000000000000000000000000000000;;		for _, tv := range a {
0000000000000000000000000000000000000000;;			if int(tv)-v != stride {
0000000000000000000000000000000000000000;;				if tv != 0 {
0000000000000000000000000000000000000000;;					count++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = int(tv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return count
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *normCompacter) Size(v []uint64) (sz int, ok bool) {
0000000000000000000000000000000000000000;;		if n := countSparseEntries(v); n <= maxSparseEntries {
0000000000000000000000000000000000000000;;			return (n+1)*4 + 2, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *normCompacter) Store(v []uint64) uint32 {
0000000000000000000000000000000000000000;;		h := uint32(len(c.sparseOffset))
0000000000000000000000000000000000000000;;		c.sparseBlocks = append(c.sparseBlocks, v)
0000000000000000000000000000000000000000;;		c.sparseOffset = append(c.sparseOffset, uint16(c.sparseCount))
0000000000000000000000000000000000000000;;		c.sparseCount += countSparseEntries(v) + 1
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *normCompacter) Handler() string {
0000000000000000000000000000000000000000;;		return c.name + "Sparse.lookup"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *normCompacter) Print(w io.Writer) (retErr error) {
0000000000000000000000000000000000000000;;		p := func(f string, x ...interface{}) {
0000000000000000000000000000000000000000;;			if _, err := fmt.Fprintf(w, f, x...); retErr == nil && err != nil {
0000000000000000000000000000000000000000;;				retErr = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ls := len(c.sparseBlocks)
0000000000000000000000000000000000000000;;		p("// %sSparseOffset: %d entries, %d bytes\n", c.name, ls, ls*2)
0000000000000000000000000000000000000000;;		p("var %sSparseOffset = %#v\n\n", c.name, c.sparseOffset)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := c.sparseCount
0000000000000000000000000000000000000000;;		p("// %sSparseValues: %d entries, %d bytes\n", c.name, ns, ns*4)
0000000000000000000000000000000000000000;;		p("var %sSparseValues = [%d]valueRange {", c.name, ns)
0000000000000000000000000000000000000000;;		for i, b := range c.sparseBlocks {
0000000000000000000000000000000000000000;;			p("\n// Block %#x, offset %#x", i, c.sparseOffset[i])
0000000000000000000000000000000000000000;;			var v int
0000000000000000000000000000000000000000;;			stride := mostFrequentStride(b)
0000000000000000000000000000000000000000;;			n := countSparseEntries(b)
0000000000000000000000000000000000000000;;			p("\n{value:%#04x,lo:%#02x},", stride, uint8(n))
0000000000000000000000000000000000000000;;			for i, nv := range b {
0000000000000000000000000000000000000000;;				if int(nv)-v != stride {
0000000000000000000000000000000000000000;;					if v != 0 {
0000000000000000000000000000000000000000;;						p(",hi:%#02x},", 0x80+i-1)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if nv != 0 {
0000000000000000000000000000000000000000;;						p("\n{value:%#04x,lo:%#02x", nv, 0x80+i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v = int(nv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v != 0 {
0000000000000000000000000000000000000000;;				p(",hi:%#02x},", 0x80+len(b)-1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p("\n}\n\n")
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
