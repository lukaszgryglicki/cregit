0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package norm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains Form-specific logic and wrappers for data in tables.go.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rune info is stored in a separate trie per composing form. A composing form
0000000000000000000000000000000000000000;;	// and its corresponding decomposing form share the same trie.  Each trie maps
0000000000000000000000000000000000000000;;	// a rune to a uint16. The values take two forms.  For v >= 0x8000:
0000000000000000000000000000000000000000;;	//   bits
0000000000000000000000000000000000000000;;	//   15:    1 (inverse of NFD_QD bit of qcInfo)
0000000000000000000000000000000000000000;;	//   13..7: qcInfo (see below). isYesD is always true (no decompostion).
0000000000000000000000000000000000000000;;	//    6..0: ccc (compressed CCC value).
0000000000000000000000000000000000000000;;	// For v < 0x8000, the respective rune has a decomposition and v is an index
0000000000000000000000000000000000000000;;	// into a byte array of UTF-8 decomposition sequences and additional info and
0000000000000000000000000000000000000000;;	// has the form:
0000000000000000000000000000000000000000;;	//    <header> <decomp_byte>* [<tccc> [<lccc>]]
0000000000000000000000000000000000000000;;	// The header contains the number of bytes in the decomposition (excluding this
0000000000000000000000000000000000000000;;	// length byte). The two most significant bits of this length byte correspond
0000000000000000000000000000000000000000;;	// to bit 5 and 4 of qcInfo (see below).  The byte sequence itself starts at v+1.
0000000000000000000000000000000000000000;;	// The byte sequence is followed by a trailing and leading CCC if the values
0000000000000000000000000000000000000000;;	// for these are not zero.  The value of v determines which ccc are appended
0000000000000000000000000000000000000000;;	// to the sequences.  For v < firstCCC, there are none, for v >= firstCCC,
0000000000000000000000000000000000000000;;	// the sequence is followed by a trailing ccc, and for v >= firstLeadingCC
0000000000000000000000000000000000000000;;	// there is an additional leading ccc. The value of tccc itself is the
0000000000000000000000000000000000000000;;	// trailing CCC shifted left 2 bits. The two least-significant bits of tccc
0000000000000000000000000000000000000000;;	// are the number of trailing non-starters.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		qcInfoMask      = 0x3F // to clear all but the relevant bits in a qcInfo
0000000000000000000000000000000000000000;;		headerLenMask   = 0x3F // extract the length value from the header byte
0000000000000000000000000000000000000000;;		headerFlagsMask = 0xC0 // extract the qcInfo bits from the header byte
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Properties provides access to normalization properties of a rune.
0000000000000000000000000000000000000000;;	type Properties struct {
0000000000000000000000000000000000000000;;		pos   uint8  // start position in reorderBuffer; used in composition.go
0000000000000000000000000000000000000000;;		size  uint8  // length of UTF-8 encoding of this rune
0000000000000000000000000000000000000000;;		ccc   uint8  // leading canonical combining class (ccc if not decomposition)
0000000000000000000000000000000000000000;;		tccc  uint8  // trailing canonical combining class (ccc if not decomposition)
0000000000000000000000000000000000000000;;		nLead uint8  // number of leading non-starters.
0000000000000000000000000000000000000000;;		flags qcInfo // quick check flags
0000000000000000000000000000000000000000;;		index uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// functions dispatchable per form
0000000000000000000000000000000000000000;;	type lookupFunc func(b input, i int) Properties
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// formInfo holds Form-specific functions and tables.
0000000000000000000000000000000000000000;;	type formInfo struct {
0000000000000000000000000000000000000000;;		form                     Form
0000000000000000000000000000000000000000;;		composing, compatibility bool // form type
0000000000000000000000000000000000000000;;		info                     lookupFunc
0000000000000000000000000000000000000000;;		nextMain                 iterFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var formTable []*formInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		formTable = make([]*formInfo, 4)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range formTable {
0000000000000000000000000000000000000000;;			f := &formInfo{}
0000000000000000000000000000000000000000;;			formTable[i] = f
0000000000000000000000000000000000000000;;			f.form = Form(i)
0000000000000000000000000000000000000000;;			if Form(i) == NFKD || Form(i) == NFKC {
0000000000000000000000000000000000000000;;				f.compatibility = true
0000000000000000000000000000000000000000;;				f.info = lookupInfoNFKC
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				f.info = lookupInfoNFC
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.nextMain = nextDecomposed
0000000000000000000000000000000000000000;;			if Form(i) == NFC || Form(i) == NFKC {
0000000000000000000000000000000000000000;;				f.nextMain = nextComposed
0000000000000000000000000000000000000000;;				f.composing = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We do not distinguish between boundaries for NFC, NFD, etc. to avoid
0000000000000000000000000000000000000000;;	// unexpected behavior for the user.  For example, in NFD, there is a boundary
0000000000000000000000000000000000000000;;	// after 'a'.  However, 'a' might combine with modifiers, so from the application's
0000000000000000000000000000000000000000;;	// perspective it is not a good boundary. We will therefore always use the
0000000000000000000000000000000000000000;;	// boundaries for the combining variants.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoundaryBefore returns true if this rune starts a new segment and
0000000000000000000000000000000000000000;;	// cannot combine with any rune on the left.
0000000000000000000000000000000000000000;;	func (p Properties) BoundaryBefore() bool {
0000000000000000000000000000000000000000;;		if p.ccc == 0 && !p.combinesBackward() {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We assume that the CCC of the first character in a decomposition
0000000000000000000000000000000000000000;;		// is always non-zero if different from info.ccc and that we can return
0000000000000000000000000000000000000000;;		// false at this point. This is verified by maketables.
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoundaryAfter returns true if runes cannot combine with or otherwise
0000000000000000000000000000000000000000;;	// interact with this or previous runes.
0000000000000000000000000000000000000000;;	func (p Properties) BoundaryAfter() bool {
0000000000000000000000000000000000000000;;		// TODO: loosen these conditions.
0000000000000000000000000000000000000000;;		return p.isInert()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We pack quick check data in 4 bits:
0000000000000000000000000000000000000000;;	//   5:    Combines forward  (0 == false, 1 == true)
0000000000000000000000000000000000000000;;	//   4..3: NFC_QC Yes(00), No (10), or Maybe (11)
0000000000000000000000000000000000000000;;	//   2:    NFD_QC Yes (0) or No (1). No also means there is a decomposition.
0000000000000000000000000000000000000000;;	//   1..0: Number of trailing non-starters.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When all 4 bits are zero, the character is inert, meaning it is never
0000000000000000000000000000000000000000;;	// influenced by normalization.
0000000000000000000000000000000000000000;;	type qcInfo uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Properties) isYesC() bool { return p.flags&0x10 == 0 }
0000000000000000000000000000000000000000;;	func (p Properties) isYesD() bool { return p.flags&0x4 == 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Properties) combinesForward() bool  { return p.flags&0x20 != 0 }
0000000000000000000000000000000000000000;;	func (p Properties) combinesBackward() bool { return p.flags&0x8 != 0 } // == isMaybe
0000000000000000000000000000000000000000;;	func (p Properties) hasDecomposition() bool { return p.flags&0x4 != 0 } // == isNoD
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Properties) isInert() bool {
0000000000000000000000000000000000000000;;		return p.flags&qcInfoMask == 0 && p.ccc == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Properties) multiSegment() bool {
0000000000000000000000000000000000000000;;		return p.index >= firstMulti && p.index < endMulti
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Properties) nLeadingNonStarters() uint8 {
0000000000000000000000000000000000000000;;		return p.nLead
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Properties) nTrailingNonStarters() uint8 {
0000000000000000000000000000000000000000;;		return uint8(p.flags & 0x03)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decomposition returns the decomposition for the underlying rune
0000000000000000000000000000000000000000;;	// or nil if there is none.
0000000000000000000000000000000000000000;;	func (p Properties) Decomposition() []byte {
0000000000000000000000000000000000000000;;		// TODO: create the decomposition for Hangul?
0000000000000000000000000000000000000000;;		if p.index == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := p.index
0000000000000000000000000000000000000000;;		n := decomps[i] & headerLenMask
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		return decomps[i : i+uint16(n)]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size returns the length of UTF-8 encoding of the rune.
0000000000000000000000000000000000000000;;	func (p Properties) Size() int {
0000000000000000000000000000000000000000;;		return int(p.size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CCC returns the canonical combining class of the underlying rune.
0000000000000000000000000000000000000000;;	func (p Properties) CCC() uint8 {
0000000000000000000000000000000000000000;;		if p.index >= firstCCCZeroExcept {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ccc[p.ccc]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LeadCCC returns the CCC of the first rune in the decomposition.
0000000000000000000000000000000000000000;;	// If there is no decomposition, LeadCCC equals CCC.
0000000000000000000000000000000000000000;;	func (p Properties) LeadCCC() uint8 {
0000000000000000000000000000000000000000;;		return ccc[p.ccc]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TrailCCC returns the CCC of the last rune in the decomposition.
0000000000000000000000000000000000000000;;	// If there is no decomposition, TrailCCC equals CCC.
0000000000000000000000000000000000000000;;	func (p Properties) TrailCCC() uint8 {
0000000000000000000000000000000000000000;;		return ccc[p.tccc]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recomposition
0000000000000000000000000000000000000000;;	// We use 32-bit keys instead of 64-bit for the two codepoint keys.
0000000000000000000000000000000000000000;;	// This clips off the bits of three entries, but we know this will not
0000000000000000000000000000000000000000;;	// result in a collision. In the unlikely event that changes to
0000000000000000000000000000000000000000;;	// UnicodeData.txt introduce collisions, the compiler will catch it.
0000000000000000000000000000000000000000;;	// Note that the recomposition map for NFC and NFKC are identical.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// combine returns the combined rune or 0 if it doesn't exist.
0000000000000000000000000000000000000000;;	func combine(a, b rune) rune {
0000000000000000000000000000000000000000;;		key := uint32(uint16(a))<<16 + uint32(uint16(b))
0000000000000000000000000000000000000000;;		return recompMap[key]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lookupInfoNFC(b input, i int) Properties {
0000000000000000000000000000000000000000;;		v, sz := b.charinfoNFC(i)
0000000000000000000000000000000000000000;;		return compInfo(v, sz)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lookupInfoNFKC(b input, i int) Properties {
0000000000000000000000000000000000000000;;		v, sz := b.charinfoNFKC(i)
0000000000000000000000000000000000000000;;		return compInfo(v, sz)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Properties returns properties for the first rune in s.
0000000000000000000000000000000000000000;;	func (f Form) Properties(s []byte) Properties {
0000000000000000000000000000000000000000;;		if f == NFC || f == NFD {
0000000000000000000000000000000000000000;;			return compInfo(nfcData.lookup(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return compInfo(nfkcData.lookup(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PropertiesString returns properties for the first rune in s.
0000000000000000000000000000000000000000;;	func (f Form) PropertiesString(s string) Properties {
0000000000000000000000000000000000000000;;		if f == NFC || f == NFD {
0000000000000000000000000000000000000000;;			return compInfo(nfcData.lookupString(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return compInfo(nfkcData.lookupString(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compInfo converts the information contained in v and sz
0000000000000000000000000000000000000000;;	// to a Properties.  See the comment at the top of the file
0000000000000000000000000000000000000000;;	// for more information on the format.
0000000000000000000000000000000000000000;;	func compInfo(v uint16, sz int) Properties {
0000000000000000000000000000000000000000;;		if v == 0 {
0000000000000000000000000000000000000000;;			return Properties{size: uint8(sz)}
0000000000000000000000000000000000000000;;		} else if v >= 0x8000 {
0000000000000000000000000000000000000000;;			p := Properties{
0000000000000000000000000000000000000000;;				size:  uint8(sz),
0000000000000000000000000000000000000000;;				ccc:   uint8(v),
0000000000000000000000000000000000000000;;				tccc:  uint8(v),
0000000000000000000000000000000000000000;;				flags: qcInfo(v >> 8),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.ccc > 0 || p.combinesBackward() {
0000000000000000000000000000000000000000;;				p.nLead = uint8(p.flags & 0x3)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// has decomposition
0000000000000000000000000000000000000000;;		h := decomps[v]
0000000000000000000000000000000000000000;;		f := (qcInfo(h&headerFlagsMask) >> 2) | 0x4
0000000000000000000000000000000000000000;;		p := Properties{size: uint8(sz), flags: f, index: v}
0000000000000000000000000000000000000000;;		if v >= firstCCC {
0000000000000000000000000000000000000000;;			v += uint16(h&headerLenMask) + 1
0000000000000000000000000000000000000000;;			c := decomps[v]
0000000000000000000000000000000000000000;;			p.tccc = c >> 2
0000000000000000000000000000000000000000;;			p.flags |= qcInfo(c & 0x3)
0000000000000000000000000000000000000000;;			if v >= firstLeadingCCC {
0000000000000000000000000000000000000000;;				p.nLead = c & 0x3
0000000000000000000000000000000000000000;;				if v >= firstStarterWithNLead {
0000000000000000000000000000000000000000;;					// We were tricked. Remove the decomposition.
0000000000000000000000000000000000000000;;					p.flags &= 0x03
0000000000000000000000000000000000000000;;					p.index = 0
0000000000000000000000000000000000000000;;					return p
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.ccc = decomps[v+1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
