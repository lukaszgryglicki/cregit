0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package norm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset implements the Reset method of the transform.Transformer interface.
0000000000000000000000000000000000000000;;	func (Form) Reset() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform implements the Transform method of the transform.Transformer
0000000000000000000000000000000000000000;;	// interface. It may need to write segments of up to MaxSegmentSize at once.
0000000000000000000000000000000000000000;;	// Users should either catch ErrShortDst and allow dst to grow or have dst be at
0000000000000000000000000000000000000000;;	// least of size MaxTransformChunkSize to be guaranteed of progress.
0000000000000000000000000000000000000000;;	func (f Form) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		// Cap the maximum number of src bytes to check.
0000000000000000000000000000000000000000;;		b := src
0000000000000000000000000000000000000000;;		eof := atEOF
0000000000000000000000000000000000000000;;		if ns := len(dst); ns < len(b) {
0000000000000000000000000000000000000000;;			err = transform.ErrShortDst
0000000000000000000000000000000000000000;;			eof = false
0000000000000000000000000000000000000000;;			b = b[:ns]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, ok := formTable[f].quickSpan(inputBytes(b), n, len(b), eof)
0000000000000000000000000000000000000000;;		n += copy(dst[n:], b[n:i])
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			nDst, nSrc, err = f.transform(dst[n:], src[n:], atEOF)
0000000000000000000000000000000000000000;;			return nDst + n, nSrc + n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n < len(src) && !atEOF {
0000000000000000000000000000000000000000;;			err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func flushTransform(rb *reorderBuffer) bool {
0000000000000000000000000000000000000000;;		// Write out (must fully fit in dst, or else it is a ErrShortDst).
0000000000000000000000000000000000000000;;		if len(rb.out) < rb.nrune*utf8.UTFMax {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb.out = rb.out[rb.flushCopy(rb.out):]
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errs = []error{nil, transform.ErrShortDst, transform.ErrShortSrc}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// transform implements the transform.Transformer interface. It is only called
0000000000000000000000000000000000000000;;	// when quickSpan does not pass for a given string.
0000000000000000000000000000000000000000;;	func (f Form) transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		// TODO: get rid of reorderBuffer. See CL 23460044.
0000000000000000000000000000000000000000;;		rb := reorderBuffer{}
0000000000000000000000000000000000000000;;		rb.init(f, src)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Load segment into reorder buffer.
0000000000000000000000000000000000000000;;			rb.setFlusher(dst[nDst:], flushTransform)
0000000000000000000000000000000000000000;;			end := decomposeSegment(&rb, nSrc, atEOF)
0000000000000000000000000000000000000000;;			if end < 0 {
0000000000000000000000000000000000000000;;				return nDst, nSrc, errs[-end]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nDst = len(dst) - len(rb.out)
0000000000000000000000000000000000000000;;			nSrc = end
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Next quickSpan.
0000000000000000000000000000000000000000;;			end = rb.nsrc
0000000000000000000000000000000000000000;;			eof := atEOF
0000000000000000000000000000000000000000;;			if n := nSrc + len(dst) - nDst; n < end {
0000000000000000000000000000000000000000;;				err = transform.ErrShortDst
0000000000000000000000000000000000000000;;				end = n
0000000000000000000000000000000000000000;;				eof = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			end, ok := rb.f.quickSpan(rb.src, nSrc, end, eof)
0000000000000000000000000000000000000000;;			n := copy(dst[nDst:], rb.src.bytes[nSrc:end])
0000000000000000000000000000000000000000;;			nSrc += n
0000000000000000000000000000000000000000;;			nDst += n
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				if n < rb.nsrc && !atEOF {
0000000000000000000000000000000000000000;;					err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nDst, nSrc, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
