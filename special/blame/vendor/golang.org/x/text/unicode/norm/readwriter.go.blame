0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package norm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type normWriter struct {
0000000000000000000000000000000000000000;;		rb  reorderBuffer
0000000000000000000000000000000000000000;;		w   io.Writer
0000000000000000000000000000000000000000;;		buf []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write implements the standard write interface.  If the last characters are
0000000000000000000000000000000000000000;;	// not at a normalization boundary, the bytes will be buffered for the next
0000000000000000000000000000000000000000;;	// write. The remaining bytes will be written on close.
0000000000000000000000000000000000000000;;	func (w *normWriter) Write(data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		// Process data in pieces to keep w.buf size bounded.
0000000000000000000000000000000000000000;;		const chunk = 4000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(data) > 0 {
0000000000000000000000000000000000000000;;			// Normalize into w.buf.
0000000000000000000000000000000000000000;;			m := len(data)
0000000000000000000000000000000000000000;;			if m > chunk {
0000000000000000000000000000000000000000;;				m = chunk
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.rb.src = inputBytes(data[:m])
0000000000000000000000000000000000000000;;			w.rb.nsrc = m
0000000000000000000000000000000000000000;;			w.buf = doAppend(&w.rb, w.buf, 0)
0000000000000000000000000000000000000000;;			data = data[m:]
0000000000000000000000000000000000000000;;			n += m
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write out complete prefix, save remainder.
0000000000000000000000000000000000000000;;			// Note that lastBoundary looks back at most 31 runes.
0000000000000000000000000000000000000000;;			i := lastBoundary(&w.rb.f, w.buf)
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				i = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				if _, err = w.w.Write(w.buf[:i]); err != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				bn := copy(w.buf, w.buf[i:])
0000000000000000000000000000000000000000;;				w.buf = w.buf[:bn]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close forces data that remains in the buffer to be written.
0000000000000000000000000000000000000000;;	func (w *normWriter) Close() error {
0000000000000000000000000000000000000000;;		if len(w.buf) > 0 {
0000000000000000000000000000000000000000;;			_, err := w.w.Write(w.buf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Writer returns a new writer that implements Write(b)
0000000000000000000000000000000000000000;;	// by writing f(b) to w.  The returned writer may use an
0000000000000000000000000000000000000000;;	// an internal buffer to maintain state across Write calls.
0000000000000000000000000000000000000000;;	// Calling its Close method writes any buffered data to w.
0000000000000000000000000000000000000000;;	func (f Form) Writer(w io.Writer) io.WriteCloser {
0000000000000000000000000000000000000000;;		wr := &normWriter{rb: reorderBuffer{}, w: w}
0000000000000000000000000000000000000000;;		wr.rb.init(f, nil)
0000000000000000000000000000000000000000;;		return wr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type normReader struct {
0000000000000000000000000000000000000000;;		rb           reorderBuffer
0000000000000000000000000000000000000000;;		r            io.Reader
0000000000000000000000000000000000000000;;		inbuf        []byte
0000000000000000000000000000000000000000;;		outbuf       []byte
0000000000000000000000000000000000000000;;		bufStart     int
0000000000000000000000000000000000000000;;		lastBoundary int
0000000000000000000000000000000000000000;;		err          error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read implements the standard read interface.
0000000000000000000000000000000000000000;;	func (r *normReader) Read(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if r.lastBoundary-r.bufStart > 0 {
0000000000000000000000000000000000000000;;				n := copy(p, r.outbuf[r.bufStart:r.lastBoundary])
0000000000000000000000000000000000000000;;				r.bufStart += n
0000000000000000000000000000000000000000;;				if r.lastBoundary-r.bufStart > 0 {
0000000000000000000000000000000000000000;;					return n, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return n, r.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.err != nil {
0000000000000000000000000000000000000000;;				return 0, r.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			outn := copy(r.outbuf, r.outbuf[r.lastBoundary:])
0000000000000000000000000000000000000000;;			r.outbuf = r.outbuf[0:outn]
0000000000000000000000000000000000000000;;			r.bufStart = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n, err := r.r.Read(r.inbuf)
0000000000000000000000000000000000000000;;			r.rb.src = inputBytes(r.inbuf[0:n])
0000000000000000000000000000000000000000;;			r.rb.nsrc, r.err = n, err
0000000000000000000000000000000000000000;;			if n > 0 {
0000000000000000000000000000000000000000;;				r.outbuf = doAppend(&r.rb, r.outbuf, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				r.lastBoundary = len(r.outbuf)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.lastBoundary = lastBoundary(&r.rb.f, r.outbuf)
0000000000000000000000000000000000000000;;				if r.lastBoundary == -1 {
0000000000000000000000000000000000000000;;					r.lastBoundary = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("should not reach here")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reader returns a new reader that implements Read
0000000000000000000000000000000000000000;;	// by reading data from r and returning f(data).
0000000000000000000000000000000000000000;;	func (f Form) Reader(r io.Reader) io.Reader {
0000000000000000000000000000000000000000;;		const chunk = 4000
0000000000000000000000000000000000000000;;		buf := make([]byte, chunk)
0000000000000000000000000000000000000000;;		rr := &normReader{rb: reorderBuffer{}, r: r, inbuf: buf}
0000000000000000000000000000000000000000;;		rr.rb.init(f, buf)
0000000000000000000000000000000000000000;;		return rr
0000000000000000000000000000000000000000;;	}
