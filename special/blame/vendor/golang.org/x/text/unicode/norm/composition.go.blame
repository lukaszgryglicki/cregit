0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package norm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		maxNonStarters = 30
0000000000000000000000000000000000000000;;		// The maximum number of characters needed for a buffer is
0000000000000000000000000000000000000000;;		// maxNonStarters + 1 for the starter + 1 for the GCJ
0000000000000000000000000000000000000000;;		maxBufferSize    = maxNonStarters + 2
0000000000000000000000000000000000000000;;		maxNFCExpansion  = 3  // NFC(0x1D160)
0000000000000000000000000000000000000000;;		maxNFKCExpansion = 18 // NFKC(0xFDFA)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxByteBufferSize = utf8.UTFMax * maxBufferSize // 128
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ssState is used for reporting the segment state after inserting a rune.
0000000000000000000000000000000000000000;;	// It is returned by streamSafe.next.
0000000000000000000000000000000000000000;;	type ssState int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Indicates a rune was successfully added to the segment.
0000000000000000000000000000000000000000;;		ssSuccess ssState = iota
0000000000000000000000000000000000000000;;		// Indicates a rune starts a new segment and should not be added.
0000000000000000000000000000000000000000;;		ssStarter
0000000000000000000000000000000000000000;;		// Indicates a rune caused a segment overflow and a CGJ should be inserted.
0000000000000000000000000000000000000000;;		ssOverflow
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamSafe implements the policy of when a CGJ should be inserted.
0000000000000000000000000000000000000000;;	type streamSafe uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mkStreamSafe is a shorthand for declaring a streamSafe var and calling
0000000000000000000000000000000000000000;;	// first on it.
0000000000000000000000000000000000000000;;	func mkStreamSafe(p Properties) streamSafe {
0000000000000000000000000000000000000000;;		return streamSafe(p.nTrailingNonStarters())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// first inserts the first rune of a segment.
0000000000000000000000000000000000000000;;	func (ss *streamSafe) first(p Properties) {
0000000000000000000000000000000000000000;;		if *ss != 0 {
0000000000000000000000000000000000000000;;			panic("!= 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*ss = streamSafe(p.nTrailingNonStarters())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insert returns a ssState value to indicate whether a rune represented by p
0000000000000000000000000000000000000000;;	// can be inserted.
0000000000000000000000000000000000000000;;	func (ss *streamSafe) next(p Properties) ssState {
0000000000000000000000000000000000000000;;		if *ss > maxNonStarters {
0000000000000000000000000000000000000000;;			panic("streamSafe was not reset")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := p.nLeadingNonStarters()
0000000000000000000000000000000000000000;;		if *ss += streamSafe(n); *ss > maxNonStarters {
0000000000000000000000000000000000000000;;			*ss = 0
0000000000000000000000000000000000000000;;			return ssOverflow
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The Stream-Safe Text Processing prescribes that the counting can stop
0000000000000000000000000000000000000000;;		// as soon as a starter is encountered. However, there are some starters,
0000000000000000000000000000000000000000;;		// like Jamo V and T, that can combine with other runes, leaving their
0000000000000000000000000000000000000000;;		// successive non-starters appended to the previous, possibly causing an
0000000000000000000000000000000000000000;;		// overflow. We will therefore consider any rune with a non-zero nLead to
0000000000000000000000000000000000000000;;		// be a non-starter. Note that it always hold that if nLead > 0 then
0000000000000000000000000000000000000000;;		// nLead == nTrail.
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			*ss = 0
0000000000000000000000000000000000000000;;			return ssStarter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ssSuccess
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// backwards is used for checking for overflow and segment starts
0000000000000000000000000000000000000000;;	// when traversing a string backwards. Users do not need to call first
0000000000000000000000000000000000000000;;	// for the first rune. The state of the streamSafe retains the count of
0000000000000000000000000000000000000000;;	// the non-starters loaded.
0000000000000000000000000000000000000000;;	func (ss *streamSafe) backwards(p Properties) ssState {
0000000000000000000000000000000000000000;;		if *ss > maxNonStarters {
0000000000000000000000000000000000000000;;			panic("streamSafe was not reset")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := *ss + streamSafe(p.nTrailingNonStarters())
0000000000000000000000000000000000000000;;		if c > maxNonStarters {
0000000000000000000000000000000000000000;;			return ssOverflow
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*ss = c
0000000000000000000000000000000000000000;;		if p.nLeadingNonStarters() == 0 {
0000000000000000000000000000000000000000;;			return ssStarter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ssSuccess
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss streamSafe) isMax() bool {
0000000000000000000000000000000000000000;;		return ss == maxNonStarters
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GraphemeJoiner is inserted after maxNonStarters non-starter runes.
0000000000000000000000000000000000000000;;	const GraphemeJoiner = "\u034F"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reorderBuffer is used to normalize a single segment.  Characters inserted with
0000000000000000000000000000000000000000;;	// insert are decomposed and reordered based on CCC. The compose method can
0000000000000000000000000000000000000000;;	// be used to recombine characters.  Note that the byte buffer does not hold
0000000000000000000000000000000000000000;;	// the UTF-8 characters in order.  Only the rune array is maintained in sorted
0000000000000000000000000000000000000000;;	// order. flush writes the resulting segment to a byte array.
0000000000000000000000000000000000000000;;	type reorderBuffer struct {
0000000000000000000000000000000000000000;;		rune  [maxBufferSize]Properties // Per character info.
0000000000000000000000000000000000000000;;		byte  [maxByteBufferSize]byte   // UTF-8 buffer. Referenced by runeInfo.pos.
0000000000000000000000000000000000000000;;		nbyte uint8                     // Number or bytes.
0000000000000000000000000000000000000000;;		ss    streamSafe                // For limiting length of non-starter sequence.
0000000000000000000000000000000000000000;;		nrune int                       // Number of runeInfos.
0000000000000000000000000000000000000000;;		f     formInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		src      input
0000000000000000000000000000000000000000;;		nsrc     int
0000000000000000000000000000000000000000;;		tmpBytes input
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out    []byte
0000000000000000000000000000000000000000;;		flushF func(*reorderBuffer) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) init(f Form, src []byte) {
0000000000000000000000000000000000000000;;		rb.f = *formTable[f]
0000000000000000000000000000000000000000;;		rb.src.setBytes(src)
0000000000000000000000000000000000000000;;		rb.nsrc = len(src)
0000000000000000000000000000000000000000;;		rb.ss = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) initString(f Form, src string) {
0000000000000000000000000000000000000000;;		rb.f = *formTable[f]
0000000000000000000000000000000000000000;;		rb.src.setString(src)
0000000000000000000000000000000000000000;;		rb.nsrc = len(src)
0000000000000000000000000000000000000000;;		rb.ss = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) setFlusher(out []byte, f func(*reorderBuffer) bool) {
0000000000000000000000000000000000000000;;		rb.out = out
0000000000000000000000000000000000000000;;		rb.flushF = f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reset discards all characters from the buffer.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) reset() {
0000000000000000000000000000000000000000;;		rb.nrune = 0
0000000000000000000000000000000000000000;;		rb.nbyte = 0
0000000000000000000000000000000000000000;;		rb.ss = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) doFlush() bool {
0000000000000000000000000000000000000000;;		if rb.f.composing {
0000000000000000000000000000000000000000;;			rb.compose()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res := rb.flushF(rb)
0000000000000000000000000000000000000000;;		rb.reset()
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendFlush appends the normalized segment to rb.out.
0000000000000000000000000000000000000000;;	func appendFlush(rb *reorderBuffer) bool {
0000000000000000000000000000000000000000;;		for i := 0; i < rb.nrune; i++ {
0000000000000000000000000000000000000000;;			start := rb.rune[i].pos
0000000000000000000000000000000000000000;;			end := start + rb.rune[i].size
0000000000000000000000000000000000000000;;			rb.out = append(rb.out, rb.byte[start:end]...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flush appends the normalized segment to out and resets rb.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) flush(out []byte) []byte {
0000000000000000000000000000000000000000;;		for i := 0; i < rb.nrune; i++ {
0000000000000000000000000000000000000000;;			start := rb.rune[i].pos
0000000000000000000000000000000000000000;;			end := start + rb.rune[i].size
0000000000000000000000000000000000000000;;			out = append(out, rb.byte[start:end]...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb.reset()
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flushCopy copies the normalized segment to buf and resets rb.
0000000000000000000000000000000000000000;;	// It returns the number of bytes written to buf.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) flushCopy(buf []byte) int {
0000000000000000000000000000000000000000;;		p := 0
0000000000000000000000000000000000000000;;		for i := 0; i < rb.nrune; i++ {
0000000000000000000000000000000000000000;;			runep := rb.rune[i]
0000000000000000000000000000000000000000;;			p += copy(buf[p:], rb.byte[runep.pos:runep.pos+runep.size])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb.reset()
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertOrdered inserts a rune in the buffer, ordered by Canonical Combining Class.
0000000000000000000000000000000000000000;;	// It returns false if the buffer is not large enough to hold the rune.
0000000000000000000000000000000000000000;;	// It is used internally by insert and insertString only.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) insertOrdered(info Properties) {
0000000000000000000000000000000000000000;;		n := rb.nrune
0000000000000000000000000000000000000000;;		b := rb.rune[:]
0000000000000000000000000000000000000000;;		cc := info.ccc
0000000000000000000000000000000000000000;;		if cc > 0 {
0000000000000000000000000000000000000000;;			// Find insertion position + move elements to make room.
0000000000000000000000000000000000000000;;			for ; n > 0; n-- {
0000000000000000000000000000000000000000;;				if b[n-1].ccc <= cc {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b[n] = b[n-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb.nrune += 1
0000000000000000000000000000000000000000;;		pos := uint8(rb.nbyte)
0000000000000000000000000000000000000000;;		rb.nbyte += utf8.UTFMax
0000000000000000000000000000000000000000;;		info.pos = pos
0000000000000000000000000000000000000000;;		b[n] = info
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertErr is an error code returned by insert. Using this type instead
0000000000000000000000000000000000000000;;	// of error improves performance up to 20% for many of the benchmarks.
0000000000000000000000000000000000000000;;	type insertErr int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		iSuccess insertErr = -iota
0000000000000000000000000000000000000000;;		iShortDst
0000000000000000000000000000000000000000;;		iShortSrc
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertFlush inserts the given rune in the buffer ordered by CCC.
0000000000000000000000000000000000000000;;	// If a decomposition with multiple segments are encountered, they leading
0000000000000000000000000000000000000000;;	// ones are flushed.
0000000000000000000000000000000000000000;;	// It returns a non-zero error code if the rune was not inserted.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) insertFlush(src input, i int, info Properties) insertErr {
0000000000000000000000000000000000000000;;		if rune := src.hangul(i); rune != 0 {
0000000000000000000000000000000000000000;;			rb.decomposeHangul(rune)
0000000000000000000000000000000000000000;;			return iSuccess
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.hasDecomposition() {
0000000000000000000000000000000000000000;;			return rb.insertDecomposed(info.Decomposition())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb.insertSingle(src, i, info)
0000000000000000000000000000000000000000;;		return iSuccess
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertUnsafe inserts the given rune in the buffer ordered by CCC.
0000000000000000000000000000000000000000;;	// It is assumed there is sufficient space to hold the runes. It is the
0000000000000000000000000000000000000000;;	// responsibility of the caller to ensure this. This can be done by checking
0000000000000000000000000000000000000000;;	// the state returned by the streamSafe type.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) insertUnsafe(src input, i int, info Properties) {
0000000000000000000000000000000000000000;;		if rune := src.hangul(i); rune != 0 {
0000000000000000000000000000000000000000;;			rb.decomposeHangul(rune)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.hasDecomposition() {
0000000000000000000000000000000000000000;;			// TODO: inline.
0000000000000000000000000000000000000000;;			rb.insertDecomposed(info.Decomposition())
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rb.insertSingle(src, i, info)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertDecomposed inserts an entry in to the reorderBuffer for each rune
0000000000000000000000000000000000000000;;	// in dcomp. dcomp must be a sequence of decomposed UTF-8-encoded runes.
0000000000000000000000000000000000000000;;	// It flushes the buffer on each new segment start.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) insertDecomposed(dcomp []byte) insertErr {
0000000000000000000000000000000000000000;;		rb.tmpBytes.setBytes(dcomp)
0000000000000000000000000000000000000000;;		for i := 0; i < len(dcomp); {
0000000000000000000000000000000000000000;;			info := rb.f.info(rb.tmpBytes, i)
0000000000000000000000000000000000000000;;			if info.BoundaryBefore() && rb.nrune > 0 && !rb.doFlush() {
0000000000000000000000000000000000000000;;				return iShortDst
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i += copy(rb.byte[rb.nbyte:], dcomp[i:i+int(info.size)])
0000000000000000000000000000000000000000;;			rb.insertOrdered(info)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return iSuccess
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertSingle inserts an entry in the reorderBuffer for the rune at
0000000000000000000000000000000000000000;;	// position i. info is the runeInfo for the rune at position i.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) insertSingle(src input, i int, info Properties) {
0000000000000000000000000000000000000000;;		src.copySlice(rb.byte[rb.nbyte:], i, i+int(info.size))
0000000000000000000000000000000000000000;;		rb.insertOrdered(info)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertCGJ inserts a Combining Grapheme Joiner (0x034f) into rb.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) insertCGJ() {
0000000000000000000000000000000000000000;;		rb.insertSingle(input{str: GraphemeJoiner}, 0, Properties{size: uint8(len(GraphemeJoiner))})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendRune inserts a rune at the end of the buffer. It is used for Hangul.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) appendRune(r rune) {
0000000000000000000000000000000000000000;;		bn := rb.nbyte
0000000000000000000000000000000000000000;;		sz := utf8.EncodeRune(rb.byte[bn:], rune(r))
0000000000000000000000000000000000000000;;		rb.nbyte += utf8.UTFMax
0000000000000000000000000000000000000000;;		rb.rune[rb.nrune] = Properties{pos: bn, size: uint8(sz)}
0000000000000000000000000000000000000000;;		rb.nrune++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignRune sets a rune at position pos. It is used for Hangul and recomposition.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) assignRune(pos int, r rune) {
0000000000000000000000000000000000000000;;		bn := rb.rune[pos].pos
0000000000000000000000000000000000000000;;		sz := utf8.EncodeRune(rb.byte[bn:], rune(r))
0000000000000000000000000000000000000000;;		rb.rune[pos] = Properties{pos: bn, size: uint8(sz)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runeAt returns the rune at position n. It is used for Hangul and recomposition.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) runeAt(n int) rune {
0000000000000000000000000000000000000000;;		inf := rb.rune[n]
0000000000000000000000000000000000000000;;		r, _ := utf8.DecodeRune(rb.byte[inf.pos : inf.pos+inf.size])
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bytesAt returns the UTF-8 encoding of the rune at position n.
0000000000000000000000000000000000000000;;	// It is used for Hangul and recomposition.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) bytesAt(n int) []byte {
0000000000000000000000000000000000000000;;		inf := rb.rune[n]
0000000000000000000000000000000000000000;;		return rb.byte[inf.pos : int(inf.pos)+int(inf.size)]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For Hangul we combine algorithmically, instead of using tables.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		hangulBase  = 0xAC00 // UTF-8(hangulBase) -> EA B0 80
0000000000000000000000000000000000000000;;		hangulBase0 = 0xEA
0000000000000000000000000000000000000000;;		hangulBase1 = 0xB0
0000000000000000000000000000000000000000;;		hangulBase2 = 0x80
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hangulEnd  = hangulBase + jamoLVTCount // UTF-8(0xD7A4) -> ED 9E A4
0000000000000000000000000000000000000000;;		hangulEnd0 = 0xED
0000000000000000000000000000000000000000;;		hangulEnd1 = 0x9E
0000000000000000000000000000000000000000;;		hangulEnd2 = 0xA4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jamoLBase  = 0x1100 // UTF-8(jamoLBase) -> E1 84 00
0000000000000000000000000000000000000000;;		jamoLBase0 = 0xE1
0000000000000000000000000000000000000000;;		jamoLBase1 = 0x84
0000000000000000000000000000000000000000;;		jamoLEnd   = 0x1113
0000000000000000000000000000000000000000;;		jamoVBase  = 0x1161
0000000000000000000000000000000000000000;;		jamoVEnd   = 0x1176
0000000000000000000000000000000000000000;;		jamoTBase  = 0x11A7
0000000000000000000000000000000000000000;;		jamoTEnd   = 0x11C3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jamoTCount   = 28
0000000000000000000000000000000000000000;;		jamoVCount   = 21
0000000000000000000000000000000000000000;;		jamoVTCount  = 21 * 28
0000000000000000000000000000000000000000;;		jamoLVTCount = 19 * 21 * 28
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const hangulUTF8Size = 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isHangul(b []byte) bool {
0000000000000000000000000000000000000000;;		if len(b) < hangulUTF8Size {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b0 := b[0]
0000000000000000000000000000000000000000;;		if b0 < hangulBase0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b1 := b[1]
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case b0 == hangulBase0:
0000000000000000000000000000000000000000;;			return b1 >= hangulBase1
0000000000000000000000000000000000000000;;		case b0 < hangulEnd0:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case b0 > hangulEnd0:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case b1 < hangulEnd1:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b1 == hangulEnd1 && b[2] < hangulEnd2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isHangulString(b string) bool {
0000000000000000000000000000000000000000;;		if len(b) < hangulUTF8Size {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b0 := b[0]
0000000000000000000000000000000000000000;;		if b0 < hangulBase0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b1 := b[1]
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case b0 == hangulBase0:
0000000000000000000000000000000000000000;;			return b1 >= hangulBase1
0000000000000000000000000000000000000000;;		case b0 < hangulEnd0:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case b0 > hangulEnd0:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case b1 < hangulEnd1:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b1 == hangulEnd1 && b[2] < hangulEnd2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Caller must ensure len(b) >= 2.
0000000000000000000000000000000000000000;;	func isJamoVT(b []byte) bool {
0000000000000000000000000000000000000000;;		// True if (rune & 0xff00) == jamoLBase
0000000000000000000000000000000000000000;;		return b[0] == jamoLBase0 && (b[1]&0xFC) == jamoLBase1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isHangulWithoutJamoT(b []byte) bool {
0000000000000000000000000000000000000000;;		c, _ := utf8.DecodeRune(b)
0000000000000000000000000000000000000000;;		c -= hangulBase
0000000000000000000000000000000000000000;;		return c < jamoLVTCount && c%jamoTCount == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decomposeHangul writes the decomposed Hangul to buf and returns the number
0000000000000000000000000000000000000000;;	// of bytes written.  len(buf) should be at least 9.
0000000000000000000000000000000000000000;;	func decomposeHangul(buf []byte, r rune) int {
0000000000000000000000000000000000000000;;		const JamoUTF8Len = 3
0000000000000000000000000000000000000000;;		r -= hangulBase
0000000000000000000000000000000000000000;;		x := r % jamoTCount
0000000000000000000000000000000000000000;;		r /= jamoTCount
0000000000000000000000000000000000000000;;		utf8.EncodeRune(buf, jamoLBase+r/jamoVCount)
0000000000000000000000000000000000000000;;		utf8.EncodeRune(buf[JamoUTF8Len:], jamoVBase+r%jamoVCount)
0000000000000000000000000000000000000000;;		if x != 0 {
0000000000000000000000000000000000000000;;			utf8.EncodeRune(buf[2*JamoUTF8Len:], jamoTBase+x)
0000000000000000000000000000000000000000;;			return 3 * JamoUTF8Len
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 2 * JamoUTF8Len
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decomposeHangul algorithmically decomposes a Hangul rune into
0000000000000000000000000000000000000000;;	// its Jamo components.
0000000000000000000000000000000000000000;;	// See http://unicode.org/reports/tr15/#Hangul for details on decomposing Hangul.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) decomposeHangul(r rune) {
0000000000000000000000000000000000000000;;		r -= hangulBase
0000000000000000000000000000000000000000;;		x := r % jamoTCount
0000000000000000000000000000000000000000;;		r /= jamoTCount
0000000000000000000000000000000000000000;;		rb.appendRune(jamoLBase + r/jamoVCount)
0000000000000000000000000000000000000000;;		rb.appendRune(jamoVBase + r%jamoVCount)
0000000000000000000000000000000000000000;;		if x != 0 {
0000000000000000000000000000000000000000;;			rb.appendRune(jamoTBase + x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// combineHangul algorithmically combines Jamo character components into Hangul.
0000000000000000000000000000000000000000;;	// See http://unicode.org/reports/tr15/#Hangul for details on combining Hangul.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) combineHangul(s, i, k int) {
0000000000000000000000000000000000000000;;		b := rb.rune[:]
0000000000000000000000000000000000000000;;		bn := rb.nrune
0000000000000000000000000000000000000000;;		for ; i < bn; i++ {
0000000000000000000000000000000000000000;;			cccB := b[k-1].ccc
0000000000000000000000000000000000000000;;			cccC := b[i].ccc
0000000000000000000000000000000000000000;;			if cccB == 0 {
0000000000000000000000000000000000000000;;				s = k - 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s != k-1 && cccB >= cccC {
0000000000000000000000000000000000000000;;				// b[i] is blocked by greater-equal cccX below it
0000000000000000000000000000000000000000;;				b[k] = b[i]
0000000000000000000000000000000000000000;;				k++
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				l := rb.runeAt(s) // also used to compare to hangulBase
0000000000000000000000000000000000000000;;				v := rb.runeAt(i) // also used to compare to jamoT
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case jamoLBase <= l && l < jamoLEnd &&
0000000000000000000000000000000000000000;;					jamoVBase <= v && v < jamoVEnd:
0000000000000000000000000000000000000000;;					// 11xx plus 116x to LV
0000000000000000000000000000000000000000;;					rb.assignRune(s, hangulBase+
0000000000000000000000000000000000000000;;						(l-jamoLBase)*jamoVTCount+(v-jamoVBase)*jamoTCount)
0000000000000000000000000000000000000000;;				case hangulBase <= l && l < hangulEnd &&
0000000000000000000000000000000000000000;;					jamoTBase < v && v < jamoTEnd &&
0000000000000000000000000000000000000000;;					((l-hangulBase)%jamoTCount) == 0:
0000000000000000000000000000000000000000;;					// ACxx plus 11Ax to LVT
0000000000000000000000000000000000000000;;					rb.assignRune(s, l+v-jamoTBase)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					b[k] = b[i]
0000000000000000000000000000000000000000;;					k++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb.nrune = k
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// compose recombines the runes in the buffer.
0000000000000000000000000000000000000000;;	// It should only be used to recompose a single segment, as it will not
0000000000000000000000000000000000000000;;	// handle alternations between Hangul and non-Hangul characters correctly.
0000000000000000000000000000000000000000;;	func (rb *reorderBuffer) compose() {
0000000000000000000000000000000000000000;;		// UAX #15, section X5 , including Corrigendum #5
0000000000000000000000000000000000000000;;		// "In any character sequence beginning with starter S, a character C is
0000000000000000000000000000000000000000;;		//  blocked from S if and only if there is some character B between S
0000000000000000000000000000000000000000;;		//  and C, and either B is a starter or it has the same or higher
0000000000000000000000000000000000000000;;		//  combining class as C."
0000000000000000000000000000000000000000;;		bn := rb.nrune
0000000000000000000000000000000000000000;;		if bn == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		k := 1
0000000000000000000000000000000000000000;;		b := rb.rune[:]
0000000000000000000000000000000000000000;;		for s, i := 0, 1; i < bn; i++ {
0000000000000000000000000000000000000000;;			if isJamoVT(rb.bytesAt(i)) {
0000000000000000000000000000000000000000;;				// Redo from start in Hangul mode. Necessary to support
0000000000000000000000000000000000000000;;				// U+320E..U+321E in NFKC mode.
0000000000000000000000000000000000000000;;				rb.combineHangul(s, i, k)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ii := b[i]
0000000000000000000000000000000000000000;;			// We can only use combineForward as a filter if we later
0000000000000000000000000000000000000000;;			// get the info for the combined character. This is more
0000000000000000000000000000000000000000;;			// expensive than using the filter. Using combinesBackward()
0000000000000000000000000000000000000000;;			// is safe.
0000000000000000000000000000000000000000;;			if ii.combinesBackward() {
0000000000000000000000000000000000000000;;				cccB := b[k-1].ccc
0000000000000000000000000000000000000000;;				cccC := ii.ccc
0000000000000000000000000000000000000000;;				blocked := false // b[i] blocked by starter or greater or equal CCC?
0000000000000000000000000000000000000000;;				if cccB == 0 {
0000000000000000000000000000000000000000;;					s = k - 1
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					blocked = s != k-1 && cccB >= cccC
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !blocked {
0000000000000000000000000000000000000000;;					combined := combine(rb.runeAt(s), rb.runeAt(i))
0000000000000000000000000000000000000000;;					if combined != 0 {
0000000000000000000000000000000000000000;;						rb.assignRune(s, combined)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b[k] = b[i]
0000000000000000000000000000000000000000;;			k++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb.nrune = k
0000000000000000000000000000000000000000;;	}
