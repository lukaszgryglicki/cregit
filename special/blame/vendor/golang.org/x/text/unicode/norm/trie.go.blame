0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package norm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type valueRange struct {
0000000000000000000000000000000000000000;;		value  uint16 // header: value:stride
0000000000000000000000000000000000000000;;		lo, hi byte   // header: lo:n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sparseBlocks struct {
0000000000000000000000000000000000000000;;		values []valueRange
0000000000000000000000000000000000000000;;		offset []uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nfcSparse = sparseBlocks{
0000000000000000000000000000000000000000;;		values: nfcSparseValues[:],
0000000000000000000000000000000000000000;;		offset: nfcSparseOffset[:],
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nfkcSparse = sparseBlocks{
0000000000000000000000000000000000000000;;		values: nfkcSparseValues[:],
0000000000000000000000000000000000000000;;		offset: nfkcSparseOffset[:],
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		nfcData  = newNfcTrie(0)
0000000000000000000000000000000000000000;;		nfkcData = newNfkcTrie(0)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lookupValue determines the type of block n and looks up the value for b.
0000000000000000000000000000000000000000;;	// For n < t.cutoff, the block is a simple lookup table. Otherwise, the block
0000000000000000000000000000000000000000;;	// is a list of ranges with an accompanying value. Given a matching range r,
0000000000000000000000000000000000000000;;	// the value for b is by r.value + (b - r.lo) * stride.
0000000000000000000000000000000000000000;;	func (t *sparseBlocks) lookup(n uint32, b byte) uint16 {
0000000000000000000000000000000000000000;;		offset := t.offset[n]
0000000000000000000000000000000000000000;;		header := t.values[offset]
0000000000000000000000000000000000000000;;		lo := offset + 1
0000000000000000000000000000000000000000;;		hi := lo + uint16(header.lo)
0000000000000000000000000000000000000000;;		for lo < hi {
0000000000000000000000000000000000000000;;			m := lo + (hi-lo)/2
0000000000000000000000000000000000000000;;			r := t.values[m]
0000000000000000000000000000000000000000;;			if r.lo <= b && b <= r.hi {
0000000000000000000000000000000000000000;;				return r.value + uint16(b-r.lo)*header.value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b < r.lo {
0000000000000000000000000000000000000000;;				hi = m
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				lo = m + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
