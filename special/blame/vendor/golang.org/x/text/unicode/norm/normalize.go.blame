0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	//go:generate go run maketables.go triegen.go
0000000000000000000000000000000000000000;;	//go:generate go run maketables.go triegen.go -test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package norm contains types and functions for normalizing Unicode strings.
0000000000000000000000000000000000000000;;	package norm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Form denotes a canonical representation of Unicode code points.
0000000000000000000000000000000000000000;;	// The Unicode-defined normalization and equivalence forms are:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   NFC   Unicode Normalization Form C
0000000000000000000000000000000000000000;;	//   NFD   Unicode Normalization Form D
0000000000000000000000000000000000000000;;	//   NFKC  Unicode Normalization Form KC
0000000000000000000000000000000000000000;;	//   NFKD  Unicode Normalization Form KD
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For a Form f, this documentation uses the notation f(x) to mean
0000000000000000000000000000000000000000;;	// the bytes or string x converted to the given form.
0000000000000000000000000000000000000000;;	// A position n in x is called a boundary if conversion to the form can
0000000000000000000000000000000000000000;;	// proceed independently on both sides:
0000000000000000000000000000000000000000;;	//   f(x) == append(f(x[0:n]), f(x[n:])...)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// References: http://unicode.org/reports/tr15/ and
0000000000000000000000000000000000000000;;	// http://unicode.org/notes/tn5/.
0000000000000000000000000000000000000000;;	type Form int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NFC Form = iota
0000000000000000000000000000000000000000;;		NFD
0000000000000000000000000000000000000000;;		NFKC
0000000000000000000000000000000000000000;;		NFKD
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns f(b). May return b if f(b) = b.
0000000000000000000000000000000000000000;;	func (f Form) Bytes(b []byte) []byte {
0000000000000000000000000000000000000000;;		src := inputBytes(b)
0000000000000000000000000000000000000000;;		ft := formTable[f]
0000000000000000000000000000000000000000;;		n, ok := ft.quickSpan(src, 0, len(b), true)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := make([]byte, n, len(b))
0000000000000000000000000000000000000000;;		copy(out, b[0:n])
0000000000000000000000000000000000000000;;		rb := reorderBuffer{f: *ft, src: src, nsrc: len(b), out: out, flushF: appendFlush}
0000000000000000000000000000000000000000;;		return doAppendInner(&rb, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns f(s).
0000000000000000000000000000000000000000;;	func (f Form) String(s string) string {
0000000000000000000000000000000000000000;;		src := inputString(s)
0000000000000000000000000000000000000000;;		ft := formTable[f]
0000000000000000000000000000000000000000;;		n, ok := ft.quickSpan(src, 0, len(s), true)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := make([]byte, n, len(s))
0000000000000000000000000000000000000000;;		copy(out, s[0:n])
0000000000000000000000000000000000000000;;		rb := reorderBuffer{f: *ft, src: src, nsrc: len(s), out: out, flushF: appendFlush}
0000000000000000000000000000000000000000;;		return string(doAppendInner(&rb, n))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNormal returns true if b == f(b).
0000000000000000000000000000000000000000;;	func (f Form) IsNormal(b []byte) bool {
0000000000000000000000000000000000000000;;		src := inputBytes(b)
0000000000000000000000000000000000000000;;		ft := formTable[f]
0000000000000000000000000000000000000000;;		bp, ok := ft.quickSpan(src, 0, len(b), true)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb := reorderBuffer{f: *ft, src: src, nsrc: len(b)}
0000000000000000000000000000000000000000;;		rb.setFlusher(nil, cmpNormalBytes)
0000000000000000000000000000000000000000;;		for bp < len(b) {
0000000000000000000000000000000000000000;;			rb.out = b[bp:]
0000000000000000000000000000000000000000;;			if bp = decomposeSegment(&rb, bp, true); bp < 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bp, _ = rb.f.quickSpan(rb.src, bp, len(b), true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cmpNormalBytes(rb *reorderBuffer) bool {
0000000000000000000000000000000000000000;;		b := rb.out
0000000000000000000000000000000000000000;;		for i := 0; i < rb.nrune; i++ {
0000000000000000000000000000000000000000;;			info := rb.rune[i]
0000000000000000000000000000000000000000;;			if int(info.size) > len(b) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p := info.pos
0000000000000000000000000000000000000000;;			pe := p + info.size
0000000000000000000000000000000000000000;;			for ; p < pe; p++ {
0000000000000000000000000000000000000000;;				if b[0] != rb.byte[p] {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b = b[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNormalString returns true if s == f(s).
0000000000000000000000000000000000000000;;	func (f Form) IsNormalString(s string) bool {
0000000000000000000000000000000000000000;;		src := inputString(s)
0000000000000000000000000000000000000000;;		ft := formTable[f]
0000000000000000000000000000000000000000;;		bp, ok := ft.quickSpan(src, 0, len(s), true)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb := reorderBuffer{f: *ft, src: src, nsrc: len(s)}
0000000000000000000000000000000000000000;;		rb.setFlusher(nil, func(rb *reorderBuffer) bool {
0000000000000000000000000000000000000000;;			for i := 0; i < rb.nrune; i++ {
0000000000000000000000000000000000000000;;				info := rb.rune[i]
0000000000000000000000000000000000000000;;				if bp+int(info.size) > len(s) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p := info.pos
0000000000000000000000000000000000000000;;				pe := p + info.size
0000000000000000000000000000000000000000;;				for ; p < pe; p++ {
0000000000000000000000000000000000000000;;					if s[bp] != rb.byte[p] {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					bp++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		for bp < len(s) {
0000000000000000000000000000000000000000;;			if bp = decomposeSegment(&rb, bp, true); bp < 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bp, _ = rb.f.quickSpan(rb.src, bp, len(s), true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// patchTail fixes a case where a rune may be incorrectly normalized
0000000000000000000000000000000000000000;;	// if it is followed by illegal continuation bytes. It returns the
0000000000000000000000000000000000000000;;	// patched buffer and whether the decomposition is still in progress.
0000000000000000000000000000000000000000;;	func patchTail(rb *reorderBuffer) bool {
0000000000000000000000000000000000000000;;		info, p := lastRuneStart(&rb.f, rb.out)
0000000000000000000000000000000000000000;;		if p == -1 || info.size == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		end := p + int(info.size)
0000000000000000000000000000000000000000;;		extra := len(rb.out) - end
0000000000000000000000000000000000000000;;		if extra > 0 {
0000000000000000000000000000000000000000;;			// Potentially allocating memory. However, this only
0000000000000000000000000000000000000000;;			// happens with ill-formed UTF-8.
0000000000000000000000000000000000000000;;			x := make([]byte, 0)
0000000000000000000000000000000000000000;;			x = append(x, rb.out[len(rb.out)-extra:]...)
0000000000000000000000000000000000000000;;			rb.out = rb.out[:end]
0000000000000000000000000000000000000000;;			decomposeToLastBoundary(rb)
0000000000000000000000000000000000000000;;			rb.doFlush()
0000000000000000000000000000000000000000;;			rb.out = append(rb.out, x...)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := rb.out[p:]
0000000000000000000000000000000000000000;;		rb.out = rb.out[:p]
0000000000000000000000000000000000000000;;		decomposeToLastBoundary(rb)
0000000000000000000000000000000000000000;;		if s := rb.ss.next(info); s == ssStarter {
0000000000000000000000000000000000000000;;			rb.doFlush()
0000000000000000000000000000000000000000;;			rb.ss.first(info)
0000000000000000000000000000000000000000;;		} else if s == ssOverflow {
0000000000000000000000000000000000000000;;			rb.doFlush()
0000000000000000000000000000000000000000;;			rb.insertCGJ()
0000000000000000000000000000000000000000;;			rb.ss = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb.insertUnsafe(inputBytes(buf), 0, info)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendQuick(rb *reorderBuffer, i int) int {
0000000000000000000000000000000000000000;;		if rb.nsrc == i {
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		end, _ := rb.f.quickSpan(rb.src, i, rb.nsrc, true)
0000000000000000000000000000000000000000;;		rb.out = rb.src.appendSlice(rb.out, i, end)
0000000000000000000000000000000000000000;;		return end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Append returns f(append(out, b...)).
0000000000000000000000000000000000000000;;	// The buffer out must be nil, empty, or equal to f(out).
0000000000000000000000000000000000000000;;	func (f Form) Append(out []byte, src ...byte) []byte {
0000000000000000000000000000000000000000;;		return f.doAppend(out, inputBytes(src), len(src))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Form) doAppend(out []byte, src input, n int) []byte {
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ft := formTable[f]
0000000000000000000000000000000000000000;;		// Attempt to do a quickSpan first so we can avoid initializing the reorderBuffer.
0000000000000000000000000000000000000000;;		if len(out) == 0 {
0000000000000000000000000000000000000000;;			p, _ := ft.quickSpan(src, 0, n, true)
0000000000000000000000000000000000000000;;			out = src.appendSlice(out, 0, p)
0000000000000000000000000000000000000000;;			if p == n {
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rb := reorderBuffer{f: *ft, src: src, nsrc: n, out: out, flushF: appendFlush}
0000000000000000000000000000000000000000;;			return doAppendInner(&rb, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb := reorderBuffer{f: *ft, src: src, nsrc: n}
0000000000000000000000000000000000000000;;		return doAppend(&rb, out, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doAppend(rb *reorderBuffer, out []byte, p int) []byte {
0000000000000000000000000000000000000000;;		rb.setFlusher(out, appendFlush)
0000000000000000000000000000000000000000;;		src, n := rb.src, rb.nsrc
0000000000000000000000000000000000000000;;		doMerge := len(out) > 0
0000000000000000000000000000000000000000;;		if q := src.skipContinuationBytes(p); q > p {
0000000000000000000000000000000000000000;;			// Move leading non-starters to destination.
0000000000000000000000000000000000000000;;			rb.out = src.appendSlice(rb.out, p, q)
0000000000000000000000000000000000000000;;			p = q
0000000000000000000000000000000000000000;;			doMerge = patchTail(rb)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fd := &rb.f
0000000000000000000000000000000000000000;;		if doMerge {
0000000000000000000000000000000000000000;;			var info Properties
0000000000000000000000000000000000000000;;			if p < n {
0000000000000000000000000000000000000000;;				info = fd.info(src, p)
0000000000000000000000000000000000000000;;				if !info.BoundaryBefore() || info.nLeadingNonStarters() > 0 {
0000000000000000000000000000000000000000;;					if p == 0 {
0000000000000000000000000000000000000000;;						decomposeToLastBoundary(rb)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					p = decomposeSegment(rb, p, true)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if info.size == 0 {
0000000000000000000000000000000000000000;;				rb.doFlush()
0000000000000000000000000000000000000000;;				// Append incomplete UTF-8 encoding.
0000000000000000000000000000000000000000;;				return src.appendSlice(rb.out, p, n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rb.nrune > 0 {
0000000000000000000000000000000000000000;;				return doAppendInner(rb, p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p = appendQuick(rb, p)
0000000000000000000000000000000000000000;;		return doAppendInner(rb, p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doAppendInner(rb *reorderBuffer, p int) []byte {
0000000000000000000000000000000000000000;;		for n := rb.nsrc; p < n; {
0000000000000000000000000000000000000000;;			p = decomposeSegment(rb, p, true)
0000000000000000000000000000000000000000;;			p = appendQuick(rb, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rb.out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppendString returns f(append(out, []byte(s))).
0000000000000000000000000000000000000000;;	// The buffer out must be nil, empty, or equal to f(out).
0000000000000000000000000000000000000000;;	func (f Form) AppendString(out []byte, src string) []byte {
0000000000000000000000000000000000000000;;		return f.doAppend(out, inputString(src), len(src))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QuickSpan returns a boundary n such that b[0:n] == f(b[0:n]).
0000000000000000000000000000000000000000;;	// It is not guaranteed to return the largest such n.
0000000000000000000000000000000000000000;;	func (f Form) QuickSpan(b []byte) int {
0000000000000000000000000000000000000000;;		n, _ := formTable[f].quickSpan(inputBytes(b), 0, len(b), true)
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// quickSpan returns a boundary n such that src[0:n] == f(src[0:n]) and
0000000000000000000000000000000000000000;;	// whether any non-normalized parts were found. If atEOF is false, n will
0000000000000000000000000000000000000000;;	// not point past the last segment if this segment might be become
0000000000000000000000000000000000000000;;	// non-normalized by appending other runes.
0000000000000000000000000000000000000000;;	func (f *formInfo) quickSpan(src input, i, end int, atEOF bool) (n int, ok bool) {
0000000000000000000000000000000000000000;;		var lastCC uint8
0000000000000000000000000000000000000000;;		ss := streamSafe(0)
0000000000000000000000000000000000000000;;		lastSegStart := i
0000000000000000000000000000000000000000;;		for n = end; i < n; {
0000000000000000000000000000000000000000;;			if j := src.skipASCII(i, n); i != j {
0000000000000000000000000000000000000000;;				i = j
0000000000000000000000000000000000000000;;				lastSegStart = i - 1
0000000000000000000000000000000000000000;;				lastCC = 0
0000000000000000000000000000000000000000;;				ss = 0
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info := f.info(src, i)
0000000000000000000000000000000000000000;;			if info.size == 0 {
0000000000000000000000000000000000000000;;				if atEOF {
0000000000000000000000000000000000000000;;					// include incomplete runes
0000000000000000000000000000000000000000;;					return n, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return lastSegStart, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// This block needs to be before the next, because it is possible to
0000000000000000000000000000000000000000;;			// have an overflow for runes that are starters (e.g. with U+FF9E).
0000000000000000000000000000000000000000;;			switch ss.next(info) {
0000000000000000000000000000000000000000;;			case ssStarter:
0000000000000000000000000000000000000000;;				ss.first(info)
0000000000000000000000000000000000000000;;				lastSegStart = i
0000000000000000000000000000000000000000;;			case ssOverflow:
0000000000000000000000000000000000000000;;				return lastSegStart, false
0000000000000000000000000000000000000000;;			case ssSuccess:
0000000000000000000000000000000000000000;;				if lastCC > info.ccc {
0000000000000000000000000000000000000000;;					return lastSegStart, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f.composing {
0000000000000000000000000000000000000000;;				if !info.isYesC() {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !info.isYesD() {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastCC = info.ccc
0000000000000000000000000000000000000000;;			i += int(info.size)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i == n {
0000000000000000000000000000000000000000;;			if !atEOF {
0000000000000000000000000000000000000000;;				n = lastSegStart
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return n, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lastSegStart, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QuickSpanString returns a boundary n such that b[0:n] == f(s[0:n]).
0000000000000000000000000000000000000000;;	// It is not guaranteed to return the largest such n.
0000000000000000000000000000000000000000;;	func (f Form) QuickSpanString(s string) int {
0000000000000000000000000000000000000000;;		n, _ := formTable[f].quickSpan(inputString(s), 0, len(s), true)
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FirstBoundary returns the position i of the first boundary in b
0000000000000000000000000000000000000000;;	// or -1 if b contains no boundary.
0000000000000000000000000000000000000000;;	func (f Form) FirstBoundary(b []byte) int {
0000000000000000000000000000000000000000;;		return f.firstBoundary(inputBytes(b), len(b))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Form) firstBoundary(src input, nsrc int) int {
0000000000000000000000000000000000000000;;		i := src.skipContinuationBytes(0)
0000000000000000000000000000000000000000;;		if i >= nsrc {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fd := formTable[f]
0000000000000000000000000000000000000000;;		ss := streamSafe(0)
0000000000000000000000000000000000000000;;		// We should call ss.first here, but we can't as the first rune is
0000000000000000000000000000000000000000;;		// skipped already. This means FirstBoundary can't really determine
0000000000000000000000000000000000000000;;		// CGJ insertion points correctly. Luckily it doesn't have to.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			info := fd.info(src, i)
0000000000000000000000000000000000000000;;			if info.size == 0 {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s := ss.next(info); s != ssSuccess {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i += int(info.size)
0000000000000000000000000000000000000000;;			if i >= nsrc {
0000000000000000000000000000000000000000;;				if !info.BoundaryAfter() && !ss.isMax() {
0000000000000000000000000000000000000000;;					return -1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nsrc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FirstBoundaryInString returns the position i of the first boundary in s
0000000000000000000000000000000000000000;;	// or -1 if s contains no boundary.
0000000000000000000000000000000000000000;;	func (f Form) FirstBoundaryInString(s string) int {
0000000000000000000000000000000000000000;;		return f.firstBoundary(inputString(s), len(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextBoundary reports the index of the boundary between the first and next
0000000000000000000000000000000000000000;;	// segment in b or -1 if atEOF is false and there are not enough bytes to
0000000000000000000000000000000000000000;;	// determine this boundary.
0000000000000000000000000000000000000000;;	func (f Form) NextBoundary(b []byte, atEOF bool) int {
0000000000000000000000000000000000000000;;		return f.nextBoundary(inputBytes(b), len(b), atEOF)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextBoundaryInString reports the index of the boundary between the first and
0000000000000000000000000000000000000000;;	// next segment in b or -1 if atEOF is false and there are not enough bytes to
0000000000000000000000000000000000000000;;	// determine this boundary.
0000000000000000000000000000000000000000;;	func (f Form) NextBoundaryInString(s string, atEOF bool) int {
0000000000000000000000000000000000000000;;		return f.nextBoundary(inputString(s), len(s), atEOF)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Form) nextBoundary(src input, nsrc int, atEOF bool) int {
0000000000000000000000000000000000000000;;		if nsrc == 0 {
0000000000000000000000000000000000000000;;			if atEOF {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fd := formTable[f]
0000000000000000000000000000000000000000;;		info := fd.info(src, 0)
0000000000000000000000000000000000000000;;		if info.size == 0 {
0000000000000000000000000000000000000000;;			if atEOF {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss := streamSafe(0)
0000000000000000000000000000000000000000;;		ss.first(info)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := int(info.size); i < nsrc; i += int(info.size) {
0000000000000000000000000000000000000000;;			info = fd.info(src, i)
0000000000000000000000000000000000000000;;			if info.size == 0 {
0000000000000000000000000000000000000000;;				if atEOF {
0000000000000000000000000000000000000000;;					return i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s := ss.next(info); s != ssSuccess {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !atEOF && !info.BoundaryAfter() && !ss.isMax() {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nsrc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LastBoundary returns the position i of the last boundary in b
0000000000000000000000000000000000000000;;	// or -1 if b contains no boundary.
0000000000000000000000000000000000000000;;	func (f Form) LastBoundary(b []byte) int {
0000000000000000000000000000000000000000;;		return lastBoundary(formTable[f], b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lastBoundary(fd *formInfo, b []byte) int {
0000000000000000000000000000000000000000;;		i := len(b)
0000000000000000000000000000000000000000;;		info, p := lastRuneStart(fd, b)
0000000000000000000000000000000000000000;;		if p == -1 {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.size == 0 { // ends with incomplete rune
0000000000000000000000000000000000000000;;			if p == 0 { // starts with incomplete rune
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = p
0000000000000000000000000000000000000000;;			info, p = lastRuneStart(fd, b[:i])
0000000000000000000000000000000000000000;;			if p == -1 { // incomplete UTF-8 encoding or non-starter bytes without a starter
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p+int(info.size) != i { // trailing non-starter bytes: illegal UTF-8
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.BoundaryAfter() {
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss := streamSafe(0)
0000000000000000000000000000000000000000;;		v := ss.backwards(info)
0000000000000000000000000000000000000000;;		for i = p; i >= 0 && v != ssStarter; i = p {
0000000000000000000000000000000000000000;;			info, p = lastRuneStart(fd, b[:i])
0000000000000000000000000000000000000000;;			if v = ss.backwards(info); v == ssOverflow {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p+int(info.size) != i {
0000000000000000000000000000000000000000;;				if p == -1 { // no boundary found
0000000000000000000000000000000000000000;;					return -1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return i // boundary after an illegal UTF-8 encoding
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decomposeSegment scans the first segment in src into rb. It inserts 0x034f
0000000000000000000000000000000000000000;;	// (Grapheme Joiner) when it encounters a sequence of more than 30 non-starters
0000000000000000000000000000000000000000;;	// and returns the number of bytes consumed from src or iShortDst or iShortSrc.
0000000000000000000000000000000000000000;;	func decomposeSegment(rb *reorderBuffer, sp int, atEOF bool) int {
0000000000000000000000000000000000000000;;		// Force one character to be consumed.
0000000000000000000000000000000000000000;;		info := rb.f.info(rb.src, sp)
0000000000000000000000000000000000000000;;		if info.size == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rb.nrune > 0 {
0000000000000000000000000000000000000000;;			if s := rb.ss.next(info); s == ssStarter {
0000000000000000000000000000000000000000;;				goto end
0000000000000000000000000000000000000000;;			} else if s == ssOverflow {
0000000000000000000000000000000000000000;;				rb.insertCGJ()
0000000000000000000000000000000000000000;;				goto end
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rb.ss.first(info)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := rb.insertFlush(rb.src, sp, info); err != iSuccess {
0000000000000000000000000000000000000000;;			return int(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			sp += int(info.size)
0000000000000000000000000000000000000000;;			if sp >= rb.nsrc {
0000000000000000000000000000000000000000;;				if !atEOF && !info.BoundaryAfter() {
0000000000000000000000000000000000000000;;					return int(iShortSrc)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info = rb.f.info(rb.src, sp)
0000000000000000000000000000000000000000;;			if info.size == 0 {
0000000000000000000000000000000000000000;;				if !atEOF {
0000000000000000000000000000000000000000;;					return int(iShortSrc)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s := rb.ss.next(info); s == ssStarter {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if s == ssOverflow {
0000000000000000000000000000000000000000;;				rb.insertCGJ()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := rb.insertFlush(rb.src, sp, info); err != iSuccess {
0000000000000000000000000000000000000000;;				return int(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	end:
0000000000000000000000000000000000000000;;		if !rb.doFlush() {
0000000000000000000000000000000000000000;;			return int(iShortDst)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lastRuneStart returns the runeInfo and position of the last
0000000000000000000000000000000000000000;;	// rune in buf or the zero runeInfo and -1 if no rune was found.
0000000000000000000000000000000000000000;;	func lastRuneStart(fd *formInfo, buf []byte) (Properties, int) {
0000000000000000000000000000000000000000;;		p := len(buf) - 1
0000000000000000000000000000000000000000;;		for ; p >= 0 && !utf8.RuneStart(buf[p]); p-- {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p < 0 {
0000000000000000000000000000000000000000;;			return Properties{}, -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fd.info(inputBytes(buf), p), p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decomposeToLastBoundary finds an open segment at the end of the buffer
0000000000000000000000000000000000000000;;	// and scans it into rb. Returns the buffer minus the last segment.
0000000000000000000000000000000000000000;;	func decomposeToLastBoundary(rb *reorderBuffer) {
0000000000000000000000000000000000000000;;		fd := &rb.f
0000000000000000000000000000000000000000;;		info, i := lastRuneStart(fd, rb.out)
0000000000000000000000000000000000000000;;		if int(info.size) != len(rb.out)-i {
0000000000000000000000000000000000000000;;			// illegal trailing continuation bytes
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if info.BoundaryAfter() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var add [maxNonStarters + 1]Properties // stores runeInfo in reverse order
0000000000000000000000000000000000000000;;		padd := 0
0000000000000000000000000000000000000000;;		ss := streamSafe(0)
0000000000000000000000000000000000000000;;		p := len(rb.out)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			add[padd] = info
0000000000000000000000000000000000000000;;			v := ss.backwards(info)
0000000000000000000000000000000000000000;;			if v == ssOverflow {
0000000000000000000000000000000000000000;;				// Note that if we have an overflow, it the string we are appending to
0000000000000000000000000000000000000000;;				// is not correctly normalized. In this case the behavior is undefined.
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			padd++
0000000000000000000000000000000000000000;;			p -= int(info.size)
0000000000000000000000000000000000000000;;			if v == ssStarter || p < 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info, i = lastRuneStart(fd, rb.out[:p])
0000000000000000000000000000000000000000;;			if int(info.size) != p-i {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rb.ss = ss
0000000000000000000000000000000000000000;;		// Copy bytes for insertion as we may need to overwrite rb.out.
0000000000000000000000000000000000000000;;		var buf [maxBufferSize * utf8.UTFMax]byte
0000000000000000000000000000000000000000;;		cp := buf[:copy(buf[:], rb.out[p:])]
0000000000000000000000000000000000000000;;		rb.out = rb.out[:p]
0000000000000000000000000000000000000000;;		for padd--; padd >= 0; padd-- {
0000000000000000000000000000000000000000;;			info = add[padd]
0000000000000000000000000000000000000000;;			rb.insertUnsafe(inputBytes(cp), 0, info)
0000000000000000000000000000000000000000;;			cp = cp[info.size:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
