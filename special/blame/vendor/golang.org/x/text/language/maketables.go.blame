0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// +build ignore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Language tag table generator.
0000000000000000000000000000000000000000;;	// Data read from the web.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/gen"
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/tag"
0000000000000000000000000000000000000000;;		"golang.org/x/text/unicode/cldr"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		test = flag.Bool("test",
0000000000000000000000000000000000000000;;			false,
0000000000000000000000000000000000000000;;			"test existing tables; can be used to compare web data with package data.")
0000000000000000000000000000000000000000;;		outputFile = flag.String("output",
0000000000000000000000000000000000000000;;			"tables.go",
0000000000000000000000000000000000000000;;			"output file for generated tables")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var comment = []string{
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	lang holds an alphabetically sorted list of ISO-639 language identifiers.
0000000000000000000000000000000000000000;;	All entries are 4 bytes. The index of the identifier (divided by 4) is the language tag.
0000000000000000000000000000000000000000;;	For 2-byte language identifiers, the two successive bytes have the following meaning:
0000000000000000000000000000000000000000;;	    - if the first letter of the 2- and 3-letter ISO codes are the same:
0000000000000000000000000000000000000000;;	      the second and third letter of the 3-letter ISO code.
0000000000000000000000000000000000000000;;	    - otherwise: a 0 and a by 2 bits right-shifted index into altLangISO3.
0000000000000000000000000000000000000000;;	For 3-byte language identifiers the 4th byte is 0.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	langNoIndex is a bit vector of all 3-letter language codes that are not used as an index
0000000000000000000000000000000000000000;;	in lookup tables. The language ids for these language codes are derived directly
0000000000000000000000000000000000000000;;	from the letters and are not consecutive.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	altLangISO3 holds an alphabetically sorted list of 3-letter language code alternatives
0000000000000000000000000000000000000000;;	to 2-letter language codes that cannot be derived using the method described above.
0000000000000000000000000000000000000000;;	Each 3-letter code is followed by its 1-byte langID.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	altLangIndex is used to convert indexes in altLangISO3 to langIDs.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	langAliasMap maps langIDs to their suggested replacements.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	script is an alphabetically sorted list of ISO 15924 codes. The index
0000000000000000000000000000000000000000;;	of the script in the string, divided by 4, is the internal scriptID.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	isoRegionOffset needs to be added to the index of regionISO to obtain the regionID
0000000000000000000000000000000000000000;;	for 2-letter ISO codes. (The first isoRegionOffset regionIDs are reserved for
0000000000000000000000000000000000000000;;	the UN.M49 codes used for groups.)`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	regionISO holds a list of alphabetically sorted 2-letter ISO region codes.
0000000000000000000000000000000000000000;;	Each 2-letter codes is followed by two bytes with the following meaning:
0000000000000000000000000000000000000000;;	    - [A-Z}{2}: the first letter of the 2-letter code plus these two 
0000000000000000000000000000000000000000;;	                letters form the 3-letter ISO code.
0000000000000000000000000000000000000000;;	    - 0, n:     index into altRegionISO3.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	regionTypes defines the status of a region for various standards.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	m49 maps regionIDs to UN.M49 codes. The first isoRegionOffset entries are
0000000000000000000000000000000000000000;;	codes indicating collections of regions.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	m49Index gives indexes into fromM49 based on the three most significant bits
0000000000000000000000000000000000000000;;	of a 10-bit UN.M49 code. To search an UN.M49 code in fromM49, search in
0000000000000000000000000000000000000000;;	   fromM49[m49Index[msb39(code)]:m49Index[msb3(code)+1]]
0000000000000000000000000000000000000000;;	for an entry where the first 7 bits match the 7 lsb of the UN.M49 code.
0000000000000000000000000000000000000000;;	The region code is stored in the 9 lsb of the indexed value.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	fromM49 contains entries to map UN.M49 codes to regions. See m49Index for details.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	altRegionISO3 holds a list of 3-letter region codes that cannot be
0000000000000000000000000000000000000000;;	mapped to 2-letter codes using the default algorithm. This is a short list.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	altRegionIDs holds a list of regionIDs the positions of which match those
0000000000000000000000000000000000000000;;	of the 3-letter ISO codes in altRegionISO3.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	variantNumSpecialized is the number of specialized variants in variants.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	suppressScript is an index from langID to the dominant script for that language,
0000000000000000000000000000000000000000;;	if it exists.  If a script is given, it should be suppressed from the language tag.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	likelyLang is a lookup table, indexed by langID, for the most likely
0000000000000000000000000000000000000000;;	scripts and regions given incomplete information. If more entries exist for a
0000000000000000000000000000000000000000;;	given language, region and script are the index and size respectively
0000000000000000000000000000000000000000;;	of the list in likelyLangList.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	likelyLangList holds lists info associated with likelyLang.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	likelyRegion is a lookup table, indexed by regionID, for the most likely
0000000000000000000000000000000000000000;;	languages and scripts given incomplete information. If more entries exist
0000000000000000000000000000000000000000;;	for a given regionID, lang and script are the index and size respectively
0000000000000000000000000000000000000000;;	of the list in likelyRegionList.
0000000000000000000000000000000000000000;;	TODO: exclude containers and user-definable regions from the list.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	likelyRegionList holds lists info associated with likelyRegion.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	likelyScript is a lookup table, indexed by scriptID, for the most likely
0000000000000000000000000000000000000000;;	languages and regions given a script.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	matchLang holds pairs of langIDs of base languages that are typically
0000000000000000000000000000000000000000;;	mutually intelligible. Each pair is associated with a confidence and
0000000000000000000000000000000000000000;;	whether the intelligibility goes one or both ways.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	matchScript holds pairs of scriptIDs where readers of one script
0000000000000000000000000000000000000000;;	can typically also read the other. Each is associated with a confidence.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	nRegionGroups is the number of region groups.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	regionInclusion maps region identifiers to sets of regions in regionInclusionBits,
0000000000000000000000000000000000000000;;	where each set holds all groupings that are directly connected in a region
0000000000000000000000000000000000000000;;	containment graph.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	regionInclusionBits is an array of bit vectors where every vector represents
0000000000000000000000000000000000000000;;	a set of region groupings.  These sets are used to compute the distance
0000000000000000000000000000000000000000;;	between two regions for the purpose of language matching.`,
0000000000000000000000000000000000000000;;		`
0000000000000000000000000000000000000000;;	regionInclusionNext marks, for each entry in regionInclusionBits, the set of
0000000000000000000000000000000000000000;;	all groups that are reachable from the groups set in the respective entry.`,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: consider changing some of these structures to tries. This can reduce
0000000000000000000000000000000000000000;;	// memory, but may increase the need for memory allocations. This could be
0000000000000000000000000000000000000000;;	// mitigated if we can piggyback on language tags for common cases.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func failOnError(e error) {
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			log.Panic(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type setType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Indexed setType = 1 + iota // all elements must be of same size
0000000000000000000000000000000000000000;;		Linear
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stringSet struct {
0000000000000000000000000000000000000000;;		s              []string
0000000000000000000000000000000000000000;;		sorted, frozen bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We often need to update values after the creation of an index is completed.
0000000000000000000000000000000000000000;;		// We include a convenience map for keeping track of this.
0000000000000000000000000000000000000000;;		update map[string]string
0000000000000000000000000000000000000000;;		typ    setType // used for checking.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) clone() stringSet {
0000000000000000000000000000000000000000;;		c := *ss
0000000000000000000000000000000000000000;;		c.s = append([]string(nil), c.s...)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) setType(t setType) {
0000000000000000000000000000000000000000;;		if ss.typ != t && ss.typ != 0 {
0000000000000000000000000000000000000000;;			log.Panicf("type %d cannot be assigned as it was already %d", t, ss.typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parse parses a whitespace-separated string and initializes ss with its
0000000000000000000000000000000000000000;;	// components.
0000000000000000000000000000000000000000;;	func (ss *stringSet) parse(s string) {
0000000000000000000000000000000000000000;;		scan := bufio.NewScanner(strings.NewReader(s))
0000000000000000000000000000000000000000;;		scan.Split(bufio.ScanWords)
0000000000000000000000000000000000000000;;		for scan.Scan() {
0000000000000000000000000000000000000000;;			ss.add(scan.Text())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) assertChangeable() {
0000000000000000000000000000000000000000;;		if ss.frozen {
0000000000000000000000000000000000000000;;			log.Panic("attempt to modify a frozen stringSet")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) add(s string) {
0000000000000000000000000000000000000000;;		ss.assertChangeable()
0000000000000000000000000000000000000000;;		ss.s = append(ss.s, s)
0000000000000000000000000000000000000000;;		ss.sorted = ss.frozen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) freeze() {
0000000000000000000000000000000000000000;;		ss.compact()
0000000000000000000000000000000000000000;;		ss.frozen = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) compact() {
0000000000000000000000000000000000000000;;		if ss.sorted {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a := ss.s
0000000000000000000000000000000000000000;;		sort.Strings(a)
0000000000000000000000000000000000000000;;		k := 0
0000000000000000000000000000000000000000;;		for i := 1; i < len(a); i++ {
0000000000000000000000000000000000000000;;			if a[k] != a[i] {
0000000000000000000000000000000000000000;;				a[k+1] = a[i]
0000000000000000000000000000000000000000;;				k++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss.s = a[:k+1]
0000000000000000000000000000000000000000;;		ss.sorted = ss.frozen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type funcSorter struct {
0000000000000000000000000000000000000000;;		fn func(a, b string) bool
0000000000000000000000000000000000000000;;		sort.StringSlice
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s funcSorter) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s.fn(s.StringSlice[i], s.StringSlice[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) sortFunc(f func(a, b string) bool) {
0000000000000000000000000000000000000000;;		ss.compact()
0000000000000000000000000000000000000000;;		sort.Sort(funcSorter{f, sort.StringSlice(ss.s)})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) remove(s string) {
0000000000000000000000000000000000000000;;		ss.assertChangeable()
0000000000000000000000000000000000000000;;		if i, ok := ss.find(s); ok {
0000000000000000000000000000000000000000;;			copy(ss.s[i:], ss.s[i+1:])
0000000000000000000000000000000000000000;;			ss.s = ss.s[:len(ss.s)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) replace(ol, nu string) {
0000000000000000000000000000000000000000;;		ss.s[ss.index(ol)] = nu
0000000000000000000000000000000000000000;;		ss.sorted = ss.frozen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) index(s string) int {
0000000000000000000000000000000000000000;;		ss.setType(Indexed)
0000000000000000000000000000000000000000;;		i, ok := ss.find(s)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			if i < len(ss.s) {
0000000000000000000000000000000000000000;;				log.Panicf("find: item %q is not in list. Closest match is %q.", s, ss.s[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			log.Panicf("find: item %q is not in list", s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) find(s string) (int, bool) {
0000000000000000000000000000000000000000;;		ss.compact()
0000000000000000000000000000000000000000;;		i := sort.SearchStrings(ss.s, s)
0000000000000000000000000000000000000000;;		return i, i != len(ss.s) && ss.s[i] == s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) slice() []string {
0000000000000000000000000000000000000000;;		ss.compact()
0000000000000000000000000000000000000000;;		return ss.s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss *stringSet) updateLater(v, key string) {
0000000000000000000000000000000000000000;;		if ss.update == nil {
0000000000000000000000000000000000000000;;			ss.update = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss.update[v] = key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// join joins the string and ensures that all entries are of the same length.
0000000000000000000000000000000000000000;;	func (ss *stringSet) join() string {
0000000000000000000000000000000000000000;;		ss.setType(Indexed)
0000000000000000000000000000000000000000;;		n := len(ss.s[0])
0000000000000000000000000000000000000000;;		for _, s := range ss.s {
0000000000000000000000000000000000000000;;			if len(s) != n {
0000000000000000000000000000000000000000;;				log.Panicf("join: not all entries are of the same length: %q", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ss.s = append(ss.s, strings.Repeat("\xff", n))
0000000000000000000000000000000000000000;;		return strings.Join(ss.s, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ianaEntry holds information for an entry in the IANA Language Subtag Repository.
0000000000000000000000000000000000000000;;	// All types use the same entry.
0000000000000000000000000000000000000000;;	// See http://tools.ietf.org/html/bcp47#section-5.1 for a description of the various
0000000000000000000000000000000000000000;;	// fields.
0000000000000000000000000000000000000000;;	type ianaEntry struct {
0000000000000000000000000000000000000000;;		typ            string
0000000000000000000000000000000000000000;;		description    []string
0000000000000000000000000000000000000000;;		scope          string
0000000000000000000000000000000000000000;;		added          string
0000000000000000000000000000000000000000;;		preferred      string
0000000000000000000000000000000000000000;;		deprecated     string
0000000000000000000000000000000000000000;;		suppressScript string
0000000000000000000000000000000000000000;;		macro          string
0000000000000000000000000000000000000000;;		prefix         []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type builder struct {
0000000000000000000000000000000000000000;;		w    *gen.CodeWriter
0000000000000000000000000000000000000000;;		hw   io.Writer // MultiWriter for w and w.Hash
0000000000000000000000000000000000000000;;		data *cldr.CLDR
0000000000000000000000000000000000000000;;		supp *cldr.SupplementalData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// indices
0000000000000000000000000000000000000000;;		locale      stringSet // common locales
0000000000000000000000000000000000000000;;		lang        stringSet // canonical language ids (2 or 3 letter ISO codes) with data
0000000000000000000000000000000000000000;;		langNoIndex stringSet // 3-letter ISO codes with no associated data
0000000000000000000000000000000000000000;;		script      stringSet // 4-letter ISO codes
0000000000000000000000000000000000000000;;		region      stringSet // 2-letter ISO or 3-digit UN M49 codes
0000000000000000000000000000000000000000;;		variant     stringSet // 4-8-alphanumeric variant code.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Region codes that are groups with their corresponding group IDs.
0000000000000000000000000000000000000000;;		groups map[int]index
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// langInfo
0000000000000000000000000000000000000000;;		registry map[string]*ianaEntry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type index uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBuilder(w *gen.CodeWriter) *builder {
0000000000000000000000000000000000000000;;		r := gen.OpenCLDRCoreZip()
0000000000000000000000000000000000000000;;		defer r.Close()
0000000000000000000000000000000000000000;;		d := &cldr.Decoder{}
0000000000000000000000000000000000000000;;		data, err := d.DecodeZip(r)
0000000000000000000000000000000000000000;;		failOnError(err)
0000000000000000000000000000000000000000;;		b := builder{
0000000000000000000000000000000000000000;;			w:    w,
0000000000000000000000000000000000000000;;			hw:   io.MultiWriter(w, w.Hash),
0000000000000000000000000000000000000000;;			data: data,
0000000000000000000000000000000000000000;;			supp: data.Supplemental(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.parseRegistry()
0000000000000000000000000000000000000000;;		return &b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) parseRegistry() {
0000000000000000000000000000000000000000;;		r := gen.OpenIANAFile("assignments/language-subtag-registry")
0000000000000000000000000000000000000000;;		defer r.Close()
0000000000000000000000000000000000000000;;		b.registry = make(map[string]*ianaEntry)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scan := bufio.NewScanner(r)
0000000000000000000000000000000000000000;;		scan.Split(bufio.ScanWords)
0000000000000000000000000000000000000000;;		var record *ianaEntry
0000000000000000000000000000000000000000;;		for more := scan.Scan(); more; {
0000000000000000000000000000000000000000;;			key := scan.Text()
0000000000000000000000000000000000000000;;			more = scan.Scan()
0000000000000000000000000000000000000000;;			value := scan.Text()
0000000000000000000000000000000000000000;;			switch key {
0000000000000000000000000000000000000000;;			case "Type:":
0000000000000000000000000000000000000000;;				record = &ianaEntry{typ: value}
0000000000000000000000000000000000000000;;			case "Subtag:", "Tag:":
0000000000000000000000000000000000000000;;				if s := strings.SplitN(value, "..", 2); len(s) > 1 {
0000000000000000000000000000000000000000;;					for a := s[0]; a <= s[1]; a = inc(a) {
0000000000000000000000000000000000000000;;						b.addToRegistry(a, record)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					b.addToRegistry(value, record)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case "Suppress-Script:":
0000000000000000000000000000000000000000;;				record.suppressScript = value
0000000000000000000000000000000000000000;;			case "Added:":
0000000000000000000000000000000000000000;;				record.added = value
0000000000000000000000000000000000000000;;			case "Deprecated:":
0000000000000000000000000000000000000000;;				record.deprecated = value
0000000000000000000000000000000000000000;;			case "Macrolanguage:":
0000000000000000000000000000000000000000;;				record.macro = value
0000000000000000000000000000000000000000;;			case "Preferred-Value:":
0000000000000000000000000000000000000000;;				record.preferred = value
0000000000000000000000000000000000000000;;			case "Prefix:":
0000000000000000000000000000000000000000;;				record.prefix = append(record.prefix, value)
0000000000000000000000000000000000000000;;			case "Scope:":
0000000000000000000000000000000000000000;;				record.scope = value
0000000000000000000000000000000000000000;;			case "Description:":
0000000000000000000000000000000000000000;;				buf := []byte(value)
0000000000000000000000000000000000000000;;				for more = scan.Scan(); more; more = scan.Scan() {
0000000000000000000000000000000000000000;;					b := scan.Bytes()
0000000000000000000000000000000000000000;;					if b[0] == '%' || b[len(b)-1] == ':' {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					buf = append(buf, ' ')
0000000000000000000000000000000000000000;;					buf = append(buf, b...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				record.description = append(record.description, string(buf))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			more = scan.Scan()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if scan.Err() != nil {
0000000000000000000000000000000000000000;;			log.Panic(scan.Err())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) addToRegistry(key string, entry *ianaEntry) {
0000000000000000000000000000000000000000;;		if info, ok := b.registry[key]; ok {
0000000000000000000000000000000000000000;;			if info.typ != "language" || entry.typ != "extlang" {
0000000000000000000000000000000000000000;;				log.Fatalf("parseRegistry: tag %q already exists", key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			b.registry[key] = entry
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var commentIndex = make(map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		for _, s := range comment {
0000000000000000000000000000000000000000;;			key := strings.TrimSpace(strings.SplitN(s, " ", 2)[0])
0000000000000000000000000000000000000000;;			commentIndex[key] = s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) comment(name string) {
0000000000000000000000000000000000000000;;		if s := commentIndex[name]; len(s) > 0 {
0000000000000000000000000000000000000000;;			b.w.WriteComment(s)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Fprintln(b.w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) pf(f string, x ...interface{}) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(b.hw, f, x...)
0000000000000000000000000000000000000000;;		fmt.Fprint(b.hw, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) p(x ...interface{}) {
0000000000000000000000000000000000000000;;		fmt.Fprintln(b.hw, x...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) addSize(s int) {
0000000000000000000000000000000000000000;;		b.w.Size += s
0000000000000000000000000000000000000000;;		b.pf("// Size: %d bytes", s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeConst(name string, x interface{}) {
0000000000000000000000000000000000000000;;		b.comment(name)
0000000000000000000000000000000000000000;;		b.w.WriteConst(name, x)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeConsts computes f(v) for all v in values and writes the results
0000000000000000000000000000000000000000;;	// as constants named _v to a single constant block.
0000000000000000000000000000000000000000;;	func (b *builder) writeConsts(f func(string) int, values ...string) {
0000000000000000000000000000000000000000;;		b.pf("const (")
0000000000000000000000000000000000000000;;		for _, v := range values {
0000000000000000000000000000000000000000;;			b.pf("\t_%s = %v", v, f(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.pf(")")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeType writes the type of the given value, which must be a struct.
0000000000000000000000000000000000000000;;	func (b *builder) writeType(value interface{}) {
0000000000000000000000000000000000000000;;		b.comment(reflect.TypeOf(value).Name())
0000000000000000000000000000000000000000;;		b.w.WriteType(value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeSlice(name string, ss interface{}) {
0000000000000000000000000000000000000000;;		b.writeSliceAddSize(name, 0, ss)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeSliceAddSize(name string, extraSize int, ss interface{}) {
0000000000000000000000000000000000000000;;		b.comment(name)
0000000000000000000000000000000000000000;;		b.w.Size += extraSize
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(ss)
0000000000000000000000000000000000000000;;		t := v.Type().Elem()
0000000000000000000000000000000000000000;;		b.pf("// Size: %d bytes, %d elements", v.Len()*int(t.Size())+extraSize, v.Len())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(b.w, "var %s = ", name)
0000000000000000000000000000000000000000;;		b.w.WriteArray(ss)
0000000000000000000000000000000000000000;;		b.p()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fromTo struct {
0000000000000000000000000000000000000000;;		from, to uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeSortedMap(name string, ss *stringSet, index func(s string) uint16) {
0000000000000000000000000000000000000000;;		ss.sortFunc(func(a, b string) bool {
0000000000000000000000000000000000000000;;			return index(a) < index(b)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		m := []fromTo{}
0000000000000000000000000000000000000000;;		for _, s := range ss.s {
0000000000000000000000000000000000000000;;			m = append(m, fromTo{index(s), index(ss.update[s])})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSlice(name, m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const base = 'z' - 'a' + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func strToInt(s string) uint {
0000000000000000000000000000000000000000;;		v := uint(0)
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			v *= base
0000000000000000000000000000000000000000;;			v += uint(s[i] - 'a')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// converts the given integer to the original ASCII string passed to strToInt.
0000000000000000000000000000000000000000;;	// len(s) must match the number of characters obtained.
0000000000000000000000000000000000000000;;	func intToStr(v uint, s []byte) {
0000000000000000000000000000000000000000;;		for i := len(s) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			s[i] = byte(v%base) + 'a'
0000000000000000000000000000000000000000;;			v /= base
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeBitVector(name string, ss []string) {
0000000000000000000000000000000000000000;;		vec := make([]uint8, int(math.Ceil(math.Pow(base, float64(len(ss[0])))/8)))
0000000000000000000000000000000000000000;;		for _, s := range ss {
0000000000000000000000000000000000000000;;			v := strToInt(s)
0000000000000000000000000000000000000000;;			vec[v/8] |= 1 << (v % 8)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSlice(name, vec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: convert this type into a list or two-stage trie.
0000000000000000000000000000000000000000;;	func (b *builder) writeMapFunc(name string, m map[string]string, f func(string) uint16) {
0000000000000000000000000000000000000000;;		b.comment(name)
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(m)
0000000000000000000000000000000000000000;;		sz := v.Len() * (2 + int(v.Type().Key().Size()))
0000000000000000000000000000000000000000;;		for _, k := range m {
0000000000000000000000000000000000000000;;			sz += len(k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.addSize(sz)
0000000000000000000000000000000000000000;;		keys := []string{}
0000000000000000000000000000000000000000;;		b.pf(`var %s = map[string]uint16{`, name)
0000000000000000000000000000000000000000;;		for k := range m {
0000000000000000000000000000000000000000;;			keys = append(keys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(keys)
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			b.pf("\t%q: %v,", k, f(m[k]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.p("}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeMap(name string, m interface{}) {
0000000000000000000000000000000000000000;;		b.comment(name)
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(m)
0000000000000000000000000000000000000000;;		sz := v.Len() * (2 + int(v.Type().Key().Size()) + int(v.Type().Elem().Size()))
0000000000000000000000000000000000000000;;		b.addSize(sz)
0000000000000000000000000000000000000000;;		f := strings.FieldsFunc(fmt.Sprintf("%#v", m), func(r rune) bool {
0000000000000000000000000000000000000000;;			return strings.IndexRune("{}, ", r) != -1
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		sort.Strings(f[1:])
0000000000000000000000000000000000000000;;		b.pf(`var %s = %s{`, name, f[0])
0000000000000000000000000000000000000000;;		for _, kv := range f[1:] {
0000000000000000000000000000000000000000;;			b.pf("\t%s,", kv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.p("}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) langIndex(s string) uint16 {
0000000000000000000000000000000000000000;;		if s == "und" {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i, ok := b.lang.find(s); ok {
0000000000000000000000000000000000000000;;			return uint16(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint16(strToInt(s)) + uint16(len(b.lang.s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// inc advances the string to its lexicographical successor.
0000000000000000000000000000000000000000;;	func inc(s string) string {
0000000000000000000000000000000000000000;;		const maxTagLength = 4
0000000000000000000000000000000000000000;;		var buf [maxTagLength]byte
0000000000000000000000000000000000000000;;		intToStr(strToInt(strings.ToLower(s))+1, buf[:len(s)])
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			if s[i] <= 'Z' {
0000000000000000000000000000000000000000;;				buf[i] -= 'a' - 'A'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf[:len(s)])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) parseIndices() {
0000000000000000000000000000000000000000;;		meta := b.supp.Metadata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range b.registry {
0000000000000000000000000000000000000000;;			var ss *stringSet
0000000000000000000000000000000000000000;;			switch v.typ {
0000000000000000000000000000000000000000;;			case "language":
0000000000000000000000000000000000000000;;				if len(k) == 2 || v.suppressScript != "" || v.scope == "special" {
0000000000000000000000000000000000000000;;					b.lang.add(k)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					ss = &b.langNoIndex
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case "region":
0000000000000000000000000000000000000000;;				ss = &b.region
0000000000000000000000000000000000000000;;			case "script":
0000000000000000000000000000000000000000;;				ss = &b.script
0000000000000000000000000000000000000000;;			case "variant":
0000000000000000000000000000000000000000;;				ss = &b.variant
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ss.add(k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Include any language for which there is data.
0000000000000000000000000000000000000000;;		for _, lang := range b.data.Locales() {
0000000000000000000000000000000000000000;;			if x := b.data.RawLDML(lang); false ||
0000000000000000000000000000000000000000;;				x.LocaleDisplayNames != nil ||
0000000000000000000000000000000000000000;;				x.Characters != nil ||
0000000000000000000000000000000000000000;;				x.Delimiters != nil ||
0000000000000000000000000000000000000000;;				x.Measurement != nil ||
0000000000000000000000000000000000000000;;				x.Dates != nil ||
0000000000000000000000000000000000000000;;				x.Numbers != nil ||
0000000000000000000000000000000000000000;;				x.Units != nil ||
0000000000000000000000000000000000000000;;				x.ListPatterns != nil ||
0000000000000000000000000000000000000000;;				x.Collations != nil ||
0000000000000000000000000000000000000000;;				x.Segmentations != nil ||
0000000000000000000000000000000000000000;;				x.Rbnf != nil ||
0000000000000000000000000000000000000000;;				x.Annotations != nil ||
0000000000000000000000000000000000000000;;				x.Metadata != nil {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				from := strings.Split(lang, "_")
0000000000000000000000000000000000000000;;				if lang := from[0]; lang != "root" {
0000000000000000000000000000000000000000;;					b.lang.add(lang)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Include locales for plural rules, which uses a different structure.
0000000000000000000000000000000000000000;;		for _, plurals := range b.data.Supplemental().Plurals {
0000000000000000000000000000000000000000;;			for _, rules := range plurals.PluralRules {
0000000000000000000000000000000000000000;;				for _, lang := range strings.Split(rules.Locales, " ") {
0000000000000000000000000000000000000000;;					if lang = strings.Split(lang, "_")[0]; lang != "root" {
0000000000000000000000000000000000000000;;						b.lang.add(lang)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Include languages in likely subtags.
0000000000000000000000000000000000000000;;		for _, m := range b.supp.LikelySubtags.LikelySubtag {
0000000000000000000000000000000000000000;;			from := strings.Split(m.From, "_")
0000000000000000000000000000000000000000;;			b.lang.add(from[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Include ISO-639 alpha-3 bibliographic entries.
0000000000000000000000000000000000000000;;		for _, a := range meta.Alias.LanguageAlias {
0000000000000000000000000000000000000000;;			if a.Reason == "bibliographic" {
0000000000000000000000000000000000000000;;				b.langNoIndex.add(a.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Include regions in territoryAlias (not all are in the IANA registry!)
0000000000000000000000000000000000000000;;		for _, reg := range b.supp.Metadata.Alias.TerritoryAlias {
0000000000000000000000000000000000000000;;			if len(reg.Type) == 2 {
0000000000000000000000000000000000000000;;				b.region.add(reg.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, s := range b.lang.s {
0000000000000000000000000000000000000000;;			if len(s) == 3 {
0000000000000000000000000000000000000000;;				b.langNoIndex.remove(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeConst("numLanguages", len(b.lang.slice())+len(b.langNoIndex.slice()))
0000000000000000000000000000000000000000;;		b.writeConst("numScripts", len(b.script.slice()))
0000000000000000000000000000000000000000;;		b.writeConst("numRegions", len(b.region.slice()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add dummy codes at the start of each list to represent "unspecified".
0000000000000000000000000000000000000000;;		b.lang.add("---")
0000000000000000000000000000000000000000;;		b.script.add("----")
0000000000000000000000000000000000000000;;		b.region.add("---")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// common locales
0000000000000000000000000000000000000000;;		b.locale.parse(meta.DefaultContent.Locales)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) computeRegionGroups() {
0000000000000000000000000000000000000000;;		b.groups = make(map[int]index)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create group indices.
0000000000000000000000000000000000000000;;		for i := 1; b.region.s[i][0] < 'A'; i++ { // Base M49 indices on regionID.
0000000000000000000000000000000000000000;;			b.groups[i] = index(len(b.groups))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, g := range b.supp.TerritoryContainment.Group {
0000000000000000000000000000000000000000;;			group := b.region.index(g.Type)
0000000000000000000000000000000000000000;;			if _, ok := b.groups[group]; !ok {
0000000000000000000000000000000000000000;;				b.groups[group] = index(len(b.groups))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b.groups) > 32 {
0000000000000000000000000000000000000000;;			log.Fatalf("only 32 groups supported, found %d", len(b.groups))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeConst("nRegionGroups", len(b.groups))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var langConsts = []string{
0000000000000000000000000000000000000000;;		"af", "am", "ar", "az", "bg", "bn", "ca", "cs", "da", "de", "el", "en", "es",
0000000000000000000000000000000000000000;;		"et", "fa", "fi", "fil", "fr", "gu", "he", "hi", "hr", "hu", "hy", "id", "is",
0000000000000000000000000000000000000000;;		"it", "ja", "ka", "kk", "km", "kn", "ko", "ky", "lo", "lt", "lv", "mk", "ml",
0000000000000000000000000000000000000000;;		"mn", "mo", "mr", "ms", "mul", "my", "nb", "ne", "nl", "no", "pa", "pl", "pt",
0000000000000000000000000000000000000000;;		"ro", "ru", "sh", "si", "sk", "sl", "sq", "sr", "sv", "sw", "ta", "te", "th",
0000000000000000000000000000000000000000;;		"tl", "tn", "tr", "uk", "ur", "uz", "vi", "zh", "zu",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// constants for grandfathered tags (if not already defined)
0000000000000000000000000000000000000000;;		"jbo", "ami", "bnn", "hak", "tlh", "lb", "nv", "pwn", "tao", "tay", "tsu",
0000000000000000000000000000000000000000;;		"nn", "sfb", "vgt", "sgg", "cmn", "nan", "hsn",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeLanguage generates all tables needed for language canonicalization.
0000000000000000000000000000000000000000;;	func (b *builder) writeLanguage() {
0000000000000000000000000000000000000000;;		meta := b.supp.Metadata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.writeConst("nonCanonicalUnd", b.lang.index("und"))
0000000000000000000000000000000000000000;;		b.writeConsts(func(s string) int { return int(b.langIndex(s)) }, langConsts...)
0000000000000000000000000000000000000000;;		b.writeConst("langPrivateStart", b.langIndex("qaa"))
0000000000000000000000000000000000000000;;		b.writeConst("langPrivateEnd", b.langIndex("qtz"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get language codes that need to be mapped (overlong 3-letter codes,
0000000000000000000000000000000000000000;;		// deprecated 2-letter codes, legacy and grandfathered tags.)
0000000000000000000000000000000000000000;;		langAliasMap := stringSet{}
0000000000000000000000000000000000000000;;		aliasTypeMap := map[string]langAliasType{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// altLangISO3 get the alternative ISO3 names that need to be mapped.
0000000000000000000000000000000000000000;;		altLangISO3 := stringSet{}
0000000000000000000000000000000000000000;;		// Add dummy start to avoid the use of index 0.
0000000000000000000000000000000000000000;;		altLangISO3.add("---")
0000000000000000000000000000000000000000;;		altLangISO3.updateLater("---", "aa")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lang := b.lang.clone()
0000000000000000000000000000000000000000;;		for _, a := range meta.Alias.LanguageAlias {
0000000000000000000000000000000000000000;;			if a.Replacement == "" {
0000000000000000000000000000000000000000;;				a.Replacement = "und"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: support mapping to tags
0000000000000000000000000000000000000000;;			repl := strings.SplitN(a.Replacement, "_", 2)[0]
0000000000000000000000000000000000000000;;			if a.Reason == "overlong" {
0000000000000000000000000000000000000000;;				if len(a.Replacement) == 2 && len(a.Type) == 3 {
0000000000000000000000000000000000000000;;					lang.updateLater(a.Replacement, a.Type)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if len(a.Type) <= 3 {
0000000000000000000000000000000000000000;;				switch a.Reason {
0000000000000000000000000000000000000000;;				case "macrolanguage":
0000000000000000000000000000000000000000;;					aliasTypeMap[a.Type] = langMacro
0000000000000000000000000000000000000000;;				case "deprecated":
0000000000000000000000000000000000000000;;					// handled elsewhere
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case "bibliographic", "legacy":
0000000000000000000000000000000000000000;;					if a.Type == "no" {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					aliasTypeMap[a.Type] = langLegacy
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					log.Fatalf("new %s alias: %s", a.Reason, a.Type)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				langAliasMap.add(a.Type)
0000000000000000000000000000000000000000;;				langAliasMap.updateLater(a.Type, repl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Manually add the mapping of "nb" (Norwegian) to its macro language.
0000000000000000000000000000000000000000;;		// This can be removed if CLDR adopts this change.
0000000000000000000000000000000000000000;;		langAliasMap.add("nb")
0000000000000000000000000000000000000000;;		langAliasMap.updateLater("nb", "no")
0000000000000000000000000000000000000000;;		aliasTypeMap["nb"] = langMacro
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range b.registry {
0000000000000000000000000000000000000000;;			// Also add deprecated values for 3-letter ISO codes, which CLDR omits.
0000000000000000000000000000000000000000;;			if v.typ == "language" && v.deprecated != "" && v.preferred != "" {
0000000000000000000000000000000000000000;;				langAliasMap.add(k)
0000000000000000000000000000000000000000;;				langAliasMap.updateLater(k, v.preferred)
0000000000000000000000000000000000000000;;				aliasTypeMap[k] = langDeprecated
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Fix CLDR mappings.
0000000000000000000000000000000000000000;;		lang.updateLater("tl", "tgl")
0000000000000000000000000000000000000000;;		lang.updateLater("sh", "hbs")
0000000000000000000000000000000000000000;;		lang.updateLater("mo", "mol")
0000000000000000000000000000000000000000;;		lang.updateLater("no", "nor")
0000000000000000000000000000000000000000;;		lang.updateLater("tw", "twi")
0000000000000000000000000000000000000000;;		lang.updateLater("nb", "nob")
0000000000000000000000000000000000000000;;		lang.updateLater("ak", "aka")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure that each 2-letter code is matched with a 3-letter code.
0000000000000000000000000000000000000000;;		for _, v := range lang.s[1:] {
0000000000000000000000000000000000000000;;			s, ok := lang.update[v]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				if s, ok = lang.update[langAliasMap.update[v]]; !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lang.update[v] = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v[0] != s[0] {
0000000000000000000000000000000000000000;;				altLangISO3.add(s)
0000000000000000000000000000000000000000;;				altLangISO3.updateLater(s, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Complete canonialized language tags.
0000000000000000000000000000000000000000;;		lang.freeze()
0000000000000000000000000000000000000000;;		for i, v := range lang.s {
0000000000000000000000000000000000000000;;			// We can avoid these manual entries by using the IANI registry directly.
0000000000000000000000000000000000000000;;			// Seems easier to update the list manually, as changes are rare.
0000000000000000000000000000000000000000;;			// The panic in this loop will trigger if we miss an entry.
0000000000000000000000000000000000000000;;			add := ""
0000000000000000000000000000000000000000;;			if s, ok := lang.update[v]; ok {
0000000000000000000000000000000000000000;;				if s[0] == v[0] {
0000000000000000000000000000000000000000;;					add = s[1:]
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					add = string([]byte{0, byte(altLangISO3.index(s))})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if len(v) == 3 {
0000000000000000000000000000000000000000;;				add = "\x00"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				log.Panicf("no data for long form of %q", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lang.s[i] += add
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeConst("lang", tag.Index(lang.join()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.writeConst("langNoIndexOffset", len(b.lang.s))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// space of all valid 3-letter language identifiers.
0000000000000000000000000000000000000000;;		b.writeBitVector("langNoIndex", b.langNoIndex.slice())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		altLangIndex := []uint16{}
0000000000000000000000000000000000000000;;		for i, s := range altLangISO3.slice() {
0000000000000000000000000000000000000000;;			altLangISO3.s[i] += string([]byte{byte(len(altLangIndex))})
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				idx := b.lang.index(altLangISO3.update[s])
0000000000000000000000000000000000000000;;				altLangIndex = append(altLangIndex, uint16(idx))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeConst("altLangISO3", tag.Index(altLangISO3.join()))
0000000000000000000000000000000000000000;;		b.writeSlice("altLangIndex", altLangIndex)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.writeSortedMap("langAliasMap", &langAliasMap, b.langIndex)
0000000000000000000000000000000000000000;;		types := make([]langAliasType, len(langAliasMap.s))
0000000000000000000000000000000000000000;;		for i, s := range langAliasMap.s {
0000000000000000000000000000000000000000;;			types[i] = aliasTypeMap[s]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSlice("langAliasTypes", types)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var scriptConsts = []string{
0000000000000000000000000000000000000000;;		"Latn", "Hani", "Hans", "Hant", "Qaaa", "Qaai", "Qabx", "Zinh", "Zyyy",
0000000000000000000000000000000000000000;;		"Zzzz",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeScript() {
0000000000000000000000000000000000000000;;		b.writeConsts(b.script.index, scriptConsts...)
0000000000000000000000000000000000000000;;		b.writeConst("script", tag.Index(b.script.join()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		supp := make([]uint8, len(b.lang.slice()))
0000000000000000000000000000000000000000;;		for i, v := range b.lang.slice()[1:] {
0000000000000000000000000000000000000000;;			if sc := b.registry[v].suppressScript; sc != "" {
0000000000000000000000000000000000000000;;				supp[i+1] = uint8(b.script.index(sc))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSlice("suppressScript", supp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There is only one deprecated script in CLDR. This value is hard-coded.
0000000000000000000000000000000000000000;;		// We check here if the code must be updated.
0000000000000000000000000000000000000000;;		for _, a := range b.supp.Metadata.Alias.ScriptAlias {
0000000000000000000000000000000000000000;;			if a.Type != "Qaai" {
0000000000000000000000000000000000000000;;				log.Panicf("unexpected deprecated stript %q", a.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseM49(s string) int16 {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, err := strconv.ParseUint(s, 10, 10)
0000000000000000000000000000000000000000;;		failOnError(err)
0000000000000000000000000000000000000000;;		return int16(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var regionConsts = []string{
0000000000000000000000000000000000000000;;		"001", "419", "BR", "CA", "ES", "GB", "MD", "PT", "UK", "US",
0000000000000000000000000000000000000000;;		"ZZ", "XA", "XC", "XK", // Unofficial tag for Kosovo.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeRegion() {
0000000000000000000000000000000000000000;;		b.writeConsts(b.region.index, regionConsts...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isoOffset := b.region.index("AA")
0000000000000000000000000000000000000000;;		m49map := make([]int16, len(b.region.slice()))
0000000000000000000000000000000000000000;;		fromM49map := make(map[int16]int)
0000000000000000000000000000000000000000;;		altRegionISO3 := ""
0000000000000000000000000000000000000000;;		altRegionIDs := []uint16{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.writeConst("isoRegionOffset", isoOffset)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2-letter region lookup and mapping to numeric codes.
0000000000000000000000000000000000000000;;		regionISO := b.region.clone()
0000000000000000000000000000000000000000;;		regionISO.s = regionISO.s[isoOffset:]
0000000000000000000000000000000000000000;;		regionISO.sorted = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		regionTypes := make([]byte, len(b.region.s))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is the region valid BCP 47?
0000000000000000000000000000000000000000;;		for s, e := range b.registry {
0000000000000000000000000000000000000000;;			if len(s) == 2 && s == strings.ToUpper(s) {
0000000000000000000000000000000000000000;;				i := b.region.index(s)
0000000000000000000000000000000000000000;;				for _, d := range e.description {
0000000000000000000000000000000000000000;;					if strings.Contains(d, "Private use") {
0000000000000000000000000000000000000000;;						regionTypes[i] = iso3166UserAssgined
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				regionTypes[i] |= bcp47Region
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is the region a valid ccTLD?
0000000000000000000000000000000000000000;;		r := gen.OpenIANAFile("domains/root/db")
0000000000000000000000000000000000000000;;		defer r.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf, err := ioutil.ReadAll(r)
0000000000000000000000000000000000000000;;		failOnError(err)
0000000000000000000000000000000000000000;;		re := regexp.MustCompile(`"/domains/root/db/([a-z]{2}).html"`)
0000000000000000000000000000000000000000;;		for _, m := range re.FindAllSubmatch(buf, -1) {
0000000000000000000000000000000000000000;;			i := b.region.index(strings.ToUpper(string(m[1])))
0000000000000000000000000000000000000000;;			regionTypes[i] |= ccTLD
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.writeSlice("regionTypes", regionTypes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iso3Set := make(map[string]int)
0000000000000000000000000000000000000000;;		update := func(iso2, iso3 string) {
0000000000000000000000000000000000000000;;			i := regionISO.index(iso2)
0000000000000000000000000000000000000000;;			if j, ok := iso3Set[iso3]; !ok && iso3[0] == iso2[0] {
0000000000000000000000000000000000000000;;				regionISO.s[i] += iso3[1:]
0000000000000000000000000000000000000000;;				iso3Set[iso3] = -1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if ok && j >= 0 {
0000000000000000000000000000000000000000;;					regionISO.s[i] += string([]byte{0, byte(j)})
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					iso3Set[iso3] = len(altRegionISO3)
0000000000000000000000000000000000000000;;					regionISO.s[i] += string([]byte{0, byte(len(altRegionISO3))})
0000000000000000000000000000000000000000;;					altRegionISO3 += iso3
0000000000000000000000000000000000000000;;					altRegionIDs = append(altRegionIDs, uint16(isoOffset+i))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range b.supp.CodeMappings.TerritoryCodes {
0000000000000000000000000000000000000000;;			i := regionISO.index(tc.Type) + isoOffset
0000000000000000000000000000000000000000;;			if d := m49map[i]; d != 0 {
0000000000000000000000000000000000000000;;				log.Panicf("%s found as a duplicate UN.M49 code of %03d", tc.Numeric, d)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m49 := parseM49(tc.Numeric)
0000000000000000000000000000000000000000;;			m49map[i] = m49
0000000000000000000000000000000000000000;;			if r := fromM49map[m49]; r == 0 {
0000000000000000000000000000000000000000;;				fromM49map[m49] = i
0000000000000000000000000000000000000000;;			} else if r != i {
0000000000000000000000000000000000000000;;				dep := b.registry[regionISO.s[r-isoOffset]].deprecated
0000000000000000000000000000000000000000;;				if t := b.registry[tc.Type]; t != nil && dep != "" && (t.deprecated == "" || t.deprecated > dep) {
0000000000000000000000000000000000000000;;					fromM49map[m49] = i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ta := range b.supp.Metadata.Alias.TerritoryAlias {
0000000000000000000000000000000000000000;;			if len(ta.Type) == 3 && ta.Type[0] <= '9' && len(ta.Replacement) == 2 {
0000000000000000000000000000000000000000;;				from := parseM49(ta.Type)
0000000000000000000000000000000000000000;;				if r := fromM49map[from]; r == 0 {
0000000000000000000000000000000000000000;;					fromM49map[from] = regionISO.index(ta.Replacement) + isoOffset
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range b.supp.CodeMappings.TerritoryCodes {
0000000000000000000000000000000000000000;;			if len(tc.Alpha3) == 3 {
0000000000000000000000000000000000000000;;				update(tc.Type, tc.Alpha3)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This entries are not included in territoryCodes. Mostly 3-letter variants
0000000000000000000000000000000000000000;;		// of deleted codes and an entry for QU.
0000000000000000000000000000000000000000;;		for _, m := range []struct{ iso2, iso3 string }{
0000000000000000000000000000000000000000;;			{"CT", "CTE"},
0000000000000000000000000000000000000000;;			{"DY", "DHY"},
0000000000000000000000000000000000000000;;			{"HV", "HVO"},
0000000000000000000000000000000000000000;;			{"JT", "JTN"},
0000000000000000000000000000000000000000;;			{"MI", "MID"},
0000000000000000000000000000000000000000;;			{"NH", "NHB"},
0000000000000000000000000000000000000000;;			{"NQ", "ATN"},
0000000000000000000000000000000000000000;;			{"PC", "PCI"},
0000000000000000000000000000000000000000;;			{"PU", "PUS"},
0000000000000000000000000000000000000000;;			{"PZ", "PCZ"},
0000000000000000000000000000000000000000;;			{"RH", "RHO"},
0000000000000000000000000000000000000000;;			{"VD", "VDR"},
0000000000000000000000000000000000000000;;			{"WK", "WAK"},
0000000000000000000000000000000000000000;;			// These three-letter codes are used for others as well.
0000000000000000000000000000000000000000;;			{"FQ", "ATF"},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			update(m.iso2, m.iso3)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, s := range regionISO.s {
0000000000000000000000000000000000000000;;			if len(s) != 4 {
0000000000000000000000000000000000000000;;				regionISO.s[i] = s + "  "
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeConst("regionISO", tag.Index(regionISO.join()))
0000000000000000000000000000000000000000;;		b.writeConst("altRegionISO3", altRegionISO3)
0000000000000000000000000000000000000000;;		b.writeSlice("altRegionIDs", altRegionIDs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create list of deprecated regions.
0000000000000000000000000000000000000000;;		// TODO: consider inserting SF -> FI. Not included by CLDR, but is the only
0000000000000000000000000000000000000000;;		// Transitionally-reserved mapping not included.
0000000000000000000000000000000000000000;;		regionOldMap := stringSet{}
0000000000000000000000000000000000000000;;		// Include regions in territoryAlias (not all are in the IANA registry!)
0000000000000000000000000000000000000000;;		for _, reg := range b.supp.Metadata.Alias.TerritoryAlias {
0000000000000000000000000000000000000000;;			if len(reg.Type) == 2 && reg.Reason == "deprecated" && len(reg.Replacement) == 2 {
0000000000000000000000000000000000000000;;				regionOldMap.add(reg.Type)
0000000000000000000000000000000000000000;;				regionOldMap.updateLater(reg.Type, reg.Replacement)
0000000000000000000000000000000000000000;;				i, _ := regionISO.find(reg.Type)
0000000000000000000000000000000000000000;;				j, _ := regionISO.find(reg.Replacement)
0000000000000000000000000000000000000000;;				if k := m49map[i+isoOffset]; k == 0 {
0000000000000000000000000000000000000000;;					m49map[i+isoOffset] = m49map[j+isoOffset]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSortedMap("regionOldMap", &regionOldMap, func(s string) uint16 {
0000000000000000000000000000000000000000;;			return uint16(b.region.index(s))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// 3-digit region lookup, groupings.
0000000000000000000000000000000000000000;;		for i := 1; i < isoOffset; i++ {
0000000000000000000000000000000000000000;;			m := parseM49(b.region.s[i])
0000000000000000000000000000000000000000;;			m49map[i] = m
0000000000000000000000000000000000000000;;			fromM49map[m] = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSlice("m49", m49map)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			searchBits = 7
0000000000000000000000000000000000000000;;			regionBits = 9
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if len(m49map) >= 1<<regionBits {
0000000000000000000000000000000000000000;;			log.Fatalf("Maximum number of regions exceeded: %d > %d", len(m49map), 1<<regionBits)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m49Index := [9]int16{}
0000000000000000000000000000000000000000;;		fromM49 := []uint16{}
0000000000000000000000000000000000000000;;		m49 := []int{}
0000000000000000000000000000000000000000;;		for k, _ := range fromM49map {
0000000000000000000000000000000000000000;;			m49 = append(m49, int(k))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Ints(m49)
0000000000000000000000000000000000000000;;		for _, k := range m49[1:] {
0000000000000000000000000000000000000000;;			val := (k & (1<<searchBits - 1)) << regionBits
0000000000000000000000000000000000000000;;			fromM49 = append(fromM49, uint16(val|fromM49map[int16(k)]))
0000000000000000000000000000000000000000;;			m49Index[1:][k>>searchBits] = int16(len(fromM49))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSlice("m49Index", m49Index)
0000000000000000000000000000000000000000;;		b.writeSlice("fromM49", fromM49)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// TODO: put these lists in regionTypes as user data? Could be used for
0000000000000000000000000000000000000000;;		// various optimizations and refinements and could be exposed in the API.
0000000000000000000000000000000000000000;;		iso3166Except = "AC CP DG EA EU FX IC SU TA UK"
0000000000000000000000000000000000000000;;		iso3166Trans  = "AN BU CS NT TP YU ZR" // SF is not in our set of Regions.
0000000000000000000000000000000000000000;;		// DY and RH are actually not deleted, but indeterminately reserved.
0000000000000000000000000000000000000000;;		iso3166DelCLDR = "CT DD DY FQ HV JT MI NH NQ PC PU PZ RH VD WK YD"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		iso3166UserAssgined = 1 << iota
0000000000000000000000000000000000000000;;		ccTLD
0000000000000000000000000000000000000000;;		bcp47Region
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func find(list []string, s string) int {
0000000000000000000000000000000000000000;;		for i, t := range list {
0000000000000000000000000000000000000000;;			if t == s {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeVariants generates per-variant information and creates a map from variant
0000000000000000000000000000000000000000;;	// name to index value. We assign index values such that sorting multiple
0000000000000000000000000000000000000000;;	// variants by index value will result in the correct order.
0000000000000000000000000000000000000000;;	// There are two types of variants: specialized and general. Specialized variants
0000000000000000000000000000000000000000;;	// are only applicable to certain language or language-script pairs. Generalized
0000000000000000000000000000000000000000;;	// variants apply to any language. Generalized variants always sort after
0000000000000000000000000000000000000000;;	// specialized variants.  We will therefore always assign a higher index value
0000000000000000000000000000000000000000;;	// to a generalized variant than any other variant. Generalized variants are
0000000000000000000000000000000000000000;;	// sorted alphabetically among themselves.
0000000000000000000000000000000000000000;;	// Specialized variants may also sort after other specialized variants. Such
0000000000000000000000000000000000000000;;	// variants will be ordered after any of the variants they may follow.
0000000000000000000000000000000000000000;;	// We assume that if a variant x is followed by a variant y, then for any prefix
0000000000000000000000000000000000000000;;	// p of x, p-x is a prefix of y. This allows us to order tags based on the
0000000000000000000000000000000000000000;;	// maximum of the length of any of its prefixes.
0000000000000000000000000000000000000000;;	// TODO: it is possible to define a set of Prefix values on variants such that
0000000000000000000000000000000000000000;;	// a total order cannot be defined to the point that this algorithm breaks.
0000000000000000000000000000000000000000;;	// In other words, we cannot guarantee the same order of variants for the
0000000000000000000000000000000000000000;;	// future using the same algorithm or for non-compliant combinations of
0000000000000000000000000000000000000000;;	// variants. For this reason, consider using simple alphabetic sorting
0000000000000000000000000000000000000000;;	// of variants and ignore Prefix restrictions altogether.
0000000000000000000000000000000000000000;;	func (b *builder) writeVariant() {
0000000000000000000000000000000000000000;;		generalized := stringSet{}
0000000000000000000000000000000000000000;;		specialized := stringSet{}
0000000000000000000000000000000000000000;;		specializedExtend := stringSet{}
0000000000000000000000000000000000000000;;		// Collate the variants by type and check assumptions.
0000000000000000000000000000000000000000;;		for _, v := range b.variant.slice() {
0000000000000000000000000000000000000000;;			e := b.registry[v]
0000000000000000000000000000000000000000;;			if len(e.prefix) == 0 {
0000000000000000000000000000000000000000;;				generalized.add(v)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c := strings.Split(e.prefix[0], "-")
0000000000000000000000000000000000000000;;			hasScriptOrRegion := false
0000000000000000000000000000000000000000;;			if len(c) > 1 {
0000000000000000000000000000000000000000;;				_, hasScriptOrRegion = b.script.find(c[1])
0000000000000000000000000000000000000000;;				if !hasScriptOrRegion {
0000000000000000000000000000000000000000;;					_, hasScriptOrRegion = b.region.find(c[1])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(c) == 1 || len(c) == 2 && hasScriptOrRegion {
0000000000000000000000000000000000000000;;				// Variant is preceded by a language.
0000000000000000000000000000000000000000;;				specialized.add(v)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Variant is preceded by another variant.
0000000000000000000000000000000000000000;;			specializedExtend.add(v)
0000000000000000000000000000000000000000;;			prefix := c[0] + "-"
0000000000000000000000000000000000000000;;			if hasScriptOrRegion {
0000000000000000000000000000000000000000;;				prefix += c[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, p := range e.prefix {
0000000000000000000000000000000000000000;;				// Verify that the prefix minus the last element is a prefix of the
0000000000000000000000000000000000000000;;				// predecessor element.
0000000000000000000000000000000000000000;;				i := strings.LastIndex(p, "-")
0000000000000000000000000000000000000000;;				pred := b.registry[p[i+1:]]
0000000000000000000000000000000000000000;;				if find(pred.prefix, p[:i]) < 0 {
0000000000000000000000000000000000000000;;					log.Fatalf("prefix %q for variant %q not consistent with predecessor spec", p, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// The sorting used below does not work in the general case. It works
0000000000000000000000000000000000000000;;				// if we assume that variants that may be followed by others only have
0000000000000000000000000000000000000000;;				// prefixes of the same length. Verify this.
0000000000000000000000000000000000000000;;				count := strings.Count(p[:i], "-")
0000000000000000000000000000000000000000;;				for _, q := range pred.prefix {
0000000000000000000000000000000000000000;;					if c := strings.Count(q, "-"); c != count {
0000000000000000000000000000000000000000;;						log.Fatalf("variant %q preceding %q has a prefix %q of size %d; want %d", p[i+1:], v, q, c, count)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !strings.HasPrefix(p, prefix) {
0000000000000000000000000000000000000000;;					log.Fatalf("prefix %q of variant %q should start with %q", p, v, prefix)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort extended variants.
0000000000000000000000000000000000000000;;		a := specializedExtend.s
0000000000000000000000000000000000000000;;		less := func(v, w string) bool {
0000000000000000000000000000000000000000;;			// Sort by the maximum number of elements.
0000000000000000000000000000000000000000;;			maxCount := func(s string) (max int) {
0000000000000000000000000000000000000000;;				for _, p := range b.registry[s].prefix {
0000000000000000000000000000000000000000;;					if c := strings.Count(p, "-"); c > max {
0000000000000000000000000000000000000000;;						max = c
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cv, cw := maxCount(v), maxCount(w); cv != cw {
0000000000000000000000000000000000000000;;				return cv < cw
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Sort by name as tie breaker.
0000000000000000000000000000000000000000;;			return v < w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(funcSorter{less, sort.StringSlice(a)})
0000000000000000000000000000000000000000;;		specializedExtend.frozen = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create index from variant name to index.
0000000000000000000000000000000000000000;;		variantIndex := make(map[string]uint8)
0000000000000000000000000000000000000000;;		add := func(s []string) {
0000000000000000000000000000000000000000;;			for _, v := range s {
0000000000000000000000000000000000000000;;				variantIndex[v] = uint8(len(variantIndex))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		add(specialized.slice())
0000000000000000000000000000000000000000;;		add(specializedExtend.s)
0000000000000000000000000000000000000000;;		numSpecialized := len(variantIndex)
0000000000000000000000000000000000000000;;		add(generalized.slice())
0000000000000000000000000000000000000000;;		if n := len(variantIndex); n > 255 {
0000000000000000000000000000000000000000;;			log.Fatalf("maximum number of variants exceeded: was %d; want <= 255", n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeMap("variantIndex", variantIndex)
0000000000000000000000000000000000000000;;		b.writeConst("variantNumSpecialized", numSpecialized)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeLanguageInfo() {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeLikelyData writes tables that are used both for finding parent relations and for
0000000000000000000000000000000000000000;;	// language matching.  Each entry contains additional bits to indicate the status of the
0000000000000000000000000000000000000000;;	// data to know when it cannot be used for parent relations.
0000000000000000000000000000000000000000;;	func (b *builder) writeLikelyData() {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			isList = 1 << iota
0000000000000000000000000000000000000000;;			scriptInFrom
0000000000000000000000000000000000000000;;			regionInFrom
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		type ( // generated types
0000000000000000000000000000000000000000;;			likelyScriptRegion struct {
0000000000000000000000000000000000000000;;				region uint16
0000000000000000000000000000000000000000;;				script uint8
0000000000000000000000000000000000000000;;				flags  uint8
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			likelyLangScript struct {
0000000000000000000000000000000000000000;;				lang   uint16
0000000000000000000000000000000000000000;;				script uint8
0000000000000000000000000000000000000000;;				flags  uint8
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			likelyLangRegion struct {
0000000000000000000000000000000000000000;;				lang   uint16
0000000000000000000000000000000000000000;;				region uint16
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// likelyTag is used for getting likely tags for group regions, where
0000000000000000000000000000000000000000;;			// the likely region might be a region contained in the group.
0000000000000000000000000000000000000000;;			likelyTag struct {
0000000000000000000000000000000000000000;;				lang   uint16
0000000000000000000000000000000000000000;;				region uint16
0000000000000000000000000000000000000000;;				script uint8
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		var ( // generated variables
0000000000000000000000000000000000000000;;			likelyRegionGroup = make([]likelyTag, len(b.groups))
0000000000000000000000000000000000000000;;			likelyLang        = make([]likelyScriptRegion, len(b.lang.s))
0000000000000000000000000000000000000000;;			likelyRegion      = make([]likelyLangScript, len(b.region.s))
0000000000000000000000000000000000000000;;			likelyScript      = make([]likelyLangRegion, len(b.script.s))
0000000000000000000000000000000000000000;;			likelyLangList    = []likelyScriptRegion{}
0000000000000000000000000000000000000000;;			likelyRegionList  = []likelyLangScript{}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		type fromTo struct {
0000000000000000000000000000000000000000;;			from, to []string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		langToOther := map[int][]fromTo{}
0000000000000000000000000000000000000000;;		regionToOther := map[int][]fromTo{}
0000000000000000000000000000000000000000;;		for _, m := range b.supp.LikelySubtags.LikelySubtag {
0000000000000000000000000000000000000000;;			from := strings.Split(m.From, "_")
0000000000000000000000000000000000000000;;			to := strings.Split(m.To, "_")
0000000000000000000000000000000000000000;;			if len(to) != 3 {
0000000000000000000000000000000000000000;;				log.Fatalf("invalid number of subtags in %q: found %d, want 3", m.To, len(to))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(from) > 3 {
0000000000000000000000000000000000000000;;				log.Fatalf("invalid number of subtags: found %d, want 1-3", len(from))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if from[0] != to[0] && from[0] != "und" {
0000000000000000000000000000000000000000;;				log.Fatalf("unexpected language change in expansion: %s -> %s", from, to)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(from) == 3 {
0000000000000000000000000000000000000000;;				if from[2] != to[2] {
0000000000000000000000000000000000000000;;					log.Fatalf("unexpected region change in expansion: %s -> %s", from, to)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if from[0] != "und" {
0000000000000000000000000000000000000000;;					log.Fatalf("unexpected fully specified from tag: %s -> %s", from, to)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(from) == 1 || from[0] != "und" {
0000000000000000000000000000000000000000;;				id := 0
0000000000000000000000000000000000000000;;				if from[0] != "und" {
0000000000000000000000000000000000000000;;					id = b.lang.index(from[0])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				langToOther[id] = append(langToOther[id], fromTo{from, to})
0000000000000000000000000000000000000000;;			} else if len(from) == 2 && len(from[1]) == 4 {
0000000000000000000000000000000000000000;;				sid := b.script.index(from[1])
0000000000000000000000000000000000000000;;				likelyScript[sid].lang = uint16(b.langIndex(to[0]))
0000000000000000000000000000000000000000;;				likelyScript[sid].region = uint16(b.region.index(to[2]))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r := b.region.index(from[len(from)-1])
0000000000000000000000000000000000000000;;				if id, ok := b.groups[r]; ok {
0000000000000000000000000000000000000000;;					if from[0] != "und" {
0000000000000000000000000000000000000000;;						log.Fatalf("region changed unexpectedly: %s -> %s", from, to)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					likelyRegionGroup[id].lang = uint16(b.langIndex(to[0]))
0000000000000000000000000000000000000000;;					likelyRegionGroup[id].script = uint8(b.script.index(to[1]))
0000000000000000000000000000000000000000;;					likelyRegionGroup[id].region = uint16(b.region.index(to[2]))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					regionToOther[r] = append(regionToOther[r], fromTo{from, to})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeType(likelyLangRegion{})
0000000000000000000000000000000000000000;;		b.writeSlice("likelyScript", likelyScript)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for id := range b.lang.s {
0000000000000000000000000000000000000000;;			list := langToOther[id]
0000000000000000000000000000000000000000;;			if len(list) == 1 {
0000000000000000000000000000000000000000;;				likelyLang[id].region = uint16(b.region.index(list[0].to[2]))
0000000000000000000000000000000000000000;;				likelyLang[id].script = uint8(b.script.index(list[0].to[1]))
0000000000000000000000000000000000000000;;			} else if len(list) > 1 {
0000000000000000000000000000000000000000;;				likelyLang[id].flags = isList
0000000000000000000000000000000000000000;;				likelyLang[id].region = uint16(len(likelyLangList))
0000000000000000000000000000000000000000;;				likelyLang[id].script = uint8(len(list))
0000000000000000000000000000000000000000;;				for _, x := range list {
0000000000000000000000000000000000000000;;					flags := uint8(0)
0000000000000000000000000000000000000000;;					if len(x.from) > 1 {
0000000000000000000000000000000000000000;;						if x.from[1] == x.to[2] {
0000000000000000000000000000000000000000;;							flags = regionInFrom
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							flags = scriptInFrom
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					likelyLangList = append(likelyLangList, likelyScriptRegion{
0000000000000000000000000000000000000000;;						region: uint16(b.region.index(x.to[2])),
0000000000000000000000000000000000000000;;						script: uint8(b.script.index(x.to[1])),
0000000000000000000000000000000000000000;;						flags:  flags,
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: merge suppressScript data with this table.
0000000000000000000000000000000000000000;;		b.writeType(likelyScriptRegion{})
0000000000000000000000000000000000000000;;		b.writeSlice("likelyLang", likelyLang)
0000000000000000000000000000000000000000;;		b.writeSlice("likelyLangList", likelyLangList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for id := range b.region.s {
0000000000000000000000000000000000000000;;			list := regionToOther[id]
0000000000000000000000000000000000000000;;			if len(list) == 1 {
0000000000000000000000000000000000000000;;				likelyRegion[id].lang = uint16(b.langIndex(list[0].to[0]))
0000000000000000000000000000000000000000;;				likelyRegion[id].script = uint8(b.script.index(list[0].to[1]))
0000000000000000000000000000000000000000;;				if len(list[0].from) > 2 {
0000000000000000000000000000000000000000;;					likelyRegion[id].flags = scriptInFrom
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if len(list) > 1 {
0000000000000000000000000000000000000000;;				likelyRegion[id].flags = isList
0000000000000000000000000000000000000000;;				likelyRegion[id].lang = uint16(len(likelyRegionList))
0000000000000000000000000000000000000000;;				likelyRegion[id].script = uint8(len(list))
0000000000000000000000000000000000000000;;				for i, x := range list {
0000000000000000000000000000000000000000;;					if len(x.from) == 2 && i != 0 || i > 0 && len(x.from) != 3 {
0000000000000000000000000000000000000000;;						log.Fatalf("unspecified script must be first in list: %v at %d", x.from, i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					x := likelyLangScript{
0000000000000000000000000000000000000000;;						lang:   uint16(b.langIndex(x.to[0])),
0000000000000000000000000000000000000000;;						script: uint8(b.script.index(x.to[1])),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(list[0].from) > 2 {
0000000000000000000000000000000000000000;;						x.flags = scriptInFrom
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					likelyRegionList = append(likelyRegionList, x)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeType(likelyLangScript{})
0000000000000000000000000000000000000000;;		b.writeSlice("likelyRegion", likelyRegion)
0000000000000000000000000000000000000000;;		b.writeSlice("likelyRegionList", likelyRegionList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.writeType(likelyTag{})
0000000000000000000000000000000000000000;;		b.writeSlice("likelyRegionGroup", likelyRegionGroup)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mutualIntelligibility struct {
0000000000000000000000000000000000000000;;		want, have uint16
0000000000000000000000000000000000000000;;		conf       uint8
0000000000000000000000000000000000000000;;		oneway     bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type scriptIntelligibility struct {
0000000000000000000000000000000000000000;;		lang       uint16 // langID or 0 if *
0000000000000000000000000000000000000000;;		want, have uint8
0000000000000000000000000000000000000000;;		conf       uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortByConf []mutualIntelligibility
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l sortByConf) Less(a, b int) bool {
0000000000000000000000000000000000000000;;		return l[a].conf > l[b].conf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l sortByConf) Swap(a, b int) {
0000000000000000000000000000000000000000;;		l[a], l[b] = l[b], l[a]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l sortByConf) Len() int {
0000000000000000000000000000000000000000;;		return len(l)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toConf converts a percentage value [0, 100] to a confidence class.
0000000000000000000000000000000000000000;;	func toConf(pct uint8) uint8 {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case pct == 100:
0000000000000000000000000000000000000000;;			return 3 // Exact
0000000000000000000000000000000000000000;;		case pct >= 90:
0000000000000000000000000000000000000000;;			return 2 // High
0000000000000000000000000000000000000000;;		case pct > 50:
0000000000000000000000000000000000000000;;			return 1 // Low
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0 // No
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeMatchData writes tables with languages and scripts for which there is
0000000000000000000000000000000000000000;;	// mutual intelligibility. The data is based on CLDR's languageMatching data.
0000000000000000000000000000000000000000;;	// Note that we use a different algorithm than the one defined by CLDR and that
0000000000000000000000000000000000000000;;	// we slightly modify the data. For example, we convert scores to confidence levels.
0000000000000000000000000000000000000000;;	// We also drop all region-related data as we use a different algorithm to
0000000000000000000000000000000000000000;;	// determine region equivalence.
0000000000000000000000000000000000000000;;	func (b *builder) writeMatchData() {
0000000000000000000000000000000000000000;;		b.writeType(mutualIntelligibility{})
0000000000000000000000000000000000000000;;		b.writeType(scriptIntelligibility{})
0000000000000000000000000000000000000000;;		lm := b.supp.LanguageMatching.LanguageMatches
0000000000000000000000000000000000000000;;		cldr.MakeSlice(&lm).SelectAnyOf("type", "written")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		matchLang := []mutualIntelligibility{}
0000000000000000000000000000000000000000;;		matchScript := []scriptIntelligibility{}
0000000000000000000000000000000000000000;;		// Convert the languageMatch entries in lists keyed by desired language.
0000000000000000000000000000000000000000;;		for _, m := range lm[0].LanguageMatch {
0000000000000000000000000000000000000000;;			// Different versions of CLDR use different separators.
0000000000000000000000000000000000000000;;			desired := strings.Replace(m.Desired, "-", "_", -1)
0000000000000000000000000000000000000000;;			supported := strings.Replace(m.Supported, "-", "_", -1)
0000000000000000000000000000000000000000;;			d := strings.Split(desired, "_")
0000000000000000000000000000000000000000;;			s := strings.Split(supported, "_")
0000000000000000000000000000000000000000;;			if len(d) != len(s) || len(d) > 2 {
0000000000000000000000000000000000000000;;				// Skip all entries with regions and work around CLDR bug.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pct, _ := strconv.ParseInt(m.Percent, 10, 8)
0000000000000000000000000000000000000000;;			if len(d) == 2 && d[0] == s[0] && len(d[1]) == 4 {
0000000000000000000000000000000000000000;;				// language-script pair.
0000000000000000000000000000000000000000;;				lang := uint16(0)
0000000000000000000000000000000000000000;;				if d[0] != "*" {
0000000000000000000000000000000000000000;;					lang = uint16(b.langIndex(d[0]))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				matchScript = append(matchScript, scriptIntelligibility{
0000000000000000000000000000000000000000;;					lang: lang,
0000000000000000000000000000000000000000;;					want: uint8(b.script.index(d[1])),
0000000000000000000000000000000000000000;;					have: uint8(b.script.index(s[1])),
0000000000000000000000000000000000000000;;					conf: toConf(uint8(pct)),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				if m.Oneway != "true" {
0000000000000000000000000000000000000000;;					matchScript = append(matchScript, scriptIntelligibility{
0000000000000000000000000000000000000000;;						lang: lang,
0000000000000000000000000000000000000000;;						want: uint8(b.script.index(s[1])),
0000000000000000000000000000000000000000;;						have: uint8(b.script.index(d[1])),
0000000000000000000000000000000000000000;;						conf: toConf(uint8(pct)),
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if len(d) == 1 && d[0] != "*" {
0000000000000000000000000000000000000000;;				if pct == 100 {
0000000000000000000000000000000000000000;;					// nb == no is already handled by macro mapping. Check there
0000000000000000000000000000000000000000;;					// really is only this case.
0000000000000000000000000000000000000000;;					if d[0] != "no" || s[0] != "nb" {
0000000000000000000000000000000000000000;;						log.Fatalf("unhandled equivalence %s == %s", s[0], d[0])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				matchLang = append(matchLang, mutualIntelligibility{
0000000000000000000000000000000000000000;;					want:   uint16(b.langIndex(d[0])),
0000000000000000000000000000000000000000;;					have:   uint16(b.langIndex(s[0])),
0000000000000000000000000000000000000000;;					conf:   uint8(pct),
0000000000000000000000000000000000000000;;					oneway: m.Oneway == "true",
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// TODO: Handle other mappings.
0000000000000000000000000000000000000000;;				a := []string{"*;*", "*_*;*_*", "es_MX;es_419"}
0000000000000000000000000000000000000000;;				s := strings.Join([]string{desired, supported}, ";")
0000000000000000000000000000000000000000;;				if i := sort.SearchStrings(a, s); i == len(a) || a[i] != s {
0000000000000000000000000000000000000000;;					log.Printf("%q not handled", s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Stable(sortByConf(matchLang))
0000000000000000000000000000000000000000;;		// collapse percentage into confidence classes
0000000000000000000000000000000000000000;;		for i, m := range matchLang {
0000000000000000000000000000000000000000;;			matchLang[i].conf = toConf(m.conf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSlice("matchLang", matchLang)
0000000000000000000000000000000000000000;;		b.writeSlice("matchScript", matchScript)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeRegionInclusionData() {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			// mm holds for each group the set of groups with a distance of 1.
0000000000000000000000000000000000000000;;			mm = make(map[int][]index)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// containment holds for each group the transitive closure of
0000000000000000000000000000000000000000;;			// containment of other groups.
0000000000000000000000000000000000000000;;			containment = make(map[index][]index)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for _, g := range b.supp.TerritoryContainment.Group {
0000000000000000000000000000000000000000;;			group := b.region.index(g.Type)
0000000000000000000000000000000000000000;;			groupIdx := b.groups[group]
0000000000000000000000000000000000000000;;			for _, mem := range strings.Split(g.Contains, " ") {
0000000000000000000000000000000000000000;;				r := b.region.index(mem)
0000000000000000000000000000000000000000;;				mm[r] = append(mm[r], groupIdx)
0000000000000000000000000000000000000000;;				if g, ok := b.groups[r]; ok {
0000000000000000000000000000000000000000;;					mm[group] = append(mm[group], g)
0000000000000000000000000000000000000000;;					containment[groupIdx] = append(containment[groupIdx], g)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		regionContainment := make([]uint32, len(b.groups))
0000000000000000000000000000000000000000;;		for _, g := range b.groups {
0000000000000000000000000000000000000000;;			l := containment[g]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Compute the transitive closure of containment.
0000000000000000000000000000000000000000;;			for i := 0; i < len(l); i++ {
0000000000000000000000000000000000000000;;				l = append(l, containment[l[i]]...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Compute the bitmask.
0000000000000000000000000000000000000000;;			regionContainment[g] = 1 << g
0000000000000000000000000000000000000000;;			for _, v := range l {
0000000000000000000000000000000000000000;;				regionContainment[g] |= 1 << v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// log.Printf("%d: %X", g, regionContainment[g])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSlice("regionContainment", regionContainment)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		regionInclusion := make([]uint8, len(b.region.s))
0000000000000000000000000000000000000000;;		bvs := make(map[uint32]index)
0000000000000000000000000000000000000000;;		// Make the first bitvector positions correspond with the groups.
0000000000000000000000000000000000000000;;		for r, i := range b.groups {
0000000000000000000000000000000000000000;;			bv := uint32(1 << i)
0000000000000000000000000000000000000000;;			for _, g := range mm[r] {
0000000000000000000000000000000000000000;;				bv |= 1 << g
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bvs[bv] = i
0000000000000000000000000000000000000000;;			regionInclusion[r] = uint8(bvs[bv])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for r := 1; r < len(b.region.s); r++ {
0000000000000000000000000000000000000000;;			if _, ok := b.groups[r]; !ok {
0000000000000000000000000000000000000000;;				bv := uint32(0)
0000000000000000000000000000000000000000;;				for _, g := range mm[r] {
0000000000000000000000000000000000000000;;					bv |= 1 << g
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if bv == 0 {
0000000000000000000000000000000000000000;;					// Pick the world for unspecified regions.
0000000000000000000000000000000000000000;;					bv = 1 << b.groups[b.region.index("001")]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok := bvs[bv]; !ok {
0000000000000000000000000000000000000000;;					bvs[bv] = index(len(bvs))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				regionInclusion[r] = uint8(bvs[bv])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSlice("regionInclusion", regionInclusion)
0000000000000000000000000000000000000000;;		regionInclusionBits := make([]uint32, len(bvs))
0000000000000000000000000000000000000000;;		for k, v := range bvs {
0000000000000000000000000000000000000000;;			regionInclusionBits[v] = uint32(k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add bit vectors for increasingly large distances until a fixed point is reached.
0000000000000000000000000000000000000000;;		regionInclusionNext := []uint8{}
0000000000000000000000000000000000000000;;		for i := 0; i < len(regionInclusionBits); i++ {
0000000000000000000000000000000000000000;;			bits := regionInclusionBits[i]
0000000000000000000000000000000000000000;;			next := bits
0000000000000000000000000000000000000000;;			for i := uint(0); i < uint(len(b.groups)); i++ {
0000000000000000000000000000000000000000;;				if bits&(1<<i) != 0 {
0000000000000000000000000000000000000000;;					next |= regionInclusionBits[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := bvs[next]; !ok {
0000000000000000000000000000000000000000;;				bvs[next] = index(len(bvs))
0000000000000000000000000000000000000000;;				regionInclusionBits = append(regionInclusionBits, next)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			regionInclusionNext = append(regionInclusionNext, uint8(bvs[next]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSlice("regionInclusionBits", regionInclusionBits)
0000000000000000000000000000000000000000;;		b.writeSlice("regionInclusionNext", regionInclusionNext)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type parentRel struct {
0000000000000000000000000000000000000000;;		lang       uint16
0000000000000000000000000000000000000000;;		script     uint8
0000000000000000000000000000000000000000;;		maxScript  uint8
0000000000000000000000000000000000000000;;		toRegion   uint16
0000000000000000000000000000000000000000;;		fromRegion []uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) writeParents() {
0000000000000000000000000000000000000000;;		b.writeType(parentRel{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parents := []parentRel{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Construct parent overrides.
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		for _, p := range b.data.Supplemental().ParentLocales.ParentLocale {
0000000000000000000000000000000000000000;;			// Skipping non-standard scripts to root is implemented using addTags.
0000000000000000000000000000000000000000;;			if p.Parent == "root" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sub := strings.Split(p.Parent, "_")
0000000000000000000000000000000000000000;;			parent := parentRel{lang: b.langIndex(sub[0])}
0000000000000000000000000000000000000000;;			if len(sub) == 2 {
0000000000000000000000000000000000000000;;				// TODO: check that all undefined scripts are indeed Latn in these
0000000000000000000000000000000000000000;;				// cases.
0000000000000000000000000000000000000000;;				parent.maxScript = uint8(b.script.index("Latn"))
0000000000000000000000000000000000000000;;				parent.toRegion = uint16(b.region.index(sub[1]))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				parent.script = uint8(b.script.index(sub[1]))
0000000000000000000000000000000000000000;;				parent.maxScript = parent.script
0000000000000000000000000000000000000000;;				parent.toRegion = uint16(b.region.index(sub[2]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range strings.Split(p.Locales, " ") {
0000000000000000000000000000000000000000;;				region := b.region.index(c[strings.LastIndex(c, "_")+1:])
0000000000000000000000000000000000000000;;				parent.fromRegion = append(parent.fromRegion, uint16(region))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parents = append(parents, parent)
0000000000000000000000000000000000000000;;			n += len(parent.fromRegion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.writeSliceAddSize("parents", n*2, parents)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		gen.Init()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gen.Repackage("gen_common.go", "common.go", "language")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := gen.NewCodeWriter()
0000000000000000000000000000000000000000;;		defer w.WriteGoFile("tables.go", "language")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, `import "golang.org/x/text/internal/tag"`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := newBuilder(w)
0000000000000000000000000000000000000000;;		gen.WriteCLDRVersion(w)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.parseIndices()
0000000000000000000000000000000000000000;;		b.writeType(fromTo{})
0000000000000000000000000000000000000000;;		b.writeLanguage()
0000000000000000000000000000000000000000;;		b.writeScript()
0000000000000000000000000000000000000000;;		b.writeRegion()
0000000000000000000000000000000000000000;;		b.writeVariant()
0000000000000000000000000000000000000000;;		// TODO: b.writeLocale()
0000000000000000000000000000000000000000;;		b.computeRegionGroups()
0000000000000000000000000000000000000000;;		b.writeLikelyData()
0000000000000000000000000000000000000000;;		b.writeMatchData()
0000000000000000000000000000000000000000;;		b.writeRegionInclusionData()
0000000000000000000000000000000000000000;;		b.writeParents()
0000000000000000000000000000000000000000;;	}
