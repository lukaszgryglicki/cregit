0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package language
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/tag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isAlpha returns true if the byte is not a digit.
0000000000000000000000000000000000000000;;	// b must be an ASCII letter or digit.
0000000000000000000000000000000000000000;;	func isAlpha(b byte) bool {
0000000000000000000000000000000000000000;;		return b > '9'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isAlphaNum returns true if the string contains only ASCII letters or digits.
0000000000000000000000000000000000000000;;	func isAlphaNum(s []byte) bool {
0000000000000000000000000000000000000000;;		for _, c := range s {
0000000000000000000000000000000000000000;;			if !('a' <= c && c <= 'z' || 'A' <= c && c <= 'Z' || '0' <= c && c <= '9') {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errSyntax is returned by any of the parsing functions when the
0000000000000000000000000000000000000000;;	// input is not well-formed, according to BCP 47.
0000000000000000000000000000000000000000;;	// TODO: return the position at which the syntax error occurred?
0000000000000000000000000000000000000000;;	var errSyntax = errors.New("language: tag is not well-formed")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValueError is returned by any of the parsing functions when the
0000000000000000000000000000000000000000;;	// input is well-formed but the respective subtag is not recognized
0000000000000000000000000000000000000000;;	// as a valid value.
0000000000000000000000000000000000000000;;	type ValueError struct {
0000000000000000000000000000000000000000;;		v [8]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mkErrInvalid(s []byte) error {
0000000000000000000000000000000000000000;;		var e ValueError
0000000000000000000000000000000000000000;;		copy(e.v[:], s)
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e ValueError) tag() []byte {
0000000000000000000000000000000000000000;;		n := bytes.IndexByte(e.v[:], 0)
0000000000000000000000000000000000000000;;		if n == -1 {
0000000000000000000000000000000000000000;;			n = 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.v[:n]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error implements the error interface.
0000000000000000000000000000000000000000;;	func (e ValueError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("language: subtag %q is well-formed but unknown", e.tag())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Subtag returns the subtag for which the error occurred.
0000000000000000000000000000000000000000;;	func (e ValueError) Subtag() string {
0000000000000000000000000000000000000000;;		return string(e.tag())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanner is used to scan BCP 47 tokens, which are separated by _ or -.
0000000000000000000000000000000000000000;;	type scanner struct {
0000000000000000000000000000000000000000;;		b     []byte
0000000000000000000000000000000000000000;;		bytes [max99thPercentileSize]byte
0000000000000000000000000000000000000000;;		token []byte
0000000000000000000000000000000000000000;;		start int // start position of the current token
0000000000000000000000000000000000000000;;		end   int // end position of the current token
0000000000000000000000000000000000000000;;		next  int // next point for scan
0000000000000000000000000000000000000000;;		err   error
0000000000000000000000000000000000000000;;		done  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeScannerString(s string) scanner {
0000000000000000000000000000000000000000;;		scan := scanner{}
0000000000000000000000000000000000000000;;		if len(s) <= len(scan.bytes) {
0000000000000000000000000000000000000000;;			scan.b = scan.bytes[:copy(scan.bytes[:], s)]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			scan.b = []byte(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scan.init()
0000000000000000000000000000000000000000;;		return scan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeScanner returns a scanner using b as the input buffer.
0000000000000000000000000000000000000000;;	// b is not copied and may be modified by the scanner routines.
0000000000000000000000000000000000000000;;	func makeScanner(b []byte) scanner {
0000000000000000000000000000000000000000;;		scan := scanner{b: b}
0000000000000000000000000000000000000000;;		scan.init()
0000000000000000000000000000000000000000;;		return scan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *scanner) init() {
0000000000000000000000000000000000000000;;		for i, c := range s.b {
0000000000000000000000000000000000000000;;			if c == '_' {
0000000000000000000000000000000000000000;;				s.b[i] = '-'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.scan()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// restToLower converts the string between start and end to lower case.
0000000000000000000000000000000000000000;;	func (s *scanner) toLower(start, end int) {
0000000000000000000000000000000000000000;;		for i := start; i < end; i++ {
0000000000000000000000000000000000000000;;			c := s.b[i]
0000000000000000000000000000000000000000;;			if 'A' <= c && c <= 'Z' {
0000000000000000000000000000000000000000;;				s.b[i] += 'a' - 'A'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *scanner) setError(e error) {
0000000000000000000000000000000000000000;;		if s.err == nil || (e == errSyntax && s.err != errSyntax) {
0000000000000000000000000000000000000000;;			s.err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resizeRange shrinks or grows the array at position oldStart such that
0000000000000000000000000000000000000000;;	// a new string of size newSize can fit between oldStart and oldEnd.
0000000000000000000000000000000000000000;;	// Sets the scan point to after the resized range.
0000000000000000000000000000000000000000;;	func (s *scanner) resizeRange(oldStart, oldEnd, newSize int) {
0000000000000000000000000000000000000000;;		s.start = oldStart
0000000000000000000000000000000000000000;;		if end := oldStart + newSize; end != oldEnd {
0000000000000000000000000000000000000000;;			diff := end - oldEnd
0000000000000000000000000000000000000000;;			if end < cap(s.b) {
0000000000000000000000000000000000000000;;				b := make([]byte, len(s.b)+diff)
0000000000000000000000000000000000000000;;				copy(b, s.b[:oldStart])
0000000000000000000000000000000000000000;;				copy(b[end:], s.b[oldEnd:])
0000000000000000000000000000000000000000;;				s.b = b
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s.b = append(s.b[end:], s.b[oldEnd:]...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.next = end + (s.next - s.end)
0000000000000000000000000000000000000000;;			s.end = end
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// replace replaces the current token with repl.
0000000000000000000000000000000000000000;;	func (s *scanner) replace(repl string) {
0000000000000000000000000000000000000000;;		s.resizeRange(s.start, s.end, len(repl))
0000000000000000000000000000000000000000;;		copy(s.b[s.start:], repl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gobble removes the current token from the input.
0000000000000000000000000000000000000000;;	// Caller must call scan after calling gobble.
0000000000000000000000000000000000000000;;	func (s *scanner) gobble(e error) {
0000000000000000000000000000000000000000;;		s.setError(e)
0000000000000000000000000000000000000000;;		if s.start == 0 {
0000000000000000000000000000000000000000;;			s.b = s.b[:+copy(s.b, s.b[s.next:])]
0000000000000000000000000000000000000000;;			s.end = 0
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.b = s.b[:s.start-1+copy(s.b[s.start-1:], s.b[s.end:])]
0000000000000000000000000000000000000000;;			s.end = s.start - 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.next = s.start
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteRange removes the given range from s.b before the current token.
0000000000000000000000000000000000000000;;	func (s *scanner) deleteRange(start, end int) {
0000000000000000000000000000000000000000;;		s.setError(errSyntax)
0000000000000000000000000000000000000000;;		s.b = s.b[:start+copy(s.b[start:], s.b[end:])]
0000000000000000000000000000000000000000;;		diff := end - start
0000000000000000000000000000000000000000;;		s.next -= diff
0000000000000000000000000000000000000000;;		s.start -= diff
0000000000000000000000000000000000000000;;		s.end -= diff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scan parses the next token of a BCP 47 string.  Tokens that are larger
0000000000000000000000000000000000000000;;	// than 8 characters or include non-alphanumeric characters result in an error
0000000000000000000000000000000000000000;;	// and are gobbled and removed from the output.
0000000000000000000000000000000000000000;;	// It returns the end position of the last token consumed.
0000000000000000000000000000000000000000;;	func (s *scanner) scan() (end int) {
0000000000000000000000000000000000000000;;		end = s.end
0000000000000000000000000000000000000000;;		s.token = nil
0000000000000000000000000000000000000000;;		for s.start = s.next; s.next < len(s.b); {
0000000000000000000000000000000000000000;;			i := bytes.IndexByte(s.b[s.next:], '-')
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				s.end = len(s.b)
0000000000000000000000000000000000000000;;				s.next = len(s.b)
0000000000000000000000000000000000000000;;				i = s.end - s.start
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s.end = s.next + i
0000000000000000000000000000000000000000;;				s.next = s.end + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			token := s.b[s.start:s.end]
0000000000000000000000000000000000000000;;			if i < 1 || i > 8 || !isAlphaNum(token) {
0000000000000000000000000000000000000000;;				s.gobble(errSyntax)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.token = token
0000000000000000000000000000000000000000;;			return end
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n := len(s.b); n > 0 && s.b[n-1] == '-' {
0000000000000000000000000000000000000000;;			s.setError(errSyntax)
0000000000000000000000000000000000000000;;			s.b = s.b[:len(s.b)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.done = true
0000000000000000000000000000000000000000;;		return end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// acceptMinSize parses multiple tokens of the given size or greater.
0000000000000000000000000000000000000000;;	// It returns the end position of the last token consumed.
0000000000000000000000000000000000000000;;	func (s *scanner) acceptMinSize(min int) (end int) {
0000000000000000000000000000000000000000;;		end = s.end
0000000000000000000000000000000000000000;;		s.scan()
0000000000000000000000000000000000000000;;		for ; len(s.token) >= min; s.scan() {
0000000000000000000000000000000000000000;;			end = s.end
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse parses the given BCP 47 string and returns a valid Tag. If parsing
0000000000000000000000000000000000000000;;	// failed it returns an error and any part of the tag that could be parsed.
0000000000000000000000000000000000000000;;	// If parsing succeeded but an unknown value was found, it returns
0000000000000000000000000000000000000000;;	// ValueError. The Tag returned in this case is just stripped of the unknown
0000000000000000000000000000000000000000;;	// value. All other values are preserved. It accepts tags in the BCP 47 format
0000000000000000000000000000000000000000;;	// and extensions to this standard defined in
0000000000000000000000000000000000000000;;	// http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
0000000000000000000000000000000000000000;;	// The resulting tag is canonicalized using the default canonicalization type.
0000000000000000000000000000000000000000;;	func Parse(s string) (t Tag, err error) {
0000000000000000000000000000000000000000;;		return Default.Parse(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse parses the given BCP 47 string and returns a valid Tag. If parsing
0000000000000000000000000000000000000000;;	// failed it returns an error and any part of the tag that could be parsed.
0000000000000000000000000000000000000000;;	// If parsing succeeded but an unknown value was found, it returns
0000000000000000000000000000000000000000;;	// ValueError. The Tag returned in this case is just stripped of the unknown
0000000000000000000000000000000000000000;;	// value. All other values are preserved. It accepts tags in the BCP 47 format
0000000000000000000000000000000000000000;;	// and extensions to this standard defined in
0000000000000000000000000000000000000000;;	// http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
0000000000000000000000000000000000000000;;	// The resulting tag is canonicalized using the the canonicalization type c.
0000000000000000000000000000000000000000;;	func (c CanonType) Parse(s string) (t Tag, err error) {
0000000000000000000000000000000000000000;;		// TODO: consider supporting old-style locale key-value pairs.
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return und, errSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s) <= maxAltTaglen {
0000000000000000000000000000000000000000;;			b := [maxAltTaglen]byte{}
0000000000000000000000000000000000000000;;			for i, c := range s {
0000000000000000000000000000000000000000;;				// Generating invalid UTF-8 is okay as it won't match.
0000000000000000000000000000000000000000;;				if 'A' <= c && c <= 'Z' {
0000000000000000000000000000000000000000;;					c += 'a' - 'A'
0000000000000000000000000000000000000000;;				} else if c == '_' {
0000000000000000000000000000000000000000;;					c = '-'
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b[i] = byte(c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t, ok := grandfathered(b); ok {
0000000000000000000000000000000000000000;;				return t, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scan := makeScannerString(s)
0000000000000000000000000000000000000000;;		t, err = parse(&scan, s)
0000000000000000000000000000000000000000;;		t, changed := t.canonicalize(c)
0000000000000000000000000000000000000000;;		if changed {
0000000000000000000000000000000000000000;;			t.remakeString()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parse(scan *scanner, s string) (t Tag, err error) {
0000000000000000000000000000000000000000;;		t = und
0000000000000000000000000000000000000000;;		var end int
0000000000000000000000000000000000000000;;		if n := len(scan.token); n <= 1 {
0000000000000000000000000000000000000000;;			scan.toLower(0, len(scan.b))
0000000000000000000000000000000000000000;;			if n == 0 || scan.token[0] != 'x' {
0000000000000000000000000000000000000000;;				return t, errSyntax
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			end = parseExtensions(scan)
0000000000000000000000000000000000000000;;		} else if n >= 4 {
0000000000000000000000000000000000000000;;			return und, errSyntax
0000000000000000000000000000000000000000;;		} else { // the usual case
0000000000000000000000000000000000000000;;			t, end = parseTag(scan)
0000000000000000000000000000000000000000;;			if n := len(scan.token); n == 1 {
0000000000000000000000000000000000000000;;				t.pExt = uint16(end)
0000000000000000000000000000000000000000;;				end = parseExtensions(scan)
0000000000000000000000000000000000000000;;			} else if end < len(scan.b) {
0000000000000000000000000000000000000000;;				scan.setError(errSyntax)
0000000000000000000000000000000000000000;;				scan.b = scan.b[:end]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if int(t.pVariant) < len(scan.b) {
0000000000000000000000000000000000000000;;			if end < len(s) {
0000000000000000000000000000000000000000;;				s = s[:end]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(s) > 0 && tag.Compare(s, scan.b) == 0 {
0000000000000000000000000000000000000000;;				t.str = s
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.str = string(scan.b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.pVariant, t.pExt = 0, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, scan.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseTag parses language, script, region and variants.
0000000000000000000000000000000000000000;;	// It returns a Tag and the end position in the input that was parsed.
0000000000000000000000000000000000000000;;	func parseTag(scan *scanner) (t Tag, end int) {
0000000000000000000000000000000000000000;;		var e error
0000000000000000000000000000000000000000;;		// TODO: set an error if an unknown lang, script or region is encountered.
0000000000000000000000000000000000000000;;		t.lang, e = getLangID(scan.token)
0000000000000000000000000000000000000000;;		scan.setError(e)
0000000000000000000000000000000000000000;;		scan.replace(t.lang.String())
0000000000000000000000000000000000000000;;		langStart := scan.start
0000000000000000000000000000000000000000;;		end = scan.scan()
0000000000000000000000000000000000000000;;		for len(scan.token) == 3 && isAlpha(scan.token[0]) {
0000000000000000000000000000000000000000;;			// From http://tools.ietf.org/html/bcp47, <lang>-<extlang> tags are equivalent
0000000000000000000000000000000000000000;;			// to a tag of the form <extlang>.
0000000000000000000000000000000000000000;;			lang, e := getLangID(scan.token)
0000000000000000000000000000000000000000;;			if lang != 0 {
0000000000000000000000000000000000000000;;				t.lang = lang
0000000000000000000000000000000000000000;;				copy(scan.b[langStart:], lang.String())
0000000000000000000000000000000000000000;;				scan.b[langStart+3] = '-'
0000000000000000000000000000000000000000;;				scan.start = langStart + 4
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			scan.gobble(e)
0000000000000000000000000000000000000000;;			end = scan.scan()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(scan.token) == 4 && isAlpha(scan.token[0]) {
0000000000000000000000000000000000000000;;			t.script, e = getScriptID(script, scan.token)
0000000000000000000000000000000000000000;;			if t.script == 0 {
0000000000000000000000000000000000000000;;				scan.gobble(e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			end = scan.scan()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n := len(scan.token); n >= 2 && n <= 3 {
0000000000000000000000000000000000000000;;			t.region, e = getRegionID(scan.token)
0000000000000000000000000000000000000000;;			if t.region == 0 {
0000000000000000000000000000000000000000;;				scan.gobble(e)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				scan.replace(t.region.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			end = scan.scan()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scan.toLower(scan.start, len(scan.b))
0000000000000000000000000000000000000000;;		t.pVariant = byte(end)
0000000000000000000000000000000000000000;;		end = parseVariants(scan, end, t)
0000000000000000000000000000000000000000;;		t.pExt = uint16(end)
0000000000000000000000000000000000000000;;		return t, end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var separator = []byte{'-'}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseVariants scans tokens as long as each token is a valid variant string.
0000000000000000000000000000000000000000;;	// Duplicate variants are removed.
0000000000000000000000000000000000000000;;	func parseVariants(scan *scanner, end int, t Tag) int {
0000000000000000000000000000000000000000;;		start := scan.start
0000000000000000000000000000000000000000;;		varIDBuf := [4]uint8{}
0000000000000000000000000000000000000000;;		variantBuf := [4][]byte{}
0000000000000000000000000000000000000000;;		varID := varIDBuf[:0]
0000000000000000000000000000000000000000;;		variant := variantBuf[:0]
0000000000000000000000000000000000000000;;		last := -1
0000000000000000000000000000000000000000;;		needSort := false
0000000000000000000000000000000000000000;;		for ; len(scan.token) >= 4; scan.scan() {
0000000000000000000000000000000000000000;;			// TODO: measure the impact of needing this conversion and redesign
0000000000000000000000000000000000000000;;			// the data structure if there is an issue.
0000000000000000000000000000000000000000;;			v, ok := variantIndex[string(scan.token)]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// unknown variant
0000000000000000000000000000000000000000;;				// TODO: allow user-defined variants?
0000000000000000000000000000000000000000;;				scan.gobble(mkErrInvalid(scan.token))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			varID = append(varID, v)
0000000000000000000000000000000000000000;;			variant = append(variant, scan.token)
0000000000000000000000000000000000000000;;			if !needSort {
0000000000000000000000000000000000000000;;				if last < int(v) {
0000000000000000000000000000000000000000;;					last = int(v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					needSort = true
0000000000000000000000000000000000000000;;					// There is no legal combinations of more than 7 variants
0000000000000000000000000000000000000000;;					// (and this is by no means a useful sequence).
0000000000000000000000000000000000000000;;					const maxVariants = 8
0000000000000000000000000000000000000000;;					if len(varID) > maxVariants {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			end = scan.end
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if needSort {
0000000000000000000000000000000000000000;;			sort.Sort(variantsSort{varID, variant})
0000000000000000000000000000000000000000;;			k, l := 0, -1
0000000000000000000000000000000000000000;;			for i, v := range varID {
0000000000000000000000000000000000000000;;				w := int(v)
0000000000000000000000000000000000000000;;				if l == w {
0000000000000000000000000000000000000000;;					// Remove duplicates.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				varID[k] = varID[i]
0000000000000000000000000000000000000000;;				variant[k] = variant[i]
0000000000000000000000000000000000000000;;				k++
0000000000000000000000000000000000000000;;				l = w
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if str := bytes.Join(variant[:k], separator); len(str) == 0 {
0000000000000000000000000000000000000000;;				end = start - 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				scan.resizeRange(start, end, len(str))
0000000000000000000000000000000000000000;;				copy(scan.b[scan.start:], str)
0000000000000000000000000000000000000000;;				end = scan.end
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type variantsSort struct {
0000000000000000000000000000000000000000;;		i []uint8
0000000000000000000000000000000000000000;;		v [][]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s variantsSort) Len() int {
0000000000000000000000000000000000000000;;		return len(s.i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s variantsSort) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s.i[i], s.i[j] = s.i[j], s.i[i]
0000000000000000000000000000000000000000;;		s.v[i], s.v[j] = s.v[j], s.v[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s variantsSort) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s.i[i] < s.i[j]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bytesSort [][]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b bytesSort) Len() int {
0000000000000000000000000000000000000000;;		return len(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b bytesSort) Swap(i, j int) {
0000000000000000000000000000000000000000;;		b[i], b[j] = b[j], b[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b bytesSort) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return bytes.Compare(b[i], b[j]) == -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseExtensions parses and normalizes the extensions in the buffer.
0000000000000000000000000000000000000000;;	// It returns the last position of scan.b that is part of any extension.
0000000000000000000000000000000000000000;;	// It also trims scan.b to remove excess parts accordingly.
0000000000000000000000000000000000000000;;	func parseExtensions(scan *scanner) int {
0000000000000000000000000000000000000000;;		start := scan.start
0000000000000000000000000000000000000000;;		exts := [][]byte{}
0000000000000000000000000000000000000000;;		private := []byte{}
0000000000000000000000000000000000000000;;		end := scan.end
0000000000000000000000000000000000000000;;		for len(scan.token) == 1 {
0000000000000000000000000000000000000000;;			extStart := scan.start
0000000000000000000000000000000000000000;;			ext := scan.token[0]
0000000000000000000000000000000000000000;;			end = parseExtension(scan)
0000000000000000000000000000000000000000;;			extension := scan.b[extStart:end]
0000000000000000000000000000000000000000;;			if len(extension) < 3 || (ext != 'x' && len(extension) < 4) {
0000000000000000000000000000000000000000;;				scan.setError(errSyntax)
0000000000000000000000000000000000000000;;				end = extStart
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if start == extStart && (ext == 'x' || scan.start == len(scan.b)) {
0000000000000000000000000000000000000000;;				scan.b = scan.b[:end]
0000000000000000000000000000000000000000;;				return end
0000000000000000000000000000000000000000;;			} else if ext == 'x' {
0000000000000000000000000000000000000000;;				private = extension
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			exts = append(exts, extension)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(bytesSort(exts))
0000000000000000000000000000000000000000;;		if len(private) > 0 {
0000000000000000000000000000000000000000;;			exts = append(exts, private)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scan.b = scan.b[:start]
0000000000000000000000000000000000000000;;		if len(exts) > 0 {
0000000000000000000000000000000000000000;;			scan.b = append(scan.b, bytes.Join(exts, separator)...)
0000000000000000000000000000000000000000;;		} else if start > 0 {
0000000000000000000000000000000000000000;;			// Strip trailing '-'.
0000000000000000000000000000000000000000;;			scan.b = scan.b[:start-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseExtension parses a single extension and returns the position of
0000000000000000000000000000000000000000;;	// the extension end.
0000000000000000000000000000000000000000;;	func parseExtension(scan *scanner) int {
0000000000000000000000000000000000000000;;		start, end := scan.start, scan.end
0000000000000000000000000000000000000000;;		switch scan.token[0] {
0000000000000000000000000000000000000000;;		case 'u':
0000000000000000000000000000000000000000;;			attrStart := end
0000000000000000000000000000000000000000;;			scan.scan()
0000000000000000000000000000000000000000;;			for last := []byte{}; len(scan.token) > 2; scan.scan() {
0000000000000000000000000000000000000000;;				if bytes.Compare(scan.token, last) != -1 {
0000000000000000000000000000000000000000;;					// Attributes are unsorted. Start over from scratch.
0000000000000000000000000000000000000000;;					p := attrStart + 1
0000000000000000000000000000000000000000;;					scan.next = p
0000000000000000000000000000000000000000;;					attrs := [][]byte{}
0000000000000000000000000000000000000000;;					for scan.scan(); len(scan.token) > 2; scan.scan() {
0000000000000000000000000000000000000000;;						attrs = append(attrs, scan.token)
0000000000000000000000000000000000000000;;						end = scan.end
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sort.Sort(bytesSort(attrs))
0000000000000000000000000000000000000000;;					copy(scan.b[p:], bytes.Join(attrs, separator))
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				last = scan.token
0000000000000000000000000000000000000000;;				end = scan.end
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var last, key []byte
0000000000000000000000000000000000000000;;			for attrEnd := end; len(scan.token) == 2; last = key {
0000000000000000000000000000000000000000;;				key = scan.token
0000000000000000000000000000000000000000;;				keyEnd := scan.end
0000000000000000000000000000000000000000;;				end = scan.acceptMinSize(3)
0000000000000000000000000000000000000000;;				// TODO: check key value validity
0000000000000000000000000000000000000000;;				if keyEnd == end || bytes.Compare(key, last) != 1 {
0000000000000000000000000000000000000000;;					// We have an invalid key or the keys are not sorted.
0000000000000000000000000000000000000000;;					// Start scanning keys from scratch and reorder.
0000000000000000000000000000000000000000;;					p := attrEnd + 1
0000000000000000000000000000000000000000;;					scan.next = p
0000000000000000000000000000000000000000;;					keys := [][]byte{}
0000000000000000000000000000000000000000;;					for scan.scan(); len(scan.token) == 2; {
0000000000000000000000000000000000000000;;						keyStart, keyEnd := scan.start, scan.end
0000000000000000000000000000000000000000;;						end = scan.acceptMinSize(3)
0000000000000000000000000000000000000000;;						if keyEnd != end {
0000000000000000000000000000000000000000;;							keys = append(keys, scan.b[keyStart:end])
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							scan.setError(errSyntax)
0000000000000000000000000000000000000000;;							end = keyStart
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sort.Sort(bytesSort(keys))
0000000000000000000000000000000000000000;;					reordered := bytes.Join(keys, separator)
0000000000000000000000000000000000000000;;					if e := p + len(reordered); e < end {
0000000000000000000000000000000000000000;;						scan.deleteRange(e, end)
0000000000000000000000000000000000000000;;						end = e
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					copy(scan.b[p:], bytes.Join(keys, separator))
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 't':
0000000000000000000000000000000000000000;;			scan.scan()
0000000000000000000000000000000000000000;;			if n := len(scan.token); n >= 2 && n <= 3 && isAlpha(scan.token[1]) {
0000000000000000000000000000000000000000;;				_, end = parseTag(scan)
0000000000000000000000000000000000000000;;				scan.toLower(start, end)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for len(scan.token) == 2 && !isAlpha(scan.token[1]) {
0000000000000000000000000000000000000000;;				end = scan.acceptMinSize(3)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 'x':
0000000000000000000000000000000000000000;;			end = scan.acceptMinSize(1)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			end = scan.acceptMinSize(2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compose creates a Tag from individual parts, which may be of type Tag, Base,
0000000000000000000000000000000000000000;;	// Script, Region, Variant, []Variant, Extension, []Extension or error. If a
0000000000000000000000000000000000000000;;	// Base, Script or Region or slice of type Variant or Extension is passed more
0000000000000000000000000000000000000000;;	// than once, the latter will overwrite the former. Variants and Extensions are
0000000000000000000000000000000000000000;;	// accumulated, but if two extensions of the same type are passed, the latter
0000000000000000000000000000000000000000;;	// will replace the former. A Tag overwrites all former values and typically
0000000000000000000000000000000000000000;;	// only makes sense as the first argument. The resulting tag is returned after
0000000000000000000000000000000000000000;;	// canonicalizing using the Default CanonType. If one or more errors are
0000000000000000000000000000000000000000;;	// encountered, one of the errors is returned.
0000000000000000000000000000000000000000;;	func Compose(part ...interface{}) (t Tag, err error) {
0000000000000000000000000000000000000000;;		return Default.Compose(part...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compose creates a Tag from individual parts, which may be of type Tag, Base,
0000000000000000000000000000000000000000;;	// Script, Region, Variant, []Variant, Extension, []Extension or error. If a
0000000000000000000000000000000000000000;;	// Base, Script or Region or slice of type Variant or Extension is passed more
0000000000000000000000000000000000000000;;	// than once, the latter will overwrite the former. Variants and Extensions are
0000000000000000000000000000000000000000;;	// accumulated, but if two extensions of the same type are passed, the latter
0000000000000000000000000000000000000000;;	// will replace the former. A Tag overwrites all former values and typically
0000000000000000000000000000000000000000;;	// only makes sense as the first argument. The resulting tag is returned after
0000000000000000000000000000000000000000;;	// canonicalizing using CanonType c. If one or more errors are encountered,
0000000000000000000000000000000000000000;;	// one of the errors is returned.
0000000000000000000000000000000000000000;;	func (c CanonType) Compose(part ...interface{}) (t Tag, err error) {
0000000000000000000000000000000000000000;;		var b builder
0000000000000000000000000000000000000000;;		if err = b.update(part...); err != nil {
0000000000000000000000000000000000000000;;			return und, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, _ = b.tag.canonicalize(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b.ext) > 0 || len(b.variant) > 0 {
0000000000000000000000000000000000000000;;			sort.Sort(sortVariant(b.variant))
0000000000000000000000000000000000000000;;			sort.Strings(b.ext)
0000000000000000000000000000000000000000;;			if b.private != "" {
0000000000000000000000000000000000000000;;				b.ext = append(b.ext, b.private)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n := maxCoreSize + tokenLen(b.variant...) + tokenLen(b.ext...)
0000000000000000000000000000000000000000;;			buf := make([]byte, n)
0000000000000000000000000000000000000000;;			p := t.genCoreBytes(buf)
0000000000000000000000000000000000000000;;			t.pVariant = byte(p)
0000000000000000000000000000000000000000;;			p += appendTokens(buf[p:], b.variant...)
0000000000000000000000000000000000000000;;			t.pExt = uint16(p)
0000000000000000000000000000000000000000;;			p += appendTokens(buf[p:], b.ext...)
0000000000000000000000000000000000000000;;			t.str = string(buf[:p])
0000000000000000000000000000000000000000;;		} else if b.private != "" {
0000000000000000000000000000000000000000;;			t.str = b.private
0000000000000000000000000000000000000000;;			t.remakeString()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type builder struct {
0000000000000000000000000000000000000000;;		tag Tag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		private string // the x extension
0000000000000000000000000000000000000000;;		ext     []string
0000000000000000000000000000000000000000;;		variant []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) addExt(e string) {
0000000000000000000000000000000000000000;;		if e == "" {
0000000000000000000000000000000000000000;;		} else if e[0] == 'x' {
0000000000000000000000000000000000000000;;			b.private = e
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			b.ext = append(b.ext, e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errInvalidArgument = errors.New("invalid Extension or Variant")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *builder) update(part ...interface{}) (err error) {
0000000000000000000000000000000000000000;;		replace := func(l *[]string, s string, eq func(a, b string) bool) bool {
0000000000000000000000000000000000000000;;			if s == "" {
0000000000000000000000000000000000000000;;				b.err = errInvalidArgument
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, v := range *l {
0000000000000000000000000000000000000000;;				if eq(v, s) {
0000000000000000000000000000000000000000;;					(*l)[i] = s
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, x := range part {
0000000000000000000000000000000000000000;;			switch v := x.(type) {
0000000000000000000000000000000000000000;;			case Tag:
0000000000000000000000000000000000000000;;				b.tag.lang = v.lang
0000000000000000000000000000000000000000;;				b.tag.region = v.region
0000000000000000000000000000000000000000;;				b.tag.script = v.script
0000000000000000000000000000000000000000;;				if v.str != "" {
0000000000000000000000000000000000000000;;					b.variant = nil
0000000000000000000000000000000000000000;;					for x, s := "", v.str[v.pVariant:v.pExt]; s != ""; {
0000000000000000000000000000000000000000;;						x, s = nextToken(s)
0000000000000000000000000000000000000000;;						b.variant = append(b.variant, x)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					b.ext, b.private = nil, ""
0000000000000000000000000000000000000000;;					for i, e := int(v.pExt), ""; i < len(v.str); {
0000000000000000000000000000000000000000;;						i, e = getExtension(v.str, i)
0000000000000000000000000000000000000000;;						b.addExt(e)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case Base:
0000000000000000000000000000000000000000;;				b.tag.lang = v.langID
0000000000000000000000000000000000000000;;			case Script:
0000000000000000000000000000000000000000;;				b.tag.script = v.scriptID
0000000000000000000000000000000000000000;;			case Region:
0000000000000000000000000000000000000000;;				b.tag.region = v.regionID
0000000000000000000000000000000000000000;;			case Variant:
0000000000000000000000000000000000000000;;				if !replace(&b.variant, v.variant, func(a, b string) bool { return a == b }) {
0000000000000000000000000000000000000000;;					b.variant = append(b.variant, v.variant)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case Extension:
0000000000000000000000000000000000000000;;				if !replace(&b.ext, v.s, func(a, b string) bool { return a[0] == b[0] }) {
0000000000000000000000000000000000000000;;					b.addExt(v.s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case []Variant:
0000000000000000000000000000000000000000;;				b.variant = nil
0000000000000000000000000000000000000000;;				for _, x := range v {
0000000000000000000000000000000000000000;;					b.update(x)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case []Extension:
0000000000000000000000000000000000000000;;				b.ext, b.private = nil, ""
0000000000000000000000000000000000000000;;				for _, e := range v {
0000000000000000000000000000000000000000;;					b.update(e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			// TODO: support parsing of raw strings based on morphology or just extensions?
0000000000000000000000000000000000000000;;			case error:
0000000000000000000000000000000000000000;;				err = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tokenLen(token ...string) (n int) {
0000000000000000000000000000000000000000;;		for _, t := range token {
0000000000000000000000000000000000000000;;			n += len(t) + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendTokens(b []byte, token ...string) int {
0000000000000000000000000000000000000000;;		p := 0
0000000000000000000000000000000000000000;;		for _, t := range token {
0000000000000000000000000000000000000000;;			b[p] = '-'
0000000000000000000000000000000000000000;;			copy(b[p+1:], t)
0000000000000000000000000000000000000000;;			p += 1 + len(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortVariant []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sortVariant) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sortVariant) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[j], s[i] = s[i], s[j]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s sortVariant) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return variantIndex[s[i]] < variantIndex[s[j]]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findExt(list []string, x byte) int {
0000000000000000000000000000000000000000;;		for i, e := range list {
0000000000000000000000000000000000000000;;			if e[0] == x {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getExtension returns the name, body and end position of the extension.
0000000000000000000000000000000000000000;;	func getExtension(s string, p int) (end int, ext string) {
0000000000000000000000000000000000000000;;		if s[p] == '-' {
0000000000000000000000000000000000000000;;			p++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s[p] == 'x' {
0000000000000000000000000000000000000000;;			return len(s), s[p:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		end = nextExtension(s, p)
0000000000000000000000000000000000000000;;		return end, s[p:end]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextExtension finds the next extension within the string, searching
0000000000000000000000000000000000000000;;	// for the -<char>- pattern from position p.
0000000000000000000000000000000000000000;;	// In the fast majority of cases, language tags will have at most
0000000000000000000000000000000000000000;;	// one extension and extensions tend to be small.
0000000000000000000000000000000000000000;;	func nextExtension(s string, p int) int {
0000000000000000000000000000000000000000;;		for n := len(s) - 3; p < n; {
0000000000000000000000000000000000000000;;			if s[p] == '-' {
0000000000000000000000000000000000000000;;				if s[p+2] == '-' {
0000000000000000000000000000000000000000;;					return p
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p += 3
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errInvalidWeight = errors.New("ParseAcceptLanguage: invalid weight")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseAcceptLanguage parses the contents of a Accept-Language header as
0000000000000000000000000000000000000000;;	// defined in http://www.ietf.org/rfc/rfc2616.txt and returns a list of Tags and
0000000000000000000000000000000000000000;;	// a list of corresponding quality weights. It is more permissive than RFC 2616
0000000000000000000000000000000000000000;;	// and may return non-nil slices even if the input is not valid.
0000000000000000000000000000000000000000;;	// The Tags will be sorted by highest weight first and then by first occurrence.
0000000000000000000000000000000000000000;;	// Tags with a weight of zero will be dropped. An error will be returned if the
0000000000000000000000000000000000000000;;	// input could not be parsed.
0000000000000000000000000000000000000000;;	func ParseAcceptLanguage(s string) (tag []Tag, q []float32, err error) {
0000000000000000000000000000000000000000;;		var entry string
0000000000000000000000000000000000000000;;		for s != "" {
0000000000000000000000000000000000000000;;			if entry, s = split(s, ','); entry == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			entry, weight := split(entry, ';')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Scan the language.
0000000000000000000000000000000000000000;;			t, err := Parse(entry)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				id, ok := acceptFallback[entry]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t = Tag{lang: id}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Scan the optional weight.
0000000000000000000000000000000000000000;;			w := 1.0
0000000000000000000000000000000000000000;;			if weight != "" {
0000000000000000000000000000000000000000;;				weight = consume(weight, 'q')
0000000000000000000000000000000000000000;;				weight = consume(weight, '=')
0000000000000000000000000000000000000000;;				// consume returns the empty string when a token could not be
0000000000000000000000000000000000000000;;				// consumed, resulting in an error for ParseFloat.
0000000000000000000000000000000000000000;;				if w, err = strconv.ParseFloat(weight, 32); err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, errInvalidWeight
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Drop tags with a quality weight of 0.
0000000000000000000000000000000000000000;;				if w <= 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tag = append(tag, t)
0000000000000000000000000000000000000000;;			q = append(q, float32(w))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sortStable(&tagSort{tag, q})
0000000000000000000000000000000000000000;;		return tag, q, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// consume removes a leading token c from s and returns the result or the empty
0000000000000000000000000000000000000000;;	// string if there is no such token.
0000000000000000000000000000000000000000;;	func consume(s string, c byte) string {
0000000000000000000000000000000000000000;;		if s == "" || s[0] != c {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.TrimSpace(s[1:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func split(s string, c byte) (head, tail string) {
0000000000000000000000000000000000000000;;		if i := strings.IndexByte(s, c); i >= 0 {
0000000000000000000000000000000000000000;;			return strings.TrimSpace(s[:i]), strings.TrimSpace(s[i+1:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.TrimSpace(s), ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add hack mapping to deal with a small number of cases that that occur
0000000000000000000000000000000000000000;;	// in Accept-Language (with reasonable frequency).
0000000000000000000000000000000000000000;;	var acceptFallback = map[string]langID{
0000000000000000000000000000000000000000;;		"english": _en,
0000000000000000000000000000000000000000;;		"deutsch": _de,
0000000000000000000000000000000000000000;;		"italian": _it,
0000000000000000000000000000000000000000;;		"french":  _fr,
0000000000000000000000000000000000000000;;		"*":       _mul, // defined in the spec to match all languages.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tagSort struct {
0000000000000000000000000000000000000000;;		tag []Tag
0000000000000000000000000000000000000000;;		q   []float32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *tagSort) Len() int {
0000000000000000000000000000000000000000;;		return len(s.q)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *tagSort) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s.q[i] > s.q[j]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *tagSort) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s.tag[i], s.tag[j] = s.tag[j], s.tag[i]
0000000000000000000000000000000000000000;;		s.q[i], s.q[j] = s.q[j], s.q[i]
0000000000000000000000000000000000000000;;	}
