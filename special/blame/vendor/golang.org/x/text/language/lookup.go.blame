0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package language
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/tag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findIndex tries to find the given tag in idx and returns a standardized error
0000000000000000000000000000000000000000;;	// if it could not be found.
0000000000000000000000000000000000000000;;	func findIndex(idx tag.Index, key []byte, form string) (index int, err error) {
0000000000000000000000000000000000000000;;		if !tag.FixCase(form, key) {
0000000000000000000000000000000000000000;;			return 0, errSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := idx.Index(key)
0000000000000000000000000000000000000000;;		if i == -1 {
0000000000000000000000000000000000000000;;			return 0, mkErrInvalid(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func searchUint(imap []uint16, key uint16) int {
0000000000000000000000000000000000000000;;		return sort.Search(len(imap), func(i int) bool {
0000000000000000000000000000000000000000;;			return imap[i] >= key
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type langID uint16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLangID returns the langID of s if s is a canonical subtag
0000000000000000000000000000000000000000;;	// or langUnknown if s is not a canonical subtag.
0000000000000000000000000000000000000000;;	func getLangID(s []byte) (langID, error) {
0000000000000000000000000000000000000000;;		if len(s) == 2 {
0000000000000000000000000000000000000000;;			return getLangISO2(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return getLangISO3(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapLang returns the mapped langID of id according to mapping m.
0000000000000000000000000000000000000000;;	func normLang(id langID) (langID, langAliasType) {
0000000000000000000000000000000000000000;;		k := sort.Search(len(langAliasMap), func(i int) bool {
0000000000000000000000000000000000000000;;			return langAliasMap[i].from >= uint16(id)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if k < len(langAliasMap) && langAliasMap[k].from == uint16(id) {
0000000000000000000000000000000000000000;;			return langID(langAliasMap[k].to), langAliasTypes[k]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return id, langAliasTypeUnknown
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLangISO2 returns the langID for the given 2-letter ISO language code
0000000000000000000000000000000000000000;;	// or unknownLang if this does not exist.
0000000000000000000000000000000000000000;;	func getLangISO2(s []byte) (langID, error) {
0000000000000000000000000000000000000000;;		if !tag.FixCase("zz", s) {
0000000000000000000000000000000000000000;;			return 0, errSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i := lang.Index(s); i != -1 && lang.Elem(i)[3] != 0 {
0000000000000000000000000000000000000000;;			return langID(i), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, mkErrInvalid(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const base = 'z' - 'a' + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func strToInt(s []byte) uint {
0000000000000000000000000000000000000000;;		v := uint(0)
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			v *= base
0000000000000000000000000000000000000000;;			v += uint(s[i] - 'a')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// converts the given integer to the original ASCII string passed to strToInt.
0000000000000000000000000000000000000000;;	// len(s) must match the number of characters obtained.
0000000000000000000000000000000000000000;;	func intToStr(v uint, s []byte) {
0000000000000000000000000000000000000000;;		for i := len(s) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			s[i] = byte(v%base) + 'a'
0000000000000000000000000000000000000000;;			v /= base
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getLangISO3 returns the langID for the given 3-letter ISO language code
0000000000000000000000000000000000000000;;	// or unknownLang if this does not exist.
0000000000000000000000000000000000000000;;	func getLangISO3(s []byte) (langID, error) {
0000000000000000000000000000000000000000;;		if tag.FixCase("und", s) {
0000000000000000000000000000000000000000;;			// first try to match canonical 3-letter entries
0000000000000000000000000000000000000000;;			for i := lang.Index(s[:2]); i != -1; i = lang.Next(s[:2], i) {
0000000000000000000000000000000000000000;;				if e := lang.Elem(i); e[3] == 0 && e[2] == s[2] {
0000000000000000000000000000000000000000;;					// We treat "und" as special and always translate it to "unspecified".
0000000000000000000000000000000000000000;;					// Note that ZZ and Zzzz are private use and are not treated as
0000000000000000000000000000000000000000;;					// unspecified by default.
0000000000000000000000000000000000000000;;					id := langID(i)
0000000000000000000000000000000000000000;;					if id == nonCanonicalUnd {
0000000000000000000000000000000000000000;;						return 0, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return id, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i := altLangISO3.Index(s); i != -1 {
0000000000000000000000000000000000000000;;				return langID(altLangIndex[altLangISO3.Elem(i)[3]]), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n := strToInt(s)
0000000000000000000000000000000000000000;;			if langNoIndex[n/8]&(1<<(n%8)) != 0 {
0000000000000000000000000000000000000000;;				return langID(n) + langNoIndexOffset, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check for non-canonical uses of ISO3.
0000000000000000000000000000000000000000;;			for i := lang.Index(s[:1]); i != -1; i = lang.Next(s[:1], i) {
0000000000000000000000000000000000000000;;				if e := lang.Elem(i); e[2] == s[1] && e[3] == s[2] {
0000000000000000000000000000000000000000;;					return langID(i), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0, mkErrInvalid(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, errSyntax
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stringToBuf writes the string to b and returns the number of bytes
0000000000000000000000000000000000000000;;	// written.  cap(b) must be >= 3.
0000000000000000000000000000000000000000;;	func (id langID) stringToBuf(b []byte) int {
0000000000000000000000000000000000000000;;		if id >= langNoIndexOffset {
0000000000000000000000000000000000000000;;			intToStr(uint(id)-langNoIndexOffset, b[:3])
0000000000000000000000000000000000000000;;			return 3
0000000000000000000000000000000000000000;;		} else if id == 0 {
0000000000000000000000000000000000000000;;			return copy(b, "und")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := lang[id<<2:]
0000000000000000000000000000000000000000;;		if l[3] == 0 {
0000000000000000000000000000000000000000;;			return copy(b, l[:3])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copy(b, l[:2])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the BCP 47 representation of the langID.
0000000000000000000000000000000000000000;;	// Use b as variable name, instead of id, to ensure the variable
0000000000000000000000000000000000000000;;	// used is consistent with that of Base in which this type is embedded.
0000000000000000000000000000000000000000;;	func (b langID) String() string {
0000000000000000000000000000000000000000;;		if b == 0 {
0000000000000000000000000000000000000000;;			return "und"
0000000000000000000000000000000000000000;;		} else if b >= langNoIndexOffset {
0000000000000000000000000000000000000000;;			b -= langNoIndexOffset
0000000000000000000000000000000000000000;;			buf := [3]byte{}
0000000000000000000000000000000000000000;;			intToStr(uint(b), buf[:])
0000000000000000000000000000000000000000;;			return string(buf[:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := lang.Elem(int(b))
0000000000000000000000000000000000000000;;		if l[3] == 0 {
0000000000000000000000000000000000000000;;			return l[:3]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l[:2]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ISO3 returns the ISO 639-3 language code.
0000000000000000000000000000000000000000;;	func (b langID) ISO3() string {
0000000000000000000000000000000000000000;;		if b == 0 || b >= langNoIndexOffset {
0000000000000000000000000000000000000000;;			return b.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := lang.Elem(int(b))
0000000000000000000000000000000000000000;;		if l[3] == 0 {
0000000000000000000000000000000000000000;;			return l[:3]
0000000000000000000000000000000000000000;;		} else if l[2] == 0 {
0000000000000000000000000000000000000000;;			return altLangISO3.Elem(int(l[3]))[:3]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This allocation will only happen for 3-letter ISO codes
0000000000000000000000000000000000000000;;		// that are non-canonical BCP 47 language identifiers.
0000000000000000000000000000000000000000;;		return l[0:1] + l[2:4]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPrivateUse reports whether this language code is reserved for private use.
0000000000000000000000000000000000000000;;	func (b langID) IsPrivateUse() bool {
0000000000000000000000000000000000000000;;		return langPrivateStart <= b && b <= langPrivateEnd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type regionID uint16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRegionID returns the region id for s if s is a valid 2-letter region code
0000000000000000000000000000000000000000;;	// or unknownRegion.
0000000000000000000000000000000000000000;;	func getRegionID(s []byte) (regionID, error) {
0000000000000000000000000000000000000000;;		if len(s) == 3 {
0000000000000000000000000000000000000000;;			if isAlpha(s[0]) {
0000000000000000000000000000000000000000;;				return getRegionISO3(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i, err := strconv.ParseUint(string(s), 10, 10); err == nil {
0000000000000000000000000000000000000000;;				return getRegionM49(int(i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return getRegionISO2(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRegionISO2 returns the regionID for the given 2-letter ISO country code
0000000000000000000000000000000000000000;;	// or unknownRegion if this does not exist.
0000000000000000000000000000000000000000;;	func getRegionISO2(s []byte) (regionID, error) {
0000000000000000000000000000000000000000;;		i, err := findIndex(regionISO, s, "ZZ")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return regionID(i) + isoRegionOffset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRegionISO3 returns the regionID for the given 3-letter ISO country code
0000000000000000000000000000000000000000;;	// or unknownRegion if this does not exist.
0000000000000000000000000000000000000000;;	func getRegionISO3(s []byte) (regionID, error) {
0000000000000000000000000000000000000000;;		if tag.FixCase("ZZZ", s) {
0000000000000000000000000000000000000000;;			for i := regionISO.Index(s[:1]); i != -1; i = regionISO.Next(s[:1], i) {
0000000000000000000000000000000000000000;;				if e := regionISO.Elem(i); e[2] == s[1] && e[3] == s[2] {
0000000000000000000000000000000000000000;;					return regionID(i) + isoRegionOffset, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < len(altRegionISO3); i += 3 {
0000000000000000000000000000000000000000;;				if tag.Compare(altRegionISO3[i:i+3], s) == 0 {
0000000000000000000000000000000000000000;;					return regionID(altRegionIDs[i/3]), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0, mkErrInvalid(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, errSyntax
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRegionM49(n int) (regionID, error) {
0000000000000000000000000000000000000000;;		if 0 < n && n <= 999 {
0000000000000000000000000000000000000000;;			const (
0000000000000000000000000000000000000000;;				searchBits = 7
0000000000000000000000000000000000000000;;				regionBits = 9
0000000000000000000000000000000000000000;;				regionMask = 1<<regionBits - 1
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			idx := n >> searchBits
0000000000000000000000000000000000000000;;			buf := fromM49[m49Index[idx]:m49Index[idx+1]]
0000000000000000000000000000000000000000;;			val := uint16(n) << regionBits // we rely on bits shifting out
0000000000000000000000000000000000000000;;			i := sort.Search(len(buf), func(i int) bool {
0000000000000000000000000000000000000000;;				return buf[i] >= val
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if r := fromM49[int(m49Index[idx])+i]; r&^regionMask == val {
0000000000000000000000000000000000000000;;				return regionID(r & regionMask), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var e ValueError
0000000000000000000000000000000000000000;;		fmt.Fprint(bytes.NewBuffer([]byte(e.v[:])), n)
0000000000000000000000000000000000000000;;		return 0, e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// normRegion returns a region if r is deprecated or 0 otherwise.
0000000000000000000000000000000000000000;;	// TODO: consider supporting BYS (-> BLR), CSK (-> 200 or CZ), PHI (-> PHL) and AFI (-> DJ).
0000000000000000000000000000000000000000;;	// TODO: consider mapping split up regions to new most populous one (like CLDR).
0000000000000000000000000000000000000000;;	func normRegion(r regionID) regionID {
0000000000000000000000000000000000000000;;		m := regionOldMap
0000000000000000000000000000000000000000;;		k := sort.Search(len(m), func(i int) bool {
0000000000000000000000000000000000000000;;			return m[i].from >= uint16(r)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if k < len(m) && m[k].from == uint16(r) {
0000000000000000000000000000000000000000;;			return regionID(m[k].to)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		iso3166UserAssigned = 1 << iota
0000000000000000000000000000000000000000;;		ccTLD
0000000000000000000000000000000000000000;;		bcp47Region
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r regionID) typ() byte {
0000000000000000000000000000000000000000;;		return regionTypes[r]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the BCP 47 representation for the region.
0000000000000000000000000000000000000000;;	// It returns "ZZ" for an unspecified region.
0000000000000000000000000000000000000000;;	func (r regionID) String() string {
0000000000000000000000000000000000000000;;		if r < isoRegionOffset {
0000000000000000000000000000000000000000;;			if r == 0 {
0000000000000000000000000000000000000000;;				return "ZZ"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%03d", r.M49())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r -= isoRegionOffset
0000000000000000000000000000000000000000;;		return regionISO.Elem(int(r))[:2]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ISO3 returns the 3-letter ISO code of r.
0000000000000000000000000000000000000000;;	// Note that not all regions have a 3-letter ISO code.
0000000000000000000000000000000000000000;;	// In such cases this method returns "ZZZ".
0000000000000000000000000000000000000000;;	func (r regionID) ISO3() string {
0000000000000000000000000000000000000000;;		if r < isoRegionOffset {
0000000000000000000000000000000000000000;;			return "ZZZ"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r -= isoRegionOffset
0000000000000000000000000000000000000000;;		reg := regionISO.Elem(int(r))
0000000000000000000000000000000000000000;;		switch reg[2] {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return altRegionISO3[reg[3]:][:3]
0000000000000000000000000000000000000000;;		case ' ':
0000000000000000000000000000000000000000;;			return "ZZZ"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reg[0:1] + reg[2:4]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// M49 returns the UN M.49 encoding of r, or 0 if this encoding
0000000000000000000000000000000000000000;;	// is not defined for r.
0000000000000000000000000000000000000000;;	func (r regionID) M49() int {
0000000000000000000000000000000000000000;;		return int(m49[r])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPrivateUse reports whether r has the ISO 3166 User-assigned status. This
0000000000000000000000000000000000000000;;	// may include private-use tags that are assigned by CLDR and used in this
0000000000000000000000000000000000000000;;	// implementation. So IsPrivateUse and IsCountry can be simultaneously true.
0000000000000000000000000000000000000000;;	func (r regionID) IsPrivateUse() bool {
0000000000000000000000000000000000000000;;		return r.typ()&iso3166UserAssigned != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type scriptID uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getScriptID returns the script id for string s. It assumes that s
0000000000000000000000000000000000000000;;	// is of the format [A-Z][a-z]{3}.
0000000000000000000000000000000000000000;;	func getScriptID(idx tag.Index, s []byte) (scriptID, error) {
0000000000000000000000000000000000000000;;		i, err := findIndex(idx, s, "Zzzz")
0000000000000000000000000000000000000000;;		return scriptID(i), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the script code in title case.
0000000000000000000000000000000000000000;;	// It returns "Zzzz" for an unspecified script.
0000000000000000000000000000000000000000;;	func (s scriptID) String() string {
0000000000000000000000000000000000000000;;		if s == 0 {
0000000000000000000000000000000000000000;;			return "Zzzz"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return script.Elem(int(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPrivateUse reports whether this script code is reserved for private use.
0000000000000000000000000000000000000000;;	func (s scriptID) IsPrivateUse() bool {
0000000000000000000000000000000000000000;;		return _Qaaa <= s && s <= _Qabx
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		maxAltTaglen = len("en-US-POSIX")
0000000000000000000000000000000000000000;;		maxLen       = maxAltTaglen
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// grandfatheredMap holds a mapping from legacy and grandfathered tags to
0000000000000000000000000000000000000000;;		// their base language or index to more elaborate tag.
0000000000000000000000000000000000000000;;		grandfatheredMap = map[[maxLen]byte]int16{
0000000000000000000000000000000000000000;;			[maxLen]byte{'a', 'r', 't', '-', 'l', 'o', 'j', 'b', 'a', 'n'}: _jbo, // art-lojban
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 'a', 'm', 'i'}:                          _ami, // i-ami
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 'b', 'n', 'n'}:                          _bnn, // i-bnn
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 'h', 'a', 'k'}:                          _hak, // i-hak
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 'k', 'l', 'i', 'n', 'g', 'o', 'n'}:      _tlh, // i-klingon
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 'l', 'u', 'x'}:                          _lb,  // i-lux
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 'n', 'a', 'v', 'a', 'j', 'o'}:           _nv,  // i-navajo
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 'p', 'w', 'n'}:                          _pwn, // i-pwn
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 't', 'a', 'o'}:                          _tao, // i-tao
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 't', 'a', 'y'}:                          _tay, // i-tay
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 't', 's', 'u'}:                          _tsu, // i-tsu
0000000000000000000000000000000000000000;;			[maxLen]byte{'n', 'o', '-', 'b', 'o', 'k'}:                     _nb,  // no-bok
0000000000000000000000000000000000000000;;			[maxLen]byte{'n', 'o', '-', 'n', 'y', 'n'}:                     _nn,  // no-nyn
0000000000000000000000000000000000000000;;			[maxLen]byte{'s', 'g', 'n', '-', 'b', 'e', '-', 'f', 'r'}:      _sfb, // sgn-BE-FR
0000000000000000000000000000000000000000;;			[maxLen]byte{'s', 'g', 'n', '-', 'b', 'e', '-', 'n', 'l'}:      _vgt, // sgn-BE-NL
0000000000000000000000000000000000000000;;			[maxLen]byte{'s', 'g', 'n', '-', 'c', 'h', '-', 'd', 'e'}:      _sgg, // sgn-CH-DE
0000000000000000000000000000000000000000;;			[maxLen]byte{'z', 'h', '-', 'g', 'u', 'o', 'y', 'u'}:           _cmn, // zh-guoyu
0000000000000000000000000000000000000000;;			[maxLen]byte{'z', 'h', '-', 'h', 'a', 'k', 'k', 'a'}:           _hak, // zh-hakka
0000000000000000000000000000000000000000;;			[maxLen]byte{'z', 'h', '-', 'm', 'i', 'n', '-', 'n', 'a', 'n'}: _nan, // zh-min-nan
0000000000000000000000000000000000000000;;			[maxLen]byte{'z', 'h', '-', 'x', 'i', 'a', 'n', 'g'}:           _hsn, // zh-xiang
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Grandfathered tags with no modern replacement will be converted as
0000000000000000000000000000000000000000;;			// follows:
0000000000000000000000000000000000000000;;			[maxLen]byte{'c', 'e', 'l', '-', 'g', 'a', 'u', 'l', 'i', 's', 'h'}: -1, // cel-gaulish
0000000000000000000000000000000000000000;;			[maxLen]byte{'e', 'n', '-', 'g', 'b', '-', 'o', 'e', 'd'}:           -2, // en-GB-oed
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 'd', 'e', 'f', 'a', 'u', 'l', 't'}:           -3, // i-default
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 'e', 'n', 'o', 'c', 'h', 'i', 'a', 'n'}:      -4, // i-enochian
0000000000000000000000000000000000000000;;			[maxLen]byte{'i', '-', 'm', 'i', 'n', 'g', 'o'}:                     -5, // i-mingo
0000000000000000000000000000000000000000;;			[maxLen]byte{'z', 'h', '-', 'm', 'i', 'n'}:                          -6, // zh-min
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// CLDR-specific tag.
0000000000000000000000000000000000000000;;			[maxLen]byte{'r', 'o', 'o', 't'}:                                    0,  // root
0000000000000000000000000000000000000000;;			[maxLen]byte{'e', 'n', '-', 'u', 's', '-', 'p', 'o', 's', 'i', 'x'}: -7, // en_US_POSIX"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		altTagIndex = [...]uint8{0, 17, 31, 45, 61, 74, 86, 102}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		altTags = "xtg-x-cel-gaulishen-GB-oxendicten-x-i-defaultund-x-i-enochiansee-x-i-mingonan-x-zh-minen-US-u-va-posix"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func grandfathered(s [maxAltTaglen]byte) (t Tag, ok bool) {
0000000000000000000000000000000000000000;;		if v, ok := grandfatheredMap[s]; ok {
0000000000000000000000000000000000000000;;			if v < 0 {
0000000000000000000000000000000000000000;;				return Make(altTags[altTagIndex[-v-1]:altTagIndex[-v]]), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.lang = langID(v)
0000000000000000000000000000000000000000;;			return t, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, false
0000000000000000000000000000000000000000;;	}
