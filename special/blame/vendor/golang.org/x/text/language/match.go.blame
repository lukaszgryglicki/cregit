0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package language
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matcher is the interface that wraps the Match method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Match returns the best match for any of the given tags, along with
0000000000000000000000000000000000000000;;	// a unique index associated with the returned tag and a confidence
0000000000000000000000000000000000000000;;	// score.
0000000000000000000000000000000000000000;;	type Matcher interface {
0000000000000000000000000000000000000000;;		Match(t ...Tag) (tag Tag, index int, c Confidence)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Comprehends reports the confidence score for a speaker of a given language
0000000000000000000000000000000000000000;;	// to being able to comprehend the written form of an alternative language.
0000000000000000000000000000000000000000;;	func Comprehends(speaker, alternative Tag) Confidence {
0000000000000000000000000000000000000000;;		_, _, c := NewMatcher([]Tag{alternative}).Match(speaker)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMatcher returns a Matcher that matches an ordered list of preferred tags
0000000000000000000000000000000000000000;;	// against a list of supported tags based on written intelligibility, closeness
0000000000000000000000000000000000000000;;	// of dialect, equivalence of subtags and various other rules. It is initialized
0000000000000000000000000000000000000000;;	// with the list of supported tags. The first element is used as the default
0000000000000000000000000000000000000000;;	// value in case no match is found.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Its Match method matches the first of the given Tags to reach a certain
0000000000000000000000000000000000000000;;	// confidence threshold. The tags passed to Match should therefore be specified
0000000000000000000000000000000000000000;;	// in order of preference. Extensions are ignored for matching.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The index returned by the Match method corresponds to the index of the
0000000000000000000000000000000000000000;;	// matched tag in t, but is augmented with the Unicode extension ('u')of the
0000000000000000000000000000000000000000;;	// corresponding preferred tag. This allows user locale options to be passed
0000000000000000000000000000000000000000;;	// transparently.
0000000000000000000000000000000000000000;;	func NewMatcher(t []Tag) Matcher {
0000000000000000000000000000000000000000;;		return newMatcher(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *matcher) Match(want ...Tag) (t Tag, index int, c Confidence) {
0000000000000000000000000000000000000000;;		match, w, c := m.getBest(want...)
0000000000000000000000000000000000000000;;		if match == nil {
0000000000000000000000000000000000000000;;			t = m.default_.tag
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t, index = match.tag, match.index
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Copy options from the user-provided tag into the result tag. This is hard
0000000000000000000000000000000000000000;;		// to do after the fact, so we do it here.
0000000000000000000000000000000000000000;;		// TODO: consider also adding in variants that are compatible with the
0000000000000000000000000000000000000000;;		// matched language.
0000000000000000000000000000000000000000;;		// TODO: Add back region if it is non-ambiguous? Or create another tag to
0000000000000000000000000000000000000000;;		// preserve the region?
0000000000000000000000000000000000000000;;		if u, ok := w.Extension('u'); ok {
0000000000000000000000000000000000000000;;			t, _ = Raw.Compose(t, u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, index, c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type scriptRegionFlags uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		isList = 1 << iota
0000000000000000000000000000000000000000;;		scriptInFrom
0000000000000000000000000000000000000000;;		regionInFrom
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tag) setUndefinedLang(id langID) {
0000000000000000000000000000000000000000;;		if t.lang == 0 {
0000000000000000000000000000000000000000;;			t.lang = id
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tag) setUndefinedScript(id scriptID) {
0000000000000000000000000000000000000000;;		if t.script == 0 {
0000000000000000000000000000000000000000;;			t.script = id
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tag) setUndefinedRegion(id regionID) {
0000000000000000000000000000000000000000;;		if t.region == 0 || t.region.contains(id) {
0000000000000000000000000000000000000000;;			t.region = id
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrMissingLikelyTagsData indicates no information was available
0000000000000000000000000000000000000000;;	// to compute likely values of missing tags.
0000000000000000000000000000000000000000;;	var ErrMissingLikelyTagsData = errors.New("missing likely tags data")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addLikelySubtags sets subtags to their most likely value, given the locale.
0000000000000000000000000000000000000000;;	// In most cases this means setting fields for unknown values, but in some
0000000000000000000000000000000000000000;;	// cases it may alter a value.  It returns a ErrMissingLikelyTagsData error
0000000000000000000000000000000000000000;;	// if the given locale cannot be expanded.
0000000000000000000000000000000000000000;;	func (t Tag) addLikelySubtags() (Tag, error) {
0000000000000000000000000000000000000000;;		id, err := addTags(t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return t, err
0000000000000000000000000000000000000000;;		} else if id.equalTags(t) {
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		id.remakeString()
0000000000000000000000000000000000000000;;		return id, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// specializeRegion attempts to specialize a group region.
0000000000000000000000000000000000000000;;	func specializeRegion(t *Tag) bool {
0000000000000000000000000000000000000000;;		if i := regionInclusion[t.region]; i < nRegionGroups {
0000000000000000000000000000000000000000;;			x := likelyRegionGroup[i]
0000000000000000000000000000000000000000;;			if langID(x.lang) == t.lang && scriptID(x.script) == t.script {
0000000000000000000000000000000000000000;;				t.region = regionID(x.region)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addTags(t Tag) (Tag, error) {
0000000000000000000000000000000000000000;;		// We leave private use identifiers alone.
0000000000000000000000000000000000000000;;		if t.private() {
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.script != 0 && t.region != 0 {
0000000000000000000000000000000000000000;;			if t.lang != 0 {
0000000000000000000000000000000000000000;;				// already fully specified
0000000000000000000000000000000000000000;;				specializeRegion(&t)
0000000000000000000000000000000000000000;;				return t, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Search matches for und-script-region. Note that for these cases
0000000000000000000000000000000000000000;;			// region will never be a group so there is no need to check for this.
0000000000000000000000000000000000000000;;			list := likelyRegion[t.region : t.region+1]
0000000000000000000000000000000000000000;;			if x := list[0]; x.flags&isList != 0 {
0000000000000000000000000000000000000000;;				list = likelyRegionList[x.lang : x.lang+uint16(x.script)]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, x := range list {
0000000000000000000000000000000000000000;;				// Deviating from the spec. See match_test.go for details.
0000000000000000000000000000000000000000;;				if scriptID(x.script) == t.script {
0000000000000000000000000000000000000000;;					t.setUndefinedLang(langID(x.lang))
0000000000000000000000000000000000000000;;					return t, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.lang != 0 {
0000000000000000000000000000000000000000;;			// Search matches for lang-script and lang-region, where lang != und.
0000000000000000000000000000000000000000;;			if t.lang < langNoIndexOffset {
0000000000000000000000000000000000000000;;				x := likelyLang[t.lang]
0000000000000000000000000000000000000000;;				if x.flags&isList != 0 {
0000000000000000000000000000000000000000;;					list := likelyLangList[x.region : x.region+uint16(x.script)]
0000000000000000000000000000000000000000;;					if t.script != 0 {
0000000000000000000000000000000000000000;;						for _, x := range list {
0000000000000000000000000000000000000000;;							if scriptID(x.script) == t.script && x.flags&scriptInFrom != 0 {
0000000000000000000000000000000000000000;;								t.setUndefinedRegion(regionID(x.region))
0000000000000000000000000000000000000000;;								return t, nil
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else if t.region != 0 {
0000000000000000000000000000000000000000;;						count := 0
0000000000000000000000000000000000000000;;						goodScript := true
0000000000000000000000000000000000000000;;						tt := t
0000000000000000000000000000000000000000;;						for _, x := range list {
0000000000000000000000000000000000000000;;							// We visit all entries for which the script was not
0000000000000000000000000000000000000000;;							// defined, including the ones where the region was not
0000000000000000000000000000000000000000;;							// defined. This allows for proper disambiguation within
0000000000000000000000000000000000000000;;							// regions.
0000000000000000000000000000000000000000;;							if x.flags&scriptInFrom == 0 && t.region.contains(regionID(x.region)) {
0000000000000000000000000000000000000000;;								tt.region = regionID(x.region)
0000000000000000000000000000000000000000;;								tt.setUndefinedScript(scriptID(x.script))
0000000000000000000000000000000000000000;;								goodScript = goodScript && tt.script == scriptID(x.script)
0000000000000000000000000000000000000000;;								count++
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if count == 1 {
0000000000000000000000000000000000000000;;							return tt, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// Even if we fail to find a unique Region, we might have
0000000000000000000000000000000000000000;;						// an unambiguous script.
0000000000000000000000000000000000000000;;						if goodScript {
0000000000000000000000000000000000000000;;							t.script = tt.script
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Search matches for und-script.
0000000000000000000000000000000000000000;;			if t.script != 0 {
0000000000000000000000000000000000000000;;				x := likelyScript[t.script]
0000000000000000000000000000000000000000;;				if x.region != 0 {
0000000000000000000000000000000000000000;;					t.setUndefinedRegion(regionID(x.region))
0000000000000000000000000000000000000000;;					t.setUndefinedLang(langID(x.lang))
0000000000000000000000000000000000000000;;					return t, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Search matches for und-region. If und-script-region exists, it would
0000000000000000000000000000000000000000;;			// have been found earlier.
0000000000000000000000000000000000000000;;			if t.region != 0 {
0000000000000000000000000000000000000000;;				if i := regionInclusion[t.region]; i < nRegionGroups {
0000000000000000000000000000000000000000;;					x := likelyRegionGroup[i]
0000000000000000000000000000000000000000;;					if x.region != 0 {
0000000000000000000000000000000000000000;;						t.setUndefinedLang(langID(x.lang))
0000000000000000000000000000000000000000;;						t.setUndefinedScript(scriptID(x.script))
0000000000000000000000000000000000000000;;						t.region = regionID(x.region)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					x := likelyRegion[t.region]
0000000000000000000000000000000000000000;;					if x.flags&isList != 0 {
0000000000000000000000000000000000000000;;						x = likelyRegionList[x.lang]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if x.script != 0 && x.flags != scriptInFrom {
0000000000000000000000000000000000000000;;						t.setUndefinedLang(langID(x.lang))
0000000000000000000000000000000000000000;;						t.setUndefinedScript(scriptID(x.script))
0000000000000000000000000000000000000000;;						return t, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Search matches for lang.
0000000000000000000000000000000000000000;;		if t.lang < langNoIndexOffset {
0000000000000000000000000000000000000000;;			x := likelyLang[t.lang]
0000000000000000000000000000000000000000;;			if x.flags&isList != 0 {
0000000000000000000000000000000000000000;;				x = likelyLangList[x.region]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x.region != 0 {
0000000000000000000000000000000000000000;;				t.setUndefinedScript(scriptID(x.script))
0000000000000000000000000000000000000000;;				t.setUndefinedRegion(regionID(x.region))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			specializeRegion(&t)
0000000000000000000000000000000000000000;;			if t.lang == 0 {
0000000000000000000000000000000000000000;;				t.lang = _en // default language
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, ErrMissingLikelyTagsData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Tag) setTagsFrom(id Tag) {
0000000000000000000000000000000000000000;;		t.lang = id.lang
0000000000000000000000000000000000000000;;		t.script = id.script
0000000000000000000000000000000000000000;;		t.region = id.region
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// minimize removes the region or script subtags from t such that
0000000000000000000000000000000000000000;;	// t.addLikelySubtags() == t.minimize().addLikelySubtags().
0000000000000000000000000000000000000000;;	func (t Tag) minimize() (Tag, error) {
0000000000000000000000000000000000000000;;		t, err := minimizeTags(t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return t, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.remakeString()
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// minimizeTags mimics the behavior of the ICU 51 C implementation.
0000000000000000000000000000000000000000;;	func minimizeTags(t Tag) (Tag, error) {
0000000000000000000000000000000000000000;;		if t.equalTags(und) {
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		max, err := addTags(t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return t, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, id := range [...]Tag{
0000000000000000000000000000000000000000;;			{lang: t.lang},
0000000000000000000000000000000000000000;;			{lang: t.lang, region: t.region},
0000000000000000000000000000000000000000;;			{lang: t.lang, script: t.script},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			if x, err := addTags(id); err == nil && max.equalTags(x) {
0000000000000000000000000000000000000000;;				t.setTagsFrom(id)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tag Matching
0000000000000000000000000000000000000000;;	// CLDR defines an algorithm for finding the best match between two sets of language
0000000000000000000000000000000000000000;;	// tags. The basic algorithm defines how to score a possible match and then find
0000000000000000000000000000000000000000;;	// the match with the best score
0000000000000000000000000000000000000000;;	// (see http://www.unicode.org/reports/tr35/#LanguageMatching).
0000000000000000000000000000000000000000;;	// Using scoring has several disadvantages. The scoring obfuscates the importance of
0000000000000000000000000000000000000000;;	// the various factors considered, making the algorithm harder to understand. Using
0000000000000000000000000000000000000000;;	// scoring also requires the full score to be computed for each pair of tags.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// We will use a different algorithm which aims to have the following properties:
0000000000000000000000000000000000000000;;	// - clarity on the precedence of the various selection factors, and
0000000000000000000000000000000000000000;;	// - improved performance by allowing early termination of a comparison.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Matching algorithm (overview)
0000000000000000000000000000000000000000;;	// Input:
0000000000000000000000000000000000000000;;	//   - supported: a set of supported tags
0000000000000000000000000000000000000000;;	//   - default:   the default tag to return in case there is no match
0000000000000000000000000000000000000000;;	//   - desired:   list of desired tags, ordered by preference, starting with
0000000000000000000000000000000000000000;;	//                the most-preferred.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Algorithm:
0000000000000000000000000000000000000000;;	//   1) Set the best match to the lowest confidence level
0000000000000000000000000000000000000000;;	//   2) For each tag in "desired":
0000000000000000000000000000000000000000;;	//     a) For each tag in "supported":
0000000000000000000000000000000000000000;;	//        1) compute the match between the two tags.
0000000000000000000000000000000000000000;;	//        2) if the match is better than the previous best match, replace it
0000000000000000000000000000000000000000;;	//           with the new match. (see next section)
0000000000000000000000000000000000000000;;	//     b) if the current best match is above a certain threshold, return this
0000000000000000000000000000000000000000;;	//        match without proceeding to the next tag in "desired". [See Note 1]
0000000000000000000000000000000000000000;;	//   3) If the best match so far is below a certain threshold, return "default".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Ranking:
0000000000000000000000000000000000000000;;	// We use two phases to determine whether one pair of tags are a better match
0000000000000000000000000000000000000000;;	// than another pair of tags. First, we determine a rough confidence level. If the
0000000000000000000000000000000000000000;;	// levels are different, the one with the highest confidence wins.
0000000000000000000000000000000000000000;;	// Second, if the rough confidence levels are identical, we use a set of tie-breaker
0000000000000000000000000000000000000000;;	// rules.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The confidence level of matching a pair of tags is determined by finding the
0000000000000000000000000000000000000000;;	// lowest confidence level of any matches of the corresponding subtags (the
0000000000000000000000000000000000000000;;	// result is deemed as good as its weakest link).
0000000000000000000000000000000000000000;;	// We define the following levels:
0000000000000000000000000000000000000000;;	//   Exact    - An exact match of a subtag, before adding likely subtags.
0000000000000000000000000000000000000000;;	//   MaxExact - An exact match of a subtag, after adding likely subtags.
0000000000000000000000000000000000000000;;	//              [See Note 2].
0000000000000000000000000000000000000000;;	//   High     - High level of mutual intelligibility between different subtag
0000000000000000000000000000000000000000;;	//              variants.
0000000000000000000000000000000000000000;;	//   Low      - Low level of mutual intelligibility between different subtag
0000000000000000000000000000000000000000;;	//              variants.
0000000000000000000000000000000000000000;;	//   No       - No mutual intelligibility.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following levels can occur for each type of subtag:
0000000000000000000000000000000000000000;;	//   Base:    Exact, MaxExact, High, Low, No
0000000000000000000000000000000000000000;;	//   Script:  Exact, MaxExact [see Note 3], Low, No
0000000000000000000000000000000000000000;;	//   Region:  Exact, MaxExact, High
0000000000000000000000000000000000000000;;	//   Variant: Exact, High
0000000000000000000000000000000000000000;;	//   Private: Exact, No
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Any result with a confidence level of Low or higher is deemed a possible match.
0000000000000000000000000000000000000000;;	// Once a desired tag matches any of the supported tags with a level of MaxExact
0000000000000000000000000000000000000000;;	// or higher, the next desired tag is not considered (see Step 2.b).
0000000000000000000000000000000000000000;;	// Note that CLDR provides languageMatching data that defines close equivalence
0000000000000000000000000000000000000000;;	// classes for base languages, scripts and regions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Tie-breaking
0000000000000000000000000000000000000000;;	// If we get the same confidence level for two matches, we apply a sequence of
0000000000000000000000000000000000000000;;	// tie-breaking rules. The first that succeeds defines the result. The rules are
0000000000000000000000000000000000000000;;	// applied in the following order.
0000000000000000000000000000000000000000;;	//   1) Original language was defined and was identical.
0000000000000000000000000000000000000000;;	//   2) Original region was defined and was identical.
0000000000000000000000000000000000000000;;	//   3) Distance between two maximized regions was the smallest.
0000000000000000000000000000000000000000;;	//   4) Original script was defined and was identical.
0000000000000000000000000000000000000000;;	//   5) Distance from want tag to have tag using the parent relation [see Note 5.]
0000000000000000000000000000000000000000;;	// If there is still no winner after these rules are applied, the first match
0000000000000000000000000000000000000000;;	// found wins.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Notes:
0000000000000000000000000000000000000000;;	// [1] Note that even if we may not have a perfect match, if a match is above a
0000000000000000000000000000000000000000;;	//     certain threshold, it is considered a better match than any other match
0000000000000000000000000000000000000000;;	//     to a tag later in the list of preferred language tags.
0000000000000000000000000000000000000000;;	// [2] In practice, as matching of Exact is done in a separate phase from
0000000000000000000000000000000000000000;;	//     matching the other levels, we reuse the Exact level to mean MaxExact in
0000000000000000000000000000000000000000;;	//     the second phase. As a consequence, we only need the levels defined by
0000000000000000000000000000000000000000;;	//     the Confidence type. The MaxExact confidence level is mapped to High in
0000000000000000000000000000000000000000;;	//     the public API.
0000000000000000000000000000000000000000;;	// [3] We do not differentiate between maximized script values that were derived
0000000000000000000000000000000000000000;;	//     from suppressScript versus most likely tag data. We determined that in
0000000000000000000000000000000000000000;;	//     ranking the two, one ranks just after the other. Moreover, the two cannot
0000000000000000000000000000000000000000;;	//     occur concurrently. As a consequence, they are identical for practical
0000000000000000000000000000000000000000;;	//     purposes.
0000000000000000000000000000000000000000;;	// [4] In case of deprecated, macro-equivalents and legacy mappings, we assign
0000000000000000000000000000000000000000;;	//     the MaxExact level to allow iw vs he to still be a closer match than
0000000000000000000000000000000000000000;;	//     en-AU vs en-US, for example.
0000000000000000000000000000000000000000;;	// [5] In CLDR a locale inherits fields that are unspecified for this locale
0000000000000000000000000000000000000000;;	//     from its parent. Therefore, if a locale is a parent of another locale,
0000000000000000000000000000000000000000;;	//     it is a strong measure for closeness, especially when no other tie
0000000000000000000000000000000000000000;;	//     breaker rule applies. One could also argue it is inconsistent, for
0000000000000000000000000000000000000000;;	//     example, when pt-AO matches pt (which CLDR equates with pt-BR), even
0000000000000000000000000000000000000000;;	//     though its parent is pt-PT according to the inheritance rules.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Implementation Details:
0000000000000000000000000000000000000000;;	// There are several performance considerations worth pointing out. Most notably,
0000000000000000000000000000000000000000;;	// we preprocess as much as possible (within reason) at the time of creation of a
0000000000000000000000000000000000000000;;	// matcher. This includes:
0000000000000000000000000000000000000000;;	//   - creating a per-language map, which includes data for the raw base language
0000000000000000000000000000000000000000;;	//     and its canonicalized variant (if applicable),
0000000000000000000000000000000000000000;;	//   - expanding entries for the equivalence classes defined in CLDR's
0000000000000000000000000000000000000000;;	//     languageMatch data.
0000000000000000000000000000000000000000;;	// The per-language map ensures that typically only a very small number of tags
0000000000000000000000000000000000000000;;	// need to be considered. The pre-expansion of canonicalized subtags and
0000000000000000000000000000000000000000;;	// equivalence classes reduces the amount of map lookups that need to be done at
0000000000000000000000000000000000000000;;	// runtime.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matcher keeps a set of supported language tags, indexed by language.
0000000000000000000000000000000000000000;;	type matcher struct {
0000000000000000000000000000000000000000;;		default_     *haveTag
0000000000000000000000000000000000000000;;		index        map[langID]*matchHeader
0000000000000000000000000000000000000000;;		passSettings bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matchHeader has the lists of tags for exact matches and matches based on
0000000000000000000000000000000000000000;;	// maximized and canonicalized tags for a given language.
0000000000000000000000000000000000000000;;	type matchHeader struct {
0000000000000000000000000000000000000000;;		exact []haveTag
0000000000000000000000000000000000000000;;		max   []haveTag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// haveTag holds a supported Tag and its maximized script and region. The maximized
0000000000000000000000000000000000000000;;	// or canonicalized language is not stored as it is not needed during matching.
0000000000000000000000000000000000000000;;	type haveTag struct {
0000000000000000000000000000000000000000;;		tag Tag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// index of this tag in the original list of supported tags.
0000000000000000000000000000000000000000;;		index int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// conf is the maximum confidence that can result from matching this haveTag.
0000000000000000000000000000000000000000;;		// When conf < Exact this means it was inserted after applying a CLDR equivalence rule.
0000000000000000000000000000000000000000;;		conf Confidence
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maximized region and script.
0000000000000000000000000000000000000000;;		maxRegion regionID
0000000000000000000000000000000000000000;;		maxScript scriptID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// altScript may be checked as an alternative match to maxScript. If altScript
0000000000000000000000000000000000000000;;		// matches, the confidence level for this match is Low. Theoretically there
0000000000000000000000000000000000000000;;		// could be multiple alternative scripts. This does not occur in practice.
0000000000000000000000000000000000000000;;		altScript scriptID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nextMax is the index of the next haveTag with the same maximized tags.
0000000000000000000000000000000000000000;;		nextMax uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeHaveTag(tag Tag, index int) (haveTag, langID) {
0000000000000000000000000000000000000000;;		max := tag
0000000000000000000000000000000000000000;;		if tag.lang != 0 {
0000000000000000000000000000000000000000;;			max, _ = max.canonicalize(All)
0000000000000000000000000000000000000000;;			max, _ = addTags(max)
0000000000000000000000000000000000000000;;			max.remakeString()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return haveTag{tag, index, Exact, max.region, max.script, altScript(max.lang, max.script), 0}, max.lang
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// altScript returns an alternative script that may match the given script with
0000000000000000000000000000000000000000;;	// a low confidence.  At the moment, the langMatch data allows for at most one
0000000000000000000000000000000000000000;;	// script to map to another and we rely on this to keep the code simple.
0000000000000000000000000000000000000000;;	func altScript(l langID, s scriptID) scriptID {
0000000000000000000000000000000000000000;;		for _, alt := range matchScript {
0000000000000000000000000000000000000000;;			if (alt.lang == 0 || langID(alt.lang) == l) && scriptID(alt.have) == s {
0000000000000000000000000000000000000000;;				return scriptID(alt.want)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addIfNew adds a haveTag to the list of tags only if it is a unique tag.
0000000000000000000000000000000000000000;;	// Tags that have the same maximized values are linked by index.
0000000000000000000000000000000000000000;;	func (h *matchHeader) addIfNew(n haveTag, exact bool) {
0000000000000000000000000000000000000000;;		// Don't add new exact matches.
0000000000000000000000000000000000000000;;		for _, v := range h.exact {
0000000000000000000000000000000000000000;;			if v.tag.equalsRest(n.tag) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if exact {
0000000000000000000000000000000000000000;;			h.exact = append(h.exact, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Allow duplicate maximized tags, but create a linked list to allow quickly
0000000000000000000000000000000000000000;;		// comparing the equivalents and bail out.
0000000000000000000000000000000000000000;;		for i, v := range h.max {
0000000000000000000000000000000000000000;;			if v.maxScript == n.maxScript &&
0000000000000000000000000000000000000000;;				v.maxRegion == n.maxRegion &&
0000000000000000000000000000000000000000;;				v.tag.variantOrPrivateTagStr() == n.tag.variantOrPrivateTagStr() {
0000000000000000000000000000000000000000;;				for h.max[i].nextMax != 0 {
0000000000000000000000000000000000000000;;					i = int(h.max[i].nextMax)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				h.max[i].nextMax = uint16(len(h.max))
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.max = append(h.max, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// header returns the matchHeader for the given language. It creates one if
0000000000000000000000000000000000000000;;	// it doesn't already exist.
0000000000000000000000000000000000000000;;	func (m *matcher) header(l langID) *matchHeader {
0000000000000000000000000000000000000000;;		if h := m.index[l]; h != nil {
0000000000000000000000000000000000000000;;			return h
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := &matchHeader{}
0000000000000000000000000000000000000000;;		m.index[l] = h
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newMatcher builds an index for the given supported tags and returns it as
0000000000000000000000000000000000000000;;	// a matcher. It also expands the index by considering various equivalence classes
0000000000000000000000000000000000000000;;	// for a given tag.
0000000000000000000000000000000000000000;;	func newMatcher(supported []Tag) *matcher {
0000000000000000000000000000000000000000;;		m := &matcher{
0000000000000000000000000000000000000000;;			index: make(map[langID]*matchHeader),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(supported) == 0 {
0000000000000000000000000000000000000000;;			m.default_ = &haveTag{}
0000000000000000000000000000000000000000;;			return m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add supported languages to the index. Add exact matches first to give
0000000000000000000000000000000000000000;;		// them precedence.
0000000000000000000000000000000000000000;;		for i, tag := range supported {
0000000000000000000000000000000000000000;;			pair, _ := makeHaveTag(tag, i)
0000000000000000000000000000000000000000;;			m.header(tag.lang).addIfNew(pair, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.default_ = &m.header(supported[0].lang).exact[0]
0000000000000000000000000000000000000000;;		for i, tag := range supported {
0000000000000000000000000000000000000000;;			pair, max := makeHaveTag(tag, i)
0000000000000000000000000000000000000000;;			if max != tag.lang {
0000000000000000000000000000000000000000;;				m.header(max).addIfNew(pair, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update is used to add indexes in the map for equivalent languages.
0000000000000000000000000000000000000000;;		// If force is true, the update will also apply to derived entries. To
0000000000000000000000000000000000000000;;		// avoid applying a "transitive closure", use false.
0000000000000000000000000000000000000000;;		update := func(want, have uint16, conf Confidence, force bool) {
0000000000000000000000000000000000000000;;			if hh := m.index[langID(have)]; hh != nil {
0000000000000000000000000000000000000000;;				if !force && len(hh.exact) == 0 {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				hw := m.header(langID(want))
0000000000000000000000000000000000000000;;				for _, v := range hh.max {
0000000000000000000000000000000000000000;;					if conf < v.conf {
0000000000000000000000000000000000000000;;						v.conf = conf
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					v.nextMax = 0 // this value needs to be recomputed
0000000000000000000000000000000000000000;;					if v.altScript != 0 {
0000000000000000000000000000000000000000;;						v.altScript = altScript(langID(want), v.maxScript)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					hw.addIfNew(v, conf == Exact && len(hh.exact) > 0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add entries for languages with mutual intelligibility as defined by CLDR's
0000000000000000000000000000000000000000;;		// languageMatch data.
0000000000000000000000000000000000000000;;		for _, ml := range matchLang {
0000000000000000000000000000000000000000;;			update(ml.want, ml.have, Confidence(ml.conf), false)
0000000000000000000000000000000000000000;;			if !ml.oneway {
0000000000000000000000000000000000000000;;				update(ml.have, ml.want, Confidence(ml.conf), false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add entries for possible canonicalizations. This is an optimization to
0000000000000000000000000000000000000000;;		// ensure that only one map lookup needs to be done at runtime per desired tag.
0000000000000000000000000000000000000000;;		// First we match deprecated equivalents. If they are perfect equivalents
0000000000000000000000000000000000000000;;		// (their canonicalization simply substitutes a different language code, but
0000000000000000000000000000000000000000;;		// nothing else), the match confidence is Exact, otherwise it is High.
0000000000000000000000000000000000000000;;		for i, lm := range langAliasMap {
0000000000000000000000000000000000000000;;			if lm.from == _sh {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If deprecated codes match and there is no fiddling with the script or
0000000000000000000000000000000000000000;;			// or region, we consider it an exact match.
0000000000000000000000000000000000000000;;			conf := Exact
0000000000000000000000000000000000000000;;			if langAliasTypes[i] != langMacro {
0000000000000000000000000000000000000000;;				if !isExactEquivalent(langID(lm.from)) {
0000000000000000000000000000000000000000;;					conf = High
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				update(lm.to, lm.from, conf, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			update(lm.from, lm.to, conf, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getBest gets the best matching tag in m for any of the given tags, taking into
0000000000000000000000000000000000000000;;	// account the order of preference of the given tags.
0000000000000000000000000000000000000000;;	func (m *matcher) getBest(want ...Tag) (got *haveTag, orig Tag, c Confidence) {
0000000000000000000000000000000000000000;;		best := bestMatch{}
0000000000000000000000000000000000000000;;		for _, w := range want {
0000000000000000000000000000000000000000;;			var max Tag
0000000000000000000000000000000000000000;;			// Check for exact match first.
0000000000000000000000000000000000000000;;			h := m.index[w.lang]
0000000000000000000000000000000000000000;;			if w.lang != 0 {
0000000000000000000000000000000000000000;;				// Base language is defined.
0000000000000000000000000000000000000000;;				if h == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i := range h.exact {
0000000000000000000000000000000000000000;;					have := &h.exact[i]
0000000000000000000000000000000000000000;;					if have.tag.equalsRest(w) {
0000000000000000000000000000000000000000;;						return have, w, Exact
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				max, _ = w.canonicalize(Legacy | Deprecated)
0000000000000000000000000000000000000000;;				max, _ = addTags(max)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Base language is not defined.
0000000000000000000000000000000000000000;;				if h != nil {
0000000000000000000000000000000000000000;;					for i := range h.exact {
0000000000000000000000000000000000000000;;						have := &h.exact[i]
0000000000000000000000000000000000000000;;						if have.tag.equalsRest(w) {
0000000000000000000000000000000000000000;;							return have, w, Exact
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if w.script == 0 && w.region == 0 {
0000000000000000000000000000000000000000;;					// We skip all tags matching und for approximate matching, including
0000000000000000000000000000000000000000;;					// private tags.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				max, _ = addTags(w)
0000000000000000000000000000000000000000;;				if h = m.index[max.lang]; h == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check for match based on maximized tag.
0000000000000000000000000000000000000000;;			for i := range h.max {
0000000000000000000000000000000000000000;;				have := &h.max[i]
0000000000000000000000000000000000000000;;				best.update(have, w, max.script, max.region)
0000000000000000000000000000000000000000;;				if best.conf == Exact {
0000000000000000000000000000000000000000;;					for have.nextMax != 0 {
0000000000000000000000000000000000000000;;						have = &h.max[have.nextMax]
0000000000000000000000000000000000000000;;						best.update(have, w, max.script, max.region)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return best.have, best.want, High
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if best.conf <= No {
0000000000000000000000000000000000000000;;			if len(want) != 0 {
0000000000000000000000000000000000000000;;				return nil, want[0], No
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, Tag{}, No
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return best.have, best.want, best.conf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bestMatch accumulates the best match so far.
0000000000000000000000000000000000000000;;	type bestMatch struct {
0000000000000000000000000000000000000000;;		have *haveTag
0000000000000000000000000000000000000000;;		want Tag
0000000000000000000000000000000000000000;;		conf Confidence
0000000000000000000000000000000000000000;;		// Cached results from applying tie-breaking rules.
0000000000000000000000000000000000000000;;		origLang   bool
0000000000000000000000000000000000000000;;		origReg    bool
0000000000000000000000000000000000000000;;		regDist    uint8
0000000000000000000000000000000000000000;;		origScript bool
0000000000000000000000000000000000000000;;		parentDist uint8 // 255 if have is not an ancestor of want tag.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// update updates the existing best match if the new pair is considered to be a
0000000000000000000000000000000000000000;;	// better match.
0000000000000000000000000000000000000000;;	// To determine if the given pair is a better match, it first computes the rough
0000000000000000000000000000000000000000;;	// confidence level. If this surpasses the current match, it will replace it and
0000000000000000000000000000000000000000;;	// update the tie-breaker rule cache. If there is a tie, it proceeds with applying
0000000000000000000000000000000000000000;;	// a series of tie-breaker rules. If there is no conclusive winner after applying
0000000000000000000000000000000000000000;;	// the tie-breaker rules, it leaves the current match as the preferred match.
0000000000000000000000000000000000000000;;	func (m *bestMatch) update(have *haveTag, tag Tag, maxScript scriptID, maxRegion regionID) {
0000000000000000000000000000000000000000;;		// Bail if the maximum attainable confidence is below that of the current best match.
0000000000000000000000000000000000000000;;		c := have.conf
0000000000000000000000000000000000000000;;		if c < m.conf {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if have.maxScript != maxScript {
0000000000000000000000000000000000000000;;			// There is usually very little comprehension between different scripts.
0000000000000000000000000000000000000000;;			// In a few cases there may still be Low comprehension. This possibility is
0000000000000000000000000000000000000000;;			// pre-computed and stored in have.altScript.
0000000000000000000000000000000000000000;;			if Low < m.conf || have.altScript != maxScript {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c = Low
0000000000000000000000000000000000000000;;		} else if have.maxRegion != maxRegion {
0000000000000000000000000000000000000000;;			// There is usually a small difference between languages across regions.
0000000000000000000000000000000000000000;;			// We use the region distance (below) to disambiguate between equal matches.
0000000000000000000000000000000000000000;;			if High < c {
0000000000000000000000000000000000000000;;				c = High
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We store the results of the computations of the tie-breaker rules along
0000000000000000000000000000000000000000;;		// with the best match. There is no need to do the checks once we determine
0000000000000000000000000000000000000000;;		// we have a winner, but we do still need to do the tie-breaker computations.
0000000000000000000000000000000000000000;;		// We use "beaten" to keep track if we still need to do the checks.
0000000000000000000000000000000000000000;;		beaten := false // true if the new pair defeats the current one.
0000000000000000000000000000000000000000;;		if c != m.conf {
0000000000000000000000000000000000000000;;			if c < m.conf {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			beaten = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tie-breaker rules:
0000000000000000000000000000000000000000;;		// We prefer if the pre-maximized language was specified and identical.
0000000000000000000000000000000000000000;;		origLang := have.tag.lang == tag.lang && tag.lang != 0
0000000000000000000000000000000000000000;;		if !beaten && m.origLang != origLang {
0000000000000000000000000000000000000000;;			if m.origLang {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			beaten = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We prefer if the pre-maximized region was specified and identical.
0000000000000000000000000000000000000000;;		origReg := have.tag.region == tag.region && tag.region != 0
0000000000000000000000000000000000000000;;		if !beaten && m.origReg != origReg {
0000000000000000000000000000000000000000;;			if m.origReg {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			beaten = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Next we prefer smaller distances between regions, as defined by regionDist.
0000000000000000000000000000000000000000;;		regDist := regionDist(have.maxRegion, maxRegion, tag.lang)
0000000000000000000000000000000000000000;;		if !beaten && m.regDist != regDist {
0000000000000000000000000000000000000000;;			if regDist > m.regDist {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			beaten = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Next we prefer if the pre-maximized script was specified and identical.
0000000000000000000000000000000000000000;;		origScript := have.tag.script == tag.script && tag.script != 0
0000000000000000000000000000000000000000;;		if !beaten && m.origScript != origScript {
0000000000000000000000000000000000000000;;			if m.origScript {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			beaten = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finally we prefer tags which have a closer parent relationship.
0000000000000000000000000000000000000000;;		parentDist := parentDistance(have.tag.region, tag)
0000000000000000000000000000000000000000;;		if !beaten && m.parentDist != parentDist {
0000000000000000000000000000000000000000;;			if parentDist > m.parentDist {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			beaten = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update m to the newly found best match.
0000000000000000000000000000000000000000;;		if beaten {
0000000000000000000000000000000000000000;;			m.have = have
0000000000000000000000000000000000000000;;			m.want = tag
0000000000000000000000000000000000000000;;			m.conf = c
0000000000000000000000000000000000000000;;			m.origLang = origLang
0000000000000000000000000000000000000000;;			m.origReg = origReg
0000000000000000000000000000000000000000;;			m.origScript = origScript
0000000000000000000000000000000000000000;;			m.regDist = regDist
0000000000000000000000000000000000000000;;			m.parentDist = parentDist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parentDistance returns the number of times Parent must be called before the
0000000000000000000000000000000000000000;;	// regions match. It is assumed that it has already been checked that lang and
0000000000000000000000000000000000000000;;	// script are identical. If haveRegion does not occur in the ancestor chain of
0000000000000000000000000000000000000000;;	// tag, it returns 255.
0000000000000000000000000000000000000000;;	func parentDistance(haveRegion regionID, tag Tag) uint8 {
0000000000000000000000000000000000000000;;		p := tag.Parent()
0000000000000000000000000000000000000000;;		d := uint8(1)
0000000000000000000000000000000000000000;;		for haveRegion != p.region {
0000000000000000000000000000000000000000;;			if p.region == 0 {
0000000000000000000000000000000000000000;;				return 255
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p = p.Parent()
0000000000000000000000000000000000000000;;			d++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// regionDist wraps regionDistance with some exceptions to the algorithmic distance.
0000000000000000000000000000000000000000;;	func regionDist(a, b regionID, lang langID) uint8 {
0000000000000000000000000000000000000000;;		if lang == _en {
0000000000000000000000000000000000000000;;			// Two variants of non-US English are close to each other, regardless of distance.
0000000000000000000000000000000000000000;;			if a != _US && b != _US {
0000000000000000000000000000000000000000;;				return 2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint8(regionDistance(a, b))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// regionDistance computes the distance between two regions based on the
0000000000000000000000000000000000000000;;	// distance in the graph of region containments as defined in CLDR. It iterates
0000000000000000000000000000000000000000;;	// over increasingly inclusive sets of groups, represented as bit vectors, until
0000000000000000000000000000000000000000;;	// the source bit vector has bits in common with the destination vector.
0000000000000000000000000000000000000000;;	func regionDistance(a, b regionID) int {
0000000000000000000000000000000000000000;;		if a == b {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, q := regionInclusion[a], regionInclusion[b]
0000000000000000000000000000000000000000;;		if p < nRegionGroups {
0000000000000000000000000000000000000000;;			p, q = q, p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		set := regionInclusionBits
0000000000000000000000000000000000000000;;		if q < nRegionGroups && set[p]&(1<<q) != 0 {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d := 2
0000000000000000000000000000000000000000;;		for goal := set[q]; set[p]&goal == 0; p = regionInclusionNext[p] {
0000000000000000000000000000000000000000;;			d++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t Tag) variants() string {
0000000000000000000000000000000000000000;;		if t.pVariant == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.str[t.pVariant:t.pExt]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// variantOrPrivateTagStr returns variants or private use tags.
0000000000000000000000000000000000000000;;	func (t Tag) variantOrPrivateTagStr() string {
0000000000000000000000000000000000000000;;		if t.pExt > 0 {
0000000000000000000000000000000000000000;;			return t.str[t.pVariant:t.pExt]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.str[t.pVariant:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// equalsRest compares everything except the language.
0000000000000000000000000000000000000000;;	func (a Tag) equalsRest(b Tag) bool {
0000000000000000000000000000000000000000;;		// TODO: don't include extensions in this comparison. To do this efficiently,
0000000000000000000000000000000000000000;;		// though, we should handle private tags separately.
0000000000000000000000000000000000000000;;		return a.script == b.script && a.region == b.region && a.variantOrPrivateTagStr() == b.variantOrPrivateTagStr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isExactEquivalent returns true if canonicalizing the language will not alter
0000000000000000000000000000000000000000;;	// the script or region of a tag.
0000000000000000000000000000000000000000;;	func isExactEquivalent(l langID) bool {
0000000000000000000000000000000000000000;;		for _, o := range notEquivalent {
0000000000000000000000000000000000000000;;			if o == l {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var notEquivalent []langID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// Create a list of all languages for which canonicalization may alter the
0000000000000000000000000000000000000000;;		// script or region.
0000000000000000000000000000000000000000;;		for _, lm := range langAliasMap {
0000000000000000000000000000000000000000;;			tag := Tag{lang: langID(lm.from)}
0000000000000000000000000000000000000000;;			if tag, _ = tag.canonicalize(All); tag.script != 0 || tag.region != 0 {
0000000000000000000000000000000000000000;;				notEquivalent = append(notEquivalent, langID(lm.from))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
