0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// +build ignore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file generates derivative tables based on the language package itself.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/gen"
0000000000000000000000000000000000000000;;		"golang.org/x/text/language"
0000000000000000000000000000000000000000;;		"golang.org/x/text/unicode/cldr"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		test = flag.Bool("test", false,
0000000000000000000000000000000000000000;;			"test existing tables; can be used to compare web data with package data.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		draft = flag.String("draft",
0000000000000000000000000000000000000000;;			"contributed",
0000000000000000000000000000000000000000;;			`Minimal draft requirements (approved, contributed, provisional, unconfirmed).`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		gen.Init()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read the CLDR zip file.
0000000000000000000000000000000000000000;;		r := gen.OpenCLDRCoreZip()
0000000000000000000000000000000000000000;;		defer r.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := &cldr.Decoder{}
0000000000000000000000000000000000000000;;		data, err := d.DecodeZip(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatalf("DecodeZip: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := gen.NewCodeWriter()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err = w.WriteGo(buf, "language"); err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Error formatting file index.go: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Since we're generating a table for our own package we need to rewrite
0000000000000000000000000000000000000000;;			// doing the equivalent of go fmt -r 'language.b -> b'. Using
0000000000000000000000000000000000000000;;			// bytes.Replace will do.
0000000000000000000000000000000000000000;;			out := bytes.Replace(buf.Bytes(), []byte("language."), nil, -1)
0000000000000000000000000000000000000000;;			if err := ioutil.WriteFile("index.go", out, 0600); err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Could not create file index.go: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := map[language.Tag]bool{}
0000000000000000000000000000000000000000;;		for _, lang := range data.Locales() {
0000000000000000000000000000000000000000;;			// We include all locales unconditionally to be consistent with en_US.
0000000000000000000000000000000000000000;;			// We want en_US, even though it has no data associated with it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: put any of the languages for which no data exists at the end
0000000000000000000000000000000000000000;;			// of the index. This allows all components based on ICU to use that
0000000000000000000000000000000000000000;;			// as the cutoff point.
0000000000000000000000000000000000000000;;			// if x := data.RawLDML(lang); false ||
0000000000000000000000000000000000000000;;			// 	x.LocaleDisplayNames != nil ||
0000000000000000000000000000000000000000;;			// 	x.Characters != nil ||
0000000000000000000000000000000000000000;;			// 	x.Delimiters != nil ||
0000000000000000000000000000000000000000;;			// 	x.Measurement != nil ||
0000000000000000000000000000000000000000;;			// 	x.Dates != nil ||
0000000000000000000000000000000000000000;;			// 	x.Numbers != nil ||
0000000000000000000000000000000000000000;;			// 	x.Units != nil ||
0000000000000000000000000000000000000000;;			// 	x.ListPatterns != nil ||
0000000000000000000000000000000000000000;;			// 	x.Collations != nil ||
0000000000000000000000000000000000000000;;			// 	x.Segmentations != nil ||
0000000000000000000000000000000000000000;;			// 	x.Rbnf != nil ||
0000000000000000000000000000000000000000;;			// 	x.Annotations != nil ||
0000000000000000000000000000000000000000;;			// 	x.Metadata != nil {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: support POSIX natively, albeit non-standard.
0000000000000000000000000000000000000000;;			tag := language.Make(strings.Replace(lang, "_POSIX", "-u-va-posix", 1))
0000000000000000000000000000000000000000;;			m[tag] = true
0000000000000000000000000000000000000000;;			// }
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Include locales for plural rules, which uses a different structure.
0000000000000000000000000000000000000000;;		for _, plurals := range data.Supplemental().Plurals {
0000000000000000000000000000000000000000;;			for _, rules := range plurals.PluralRules {
0000000000000000000000000000000000000000;;				for _, lang := range strings.Split(rules.Locales, " ") {
0000000000000000000000000000000000000000;;					m[language.Make(lang)] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var core, special []language.Tag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for t := range m {
0000000000000000000000000000000000000000;;			if x := t.Extensions(); len(x) != 0 && fmt.Sprint(x) != "[u-va-posix]" {
0000000000000000000000000000000000000000;;				log.Fatalf("Unexpected extension %v in %v", x, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(t.Variants()) == 0 && len(t.Extensions()) == 0 {
0000000000000000000000000000000000000000;;				core = append(core, t)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				special = append(special, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.WriteComment(`
0000000000000000000000000000000000000000;;		NumCompactTags is the number of common tags. The maximum tag is
0000000000000000000000000000000000000000;;		NumCompactTags-1.`)
0000000000000000000000000000000000000000;;		w.WriteConst("NumCompactTags", len(core)+len(special))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Sort(byAlpha(special))
0000000000000000000000000000000000000000;;		w.WriteVar("specialTags", special)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: order by frequency?
0000000000000000000000000000000000000000;;		sort.Sort(byAlpha(core))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Size computations are just an estimate.
0000000000000000000000000000000000000000;;		w.Size += int(reflect.TypeOf(map[uint32]uint16{}).Size())
0000000000000000000000000000000000000000;;		w.Size += len(core) * 6 // size of uint32 and uint16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(w)
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "var coreTags = map[uint32]uint16{")
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "0x0: 0, // und")
0000000000000000000000000000000000000000;;		i := len(special) + 1 // Und and special tags already written.
0000000000000000000000000000000000000000;;		for _, t := range core {
0000000000000000000000000000000000000000;;			if t == language.Und {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprint(w.Hash, t, i)
0000000000000000000000000000000000000000;;			b, s, r := t.Raw()
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "0x%s%s%s: %d, // %s\n",
0000000000000000000000000000000000000000;;				getIndex(b, 3), // 3 is enough as it is guaranteed to be a compact number
0000000000000000000000000000000000000000;;				getIndex(s, 2),
0000000000000000000000000000000000000000;;				getIndex(r, 3),
0000000000000000000000000000000000000000;;				i, t)
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getIndex prints the subtag type and extracts its index of size nibble.
0000000000000000000000000000000000000000;;	// If the index is less than n nibbles, the result is prefixed with 0s.
0000000000000000000000000000000000000000;;	func getIndex(x interface{}, n int) string {
0000000000000000000000000000000000000000;;		s := fmt.Sprintf("%#v", x) // s is of form Type{typeID: 0x00}
0000000000000000000000000000000000000000;;		s = s[strings.Index(s, "0x")+2 : len(s)-1]
0000000000000000000000000000000000000000;;		return strings.Repeat("0", n-len(s)) + s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byAlpha []language.Tag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a byAlpha) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a byAlpha) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	func (a byAlpha) Less(i, j int) bool { return a[i].String() < a[j].String() }
