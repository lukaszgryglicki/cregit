0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	//go:generate go run maketables.go gen_common.go -output tables.go
0000000000000000000000000000000000000000;;	//go:generate go run gen_index.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package language implements BCP 47 language tags and related functionality.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Tag type, which is used to represent languages, is agnostic to the
0000000000000000000000000000000000000000;;	// meaning of its subtags. Tags are not fully canonicalized to preserve
0000000000000000000000000000000000000000;;	// information that may be valuable in certain contexts. As a consequence, two
0000000000000000000000000000000000000000;;	// different tags may represent identical languages.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Initializing language- or locale-specific components usually consists of
0000000000000000000000000000000000000000;;	// two steps. The first step is to select a display language based on the
0000000000000000000000000000000000000000;;	// preferred languages of the user and the languages supported by an application.
0000000000000000000000000000000000000000;;	// The second step is to create the language-specific services based on
0000000000000000000000000000000000000000;;	// this selection. Each is discussed in more details below.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Matching preferred against supported languages
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An application may support various languages. This list is typically limited
0000000000000000000000000000000000000000;;	// by the languages for which there exists translations of the user interface.
0000000000000000000000000000000000000000;;	// Similarly, a user may provide a list of preferred languages which is limited
0000000000000000000000000000000000000000;;	// by the languages understood by this user.
0000000000000000000000000000000000000000;;	// An application should use a Matcher to find the best supported language based
0000000000000000000000000000000000000000;;	// on the user's preferred list.
0000000000000000000000000000000000000000;;	// Matchers are aware of the intricacies of equivalence between languages.
0000000000000000000000000000000000000000;;	// The default Matcher implementation takes into account things such as
0000000000000000000000000000000000000000;;	// deprecated subtags, legacy tags, and mutual intelligibility between scripts
0000000000000000000000000000000000000000;;	// and languages.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A Matcher for English, Australian English, Danish, and standard Mandarin can
0000000000000000000000000000000000000000;;	// be defined as follows:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//		var matcher = language.NewMatcher([]language.Tag{
0000000000000000000000000000000000000000;;	//			language.English,   // The first language is used as fallback.
0000000000000000000000000000000000000000;;	// 			language.MustParse("en-AU"),
0000000000000000000000000000000000000000;;	//			language.Danish,
0000000000000000000000000000000000000000;;	//			language.Chinese,
0000000000000000000000000000000000000000;;	//		})
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following code selects the best match for someone speaking Spanish and
0000000000000000000000000000000000000000;;	// Norwegian:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 		preferred := []language.Tag{ language.Spanish, language.Norwegian }
0000000000000000000000000000000000000000;;	//		tag, _, _ := matcher.Match(preferred...)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In this case, the best match is Danish, as Danish is sufficiently a match to
0000000000000000000000000000000000000000;;	// Norwegian to not have to fall back to the default.
0000000000000000000000000000000000000000;;	// See ParseAcceptLanguage on how to handle the Accept-Language HTTP header.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Selecting language-specific services
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// One should always use the Tag returned by the Matcher to create an instance
0000000000000000000000000000000000000000;;	// of any of the language-specific services provided by the text repository.
0000000000000000000000000000000000000000;;	// This prevents the mixing of languages, such as having a different language for
0000000000000000000000000000000000000000;;	// messages and display names, as well as improper casing or sorting order for
0000000000000000000000000000000000000000;;	// the selected language.
0000000000000000000000000000000000000000;;	// Using the returned Tag also allows user-defined settings, such as collation
0000000000000000000000000000000000000000;;	// order or numbering system to be transparently passed as options.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If you have language-specific data in your application, however, it will in
0000000000000000000000000000000000000000;;	// most cases suffice to use the index returned by the matcher to identify
0000000000000000000000000000000000000000;;	// the user language.
0000000000000000000000000000000000000000;;	// The following loop provides an alternative in case this is not sufficient:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 		supported := map[language.Tag]data{
0000000000000000000000000000000000000000;;	//			language.English:            enData,
0000000000000000000000000000000000000000;;	// 			language.MustParse("en-AU"): enAUData,
0000000000000000000000000000000000000000;;	//			language.Danish:             daData,
0000000000000000000000000000000000000000;;	//			language.Chinese:            zhData,
0000000000000000000000000000000000000000;;	// 		}
0000000000000000000000000000000000000000;;	//		tag, _, _ := matcher.Match(preferred...)
0000000000000000000000000000000000000000;;	//		for ; tag != language.Und; tag = tag.Parent() {
0000000000000000000000000000000000000000;;	//			if v, ok := supported[tag]; ok {
0000000000000000000000000000000000000000;;	//				return v
0000000000000000000000000000000000000000;;	//			}
0000000000000000000000000000000000000000;;	//		}
0000000000000000000000000000000000000000;;	// 		return enData // should not reach here
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Repeatedly taking the Parent of the tag returned by Match will eventually
0000000000000000000000000000000000000000;;	// match one of the tags used to initialize the Matcher.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Canonicalization
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// By default, only legacy and deprecated tags are converted into their
0000000000000000000000000000000000000000;;	// canonical equivalent. All other information is preserved. This approach makes
0000000000000000000000000000000000000000;;	// the confidence scores more accurate and allows matchers to distinguish
0000000000000000000000000000000000000000;;	// between variants that are otherwise lost.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As a consequence, two tags that should be treated as identical according to
0000000000000000000000000000000000000000;;	// BCP 47 or CLDR, like "en-Latn" and "en", will be represented differently. The
0000000000000000000000000000000000000000;;	// Matchers will handle such distinctions, though, and are aware of the
0000000000000000000000000000000000000000;;	// equivalence relations. The CanonType type can be used to alter the
0000000000000000000000000000000000000000;;	// canonicalization form.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// References
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// BCP 47 - Tags for Identifying Languages
0000000000000000000000000000000000000000;;	// http://tools.ietf.org/html/bcp47
0000000000000000000000000000000000000000;;	package language
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Remove above NOTE after:
0000000000000000000000000000000000000000;;	// - verifying that tables are dropped correctly (most notably matcher tables).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// maxCoreSize is the maximum size of a BCP 47 tag without variants and
0000000000000000000000000000000000000000;;		// extensions. Equals max lang (3) + script (4) + max reg (3) + 2 dashes.
0000000000000000000000000000000000000000;;		maxCoreSize = 12
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// max99thPercentileSize is a somewhat arbitrary buffer size that presumably
0000000000000000000000000000000000000000;;		// is large enough to hold at least 99% of the BCP 47 tags.
0000000000000000000000000000000000000000;;		max99thPercentileSize = 32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// maxSimpleUExtensionSize is the maximum size of a -u extension with one
0000000000000000000000000000000000000000;;		// key-type pair. Equals len("-u-") + key (2) + dash + max value (8).
0000000000000000000000000000000000000000;;		maxSimpleUExtensionSize = 14
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tag represents a BCP 47 language tag. It is used to specify an instance of a
0000000000000000000000000000000000000000;;	// specific language or locale. All language tag values are guaranteed to be
0000000000000000000000000000000000000000;;	// well-formed.
0000000000000000000000000000000000000000;;	type Tag struct {
0000000000000000000000000000000000000000;;		lang     langID
0000000000000000000000000000000000000000;;		region   regionID
0000000000000000000000000000000000000000;;		script   scriptID
0000000000000000000000000000000000000000;;		pVariant byte   // offset in str, includes preceding '-'
0000000000000000000000000000000000000000;;		pExt     uint16 // offset of first extension, includes preceding '-'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// str is the string representation of the Tag. It will only be used if the
0000000000000000000000000000000000000000;;		// tag has variants or extensions.
0000000000000000000000000000000000000000;;		str string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make is a convenience wrapper for Parse that omits the error.
0000000000000000000000000000000000000000;;	// In case of an error, a sensible default is returned.
0000000000000000000000000000000000000000;;	func Make(s string) Tag {
0000000000000000000000000000000000000000;;		return Default.Make(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make is a convenience wrapper for c.Parse that omits the error.
0000000000000000000000000000000000000000;;	// In case of an error, a sensible default is returned.
0000000000000000000000000000000000000000;;	func (c CanonType) Make(s string) Tag {
0000000000000000000000000000000000000000;;		t, _ := c.Parse(s)
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Raw returns the raw base language, script and region, without making an
0000000000000000000000000000000000000000;;	// attempt to infer their values.
0000000000000000000000000000000000000000;;	func (t Tag) Raw() (b Base, s Script, r Region) {
0000000000000000000000000000000000000000;;		return Base{t.lang}, Script{t.script}, Region{t.region}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// equalTags compares language, script and region subtags only.
0000000000000000000000000000000000000000;;	func (t Tag) equalTags(a Tag) bool {
0000000000000000000000000000000000000000;;		return t.lang == a.lang && t.script == a.script && t.region == a.region
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRoot returns true if t is equal to language "und".
0000000000000000000000000000000000000000;;	func (t Tag) IsRoot() bool {
0000000000000000000000000000000000000000;;		if int(t.pVariant) < len(t.str) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.equalTags(und)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// private reports whether the Tag consists solely of a private use tag.
0000000000000000000000000000000000000000;;	func (t Tag) private() bool {
0000000000000000000000000000000000000000;;		return t.str != "" && t.pVariant == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CanonType can be used to enable or disable various types of canonicalization.
0000000000000000000000000000000000000000;;	type CanonType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Replace deprecated base languages with their preferred replacements.
0000000000000000000000000000000000000000;;		DeprecatedBase CanonType = 1 << iota
0000000000000000000000000000000000000000;;		// Replace deprecated scripts with their preferred replacements.
0000000000000000000000000000000000000000;;		DeprecatedScript
0000000000000000000000000000000000000000;;		// Replace deprecated regions with their preferred replacements.
0000000000000000000000000000000000000000;;		DeprecatedRegion
0000000000000000000000000000000000000000;;		// Remove redundant scripts.
0000000000000000000000000000000000000000;;		SuppressScript
0000000000000000000000000000000000000000;;		// Normalize legacy encodings. This includes legacy languages defined in
0000000000000000000000000000000000000000;;		// CLDR as well as bibliographic codes defined in ISO-639.
0000000000000000000000000000000000000000;;		Legacy
0000000000000000000000000000000000000000;;		// Map the dominant language of a macro language group to the macro language
0000000000000000000000000000000000000000;;		// subtag. For example cmn -> zh.
0000000000000000000000000000000000000000;;		Macro
0000000000000000000000000000000000000000;;		// The CLDR flag should be used if full compatibility with CLDR is required.
0000000000000000000000000000000000000000;;		// There are a few cases where language.Tag may differ from CLDR. To follow all
0000000000000000000000000000000000000000;;		// of CLDR's suggestions, use All|CLDR.
0000000000000000000000000000000000000000;;		CLDR
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Raw can be used to Compose or Parse without Canonicalization.
0000000000000000000000000000000000000000;;		Raw CanonType = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Replace all deprecated tags with their preferred replacements.
0000000000000000000000000000000000000000;;		Deprecated = DeprecatedBase | DeprecatedScript | DeprecatedRegion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All canonicalizations recommended by BCP 47.
0000000000000000000000000000000000000000;;		BCP47 = Deprecated | SuppressScript
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All canonicalizations.
0000000000000000000000000000000000000000;;		All = BCP47 | Legacy | Macro
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default is the canonicalization used by Parse, Make and Compose. To
0000000000000000000000000000000000000000;;		// preserve as much information as possible, canonicalizations that remove
0000000000000000000000000000000000000000;;		// potentially valuable information are not included. The Matcher is
0000000000000000000000000000000000000000;;		// designed to recognize similar tags that would be the same if
0000000000000000000000000000000000000000;;		// they were canonicalized using All.
0000000000000000000000000000000000000000;;		Default = Deprecated | Legacy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		canonLang = DeprecatedBase | Legacy | Macro
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: LikelyScript, LikelyRegion: suppress similar to ICU.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// canonicalize returns the canonicalized equivalent of the tag and
0000000000000000000000000000000000000000;;	// whether there was any change.
0000000000000000000000000000000000000000;;	func (t Tag) canonicalize(c CanonType) (Tag, bool) {
0000000000000000000000000000000000000000;;		if c == Raw {
0000000000000000000000000000000000000000;;			return t, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		changed := false
0000000000000000000000000000000000000000;;		if c&SuppressScript != 0 {
0000000000000000000000000000000000000000;;			if t.lang < langNoIndexOffset && uint8(t.script) == suppressScript[t.lang] {
0000000000000000000000000000000000000000;;				t.script = 0
0000000000000000000000000000000000000000;;				changed = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c&canonLang != 0 {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if l, aliasType := normLang(t.lang); l != t.lang {
0000000000000000000000000000000000000000;;					switch aliasType {
0000000000000000000000000000000000000000;;					case langLegacy:
0000000000000000000000000000000000000000;;						if c&Legacy != 0 {
0000000000000000000000000000000000000000;;							if t.lang == _sh && t.script == 0 {
0000000000000000000000000000000000000000;;								t.script = _Latn
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							t.lang = l
0000000000000000000000000000000000000000;;							changed = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case langMacro:
0000000000000000000000000000000000000000;;						if c&Macro != 0 {
0000000000000000000000000000000000000000;;							// We deviate here from CLDR. The mapping "nb" -> "no"
0000000000000000000000000000000000000000;;							// qualifies as a typical Macro language mapping.  However,
0000000000000000000000000000000000000000;;							// for legacy reasons, CLDR maps "no", the macro language
0000000000000000000000000000000000000000;;							// code for Norwegian, to the dominant variant "nb". This
0000000000000000000000000000000000000000;;							// change is currently under consideration for CLDR as well.
0000000000000000000000000000000000000000;;							// See http://unicode.org/cldr/trac/ticket/2698 and also
0000000000000000000000000000000000000000;;							// http://unicode.org/cldr/trac/ticket/1790 for some of the
0000000000000000000000000000000000000000;;							// practical implications. TODO: this check could be removed
0000000000000000000000000000000000000000;;							// if CLDR adopts this change.
0000000000000000000000000000000000000000;;							if c&CLDR == 0 || t.lang != _nb {
0000000000000000000000000000000000000000;;								changed = true
0000000000000000000000000000000000000000;;								t.lang = l
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case langDeprecated:
0000000000000000000000000000000000000000;;						if c&DeprecatedBase != 0 {
0000000000000000000000000000000000000000;;							if t.lang == _mo && t.region == 0 {
0000000000000000000000000000000000000000;;								t.region = _MD
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							t.lang = l
0000000000000000000000000000000000000000;;							changed = true
0000000000000000000000000000000000000000;;							// Other canonicalization types may still apply.
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if c&Legacy != 0 && t.lang == _no && c&CLDR != 0 {
0000000000000000000000000000000000000000;;					t.lang = _nb
0000000000000000000000000000000000000000;;					changed = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c&DeprecatedScript != 0 {
0000000000000000000000000000000000000000;;			if t.script == _Qaai {
0000000000000000000000000000000000000000;;				changed = true
0000000000000000000000000000000000000000;;				t.script = _Zinh
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c&DeprecatedRegion != 0 {
0000000000000000000000000000000000000000;;			if r := normRegion(t.region); r != 0 {
0000000000000000000000000000000000000000;;				changed = true
0000000000000000000000000000000000000000;;				t.region = r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, changed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Canonicalize returns the canonicalized equivalent of the tag.
0000000000000000000000000000000000000000;;	func (c CanonType) Canonicalize(t Tag) (Tag, error) {
0000000000000000000000000000000000000000;;		t, changed := t.canonicalize(c)
0000000000000000000000000000000000000000;;		if changed {
0000000000000000000000000000000000000000;;			t.remakeString()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Confidence indicates the level of certainty for a given return value.
0000000000000000000000000000000000000000;;	// For example, Serbian may be written in Cyrillic or Latin script.
0000000000000000000000000000000000000000;;	// The confidence level indicates whether a value was explicitly specified,
0000000000000000000000000000000000000000;;	// whether it is typically the only possible value, or whether there is
0000000000000000000000000000000000000000;;	// an ambiguity.
0000000000000000000000000000000000000000;;	type Confidence int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		No    Confidence = iota // full confidence that there was no match
0000000000000000000000000000000000000000;;		Low                     // most likely value picked out of a set of alternatives
0000000000000000000000000000000000000000;;		High                    // value is generally assumed to be the correct match
0000000000000000000000000000000000000000;;		Exact                   // exact match or explicitly specified value
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var confName = []string{"No", "Low", "High", "Exact"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Confidence) String() string {
0000000000000000000000000000000000000000;;		return confName[c]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// remakeString is used to update t.str in case lang, script or region changed.
0000000000000000000000000000000000000000;;	// It is assumed that pExt and pVariant still point to the start of the
0000000000000000000000000000000000000000;;	// respective parts.
0000000000000000000000000000000000000000;;	func (t *Tag) remakeString() {
0000000000000000000000000000000000000000;;		if t.str == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		extra := t.str[t.pVariant:]
0000000000000000000000000000000000000000;;		if t.pVariant > 0 {
0000000000000000000000000000000000000000;;			extra = extra[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.equalTags(und) && strings.HasPrefix(extra, "x-") {
0000000000000000000000000000000000000000;;			t.str = extra
0000000000000000000000000000000000000000;;			t.pVariant = 0
0000000000000000000000000000000000000000;;			t.pExt = 0
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buf [max99thPercentileSize]byte // avoid extra memory allocation in most cases.
0000000000000000000000000000000000000000;;		b := buf[:t.genCoreBytes(buf[:])]
0000000000000000000000000000000000000000;;		if extra != "" {
0000000000000000000000000000000000000000;;			diff := len(b) - int(t.pVariant)
0000000000000000000000000000000000000000;;			b = append(b, '-')
0000000000000000000000000000000000000000;;			b = append(b, extra...)
0000000000000000000000000000000000000000;;			t.pVariant = uint8(int(t.pVariant) + diff)
0000000000000000000000000000000000000000;;			t.pExt = uint16(int(t.pExt) + diff)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t.pVariant = uint8(len(b))
0000000000000000000000000000000000000000;;			t.pExt = uint16(len(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.str = string(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genCoreBytes writes a string for the base languages, script and region tags
0000000000000000000000000000000000000000;;	// to the given buffer and returns the number of bytes written. It will never
0000000000000000000000000000000000000000;;	// write more than maxCoreSize bytes.
0000000000000000000000000000000000000000;;	func (t *Tag) genCoreBytes(buf []byte) int {
0000000000000000000000000000000000000000;;		n := t.lang.stringToBuf(buf[:])
0000000000000000000000000000000000000000;;		if t.script != 0 {
0000000000000000000000000000000000000000;;			n += copy(buf[n:], "-")
0000000000000000000000000000000000000000;;			n += copy(buf[n:], t.script.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.region != 0 {
0000000000000000000000000000000000000000;;			n += copy(buf[n:], "-")
0000000000000000000000000000000000000000;;			n += copy(buf[n:], t.region.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the canonical string representation of the language tag.
0000000000000000000000000000000000000000;;	func (t Tag) String() string {
0000000000000000000000000000000000000000;;		if t.str != "" {
0000000000000000000000000000000000000000;;			return t.str
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.script == 0 && t.region == 0 {
0000000000000000000000000000000000000000;;			return t.lang.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := [maxCoreSize]byte{}
0000000000000000000000000000000000000000;;		return string(buf[:t.genCoreBytes(buf[:])])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Base returns the base language of the language tag. If the base language is
0000000000000000000000000000000000000000;;	// unspecified, an attempt will be made to infer it from the context.
0000000000000000000000000000000000000000;;	// It uses a variant of CLDR's Add Likely Subtags algorithm. This is subject to change.
0000000000000000000000000000000000000000;;	func (t Tag) Base() (Base, Confidence) {
0000000000000000000000000000000000000000;;		if t.lang != 0 {
0000000000000000000000000000000000000000;;			return Base{t.lang}, Exact
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := High
0000000000000000000000000000000000000000;;		if t.script == 0 && !(Region{t.region}).IsCountry() {
0000000000000000000000000000000000000000;;			c = Low
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tag, err := addTags(t); err == nil && tag.lang != 0 {
0000000000000000000000000000000000000000;;			return Base{tag.lang}, c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Base{0}, No
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Script infers the script for the language tag. If it was not explicitly given, it will infer
0000000000000000000000000000000000000000;;	// a most likely candidate.
0000000000000000000000000000000000000000;;	// If more than one script is commonly used for a language, the most likely one
0000000000000000000000000000000000000000;;	// is returned with a low confidence indication. For example, it returns (Cyrl, Low)
0000000000000000000000000000000000000000;;	// for Serbian.
0000000000000000000000000000000000000000;;	// If a script cannot be inferred (Zzzz, No) is returned. We do not use Zyyy (undetermined)
0000000000000000000000000000000000000000;;	// as one would suspect from the IANA registry for BCP 47. In a Unicode context Zyyy marks
0000000000000000000000000000000000000000;;	// common characters (like 1, 2, 3, '.', etc.) and is therefore more like multiple scripts.
0000000000000000000000000000000000000000;;	// See http://www.unicode.org/reports/tr24/#Values for more details. Zzzz is also used for
0000000000000000000000000000000000000000;;	// unknown value in CLDR.  (Zzzz, Exact) is returned if Zzzz was explicitly specified.
0000000000000000000000000000000000000000;;	// Note that an inferred script is never guaranteed to be the correct one. Latin is
0000000000000000000000000000000000000000;;	// almost exclusively used for Afrikaans, but Arabic has been used for some texts
0000000000000000000000000000000000000000;;	// in the past.  Also, the script that is commonly used may change over time.
0000000000000000000000000000000000000000;;	// It uses a variant of CLDR's Add Likely Subtags algorithm. This is subject to change.
0000000000000000000000000000000000000000;;	func (t Tag) Script() (Script, Confidence) {
0000000000000000000000000000000000000000;;		if t.script != 0 {
0000000000000000000000000000000000000000;;			return Script{t.script}, Exact
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sc, c := scriptID(_Zzzz), No
0000000000000000000000000000000000000000;;		if t.lang < langNoIndexOffset {
0000000000000000000000000000000000000000;;			if scr := scriptID(suppressScript[t.lang]); scr != 0 {
0000000000000000000000000000000000000000;;				// Note: it is not always the case that a language with a suppress
0000000000000000000000000000000000000000;;				// script value is only written in one script (e.g. kk, ms, pa).
0000000000000000000000000000000000000000;;				if t.region == 0 {
0000000000000000000000000000000000000000;;					return Script{scriptID(scr)}, High
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sc, c = scr, High
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tag, err := addTags(t); err == nil {
0000000000000000000000000000000000000000;;			if tag.script != sc {
0000000000000000000000000000000000000000;;				sc, c = tag.script, Low
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t, _ = (Deprecated | Macro).Canonicalize(t)
0000000000000000000000000000000000000000;;			if tag, err := addTags(t); err == nil && tag.script != sc {
0000000000000000000000000000000000000000;;				sc, c = tag.script, Low
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Script{sc}, c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Region returns the region for the language tag. If it was not explicitly given, it will
0000000000000000000000000000000000000000;;	// infer a most likely candidate from the context.
0000000000000000000000000000000000000000;;	// It uses a variant of CLDR's Add Likely Subtags algorithm. This is subject to change.
0000000000000000000000000000000000000000;;	func (t Tag) Region() (Region, Confidence) {
0000000000000000000000000000000000000000;;		if t.region != 0 {
0000000000000000000000000000000000000000;;			return Region{t.region}, Exact
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t, err := addTags(t); err == nil {
0000000000000000000000000000000000000000;;			return Region{t.region}, Low // TODO: differentiate between high and low.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, _ = (Deprecated | Macro).Canonicalize(t)
0000000000000000000000000000000000000000;;		if tag, err := addTags(t); err == nil {
0000000000000000000000000000000000000000;;			return Region{tag.region}, Low
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Region{_ZZ}, No // TODO: return world instead of undetermined?
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Variant returns the variants specified explicitly for this language tag.
0000000000000000000000000000000000000000;;	// or nil if no variant was specified.
0000000000000000000000000000000000000000;;	func (t Tag) Variants() []Variant {
0000000000000000000000000000000000000000;;		v := []Variant{}
0000000000000000000000000000000000000000;;		if int(t.pVariant) < int(t.pExt) {
0000000000000000000000000000000000000000;;			for x, str := "", t.str[t.pVariant:t.pExt]; str != ""; {
0000000000000000000000000000000000000000;;				x, str = nextToken(str)
0000000000000000000000000000000000000000;;				v = append(v, Variant{x})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parent returns the CLDR parent of t. In CLDR, missing fields in data for a
0000000000000000000000000000000000000000;;	// specific language are substituted with fields from the parent language.
0000000000000000000000000000000000000000;;	// The parent for a language may change for newer versions of CLDR.
0000000000000000000000000000000000000000;;	func (t Tag) Parent() Tag {
0000000000000000000000000000000000000000;;		if t.str != "" {
0000000000000000000000000000000000000000;;			// Strip the variants and extensions.
0000000000000000000000000000000000000000;;			t, _ = Raw.Compose(t.Raw())
0000000000000000000000000000000000000000;;			if t.region == 0 && t.script != 0 && t.lang != 0 {
0000000000000000000000000000000000000000;;				base, _ := addTags(Tag{lang: t.lang})
0000000000000000000000000000000000000000;;				if base.script == t.script {
0000000000000000000000000000000000000000;;					return Tag{lang: t.lang}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.lang != 0 {
0000000000000000000000000000000000000000;;			if t.region != 0 {
0000000000000000000000000000000000000000;;				maxScript := t.script
0000000000000000000000000000000000000000;;				if maxScript == 0 {
0000000000000000000000000000000000000000;;					max, _ := addTags(t)
0000000000000000000000000000000000000000;;					maxScript = max.script
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := range parents {
0000000000000000000000000000000000000000;;					if langID(parents[i].lang) == t.lang && scriptID(parents[i].maxScript) == maxScript {
0000000000000000000000000000000000000000;;						for _, r := range parents[i].fromRegion {
0000000000000000000000000000000000000000;;							if regionID(r) == t.region {
0000000000000000000000000000000000000000;;								return Tag{
0000000000000000000000000000000000000000;;									lang:   t.lang,
0000000000000000000000000000000000000000;;									script: scriptID(parents[i].script),
0000000000000000000000000000000000000000;;									region: regionID(parents[i].toRegion),
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Strip the script if it is the default one.
0000000000000000000000000000000000000000;;				base, _ := addTags(Tag{lang: t.lang})
0000000000000000000000000000000000000000;;				if base.script != maxScript {
0000000000000000000000000000000000000000;;					return Tag{lang: t.lang, script: maxScript}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return Tag{lang: t.lang}
0000000000000000000000000000000000000000;;			} else if t.script != 0 {
0000000000000000000000000000000000000000;;				// The parent for an base-script pair with a non-default script is
0000000000000000000000000000000000000000;;				// "und" instead of the base language.
0000000000000000000000000000000000000000;;				base, _ := addTags(Tag{lang: t.lang})
0000000000000000000000000000000000000000;;				if base.script != t.script {
0000000000000000000000000000000000000000;;					return und
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return Tag{lang: t.lang}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return und
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns token t and the rest of the string.
0000000000000000000000000000000000000000;;	func nextToken(s string) (t, tail string) {
0000000000000000000000000000000000000000;;		p := strings.Index(s[1:], "-")
0000000000000000000000000000000000000000;;		if p == -1 {
0000000000000000000000000000000000000000;;			return s[1:], ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p++
0000000000000000000000000000000000000000;;		return s[1:p], s[p:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extension is a single BCP 47 extension.
0000000000000000000000000000000000000000;;	type Extension struct {
0000000000000000000000000000000000000000;;		s string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation of the extension, including the
0000000000000000000000000000000000000000;;	// type tag.
0000000000000000000000000000000000000000;;	func (e Extension) String() string {
0000000000000000000000000000000000000000;;		return e.s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseExtension parses s as an extension and returns it on success.
0000000000000000000000000000000000000000;;	func ParseExtension(s string) (e Extension, err error) {
0000000000000000000000000000000000000000;;		scan := makeScannerString(s)
0000000000000000000000000000000000000000;;		var end int
0000000000000000000000000000000000000000;;		if n := len(scan.token); n != 1 {
0000000000000000000000000000000000000000;;			return Extension{}, errSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scan.toLower(0, len(scan.b))
0000000000000000000000000000000000000000;;		end = parseExtension(&scan)
0000000000000000000000000000000000000000;;		if end != len(s) {
0000000000000000000000000000000000000000;;			return Extension{}, errSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Extension{string(scan.b)}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type returns the one-byte extension type of e. It returns 0 for the zero
0000000000000000000000000000000000000000;;	// exception.
0000000000000000000000000000000000000000;;	func (e Extension) Type() byte {
0000000000000000000000000000000000000000;;		if e.s == "" {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.s[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tokens returns the list of tokens of e.
0000000000000000000000000000000000000000;;	func (e Extension) Tokens() []string {
0000000000000000000000000000000000000000;;		return strings.Split(e.s, "-")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extension returns the extension of type x for tag t. It will return
0000000000000000000000000000000000000000;;	// false for ok if t does not have the requested extension. The returned
0000000000000000000000000000000000000000;;	// extension will be invalid in this case.
0000000000000000000000000000000000000000;;	func (t Tag) Extension(x byte) (ext Extension, ok bool) {
0000000000000000000000000000000000000000;;		for i := int(t.pExt); i < len(t.str)-1; {
0000000000000000000000000000000000000000;;			var ext string
0000000000000000000000000000000000000000;;			i, ext = getExtension(t.str, i)
0000000000000000000000000000000000000000;;			if ext[0] == x {
0000000000000000000000000000000000000000;;				return Extension{ext}, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Extension{string(x)}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extensions returns all extensions of t.
0000000000000000000000000000000000000000;;	func (t Tag) Extensions() []Extension {
0000000000000000000000000000000000000000;;		e := []Extension{}
0000000000000000000000000000000000000000;;		for i := int(t.pExt); i < len(t.str)-1; {
0000000000000000000000000000000000000000;;			var ext string
0000000000000000000000000000000000000000;;			i, ext = getExtension(t.str, i)
0000000000000000000000000000000000000000;;			e = append(e, Extension{ext})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeForKey returns the type associated with the given key, where key and type
0000000000000000000000000000000000000000;;	// are of the allowed values defined for the Unicode locale extension ('u') in
0000000000000000000000000000000000000000;;	// http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
0000000000000000000000000000000000000000;;	// TypeForKey will traverse the inheritance chain to get the correct value.
0000000000000000000000000000000000000000;;	func (t Tag) TypeForKey(key string) string {
0000000000000000000000000000000000000000;;		if start, end, _ := t.findTypeForKey(key); end != start {
0000000000000000000000000000000000000000;;			return t.str[start:end]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errPrivateUse       = errors.New("cannot set a key on a private use tag")
0000000000000000000000000000000000000000;;		errInvalidArguments = errors.New("invalid key or type")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTypeForKey returns a new Tag with the key set to type, where key and type
0000000000000000000000000000000000000000;;	// are of the allowed values defined for the Unicode locale extension ('u') in
0000000000000000000000000000000000000000;;	// http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers.
0000000000000000000000000000000000000000;;	// An empty value removes an existing pair with the same key.
0000000000000000000000000000000000000000;;	func (t Tag) SetTypeForKey(key, value string) (Tag, error) {
0000000000000000000000000000000000000000;;		if t.private() {
0000000000000000000000000000000000000000;;			return t, errPrivateUse
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(key) != 2 {
0000000000000000000000000000000000000000;;			return t, errInvalidArguments
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the setting if value is "".
0000000000000000000000000000000000000000;;		if value == "" {
0000000000000000000000000000000000000000;;			start, end, _ := t.findTypeForKey(key)
0000000000000000000000000000000000000000;;			if start != end {
0000000000000000000000000000000000000000;;				// Remove key tag and leading '-'.
0000000000000000000000000000000000000000;;				start -= 4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Remove a possible empty extension.
0000000000000000000000000000000000000000;;				if (end == len(t.str) || t.str[end+2] == '-') && t.str[start-2] == '-' {
0000000000000000000000000000000000000000;;					start -= 2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if start == int(t.pVariant) && end == len(t.str) {
0000000000000000000000000000000000000000;;					t.str = ""
0000000000000000000000000000000000000000;;					t.pVariant, t.pExt = 0, 0
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.str = fmt.Sprintf("%s%s", t.str[:start], t.str[end:])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return t, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(value) < 3 || len(value) > 8 {
0000000000000000000000000000000000000000;;			return t, errInvalidArguments
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			buf    [maxCoreSize + maxSimpleUExtensionSize]byte
0000000000000000000000000000000000000000;;			uStart int // start of the -u extension.
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate the tag string if needed.
0000000000000000000000000000000000000000;;		if t.str == "" {
0000000000000000000000000000000000000000;;			uStart = t.genCoreBytes(buf[:])
0000000000000000000000000000000000000000;;			buf[uStart] = '-'
0000000000000000000000000000000000000000;;			uStart++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create new key-type pair and parse it to verify.
0000000000000000000000000000000000000000;;		b := buf[uStart:]
0000000000000000000000000000000000000000;;		copy(b, "u-")
0000000000000000000000000000000000000000;;		copy(b[2:], key)
0000000000000000000000000000000000000000;;		b[4] = '-'
0000000000000000000000000000000000000000;;		b = b[:5+copy(b[5:], value)]
0000000000000000000000000000000000000000;;		scan := makeScanner(b)
0000000000000000000000000000000000000000;;		if parseExtensions(&scan); scan.err != nil {
0000000000000000000000000000000000000000;;			return t, scan.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assemble the replacement string.
0000000000000000000000000000000000000000;;		if t.str == "" {
0000000000000000000000000000000000000000;;			t.pVariant, t.pExt = byte(uStart-1), uint16(uStart-1)
0000000000000000000000000000000000000000;;			t.str = string(buf[:uStart+len(b)])
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s := t.str
0000000000000000000000000000000000000000;;			start, end, hasExt := t.findTypeForKey(key)
0000000000000000000000000000000000000000;;			if start == end {
0000000000000000000000000000000000000000;;				if hasExt {
0000000000000000000000000000000000000000;;					b = b[2:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.str = fmt.Sprintf("%s-%s%s", s[:start], b, s[end:])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.str = fmt.Sprintf("%s%s%s", s[:start], value, s[end:])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findKeyAndType returns the start and end position for the type corresponding
0000000000000000000000000000000000000000;;	// to key or the point at which to insert the key-value pair if the type
0000000000000000000000000000000000000000;;	// wasn't found. The hasExt return value reports whether an -u extension was present.
0000000000000000000000000000000000000000;;	// Note: the extensions are typically very small and are likely to contain
0000000000000000000000000000000000000000;;	// only one key-type pair.
0000000000000000000000000000000000000000;;	func (t Tag) findTypeForKey(key string) (start, end int, hasExt bool) {
0000000000000000000000000000000000000000;;		p := int(t.pExt)
0000000000000000000000000000000000000000;;		if len(key) != 2 || p == len(t.str) || p == 0 {
0000000000000000000000000000000000000000;;			return p, p, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := t.str
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find the correct extension.
0000000000000000000000000000000000000000;;		for p++; s[p] != 'u'; p++ {
0000000000000000000000000000000000000000;;			if s[p] > 'u' {
0000000000000000000000000000000000000000;;				p--
0000000000000000000000000000000000000000;;				return p, p, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p = nextExtension(s, p); p == len(s) {
0000000000000000000000000000000000000000;;				return len(s), len(s), false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Proceed to the hyphen following the extension name.
0000000000000000000000000000000000000000;;		p++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// curKey is the key currently being processed.
0000000000000000000000000000000000000000;;		curKey := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Iterate over keys until we get the end of a section.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// p points to the hyphen preceding the current token.
0000000000000000000000000000000000000000;;			if p3 := p + 3; s[p3] == '-' {
0000000000000000000000000000000000000000;;				// Found a key.
0000000000000000000000000000000000000000;;				// Check whether we just processed the key that was requested.
0000000000000000000000000000000000000000;;				if curKey == key {
0000000000000000000000000000000000000000;;					return start, p, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Set to the next key and continue scanning type tokens.
0000000000000000000000000000000000000000;;				curKey = s[p+1 : p3]
0000000000000000000000000000000000000000;;				if curKey > key {
0000000000000000000000000000000000000000;;					return p, p, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Start of the type token sequence.
0000000000000000000000000000000000000000;;				start = p + 4
0000000000000000000000000000000000000000;;				// A type is at least 3 characters long.
0000000000000000000000000000000000000000;;				p += 7 // 4 + 3
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Attribute or type, which is at least 3 characters long.
0000000000000000000000000000000000000000;;				p += 4
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// p points past the third character of a type or attribute.
0000000000000000000000000000000000000000;;			max := p + 5 // maximum length of token plus hyphen.
0000000000000000000000000000000000000000;;			if len(s) < max {
0000000000000000000000000000000000000000;;				max = len(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for ; p < max && s[p] != '-'; p++ {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Bail if we have exhausted all tokens or if the next token starts
0000000000000000000000000000000000000000;;			// a new extension.
0000000000000000000000000000000000000000;;			if p == len(s) || s[p+2] == '-' {
0000000000000000000000000000000000000000;;				if curKey == key {
0000000000000000000000000000000000000000;;					return start, p, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return p, p, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompactIndex returns an index, where 0 <= index < NumCompactTags, for tags
0000000000000000000000000000000000000000;;	// for which data exists in the text repository. The index will change over time
0000000000000000000000000000000000000000;;	// and should not be stored in persistent storage. Extensions, except for the
0000000000000000000000000000000000000000;;	// 'va' type of the 'u' extension, are ignored. It will return 0, false if no
0000000000000000000000000000000000000000;;	// compact tag exists, where 0 is the index for the root language (Und).
0000000000000000000000000000000000000000;;	func CompactIndex(t Tag) (index int, ok bool) {
0000000000000000000000000000000000000000;;		// TODO: perhaps give more frequent tags a lower index.
0000000000000000000000000000000000000000;;		// TODO: we could make the indexes stable. This will excluded some
0000000000000000000000000000000000000000;;		//       possibilities for optimization, so don't do this quite yet.
0000000000000000000000000000000000000000;;		b, s, r := t.Raw()
0000000000000000000000000000000000000000;;		if len(t.str) > 0 {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(t.str, "x-") {
0000000000000000000000000000000000000000;;				// We have no entries for user-defined tags.
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if uint16(t.pVariant) != t.pExt {
0000000000000000000000000000000000000000;;				// There are no tags with variants and an u-va type.
0000000000000000000000000000000000000000;;				if t.TypeForKey("va") != "" {
0000000000000000000000000000000000000000;;					return 0, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t, _ = Raw.Compose(b, s, r, t.Variants())
0000000000000000000000000000000000000000;;			} else if _, ok := t.Extension('u'); ok {
0000000000000000000000000000000000000000;;				// Strip all but the 'va' entry.
0000000000000000000000000000000000000000;;				variant := t.TypeForKey("va")
0000000000000000000000000000000000000000;;				t, _ = Raw.Compose(b, s, r)
0000000000000000000000000000000000000000;;				t, _ = t.SetTypeForKey("va", variant)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(t.str) > 0 {
0000000000000000000000000000000000000000;;				// We have some variants.
0000000000000000000000000000000000000000;;				for i, s := range specialTags {
0000000000000000000000000000000000000000;;					if s == t {
0000000000000000000000000000000000000000;;						return i + 1, true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// No variants specified: just compare core components.
0000000000000000000000000000000000000000;;		// The key has the form lllssrrr, where l, s, and r are nibbles for
0000000000000000000000000000000000000000;;		// respectively the langID, scriptID, and regionID.
0000000000000000000000000000000000000000;;		key := uint32(b.langID) << (8 + 12)
0000000000000000000000000000000000000000;;		key |= uint32(s.scriptID) << 12
0000000000000000000000000000000000000000;;		key |= uint32(r.regionID)
0000000000000000000000000000000000000000;;		x, ok := coreTags[key]
0000000000000000000000000000000000000000;;		return int(x), ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Base is an ISO 639 language code, used for encoding the base language
0000000000000000000000000000000000000000;;	// of a language tag.
0000000000000000000000000000000000000000;;	type Base struct {
0000000000000000000000000000000000000000;;		langID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseBase parses a 2- or 3-letter ISO 639 code.
0000000000000000000000000000000000000000;;	// It returns a ValueError if s is a well-formed but unknown language identifier
0000000000000000000000000000000000000000;;	// or another error if another error occurred.
0000000000000000000000000000000000000000;;	func ParseBase(s string) (Base, error) {
0000000000000000000000000000000000000000;;		if n := len(s); n < 2 || 3 < n {
0000000000000000000000000000000000000000;;			return Base{}, errSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buf [3]byte
0000000000000000000000000000000000000000;;		l, err := getLangID(buf[:copy(buf[:], s)])
0000000000000000000000000000000000000000;;		return Base{l}, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Script is a 4-letter ISO 15924 code for representing scripts.
0000000000000000000000000000000000000000;;	// It is idiomatically represented in title case.
0000000000000000000000000000000000000000;;	type Script struct {
0000000000000000000000000000000000000000;;		scriptID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseScript parses a 4-letter ISO 15924 code.
0000000000000000000000000000000000000000;;	// It returns a ValueError if s is a well-formed but unknown script identifier
0000000000000000000000000000000000000000;;	// or another error if another error occurred.
0000000000000000000000000000000000000000;;	func ParseScript(s string) (Script, error) {
0000000000000000000000000000000000000000;;		if len(s) != 4 {
0000000000000000000000000000000000000000;;			return Script{}, errSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buf [4]byte
0000000000000000000000000000000000000000;;		sc, err := getScriptID(script, buf[:copy(buf[:], s)])
0000000000000000000000000000000000000000;;		return Script{sc}, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Region is an ISO 3166-1 or UN M.49 code for representing countries and regions.
0000000000000000000000000000000000000000;;	type Region struct {
0000000000000000000000000000000000000000;;		regionID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeM49 returns the Region for the given UN M.49 code.
0000000000000000000000000000000000000000;;	// It returns an error if r is not a valid code.
0000000000000000000000000000000000000000;;	func EncodeM49(r int) (Region, error) {
0000000000000000000000000000000000000000;;		rid, err := getRegionM49(r)
0000000000000000000000000000000000000000;;		return Region{rid}, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseRegion parses a 2- or 3-letter ISO 3166-1 or a UN M.49 code.
0000000000000000000000000000000000000000;;	// It returns a ValueError if s is a well-formed but unknown region identifier
0000000000000000000000000000000000000000;;	// or another error if another error occurred.
0000000000000000000000000000000000000000;;	func ParseRegion(s string) (Region, error) {
0000000000000000000000000000000000000000;;		if n := len(s); n < 2 || 3 < n {
0000000000000000000000000000000000000000;;			return Region{}, errSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buf [3]byte
0000000000000000000000000000000000000000;;		r, err := getRegionID(buf[:copy(buf[:], s)])
0000000000000000000000000000000000000000;;		return Region{r}, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsCountry returns whether this region is a country or autonomous area. This
0000000000000000000000000000000000000000;;	// includes non-standard definitions from CLDR.
0000000000000000000000000000000000000000;;	func (r Region) IsCountry() bool {
0000000000000000000000000000000000000000;;		if r.regionID == 0 || r.IsGroup() || r.IsPrivateUse() && r.regionID != _XK {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsGroup returns whether this region defines a collection of regions. This
0000000000000000000000000000000000000000;;	// includes non-standard definitions from CLDR.
0000000000000000000000000000000000000000;;	func (r Region) IsGroup() bool {
0000000000000000000000000000000000000000;;		if r.regionID == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(regionInclusion[r.regionID]) < len(regionContainment)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains returns whether Region c is contained by Region r. It returns true
0000000000000000000000000000000000000000;;	// if c == r.
0000000000000000000000000000000000000000;;	func (r Region) Contains(c Region) bool {
0000000000000000000000000000000000000000;;		return r.regionID.contains(c.regionID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r regionID) contains(c regionID) bool {
0000000000000000000000000000000000000000;;		if r == c {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g := regionInclusion[r]
0000000000000000000000000000000000000000;;		if g >= nRegionGroups {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m := regionContainment[g]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := regionInclusion[c]
0000000000000000000000000000000000000000;;		b := regionInclusionBits[d]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A contained country may belong to multiple disjoint groups. Matching any
0000000000000000000000000000000000000000;;		// of these indicates containment. If the contained region is a group, it
0000000000000000000000000000000000000000;;		// must strictly be a subset.
0000000000000000000000000000000000000000;;		if d >= nRegionGroups {
0000000000000000000000000000000000000000;;			return b&m != 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b&^m == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errNoTLD = errors.New("language: region is not a valid ccTLD")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TLD returns the country code top-level domain (ccTLD). UK is returned for GB.
0000000000000000000000000000000000000000;;	// In all other cases it returns either the region itself or an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method may return an error for a region for which there exists a
0000000000000000000000000000000000000000;;	// canonical form with a ccTLD. To get that ccTLD canonicalize r first. The
0000000000000000000000000000000000000000;;	// region will already be canonicalized it was obtained from a Tag that was
0000000000000000000000000000000000000000;;	// obtained using any of the default methods.
0000000000000000000000000000000000000000;;	func (r Region) TLD() (Region, error) {
0000000000000000000000000000000000000000;;		// See http://en.wikipedia.org/wiki/Country_code_top-level_domain for the
0000000000000000000000000000000000000000;;		// difference between ISO 3166-1 and IANA ccTLD.
0000000000000000000000000000000000000000;;		if r.regionID == _GB {
0000000000000000000000000000000000000000;;			r = Region{_UK}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (r.typ() & ccTLD) == 0 {
0000000000000000000000000000000000000000;;			return Region{}, errNoTLD
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Canonicalize returns the region or a possible replacement if the region is
0000000000000000000000000000000000000000;;	// deprecated. It will not return a replacement for deprecated regions that
0000000000000000000000000000000000000000;;	// are split into multiple regions.
0000000000000000000000000000000000000000;;	func (r Region) Canonicalize() Region {
0000000000000000000000000000000000000000;;		if cr := normRegion(r.regionID); cr != 0 {
0000000000000000000000000000000000000000;;			return Region{cr}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Variant represents a registered variant of a language as defined by BCP 47.
0000000000000000000000000000000000000000;;	type Variant struct {
0000000000000000000000000000000000000000;;		variant string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseVariant parses and returns a Variant. An error is returned if s is not
0000000000000000000000000000000000000000;;	// a valid variant.
0000000000000000000000000000000000000000;;	func ParseVariant(s string) (Variant, error) {
0000000000000000000000000000000000000000;;		s = strings.ToLower(s)
0000000000000000000000000000000000000000;;		if _, ok := variantIndex[s]; ok {
0000000000000000000000000000000000000000;;			return Variant{s}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Variant{}, mkErrInvalid([]byte(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation of the variant.
0000000000000000000000000000000000000000;;	func (v Variant) String() string {
0000000000000000000000000000000000000000;;		return v.variant
0000000000000000000000000000000000000000;;	}
