0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package language
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Coverage interface is used to define the level of coverage of an
0000000000000000000000000000000000000000;;	// internationalization service. Note that not all types are supported by all
0000000000000000000000000000000000000000;;	// services. As lists may be generated on the fly, it is recommended that users
0000000000000000000000000000000000000000;;	// of a Coverage cache the results.
0000000000000000000000000000000000000000;;	type Coverage interface {
0000000000000000000000000000000000000000;;		// Tags returns the list of supported tags.
0000000000000000000000000000000000000000;;		Tags() []Tag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BaseLanguages returns the list of supported base languages.
0000000000000000000000000000000000000000;;		BaseLanguages() []Base
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scripts returns the list of supported scripts.
0000000000000000000000000000000000000000;;		Scripts() []Script
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Regions returns the list of supported regions.
0000000000000000000000000000000000000000;;		Regions() []Region
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Supported defines a Coverage that lists all supported subtags. Tags
0000000000000000000000000000000000000000;;		// always returns nil.
0000000000000000000000000000000000000000;;		Supported Coverage = allSubtags{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO:
0000000000000000000000000000000000000000;;	// - Support Variants, numbering systems.
0000000000000000000000000000000000000000;;	// - CLDR coverage levels.
0000000000000000000000000000000000000000;;	// - Set of common tags defined in this package.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type allSubtags struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Regions returns the list of supported regions. As all regions are in a
0000000000000000000000000000000000000000;;	// consecutive range, it simply returns a slice of numbers in increasing order.
0000000000000000000000000000000000000000;;	// The "undefined" region is not returned.
0000000000000000000000000000000000000000;;	func (s allSubtags) Regions() []Region {
0000000000000000000000000000000000000000;;		reg := make([]Region, numRegions)
0000000000000000000000000000000000000000;;		for i := range reg {
0000000000000000000000000000000000000000;;			reg[i] = Region{regionID(i + 1)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scripts returns the list of supported scripts. As all scripts are in a
0000000000000000000000000000000000000000;;	// consecutive range, it simply returns a slice of numbers in increasing order.
0000000000000000000000000000000000000000;;	// The "undefined" script is not returned.
0000000000000000000000000000000000000000;;	func (s allSubtags) Scripts() []Script {
0000000000000000000000000000000000000000;;		scr := make([]Script, numScripts)
0000000000000000000000000000000000000000;;		for i := range scr {
0000000000000000000000000000000000000000;;			scr[i] = Script{scriptID(i + 1)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BaseLanguages returns the list of all supported base languages. It generates
0000000000000000000000000000000000000000;;	// the list by traversing the internal structures.
0000000000000000000000000000000000000000;;	func (s allSubtags) BaseLanguages() []Base {
0000000000000000000000000000000000000000;;		base := make([]Base, 0, numLanguages)
0000000000000000000000000000000000000000;;		for i := 0; i < langNoIndexOffset; i++ {
0000000000000000000000000000000000000000;;			// We included "und" already for the value 0.
0000000000000000000000000000000000000000;;			if i != nonCanonicalUnd {
0000000000000000000000000000000000000000;;				base = append(base, Base{langID(i)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := langNoIndexOffset
0000000000000000000000000000000000000000;;		for _, v := range langNoIndex {
0000000000000000000000000000000000000000;;			for k := 0; k < 8; k++ {
0000000000000000000000000000000000000000;;				if v&1 == 1 {
0000000000000000000000000000000000000000;;					base = append(base, Base{langID(i)})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v >>= 1
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return base
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tags always returns nil.
0000000000000000000000000000000000000000;;	func (s allSubtags) Tags() []Tag {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// coverage is used used by NewCoverage which is used as a convenient way for
0000000000000000000000000000000000000000;;	// creating Coverage implementations for partially defined data. Very often a
0000000000000000000000000000000000000000;;	// package will only need to define a subset of slices. coverage provides a
0000000000000000000000000000000000000000;;	// convenient way to do this. Moreover, packages using NewCoverage, instead of
0000000000000000000000000000000000000000;;	// their own implementation, will not break if later new slice types are added.
0000000000000000000000000000000000000000;;	type coverage struct {
0000000000000000000000000000000000000000;;		tags    func() []Tag
0000000000000000000000000000000000000000;;		bases   func() []Base
0000000000000000000000000000000000000000;;		scripts func() []Script
0000000000000000000000000000000000000000;;		regions func() []Region
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *coverage) Tags() []Tag {
0000000000000000000000000000000000000000;;		if s.tags == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.tags()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bases implements sort.Interface and is used to sort base languages.
0000000000000000000000000000000000000000;;	type bases []Base
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b bases) Len() int {
0000000000000000000000000000000000000000;;		return len(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b bases) Swap(i, j int) {
0000000000000000000000000000000000000000;;		b[i], b[j] = b[j], b[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b bases) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return b[i].langID < b[j].langID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BaseLanguages returns the result from calling s.bases if it is specified or
0000000000000000000000000000000000000000;;	// otherwise derives the set of supported base languages from tags.
0000000000000000000000000000000000000000;;	func (s *coverage) BaseLanguages() []Base {
0000000000000000000000000000000000000000;;		if s.bases == nil {
0000000000000000000000000000000000000000;;			tags := s.Tags()
0000000000000000000000000000000000000000;;			if len(tags) == 0 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a := make([]Base, len(tags))
0000000000000000000000000000000000000000;;			for i, t := range tags {
0000000000000000000000000000000000000000;;				a[i] = Base{langID(t.lang)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Sort(bases(a))
0000000000000000000000000000000000000000;;			k := 0
0000000000000000000000000000000000000000;;			for i := 1; i < len(a); i++ {
0000000000000000000000000000000000000000;;				if a[k] != a[i] {
0000000000000000000000000000000000000000;;					k++
0000000000000000000000000000000000000000;;					a[k] = a[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return a[:k+1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.bases()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *coverage) Scripts() []Script {
0000000000000000000000000000000000000000;;		if s.scripts == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.scripts()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *coverage) Regions() []Region {
0000000000000000000000000000000000000000;;		if s.regions == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.regions()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCoverage returns a Coverage for the given lists. It is typically used by
0000000000000000000000000000000000000000;;	// packages providing internationalization services to define their level of
0000000000000000000000000000000000000000;;	// coverage. A list may be of type []T or func() []T, where T is either Tag,
0000000000000000000000000000000000000000;;	// Base, Script or Region. The returned Coverage derives the value for Bases
0000000000000000000000000000000000000000;;	// from Tags if no func or slice for []Base is specified. For other unspecified
0000000000000000000000000000000000000000;;	// types the returned Coverage will return nil for the respective methods.
0000000000000000000000000000000000000000;;	func NewCoverage(list ...interface{}) Coverage {
0000000000000000000000000000000000000000;;		s := &coverage{}
0000000000000000000000000000000000000000;;		for _, x := range list {
0000000000000000000000000000000000000000;;			switch v := x.(type) {
0000000000000000000000000000000000000000;;			case func() []Base:
0000000000000000000000000000000000000000;;				s.bases = v
0000000000000000000000000000000000000000;;			case func() []Script:
0000000000000000000000000000000000000000;;				s.scripts = v
0000000000000000000000000000000000000000;;			case func() []Region:
0000000000000000000000000000000000000000;;				s.regions = v
0000000000000000000000000000000000000000;;			case func() []Tag:
0000000000000000000000000000000000000000;;				s.tags = v
0000000000000000000000000000000000000000;;			case []Base:
0000000000000000000000000000000000000000;;				s.bases = func() []Base { return v }
0000000000000000000000000000000000000000;;			case []Script:
0000000000000000000000000000000000000000;;				s.scripts = func() []Script { return v }
0000000000000000000000000000000000000000;;			case []Region:
0000000000000000000000000000000000000000;;				s.regions = func() []Region { return v }
0000000000000000000000000000000000000000;;			case []Tag:
0000000000000000000000000000000000000000;;				s.tags = func() []Tag { return v }
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("language: unsupported set type %T", v))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
