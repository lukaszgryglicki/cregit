0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
cabf0ed26cfc9aa3cb1e604605ff2083c0b112d2;;	
0000000000000000000000000000000000000000;;	// Package encoding defines an interface for character encodings, such as Shift
0000000000000000000000000000000000000000;;	// JIS and Windows 1252, that can convert to and from UTF-8.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Encoding implementations are provided in other packages, such as
0000000000000000000000000000000000000000;;	// golang.org/x/text/encoding/charmap and
0000000000000000000000000000000000000000;;	// golang.org/x/text/encoding/japanese.
0000000000000000000000000000000000000000;;	package encoding
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/encoding/internal/identifier"
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO:
0000000000000000000000000000000000000000;;	// - There seems to be some inconsistency in when decoders return errors
0000000000000000000000000000000000000000;;	//   and when not. Also documentation seems to suggest they shouldn't return
0000000000000000000000000000000000000000;;	//   errors at all (except for UTF-16).
0000000000000000000000000000000000000000;;	// - Encoders seem to rely on or at least benefit from the input being in NFC
0000000000000000000000000000000000000000;;	//   normal form. Perhaps add an example how users could prepare their output.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encoding is a character set encoding that can be transformed to and from
0000000000000000000000000000000000000000;;	// UTF-8.
0000000000000000000000000000000000000000;;	type Encoding interface {
0000000000000000000000000000000000000000;;		// NewDecoder returns a Decoder.
0000000000000000000000000000000000000000;;		NewDecoder() *Decoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewEncoder returns an Encoder.
0000000000000000000000000000000000000000;;		NewEncoder() *Encoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Decoder converts bytes to UTF-8. It implements transform.Transformer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Transforming source bytes that are not of that encoding will not result in an
0000000000000000000000000000000000000000;;	// error per se. Each byte that cannot be transcoded will be represented in the
0000000000000000000000000000000000000000;;	// output by the UTF-8 encoding of '\uFFFD', the replacement rune.
0000000000000000000000000000000000000000;;	type Decoder struct {
0000000000000000000000000000000000000000;;		transform.Transformer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This forces external creators of Decoders to use names in struct
0000000000000000000000000000000000000000;;		// initializers, allowing for future extendibility without having to break
0000000000000000000000000000000000000000;;		// code.
0000000000000000000000000000000000000000;;		_ struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes converts the given encoded bytes to UTF-8. It returns the converted
0000000000000000000000000000000000000000;;	// bytes or 0, err if any error occurred.
0000000000000000000000000000000000000000;;	func (d *Decoder) Bytes(b []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		b, _, err := transform.Bytes(d, b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String converts the given encoded string to UTF-8. It returns the converted
0000000000000000000000000000000000000000;;	// string or 0, err if any error occurred.
0000000000000000000000000000000000000000;;	func (d *Decoder) String(s string) (string, error) {
0000000000000000000000000000000000000000;;		s, _, err := transform.String(d, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reader wraps another Reader to decode its bytes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Decoder may not be used for any other operation as long as the returned
0000000000000000000000000000000000000000;;	// Reader is in use.
0000000000000000000000000000000000000000;;	func (d *Decoder) Reader(r io.Reader) io.Reader {
0000000000000000000000000000000000000000;;		return transform.NewReader(r, d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Encoder converts bytes from UTF-8. It implements transform.Transformer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Each rune that cannot be transcoded will result in an error. In this case,
0000000000000000000000000000000000000000;;	// the transform will consume all source byte up to, not including the offending
0000000000000000000000000000000000000000;;	// rune. Transforming source bytes that are not valid UTF-8 will be replaced by
0000000000000000000000000000000000000000;;	// `\uFFFD`. To return early with an error instead, use transform.Chain to
0000000000000000000000000000000000000000;;	// preprocess the data with a UTF8Validator.
0000000000000000000000000000000000000000;;	type Encoder struct {
0000000000000000000000000000000000000000;;		transform.Transformer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This forces external creators of Encoders to use names in struct
0000000000000000000000000000000000000000;;		// initializers, allowing for future extendibility without having to break
0000000000000000000000000000000000000000;;		// code.
0000000000000000000000000000000000000000;;		_ struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes converts bytes from UTF-8. It returns the converted bytes or 0, err if
0000000000000000000000000000000000000000;;	// any error occurred.
0000000000000000000000000000000000000000;;	func (e *Encoder) Bytes(b []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		b, _, err := transform.Bytes(e, b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String converts a string from UTF-8. It returns the converted string or
0000000000000000000000000000000000000000;;	// 0, err if any error occurred.
0000000000000000000000000000000000000000;;	func (e *Encoder) String(s string) (string, error) {
0000000000000000000000000000000000000000;;		s, _, err := transform.String(e, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Writer wraps another Writer to encode its UTF-8 output.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Encoder may not be used for any other operation as long as the returned
0000000000000000000000000000000000000000;;	// Writer is in use.
0000000000000000000000000000000000000000;;	func (e *Encoder) Writer(w io.Writer) io.Writer {
0000000000000000000000000000000000000000;;		return transform.NewWriter(w, e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ASCIISub is the ASCII substitute character, as recommended by
0000000000000000000000000000000000000000;;	// http://unicode.org/reports/tr36/#Text_Comparison
0000000000000000000000000000000000000000;;	const ASCIISub = '\x1a'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nop is the nop encoding. Its transformed bytes are the same as the source
0000000000000000000000000000000000000000;;	// bytes; it does not replace invalid UTF-8 sequences.
0000000000000000000000000000000000000000;;	var Nop Encoding = nop{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nop struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nop) NewDecoder() *Decoder {
0000000000000000000000000000000000000000;;		return &Decoder{Transformer: transform.Nop}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (nop) NewEncoder() *Encoder {
0000000000000000000000000000000000000000;;		return &Encoder{Transformer: transform.Nop}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replacement is the replacement encoding. Decoding from the replacement
0000000000000000000000000000000000000000;;	// encoding yields a single '\uFFFD' replacement rune. Encoding from UTF-8 to
0000000000000000000000000000000000000000;;	// the replacement encoding yields the same as the source bytes except that
0000000000000000000000000000000000000000;;	// invalid UTF-8 is converted to '\uFFFD'.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is defined at http://encoding.spec.whatwg.org/#replacement
0000000000000000000000000000000000000000;;	var Replacement Encoding = replacement{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type replacement struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (replacement) NewDecoder() *Decoder {
0000000000000000000000000000000000000000;;		return &Decoder{Transformer: replacementDecoder{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (replacement) NewEncoder() *Encoder {
0000000000000000000000000000000000000000;;		return &Encoder{Transformer: replacementEncoder{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (replacement) ID() (mib identifier.MIB, other string) {
0000000000000000000000000000000000000000;;		return identifier.Replacement, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type replacementDecoder struct{ transform.NopResetter }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (replacementDecoder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		if len(dst) < 3 {
0000000000000000000000000000000000000000;;			return 0, 0, transform.ErrShortDst
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if atEOF {
0000000000000000000000000000000000000000;;			const fffd = "\ufffd"
0000000000000000000000000000000000000000;;			dst[0] = fffd[0]
0000000000000000000000000000000000000000;;			dst[1] = fffd[1]
0000000000000000000000000000000000000000;;			dst[2] = fffd[2]
0000000000000000000000000000000000000000;;			nDst = 3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, len(src), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type replacementEncoder struct{ transform.NopResetter }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (replacementEncoder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		r, size := rune(0), 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ; nSrc < len(src); nSrc += size {
0000000000000000000000000000000000000000;;			r = rune(src[nSrc])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Decode a 1-byte rune.
0000000000000000000000000000000000000000;;			if r < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				size = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Decode a multi-byte rune.
0000000000000000000000000000000000000000;;				r, size = utf8.DecodeRune(src[nSrc:])
0000000000000000000000000000000000000000;;				if size == 1 {
0000000000000000000000000000000000000000;;					// All valid runes of size 1 (those below utf8.RuneSelf) were
0000000000000000000000000000000000000000;;					// handled above. We have invalid UTF-8 or we haven't seen the
0000000000000000000000000000000000000000;;					// full character yet.
0000000000000000000000000000000000000000;;					if !atEOF && !utf8.FullRune(src[nSrc:]) {
0000000000000000000000000000000000000000;;						err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					r = '\ufffd'
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if nDst+utf8.RuneLen(r) > len(dst) {
0000000000000000000000000000000000000000;;				err = transform.ErrShortDst
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nDst += utf8.EncodeRune(dst[nDst:], r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTMLEscapeUnsupported wraps encoders to replace source runes outside the
0000000000000000000000000000000000000000;;	// repertoire of the destination encoding with HTML escape sequences.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This wrapper exists to comply to URL and HTML forms requiring a
0000000000000000000000000000000000000000;;	// non-terminating legacy encoder. The produced sequences may lead to data
0000000000000000000000000000000000000000;;	// loss as they are indistinguishable from legitimate input. To avoid this
0000000000000000000000000000000000000000;;	// issue, use UTF-8 encodings whenever possible.
0000000000000000000000000000000000000000;;	func HTMLEscapeUnsupported(e *Encoder) *Encoder {
0000000000000000000000000000000000000000;;		return &Encoder{Transformer: &errorHandler{e, errorToHTML}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceUnsupported wraps encoders to replace source runes outside the
0000000000000000000000000000000000000000;;	// repertoire of the destination encoding with an encoding-specific
0000000000000000000000000000000000000000;;	// replacement.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This wrapper is only provided for backwards compatibility and legacy
0000000000000000000000000000000000000000;;	// handling. Its use is strongly discouraged. Use UTF-8 whenever possible.
0000000000000000000000000000000000000000;;	func ReplaceUnsupported(e *Encoder) *Encoder {
0000000000000000000000000000000000000000;;		return &Encoder{Transformer: &errorHandler{e, errorToReplacement}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errorHandler struct {
0000000000000000000000000000000000000000;;		*Encoder
0000000000000000000000000000000000000000;;		handler func(dst []byte, r rune, err repertoireError) (n int, ok bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: consider making this error public in some form.
0000000000000000000000000000000000000000;;	type repertoireError interface {
0000000000000000000000000000000000000000;;		Replacement() byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h errorHandler) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		nDst, nSrc, err = h.Transformer.Transform(dst, src, atEOF)
0000000000000000000000000000000000000000;;		for err != nil {
0000000000000000000000000000000000000000;;			rerr, ok := err.(repertoireError)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nDst, nSrc, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r, sz := utf8.DecodeRune(src[nSrc:])
0000000000000000000000000000000000000000;;			n, ok := h.handler(dst[nDst:], r, rerr)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = nil
0000000000000000000000000000000000000000;;			nDst += n
0000000000000000000000000000000000000000;;			if nSrc += sz; nSrc < len(src) {
0000000000000000000000000000000000000000;;				var dn, sn int
0000000000000000000000000000000000000000;;				dn, sn, err = h.Transformer.Transform(dst[nDst:], src[nSrc:], atEOF)
0000000000000000000000000000000000000000;;				nDst += dn
0000000000000000000000000000000000000000;;				nSrc += sn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func errorToHTML(dst []byte, r rune, err repertoireError) (n int, ok bool) {
0000000000000000000000000000000000000000;;		buf := [8]byte{}
0000000000000000000000000000000000000000;;		b := strconv.AppendUint(buf[:0], uint64(r), 10)
0000000000000000000000000000000000000000;;		if n = len(b) + len("&#;"); n >= len(dst) {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dst[0] = '&'
0000000000000000000000000000000000000000;;		dst[1] = '#'
0000000000000000000000000000000000000000;;		dst[copy(dst[2:], b)+2] = ';'
0000000000000000000000000000000000000000;;		return n, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func errorToReplacement(dst []byte, r rune, err repertoireError) (n int, ok bool) {
0000000000000000000000000000000000000000;;		if len(dst) == 0 {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dst[0] = err.Replacement()
0000000000000000000000000000000000000000;;		return 1, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrInvalidUTF8 means that a transformer encountered invalid UTF-8.
0000000000000000000000000000000000000000;;	var ErrInvalidUTF8 = errors.New("encoding: invalid UTF-8")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UTF8Validator is a transformer that returns ErrInvalidUTF8 on the first
0000000000000000000000000000000000000000;;	// input byte that is not valid UTF-8.
0000000000000000000000000000000000000000;;	var UTF8Validator transform.Transformer = utf8Validator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type utf8Validator struct{ transform.NopResetter }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (utf8Validator) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		n := len(src)
0000000000000000000000000000000000000000;;		if n > len(dst) {
0000000000000000000000000000000000000000;;			n = len(dst)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < n; {
0000000000000000000000000000000000000000;;			if c := src[i]; c < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				dst[i] = c
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, size := utf8.DecodeRune(src[i:])
0000000000000000000000000000000000000000;;			if size == 1 {
0000000000000000000000000000000000000000;;				// All valid runes of size 1 (those below utf8.RuneSelf) were
0000000000000000000000000000000000000000;;				// handled above. We have invalid UTF-8 or we haven't seen the
0000000000000000000000000000000000000000;;				// full character yet.
0000000000000000000000000000000000000000;;				err = ErrInvalidUTF8
0000000000000000000000000000000000000000;;				if !atEOF && !utf8.FullRune(src[i:]) {
0000000000000000000000000000000000000000;;					err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return i, i, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i+size > len(dst) {
0000000000000000000000000000000000000000;;				return i, i, transform.ErrShortDst
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for ; size > 0; size-- {
0000000000000000000000000000000000000000;;				dst[i] = src[i]
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(src) > len(dst) {
0000000000000000000000000000000000000000;;			err = transform.ErrShortDst
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, n, err
0000000000000000000000000000000000000000;;	}
