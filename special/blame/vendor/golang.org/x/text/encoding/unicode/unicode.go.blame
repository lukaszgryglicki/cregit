0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
cabf0ed26cfc9aa3cb1e604605ff2083c0b112d2;;	
0000000000000000000000000000000000000000;;	// Package unicode provides Unicode encodings such as UTF-16.
0000000000000000000000000000000000000000;;	package unicode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"unicode/utf16"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/encoding"
0000000000000000000000000000000000000000;;		"golang.org/x/text/encoding/internal"
0000000000000000000000000000000000000000;;		"golang.org/x/text/encoding/internal/identifier"
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/utf8internal"
0000000000000000000000000000000000000000;;		"golang.org/x/text/runes"
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: I think the Transformers really should return errors on unmatched
0000000000000000000000000000000000000000;;	// surrogate pairs and odd numbers of bytes. This is not required by RFC 2781,
0000000000000000000000000000000000000000;;	// which leaves it open, but is suggested by WhatWG. It will allow for all error
0000000000000000000000000000000000000000;;	// modes as defined by WhatWG: fatal, HTML and Replacement. This would require
0000000000000000000000000000000000000000;;	// the introduction of some kind of error type for conveying the erroneous code
0000000000000000000000000000000000000000;;	// point.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UTF8 is the UTF-8 encoding.
0000000000000000000000000000000000000000;;	var UTF8 encoding.Encoding = utf8enc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var utf8enc = &internal.Encoding{
0000000000000000000000000000000000000000;;		&internal.SimpleEncoding{utf8Decoder{}, runes.ReplaceIllFormed()},
0000000000000000000000000000000000000000;;		"UTF-8",
0000000000000000000000000000000000000000;;		identifier.UTF8,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type utf8Decoder struct{ transform.NopResetter }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (utf8Decoder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		var pSrc int // point from which to start copy in src
0000000000000000000000000000000000000000;;		var accept utf8internal.AcceptRange
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The decoder can only make the input larger, not smaller.
0000000000000000000000000000000000000000;;		n := len(src)
0000000000000000000000000000000000000000;;		if len(dst) < n {
0000000000000000000000000000000000000000;;			err = transform.ErrShortDst
0000000000000000000000000000000000000000;;			n = len(dst)
0000000000000000000000000000000000000000;;			atEOF = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for nSrc < n {
0000000000000000000000000000000000000000;;			c := src[nSrc]
0000000000000000000000000000000000000000;;			if c < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				nSrc++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			first := utf8internal.First[c]
0000000000000000000000000000000000000000;;			size := int(first & utf8internal.SizeMask)
0000000000000000000000000000000000000000;;			if first == utf8internal.FirstInvalid {
0000000000000000000000000000000000000000;;				goto handleInvalid // invalid starter byte
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			accept = utf8internal.AcceptRanges[first>>utf8internal.AcceptShift]
0000000000000000000000000000000000000000;;			if nSrc+size > n {
0000000000000000000000000000000000000000;;				if !atEOF {
0000000000000000000000000000000000000000;;					// We may stop earlier than necessary here if the short sequence
0000000000000000000000000000000000000000;;					// has invalid bytes. Not checking for this simplifies the code
0000000000000000000000000000000000000000;;					// and may avoid duplicate computations in certain conditions.
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Determine the maximal subpart of an ill-formed subsequence.
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case nSrc+1 >= n || src[nSrc+1] < accept.Lo || accept.Hi < src[nSrc+1]:
0000000000000000000000000000000000000000;;					size = 1
0000000000000000000000000000000000000000;;				case nSrc+2 >= n || src[nSrc+2] < utf8internal.LoCB || utf8internal.HiCB < src[nSrc+2]:
0000000000000000000000000000000000000000;;					size = 2
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					size = 3 // As we are short, the maximum is 3.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				goto handleInvalid
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c = src[nSrc+1]; c < accept.Lo || accept.Hi < c {
0000000000000000000000000000000000000000;;				size = 1
0000000000000000000000000000000000000000;;				goto handleInvalid // invalid continuation byte
0000000000000000000000000000000000000000;;			} else if size == 2 {
0000000000000000000000000000000000000000;;			} else if c = src[nSrc+2]; c < utf8internal.LoCB || utf8internal.HiCB < c {
0000000000000000000000000000000000000000;;				size = 2
0000000000000000000000000000000000000000;;				goto handleInvalid // invalid continuation byte
0000000000000000000000000000000000000000;;			} else if size == 3 {
0000000000000000000000000000000000000000;;			} else if c = src[nSrc+3]; c < utf8internal.LoCB || utf8internal.HiCB < c {
0000000000000000000000000000000000000000;;				size = 3
0000000000000000000000000000000000000000;;				goto handleInvalid // invalid continuation byte
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nSrc += size
0000000000000000000000000000000000000000;;			continue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handleInvalid:
0000000000000000000000000000000000000000;;			// Copy the scanned input so far.
0000000000000000000000000000000000000000;;			nDst += copy(dst[nDst:], src[pSrc:nSrc])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Append RuneError to the destination.
0000000000000000000000000000000000000000;;			const runeError = "\ufffd"
0000000000000000000000000000000000000000;;			if nDst+len(runeError) > len(dst) {
0000000000000000000000000000000000000000;;				return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nDst += copy(dst[nDst:], runeError)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Skip the maximal subpart of an ill-formed subsequence according to
0000000000000000000000000000000000000000;;			// the W3C standard way instead of the Go way. This Transform is
0000000000000000000000000000000000000000;;			// probably the only place in the text repo where it is warranted.
0000000000000000000000000000000000000000;;			nSrc += size
0000000000000000000000000000000000000000;;			pSrc = nSrc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Recompute the maximum source length.
0000000000000000000000000000000000000000;;			if sz := len(dst) - nDst; sz < len(src)-nSrc {
0000000000000000000000000000000000000000;;				err = transform.ErrShortDst
0000000000000000000000000000000000000000;;				n = nSrc + sz
0000000000000000000000000000000000000000;;				atEOF = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst + copy(dst[nDst:], src[pSrc:nSrc]), nSrc, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UTF16 returns a UTF-16 Encoding for the given default endianness and byte
0000000000000000000000000000000000000000;;	// order mark (BOM) policy.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When decoding from UTF-16 to UTF-8, if the BOMPolicy is IgnoreBOM then
0000000000000000000000000000000000000000;;	// neither BOMs U+FEFF nor noncharacters U+FFFE in the input stream will affect
0000000000000000000000000000000000000000;;	// the endianness used for decoding, and will instead be output as their
0000000000000000000000000000000000000000;;	// standard UTF-8 encodings: "\xef\xbb\xbf" and "\xef\xbf\xbe". If the BOMPolicy
0000000000000000000000000000000000000000;;	// is UseBOM or ExpectBOM a staring BOM is not written to the UTF-8 output.
0000000000000000000000000000000000000000;;	// Instead, it overrides the default endianness e for the remainder of the
0000000000000000000000000000000000000000;;	// transformation. Any subsequent BOMs U+FEFF or noncharacters U+FFFE will not
0000000000000000000000000000000000000000;;	// affect the endianness used, and will instead be output as their standard
0000000000000000000000000000000000000000;;	// UTF-8 encodings. For UseBOM, if there is no starting BOM, it will proceed
0000000000000000000000000000000000000000;;	// with the default Endianness. For ExpectBOM, in that case, the transformation
0000000000000000000000000000000000000000;;	// will return early with an ErrMissingBOM error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When encoding from UTF-8 to UTF-16, a BOM will be inserted at the start of
0000000000000000000000000000000000000000;;	// the output if the BOMPolicy is UseBOM or ExpectBOM. Otherwise, a BOM will not
0000000000000000000000000000000000000000;;	// be inserted. The UTF-8 input does not need to contain a BOM.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There is no concept of a 'native' endianness. If the UTF-16 data is produced
0000000000000000000000000000000000000000;;	// and consumed in a greater context that implies a certain endianness, use
0000000000000000000000000000000000000000;;	// IgnoreBOM. Otherwise, use ExpectBOM and always produce and consume a BOM.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In the language of http://www.unicode.org/faq/utf_bom.html#bom10, IgnoreBOM
0000000000000000000000000000000000000000;;	// corresponds to "Where the precise type of the data stream is known... the
0000000000000000000000000000000000000000;;	// BOM should not be used" and ExpectBOM corresponds to "A particular
0000000000000000000000000000000000000000;;	// protocol... may require use of the BOM".
0000000000000000000000000000000000000000;;	func UTF16(e Endianness, b BOMPolicy) encoding.Encoding {
0000000000000000000000000000000000000000;;		return utf16Encoding{config{e, b}, mibValue[e][b&bomMask]}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mibValue maps Endianness and BOMPolicy settings to MIB constants. Note that
0000000000000000000000000000000000000000;;	// some configurations map to the same MIB identifier. RFC 2781 has requirements
0000000000000000000000000000000000000000;;	// and recommendations. Some of the "configurations" are merely recommendations,
0000000000000000000000000000000000000000;;	// so multiple configurations could match.
0000000000000000000000000000000000000000;;	var mibValue = map[Endianness][numBOMValues]identifier.MIB{
0000000000000000000000000000000000000000;;		BigEndian: [numBOMValues]identifier.MIB{
0000000000000000000000000000000000000000;;			IgnoreBOM: identifier.UTF16BE,
0000000000000000000000000000000000000000;;			UseBOM:    identifier.UTF16, // BigEnding default is preferred by RFC 2781.
0000000000000000000000000000000000000000;;			// TODO: acceptBOM | strictBOM would map to UTF16BE as well.
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		LittleEndian: [numBOMValues]identifier.MIB{
0000000000000000000000000000000000000000;;			IgnoreBOM: identifier.UTF16LE,
0000000000000000000000000000000000000000;;			UseBOM:    identifier.UTF16, // LittleEndian default is allowed and preferred on Windows.
0000000000000000000000000000000000000000;;			// TODO: acceptBOM | strictBOM would map to UTF16LE as well.
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		// ExpectBOM is not widely used and has no valid MIB identifier.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All lists a configuration for each IANA-defined UTF-16 variant.
0000000000000000000000000000000000000000;;	var All = []encoding.Encoding{
0000000000000000000000000000000000000000;;		UTF8,
0000000000000000000000000000000000000000;;		UTF16(BigEndian, UseBOM),
0000000000000000000000000000000000000000;;		UTF16(BigEndian, IgnoreBOM),
0000000000000000000000000000000000000000;;		UTF16(LittleEndian, IgnoreBOM),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BOMPolicy is a UTF-16 encoding's byte order mark policy.
0000000000000000000000000000000000000000;;	type BOMPolicy uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		writeBOM   BOMPolicy = 0x01
0000000000000000000000000000000000000000;;		acceptBOM  BOMPolicy = 0x02
0000000000000000000000000000000000000000;;		requireBOM BOMPolicy = 0x04
0000000000000000000000000000000000000000;;		bomMask    BOMPolicy = 0x07
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HACK: numBOMValues == 8 triggers a bug in the 1.4 compiler (cannot have a
0000000000000000000000000000000000000000;;		// map of an array of length 8 of a type that is also used as a key or value
0000000000000000000000000000000000000000;;		// in another map). See golang.org/issue/11354.
0000000000000000000000000000000000000000;;		// TODO: consider changing this value back to 8 if the use of 1.4.* has
0000000000000000000000000000000000000000;;		// been minimized.
0000000000000000000000000000000000000000;;		numBOMValues = 8 + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IgnoreBOM means to ignore any byte order marks.
0000000000000000000000000000000000000000;;		IgnoreBOM BOMPolicy = 0
0000000000000000000000000000000000000000;;		// Common and RFC 2781-compliant interpretation for UTF-16BE/LE.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UseBOM means that the UTF-16 form may start with a byte order mark, which
0000000000000000000000000000000000000000;;		// will be used to override the default encoding.
0000000000000000000000000000000000000000;;		UseBOM BOMPolicy = writeBOM | acceptBOM
0000000000000000000000000000000000000000;;		// Common and RFC 2781-compliant interpretation for UTF-16.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExpectBOM means that the UTF-16 form must start with a byte order mark,
0000000000000000000000000000000000000000;;		// which will be used to override the default encoding.
0000000000000000000000000000000000000000;;		ExpectBOM BOMPolicy = writeBOM | acceptBOM | requireBOM
0000000000000000000000000000000000000000;;		// Used in Java as Unicode (not to be confused with Java's UTF-16) and
0000000000000000000000000000000000000000;;		// ICU's UTF-16,version=1. Not compliant with RFC 2781.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO (maybe): strictBOM: BOM must match Endianness. This would allow:
0000000000000000000000000000000000000000;;		// - UTF-16(B|L)E,version=1: writeBOM | acceptBOM | requireBOM | strictBOM
0000000000000000000000000000000000000000;;		//    (UnicodeBig and UnicodeLittle in Java)
0000000000000000000000000000000000000000;;		// - RFC 2781-compliant, but less common interpretation for UTF-16(B|L)E:
0000000000000000000000000000000000000000;;		//    acceptBOM | strictBOM (e.g. assigned to CheckBOM).
0000000000000000000000000000000000000000;;		// This addition would be consistent with supporting ExpectBOM.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Endianness is a UTF-16 encoding's default endianness.
0000000000000000000000000000000000000000;;	type Endianness bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// BigEndian is UTF-16BE.
0000000000000000000000000000000000000000;;		BigEndian Endianness = false
0000000000000000000000000000000000000000;;		// LittleEndian is UTF-16LE.
0000000000000000000000000000000000000000;;		LittleEndian Endianness = true
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrMissingBOM means that decoding UTF-16 input with ExpectBOM did not find a
0000000000000000000000000000000000000000;;	// starting byte order mark.
0000000000000000000000000000000000000000;;	var ErrMissingBOM = errors.New("encoding: missing byte order mark")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type utf16Encoding struct {
0000000000000000000000000000000000000000;;		config
0000000000000000000000000000000000000000;;		mib identifier.MIB
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type config struct {
0000000000000000000000000000000000000000;;		endianness Endianness
0000000000000000000000000000000000000000;;		bomPolicy  BOMPolicy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u utf16Encoding) NewDecoder() *encoding.Decoder {
0000000000000000000000000000000000000000;;		return &encoding.Decoder{Transformer: &utf16Decoder{
0000000000000000000000000000000000000000;;			initial: u.config,
0000000000000000000000000000000000000000;;			current: u.config,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u utf16Encoding) NewEncoder() *encoding.Encoder {
0000000000000000000000000000000000000000;;		return &encoding.Encoder{Transformer: &utf16Encoder{
0000000000000000000000000000000000000000;;			endianness:       u.endianness,
0000000000000000000000000000000000000000;;			initialBOMPolicy: u.bomPolicy,
0000000000000000000000000000000000000000;;			currentBOMPolicy: u.bomPolicy,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u utf16Encoding) ID() (mib identifier.MIB, other string) {
0000000000000000000000000000000000000000;;		return u.mib, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u utf16Encoding) String() string {
0000000000000000000000000000000000000000;;		e, b := "B", ""
0000000000000000000000000000000000000000;;		if u.endianness == LittleEndian {
0000000000000000000000000000000000000000;;			e = "L"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch u.bomPolicy {
0000000000000000000000000000000000000000;;		case ExpectBOM:
0000000000000000000000000000000000000000;;			b = "Expect"
0000000000000000000000000000000000000000;;		case UseBOM:
0000000000000000000000000000000000000000;;			b = "Use"
0000000000000000000000000000000000000000;;		case IgnoreBOM:
0000000000000000000000000000000000000000;;			b = "Ignore"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "UTF-16" + e + "E (" + b + " BOM)"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type utf16Decoder struct {
0000000000000000000000000000000000000000;;		initial config
0000000000000000000000000000000000000000;;		current config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *utf16Decoder) Reset() {
0000000000000000000000000000000000000000;;		u.current = u.initial
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *utf16Decoder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		if len(src) == 0 {
0000000000000000000000000000000000000000;;			if atEOF && u.current.bomPolicy&requireBOM != 0 {
0000000000000000000000000000000000000000;;				return 0, 0, ErrMissingBOM
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0, 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u.current.bomPolicy&acceptBOM != 0 {
0000000000000000000000000000000000000000;;			if len(src) < 2 {
0000000000000000000000000000000000000000;;				return 0, 0, transform.ErrShortSrc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case src[0] == 0xfe && src[1] == 0xff:
0000000000000000000000000000000000000000;;				u.current.endianness = BigEndian
0000000000000000000000000000000000000000;;				nSrc = 2
0000000000000000000000000000000000000000;;			case src[0] == 0xff && src[1] == 0xfe:
0000000000000000000000000000000000000000;;				u.current.endianness = LittleEndian
0000000000000000000000000000000000000000;;				nSrc = 2
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if u.current.bomPolicy&requireBOM != 0 {
0000000000000000000000000000000000000000;;					return 0, 0, ErrMissingBOM
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			u.current.bomPolicy = IgnoreBOM
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var r rune
0000000000000000000000000000000000000000;;		var dSize, sSize int
0000000000000000000000000000000000000000;;		for nSrc < len(src) {
0000000000000000000000000000000000000000;;			if nSrc+1 < len(src) {
0000000000000000000000000000000000000000;;				x := uint16(src[nSrc+0])<<8 | uint16(src[nSrc+1])
0000000000000000000000000000000000000000;;				if u.current.endianness == LittleEndian {
0000000000000000000000000000000000000000;;					x = x>>8 | x<<8
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r, sSize = rune(x), 2
0000000000000000000000000000000000000000;;				if utf16.IsSurrogate(r) {
0000000000000000000000000000000000000000;;					if nSrc+3 < len(src) {
0000000000000000000000000000000000000000;;						x = uint16(src[nSrc+2])<<8 | uint16(src[nSrc+3])
0000000000000000000000000000000000000000;;						if u.current.endianness == LittleEndian {
0000000000000000000000000000000000000000;;							x = x>>8 | x<<8
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// Save for next iteration if it is not a high surrogate.
0000000000000000000000000000000000000000;;						if isHighSurrogate(rune(x)) {
0000000000000000000000000000000000000000;;							r, sSize = utf16.DecodeRune(r, rune(x)), 4
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else if !atEOF {
0000000000000000000000000000000000000000;;						err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if dSize = utf8.RuneLen(r); dSize < 0 {
0000000000000000000000000000000000000000;;					r, dSize = utf8.RuneError, 3
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if atEOF {
0000000000000000000000000000000000000000;;				// Single trailing byte.
0000000000000000000000000000000000000000;;				r, dSize, sSize = utf8.RuneError, 3, 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if nDst+dSize > len(dst) {
0000000000000000000000000000000000000000;;				err = transform.ErrShortDst
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nDst += utf8.EncodeRune(dst[nDst:], r)
0000000000000000000000000000000000000000;;			nSrc += sSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isHighSurrogate(r rune) bool {
0000000000000000000000000000000000000000;;		return 0xDC00 <= r && r <= 0xDFFF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type utf16Encoder struct {
0000000000000000000000000000000000000000;;		endianness       Endianness
0000000000000000000000000000000000000000;;		initialBOMPolicy BOMPolicy
0000000000000000000000000000000000000000;;		currentBOMPolicy BOMPolicy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *utf16Encoder) Reset() {
0000000000000000000000000000000000000000;;		u.currentBOMPolicy = u.initialBOMPolicy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *utf16Encoder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		if u.currentBOMPolicy&writeBOM != 0 {
0000000000000000000000000000000000000000;;			if len(dst) < 2 {
0000000000000000000000000000000000000000;;				return 0, 0, transform.ErrShortDst
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst[0], dst[1] = 0xfe, 0xff
0000000000000000000000000000000000000000;;			u.currentBOMPolicy = IgnoreBOM
0000000000000000000000000000000000000000;;			nDst = 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r, size := rune(0), 0
0000000000000000000000000000000000000000;;		for nSrc < len(src) {
0000000000000000000000000000000000000000;;			r = rune(src[nSrc])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Decode a 1-byte rune.
0000000000000000000000000000000000000000;;			if r < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				size = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Decode a multi-byte rune.
0000000000000000000000000000000000000000;;				r, size = utf8.DecodeRune(src[nSrc:])
0000000000000000000000000000000000000000;;				if size == 1 {
0000000000000000000000000000000000000000;;					// All valid runes of size 1 (those below utf8.RuneSelf) were
0000000000000000000000000000000000000000;;					// handled above. We have invalid UTF-8 or we haven't seen the
0000000000000000000000000000000000000000;;					// full character yet.
0000000000000000000000000000000000000000;;					if !atEOF && !utf8.FullRune(src[nSrc:]) {
0000000000000000000000000000000000000000;;						err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if r <= 0xffff {
0000000000000000000000000000000000000000;;				if nDst+2 > len(dst) {
0000000000000000000000000000000000000000;;					err = transform.ErrShortDst
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst[nDst+0] = uint8(r >> 8)
0000000000000000000000000000000000000000;;				dst[nDst+1] = uint8(r)
0000000000000000000000000000000000000000;;				nDst += 2
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if nDst+4 > len(dst) {
0000000000000000000000000000000000000000;;					err = transform.ErrShortDst
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r1, r2 := utf16.EncodeRune(r)
0000000000000000000000000000000000000000;;				dst[nDst+0] = uint8(r1 >> 8)
0000000000000000000000000000000000000000;;				dst[nDst+1] = uint8(r1)
0000000000000000000000000000000000000000;;				dst[nDst+2] = uint8(r2 >> 8)
0000000000000000000000000000000000000000;;				dst[nDst+3] = uint8(r2)
0000000000000000000000000000000000000000;;				nDst += 4
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nSrc += size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u.endianness == LittleEndian {
0000000000000000000000000000000000000000;;			for i := 0; i < nDst; i += 2 {
0000000000000000000000000000000000000000;;				dst[i], dst[i+1] = dst[i+1], dst[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, err
0000000000000000000000000000000000000000;;	}
