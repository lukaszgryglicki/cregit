0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
cabf0ed26cfc9aa3cb1e604605ff2083c0b112d2;;	
0000000000000000000000000000000000000000;;	package unicode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BOMOverride returns a new decoder transformer that is identical to fallback,
0000000000000000000000000000000000000000;;	// except that the presence of a Byte Order Mark at the start of the input
0000000000000000000000000000000000000000;;	// causes it to switch to the corresponding Unicode decoding. It will only
0000000000000000000000000000000000000000;;	// consider BOMs for UTF-8, UTF-16BE, and UTF-16LE.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This differs from using ExpectBOM by allowing a BOM to switch to UTF-8, not
0000000000000000000000000000000000000000;;	// just UTF-16 variants, and allowing falling back to any encoding scheme.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This technique is recommended by the W3C for use in HTML 5: "For
0000000000000000000000000000000000000000;;	// compatibility with deployed content, the byte order mark (also known as BOM)
0000000000000000000000000000000000000000;;	// is considered more authoritative than anything else."
0000000000000000000000000000000000000000;;	// http://www.w3.org/TR/encoding/#specification-hooks
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Using BOMOverride is mostly intended for use cases where the first characters
0000000000000000000000000000000000000000;;	// of a fallback encoding are known to not be a BOM, for example, for valid HTML
0000000000000000000000000000000000000000;;	// and most encodings.
0000000000000000000000000000000000000000;;	func BOMOverride(fallback transform.Transformer) transform.Transformer {
0000000000000000000000000000000000000000;;		// TODO: possibly allow a variadic argument of unicode encodings to allow
0000000000000000000000000000000000000000;;		// specifying details of which fallbacks are supported as well as
0000000000000000000000000000000000000000;;		// specifying the details of the implementations. This would also allow for
0000000000000000000000000000000000000000;;		// support for UTF-32, which should not be supported by default.
0000000000000000000000000000000000000000;;		return &bomOverride{fallback: fallback}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bomOverride struct {
0000000000000000000000000000000000000000;;		fallback transform.Transformer
0000000000000000000000000000000000000000;;		current  transform.Transformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bomOverride) Reset() {
0000000000000000000000000000000000000000;;		d.current = nil
0000000000000000000000000000000000000000;;		d.fallback.Reset()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// TODO: we could use decode functions here, instead of allocating a new
0000000000000000000000000000000000000000;;		// decoder on every NewDecoder as IgnoreBOM decoders can be stateless.
0000000000000000000000000000000000000000;;		utf16le = UTF16(LittleEndian, IgnoreBOM)
0000000000000000000000000000000000000000;;		utf16be = UTF16(BigEndian, IgnoreBOM)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const utf8BOM = "\ufeff"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bomOverride) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		if d.current != nil {
0000000000000000000000000000000000000000;;			return d.current.Transform(dst, src, atEOF)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(src) < 3 && !atEOF {
0000000000000000000000000000000000000000;;			return 0, 0, transform.ErrShortSrc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.current = d.fallback
0000000000000000000000000000000000000000;;		bomSize := 0
0000000000000000000000000000000000000000;;		if len(src) >= 2 {
0000000000000000000000000000000000000000;;			if src[0] == 0xFF && src[1] == 0xFE {
0000000000000000000000000000000000000000;;				d.current = utf16le.NewDecoder()
0000000000000000000000000000000000000000;;				bomSize = 2
0000000000000000000000000000000000000000;;			} else if src[0] == 0xFE && src[1] == 0xFF {
0000000000000000000000000000000000000000;;				d.current = utf16be.NewDecoder()
0000000000000000000000000000000000000000;;				bomSize = 2
0000000000000000000000000000000000000000;;			} else if len(src) >= 3 &&
0000000000000000000000000000000000000000;;				src[0] == utf8BOM[0] &&
0000000000000000000000000000000000000000;;				src[1] == utf8BOM[1] &&
0000000000000000000000000000000000000000;;				src[2] == utf8BOM[2] {
0000000000000000000000000000000000000000;;				d.current = transform.Nop
0000000000000000000000000000000000000000;;				bomSize = 3
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bomSize < len(src) {
0000000000000000000000000000000000000000;;			nDst, nSrc, err = d.current.Transform(dst, src[bomSize:], atEOF)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc + bomSize, err
0000000000000000000000000000000000000000;;	}
