0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
cabf0ed26cfc9aa3cb1e604605ff2083c0b112d2;;	
0000000000000000000000000000000000000000;;	// +build ignore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/xml"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/gen"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type registry struct {
0000000000000000000000000000000000000000;;		XMLName  xml.Name `xml:"registry"`
0000000000000000000000000000000000000000;;		Updated  string   `xml:"updated"`
0000000000000000000000000000000000000000;;		Registry []struct {
0000000000000000000000000000000000000000;;			ID     string `xml:"id,attr"`
0000000000000000000000000000000000000000;;			Record []struct {
0000000000000000000000000000000000000000;;				Name string `xml:"name"`
0000000000000000000000000000000000000000;;				Xref []struct {
0000000000000000000000000000000000000000;;					Type string `xml:"type,attr"`
0000000000000000000000000000000000000000;;					Data string `xml:"data,attr"`
0000000000000000000000000000000000000000;;				} `xml:"xref"`
0000000000000000000000000000000000000000;;				Desc struct {
0000000000000000000000000000000000000000;;					Data string `xml:",innerxml"`
0000000000000000000000000000000000000000;;					// Any []struct {
0000000000000000000000000000000000000000;;					// 	Data string `xml:",chardata"`
0000000000000000000000000000000000000000;;					// } `xml:",any"`
0000000000000000000000000000000000000000;;					// Data string `xml:",chardata"`
0000000000000000000000000000000000000000;;				} `xml:"description,"`
0000000000000000000000000000000000000000;;				MIB   string   `xml:"value"`
0000000000000000000000000000000000000000;;				Alias []string `xml:"alias"`
0000000000000000000000000000000000000000;;				MIME  string   `xml:"preferred_alias"`
0000000000000000000000000000000000000000;;			} `xml:"record"`
0000000000000000000000000000000000000000;;		} `xml:"registry"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		r := gen.OpenIANAFile("assignments/character-sets/character-sets.xml")
0000000000000000000000000000000000000000;;		reg := &registry{}
0000000000000000000000000000000000000000;;		if err := xml.NewDecoder(r).Decode(&reg); err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			log.Fatalf("Error decoding charset registry: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(reg.Registry) == 0 || reg.Registry[0].ID != "character-sets-1" {
0000000000000000000000000000000000000000;;			log.Fatalf("Unexpected ID %s", reg.Registry[0].ID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "const (\n")
0000000000000000000000000000000000000000;;		for _, rec := range reg.Registry[0].Record {
0000000000000000000000000000000000000000;;			constName := ""
0000000000000000000000000000000000000000;;			for _, a := range rec.Alias {
0000000000000000000000000000000000000000;;				if strings.HasPrefix(a, "cs") && strings.IndexByte(a, '-') == -1 {
0000000000000000000000000000000000000000;;					// Some of the constant definitions have comments in them. Strip those.
0000000000000000000000000000000000000000;;					constName = strings.Title(strings.SplitN(a[2:], "\n", 2)[0])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if constName == "" {
0000000000000000000000000000000000000000;;				switch rec.MIB {
0000000000000000000000000000000000000000;;				case "2085":
0000000000000000000000000000000000000000;;					constName = "HZGB2312" // Not listed as alias for some reason.
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					log.Fatalf("No cs alias defined for %s.", rec.MIB)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rec.MIME != "" {
0000000000000000000000000000000000000000;;				rec.MIME = fmt.Sprintf(" (MIME: %s)", rec.MIME)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "// %s is the MIB identifier with IANA name %s%s.\n//\n", constName, rec.Name, rec.MIME)
0000000000000000000000000000000000000000;;			if len(rec.Desc.Data) > 0 {
0000000000000000000000000000000000000000;;				fmt.Fprint(w, "// ")
0000000000000000000000000000000000000000;;				d := xml.NewDecoder(strings.NewReader(rec.Desc.Data))
0000000000000000000000000000000000000000;;				inElem := true
0000000000000000000000000000000000000000;;				attr := ""
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					t, err := d.Token()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						if err != io.EOF {
0000000000000000000000000000000000000000;;							log.Fatal(err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					switch x := t.(type) {
0000000000000000000000000000000000000000;;					case xml.CharData:
0000000000000000000000000000000000000000;;						attr = "" // Don't need attribute info.
0000000000000000000000000000000000000000;;						a := bytes.Split([]byte(x), []byte("\n"))
0000000000000000000000000000000000000000;;						for i, b := range a {
0000000000000000000000000000000000000000;;							if b = bytes.TrimSpace(b); len(b) != 0 {
0000000000000000000000000000000000000000;;								if !inElem && i > 0 {
0000000000000000000000000000000000000000;;									fmt.Fprint(w, "\n// ")
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;								inElem = false
0000000000000000000000000000000000000000;;								fmt.Fprintf(w, "%s ", string(b))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case xml.StartElement:
0000000000000000000000000000000000000000;;						if x.Name.Local == "xref" {
0000000000000000000000000000000000000000;;							inElem = true
0000000000000000000000000000000000000000;;							use := false
0000000000000000000000000000000000000000;;							for _, a := range x.Attr {
0000000000000000000000000000000000000000;;								if a.Name.Local == "type" {
0000000000000000000000000000000000000000;;									use = use || a.Value != "person"
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;								if a.Name.Local == "data" && use {
0000000000000000000000000000000000000000;;									attr = a.Value + " "
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case xml.EndElement:
0000000000000000000000000000000000000000;;						inElem = false
0000000000000000000000000000000000000000;;						fmt.Fprint(w, attr)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fmt.Fprint(w, "\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, x := range rec.Xref {
0000000000000000000000000000000000000000;;				switch x.Type {
0000000000000000000000000000000000000000;;				case "rfc":
0000000000000000000000000000000000000000;;					fmt.Fprintf(w, "// Reference: %s\n", strings.ToUpper(x.Data))
0000000000000000000000000000000000000000;;				case "uri":
0000000000000000000000000000000000000000;;					fmt.Fprintf(w, "// Reference: %s\n", x.Data)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%s MIB = %s\n", constName, rec.MIB)
0000000000000000000000000000000000000000;;			fmt.Fprintln(w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, ")")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gen.WriteGoFile("mib.go", "identifier", w.Bytes())
0000000000000000000000000000000000000000;;	}
