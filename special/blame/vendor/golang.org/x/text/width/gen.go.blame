0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// +build ignore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This program generates the trie for width operations. The generated table
0000000000000000000000000000000000000000;;	// includes width category information as well as the normalization mappings.
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/gen"
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/triegen"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See gen_common.go for flags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		gen.Init()
0000000000000000000000000000000000000000;;		genTables()
0000000000000000000000000000000000000000;;		genTests()
0000000000000000000000000000000000000000;;		gen.Repackage("gen_trieval.go", "trieval.go", "width")
0000000000000000000000000000000000000000;;		gen.Repackage("gen_common.go", "common_test.go", "width")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genTables() {
0000000000000000000000000000000000000000;;		t := triegen.NewTrie("width")
0000000000000000000000000000000000000000;;		// fold and inverse mappings. See mapComment for a description of the format
0000000000000000000000000000000000000000;;		// of each entry. Add dummy value to make an index of 0 mean no mapping.
0000000000000000000000000000000000000000;;		inverse := [][4]byte{{}}
0000000000000000000000000000000000000000;;		mapping := map[[4]byte]int{[4]byte{}: 0}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getWidthData(func(r rune, tag elem, alt rune) {
0000000000000000000000000000000000000000;;			idx := 0
0000000000000000000000000000000000000000;;			if alt != 0 {
0000000000000000000000000000000000000000;;				var buf [4]byte
0000000000000000000000000000000000000000;;				buf[0] = byte(utf8.EncodeRune(buf[1:], alt))
0000000000000000000000000000000000000000;;				s := string(r)
0000000000000000000000000000000000000000;;				buf[buf[0]] ^= s[len(s)-1]
0000000000000000000000000000000000000000;;				var ok bool
0000000000000000000000000000000000000000;;				if idx, ok = mapping[buf]; !ok {
0000000000000000000000000000000000000000;;					idx = len(mapping)
0000000000000000000000000000000000000000;;					if idx > math.MaxUint8 {
0000000000000000000000000000000000000000;;						log.Fatalf("Index %d does not fit in a byte.", idx)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					mapping[buf] = idx
0000000000000000000000000000000000000000;;					inverse = append(inverse, buf)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Insert(r, uint64(tag|elem(idx)))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		gen.WriteUnicodeVersion(w)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sz, err := t.Gen(w)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sz += writeMappings(w, inverse)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "// Total table size %d bytes (%dKiB)\n", sz, sz/1024)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gen.WriteGoFile(*outputFile, "width", w.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const inverseDataComment = `
0000000000000000000000000000000000000000;;	// inverseData contains 4-byte entries of the following format:
0000000000000000000000000000000000000000;;	//   <length> <modified UTF-8-encoded rune> <0 padding>
0000000000000000000000000000000000000000;;	// The last byte of the UTF-8-encoded rune is xor-ed with the last byte of the
0000000000000000000000000000000000000000;;	// UTF-8 encoding of the original rune. Mappings often have the following
0000000000000000000000000000000000000000;;	// pattern:
0000000000000000000000000000000000000000;;	//   Ａ -> A  (U+FF21 -> U+0041)
0000000000000000000000000000000000000000;;	//   Ｂ -> B  (U+FF22 -> U+0042)
0000000000000000000000000000000000000000;;	//   ...
0000000000000000000000000000000000000000;;	// By xor-ing the last byte the same entry can be shared by many mappings. This
0000000000000000000000000000000000000000;;	// reduces the total number of distinct entries by about two thirds.
0000000000000000000000000000000000000000;;	// The resulting entry for the aforementioned mappings is
0000000000000000000000000000000000000000;;	//   { 0x01, 0xE0, 0x00, 0x00 }
0000000000000000000000000000000000000000;;	// Using this entry to map U+FF21 (UTF-8 [EF BC A1]), we get
0000000000000000000000000000000000000000;;	//   E0 ^ A1 = 41.
0000000000000000000000000000000000000000;;	// Similarly, for U+FF22 (UTF-8 [EF BC A2]), we get
0000000000000000000000000000000000000000;;	//   E0 ^ A2 = 42.
0000000000000000000000000000000000000000;;	// Note that because of the xor-ing, the byte sequence stored in the entry is
0000000000000000000000000000000000000000;;	// not valid UTF-8.`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeMappings(w io.Writer, data [][4]byte) int {
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, inverseDataComment)
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "var inverseData = [%d][4]byte{\n", len(data))
0000000000000000000000000000000000000000;;		for _, x := range data {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "{ 0x%02x, 0x%02x, 0x%02x, 0x%02x },\n", x[0], x[1], x[2], x[3])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "}")
0000000000000000000000000000000000000000;;		return len(data) * 4
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genTests() {
0000000000000000000000000000000000000000;;		w := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "\nvar mapRunes = map[rune]struct{r rune; e elem}{\n")
0000000000000000000000000000000000000000;;		getWidthData(func(r rune, tag elem, alt rune) {
0000000000000000000000000000000000000000;;			if alt != 0 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "\t0x%X: {0x%X, 0x%X},\n", r, alt, tag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "}")
0000000000000000000000000000000000000000;;		gen.WriteGoFile("runes_test.go", "width", w.Bytes())
0000000000000000000000000000000000000000;;	}
