0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	//go:generate stringer -type=Kind
0000000000000000000000000000000000000000;;	//go:generate go run gen.go gen_common.go gen_trieval.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package width provides functionality for handling different widths in text.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Wide characters behave like ideographs; they tend to allow line breaks after
0000000000000000000000000000000000000000;;	// each character and remain upright in vertical text layout. Narrow characters
0000000000000000000000000000000000000000;;	// are kept together in words or runs that are rotated sideways in vertical text
0000000000000000000000000000000000000000;;	// layout.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more information, see http://unicode.org/reports/tr11/.
0000000000000000000000000000000000000000;;	package width
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO
0000000000000000000000000000000000000000;;	// 1) Reduce table size by compressing blocks.
0000000000000000000000000000000000000000;;	// 2) API proposition for computing display length
0000000000000000000000000000000000000000;;	//    (approximation, fixed pitch only).
0000000000000000000000000000000000000000;;	// 3) Implement display length.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Kind indicates the type of width property as defined in http://unicode.org/reports/tr11/.
0000000000000000000000000000000000000000;;	type Kind int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Neutral characters do not occur in legacy East Asian character sets.
0000000000000000000000000000000000000000;;		Neutral Kind = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EastAsianAmbiguous characters that can be sometimes wide and sometimes
0000000000000000000000000000000000000000;;		// narrow and require additional information not contained in the character
0000000000000000000000000000000000000000;;		// code to further resolve their width.
0000000000000000000000000000000000000000;;		EastAsianAmbiguous
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EastAsianWide characters are wide in its usual form. They occur only in
0000000000000000000000000000000000000000;;		// the context of East Asian typography. These runes may have explicit
0000000000000000000000000000000000000000;;		// halfwidth counterparts.
0000000000000000000000000000000000000000;;		EastAsianWide
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EastAsianNarrow characters are narrow in its usual form. They often have
0000000000000000000000000000000000000000;;		// fullwidth counterparts.
0000000000000000000000000000000000000000;;		EastAsianNarrow
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note: there exist Narrow runes that do not have fullwidth or wide
0000000000000000000000000000000000000000;;		// counterparts, despite what the definition says (e.g. U+27E6).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EastAsianFullwidth characters have a compatibility decompositions of type
0000000000000000000000000000000000000000;;		// wide that map to a narrow counterpart.
0000000000000000000000000000000000000000;;		EastAsianFullwidth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EastAsianHalfwidth characters have a compatibility decomposition of type
0000000000000000000000000000000000000000;;		// narrow that map to a wide or ambiguous counterpart, plus U+20A9 â‚© WON
0000000000000000000000000000000000000000;;		// SIGN.
0000000000000000000000000000000000000000;;		EastAsianHalfwidth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note: there exist runes that have a halfwidth counterparts but that are
0000000000000000000000000000000000000000;;		// classified as Ambiguous, rather than wide (e.g. U+2190).
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: the generated tries need to return size 1 for invalid runes for the
0000000000000000000000000000000000000000;;	// width to be computed correctly (each byte should render width 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var trie = newWidthTrie(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lookup reports the Properties of the first rune in b and the number of bytes
0000000000000000000000000000000000000000;;	// of its UTF-8 encoding.
0000000000000000000000000000000000000000;;	func Lookup(b []byte) (p Properties, size int) {
0000000000000000000000000000000000000000;;		v, sz := trie.lookup(b)
0000000000000000000000000000000000000000;;		return Properties{elem(v), b[sz-1]}, sz
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupString reports the Properties of the first rune in s and the number of
0000000000000000000000000000000000000000;;	// bytes of its UTF-8 encoding.
0000000000000000000000000000000000000000;;	func LookupString(s string) (p Properties, size int) {
0000000000000000000000000000000000000000;;		v, sz := trie.lookupString(s)
0000000000000000000000000000000000000000;;		return Properties{elem(v), s[sz-1]}, sz
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LookupRune reports the Properties of rune r.
0000000000000000000000000000000000000000;;	func LookupRune(r rune) Properties {
0000000000000000000000000000000000000000;;		var buf [4]byte
0000000000000000000000000000000000000000;;		n := utf8.EncodeRune(buf[:], r)
0000000000000000000000000000000000000000;;		v, _ := trie.lookup(buf[:n])
0000000000000000000000000000000000000000;;		last := byte(r)
0000000000000000000000000000000000000000;;		if r >= utf8.RuneSelf {
0000000000000000000000000000000000000000;;			last = 0x80 + byte(r&0x3f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Properties{elem(v), last}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Properties provides access to width properties of a rune.
0000000000000000000000000000000000000000;;	type Properties struct {
0000000000000000000000000000000000000000;;		elem elem
0000000000000000000000000000000000000000;;		last byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e elem) kind() Kind {
0000000000000000000000000000000000000000;;		return Kind(e >> typeShift)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Kind returns the Kind of a rune as defined in Unicode TR #11.
0000000000000000000000000000000000000000;;	// See http://unicode.org/reports/tr11/ for more details.
0000000000000000000000000000000000000000;;	func (p Properties) Kind() Kind {
0000000000000000000000000000000000000000;;		return p.elem.kind()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Folded returns the folded variant of a rune or 0 if the rune is canonical.
0000000000000000000000000000000000000000;;	func (p Properties) Folded() rune {
0000000000000000000000000000000000000000;;		if p.elem&tagNeedsFold != 0 {
0000000000000000000000000000000000000000;;			buf := inverseData[byte(p.elem)]
0000000000000000000000000000000000000000;;			buf[buf[0]] ^= p.last
0000000000000000000000000000000000000000;;			r, _ := utf8.DecodeRune(buf[1 : 1+buf[0]])
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Narrow returns the narrow variant of a rune or 0 if the rune is already
0000000000000000000000000000000000000000;;	// narrow or doesn't have a narrow variant.
0000000000000000000000000000000000000000;;	func (p Properties) Narrow() rune {
0000000000000000000000000000000000000000;;		if k := p.elem.kind(); byte(p.elem) != 0 && (k == EastAsianFullwidth || k == EastAsianWide || k == EastAsianAmbiguous) {
0000000000000000000000000000000000000000;;			buf := inverseData[byte(p.elem)]
0000000000000000000000000000000000000000;;			buf[buf[0]] ^= p.last
0000000000000000000000000000000000000000;;			r, _ := utf8.DecodeRune(buf[1 : 1+buf[0]])
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wide returns the wide variant of a rune or 0 if the rune is already
0000000000000000000000000000000000000000;;	// wide or doesn't have a wide variant.
0000000000000000000000000000000000000000;;	func (p Properties) Wide() rune {
0000000000000000000000000000000000000000;;		if k := p.elem.kind(); byte(p.elem) != 0 && (k == EastAsianHalfwidth || k == EastAsianNarrow) {
0000000000000000000000000000000000000000;;			buf := inverseData[byte(p.elem)]
0000000000000000000000000000000000000000;;			buf[buf[0]] ^= p.last
0000000000000000000000000000000000000000;;			r, _ := utf8.DecodeRune(buf[1 : 1+buf[0]])
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO for Properties:
0000000000000000000000000000000000000000;;	// - Add Fullwidth/Halfwidth or Inverted methods for computing variants
0000000000000000000000000000000000000000;;	// mapping.
0000000000000000000000000000000000000000;;	// - Add width information (including information on non-spacing runes).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transformer implements the transform.Transformer interface.
0000000000000000000000000000000000000000;;	type Transformer struct {
0000000000000000000000000000000000000000;;		t transform.Transformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset implements the transform.Transformer interface.
0000000000000000000000000000000000000000;;	func (t Transformer) Reset() { t.t.Reset() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform implements the Transformer interface.
0000000000000000000000000000000000000000;;	func (t Transformer) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		return t.t.Transform(dst, src, atEOF)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns a new byte slice with the result of applying t to b.
0000000000000000000000000000000000000000;;	func (t Transformer) Bytes(b []byte) []byte {
0000000000000000000000000000000000000000;;		b, _, _ = transform.Bytes(t, b)
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string with the result of applying t to s.
0000000000000000000000000000000000000000;;	func (t Transformer) String(s string) string {
0000000000000000000000000000000000000000;;		s, _, _ = transform.String(t, s)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Fold is a transform that maps all runes to their canonical width.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note that the NFKC and NFKD transforms in golang.org/x/text/unicode/norm
0000000000000000000000000000000000000000;;		// provide a more generic folding mechanism.
0000000000000000000000000000000000000000;;		Fold Transformer = Transformer{foldTransform{}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Widen is a transform that maps runes to their wide variant, if
0000000000000000000000000000000000000000;;		// available.
0000000000000000000000000000000000000000;;		Widen Transformer = Transformer{wideTransform{}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Narrow is a transform that maps runes to their narrow variant, if
0000000000000000000000000000000000000000;;		// available.
0000000000000000000000000000000000000000;;		Narrow Transformer = Transformer{narrowTransform{}}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Consider the following options:
0000000000000000000000000000000000000000;;	// - Treat Ambiguous runes that have a halfwidth counterpart as wide, or some
0000000000000000000000000000000000000000;;	//   generalized variant of this.
0000000000000000000000000000000000000000;;	// - Consider a wide Won character to be the default width (or some generalized
0000000000000000000000000000000000000000;;	//   variant of this).
0000000000000000000000000000000000000000;;	// - Filter the set of characters that gets converted (the preferred approach is
0000000000000000000000000000000000000000;;	//   to allow applying filters to transforms).
