0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package width
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type foldTransform struct {
0000000000000000000000000000000000000000;;		transform.NopResetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (foldTransform) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		for nSrc < len(src) {
0000000000000000000000000000000000000000;;			if src[nSrc] < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				// ASCII fast path.
0000000000000000000000000000000000000000;;				start, end := nSrc, len(src)
0000000000000000000000000000000000000000;;				if d := len(dst) - nDst; d < end-start {
0000000000000000000000000000000000000000;;					end = nSrc + d
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for nSrc++; nSrc < end && src[nSrc] < utf8.RuneSelf; nSrc++ {
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n := copy(dst[nDst:], src[start:nSrc])
0000000000000000000000000000000000000000;;				if nDst += n; nDst == len(dst) {
0000000000000000000000000000000000000000;;					nSrc = start + n
0000000000000000000000000000000000000000;;					if nSrc == len(src) {
0000000000000000000000000000000000000000;;						return nDst, nSrc, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if src[nSrc] < utf8.RuneSelf {
0000000000000000000000000000000000000000;;						return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v, size := trie.lookup(src[nSrc:])
0000000000000000000000000000000000000000;;			if size == 0 { // incomplete UTF-8 encoding
0000000000000000000000000000000000000000;;				if !atEOF {
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortSrc
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				size = 1 // gobble 1 byte
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if elem(v)&tagNeedsFold == 0 {
0000000000000000000000000000000000000000;;				if size != copy(dst[nDst:], src[nSrc:nSrc+size]) {
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nDst += size
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				data := inverseData[byte(v)]
0000000000000000000000000000000000000000;;				if len(dst)-nDst < int(data[0]) {
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i := 1
0000000000000000000000000000000000000000;;				for end := int(data[0]); i < end; i++ {
0000000000000000000000000000000000000000;;					dst[nDst] = data[i]
0000000000000000000000000000000000000000;;					nDst++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst[nDst] = data[i] ^ src[nSrc+size-1]
0000000000000000000000000000000000000000;;				nDst++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nSrc += size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type narrowTransform struct {
0000000000000000000000000000000000000000;;		transform.NopResetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (narrowTransform) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		for nSrc < len(src) {
0000000000000000000000000000000000000000;;			if src[nSrc] < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				// ASCII fast path.
0000000000000000000000000000000000000000;;				start, end := nSrc, len(src)
0000000000000000000000000000000000000000;;				if d := len(dst) - nDst; d < end-start {
0000000000000000000000000000000000000000;;					end = nSrc + d
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for nSrc++; nSrc < end && src[nSrc] < utf8.RuneSelf; nSrc++ {
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n := copy(dst[nDst:], src[start:nSrc])
0000000000000000000000000000000000000000;;				if nDst += n; nDst == len(dst) {
0000000000000000000000000000000000000000;;					nSrc = start + n
0000000000000000000000000000000000000000;;					if nSrc == len(src) {
0000000000000000000000000000000000000000;;						return nDst, nSrc, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if src[nSrc] < utf8.RuneSelf {
0000000000000000000000000000000000000000;;						return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v, size := trie.lookup(src[nSrc:])
0000000000000000000000000000000000000000;;			if size == 0 { // incomplete UTF-8 encoding
0000000000000000000000000000000000000000;;				if !atEOF {
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortSrc
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				size = 1 // gobble 1 byte
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if k := elem(v).kind(); byte(v) == 0 || k != EastAsianFullwidth && k != EastAsianWide && k != EastAsianAmbiguous {
0000000000000000000000000000000000000000;;				if size != copy(dst[nDst:], src[nSrc:nSrc+size]) {
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nDst += size
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				data := inverseData[byte(v)]
0000000000000000000000000000000000000000;;				if len(dst)-nDst < int(data[0]) {
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i := 1
0000000000000000000000000000000000000000;;				for end := int(data[0]); i < end; i++ {
0000000000000000000000000000000000000000;;					dst[nDst] = data[i]
0000000000000000000000000000000000000000;;					nDst++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst[nDst] = data[i] ^ src[nSrc+size-1]
0000000000000000000000000000000000000000;;				nDst++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nSrc += size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type wideTransform struct {
0000000000000000000000000000000000000000;;		transform.NopResetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wideTransform) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		for nSrc < len(src) {
0000000000000000000000000000000000000000;;			// TODO: Consider ASCII fast path. Special-casing ASCII handling can
0000000000000000000000000000000000000000;;			// reduce the ns/op of BenchmarkWideASCII by about 30%. This is probably
0000000000000000000000000000000000000000;;			// not enough to warrant the extra code and complexity.
0000000000000000000000000000000000000000;;			v, size := trie.lookup(src[nSrc:])
0000000000000000000000000000000000000000;;			if size == 0 { // incomplete UTF-8 encoding
0000000000000000000000000000000000000000;;				if !atEOF {
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortSrc
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				size = 1 // gobble 1 byte
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if k := elem(v).kind(); byte(v) == 0 || k != EastAsianHalfwidth && k != EastAsianNarrow {
0000000000000000000000000000000000000000;;				if size != copy(dst[nDst:], src[nSrc:nSrc+size]) {
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nDst += size
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				data := inverseData[byte(v)]
0000000000000000000000000000000000000000;;				if len(dst)-nDst < int(data[0]) {
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i := 1
0000000000000000000000000000000000000000;;				for end := int(data[0]); i < end; i++ {
0000000000000000000000000000000000000000;;					dst[nDst] = data[i]
0000000000000000000000000000000000000000;;					nDst++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst[nDst] = data[i] ^ src[nSrc+size-1]
0000000000000000000000000000000000000000;;				nDst++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nSrc += size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, nil
0000000000000000000000000000000000000000;;	}
