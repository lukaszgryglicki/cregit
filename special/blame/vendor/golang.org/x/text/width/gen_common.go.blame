0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// +build ignore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This code is shared between the main code generator and the test code.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/gen"
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/ucd"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		outputFile = flag.String("out", "tables.go", "output file")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeMap = map[string]elem{
0000000000000000000000000000000000000000;;		"A":  tagAmbiguous,
0000000000000000000000000000000000000000;;		"N":  tagNeutral,
0000000000000000000000000000000000000000;;		"Na": tagNarrow,
0000000000000000000000000000000000000000;;		"W":  tagWide,
0000000000000000000000000000000000000000;;		"F":  tagFullwidth,
0000000000000000000000000000000000000000;;		"H":  tagHalfwidth,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getWidthData calls f for every entry for which it is defined.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// f may be called multiple times for the same rune. The last call to f is the
0000000000000000000000000000000000000000;;	// correct value. f is not called for all runes. The default tag type is
0000000000000000000000000000000000000000;;	// Neutral.
0000000000000000000000000000000000000000;;	func getWidthData(f func(r rune, tag elem, alt rune)) {
0000000000000000000000000000000000000000;;		// Set the default values for Unified Ideographs. In line with Annex 11,
0000000000000000000000000000000000000000;;		// we encode full ranges instead of the defined runes in Unified_Ideograph.
0000000000000000000000000000000000000000;;		for _, b := range []struct{ lo, hi rune }{
0000000000000000000000000000000000000000;;			{0x4E00, 0x9FFF},   // the CJK Unified Ideographs block,
0000000000000000000000000000000000000000;;			{0x3400, 0x4DBF},   // the CJK Unified Ideographs Externsion A block,
0000000000000000000000000000000000000000;;			{0xF900, 0xFAFF},   // the CJK Compatibility Ideographs block,
0000000000000000000000000000000000000000;;			{0x20000, 0x2FFFF}, // the Supplementary Ideographic Plane,
0000000000000000000000000000000000000000;;			{0x30000, 0x3FFFF}, // the Tertiary Ideographic Plane,
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			for r := b.lo; r <= b.hi; r++ {
0000000000000000000000000000000000000000;;				f(r, tagWide, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inverse := map[rune]rune{}
0000000000000000000000000000000000000000;;		maps := map[string]bool{
0000000000000000000000000000000000000000;;			"<wide>":   true,
0000000000000000000000000000000000000000;;			"<narrow>": true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We cannot reuse package norm's decomposition, as we need an unexpanded
0000000000000000000000000000000000000000;;		// decomposition. We make use of the opportunity to verify that the
0000000000000000000000000000000000000000;;		// decomposition type is as expected.
0000000000000000000000000000000000000000;;		ucd.Parse(gen.OpenUCDFile("UnicodeData.txt"), func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			r := p.Rune(0)
0000000000000000000000000000000000000000;;			s := strings.SplitN(p.String(ucd.DecompMapping), " ", 2)
0000000000000000000000000000000000000000;;			if !maps[s[0]] {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x, err := strconv.ParseUint(s[1], 16, 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Fatalf("Error parsing rune %q", s[1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if inverse[r] != 0 || inverse[rune(x)] != 0 {
0000000000000000000000000000000000000000;;				log.Fatalf("Circular dependency in mapping between %U and %U", r, x)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			inverse[r] = rune(x)
0000000000000000000000000000000000000000;;			inverse[rune(x)] = r
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// <rune range>;<type>
0000000000000000000000000000000000000000;;		ucd.Parse(gen.OpenUCDFile("EastAsianWidth.txt"), func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			tag, ok := typeMap[p.String(1)]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				log.Fatalf("Unknown width type %q", p.String(1))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r := p.Rune(0)
0000000000000000000000000000000000000000;;			alt, ok := inverse[r]
0000000000000000000000000000000000000000;;			if tag == tagFullwidth || tag == tagHalfwidth && r != wonSign {
0000000000000000000000000000000000000000;;				tag |= tagNeedsFold
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					log.Fatalf("Narrow or wide rune %U has no decomposition", r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f(r, tag, alt)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
