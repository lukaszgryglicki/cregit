0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// Unicode table generator.
0000000000000000000000000000000000000000;;	// Data read from the web.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +build ignore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/gen"
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/triegen"
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/ucd"
0000000000000000000000000000000000000000;;		"golang.org/x/text/unicode/norm"
0000000000000000000000000000000000000000;;		"golang.org/x/text/unicode/rangetable"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var outputFile = flag.String("output", "tables.go", "output file for generated tables; default tables.go")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var assigned, disallowedRunes *unicode.RangeTable
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var runeCategory = map[rune]category{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var overrides = map[category]category{
0000000000000000000000000000000000000000;;		viramaModifier: viramaJoinT,
0000000000000000000000000000000000000000;;		greek:          greekJoinT,
0000000000000000000000000000000000000000;;		hebrew:         hebrewJoinT,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setCategory(r rune, cat category) {
0000000000000000000000000000000000000000;;		if c, ok := runeCategory[r]; ok {
0000000000000000000000000000000000000000;;			if override, ok := overrides[c]; cat == joiningT && ok {
0000000000000000000000000000000000000000;;				cat = override
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: multiple categories for rune (%v and %v)", r, c, cat)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runeCategory[r] = cat
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if numCategories > 1<<propShift {
0000000000000000000000000000000000000000;;			log.Fatalf("Number of categories is %d; may at most be %d", numCategories, 1<<propShift)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		gen.Init()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Load data
0000000000000000000000000000000000000000;;		runes := []rune{}
0000000000000000000000000000000000000000;;		// PrecisIgnorableProperties: https://tools.ietf.org/html/rfc7564#section-9.13
0000000000000000000000000000000000000000;;		ucd.Parse(gen.OpenUCDFile("DerivedCoreProperties.txt"), func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			if p.String(1) == "Default_Ignorable_Code_Point" {
0000000000000000000000000000000000000000;;				runes = append(runes, p.Rune(0))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		ucd.Parse(gen.OpenUCDFile("PropList.txt"), func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			switch p.String(1) {
0000000000000000000000000000000000000000;;			case "Noncharacter_Code_Point":
0000000000000000000000000000000000000000;;				runes = append(runes, p.Rune(0))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		// OldHangulJamo: https://tools.ietf.org/html/rfc5892#section-2.9
0000000000000000000000000000000000000000;;		ucd.Parse(gen.OpenUCDFile("HangulSyllableType.txt"), func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			switch p.String(1) {
0000000000000000000000000000000000000000;;			case "L", "V", "T":
0000000000000000000000000000000000000000;;				runes = append(runes, p.Rune(0))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		disallowedRunes = rangetable.New(runes...)
0000000000000000000000000000000000000000;;		assigned = rangetable.Assigned(unicode.Version)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Load category data.
0000000000000000000000000000000000000000;;		runeCategory['l'] = latinSmallL
0000000000000000000000000000000000000000;;		ucd.Parse(gen.OpenUCDFile("UnicodeData.txt"), func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			const cccVirama = 9
0000000000000000000000000000000000000000;;			if p.Int(ucd.CanonicalCombiningClass) == cccVirama {
0000000000000000000000000000000000000000;;				setCategory(p.Rune(0), viramaModifier)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		ucd.Parse(gen.OpenUCDFile("Scripts.txt"), func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			switch p.String(1) {
0000000000000000000000000000000000000000;;			case "Greek":
0000000000000000000000000000000000000000;;				setCategory(p.Rune(0), greek)
0000000000000000000000000000000000000000;;			case "Hebrew":
0000000000000000000000000000000000000000;;				setCategory(p.Rune(0), hebrew)
0000000000000000000000000000000000000000;;			case "Hiragana", "Katakana", "Han":
0000000000000000000000000000000000000000;;				setCategory(p.Rune(0), japanese)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the rule categories associated with exceptions. This overrides any
0000000000000000000000000000000000000000;;		// previously set categories. The original categories are manually
0000000000000000000000000000000000000000;;		// reintroduced in the categoryTransitions table.
0000000000000000000000000000000000000000;;		for r, e := range exceptions {
0000000000000000000000000000000000000000;;			if e.cat != 0 {
0000000000000000000000000000000000000000;;				runeCategory[r] = e.cat
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cat := map[string]category{
0000000000000000000000000000000000000000;;			"L": joiningL,
0000000000000000000000000000000000000000;;			"D": joiningD,
0000000000000000000000000000000000000000;;			"T": joiningT,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"R": joiningR,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ucd.Parse(gen.OpenUCDFile("extracted/DerivedJoiningType.txt"), func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			switch v := p.String(1); v {
0000000000000000000000000000000000000000;;			case "L", "D", "T", "R":
0000000000000000000000000000000000000000;;				setCategory(p.Rune(0), cat[v])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		writeTables()
0000000000000000000000000000000000000000;;		gen.Repackage("gen_trieval.go", "trieval.go", "precis")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type exception struct {
0000000000000000000000000000000000000000;;		prop property
0000000000000000000000000000000000000000;;		cat  category
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// Programmatically add the Arabic and Indic digits to the exceptions map.
0000000000000000000000000000000000000000;;		// See comment in the exceptions map below why these are marked disallowed.
0000000000000000000000000000000000000000;;		for i := rune(0); i <= 9; i++ {
0000000000000000000000000000000000000000;;			exceptions[0x0660+i] = exception{
0000000000000000000000000000000000000000;;				prop: disallowed,
0000000000000000000000000000000000000000;;				cat:  arabicIndicDigit,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			exceptions[0x06F0+i] = exception{
0000000000000000000000000000000000000000;;				prop: disallowed,
0000000000000000000000000000000000000000;;				cat:  extendedArabicIndicDigit,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Exceptions class as defined in RFC 5892
0000000000000000000000000000000000000000;;	// https://tools.ietf.org/html/rfc5892#section-2.6
0000000000000000000000000000000000000000;;	var exceptions = map[rune]exception{
0000000000000000000000000000000000000000;;		0x00DF: {prop: pValid},
0000000000000000000000000000000000000000;;		0x03C2: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06FD: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06FE: {prop: pValid},
0000000000000000000000000000000000000000;;		0x0F0B: {prop: pValid},
0000000000000000000000000000000000000000;;		0x3007: {prop: pValid},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ContextO|J rules are marked as disallowed, taking a "guilty until proven
0000000000000000000000000000000000000000;;		// innocent" approach. The main reason for this is that the check for
0000000000000000000000000000000000000000;;		// whether a context rule should be applied can be moved to the logic for
0000000000000000000000000000000000000000;;		// handing disallowed runes, taken it off the common path. The exception to
0000000000000000000000000000000000000000;;		// this rule is for katakanaMiddleDot, as the rule logic is handled without
0000000000000000000000000000000000000000;;		// using a rule function.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ContextJ (Join control)
0000000000000000000000000000000000000000;;		0x200C: {prop: disallowed, cat: zeroWidthNonJoiner},
0000000000000000000000000000000000000000;;		0x200D: {prop: disallowed, cat: zeroWidthJoiner},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ContextO
0000000000000000000000000000000000000000;;		0x00B7: {prop: disallowed, cat: middleDot},
0000000000000000000000000000000000000000;;		0x0375: {prop: disallowed, cat: greekLowerNumeralSign},
0000000000000000000000000000000000000000;;		0x05F3: {prop: disallowed, cat: hebrewPreceding}, // punctuation Geresh
0000000000000000000000000000000000000000;;		0x05F4: {prop: disallowed, cat: hebrewPreceding}, // punctuation Gershayim
0000000000000000000000000000000000000000;;		0x30FB: {prop: pValid, cat: katakanaMiddleDot},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These are officially ContextO, but the implementation does not require
0000000000000000000000000000000000000000;;		// special treatment of these, so we simply mark them as valid.
0000000000000000000000000000000000000000;;		0x0660: {prop: pValid},
0000000000000000000000000000000000000000;;		0x0661: {prop: pValid},
0000000000000000000000000000000000000000;;		0x0662: {prop: pValid},
0000000000000000000000000000000000000000;;		0x0663: {prop: pValid},
0000000000000000000000000000000000000000;;		0x0664: {prop: pValid},
0000000000000000000000000000000000000000;;		0x0665: {prop: pValid},
0000000000000000000000000000000000000000;;		0x0666: {prop: pValid},
0000000000000000000000000000000000000000;;		0x0667: {prop: pValid},
0000000000000000000000000000000000000000;;		0x0668: {prop: pValid},
0000000000000000000000000000000000000000;;		0x0669: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06F0: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06F1: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06F2: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06F3: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06F4: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06F5: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06F6: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06F7: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06F8: {prop: pValid},
0000000000000000000000000000000000000000;;		0x06F9: {prop: pValid},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		0x0640: {prop: disallowed},
0000000000000000000000000000000000000000;;		0x07FA: {prop: disallowed},
0000000000000000000000000000000000000000;;		0x302E: {prop: disallowed},
0000000000000000000000000000000000000000;;		0x302F: {prop: disallowed},
0000000000000000000000000000000000000000;;		0x3031: {prop: disallowed},
0000000000000000000000000000000000000000;;		0x3032: {prop: disallowed},
0000000000000000000000000000000000000000;;		0x3033: {prop: disallowed},
0000000000000000000000000000000000000000;;		0x3034: {prop: disallowed},
0000000000000000000000000000000000000000;;		0x3035: {prop: disallowed},
0000000000000000000000000000000000000000;;		0x303B: {prop: disallowed},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LetterDigits: https://tools.ietf.org/html/rfc5892#section-2.1
0000000000000000000000000000000000000000;;	// r in {Ll, Lu, Lo, Nd, Lm, Mn, Mc}.
0000000000000000000000000000000000000000;;	func isLetterDigits(r rune) bool {
0000000000000000000000000000000000000000;;		return unicode.In(r,
0000000000000000000000000000000000000000;;			unicode.Ll, unicode.Lu, unicode.Lm, unicode.Lo, // Letters
0000000000000000000000000000000000000000;;			unicode.Mn, unicode.Mc, // Modifiers
0000000000000000000000000000000000000000;;			unicode.Nd, // Digits
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isIdDisAndFreePVal(r rune) bool {
0000000000000000000000000000000000000000;;		return unicode.In(r,
0000000000000000000000000000000000000000;;			// OtherLetterDigits: https://tools.ietf.org/html/rfc7564#section-9.18
0000000000000000000000000000000000000000;;			// r in in {Lt, Nl, No, Me}
0000000000000000000000000000000000000000;;			unicode.Lt, unicode.Nl, unicode.No, // Other letters / numbers
0000000000000000000000000000000000000000;;			unicode.Me, // Modifiers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Spaces: https://tools.ietf.org/html/rfc7564#section-9.14
0000000000000000000000000000000000000000;;			// r in in {Zs}
0000000000000000000000000000000000000000;;			unicode.Zs,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Symbols: https://tools.ietf.org/html/rfc7564#section-9.15
0000000000000000000000000000000000000000;;			// r in {Sm, Sc, Sk, So}
0000000000000000000000000000000000000000;;			unicode.Sm, unicode.Sc, unicode.Sk, unicode.So,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Punctuation: https://tools.ietf.org/html/rfc7564#section-9.16
0000000000000000000000000000000000000000;;			// r in {Pc, Pd, Ps, Pe, Pi, Pf, Po}
0000000000000000000000000000000000000000;;			unicode.Pc, unicode.Pd, unicode.Ps, unicode.Pe,
0000000000000000000000000000000000000000;;			unicode.Pi, unicode.Pf, unicode.Po,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasCompat: https://tools.ietf.org/html/rfc7564#section-9.17
0000000000000000000000000000000000000000;;	func hasCompat(r rune) bool {
0000000000000000000000000000000000000000;;		return !norm.NFKC.IsNormalString(string(r))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// From https://tools.ietf.org/html/rfc5892:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If .cp. .in. Exceptions Then Exceptions(cp);
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. BackwardCompatible Then BackwardCompatible(cp);
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. Unassigned Then UNASSIGNED;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. ASCII7 Then PVALID;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. JoinControl Then CONTEXTJ;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. OldHangulJamo Then DISALLOWED;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. PrecisIgnorableProperties Then DISALLOWED;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. Controls Then DISALLOWED;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. HasCompat Then ID_DIS or FREE_PVAL;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. LetterDigits Then PVALID;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. OtherLetterDigits Then ID_DIS or FREE_PVAL;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. Spaces Then ID_DIS or FREE_PVAL;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. Symbols Then ID_DIS or FREE_PVAL;
0000000000000000000000000000000000000000;;	//   Else If .cp. .in. Punctuation Then ID_DIS or FREE_PVAL;
0000000000000000000000000000000000000000;;	//   Else DISALLOWED;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeTables() {
0000000000000000000000000000000000000000;;		propTrie := triegen.NewTrie("derivedProperties")
0000000000000000000000000000000000000000;;		w := gen.NewCodeWriter()
0000000000000000000000000000000000000000;;		defer w.WriteGoFile(*outputFile, "precis")
0000000000000000000000000000000000000000;;		gen.WriteUnicodeVersion(w)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Iterate over all the runes...
0000000000000000000000000000000000000000;;		for i := rune(0); i < unicode.MaxRune; i++ {
0000000000000000000000000000000000000000;;			r := rune(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !utf8.ValidRune(r) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			e, ok := exceptions[i]
0000000000000000000000000000000000000000;;			p := e.prop
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case ok:
0000000000000000000000000000000000000000;;			case !unicode.In(r, assigned):
0000000000000000000000000000000000000000;;				p = unassigned
0000000000000000000000000000000000000000;;			case r >= 0x0021 && r <= 0x007e: // Is ASCII 7
0000000000000000000000000000000000000000;;				p = pValid
0000000000000000000000000000000000000000;;			case unicode.In(r, disallowedRunes, unicode.Cc):
0000000000000000000000000000000000000000;;				p = disallowed
0000000000000000000000000000000000000000;;			case hasCompat(r):
0000000000000000000000000000000000000000;;				p = idDisOrFreePVal
0000000000000000000000000000000000000000;;			case isLetterDigits(r):
0000000000000000000000000000000000000000;;				p = pValid
0000000000000000000000000000000000000000;;			case isIdDisAndFreePVal(r):
0000000000000000000000000000000000000000;;				p = idDisOrFreePVal
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				p = disallowed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cat := runeCategory[r]
0000000000000000000000000000000000000000;;			// Don't set category for runes that are disallowed.
0000000000000000000000000000000000000000;;			if p == disallowed {
0000000000000000000000000000000000000000;;				cat = exceptions[r].cat
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			propTrie.Insert(r, uint64(p)|uint64(cat))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sz, err := propTrie.Gen(w)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Size += sz
0000000000000000000000000000000000000000;;	}
