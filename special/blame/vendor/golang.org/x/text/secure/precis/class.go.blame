0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package precis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Add contextual character rules from Appendix A of RFC5892.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A class is a set of characters that match certain derived properties. The
0000000000000000000000000000000000000000;;	// PRECIS framework defines two classes: The Freeform class and the Identifier
0000000000000000000000000000000000000000;;	// class. The freeform class should be used for profiles where expressiveness is
0000000000000000000000000000000000000000;;	// prioritized over safety such as nicknames or passwords. The identifier class
0000000000000000000000000000000000000000;;	// should be used for profiles where safety is the first priority such as
0000000000000000000000000000000000000000;;	// addressable network labels and usernames.
0000000000000000000000000000000000000000;;	type class struct {
0000000000000000000000000000000000000000;;		validFrom property
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains satisfies the runes.Set interface and returns whether the given rune
0000000000000000000000000000000000000000;;	// is a member of the class.
0000000000000000000000000000000000000000;;	func (c class) Contains(r rune) bool {
0000000000000000000000000000000000000000;;		b := make([]byte, 4)
0000000000000000000000000000000000000000;;		n := utf8.EncodeRune(b, r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trieval, _ := dpTrie.lookup(b[:n])
0000000000000000000000000000000000000000;;		return c.validFrom <= property(trieval)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		identifier = &class{validFrom: pValid}
0000000000000000000000000000000000000000;;		freeform   = &class{validFrom: idDisOrFreePVal}
0000000000000000000000000000000000000000;;	)
