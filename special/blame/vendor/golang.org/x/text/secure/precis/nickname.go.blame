0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package precis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nickAdditionalMapping struct {
0000000000000000000000000000000000000000;;		// TODO: This transformer needs to be stateless somehow…
0000000000000000000000000000000000000000;;		notStart  bool
0000000000000000000000000000000000000000;;		prevSpace bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *nickAdditionalMapping) Reset() {
0000000000000000000000000000000000000000;;		t.prevSpace = false
0000000000000000000000000000000000000000;;		t.notStart = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *nickAdditionalMapping) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		// RFC 7700 §2.1.  Rules
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 2.  Additional Mapping Rule: The additional mapping rule consists of
0000000000000000000000000000000000000000;;		//                              the following sub-rules.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//        1.  Any instances of non-ASCII space MUST be mapped to ASCII
0000000000000000000000000000000000000000;;		//            space (U+0020); a non-ASCII space is any Unicode code point
0000000000000000000000000000000000000000;;		//            having a general category of "Zs", naturally with the
0000000000000000000000000000000000000000;;		//            exception of U+0020.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//        2.  Any instances of the ASCII space character at the beginning
0000000000000000000000000000000000000000;;		//            or end of a nickname MUST be removed (e.g., "stpeter " is
0000000000000000000000000000000000000000;;		//            mapped to "stpeter").
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//        3.  Interior sequences of more than one ASCII space character
0000000000000000000000000000000000000000;;		//            MUST be mapped to a single ASCII space character (e.g.,
0000000000000000000000000000000000000000;;		//            "St  Peter" is mapped to "St Peter").
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for nSrc < len(src) {
0000000000000000000000000000000000000000;;			r, size := utf8.DecodeRune(src[nSrc:])
0000000000000000000000000000000000000000;;			if size == 0 { // Incomplete UTF-8 encoding
0000000000000000000000000000000000000000;;				if !atEOF {
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortSrc
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				size = 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if unicode.Is(unicode.Zs, r) {
0000000000000000000000000000000000000000;;				t.prevSpace = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if t.prevSpace && t.notStart {
0000000000000000000000000000000000000000;;					dst[nDst] = ' '
0000000000000000000000000000000000000000;;					nDst += 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if size != copy(dst[nDst:], src[nSrc:nSrc+size]) {
0000000000000000000000000000000000000000;;					nDst += size
0000000000000000000000000000000000000000;;					return nDst, nSrc, transform.ErrShortDst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nDst += size
0000000000000000000000000000000000000000;;				t.prevSpace = false
0000000000000000000000000000000000000000;;				t.notStart = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nSrc += size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, nil
0000000000000000000000000000000000000000;;	}
