0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package precis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains tables and code related to context rules.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type catBitmap uint16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// These bits, once set depending on the current value, are never unset.
0000000000000000000000000000000000000000;;		bJapanese catBitmap = 1 << iota
0000000000000000000000000000000000000000;;		bArabicIndicDigit
0000000000000000000000000000000000000000;;		bExtendedArabicIndicDigit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These bits are set on each iteration depending on the current value.
0000000000000000000000000000000000000000;;		bJoinStart
0000000000000000000000000000000000000000;;		bJoinMid
0000000000000000000000000000000000000000;;		bJoinEnd
0000000000000000000000000000000000000000;;		bVirama
0000000000000000000000000000000000000000;;		bLatinSmallL
0000000000000000000000000000000000000000;;		bGreek
0000000000000000000000000000000000000000;;		bHebrew
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These bits indicated which of the permanent bits need to be set at the
0000000000000000000000000000000000000000;;		// end of the checks.
0000000000000000000000000000000000000000;;		bMustHaveJapn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		permanent = bJapanese | bArabicIndicDigit | bExtendedArabicIndicDigit | bMustHaveJapn
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const finalShift = 10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errContext = errors.New("precis: contextual rule violated")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// Programmatically set these required bits as, manually setting them seems
0000000000000000000000000000000000000000;;		// too error prone.
0000000000000000000000000000000000000000;;		for i, ct := range categoryTransitions {
0000000000000000000000000000000000000000;;			categoryTransitions[i].keep |= permanent
0000000000000000000000000000000000000000;;			categoryTransitions[i].accept |= ct.term
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var categoryTransitions = []struct {
0000000000000000000000000000000000000000;;		keep catBitmap // mask selecting which bits to keep from the previous state
0000000000000000000000000000000000000000;;		set  catBitmap // mask for which bits to set for this transition
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These bitmaps are used for rules that require lookahead.
0000000000000000000000000000000000000000;;		// term&accept == term must be true, which is enforced programmatically.
0000000000000000000000000000000000000000;;		term   catBitmap // bits accepted as termination condition
0000000000000000000000000000000000000000;;		accept catBitmap // bits that pass, but not sufficient as termination
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The rule function cannot take a *context as an argument, as it would
0000000000000000000000000000000000000000;;		// cause the context to escape, adding significant overhead.
0000000000000000000000000000000000000000;;		rule func(beforeBits catBitmap) (doLookahead bool, err error)
0000000000000000000000000000000000000000;;	}{
0000000000000000000000000000000000000000;;		joiningL:          {set: bJoinStart},
0000000000000000000000000000000000000000;;		joiningD:          {set: bJoinStart | bJoinEnd},
0000000000000000000000000000000000000000;;		joiningT:          {keep: bJoinStart, set: bJoinMid},
0000000000000000000000000000000000000000;;		joiningR:          {set: bJoinEnd},
0000000000000000000000000000000000000000;;		viramaModifier:    {set: bVirama},
0000000000000000000000000000000000000000;;		viramaJoinT:       {set: bVirama | bJoinMid},
0000000000000000000000000000000000000000;;		latinSmallL:       {set: bLatinSmallL},
0000000000000000000000000000000000000000;;		greek:             {set: bGreek},
0000000000000000000000000000000000000000;;		greekJoinT:        {set: bGreek | bJoinMid},
0000000000000000000000000000000000000000;;		hebrew:            {set: bHebrew},
0000000000000000000000000000000000000000;;		hebrewJoinT:       {set: bHebrew | bJoinMid},
0000000000000000000000000000000000000000;;		japanese:          {set: bJapanese},
0000000000000000000000000000000000000000;;		katakanaMiddleDot: {set: bMustHaveJapn},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zeroWidthNonJoiner: {
0000000000000000000000000000000000000000;;			term:   bJoinEnd,
0000000000000000000000000000000000000000;;			accept: bJoinMid,
0000000000000000000000000000000000000000;;			rule: func(before catBitmap) (doLookAhead bool, err error) {
0000000000000000000000000000000000000000;;				if before&bVirama != 0 {
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if before&bJoinStart == 0 {
0000000000000000000000000000000000000000;;					return false, errContext
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		zeroWidthJoiner: {
0000000000000000000000000000000000000000;;			rule: func(before catBitmap) (doLookAhead bool, err error) {
0000000000000000000000000000000000000000;;				if before&bVirama == 0 {
0000000000000000000000000000000000000000;;					err = errContext
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		middleDot: {
0000000000000000000000000000000000000000;;			term: bLatinSmallL,
0000000000000000000000000000000000000000;;			rule: func(before catBitmap) (doLookAhead bool, err error) {
0000000000000000000000000000000000000000;;				if before&bLatinSmallL == 0 {
0000000000000000000000000000000000000000;;					return false, errContext
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		greekLowerNumeralSign: {
0000000000000000000000000000000000000000;;			set:  bGreek,
0000000000000000000000000000000000000000;;			term: bGreek,
0000000000000000000000000000000000000000;;			rule: func(before catBitmap) (doLookAhead bool, err error) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		hebrewPreceding: {
0000000000000000000000000000000000000000;;			set: bHebrew,
0000000000000000000000000000000000000000;;			rule: func(before catBitmap) (doLookAhead bool, err error) {
0000000000000000000000000000000000000000;;				if before&bHebrew == 0 {
0000000000000000000000000000000000000000;;					err = errContext
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		arabicIndicDigit: {
0000000000000000000000000000000000000000;;			set: bArabicIndicDigit,
0000000000000000000000000000000000000000;;			rule: func(before catBitmap) (doLookAhead bool, err error) {
0000000000000000000000000000000000000000;;				if before&bExtendedArabicIndicDigit != 0 {
0000000000000000000000000000000000000000;;					err = errContext
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		extendedArabicIndicDigit: {
0000000000000000000000000000000000000000;;			set: bExtendedArabicIndicDigit,
0000000000000000000000000000000000000000;;			rule: func(before catBitmap) (doLookAhead bool, err error) {
0000000000000000000000000000000000000000;;				if before&bArabicIndicDigit != 0 {
0000000000000000000000000000000000000000;;					err = errContext
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
