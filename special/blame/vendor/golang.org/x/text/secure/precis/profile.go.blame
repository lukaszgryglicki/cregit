0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package precis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/runes"
0000000000000000000000000000000000000000;;		"golang.org/x/text/secure/bidirule"
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;		"golang.org/x/text/width"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errDisallowedRune = errors.New("precis: disallowed rune encountered")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var dpTrie = newDerivedPropertiesTrie(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Profile represents a set of rules for normalizing and validating strings in
0000000000000000000000000000000000000000;;	// the PRECIS framework.
0000000000000000000000000000000000000000;;	type Profile struct {
0000000000000000000000000000000000000000;;		options
0000000000000000000000000000000000000000;;		class *class
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewIdentifier creates a new PRECIS profile based on the Identifier string
0000000000000000000000000000000000000000;;	// class. Profiles created from this class are suitable for use where safety is
0000000000000000000000000000000000000000;;	// prioritized over expressiveness like network identifiers, user accounts, chat
0000000000000000000000000000000000000000;;	// rooms, and file names.
0000000000000000000000000000000000000000;;	func NewIdentifier(opts ...Option) *Profile {
0000000000000000000000000000000000000000;;		return &Profile{
0000000000000000000000000000000000000000;;			options: getOpts(opts...),
0000000000000000000000000000000000000000;;			class:   identifier,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFreeform creates a new PRECIS profile based on the Freeform string class.
0000000000000000000000000000000000000000;;	// Profiles created from this class are suitable for use where expressiveness is
0000000000000000000000000000000000000000;;	// prioritized over safety like passwords, and display-elements such as
0000000000000000000000000000000000000000;;	// nicknames in a chat room.
0000000000000000000000000000000000000000;;	func NewFreeform(opts ...Option) *Profile {
0000000000000000000000000000000000000000;;		return &Profile{
0000000000000000000000000000000000000000;;			options: getOpts(opts...),
0000000000000000000000000000000000000000;;			class:   freeform,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTransformer creates a new transform.Transformer that performs the PRECIS
0000000000000000000000000000000000000000;;	// preparation and enforcement steps on the given UTF-8 encoded bytes.
0000000000000000000000000000000000000000;;	func (p *Profile) NewTransformer() *Transformer {
0000000000000000000000000000000000000000;;		var ts []transform.Transformer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These transforms are applied in the order defined in
0000000000000000000000000000000000000000;;		// https://tools.ietf.org/html/rfc7564#section-7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.options.foldWidth {
0000000000000000000000000000000000000000;;			ts = append(ts, width.Fold)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range p.options.additional {
0000000000000000000000000000000000000000;;			ts = append(ts, f())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.options.cases != nil {
0000000000000000000000000000000000000000;;			ts = append(ts, p.options.cases)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ts = append(ts, p.options.norm)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.options.bidiRule {
0000000000000000000000000000000000000000;;			ts = append(ts, bidirule.New())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ts = append(ts, &checker{p: p, allowed: p.Allowed()})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Add the disallow empty rule with a dummy transformer?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Transformer{transform.Chain(ts...)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errEmptyString = errors.New("precis: transformation resulted in empty string")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type buffers struct {
0000000000000000000000000000000000000000;;		src  []byte
0000000000000000000000000000000000000000;;		buf  [2][]byte
0000000000000000000000000000000000000000;;		next int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *buffers) init(n int) {
0000000000000000000000000000000000000000;;		b.buf[0] = make([]byte, 0, n)
0000000000000000000000000000000000000000;;		b.buf[1] = make([]byte, 0, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *buffers) apply(t transform.Transformer) (err error) {
0000000000000000000000000000000000000000;;		// TODO: use Span, once available.
0000000000000000000000000000000000000000;;		x := b.next & 1
0000000000000000000000000000000000000000;;		b.src, _, err = transform.Append(t, b.buf[x][:0], b.src)
0000000000000000000000000000000000000000;;		b.buf[x] = b.src
0000000000000000000000000000000000000000;;		b.next++
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *buffers) enforce(p *Profile, src []byte) (str []byte, err error) {
0000000000000000000000000000000000000000;;		b.src = src
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These transforms are applied in the order defined in
0000000000000000000000000000000000000000;;		// https://tools.ietf.org/html/rfc7564#section-7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: allow different width transforms options.
0000000000000000000000000000000000000000;;		if p.options.foldWidth {
0000000000000000000000000000000000000000;;			// TODO: use Span, once available.
0000000000000000000000000000000000000000;;			if err = b.apply(width.Fold); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, f := range p.options.additional {
0000000000000000000000000000000000000000;;			if err = b.apply(f()); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.options.cases != nil {
0000000000000000000000000000000000000000;;			if err = b.apply(p.options.cases); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n := p.norm.QuickSpan(b.src); n < len(b.src) {
0000000000000000000000000000000000000000;;			x := b.next & 1
0000000000000000000000000000000000000000;;			n = copy(b.buf[x], b.src[:n])
0000000000000000000000000000000000000000;;			b.src, _, err = transform.Append(p.norm, b.buf[x][:n], b.src[n:])
0000000000000000000000000000000000000000;;			b.buf[x] = b.src
0000000000000000000000000000000000000000;;			b.next++
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.options.bidiRule {
0000000000000000000000000000000000000000;;			if err := b.apply(bidirule.New()); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := checker{p: p}
0000000000000000000000000000000000000000;;		if _, err := c.span(b.src, true); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.disallow != nil {
0000000000000000000000000000000000000000;;			for i := 0; i < len(b.src); {
0000000000000000000000000000000000000000;;				r, size := utf8.DecodeRune(b.src[i:])
0000000000000000000000000000000000000000;;				if p.disallow.Contains(r) {
0000000000000000000000000000000000000000;;					return nil, errDisallowedRune
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i += size
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Add the disallow empty rule with a dummy transformer?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.options.disallowEmpty && len(b.src) == 0 {
0000000000000000000000000000000000000000;;			return nil, errEmptyString
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.src, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Append appends the result of applying p to src writing the result to dst.
0000000000000000000000000000000000000000;;	// It returns an error if the input string is invalid.
0000000000000000000000000000000000000000;;	func (p *Profile) Append(dst, src []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		var buf buffers
0000000000000000000000000000000000000000;;		buf.init(8 + len(src) + len(src)>>2)
0000000000000000000000000000000000000000;;		b, err := buf.enforce(p, src)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(dst, b...), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns a new byte slice with the result of applying the profile to b.
0000000000000000000000000000000000000000;;	func (p *Profile) Bytes(b []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		var buf buffers
0000000000000000000000000000000000000000;;		buf.init(8 + len(b) + len(b)>>2)
0000000000000000000000000000000000000000;;		b, err := buf.enforce(p, b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if buf.next == 0 {
0000000000000000000000000000000000000000;;			c := make([]byte, len(b))
0000000000000000000000000000000000000000;;			copy(c, b)
0000000000000000000000000000000000000000;;			return c, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string with the result of applying the profile to s.
0000000000000000000000000000000000000000;;	func (p *Profile) String(s string) (string, error) {
0000000000000000000000000000000000000000;;		var buf buffers
0000000000000000000000000000000000000000;;		buf.init(8 + len(s) + len(s)>>2)
0000000000000000000000000000000000000000;;		b, err := buf.enforce(p, []byte(s))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compare enforces both strings, and then compares them for bit-string identity
0000000000000000000000000000000000000000;;	// (byte-for-byte equality). If either string cannot be enforced, the comparison
0000000000000000000000000000000000000000;;	// is false.
0000000000000000000000000000000000000000;;	func (p *Profile) Compare(a, b string) bool {
0000000000000000000000000000000000000000;;		a, err := p.String(a)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err = p.String(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: This is out of order. Need to extract the transformation logic and
0000000000000000000000000000000000000000;;		// put this in where the normal case folding would go (but only for
0000000000000000000000000000000000000000;;		// comparison).
0000000000000000000000000000000000000000;;		if p.options.ignorecase {
0000000000000000000000000000000000000000;;			a = width.Fold.String(a)
0000000000000000000000000000000000000000;;			b = width.Fold.String(a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return a == b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Allowed returns a runes.Set containing every rune that is a member of the
0000000000000000000000000000000000000000;;	// underlying profile's string class and not disallowed by any profile specific
0000000000000000000000000000000000000000;;	// rules.
0000000000000000000000000000000000000000;;	func (p *Profile) Allowed() runes.Set {
0000000000000000000000000000000000000000;;		if p.options.disallow != nil {
0000000000000000000000000000000000000000;;			return runes.Predicate(func(r rune) bool {
0000000000000000000000000000000000000000;;				return p.class.Contains(r) && !p.options.disallow.Contains(r)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.class
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type checker struct {
0000000000000000000000000000000000000000;;		p       *Profile
0000000000000000000000000000000000000000;;		allowed runes.Set
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		beforeBits catBitmap
0000000000000000000000000000000000000000;;		termBits   catBitmap
0000000000000000000000000000000000000000;;		acceptBits catBitmap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *checker) Reset() {
0000000000000000000000000000000000000000;;		c.beforeBits = 0
0000000000000000000000000000000000000000;;		c.termBits = 0
0000000000000000000000000000000000000000;;		c.acceptBits = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *checker) span(src []byte, atEOF bool) (n int, err error) {
0000000000000000000000000000000000000000;;		for n < len(src) {
0000000000000000000000000000000000000000;;			e, sz := dpTrie.lookup(src[n:])
0000000000000000000000000000000000000000;;			d := categoryTransitions[category(e&catMask)]
0000000000000000000000000000000000000000;;			if sz == 0 {
0000000000000000000000000000000000000000;;				if !atEOF {
0000000000000000000000000000000000000000;;					return n, transform.ErrShortSrc
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return n, errDisallowedRune
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if property(e) < c.p.class.validFrom {
0000000000000000000000000000000000000000;;				if d.rule == nil {
0000000000000000000000000000000000000000;;					return n, errDisallowedRune
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				doLookAhead, err := d.rule(c.beforeBits)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return n, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if doLookAhead {
0000000000000000000000000000000000000000;;					c.beforeBits &= d.keep
0000000000000000000000000000000000000000;;					c.beforeBits |= d.set
0000000000000000000000000000000000000000;;					// We may still have a lookahead rule which we will require to
0000000000000000000000000000000000000000;;					// complete (by checking termBits == 0) before setting the new
0000000000000000000000000000000000000000;;					// bits.
0000000000000000000000000000000000000000;;					if c.termBits != 0 && (!c.checkLookahead() || c.termBits == 0) {
0000000000000000000000000000000000000000;;						return n, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					c.termBits = d.term
0000000000000000000000000000000000000000;;					c.acceptBits = d.accept
0000000000000000000000000000000000000000;;					n += sz
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.beforeBits &= d.keep
0000000000000000000000000000000000000000;;			c.beforeBits |= d.set
0000000000000000000000000000000000000000;;			if c.termBits != 0 && !c.checkLookahead() {
0000000000000000000000000000000000000000;;				return n, errContext
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += sz
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m := c.beforeBits >> finalShift; c.beforeBits&m != m || c.termBits != 0 {
0000000000000000000000000000000000000000;;			err = errContext
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *checker) checkLookahead() bool {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case c.beforeBits&c.termBits != 0:
0000000000000000000000000000000000000000;;			c.termBits = 0
0000000000000000000000000000000000000000;;			c.acceptBits = 0
0000000000000000000000000000000000000000;;		case c.beforeBits&c.acceptBits != 0:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: we may get rid of this transform if transform.Chain understands
0000000000000000000000000000000000000000;;	// something like a Spanner interface.
0000000000000000000000000000000000000000;;	func (c checker) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		short := false
0000000000000000000000000000000000000000;;		if len(dst) < len(src) {
0000000000000000000000000000000000000000;;			src = src[:len(dst)]
0000000000000000000000000000000000000000;;			atEOF = false
0000000000000000000000000000000000000000;;			short = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nSrc, err = c.span(src, atEOF)
0000000000000000000000000000000000000000;;		nDst = copy(dst, src[:nSrc])
0000000000000000000000000000000000000000;;		if short && (err == transform.ErrShortSrc || err == nil) {
0000000000000000000000000000000000000000;;			err = transform.ErrShortDst
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, err
0000000000000000000000000000000000000000;;	}
