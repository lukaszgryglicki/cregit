0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package precis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/runes"
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;		"golang.org/x/text/unicode/norm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		Nickname              *Profile = nickname          // Implements the Nickname profile specified in RFC 7700.
0000000000000000000000000000000000000000;;		UsernameCaseMapped    *Profile = usernameCaseMap   // Implements the UsernameCaseMapped profile specified in RFC 7613.
0000000000000000000000000000000000000000;;		UsernameCasePreserved *Profile = usernameNoCaseMap // Implements the UsernameCasePreserved profile specified in RFC 7613.
0000000000000000000000000000000000000000;;		OpaqueString          *Profile = opaquestring      // Implements the OpaqueString profile defined in RFC 7613 for passwords and other secure labels.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: mvl: "Ultimately, I would manually define the structs for the internal
0000000000000000000000000000000000000000;;	// profiles. This avoid pulling in unneeded tables when they are not used."
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		nickname = NewFreeform(
0000000000000000000000000000000000000000;;			AdditionalMapping(func() transform.Transformer {
0000000000000000000000000000000000000000;;				return &nickAdditionalMapping{}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			IgnoreCase,
0000000000000000000000000000000000000000;;			Norm(norm.NFKC),
0000000000000000000000000000000000000000;;			DisallowEmpty,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		usernameCaseMap = NewIdentifier(
0000000000000000000000000000000000000000;;			FoldWidth,
0000000000000000000000000000000000000000;;			FoldCase(),
0000000000000000000000000000000000000000;;			Norm(norm.NFC),
0000000000000000000000000000000000000000;;			BidiRule,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		usernameNoCaseMap = NewIdentifier(
0000000000000000000000000000000000000000;;			FoldWidth,
0000000000000000000000000000000000000000;;			Norm(norm.NFC),
0000000000000000000000000000000000000000;;			BidiRule,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		opaquestring = NewFreeform(
0000000000000000000000000000000000000000;;			AdditionalMapping(func() transform.Transformer {
0000000000000000000000000000000000000000;;				return runes.Map(func(r rune) rune {
0000000000000000000000000000000000000000;;					if unicode.Is(unicode.Zs, r) {
0000000000000000000000000000000000000000;;						return ' '
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return r
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			Norm(norm.NFC),
0000000000000000000000000000000000000000;;			DisallowEmpty,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	)
