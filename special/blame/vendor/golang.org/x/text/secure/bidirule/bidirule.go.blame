0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// Package bidirule implements the Bidi Rule defined by RFC 5893.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This package is under development. The API may change without notice and
0000000000000000000000000000000000000000;;	// without preserving backward compatibility.
0000000000000000000000000000000000000000;;	package bidirule
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;		"golang.org/x/text/unicode/bidi"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains an implementation of RFC 5893: Right-to-Left Scripts for
0000000000000000000000000000000000000000;;	// Internationalized Domain Names for Applications (IDNA)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A label is an individual component of a domain name.  Labels are usually
0000000000000000000000000000000000000000;;	// shown separated by dots; for example, the domain name "www.example.com" is
0000000000000000000000000000000000000000;;	// composed of three labels: "www", "example", and "com".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An RTL label is a label that contains at least one character of class R, AL,
0000000000000000000000000000000000000000;;	// or AN. An LTR label is any label that is not an RTL label.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A "Bidi domain name" is a domain name that contains at least one RTL label.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  The following guarantees can be made based on the above:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  o  In a domain name consisting of only labels that satisfy the rule,
0000000000000000000000000000000000000000;;	//     the requirements of Section 3 are satisfied.  Note that even LTR
0000000000000000000000000000000000000000;;	//     labels and pure ASCII labels have to be tested.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  o  In a domain name consisting of only LDH labels (as defined in the
0000000000000000000000000000000000000000;;	//     Definitions document [RFC5890]) and labels that satisfy the rule,
0000000000000000000000000000000000000000;;	//     the requirements of Section 3 are satisfied as long as a label
0000000000000000000000000000000000000000;;	//     that starts with an ASCII digit does not come after a
0000000000000000000000000000000000000000;;	//     right-to-left label.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  No guarantee is given for other combinations.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrInvalid indicates a label is invalid according to the Bidi Rule.
0000000000000000000000000000000000000000;;	var ErrInvalid = errors.New("bidirule: failed Bidi Rule")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ruleState uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ruleInitial ruleState = iota
0000000000000000000000000000000000000000;;		ruleLTR
0000000000000000000000000000000000000000;;		ruleLTRFinal
0000000000000000000000000000000000000000;;		ruleRTL
0000000000000000000000000000000000000000;;		ruleRTLFinal
0000000000000000000000000000000000000000;;		ruleInvalid
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ruleTransition struct {
0000000000000000000000000000000000000000;;		next ruleState
0000000000000000000000000000000000000000;;		mask uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var transitions = [...][2]ruleTransition{
0000000000000000000000000000000000000000;;		// [2.1] The first character must be a character with Bidi property L, R, or
0000000000000000000000000000000000000000;;		// AL. If it has the R or AL property, it is an RTL label; if it has the L
0000000000000000000000000000000000000000;;		// property, it is an LTR label.
0000000000000000000000000000000000000000;;		ruleInitial: {
0000000000000000000000000000000000000000;;			{ruleLTRFinal, 1 << bidi.L},
0000000000000000000000000000000000000000;;			{ruleRTLFinal, 1<<bidi.R | 1<<bidi.AL},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		ruleRTL: {
0000000000000000000000000000000000000000;;			// [2.3] In an RTL label, the end of the label must be a character with
0000000000000000000000000000000000000000;;			// Bidi property R, AL, EN, or AN, followed by zero or more characters
0000000000000000000000000000000000000000;;			// with Bidi property NSM.
0000000000000000000000000000000000000000;;			{ruleRTLFinal, 1<<bidi.R | 1<<bidi.AL | 1<<bidi.EN | 1<<bidi.AN},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// [2.2] In an RTL label, only characters with the Bidi properties R,
0000000000000000000000000000000000000000;;			// AL, AN, EN, ES, CS, ET, ON, BN, or NSM are allowed.
0000000000000000000000000000000000000000;;			// We exclude the entries from [2.3]
0000000000000000000000000000000000000000;;			{ruleRTL, 1<<bidi.ES | 1<<bidi.CS | 1<<bidi.ET | 1<<bidi.ON | 1<<bidi.BN | 1<<bidi.NSM},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		ruleRTLFinal: {
0000000000000000000000000000000000000000;;			// [2.3] In an RTL label, the end of the label must be a character with
0000000000000000000000000000000000000000;;			// Bidi property R, AL, EN, or AN, followed by zero or more characters
0000000000000000000000000000000000000000;;			// with Bidi property NSM.
0000000000000000000000000000000000000000;;			{ruleRTLFinal, 1<<bidi.R | 1<<bidi.AL | 1<<bidi.EN | 1<<bidi.AN | 1<<bidi.NSM},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// [2.2] In an RTL label, only characters with the Bidi properties R,
0000000000000000000000000000000000000000;;			// AL, AN, EN, ES, CS, ET, ON, BN, or NSM are allowed.
0000000000000000000000000000000000000000;;			// We exclude the entries from [2.3] and NSM.
0000000000000000000000000000000000000000;;			{ruleRTL, 1<<bidi.ES | 1<<bidi.CS | 1<<bidi.ET | 1<<bidi.ON | 1<<bidi.BN},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		ruleLTR: {
0000000000000000000000000000000000000000;;			// [2.6] In an LTR label, the end of the label must be a character with
0000000000000000000000000000000000000000;;			// Bidi property L or EN, followed by zero or more characters with Bidi
0000000000000000000000000000000000000000;;			// property NSM.
0000000000000000000000000000000000000000;;			{ruleLTRFinal, 1<<bidi.L | 1<<bidi.EN},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// [2.5] In an LTR label, only characters with the Bidi properties L,
0000000000000000000000000000000000000000;;			// EN, ES, CS, ET, ON, BN, or NSM are allowed.
0000000000000000000000000000000000000000;;			// We exclude the entries from [2.6].
0000000000000000000000000000000000000000;;			{ruleLTR, 1<<bidi.ES | 1<<bidi.CS | 1<<bidi.ET | 1<<bidi.ON | 1<<bidi.BN | 1<<bidi.NSM},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		ruleLTRFinal: {
0000000000000000000000000000000000000000;;			// [2.6] In an LTR label, the end of the label must be a character with
0000000000000000000000000000000000000000;;			// Bidi property L or EN, followed by zero or more characters with Bidi
0000000000000000000000000000000000000000;;			// property NSM.
0000000000000000000000000000000000000000;;			{ruleLTRFinal, 1<<bidi.L | 1<<bidi.EN | 1<<bidi.NSM},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// [2.5] In an LTR label, only characters with the Bidi properties L,
0000000000000000000000000000000000000000;;			// EN, ES, CS, ET, ON, BN, or NSM are allowed.
0000000000000000000000000000000000000000;;			// We exclude the entries from [2.6].
0000000000000000000000000000000000000000;;			{ruleLTR, 1<<bidi.ES | 1<<bidi.CS | 1<<bidi.ET | 1<<bidi.ON | 1<<bidi.BN},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		ruleInvalid: {
0000000000000000000000000000000000000000;;			{ruleInvalid, 0},
0000000000000000000000000000000000000000;;			{ruleInvalid, 0},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// [2.4] In an RTL label, if an EN is present, no AN may be present, and
0000000000000000000000000000000000000000;;	// vice versa.
0000000000000000000000000000000000000000;;	const exclusiveRTL = uint16(1<<bidi.EN | 1<<bidi.AN)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Direction reports the direction of the given label as defined by RFC 5893 or
0000000000000000000000000000000000000000;;	// an error if b is not a valid label according to the Bidi Rule.
0000000000000000000000000000000000000000;;	func Direction(b []byte) (bidi.Direction, error) {
0000000000000000000000000000000000000000;;		t := Transformer{}
0000000000000000000000000000000000000000;;		if n, ok := t.advance(b); ok && n == len(b) {
0000000000000000000000000000000000000000;;			switch t.state {
0000000000000000000000000000000000000000;;			case ruleLTRFinal, ruleInitial:
0000000000000000000000000000000000000000;;				return bidi.LeftToRight, nil
0000000000000000000000000000000000000000;;			case ruleRTLFinal:
0000000000000000000000000000000000000000;;				return bidi.RightToLeft, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bidi.Neutral, ErrInvalid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirectionString reports the direction of the given label as defined by RFC
0000000000000000000000000000000000000000;;	// 5893 or an error if s is not a valid label according to the Bidi Rule.
0000000000000000000000000000000000000000;;	func DirectionString(s string) (bidi.Direction, error) {
0000000000000000000000000000000000000000;;		t := Transformer{}
0000000000000000000000000000000000000000;;		if n, ok := t.advanceString(s); ok && n == len(s) {
0000000000000000000000000000000000000000;;			switch t.state {
0000000000000000000000000000000000000000;;			case ruleLTRFinal, ruleInitial:
0000000000000000000000000000000000000000;;				return bidi.LeftToRight, nil
0000000000000000000000000000000000000000;;			case ruleRTLFinal:
0000000000000000000000000000000000000000;;				return bidi.RightToLeft, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bidi.Neutral, ErrInvalid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a Transformer that verifies that input adheres to the Bidi Rule.
0000000000000000000000000000000000000000;;	func New() *Transformer {
0000000000000000000000000000000000000000;;		return &Transformer{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transformer implements transform.Transform.
0000000000000000000000000000000000000000;;	type Transformer struct {
0000000000000000000000000000000000000000;;		state ruleState
0000000000000000000000000000000000000000;;		seen  uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset implements transform.Transformer.
0000000000000000000000000000000000000000;;	func (t *Transformer) Reset() { *t = Transformer{} }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform implements transform.Transformer. This Transformer has state and
0000000000000000000000000000000000000000;;	// needs to be reset between uses.
0000000000000000000000000000000000000000;;	func (t *Transformer) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		if len(dst) < len(src) {
0000000000000000000000000000000000000000;;			src = src[:len(dst)]
0000000000000000000000000000000000000000;;			atEOF = false
0000000000000000000000000000000000000000;;			err = transform.ErrShortDst
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err1 := t.Span(src, atEOF)
0000000000000000000000000000000000000000;;		copy(dst, src[:n])
0000000000000000000000000000000000000000;;		if err == nil || err1 != nil && err1 != transform.ErrShortSrc {
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Span returns the first n bytes of src that conform to the Bidi rule.
0000000000000000000000000000000000000000;;	func (t *Transformer) Span(src []byte, atEOF bool) (n int, err error) {
0000000000000000000000000000000000000000;;		if t.state == ruleInvalid {
0000000000000000000000000000000000000000;;			return 0, ErrInvalid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, ok := t.advance(src)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case !ok:
0000000000000000000000000000000000000000;;			err = ErrInvalid
0000000000000000000000000000000000000000;;		case n < len(src):
0000000000000000000000000000000000000000;;			if !atEOF {
0000000000000000000000000000000000000000;;				err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = ErrInvalid
0000000000000000000000000000000000000000;;		case t.state != ruleLTRFinal && t.state != ruleRTLFinal && t.state != ruleInitial:
0000000000000000000000000000000000000000;;			err = ErrInvalid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Precomputing the ASCII values decreases running time for the ASCII fast path
0000000000000000000000000000000000000000;;	// by about 30%.
0000000000000000000000000000000000000000;;	var asciiTable [128]bidi.Properties
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		for i := range asciiTable {
0000000000000000000000000000000000000000;;			p, _ := bidi.LookupRune(rune(i))
0000000000000000000000000000000000000000;;			asciiTable[i] = p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transformer) advance(s []byte) (n int, ok bool) {
0000000000000000000000000000000000000000;;		var e bidi.Properties
0000000000000000000000000000000000000000;;		var sz int
0000000000000000000000000000000000000000;;		for n < len(s) {
0000000000000000000000000000000000000000;;			if s[n] < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				e, sz = asciiTable[s[n]], 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e, sz = bidi.Lookup(s[n:])
0000000000000000000000000000000000000000;;				if sz <= 1 {
0000000000000000000000000000000000000000;;					if sz == 1 {
0000000000000000000000000000000000000000;;						return n, false // invalid UTF-8
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return n, true // incomplete UTF-8 encoding
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: using CompactClass results in noticeable speedup.
0000000000000000000000000000000000000000;;			// See unicode/bidi/prop.go:Properties.CompactClass.
0000000000000000000000000000000000000000;;			c := uint16(1 << e.Class())
0000000000000000000000000000000000000000;;			t.seen |= c
0000000000000000000000000000000000000000;;			if t.seen&exclusiveRTL == exclusiveRTL {
0000000000000000000000000000000000000000;;				t.state = ruleInvalid
0000000000000000000000000000000000000000;;				return n, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch tr := transitions[t.state]; {
0000000000000000000000000000000000000000;;			case tr[0].mask&c != 0:
0000000000000000000000000000000000000000;;				t.state = tr[0].next
0000000000000000000000000000000000000000;;			case tr[1].mask&c != 0:
0000000000000000000000000000000000000000;;				t.state = tr[1].next
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				t.state = ruleInvalid
0000000000000000000000000000000000000000;;				return n, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += sz
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transformer) advanceString(s string) (n int, ok bool) {
0000000000000000000000000000000000000000;;		var e bidi.Properties
0000000000000000000000000000000000000000;;		var sz int
0000000000000000000000000000000000000000;;		for n < len(s) {
0000000000000000000000000000000000000000;;			if s[n] < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				e, sz = asciiTable[s[n]], 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e, sz = bidi.LookupString(s[n:])
0000000000000000000000000000000000000000;;				if sz <= 1 {
0000000000000000000000000000000000000000;;					if sz == 1 {
0000000000000000000000000000000000000000;;						return n, false // invalid UTF-8
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return n, true // incomplete UTF-8 encoding
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: using CompactClass results in noticeable speedup.
0000000000000000000000000000000000000000;;			// See unicode/bidi/prop.go:Properties.CompactClass.
0000000000000000000000000000000000000000;;			c := uint16(1 << e.Class())
0000000000000000000000000000000000000000;;			t.seen |= c
0000000000000000000000000000000000000000;;			if t.seen&exclusiveRTL == exclusiveRTL {
0000000000000000000000000000000000000000;;				t.state = ruleInvalid
0000000000000000000000000000000000000000;;				return n, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch tr := transitions[t.state]; {
0000000000000000000000000000000000000000;;			case tr[0].mask&c != 0:
0000000000000000000000000000000000000000;;				t.state = tr[0].next
0000000000000000000000000000000000000000;;			case tr[1].mask&c != 0:
0000000000000000000000000000000000000000;;				t.state = tr[1].next
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				t.state = ruleInvalid
0000000000000000000000000000000000000000;;				return n, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += sz
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, true
0000000000000000000000000000000000000000;;	}
