0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// Package runes provide transforms for UTF-8 encoded text.
0000000000000000000000000000000000000000;;	package runes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Set is a collection of runes.
0000000000000000000000000000000000000000;;	type Set interface {
0000000000000000000000000000000000000000;;		// Contains returns true if r is contained in the set.
0000000000000000000000000000000000000000;;		Contains(r rune) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type setFunc func(rune) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s setFunc) Contains(r rune) bool {
0000000000000000000000000000000000000000;;		return s(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note: using funcs here instead of wrapping types result in cleaner
0000000000000000000000000000000000000000;;	// documentation and a smaller API.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// In creates a Set with a Contains method that returns true for all runes in
0000000000000000000000000000000000000000;;	// the given RangeTable.
0000000000000000000000000000000000000000;;	func In(rt *unicode.RangeTable) Set {
0000000000000000000000000000000000000000;;		return setFunc(func(r rune) bool { return unicode.Is(rt, r) })
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// In creates a Set with a Contains method that returns true for all runes not
0000000000000000000000000000000000000000;;	// in the given RangeTable.
0000000000000000000000000000000000000000;;	func NotIn(rt *unicode.RangeTable) Set {
0000000000000000000000000000000000000000;;		return setFunc(func(r rune) bool { return !unicode.Is(rt, r) })
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Predicate creates a Set with a Contains method that returns f(r).
0000000000000000000000000000000000000000;;	func Predicate(f func(rune) bool) Set {
0000000000000000000000000000000000000000;;		return setFunc(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transformer implements the transform.Transformer interface.
0000000000000000000000000000000000000000;;	type Transformer struct {
0000000000000000000000000000000000000000;;		transform.Transformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns a new byte slice with the result of converting b using t.  It
0000000000000000000000000000000000000000;;	// calls Reset on t. It returns nil if any error was found. This can only happen
0000000000000000000000000000000000000000;;	// if an error-producing Transformer is passed to If.
0000000000000000000000000000000000000000;;	func (t Transformer) Bytes(b []byte) []byte {
0000000000000000000000000000000000000000;;		b, _, err := transform.Bytes(t, b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string with the result of converting s using t. It calls
0000000000000000000000000000000000000000;;	// Reset on t. It returns the empty string if any error was found. This can only
0000000000000000000000000000000000000000;;	// happen if an error-producing Transformer is passed to If.
0000000000000000000000000000000000000000;;	func (t Transformer) String(s string) string {
0000000000000000000000000000000000000000;;		s, _, err := transform.String(t, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO:
0000000000000000000000000000000000000000;;	// - Copy: copying strings and bytes in whole-rune units.
0000000000000000000000000000000000000000;;	// - Validation (maybe)
0000000000000000000000000000000000000000;;	// - Well-formed-ness (maybe)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const runeErrorString = string(utf8.RuneError)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove returns a Transformer that removes runes r for which s.Contains(r).
0000000000000000000000000000000000000000;;	// Illegal input bytes are replaced by RuneError before being passed to f.
0000000000000000000000000000000000000000;;	func Remove(s Set) Transformer {
0000000000000000000000000000000000000000;;		if f, ok := s.(setFunc); ok {
0000000000000000000000000000000000000000;;			// This little trick cuts the running time of BenchmarkRemove for sets
0000000000000000000000000000000000000000;;			// created by Predicate roughly in half.
0000000000000000000000000000000000000000;;			// TODO: special-case RangeTables as well.
0000000000000000000000000000000000000000;;			return Transformer{remove(f)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Transformer{remove(s.Contains)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove transform.RemoveFunc.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type remove func(r rune) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (remove) Reset() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform implements transform.Transformer.
0000000000000000000000000000000000000000;;	func (t remove) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		for r, size := rune(0), 0; nSrc < len(src); {
0000000000000000000000000000000000000000;;			if r = rune(src[nSrc]); r < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				size = 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r, size = utf8.DecodeRune(src[nSrc:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if size == 1 {
0000000000000000000000000000000000000000;;					// Invalid rune.
0000000000000000000000000000000000000000;;					if !atEOF && !utf8.FullRune(src[nSrc:]) {
0000000000000000000000000000000000000000;;						err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// We replace illegal bytes with RuneError. Not doing so might
0000000000000000000000000000000000000000;;					// otherwise turn a sequence of invalid UTF-8 into valid UTF-8.
0000000000000000000000000000000000000000;;					// The resulting byte sequence may subsequently contain runes
0000000000000000000000000000000000000000;;					// for which t(r) is true that were passed unnoticed.
0000000000000000000000000000000000000000;;					if !t(utf8.RuneError) {
0000000000000000000000000000000000000000;;						if nDst+3 > len(dst) {
0000000000000000000000000000000000000000;;							err = transform.ErrShortDst
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						dst[nDst+0] = runeErrorString[0]
0000000000000000000000000000000000000000;;						dst[nDst+1] = runeErrorString[1]
0000000000000000000000000000000000000000;;						dst[nDst+2] = runeErrorString[2]
0000000000000000000000000000000000000000;;						nDst += 3
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					nSrc++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t(r) {
0000000000000000000000000000000000000000;;				nSrc += size
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if nDst+size > len(dst) {
0000000000000000000000000000000000000000;;				err = transform.ErrShortDst
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < size; i++ {
0000000000000000000000000000000000000000;;				dst[nDst] = src[nSrc]
0000000000000000000000000000000000000000;;				nDst++
0000000000000000000000000000000000000000;;				nSrc++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map returns a Transformer that maps the runes in the input using the given
0000000000000000000000000000000000000000;;	// mapping. Illegal bytes in the input are converted to utf8.RuneError before
0000000000000000000000000000000000000000;;	// being passed to the mapping func.
0000000000000000000000000000000000000000;;	func Map(mapping func(rune) rune) Transformer {
0000000000000000000000000000000000000000;;		return Transformer{mapper(mapping)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mapper func(rune) rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mapper) Reset() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform implements transform.Transformer.
0000000000000000000000000000000000000000;;	func (t mapper) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		var replacement rune
0000000000000000000000000000000000000000;;		var b [utf8.UTFMax]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for r, size := rune(0), 0; nSrc < len(src); {
0000000000000000000000000000000000000000;;			if r = rune(src[nSrc]); r < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				if replacement = t(r); replacement < utf8.RuneSelf {
0000000000000000000000000000000000000000;;					if nDst == len(dst) {
0000000000000000000000000000000000000000;;						err = transform.ErrShortDst
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dst[nDst] = byte(replacement)
0000000000000000000000000000000000000000;;					nDst++
0000000000000000000000000000000000000000;;					nSrc++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				size = 1
0000000000000000000000000000000000000000;;			} else if r, size = utf8.DecodeRune(src[nSrc:]); size == 1 {
0000000000000000000000000000000000000000;;				// Invalid rune.
0000000000000000000000000000000000000000;;				if !atEOF && !utf8.FullRune(src[nSrc:]) {
0000000000000000000000000000000000000000;;					err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if replacement = t(utf8.RuneError); replacement == utf8.RuneError {
0000000000000000000000000000000000000000;;					if nDst+3 > len(dst) {
0000000000000000000000000000000000000000;;						err = transform.ErrShortDst
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dst[nDst+0] = runeErrorString[0]
0000000000000000000000000000000000000000;;					dst[nDst+1] = runeErrorString[1]
0000000000000000000000000000000000000000;;					dst[nDst+2] = runeErrorString[2]
0000000000000000000000000000000000000000;;					nDst += 3
0000000000000000000000000000000000000000;;					nSrc++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if replacement = t(r); replacement == r {
0000000000000000000000000000000000000000;;				if nDst+size > len(dst) {
0000000000000000000000000000000000000000;;					err = transform.ErrShortDst
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i := 0; i < size; i++ {
0000000000000000000000000000000000000000;;					dst[nDst] = src[nSrc]
0000000000000000000000000000000000000000;;					nDst++
0000000000000000000000000000000000000000;;					nSrc++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n := utf8.EncodeRune(b[:], replacement)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if nDst+n > len(dst) {
0000000000000000000000000000000000000000;;				err = transform.ErrShortDst
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;				dst[nDst] = b[i]
0000000000000000000000000000000000000000;;				nDst++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nSrc += size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceIllFormed returns a transformer that replaces all input bytes that are
0000000000000000000000000000000000000000;;	// not part of a well-formed UTF-8 code sequence with utf8.RuneError.
0000000000000000000000000000000000000000;;	func ReplaceIllFormed() Transformer {
0000000000000000000000000000000000000000;;		return Transformer{&replaceIllFormed{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type replaceIllFormed struct{ transform.NopResetter }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t replaceIllFormed) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		for nSrc < len(src) {
0000000000000000000000000000000000000000;;			r, size := utf8.DecodeRune(src[nSrc:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Look for an ASCII rune.
0000000000000000000000000000000000000000;;			if r < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				if nDst == len(dst) {
0000000000000000000000000000000000000000;;					err = transform.ErrShortDst
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst[nDst] = byte(r)
0000000000000000000000000000000000000000;;				nDst++
0000000000000000000000000000000000000000;;				nSrc++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Look for a valid non-ASCII rune.
0000000000000000000000000000000000000000;;			if r != utf8.RuneError || size != 1 {
0000000000000000000000000000000000000000;;				if size != copy(dst[nDst:], src[nSrc:nSrc+size]) {
0000000000000000000000000000000000000000;;					err = transform.ErrShortDst
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nDst += size
0000000000000000000000000000000000000000;;				nSrc += size
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Look for short source data.
0000000000000000000000000000000000000000;;			if !atEOF && !utf8.FullRune(src[nSrc:]) {
0000000000000000000000000000000000000000;;				err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We have an invalid rune.
0000000000000000000000000000000000000000;;			if nDst+3 > len(dst) {
0000000000000000000000000000000000000000;;				err = transform.ErrShortDst
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst[nDst+0] = runeErrorString[0]
0000000000000000000000000000000000000000;;			dst[nDst+1] = runeErrorString[1]
0000000000000000000000000000000000000000;;			dst[nDst+2] = runeErrorString[2]
0000000000000000000000000000000000000000;;			nDst += 3
0000000000000000000000000000000000000000;;			nSrc++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, err
0000000000000000000000000000000000000000;;	}
