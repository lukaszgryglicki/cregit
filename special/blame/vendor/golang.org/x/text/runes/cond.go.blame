0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package runes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note: below we pass invalid UTF-8 to the tIn and tNotIn transformers as is.
0000000000000000000000000000000000000000;;	// This is done for various reasons:
0000000000000000000000000000000000000000;;	// - To retain the semantics of the Nop transformer: if input is passed to a Nop
0000000000000000000000000000000000000000;;	//   one would expect it to be unchanged.
0000000000000000000000000000000000000000;;	// - It would be very expensive to pass a converted RuneError to a transformer:
0000000000000000000000000000000000000000;;	//   a transformer might need more source bytes after RuneError, meaning that
0000000000000000000000000000000000000000;;	//   the only way to pass it safely is to create a new buffer and manage the
0000000000000000000000000000000000000000;;	//   intermingling of RuneErrors and normal input.
0000000000000000000000000000000000000000;;	// - Many transformers leave ill-formed UTF-8 as is, so this is not
0000000000000000000000000000000000000000;;	//   inconsistent. Generally ill-formed UTF-8 is only replaced if it is a
0000000000000000000000000000000000000000;;	//   logical consequence of the operation (as for Map) or if it otherwise would
0000000000000000000000000000000000000000;;	//   pose security concerns (as for Remove).
0000000000000000000000000000000000000000;;	// - An alternative would be to return an error on ill-formed UTF-8, but this
0000000000000000000000000000000000000000;;	//   would be inconsistent with other operations.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If returns a transformer that applies tIn to consecutive runes for which
0000000000000000000000000000000000000000;;	// s.Contains(r) and tNotIn to consecutive runes for which !s.Contains(r). Reset
0000000000000000000000000000000000000000;;	// is called on tIn and tNotIn at the start of each run. A Nop transformer will
0000000000000000000000000000000000000000;;	// substitute a nil value passed to tIn or tNotIn. Invalid UTF-8 is translated
0000000000000000000000000000000000000000;;	// to RuneError to determine which transformer to apply, but is passed as is to
0000000000000000000000000000000000000000;;	// the respective transformer.
0000000000000000000000000000000000000000;;	func If(s Set, tIn, tNotIn transform.Transformer) Transformer {
0000000000000000000000000000000000000000;;		if tIn == nil && tNotIn == nil {
0000000000000000000000000000000000000000;;			return Transformer{transform.Nop}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tIn == nil {
0000000000000000000000000000000000000000;;			tIn = transform.Nop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tNotIn == nil {
0000000000000000000000000000000000000000;;			tNotIn = transform.Nop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a := &cond{
0000000000000000000000000000000000000000;;			tIn:    tIn,
0000000000000000000000000000000000000000;;			tNotIn: tNotIn,
0000000000000000000000000000000000000000;;			f:      s.Contains,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a.Reset()
0000000000000000000000000000000000000000;;		return Transformer{a}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cond struct {
0000000000000000000000000000000000000000;;		tIn, tNotIn transform.Transformer
0000000000000000000000000000000000000000;;		f           func(rune) bool
0000000000000000000000000000000000000000;;		check       func(rune) bool       // current check to perform
0000000000000000000000000000000000000000;;		t           transform.Transformer // current transformer to use
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset implements transform.Transformer.
0000000000000000000000000000000000000000;;	func (t *cond) Reset() {
0000000000000000000000000000000000000000;;		t.check = t.is
0000000000000000000000000000000000000000;;		t.t = t.tIn
0000000000000000000000000000000000000000;;		t.t.Reset() // notIn will be reset on first usage.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *cond) is(r rune) bool {
0000000000000000000000000000000000000000;;		if t.f(r) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.check = t.isNot
0000000000000000000000000000000000000000;;		t.t = t.tNotIn
0000000000000000000000000000000000000000;;		t.tNotIn.Reset()
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *cond) isNot(r rune) bool {
0000000000000000000000000000000000000000;;		if !t.f(r) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.check = t.is
0000000000000000000000000000000000000000;;		t.t = t.tIn
0000000000000000000000000000000000000000;;		t.tIn.Reset()
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *cond) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		p := 0
0000000000000000000000000000000000000000;;		for nSrc < len(src) && err == nil {
0000000000000000000000000000000000000000;;			// Don't process too much at a time, as the work might be wasted if the
0000000000000000000000000000000000000000;;			// destination buffer isn't large enough to hold the result or a
0000000000000000000000000000000000000000;;			// transform returns an error early.
0000000000000000000000000000000000000000;;			const maxChunk = 4096
0000000000000000000000000000000000000000;;			max := len(src)
0000000000000000000000000000000000000000;;			if n := nSrc + maxChunk; n < len(src) {
0000000000000000000000000000000000000000;;				max = n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			atEnd := false
0000000000000000000000000000000000000000;;			size := 0
0000000000000000000000000000000000000000;;			current := t.t
0000000000000000000000000000000000000000;;			for ; p < max; p += size {
0000000000000000000000000000000000000000;;				var r rune
0000000000000000000000000000000000000000;;				r, size = utf8.DecodeRune(src[p:])
0000000000000000000000000000000000000000;;				if r == utf8.RuneError && size == 1 {
0000000000000000000000000000000000000000;;					if !atEOF && !utf8.FullRune(src[p:]) {
0000000000000000000000000000000000000000;;						err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !t.check(r) {
0000000000000000000000000000000000000000;;					// The next rune will be the start of a new run.
0000000000000000000000000000000000000000;;					atEnd = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nDst2, nSrc2, err2 := current.Transform(dst[nDst:], src[nSrc:p], atEnd || (atEOF && p == len(src)))
0000000000000000000000000000000000000000;;			nDst += nDst2
0000000000000000000000000000000000000000;;			nSrc += nSrc2
0000000000000000000000000000000000000000;;			if err2 != nil {
0000000000000000000000000000000000000000;;				return nDst, nSrc, err2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// At this point either err != nil or t.check will pass for the rune at p.
0000000000000000000000000000000000000000;;			p = nSrc + size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nDst, nSrc, err
0000000000000000000000000000000000000000;;	}
