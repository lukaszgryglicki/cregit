0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
cabf0ed26cfc9aa3cb1e604605ff2083c0b112d2;;	
0000000000000000000000000000000000000000;;	// Package utf8internal contains low-level utf8-related constants, tables, etc.
0000000000000000000000000000000000000000;;	// that are used internally by the text package.
0000000000000000000000000000000000000000;;	package utf8internal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The default lowest and highest continuation byte.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		LoCB = 0x80 // 1000 0000
0000000000000000000000000000000000000000;;		HiCB = 0xBF // 1011 1111
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Constants related to getting information of first bytes of UTF-8 sequences.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ASCII identifies a UTF-8 byte as ASCII.
0000000000000000000000000000000000000000;;		ASCII = as
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FirstInvalid indicates a byte is invalid as a first byte of a UTF-8
0000000000000000000000000000000000000000;;		// sequence.
0000000000000000000000000000000000000000;;		FirstInvalid = xx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SizeMask is a mask for the size bits. Use use x&SizeMask to get the size.
0000000000000000000000000000000000000000;;		SizeMask = 7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AcceptShift is the right-shift count for the first byte info byte to get
0000000000000000000000000000000000000000;;		// the index into the AcceptRanges table. See AcceptRanges.
0000000000000000000000000000000000000000;;		AcceptShift = 4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The names of these constants are chosen to give nice alignment in the
0000000000000000000000000000000000000000;;		// table below. The first nibble is an index into acceptRanges or F for
0000000000000000000000000000000000000000;;		// special one-byte cases. The second nibble is the Rune length or the
0000000000000000000000000000000000000000;;		// Status for the special one-byte case.
0000000000000000000000000000000000000000;;		xx = 0xF1 // invalid: size 1
0000000000000000000000000000000000000000;;		as = 0xF0 // ASCII: size 1
0000000000000000000000000000000000000000;;		s1 = 0x02 // accept 0, size 2
0000000000000000000000000000000000000000;;		s2 = 0x13 // accept 1, size 3
0000000000000000000000000000000000000000;;		s3 = 0x03 // accept 0, size 3
0000000000000000000000000000000000000000;;		s4 = 0x23 // accept 2, size 3
0000000000000000000000000000000000000000;;		s5 = 0x34 // accept 3, size 4
0000000000000000000000000000000000000000;;		s6 = 0x04 // accept 0, size 4
0000000000000000000000000000000000000000;;		s7 = 0x44 // accept 4, size 4
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// First is information about the first byte in a UTF-8 sequence.
0000000000000000000000000000000000000000;;	var First = [256]uint8{
0000000000000000000000000000000000000000;;		//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
0000000000000000000000000000000000000000;;		as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x00-0x0F
0000000000000000000000000000000000000000;;		as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x10-0x1F
0000000000000000000000000000000000000000;;		as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x20-0x2F
0000000000000000000000000000000000000000;;		as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x30-0x3F
0000000000000000000000000000000000000000;;		as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x40-0x4F
0000000000000000000000000000000000000000;;		as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x50-0x5F
0000000000000000000000000000000000000000;;		as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x60-0x6F
0000000000000000000000000000000000000000;;		as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x70-0x7F
0000000000000000000000000000000000000000;;		//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
0000000000000000000000000000000000000000;;		xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F
0000000000000000000000000000000000000000;;		xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F
0000000000000000000000000000000000000000;;		xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF
0000000000000000000000000000000000000000;;		xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF
0000000000000000000000000000000000000000;;		xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF
0000000000000000000000000000000000000000;;		s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF
0000000000000000000000000000000000000000;;		s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF
0000000000000000000000000000000000000000;;		s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AcceptRange gives the range of valid values for the second byte in a UTF-8
0000000000000000000000000000000000000000;;	// sequence for any value for First that is not ASCII or FirstInvalid.
0000000000000000000000000000000000000000;;	type AcceptRange struct {
0000000000000000000000000000000000000000;;		Lo uint8 // lowest value for second byte.
0000000000000000000000000000000000000000;;		Hi uint8 // highest value for second byte.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AcceptRanges is a slice of AcceptRange values. For a given byte sequence b
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//		AcceptRanges[First[b[0]]>>AcceptShift]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// will give the value of AcceptRange for the multi-byte UTF-8 sequence starting
0000000000000000000000000000000000000000;;	// at b[0].
0000000000000000000000000000000000000000;;	var AcceptRanges = [...]AcceptRange{
0000000000000000000000000000000000000000;;		0: {LoCB, HiCB},
0000000000000000000000000000000000000000;;		1: {0xA0, HiCB},
0000000000000000000000000000000000000000;;		2: {LoCB, 0x9F},
0000000000000000000000000000000000000000;;		3: {0x90, HiCB},
0000000000000000000000000000000000000000;;		4: {LoCB, 0x8F},
0000000000000000000000000000000000000000;;	}
