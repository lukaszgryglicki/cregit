0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// Package tag contains functionality handling tags and related data.
0000000000000000000000000000000000000000;;	package tag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Index converts tags to a compact numeric value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All elements are of size 4. Tags may be up to 4 bytes long. Excess bytes can
0000000000000000000000000000000000000000;;	// be used to store additional information about the tag.
0000000000000000000000000000000000000000;;	type Index string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Elem returns the element data at the given index.
0000000000000000000000000000000000000000;;	func (s Index) Elem(x int) string {
0000000000000000000000000000000000000000;;		return string(s[x*4 : x*4+4])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Index reports the index of the given key or -1 if it could not be found.
0000000000000000000000000000000000000000;;	// Only the first len(key) bytes from the start of the 4-byte entries will be
0000000000000000000000000000000000000000;;	// considered for the search and the first match in Index will be returned.
0000000000000000000000000000000000000000;;	func (s Index) Index(key []byte) int {
0000000000000000000000000000000000000000;;		n := len(key)
0000000000000000000000000000000000000000;;		// search the index of the first entry with an equal or higher value than
0000000000000000000000000000000000000000;;		// key in s.
0000000000000000000000000000000000000000;;		index := sort.Search(len(s)/4, func(i int) bool {
0000000000000000000000000000000000000000;;			return cmp(s[i*4:i*4+n], key) != -1
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		i := index * 4
0000000000000000000000000000000000000000;;		if cmp(s[i:i+len(key)], key) != 0 {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return index
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Next finds the next occurrence of key after index x, which must have been
0000000000000000000000000000000000000000;;	// obtained from a call to Index using the same key. It returns x+1 or -1.
0000000000000000000000000000000000000000;;	func (s Index) Next(key []byte, x int) int {
0000000000000000000000000000000000000000;;		if x++; x*4 < len(s) && cmp(s[x*4:x*4+len(key)], key) == 0 {
0000000000000000000000000000000000000000;;			return x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cmp returns an integer comparing a and b lexicographically.
0000000000000000000000000000000000000000;;	func cmp(a Index, b []byte) int {
0000000000000000000000000000000000000000;;		n := len(a)
0000000000000000000000000000000000000000;;		if len(b) < n {
0000000000000000000000000000000000000000;;			n = len(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range b[:n] {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case a[i] > c:
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			case a[i] < c:
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(a) < len(b):
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		case len(a) > len(b):
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compare returns an integer comparing a and b lexicographically.
0000000000000000000000000000000000000000;;	func Compare(a string, b []byte) int {
0000000000000000000000000000000000000000;;		return cmp(Index(a), b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FixCase reformats b to the same pattern of cases as form.
0000000000000000000000000000000000000000;;	// If returns false if string b is malformed.
0000000000000000000000000000000000000000;;	func FixCase(form string, b []byte) bool {
0000000000000000000000000000000000000000;;		if len(form) != len(b) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range b {
0000000000000000000000000000000000000000;;			if form[i] <= 'Z' {
0000000000000000000000000000000000000000;;				if c >= 'a' {
0000000000000000000000000000000000000000;;					c -= 'z' - 'Z'
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c < 'A' || 'Z' < c {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if c <= 'Z' {
0000000000000000000000000000000000000000;;					c += 'z' - 'Z'
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c < 'a' || 'z' < c {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b[i] = c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
