0000000000000000000000000000000000000000;;	// Copyright 2013 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// Package transform provides reader and writer wrappers that transform the
0000000000000000000000000000000000000000;;	// bytes passing through as well as various transformations. Example
0000000000000000000000000000000000000000;;	// transformations provided by other packages include normalization and
0000000000000000000000000000000000000000;;	// conversion between character sets.
0000000000000000000000000000000000000000;;	package transform
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrShortDst means that the destination buffer was too short to
0000000000000000000000000000000000000000;;		// receive all of the transformed bytes.
0000000000000000000000000000000000000000;;		ErrShortDst = errors.New("transform: short destination buffer")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrShortSrc means that the source buffer has insufficient data to
0000000000000000000000000000000000000000;;		// complete the transformation.
0000000000000000000000000000000000000000;;		ErrShortSrc = errors.New("transform: short source buffer")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// errInconsistentByteCount means that Transform returned success (nil
0000000000000000000000000000000000000000;;		// error) but also returned nSrc inconsistent with the src argument.
0000000000000000000000000000000000000000;;		errInconsistentByteCount = errors.New("transform: inconsistent byte count returned")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// errShortInternal means that an internal buffer is not large enough
0000000000000000000000000000000000000000;;		// to make progress and the Transform operation must be aborted.
0000000000000000000000000000000000000000;;		errShortInternal = errors.New("transform: short internal buffer")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transformer transforms bytes.
0000000000000000000000000000000000000000;;	type Transformer interface {
0000000000000000000000000000000000000000;;		// Transform writes to dst the transformed bytes read from src, and
0000000000000000000000000000000000000000;;		// returns the number of dst bytes written and src bytes read. The
0000000000000000000000000000000000000000;;		// atEOF argument tells whether src represents the last bytes of the
0000000000000000000000000000000000000000;;		// input.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Callers should always process the nDst bytes produced and account
0000000000000000000000000000000000000000;;		// for the nSrc bytes consumed before considering the error err.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// A nil error means that all of the transformed bytes (whether freshly
0000000000000000000000000000000000000000;;		// transformed from src or left over from previous Transform calls)
0000000000000000000000000000000000000000;;		// were written to dst. A nil error can be returned regardless of
0000000000000000000000000000000000000000;;		// whether atEOF is true. If err is nil then nSrc must equal len(src);
0000000000000000000000000000000000000000;;		// the converse is not necessarily true.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// ErrShortDst means that dst was too short to receive all of the
0000000000000000000000000000000000000000;;		// transformed bytes. ErrShortSrc means that src had insufficient data
0000000000000000000000000000000000000000;;		// to complete the transformation. If both conditions apply, then
0000000000000000000000000000000000000000;;		// either error may be returned. Other than the error conditions listed
0000000000000000000000000000000000000000;;		// here, implementations are free to report other errors that arise.
0000000000000000000000000000000000000000;;		Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset resets the state and allows a Transformer to be reused.
0000000000000000000000000000000000000000;;		Reset()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NopResetter can be embedded by implementations of Transformer to add a nop
0000000000000000000000000000000000000000;;	// Reset method.
0000000000000000000000000000000000000000;;	type NopResetter struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset implements the Reset method of the Transformer interface.
0000000000000000000000000000000000000000;;	func (NopResetter) Reset() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reader wraps another io.Reader by transforming the bytes read.
0000000000000000000000000000000000000000;;	type Reader struct {
0000000000000000000000000000000000000000;;		r   io.Reader
0000000000000000000000000000000000000000;;		t   Transformer
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// dst[dst0:dst1] contains bytes that have been transformed by t but
0000000000000000000000000000000000000000;;		// not yet copied out via Read.
0000000000000000000000000000000000000000;;		dst        []byte
0000000000000000000000000000000000000000;;		dst0, dst1 int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// src[src0:src1] contains bytes that have been read from r but not
0000000000000000000000000000000000000000;;		// yet transformed through t.
0000000000000000000000000000000000000000;;		src        []byte
0000000000000000000000000000000000000000;;		src0, src1 int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// transformComplete is whether the transformation is complete,
0000000000000000000000000000000000000000;;		// regardless of whether or not it was successful.
0000000000000000000000000000000000000000;;		transformComplete bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultBufSize = 4096
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReader returns a new Reader that wraps r by transforming the bytes read
0000000000000000000000000000000000000000;;	// via t. It calls Reset on t.
0000000000000000000000000000000000000000;;	func NewReader(r io.Reader, t Transformer) *Reader {
0000000000000000000000000000000000000000;;		t.Reset()
0000000000000000000000000000000000000000;;		return &Reader{
0000000000000000000000000000000000000000;;			r:   r,
0000000000000000000000000000000000000000;;			t:   t,
0000000000000000000000000000000000000000;;			dst: make([]byte, defaultBufSize),
0000000000000000000000000000000000000000;;			src: make([]byte, defaultBufSize),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read implements the io.Reader interface.
0000000000000000000000000000000000000000;;	func (r *Reader) Read(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		n, err := 0, error(nil)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Copy out any transformed bytes and return the final error if we are done.
0000000000000000000000000000000000000000;;			if r.dst0 != r.dst1 {
0000000000000000000000000000000000000000;;				n = copy(p, r.dst[r.dst0:r.dst1])
0000000000000000000000000000000000000000;;				r.dst0 += n
0000000000000000000000000000000000000000;;				if r.dst0 == r.dst1 && r.transformComplete {
0000000000000000000000000000000000000000;;					return n, r.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return n, nil
0000000000000000000000000000000000000000;;			} else if r.transformComplete {
0000000000000000000000000000000000000000;;				return 0, r.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try to transform some source bytes, or to flush the transformer if we
0000000000000000000000000000000000000000;;			// are out of source bytes. We do this even if r.r.Read returned an error.
0000000000000000000000000000000000000000;;			// As the io.Reader documentation says, "process the n > 0 bytes returned
0000000000000000000000000000000000000000;;			// before considering the error".
0000000000000000000000000000000000000000;;			if r.src0 != r.src1 || r.err != nil {
0000000000000000000000000000000000000000;;				r.dst0 = 0
0000000000000000000000000000000000000000;;				r.dst1, n, err = r.t.Transform(r.dst, r.src[r.src0:r.src1], r.err == io.EOF)
0000000000000000000000000000000000000000;;				r.src0 += n
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case err == nil:
0000000000000000000000000000000000000000;;					if r.src0 != r.src1 {
0000000000000000000000000000000000000000;;						r.err = errInconsistentByteCount
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// The Transform call was successful; we are complete if we
0000000000000000000000000000000000000000;;					// cannot read more bytes into src.
0000000000000000000000000000000000000000;;					r.transformComplete = r.err != nil
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case err == ErrShortDst && (r.dst1 != 0 || n != 0):
0000000000000000000000000000000000000000;;					// Make room in dst by copying out, and try again.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case err == ErrShortSrc && r.src1-r.src0 != len(r.src) && r.err == nil:
0000000000000000000000000000000000000000;;					// Read more bytes into src via the code below, and try again.
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					r.transformComplete = true
0000000000000000000000000000000000000000;;					// The reader error (r.err) takes precedence over the
0000000000000000000000000000000000000000;;					// transformer error (err) unless r.err is nil or io.EOF.
0000000000000000000000000000000000000000;;					if r.err == nil || r.err == io.EOF {
0000000000000000000000000000000000000000;;						r.err = err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Move any untransformed source bytes to the start of the buffer
0000000000000000000000000000000000000000;;			// and read more bytes.
0000000000000000000000000000000000000000;;			if r.src0 != 0 {
0000000000000000000000000000000000000000;;				r.src0, r.src1 = 0, copy(r.src, r.src[r.src0:r.src1])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n, r.err = r.r.Read(r.src[r.src1:])
0000000000000000000000000000000000000000;;			r.src1 += n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: implement ReadByte (and ReadRune??).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Writer wraps another io.Writer by transforming the bytes read.
0000000000000000000000000000000000000000;;	// The user needs to call Close to flush unwritten bytes that may
0000000000000000000000000000000000000000;;	// be buffered.
0000000000000000000000000000000000000000;;	type Writer struct {
0000000000000000000000000000000000000000;;		w   io.Writer
0000000000000000000000000000000000000000;;		t   Transformer
0000000000000000000000000000000000000000;;		dst []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// src[:n] contains bytes that have not yet passed through t.
0000000000000000000000000000000000000000;;		src []byte
0000000000000000000000000000000000000000;;		n   int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWriter returns a new Writer that wraps w by transforming the bytes written
0000000000000000000000000000000000000000;;	// via t. It calls Reset on t.
0000000000000000000000000000000000000000;;	func NewWriter(w io.Writer, t Transformer) *Writer {
0000000000000000000000000000000000000000;;		t.Reset()
0000000000000000000000000000000000000000;;		return &Writer{
0000000000000000000000000000000000000000;;			w:   w,
0000000000000000000000000000000000000000;;			t:   t,
0000000000000000000000000000000000000000;;			dst: make([]byte, defaultBufSize),
0000000000000000000000000000000000000000;;			src: make([]byte, defaultBufSize),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write implements the io.Writer interface. If there are not enough
0000000000000000000000000000000000000000;;	// bytes available to complete a Transform, the bytes will be buffered
0000000000000000000000000000000000000000;;	// for the next write. Call Close to convert the remaining bytes.
0000000000000000000000000000000000000000;;	func (w *Writer) Write(data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		src := data
0000000000000000000000000000000000000000;;		if w.n > 0 {
0000000000000000000000000000000000000000;;			// Append bytes from data to the last remainder.
0000000000000000000000000000000000000000;;			// TODO: limit the amount copied on first try.
0000000000000000000000000000000000000000;;			n = copy(w.src[w.n:], data)
0000000000000000000000000000000000000000;;			w.n += n
0000000000000000000000000000000000000000;;			src = w.src[:w.n]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			nDst, nSrc, err := w.t.Transform(w.dst, src, false)
0000000000000000000000000000000000000000;;			if _, werr := w.w.Write(w.dst[:nDst]); werr != nil {
0000000000000000000000000000000000000000;;				return n, werr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			src = src[nSrc:]
0000000000000000000000000000000000000000;;			if w.n == 0 {
0000000000000000000000000000000000000000;;				n += nSrc
0000000000000000000000000000000000000000;;			} else if len(src) <= n {
0000000000000000000000000000000000000000;;				// Enough bytes from w.src have been consumed. We make src point
0000000000000000000000000000000000000000;;				// to data instead to reduce the copying.
0000000000000000000000000000000000000000;;				w.n = 0
0000000000000000000000000000000000000000;;				n -= len(src)
0000000000000000000000000000000000000000;;				src = data[n:]
0000000000000000000000000000000000000000;;				if n < len(data) && (err == nil || err == ErrShortSrc) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch err {
0000000000000000000000000000000000000000;;			case ErrShortDst:
0000000000000000000000000000000000000000;;				// This error is okay as long as we are making progress.
0000000000000000000000000000000000000000;;				if nDst > 0 || nSrc > 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case ErrShortSrc:
0000000000000000000000000000000000000000;;				if len(src) < len(w.src) {
0000000000000000000000000000000000000000;;					m := copy(w.src, src)
0000000000000000000000000000000000000000;;					// If w.n > 0, bytes from data were already copied to w.src and n
0000000000000000000000000000000000000000;;					// was already set to the number of bytes consumed.
0000000000000000000000000000000000000000;;					if w.n == 0 {
0000000000000000000000000000000000000000;;						n += m
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w.n = m
0000000000000000000000000000000000000000;;					err = nil
0000000000000000000000000000000000000000;;				} else if nDst > 0 || nSrc > 0 {
0000000000000000000000000000000000000000;;					// Not enough buffer to store the remainder. Keep processing as
0000000000000000000000000000000000000000;;					// long as there is progress. Without this case, transforms that
0000000000000000000000000000000000000000;;					// require a lookahead larger than the buffer may result in an
0000000000000000000000000000000000000000;;					// error. This is not something one may expect to be common in
0000000000000000000000000000000000000000;;					// practice, but it may occur when buffers are set to small
0000000000000000000000000000000000000000;;					// sizes during testing.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				if w.n > 0 {
0000000000000000000000000000000000000000;;					err = errInconsistentByteCount
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close implements the io.Closer interface.
0000000000000000000000000000000000000000;;	func (w *Writer) Close() error {
0000000000000000000000000000000000000000;;		src := w.src[:w.n]
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			nDst, nSrc, err := w.t.Transform(w.dst, src, true)
0000000000000000000000000000000000000000;;			if _, werr := w.w.Write(w.dst[:nDst]); werr != nil {
0000000000000000000000000000000000000000;;				return werr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != ErrShortDst {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			src = src[nSrc:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nop struct{ NopResetter }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (nop) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		n := copy(dst, src)
0000000000000000000000000000000000000000;;		if n < len(src) {
0000000000000000000000000000000000000000;;			err = ErrShortDst
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type discard struct{ NopResetter }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (discard) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		return 0, len(src), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Discard is a Transformer for which all Transform calls succeed
0000000000000000000000000000000000000000;;		// by consuming all bytes and writing nothing.
0000000000000000000000000000000000000000;;		Discard Transformer = discard{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Nop is a Transformer that copies src to dst.
0000000000000000000000000000000000000000;;		Nop Transformer = nop{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// chain is a sequence of links. A chain with N Transformers has N+1 links and
0000000000000000000000000000000000000000;;	// N+1 buffers. Of those N+1 buffers, the first and last are the src and dst
0000000000000000000000000000000000000000;;	// buffers given to chain.Transform and the middle N-1 buffers are intermediate
0000000000000000000000000000000000000000;;	// buffers owned by the chain. The i'th link transforms bytes from the i'th
0000000000000000000000000000000000000000;;	// buffer chain.link[i].b at read offset chain.link[i].p to the i+1'th buffer
0000000000000000000000000000000000000000;;	// chain.link[i+1].b at write offset chain.link[i+1].n, for i in [0, N).
0000000000000000000000000000000000000000;;	type chain struct {
0000000000000000000000000000000000000000;;		link []link
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;		// errStart is the index at which the error occurred plus 1. Processing
0000000000000000000000000000000000000000;;		// errStart at this level at the next call to Transform. As long as
0000000000000000000000000000000000000000;;		// errStart > 0, chain will not consume any more source bytes.
0000000000000000000000000000000000000000;;		errStart int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *chain) fatalError(errIndex int, err error) {
0000000000000000000000000000000000000000;;		if i := errIndex + 1; i > c.errStart {
0000000000000000000000000000000000000000;;			c.errStart = i
0000000000000000000000000000000000000000;;			c.err = err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type link struct {
0000000000000000000000000000000000000000;;		t Transformer
0000000000000000000000000000000000000000;;		// b[p:n] holds the bytes to be transformed by t.
0000000000000000000000000000000000000000;;		b []byte
0000000000000000000000000000000000000000;;		p int
0000000000000000000000000000000000000000;;		n int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *link) src() []byte {
0000000000000000000000000000000000000000;;		return l.b[l.p:l.n]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *link) dst() []byte {
0000000000000000000000000000000000000000;;		return l.b[l.n:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chain returns a Transformer that applies t in sequence.
0000000000000000000000000000000000000000;;	func Chain(t ...Transformer) Transformer {
0000000000000000000000000000000000000000;;		if len(t) == 0 {
0000000000000000000000000000000000000000;;			return nop{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := &chain{link: make([]link, len(t)+1)}
0000000000000000000000000000000000000000;;		for i, tt := range t {
0000000000000000000000000000000000000000;;			c.link[i].t = tt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Allocate intermediate buffers.
0000000000000000000000000000000000000000;;		b := make([][defaultBufSize]byte, len(t)-1)
0000000000000000000000000000000000000000;;		for i := range b {
0000000000000000000000000000000000000000;;			c.link[i+1].b = b[i][:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset resets the state of Chain. It calls Reset on all the Transformers.
0000000000000000000000000000000000000000;;	func (c *chain) Reset() {
0000000000000000000000000000000000000000;;		for i, l := range c.link {
0000000000000000000000000000000000000000;;			if l.t != nil {
0000000000000000000000000000000000000000;;				l.t.Reset()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.link[i].p, c.link[i].n = 0, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform applies the transformers of c in sequence.
0000000000000000000000000000000000000000;;	func (c *chain) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		// Set up src and dst in the chain.
0000000000000000000000000000000000000000;;		srcL := &c.link[0]
0000000000000000000000000000000000000000;;		dstL := &c.link[len(c.link)-1]
0000000000000000000000000000000000000000;;		srcL.b, srcL.p, srcL.n = src, 0, len(src)
0000000000000000000000000000000000000000;;		dstL.b, dstL.n = dst, 0
0000000000000000000000000000000000000000;;		var lastFull, needProgress bool // for detecting progress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// i is the index of the next Transformer to apply, for i in [low, high].
0000000000000000000000000000000000000000;;		// low is the lowest index for which c.link[low] may still produce bytes.
0000000000000000000000000000000000000000;;		// high is the highest index for which c.link[high] has a Transformer.
0000000000000000000000000000000000000000;;		// The error returned by Transform determines whether to increase or
0000000000000000000000000000000000000000;;		// decrease i. We try to completely fill a buffer before converting it.
0000000000000000000000000000000000000000;;		for low, i, high := c.errStart, c.errStart, len(c.link)-2; low <= i && i <= high; {
0000000000000000000000000000000000000000;;			in, out := &c.link[i], &c.link[i+1]
0000000000000000000000000000000000000000;;			nDst, nSrc, err0 := in.t.Transform(out.dst(), in.src(), atEOF && low == i)
0000000000000000000000000000000000000000;;			out.n += nDst
0000000000000000000000000000000000000000;;			in.p += nSrc
0000000000000000000000000000000000000000;;			if i > 0 && in.p == in.n {
0000000000000000000000000000000000000000;;				in.p, in.n = 0, 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			needProgress, lastFull = lastFull, false
0000000000000000000000000000000000000000;;			switch err0 {
0000000000000000000000000000000000000000;;			case ErrShortDst:
0000000000000000000000000000000000000000;;				// Process the destination buffer next. Return if we are already
0000000000000000000000000000000000000000;;				// at the high index.
0000000000000000000000000000000000000000;;				if i == high {
0000000000000000000000000000000000000000;;					return dstL.n, srcL.p, ErrShortDst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if out.n != 0 {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;					// If the Transformer at the next index is not able to process any
0000000000000000000000000000000000000000;;					// source bytes there is nothing that can be done to make progress
0000000000000000000000000000000000000000;;					// and the bytes will remain unprocessed. lastFull is used to
0000000000000000000000000000000000000000;;					// detect this and break out of the loop with a fatal error.
0000000000000000000000000000000000000000;;					lastFull = true
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// The destination buffer was too small, but is completely empty.
0000000000000000000000000000000000000000;;				// Return a fatal error as this transformation can never complete.
0000000000000000000000000000000000000000;;				c.fatalError(i, errShortInternal)
0000000000000000000000000000000000000000;;			case ErrShortSrc:
0000000000000000000000000000000000000000;;				if i == 0 {
0000000000000000000000000000000000000000;;					// Save ErrShortSrc in err. All other errors take precedence.
0000000000000000000000000000000000000000;;					err = ErrShortSrc
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Source bytes were depleted before filling up the destination buffer.
0000000000000000000000000000000000000000;;				// Verify we made some progress, move the remaining bytes to the errStart
0000000000000000000000000000000000000000;;				// and try to get more source bytes.
0000000000000000000000000000000000000000;;				if needProgress && nSrc == 0 || in.n-in.p == len(in.b) {
0000000000000000000000000000000000000000;;					// There were not enough source bytes to proceed while the source
0000000000000000000000000000000000000000;;					// buffer cannot hold any more bytes. Return a fatal error as this
0000000000000000000000000000000000000000;;					// transformation can never complete.
0000000000000000000000000000000000000000;;					c.fatalError(i, errShortInternal)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// in.b is an internal buffer and we can make progress.
0000000000000000000000000000000000000000;;				in.p, in.n = 0, copy(in.b, in.src())
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				// if i == low, we have depleted the bytes at index i or any lower levels.
0000000000000000000000000000000000000000;;				// In that case we increase low and i. In all other cases we decrease i to
0000000000000000000000000000000000000000;;				// fetch more bytes before proceeding to the next index.
0000000000000000000000000000000000000000;;				if i > low {
0000000000000000000000000000000000000000;;					i--
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				c.fatalError(i, err0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Exhausted level low or fatal error: increase low and continue
0000000000000000000000000000000000000000;;			// to process the bytes accepted so far.
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			low = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If c.errStart > 0, this means we found a fatal error.  We will clear
0000000000000000000000000000000000000000;;		// all upstream buffers. At this point, no more progress can be made
0000000000000000000000000000000000000000;;		// downstream, as Transform would have bailed while handling ErrShortDst.
0000000000000000000000000000000000000000;;		if c.errStart > 0 {
0000000000000000000000000000000000000000;;			for i := 1; i < c.errStart; i++ {
0000000000000000000000000000000000000000;;				c.link[i].p, c.link[i].n = 0, 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err, c.errStart, c.err = c.err, 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dstL.n, srcL.p, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveFunc returns a Transformer that removes from the input all runes r for
0000000000000000000000000000000000000000;;	// which f(r) is true. Illegal bytes in the input are replaced by RuneError.
0000000000000000000000000000000000000000;;	func RemoveFunc(f func(r rune) bool) Transformer {
0000000000000000000000000000000000000000;;		return removeF(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type removeF func(r rune) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (removeF) Reset() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform implements the Transformer interface.
0000000000000000000000000000000000000000;;	func (t removeF) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		for r, sz := rune(0), 0; len(src) > 0; src = src[sz:] {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if r = rune(src[0]); r < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				sz = 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r, sz = utf8.DecodeRune(src)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if sz == 1 {
0000000000000000000000000000000000000000;;					// Invalid rune.
0000000000000000000000000000000000000000;;					if !atEOF && !utf8.FullRune(src) {
0000000000000000000000000000000000000000;;						err = ErrShortSrc
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// We replace illegal bytes with RuneError. Not doing so might
0000000000000000000000000000000000000000;;					// otherwise turn a sequence of invalid UTF-8 into valid UTF-8.
0000000000000000000000000000000000000000;;					// The resulting byte sequence may subsequently contain runes
0000000000000000000000000000000000000000;;					// for which t(r) is true that were passed unnoticed.
0000000000000000000000000000000000000000;;					if !t(r) {
0000000000000000000000000000000000000000;;						if nDst+3 > len(dst) {
0000000000000000000000000000000000000000;;							err = ErrShortDst
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						nDst += copy(dst[nDst:], "\uFFFD")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					nSrc++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !t(r) {
0000000000000000000000000000000000000000;;				if nDst+sz > len(dst) {
0000000000000000000000000000000000000000;;					err = ErrShortDst
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nDst += copy(dst[nDst:], src[:sz])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nSrc += sz
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// grow returns a new []byte that is longer than b, and copies the first n bytes
0000000000000000000000000000000000000000;;	// of b to the start of the new slice.
0000000000000000000000000000000000000000;;	func grow(b []byte, n int) []byte {
0000000000000000000000000000000000000000;;		m := len(b)
0000000000000000000000000000000000000000;;		if m <= 32 {
0000000000000000000000000000000000000000;;			m = 64
0000000000000000000000000000000000000000;;		} else if m <= 256 {
0000000000000000000000000000000000000000;;			m *= 2
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m += m >> 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := make([]byte, m)
0000000000000000000000000000000000000000;;		copy(buf, b[:n])
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const initialBufSize = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string with the result of converting s[:n] using t, where
0000000000000000000000000000000000000000;;	// n <= len(s). If err == nil, n will be len(s). It calls Reset on t.
0000000000000000000000000000000000000000;;	func String(t Transformer, s string) (result string, n int, err error) {
0000000000000000000000000000000000000000;;		t.Reset()
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			// Fast path for the common case for empty input. Results in about a
0000000000000000000000000000000000000000;;			// 86% reduction of running time for BenchmarkStringLowerEmpty.
0000000000000000000000000000000000000000;;			if _, _, err := t.Transform(nil, nil, true); err == nil {
0000000000000000000000000000000000000000;;				return "", 0, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allocate only once. Note that both dst and src escape when passed to
0000000000000000000000000000000000000000;;		// Transform.
0000000000000000000000000000000000000000;;		buf := [2 * initialBufSize]byte{}
0000000000000000000000000000000000000000;;		dst := buf[:initialBufSize:initialBufSize]
0000000000000000000000000000000000000000;;		src := buf[initialBufSize : 2*initialBufSize]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The input string s is transformed in multiple chunks (starting with a
0000000000000000000000000000000000000000;;		// chunk size of initialBufSize). nDst and nSrc are per-chunk (or
0000000000000000000000000000000000000000;;		// per-Transform-call) indexes, pDst and pSrc are overall indexes.
0000000000000000000000000000000000000000;;		nDst, nSrc := 0, 0
0000000000000000000000000000000000000000;;		pDst, pSrc := 0, 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pPrefix is the length of a common prefix: the first pPrefix bytes of the
0000000000000000000000000000000000000000;;		// result will equal the first pPrefix bytes of s. It is not guaranteed to
0000000000000000000000000000000000000000;;		// be the largest such value, but if pPrefix, len(result) and len(s) are
0000000000000000000000000000000000000000;;		// all equal after the final transform (i.e. calling Transform with atEOF
0000000000000000000000000000000000000000;;		// being true returned nil error) then we don't need to allocate a new
0000000000000000000000000000000000000000;;		// result string.
0000000000000000000000000000000000000000;;		pPrefix := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Invariant: pDst == pPrefix && pSrc == pPrefix.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n := copy(src, s[pSrc:])
0000000000000000000000000000000000000000;;			nDst, nSrc, err = t.Transform(dst, src[:n], pSrc+n == len(s))
0000000000000000000000000000000000000000;;			pDst += nDst
0000000000000000000000000000000000000000;;			pSrc += nSrc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO:  let transformers implement an optional Spanner interface, akin
0000000000000000000000000000000000000000;;			// to norm's QuickSpan. This would even allow us to avoid any allocation.
0000000000000000000000000000000000000000;;			if !bytes.Equal(dst[:nDst], src[:nSrc]) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pPrefix = pSrc
0000000000000000000000000000000000000000;;			if err == ErrShortDst {
0000000000000000000000000000000000000000;;				// A buffer can only be short if a transformer modifies its input.
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if err == ErrShortSrc {
0000000000000000000000000000000000000000;;				if nSrc == 0 {
0000000000000000000000000000000000000000;;					// No progress was made.
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Equal so far and !atEOF, so continue checking.
0000000000000000000000000000000000000000;;			} else if err != nil || pPrefix == len(s) {
0000000000000000000000000000000000000000;;				return string(s[:pPrefix]), pPrefix, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Post-condition: pDst == pPrefix + nDst && pSrc == pPrefix + nSrc.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We have transformed the first pSrc bytes of the input s to become pDst
0000000000000000000000000000000000000000;;		// transformed bytes. Those transformed bytes are discontiguous: the first
0000000000000000000000000000000000000000;;		// pPrefix of them equal s[:pPrefix] and the last nDst of them equal
0000000000000000000000000000000000000000;;		// dst[:nDst]. We copy them around, into a new dst buffer if necessary, so
0000000000000000000000000000000000000000;;		// that they become one contiguous slice: dst[:pDst].
0000000000000000000000000000000000000000;;		if pPrefix != 0 {
0000000000000000000000000000000000000000;;			newDst := dst
0000000000000000000000000000000000000000;;			if pDst > len(newDst) {
0000000000000000000000000000000000000000;;				newDst = make([]byte, len(s)+nDst-nSrc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy(newDst[pPrefix:pDst], dst[:nDst])
0000000000000000000000000000000000000000;;			copy(newDst[:pPrefix], s[:pPrefix])
0000000000000000000000000000000000000000;;			dst = newDst
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prevent duplicate Transform calls with atEOF being true at the end of
0000000000000000000000000000000000000000;;		// the input. Also return if we have an unrecoverable error.
0000000000000000000000000000000000000000;;		if (err == nil && pSrc == len(s)) ||
0000000000000000000000000000000000000000;;			(err != nil && err != ErrShortDst && err != ErrShortSrc) {
0000000000000000000000000000000000000000;;			return string(dst[:pDst]), pSrc, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Transform the remaining input, growing dst and src buffers as necessary.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n := copy(src, s[pSrc:])
0000000000000000000000000000000000000000;;			nDst, nSrc, err := t.Transform(dst[pDst:], src[:n], pSrc+n == len(s))
0000000000000000000000000000000000000000;;			pDst += nDst
0000000000000000000000000000000000000000;;			pSrc += nSrc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we got ErrShortDst or ErrShortSrc, do not grow as long as we can
0000000000000000000000000000000000000000;;			// make progress. This may avoid excessive allocations.
0000000000000000000000000000000000000000;;			if err == ErrShortDst {
0000000000000000000000000000000000000000;;				if nDst == 0 {
0000000000000000000000000000000000000000;;					dst = grow(dst, pDst)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if err == ErrShortSrc {
0000000000000000000000000000000000000000;;				if nSrc == 0 {
0000000000000000000000000000000000000000;;					src = grow(src, 0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if err != nil || pSrc == len(s) {
0000000000000000000000000000000000000000;;				return string(dst[:pDst]), pSrc, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns a new byte slice with the result of converting b[:n] using t,
0000000000000000000000000000000000000000;;	// where n <= len(b). If err == nil, n will be len(b). It calls Reset on t.
0000000000000000000000000000000000000000;;	func Bytes(t Transformer, b []byte) (result []byte, n int, err error) {
0000000000000000000000000000000000000000;;		return doAppend(t, 0, make([]byte, len(b)), b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Append appends the result of converting src[:n] using t to dst, where
0000000000000000000000000000000000000000;;	// n <= len(src), If err == nil, n will be len(src). It calls Reset on t.
0000000000000000000000000000000000000000;;	func Append(t Transformer, dst, src []byte) (result []byte, n int, err error) {
0000000000000000000000000000000000000000;;		if len(dst) == cap(dst) {
0000000000000000000000000000000000000000;;			n := len(src) + len(dst) // It is okay for this to be 0.
0000000000000000000000000000000000000000;;			b := make([]byte, n)
0000000000000000000000000000000000000000;;			dst = b[:copy(b, dst)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return doAppend(t, len(dst), dst[:cap(dst)], src)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doAppend(t Transformer, pDst int, dst, src []byte) (result []byte, n int, err error) {
0000000000000000000000000000000000000000;;		t.Reset()
0000000000000000000000000000000000000000;;		pSrc := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			nDst, nSrc, err := t.Transform(dst[pDst:], src[pSrc:], true)
0000000000000000000000000000000000000000;;			pDst += nDst
0000000000000000000000000000000000000000;;			pSrc += nSrc
0000000000000000000000000000000000000000;;			if err != ErrShortDst {
0000000000000000000000000000000000000000;;				return dst[:pDst], pSrc, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Grow the destination buffer, but do not grow as long as we can make
0000000000000000000000000000000000000000;;			// progress. This may avoid excessive allocations.
0000000000000000000000000000000000000000;;			if nDst == 0 {
0000000000000000000000000000000000000000;;				dst = grow(dst, pDst)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
