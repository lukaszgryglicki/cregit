0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// +build ignore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This program generates the trie for casing operations. The Unicode casing
0000000000000000000000000000000000000000;;	// algorithm requires the lookup of various properties and mappings for each
0000000000000000000000000000000000000000;;	// rune. The table generated by this generator combines several of the most
0000000000000000000000000000000000000000;;	// frequently used of these into a single trie so that they can be accessed
0000000000000000000000000000000000000000;;	// with a single lookup.
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/gen"
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/triegen"
0000000000000000000000000000000000000000;;		"golang.org/x/text/internal/ucd"
0000000000000000000000000000000000000000;;		"golang.org/x/text/unicode/norm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		gen.Init()
0000000000000000000000000000000000000000;;		genTables()
0000000000000000000000000000000000000000;;		genTablesTest()
0000000000000000000000000000000000000000;;		gen.Repackage("gen_trieval.go", "trieval.go", "cases")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runeInfo contains all information for a rune that we care about for casing
0000000000000000000000000000000000000000;;	// operations.
0000000000000000000000000000000000000000;;	type runeInfo struct {
0000000000000000000000000000000000000000;;		Rune rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entry info // trie value for this rune.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CaseMode info
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Simple case mappings.
0000000000000000000000000000000000000000;;		Simple [1 + maxCaseMode][]rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Special casing
0000000000000000000000000000000000000000;;		HasSpecial  bool
0000000000000000000000000000000000000000;;		Conditional bool
0000000000000000000000000000000000000000;;		Special     [1 + maxCaseMode][]rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Folding
0000000000000000000000000000000000000000;;		FoldSimple  rune
0000000000000000000000000000000000000000;;		FoldSpecial rune
0000000000000000000000000000000000000000;;		FoldFull    []rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: FC_NFKC, or equivalent data.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Properties
0000000000000000000000000000000000000000;;		SoftDotted     bool
0000000000000000000000000000000000000000;;		CaseIgnorable  bool
0000000000000000000000000000000000000000;;		Cased          bool
0000000000000000000000000000000000000000;;		DecomposeGreek bool
0000000000000000000000000000000000000000;;		BreakType      string
0000000000000000000000000000000000000000;;		BreakCat       breakCategory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We care mostly about 0, Above, and IotaSubscript.
0000000000000000000000000000000000000000;;		CCC byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type breakCategory int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		breakBreak breakCategory = iota
0000000000000000000000000000000000000000;;		breakLetter
0000000000000000000000000000000000000000;;		breakIgnored
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapping returns the case mapping for the given case type.
0000000000000000000000000000000000000000;;	func (r *runeInfo) mapping(c info) string {
0000000000000000000000000000000000000000;;		if r.HasSpecial {
0000000000000000000000000000000000000000;;			return string(r.Special[c])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.Simple[c]) != 0 {
0000000000000000000000000000000000000000;;			return string(r.Simple[c])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(r.Rune)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parse(file string, f func(p *ucd.Parser)) {
0000000000000000000000000000000000000000;;		ucd.Parse(gen.OpenUCDFile(file), f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseUCD() []runeInfo {
0000000000000000000000000000000000000000;;		chars := make([]runeInfo, unicode.MaxRune)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		get := func(r rune) *runeInfo {
0000000000000000000000000000000000000000;;			c := &chars[r]
0000000000000000000000000000000000000000;;			c.Rune = r
0000000000000000000000000000000000000000;;			return c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parse("UnicodeData.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			ri := get(p.Rune(0))
0000000000000000000000000000000000000000;;			ri.CCC = byte(p.Int(ucd.CanonicalCombiningClass))
0000000000000000000000000000000000000000;;			ri.Simple[cLower] = p.Runes(ucd.SimpleLowercaseMapping)
0000000000000000000000000000000000000000;;			ri.Simple[cUpper] = p.Runes(ucd.SimpleUppercaseMapping)
0000000000000000000000000000000000000000;;			ri.Simple[cTitle] = p.Runes(ucd.SimpleTitlecaseMapping)
0000000000000000000000000000000000000000;;			if p.String(ucd.GeneralCategory) == "Lt" {
0000000000000000000000000000000000000000;;				ri.CaseMode = cTitle
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// <code>; <property>
0000000000000000000000000000000000000000;;		parse("PropList.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			if p.String(1) == "Soft_Dotted" {
0000000000000000000000000000000000000000;;				chars[p.Rune(0)].SoftDotted = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// <code>; <word break type>
0000000000000000000000000000000000000000;;		parse("DerivedCoreProperties.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			ri := get(p.Rune(0))
0000000000000000000000000000000000000000;;			switch p.String(1) {
0000000000000000000000000000000000000000;;			case "Case_Ignorable":
0000000000000000000000000000000000000000;;				ri.CaseIgnorable = true
0000000000000000000000000000000000000000;;			case "Cased":
0000000000000000000000000000000000000000;;				ri.Cased = true
0000000000000000000000000000000000000000;;			case "Lowercase":
0000000000000000000000000000000000000000;;				ri.CaseMode = cLower
0000000000000000000000000000000000000000;;			case "Uppercase":
0000000000000000000000000000000000000000;;				ri.CaseMode = cUpper
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// <code>; <lower> ; <title> ; <upper> ; (<condition_list> ;)?
0000000000000000000000000000000000000000;;		parse("SpecialCasing.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			// We drop all conditional special casing and deal with them manually in
0000000000000000000000000000000000000000;;			// the language-specific case mappers. Rune 0x03A3 is the only one with
0000000000000000000000000000000000000000;;			// a conditional formatting that is not language-specific. However,
0000000000000000000000000000000000000000;;			// dealing with this letter is tricky, especially in a streaming
0000000000000000000000000000000000000000;;			// context, so we deal with it in the Caser for Greek specifically.
0000000000000000000000000000000000000000;;			ri := get(p.Rune(0))
0000000000000000000000000000000000000000;;			if p.String(4) == "" {
0000000000000000000000000000000000000000;;				ri.HasSpecial = true
0000000000000000000000000000000000000000;;				ri.Special[cLower] = p.Runes(1)
0000000000000000000000000000000000000000;;				ri.Special[cTitle] = p.Runes(2)
0000000000000000000000000000000000000000;;				ri.Special[cUpper] = p.Runes(3)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ri.Conditional = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Use text breaking according to UAX #29.
0000000000000000000000000000000000000000;;		// <code>; <word break type>
0000000000000000000000000000000000000000;;		parse("auxiliary/WordBreakProperty.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			ri := get(p.Rune(0))
0000000000000000000000000000000000000000;;			ri.BreakType = p.String(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We collapse the word breaking properties onto the categories we need.
0000000000000000000000000000000000000000;;			switch p.String(1) { // TODO: officially we need to canonicalize.
0000000000000000000000000000000000000000;;			case "Format", "MidLetter", "MidNumLet", "Single_Quote":
0000000000000000000000000000000000000000;;				ri.BreakCat = breakIgnored
0000000000000000000000000000000000000000;;			case "ALetter", "Hebrew_Letter", "Numeric", "Extend", "ExtendNumLet":
0000000000000000000000000000000000000000;;				ri.BreakCat = breakLetter
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// <code>; <type>; <mapping>
0000000000000000000000000000000000000000;;		parse("CaseFolding.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			ri := get(p.Rune(0))
0000000000000000000000000000000000000000;;			switch p.String(1) {
0000000000000000000000000000000000000000;;			case "C":
0000000000000000000000000000000000000000;;				ri.FoldSimple = p.Rune(2)
0000000000000000000000000000000000000000;;				ri.FoldFull = p.Runes(2)
0000000000000000000000000000000000000000;;			case "S":
0000000000000000000000000000000000000000;;				ri.FoldSimple = p.Rune(2)
0000000000000000000000000000000000000000;;			case "T":
0000000000000000000000000000000000000000;;				ri.FoldSpecial = p.Rune(2)
0000000000000000000000000000000000000000;;			case "F":
0000000000000000000000000000000000000000;;				ri.FoldFull = p.Runes(2)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				log.Fatalf("%U: unknown type: %s", p.Rune(0), p.String(1))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return chars
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genTables() {
0000000000000000000000000000000000000000;;		chars := parseUCD()
0000000000000000000000000000000000000000;;		verifyProperties(chars)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := triegen.NewTrie("case")
0000000000000000000000000000000000000000;;		for i := range chars {
0000000000000000000000000000000000000000;;			c := &chars[i]
0000000000000000000000000000000000000000;;			makeEntry(c)
0000000000000000000000000000000000000000;;			t.Insert(rune(i), uint64(c.entry))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := gen.NewCodeWriter()
0000000000000000000000000000000000000000;;		defer w.WriteGoFile("tables.go", "cases")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gen.WriteUnicodeVersion(w)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: write CLDR version after adding a mechanism to detect that the
0000000000000000000000000000000000000000;;		// tables on which the manually created locale-sensitive casing code is
0000000000000000000000000000000000000000;;		// based hasn't changed.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.WriteVar("xorData", string(xorData))
0000000000000000000000000000000000000000;;		w.WriteVar("exceptions", string(exceptionData))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sz, err := t.Gen(w, triegen.Compact(&sparseCompacter{}))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Size += sz
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeEntry(ri *runeInfo) {
0000000000000000000000000000000000000000;;		if ri.CaseIgnorable {
0000000000000000000000000000000000000000;;			if ri.Cased {
0000000000000000000000000000000000000000;;				ri.entry = cIgnorableCased
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ri.entry = cIgnorableUncased
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ri.entry = ri.CaseMode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: handle soft-dotted.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ccc := cccOther
0000000000000000000000000000000000000000;;		switch ri.CCC {
0000000000000000000000000000000000000000;;		case 0: // Not_Reordered
0000000000000000000000000000000000000000;;			ccc = cccZero
0000000000000000000000000000000000000000;;		case above: // Above
0000000000000000000000000000000000000000;;			ccc = cccAbove
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ri.BreakCat == breakBreak {
0000000000000000000000000000000000000000;;			ccc = cccBreak
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ri.entry |= ccc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ri.CaseMode == cUncased {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Need to do something special.
0000000000000000000000000000000000000000;;		if ri.CaseMode == cTitle || ri.HasSpecial || ri.mapping(cTitle) != ri.mapping(cUpper) {
0000000000000000000000000000000000000000;;			makeException(ri)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f := string(ri.FoldFull); len(f) > 0 && f != ri.mapping(cUpper) && f != ri.mapping(cLower) {
0000000000000000000000000000000000000000;;			makeException(ri)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rune is either lowercase or uppercase.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		orig := string(ri.Rune)
0000000000000000000000000000000000000000;;		mapped := ""
0000000000000000000000000000000000000000;;		if ri.CaseMode == cUpper {
0000000000000000000000000000000000000000;;			mapped = ri.mapping(cLower)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			mapped = ri.mapping(cUpper)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(orig) != len(mapped) {
0000000000000000000000000000000000000000;;			makeException(ri)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if string(ri.FoldFull) == ri.mapping(cUpper) {
0000000000000000000000000000000000000000;;			ri.entry |= inverseFoldBit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := len(orig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create per-byte XOR mask.
0000000000000000000000000000000000000000;;		var b []byte
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			b = append(b, orig[i]^mapped[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove leading 0 bytes, but keep at least one byte.
0000000000000000000000000000000000000000;;		for ; len(b) > 1 && b[0] == 0; b = b[1:] {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b) == 1 && b[0]&0xc0 == 0 {
0000000000000000000000000000000000000000;;			ri.entry |= info(b[0]) << xorShift
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := string(b)
0000000000000000000000000000000000000000;;		x, ok := xorCache[key]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			xorData = append(xorData, 0) // for detecting start of sequence
0000000000000000000000000000000000000000;;			xorData = append(xorData, b...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			x = len(xorData) - 1
0000000000000000000000000000000000000000;;			xorCache[key] = x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ri.entry |= info(x<<xorShift) | xorIndexBit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var xorCache = map[string]int{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// xorData contains byte-wise XOR data for the least significant bytes of a
0000000000000000000000000000000000000000;;	// UTF-8 encoded rune. An index points to the last byte. The sequence starts
0000000000000000000000000000000000000000;;	// with a zero terminator.
0000000000000000000000000000000000000000;;	var xorData = []byte{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See the comments in gen_trieval.go re "the exceptions slice".
0000000000000000000000000000000000000000;;	var exceptionData = []byte{0}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeException encodes case mappings that cannot be expressed in a simple
0000000000000000000000000000000000000000;;	// XOR diff.
0000000000000000000000000000000000000000;;	func makeException(ri *runeInfo) {
0000000000000000000000000000000000000000;;		ccc := ri.entry & cccMask
0000000000000000000000000000000000000000;;		// Set exception bit and retain case type.
0000000000000000000000000000000000000000;;		ri.entry &= 0x0007
0000000000000000000000000000000000000000;;		ri.entry |= exceptionBit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(exceptionData) >= 1<<numExceptionBits {
0000000000000000000000000000000000000000;;			log.Fatalf("%U:exceptionData too large %x > %d bits", ri.Rune, len(exceptionData), numExceptionBits)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the offset in the exceptionData array.
0000000000000000000000000000000000000000;;		ri.entry |= info(len(exceptionData) << exceptionShift)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		orig := string(ri.Rune)
0000000000000000000000000000000000000000;;		tc := ri.mapping(cTitle)
0000000000000000000000000000000000000000;;		uc := ri.mapping(cUpper)
0000000000000000000000000000000000000000;;		lc := ri.mapping(cLower)
0000000000000000000000000000000000000000;;		ff := string(ri.FoldFull)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// addString sets the length of a string and adds it to the expansions array.
0000000000000000000000000000000000000000;;		addString := func(s string, b *byte) {
0000000000000000000000000000000000000000;;			if len(s) == 0 {
0000000000000000000000000000000000000000;;				// Zero-length mappings exist, but only for conditional casing,
0000000000000000000000000000000000000000;;				// which we are representing outside of this table.
0000000000000000000000000000000000000000;;				log.Fatalf("%U: has zero-length mapping.", ri.Rune)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*b <<= 3
0000000000000000000000000000000000000000;;			if s != orig {
0000000000000000000000000000000000000000;;				n := len(s)
0000000000000000000000000000000000000000;;				if n > 7 {
0000000000000000000000000000000000000000;;					log.Fatalf("%U: mapping larger than 7 (%d)", ri.Rune, n)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*b |= byte(n)
0000000000000000000000000000000000000000;;				exceptionData = append(exceptionData, s...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// byte 0:
0000000000000000000000000000000000000000;;		exceptionData = append(exceptionData, byte(ccc)|byte(len(ff)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// byte 1:
0000000000000000000000000000000000000000;;		p := len(exceptionData)
0000000000000000000000000000000000000000;;		exceptionData = append(exceptionData, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ff) > 7 { // May be zero-length.
0000000000000000000000000000000000000000;;			log.Fatalf("%U: fold string larger than 7 (%d)", ri.Rune, len(ff))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		exceptionData = append(exceptionData, ff...)
0000000000000000000000000000000000000000;;		ct := ri.CaseMode
0000000000000000000000000000000000000000;;		if ct != cLower {
0000000000000000000000000000000000000000;;			addString(lc, &exceptionData[p])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ct != cUpper {
0000000000000000000000000000000000000000;;			addString(uc, &exceptionData[p])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ct != cTitle {
0000000000000000000000000000000000000000;;			// If title is the same as upper, we set it to the original string so
0000000000000000000000000000000000000000;;			// that it will be marked as not present. This implies title case is
0000000000000000000000000000000000000000;;			// the same as upper case.
0000000000000000000000000000000000000000;;			if tc == uc {
0000000000000000000000000000000000000000;;				tc = orig
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addString(tc, &exceptionData[p])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sparseCompacter is a trie value block Compacter. There are many cases where
0000000000000000000000000000000000000000;;	// successive runes alternate between lower- and upper-case. This Compacter
0000000000000000000000000000000000000000;;	// exploits this by adding a special case type where the case value is obtained
0000000000000000000000000000000000000000;;	// from or-ing it with the least-significant bit of the rune, creating large
0000000000000000000000000000000000000000;;	// ranges of equal case values that compress well.
0000000000000000000000000000000000000000;;	type sparseCompacter struct {
0000000000000000000000000000000000000000;;		sparseBlocks  [][]uint16
0000000000000000000000000000000000000000;;		sparseOffsets []uint16
0000000000000000000000000000000000000000;;		sparseCount   int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeSparse returns the number of elements that compact block would contain
0000000000000000000000000000000000000000;;	// as well as the modified values.
0000000000000000000000000000000000000000;;	func makeSparse(vals []uint64) ([]uint16, int) {
0000000000000000000000000000000000000000;;		// Copy the values.
0000000000000000000000000000000000000000;;		values := make([]uint16, len(vals))
0000000000000000000000000000000000000000;;		for i, v := range vals {
0000000000000000000000000000000000000000;;			values[i] = uint16(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		alt := func(i int, v uint16) uint16 {
0000000000000000000000000000000000000000;;			if cm := info(v & fullCasedMask); cm == cUpper || cm == cLower {
0000000000000000000000000000000000000000;;				// Convert cLower or cUpper to cXORCase value, which has the form 11x.
0000000000000000000000000000000000000000;;				xor := v
0000000000000000000000000000000000000000;;				xor &^= 1
0000000000000000000000000000000000000000;;				xor |= uint16(i&1) ^ (v & 1)
0000000000000000000000000000000000000000;;				xor |= 0x4
0000000000000000000000000000000000000000;;				return xor
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var count int
0000000000000000000000000000000000000000;;		var previous uint16
0000000000000000000000000000000000000000;;		for i, v := range values {
0000000000000000000000000000000000000000;;			if v != 0 {
0000000000000000000000000000000000000000;;				// Try if the unmodified value is equal to the previous.
0000000000000000000000000000000000000000;;				if v == previous {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Try if the xor-ed value is equal to the previous value.
0000000000000000000000000000000000000000;;				a := alt(i, v)
0000000000000000000000000000000000000000;;				if a == previous {
0000000000000000000000000000000000000000;;					values[i] = a
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// This is a new value.
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Use the xor-ed value if it will be identical to the next value.
0000000000000000000000000000000000000000;;				if p := i + 1; p < len(values) && alt(p, values[p]) == a {
0000000000000000000000000000000000000000;;					values[i] = a
0000000000000000000000000000000000000000;;					v = a
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			previous = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return values, count
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sparseCompacter) Size(v []uint64) (int, bool) {
0000000000000000000000000000000000000000;;		_, n := makeSparse(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We limit using this method to having 16 entries.
0000000000000000000000000000000000000000;;		if n > 16 {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 2 + int(reflect.TypeOf(valueRange{}).Size())*n, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sparseCompacter) Store(v []uint64) uint32 {
0000000000000000000000000000000000000000;;		h := uint32(len(s.sparseOffsets))
0000000000000000000000000000000000000000;;		values, sz := makeSparse(v)
0000000000000000000000000000000000000000;;		s.sparseBlocks = append(s.sparseBlocks, values)
0000000000000000000000000000000000000000;;		s.sparseOffsets = append(s.sparseOffsets, uint16(s.sparseCount))
0000000000000000000000000000000000000000;;		s.sparseCount += sz
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sparseCompacter) Handler() string {
0000000000000000000000000000000000000000;;		// The sparse global variable and its lookup method is defined in gen_trieval.go.
0000000000000000000000000000000000000000;;		return "sparse.lookup"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sparseCompacter) Print(w io.Writer) (retErr error) {
0000000000000000000000000000000000000000;;		p := func(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;			_, err := fmt.Fprintf(w, format, args...)
0000000000000000000000000000000000000000;;			if retErr == nil && err != nil {
0000000000000000000000000000000000000000;;				retErr = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ls := len(s.sparseBlocks)
0000000000000000000000000000000000000000;;		if ls == len(s.sparseOffsets) {
0000000000000000000000000000000000000000;;			s.sparseOffsets = append(s.sparseOffsets, uint16(s.sparseCount))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p("// sparseOffsets: %d entries, %d bytes\n", ls+1, (ls+1)*2)
0000000000000000000000000000000000000000;;		p("var sparseOffsets = %#v\n\n", s.sparseOffsets)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns := s.sparseCount
0000000000000000000000000000000000000000;;		p("// sparseValues: %d entries, %d bytes\n", ns, ns*4)
0000000000000000000000000000000000000000;;		p("var sparseValues = [%d]valueRange {", ns)
0000000000000000000000000000000000000000;;		for i, values := range s.sparseBlocks {
0000000000000000000000000000000000000000;;			p("\n// Block %#x, offset %#x", i, s.sparseOffsets[i])
0000000000000000000000000000000000000000;;			var v uint16
0000000000000000000000000000000000000000;;			for i, nv := range values {
0000000000000000000000000000000000000000;;				if nv != v {
0000000000000000000000000000000000000000;;					if v != 0 {
0000000000000000000000000000000000000000;;						p(",hi:%#02x},", 0x80+i-1)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if nv != 0 {
0000000000000000000000000000000000000000;;						p("\n{value:%#04x,lo:%#02x", nv, 0x80+i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v = nv
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v != 0 {
0000000000000000000000000000000000000000;;				p(",hi:%#02x},", 0x80+len(values)-1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p("\n}\n\n")
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyProperties that properties of the runes that are relied upon in the
0000000000000000000000000000000000000000;;	// implementation. Each property is marked with an identifier that is referred
0000000000000000000000000000000000000000;;	// to in the places where it is used.
0000000000000000000000000000000000000000;;	func verifyProperties(chars []runeInfo) {
0000000000000000000000000000000000000000;;		for i, c := range chars {
0000000000000000000000000000000000000000;;			r := rune(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Rune properties.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// A.1: modifier never changes on lowercase. [ltLower]
0000000000000000000000000000000000000000;;			if c.CCC > 0 && unicode.ToLower(r) != r {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: non-starter changes when lowercased", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// A.2: properties of decompositions starting with I or J. [ltLower]
0000000000000000000000000000000000000000;;			d := norm.NFD.PropertiesString(string(r)).Decomposition()
0000000000000000000000000000000000000000;;			if len(d) > 0 {
0000000000000000000000000000000000000000;;				if d[0] == 'I' || d[0] == 'J' {
0000000000000000000000000000000000000000;;					// A.2.1: we expect at least an ASCII character and a modifier.
0000000000000000000000000000000000000000;;					if len(d) < 3 {
0000000000000000000000000000000000000000;;						log.Fatalf("%U: length of decomposition was %d; want >= 3", r, len(d))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// All subsequent runes are modifiers and all have the same CCC.
0000000000000000000000000000000000000000;;					runes := []rune(string(d[1:]))
0000000000000000000000000000000000000000;;					ccc := chars[runes[0]].CCC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for _, mr := range runes[1:] {
0000000000000000000000000000000000000000;;						mc := chars[mr]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// A.2.2: all modifiers have a CCC of Above or less.
0000000000000000000000000000000000000000;;						if ccc == 0 || ccc > above {
0000000000000000000000000000000000000000;;							log.Fatalf("%U: CCC of successive rune (%U) was %d; want (0,230]", r, mr, ccc)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// A.2.3: a sequence of modifiers all have the same CCC.
0000000000000000000000000000000000000000;;						if mc.CCC != ccc {
0000000000000000000000000000000000000000;;							log.Fatalf("%U: CCC of follow-up modifier (%U) was %d; want %d", r, mr, mc.CCC, ccc)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// A.2.4: for each trailing r, r in [0x300, 0x311] <=> CCC == Above.
0000000000000000000000000000000000000000;;						if (ccc == above) != (0x300 <= mr && mr <= 0x311) {
0000000000000000000000000000000000000000;;							log.Fatalf("%U: modifier %U in [U+0300, U+0311] != ccc(%U) == 230", r, mr, mr)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if i += len(string(mr)); i >= len(d) {
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// A.3: no U+0307 in decomposition of Soft-Dotted rune. [ltUpper]
0000000000000000000000000000000000000000;;			if unicode.Is(unicode.Soft_Dotted, r) && strings.Contains(string(d), "\u0307") {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: decomposition of soft-dotted rune may not contain U+0307", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// A.4: only rune U+0345 may be of CCC Iota_Subscript. [elUpper]
0000000000000000000000000000000000000000;;			if c.CCC == iotaSubscript && r != 0x0345 {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: only rune U+0345 may have CCC Iota_Subscript", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// A.5: soft-dotted runes do not have exceptions.
0000000000000000000000000000000000000000;;			if c.SoftDotted && c.entry&exceptionBit != 0 {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: soft-dotted has exception", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// A.6: Greek decomposition. [elUpper]
0000000000000000000000000000000000000000;;			if unicode.Is(unicode.Greek, r) {
0000000000000000000000000000000000000000;;				if b := norm.NFD.PropertiesString(string(r)).Decomposition(); b != nil {
0000000000000000000000000000000000000000;;					runes := []rune(string(b))
0000000000000000000000000000000000000000;;					// A.6.1: If a Greek rune decomposes and the first rune of the
0000000000000000000000000000000000000000;;					// decomposition is greater than U+00FF, the rune is always
0000000000000000000000000000000000000000;;					// great and not a modifier.
0000000000000000000000000000000000000000;;					if f := runes[0]; unicode.IsMark(f) || f > 0xFF && !unicode.Is(unicode.Greek, f) {
0000000000000000000000000000000000000000;;						log.Fatalf("%U: expeced first rune of Greek decomposition to be letter, found %U", r, f)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// A.6.2: Any follow-up rune in a Greek decomposition is a
0000000000000000000000000000000000000000;;					// modifier of which the first should be gobbled in
0000000000000000000000000000000000000000;;					// decomposition.
0000000000000000000000000000000000000000;;					for _, m := range runes[1:] {
0000000000000000000000000000000000000000;;						switch m {
0000000000000000000000000000000000000000;;						case 0x0313, 0x0314, 0x0301, 0x0300, 0x0306, 0x0342, 0x0308, 0x0304, 0x345:
0000000000000000000000000000000000000000;;						default:
0000000000000000000000000000000000000000;;							log.Fatalf("%U: modifier %U is outside of expeced Greek modifier set", r, m)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Breaking properties.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// B.1: all runes with CCC > 0 are of break type Extend.
0000000000000000000000000000000000000000;;			if c.CCC > 0 && c.BreakType != "Extend" {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: CCC == %d, but got break type %s; want Extend", r, c.CCC, c.BreakType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// B.2: all cased runes with c.CCC == 0 are of break type ALetter.
0000000000000000000000000000000000000000;;			if c.CCC == 0 && c.Cased && c.BreakType != "ALetter" {
0000000000000000000000000000000000000000;;				log.Fatalf("%U: cased, but got break type %s; want ALetter", r, c.BreakType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// B.3: letter category.
0000000000000000000000000000000000000000;;			if c.CCC == 0 && c.BreakCat != breakBreak && !c.CaseIgnorable {
0000000000000000000000000000000000000000;;				if c.BreakCat != breakLetter {
0000000000000000000000000000000000000000;;					log.Fatalf("%U: check for letter break type gave %d; want %d", r, c.BreakCat, breakLetter)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genTablesTest() {
0000000000000000000000000000000000000000;;		w := &bytes.Buffer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "var (")
0000000000000000000000000000000000000000;;		printProperties(w, "DerivedCoreProperties.txt", "Case_Ignorable", verifyIgnore)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We discard the output as we know we have perfect functions. We run them
0000000000000000000000000000000000000000;;		// just to verify the properties are correct.
0000000000000000000000000000000000000000;;		n := printProperties(ioutil.Discard, "DerivedCoreProperties.txt", "Cased", verifyCased)
0000000000000000000000000000000000000000;;		n += printProperties(ioutil.Discard, "DerivedCoreProperties.txt", "Lowercase", verifyLower)
0000000000000000000000000000000000000000;;		n += printProperties(ioutil.Discard, "DerivedCoreProperties.txt", "Uppercase", verifyUpper)
0000000000000000000000000000000000000000;;		if n > 0 {
0000000000000000000000000000000000000000;;			log.Fatalf("One of the discarded properties does not have a perfect filter.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// <code>; <lower> ; <title> ; <upper> ; (<condition_list> ;)?
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\tspecial = map[rune]struct{ toLower, toTitle, toUpper string }{")
0000000000000000000000000000000000000000;;		parse("SpecialCasing.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			// Skip conditional entries.
0000000000000000000000000000000000000000;;			if p.String(4) != "" {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r := p.Rune(0)
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "\t\t0x%04x: {%q, %q, %q},\n",
0000000000000000000000000000000000000000;;				r, string(p.Runes(1)), string(p.Runes(2)), string(p.Runes(3)))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fmt.Fprint(w, "\t}\n\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// <code>; <type>; <runes>
0000000000000000000000000000000000000000;;		table := map[rune]struct{ simple, full, special string }{}
0000000000000000000000000000000000000000;;		parse("CaseFolding.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			r := p.Rune(0)
0000000000000000000000000000000000000000;;			t := p.String(1)
0000000000000000000000000000000000000000;;			v := string(p.Runes(2))
0000000000000000000000000000000000000000;;			if t != "T" && v == string(unicode.ToLower(r)) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x := table[r]
0000000000000000000000000000000000000000;;			switch t {
0000000000000000000000000000000000000000;;			case "C":
0000000000000000000000000000000000000000;;				x.full = v
0000000000000000000000000000000000000000;;				x.simple = v
0000000000000000000000000000000000000000;;			case "S":
0000000000000000000000000000000000000000;;				x.simple = v
0000000000000000000000000000000000000000;;			case "F":
0000000000000000000000000000000000000000;;				x.full = v
0000000000000000000000000000000000000000;;			case "T":
0000000000000000000000000000000000000000;;				x.special = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			table[r] = x
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\tfoldMap = map[rune]struct{ simple, full, special string }{")
0000000000000000000000000000000000000000;;		for r := rune(0); r < 0x10FFFF; r++ {
0000000000000000000000000000000000000000;;			x, ok := table[r]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "\t\t0x%04x: {%q, %q, %q},\n", r, x.simple, x.full, x.special)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprint(w, "\t}\n\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Break property
0000000000000000000000000000000000000000;;		notBreak := map[rune]bool{}
0000000000000000000000000000000000000000;;		parse("auxiliary/WordBreakProperty.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			switch p.String(1) {
0000000000000000000000000000000000000000;;			case "Extend", "Format", "MidLetter", "MidNumLet", "Single_Quote",
0000000000000000000000000000000000000000;;				"ALetter", "Hebrew_Letter", "Numeric", "ExtendNumLet":
0000000000000000000000000000000000000000;;				notBreak[p.Rune(0)] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\tbreakProp = []struct{ lo, hi rune }{")
0000000000000000000000000000000000000000;;		inBreak := false
0000000000000000000000000000000000000000;;		for r := rune(0); r <= lastRuneForTesting; r++ {
0000000000000000000000000000000000000000;;			if isBreak := !notBreak[r]; isBreak != inBreak {
0000000000000000000000000000000000000000;;				if isBreak {
0000000000000000000000000000000000000000;;					fmt.Fprintf(w, "\t\t{0x%x, ", r)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Fprintf(w, "0x%x},\n", r-1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				inBreak = isBreak
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if inBreak {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "0x%x},\n", lastRuneForTesting)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprint(w, "\t}\n\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Word break test
0000000000000000000000000000000000000000;;		// Filter out all samples that do not contain cased characters.
0000000000000000000000000000000000000000;;		cased := map[rune]bool{}
0000000000000000000000000000000000000000;;		parse("DerivedCoreProperties.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			if p.String(1) == "Cased" {
0000000000000000000000000000000000000000;;				cased[p.Rune(0)] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\tbreakTest = []string{")
0000000000000000000000000000000000000000;;		parse("auxiliary/WordBreakTest.txt", func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			c := strings.Split(p.String(0), " ")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			const sep = '|'
0000000000000000000000000000000000000000;;			numCased := 0
0000000000000000000000000000000000000000;;			test := ""
0000000000000000000000000000000000000000;;			for ; len(c) >= 2; c = c[2:] {
0000000000000000000000000000000000000000;;				if c[0] == "" && test != "" {
0000000000000000000000000000000000000000;;					test += string(sep)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i, err := strconv.ParseUint(c[1], 16, 32)
0000000000000000000000000000000000000000;;				r := rune(i)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					log.Fatalf("Invalid rune %q.", c[1])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if r == sep {
0000000000000000000000000000000000000000;;					log.Fatalf("Separator %q not allowed in test data. Pick another one.", sep)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cased[r] {
0000000000000000000000000000000000000000;;					numCased++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				test += string(r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if numCased > 1 {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, "\t\t%q,\n", test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, "\t}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(w, ")")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gen.WriteGoFile("tables_test.go", "cases", w.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These functions are just used for verification that their definition have not
0000000000000000000000000000000000000000;;	// changed in the Unicode Standard.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyCased(r rune) bool {
0000000000000000000000000000000000000000;;		return verifyLower(r) || verifyUpper(r) || unicode.IsTitle(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyLower(r rune) bool {
0000000000000000000000000000000000000000;;		return unicode.IsLower(r) || unicode.Is(unicode.Other_Lowercase, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyUpper(r rune) bool {
0000000000000000000000000000000000000000;;		return unicode.IsUpper(r) || unicode.Is(unicode.Other_Uppercase, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifyIgnore is an approximation of the Case_Ignorable property using the
0000000000000000000000000000000000000000;;	// core unicode package. It is used to reduce the size of the test data.
0000000000000000000000000000000000000000;;	func verifyIgnore(r rune) bool {
0000000000000000000000000000000000000000;;		props := []*unicode.RangeTable{
0000000000000000000000000000000000000000;;			unicode.Mn,
0000000000000000000000000000000000000000;;			unicode.Me,
0000000000000000000000000000000000000000;;			unicode.Cf,
0000000000000000000000000000000000000000;;			unicode.Lm,
0000000000000000000000000000000000000000;;			unicode.Sk,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, p := range props {
0000000000000000000000000000000000000000;;			if unicode.Is(p, r) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printProperties prints tables of rune properties from the given UCD file.
0000000000000000000000000000000000000000;;	// A filter func f can be given to exclude certain values. A rune r will have
0000000000000000000000000000000000000000;;	// the indicated property if it is in the generated table or if f(r).
0000000000000000000000000000000000000000;;	func printProperties(w io.Writer, file, property string, f func(r rune) bool) int {
0000000000000000000000000000000000000000;;		verify := map[rune]bool{}
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		varNameParts := strings.Split(property, "_")
0000000000000000000000000000000000000000;;		varNameParts[0] = strings.ToLower(varNameParts[0])
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "\t%s = map[rune]bool{\n", strings.Join(varNameParts, ""))
0000000000000000000000000000000000000000;;		parse(file, func(p *ucd.Parser) {
0000000000000000000000000000000000000000;;			if p.String(1) == property {
0000000000000000000000000000000000000000;;				r := p.Rune(0)
0000000000000000000000000000000000000000;;				verify[r] = true
0000000000000000000000000000000000000000;;				if !f(r) {
0000000000000000000000000000000000000000;;					n++
0000000000000000000000000000000000000000;;					fmt.Fprintf(w, "\t\t0x%.4x: true,\n", r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fmt.Fprint(w, "\t}\n\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that f is correct, that is, it represents a subset of the property.
0000000000000000000000000000000000000000;;		for r := rune(0); r <= lastRuneForTesting; r++ {
0000000000000000000000000000000000000000;;			if !verify[r] && f(r) {
0000000000000000000000000000000000000000;;				log.Fatalf("Incorrect filter func for property %q.", property)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The newCaseTrie, sparseValues and sparseOffsets definitions below are
0000000000000000000000000000000000000000;;	// placeholders referred to by gen_trieval.go. The real definitions are
0000000000000000000000000000000000000000;;	// generated by this program and written to tables.go.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCaseTrie(int) int { return 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		sparseValues  [0]valueRange
0000000000000000000000000000000000000000;;		sparseOffsets [0]uint16
0000000000000000000000000000000000000000;;	)
