0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package cases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A context is used for iterating over source bytes, fetching case info and
0000000000000000000000000000000000000000;;	// writing to a destination buffer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Casing operations may need more than one rune of context to decide how a rune
0000000000000000000000000000000000000000;;	// should be cased. Casing implementations should call checkpoint on context
0000000000000000000000000000000000000000;;	// whenever it is known to be safe to return the runes processed so far.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is recommended for implementations to not allow for more than 30 case
0000000000000000000000000000000000000000;;	// ignorables as lookahead (analogous to the limit in norm) and to use state if
0000000000000000000000000000000000000000;;	// unbounded lookahead is needed for cased runes.
0000000000000000000000000000000000000000;;	type context struct {
0000000000000000000000000000000000000000;;		dst, src []byte
0000000000000000000000000000000000000000;;		atEOF    bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pDst int // pDst points past the last written rune in dst.
0000000000000000000000000000000000000000;;		pSrc int // pSrc points to the start of the currently scanned rune.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// checkpoints safe to return in Transform, where nDst <= pDst and nSrc <= pSrc.
0000000000000000000000000000000000000000;;		nDst, nSrc int
0000000000000000000000000000000000000000;;		err        error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sz   int  // size of current rune
0000000000000000000000000000000000000000;;		info info // case information of currently scanned rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// State preserved across calls to Transform.
0000000000000000000000000000000000000000;;		isMidWord bool // false if next cased letter needs to be title-cased.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *context) Reset() {
0000000000000000000000000000000000000000;;		c.isMidWord = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ret returns the return values for the Transform method. It checks whether
0000000000000000000000000000000000000000;;	// there were insufficient bytes in src to complete and introduces an error
0000000000000000000000000000000000000000;;	// accordingly, if necessary.
0000000000000000000000000000000000000000;;	func (c *context) ret() (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		if c.err != nil || c.nSrc == len(c.src) {
0000000000000000000000000000000000000000;;			return c.nDst, c.nSrc, c.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This point is only reached by mappers if there was no short destination
0000000000000000000000000000000000000000;;		// buffer. This means that the source buffer was exhausted and that c.sz was
0000000000000000000000000000000000000000;;		// set to 0 by next.
0000000000000000000000000000000000000000;;		if c.atEOF && c.pSrc == len(c.src) {
0000000000000000000000000000000000000000;;			return c.pDst, c.pSrc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.nDst, c.nSrc, transform.ErrShortSrc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkpoint sets the return value buffer points for Transform to the current
0000000000000000000000000000000000000000;;	// positions.
0000000000000000000000000000000000000000;;	func (c *context) checkpoint() {
0000000000000000000000000000000000000000;;		if c.err == nil {
0000000000000000000000000000000000000000;;			c.nDst, c.nSrc = c.pDst, c.pSrc+c.sz
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unreadRune causes the last rune read by next to be reread on the next
0000000000000000000000000000000000000000;;	// invocation of next. Only one unreadRune may be called after a call to next.
0000000000000000000000000000000000000000;;	func (c *context) unreadRune() {
0000000000000000000000000000000000000000;;		c.sz = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *context) next() bool {
0000000000000000000000000000000000000000;;		c.pSrc += c.sz
0000000000000000000000000000000000000000;;		if c.pSrc == len(c.src) || c.err != nil {
0000000000000000000000000000000000000000;;			c.info, c.sz = 0, 0
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, sz := trie.lookup(c.src[c.pSrc:])
0000000000000000000000000000000000000000;;		c.info, c.sz = info(v), sz
0000000000000000000000000000000000000000;;		if c.sz == 0 {
0000000000000000000000000000000000000000;;			if c.atEOF {
0000000000000000000000000000000000000000;;				// A zero size means we have an incomplete rune. If we are atEOF,
0000000000000000000000000000000000000000;;				// this means it is an illegal rune, which we will consume one
0000000000000000000000000000000000000000;;				// byte at a time.
0000000000000000000000000000000000000000;;				c.sz = 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c.err = transform.ErrShortSrc
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeBytes adds bytes to dst.
0000000000000000000000000000000000000000;;	func (c *context) writeBytes(b []byte) bool {
0000000000000000000000000000000000000000;;		if len(c.dst)-c.pDst < len(b) {
0000000000000000000000000000000000000000;;			c.err = transform.ErrShortDst
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This loop is faster than using copy.
0000000000000000000000000000000000000000;;		for _, ch := range b {
0000000000000000000000000000000000000000;;			c.dst[c.pDst] = ch
0000000000000000000000000000000000000000;;			c.pDst++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeString writes the given string to dst.
0000000000000000000000000000000000000000;;	func (c *context) writeString(s string) bool {
0000000000000000000000000000000000000000;;		if len(c.dst)-c.pDst < len(s) {
0000000000000000000000000000000000000000;;			c.err = transform.ErrShortDst
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This loop is faster than using copy.
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			c.dst[c.pDst] = s[i]
0000000000000000000000000000000000000000;;			c.pDst++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copy writes the current rune to dst.
0000000000000000000000000000000000000000;;	func (c *context) copy() bool {
0000000000000000000000000000000000000000;;		return c.writeBytes(c.src[c.pSrc : c.pSrc+c.sz])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyXOR copies the current rune to dst and modifies it by applying the XOR
0000000000000000000000000000000000000000;;	// pattern of the case info. It is the responsibility of the caller to ensure
0000000000000000000000000000000000000000;;	// that this is a rune with a XOR pattern defined.
0000000000000000000000000000000000000000;;	func (c *context) copyXOR() bool {
0000000000000000000000000000000000000000;;		if !c.copy() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.info&xorIndexBit == 0 {
0000000000000000000000000000000000000000;;			// Fast path for 6-bit XOR pattern, which covers most cases.
0000000000000000000000000000000000000000;;			c.dst[c.pDst-1] ^= byte(c.info >> xorShift)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Interpret XOR bits as an index.
0000000000000000000000000000000000000000;;			// TODO: test performance for unrolling this loop. Verify that we have
0000000000000000000000000000000000000000;;			// at least two bytes and at most three.
0000000000000000000000000000000000000000;;			idx := c.info >> xorShift
0000000000000000000000000000000000000000;;			for p := c.pDst - 1; ; p-- {
0000000000000000000000000000000000000000;;				c.dst[p] ^= xorData[idx]
0000000000000000000000000000000000000000;;				idx--
0000000000000000000000000000000000000000;;				if xorData[idx] == 0 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasPrefix returns true if src[pSrc:] starts with the given string.
0000000000000000000000000000000000000000;;	func (c *context) hasPrefix(s string) bool {
0000000000000000000000000000000000000000;;		b := c.src[c.pSrc:]
0000000000000000000000000000000000000000;;		if len(b) < len(s) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, c := range b[:len(s)] {
0000000000000000000000000000000000000000;;			if c != s[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// caseType returns an info with only the case bits, normalized to either
0000000000000000000000000000000000000000;;	// cLower, cUpper, cTitle or cUncased.
0000000000000000000000000000000000000000;;	func (c *context) caseType() info {
0000000000000000000000000000000000000000;;		cm := c.info & 0x7
0000000000000000000000000000000000000000;;		if cm < 4 {
0000000000000000000000000000000000000000;;			return cm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cm >= cXORCase {
0000000000000000000000000000000000000000;;			// xor the last bit of the rune with the case type bits.
0000000000000000000000000000000000000000;;			b := c.src[c.pSrc+c.sz-1]
0000000000000000000000000000000000000000;;			return info(b&1) ^ cm&0x3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cm == cIgnorableCased {
0000000000000000000000000000000000000000;;			return cLower
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cUncased
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lower writes the lowercase version of the current rune to dst.
0000000000000000000000000000000000000000;;	func lower(c *context) bool {
0000000000000000000000000000000000000000;;		ct := c.caseType()
0000000000000000000000000000000000000000;;		if c.info&hasMappingMask == 0 || ct == cLower {
0000000000000000000000000000000000000000;;			return c.copy()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.info&exceptionBit == 0 {
0000000000000000000000000000000000000000;;			return c.copyXOR()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e := exceptions[c.info>>exceptionShift:]
0000000000000000000000000000000000000000;;		offset := 2 + e[0]&lengthMask // size of header + fold string
0000000000000000000000000000000000000000;;		if nLower := (e[1] >> lengthBits) & lengthMask; nLower != noChange {
0000000000000000000000000000000000000000;;			return c.writeString(e[offset : offset+nLower])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.copy()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// upper writes the uppercase version of the current rune to dst.
0000000000000000000000000000000000000000;;	func upper(c *context) bool {
0000000000000000000000000000000000000000;;		ct := c.caseType()
0000000000000000000000000000000000000000;;		if c.info&hasMappingMask == 0 || ct == cUpper {
0000000000000000000000000000000000000000;;			return c.copy()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.info&exceptionBit == 0 {
0000000000000000000000000000000000000000;;			return c.copyXOR()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e := exceptions[c.info>>exceptionShift:]
0000000000000000000000000000000000000000;;		offset := 2 + e[0]&lengthMask // size of header + fold string
0000000000000000000000000000000000000000;;		// Get length of first special case mapping.
0000000000000000000000000000000000000000;;		n := (e[1] >> lengthBits) & lengthMask
0000000000000000000000000000000000000000;;		if ct == cTitle {
0000000000000000000000000000000000000000;;			// The first special case mapping is for lower. Set n to the second.
0000000000000000000000000000000000000000;;			if n == noChange {
0000000000000000000000000000000000000000;;				n = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n, e = e[1]&lengthMask, e[n:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != noChange {
0000000000000000000000000000000000000000;;			return c.writeString(e[offset : offset+n])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.copy()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// title writes the title case version of the current rune to dst.
0000000000000000000000000000000000000000;;	func title(c *context) bool {
0000000000000000000000000000000000000000;;		ct := c.caseType()
0000000000000000000000000000000000000000;;		if c.info&hasMappingMask == 0 || ct == cTitle {
0000000000000000000000000000000000000000;;			return c.copy()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.info&exceptionBit == 0 {
0000000000000000000000000000000000000000;;			if ct == cLower {
0000000000000000000000000000000000000000;;				return c.copyXOR()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return c.copy()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get the exception data.
0000000000000000000000000000000000000000;;		e := exceptions[c.info>>exceptionShift:]
0000000000000000000000000000000000000000;;		offset := 2 + e[0]&lengthMask // size of header + fold string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nFirst := (e[1] >> lengthBits) & lengthMask
0000000000000000000000000000000000000000;;		if nTitle := e[1] & lengthMask; nTitle != noChange {
0000000000000000000000000000000000000000;;			if nFirst != noChange {
0000000000000000000000000000000000000000;;				e = e[nFirst:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return c.writeString(e[offset : offset+nTitle])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ct == cLower && nFirst != noChange {
0000000000000000000000000000000000000000;;			// Use the uppercase version instead.
0000000000000000000000000000000000000000;;			return c.writeString(e[offset : offset+nFirst])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Already in correct case.
0000000000000000000000000000000000000000;;		return c.copy()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// foldFull writes the foldFull version of the current rune to dst.
0000000000000000000000000000000000000000;;	func foldFull(c *context) bool {
0000000000000000000000000000000000000000;;		if c.info&hasMappingMask == 0 {
0000000000000000000000000000000000000000;;			return c.copy()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ct := c.caseType()
0000000000000000000000000000000000000000;;		if c.info&exceptionBit == 0 {
0000000000000000000000000000000000000000;;			if ct != cLower || c.info&inverseFoldBit != 0 {
0000000000000000000000000000000000000000;;				return c.copyXOR()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return c.copy()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e := exceptions[c.info>>exceptionShift:]
0000000000000000000000000000000000000000;;		n := e[0] & lengthMask
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			if ct == cLower {
0000000000000000000000000000000000000000;;				return c.copy()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n = (e[1] >> lengthBits) & lengthMask
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.writeString(e[2 : 2+n])
0000000000000000000000000000000000000000;;	}
