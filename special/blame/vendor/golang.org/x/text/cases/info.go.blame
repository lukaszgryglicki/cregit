0000000000000000000000000000000000000000;;	// Copyright 2015 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package cases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c info) cccVal() info {
0000000000000000000000000000000000000000;;		if c&exceptionBit != 0 {
0000000000000000000000000000000000000000;;			return info(exceptions[c>>exceptionShift]) & cccMask
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c & cccMask
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c info) cccType() info {
0000000000000000000000000000000000000000;;		ccc := c.cccVal()
0000000000000000000000000000000000000000;;		if ccc <= cccZero {
0000000000000000000000000000000000000000;;			return cccZero
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ccc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Implement full Unicode breaking algorithm:
0000000000000000000000000000000000000000;;	// 1) Implement breaking in separate package.
0000000000000000000000000000000000000000;;	// 2) Use the breaker here.
0000000000000000000000000000000000000000;;	// 3) Compare table size and performance of using the more generic breaker.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that we can extend the current algorithm to be much more accurate. This
0000000000000000000000000000000000000000;;	// only makes sense, though, if the performance and/or space penalty of using
0000000000000000000000000000000000000000;;	// the generic breaker is big. Extra data will only be needed for non-cased
0000000000000000000000000000000000000000;;	// runes, which means there are sufficient bits left in the caseType.
0000000000000000000000000000000000000000;;	// Also note that the standard breaking algorithm doesn't always make sense
0000000000000000000000000000000000000000;;	// for title casing. For example, a4a -> A4a, but a"4a -> A"4A (where " stands
0000000000000000000000000000000000000000;;	// for modifier \u0308).
0000000000000000000000000000000000000000;;	// ICU prohibits breaking in such cases as well.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For the purpose of title casing we use an approximation of the Unicode Word
0000000000000000000000000000000000000000;;	// Breaking algorithm defined in Annex #29:
0000000000000000000000000000000000000000;;	// http://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For our approximation, we group the Word Break types into the following
0000000000000000000000000000000000000000;;	// categories, with associated rules:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1) Letter:
0000000000000000000000000000000000000000;;	//    ALetter, Hebrew_Letter, Numeric, ExtendNumLet, Extend.
0000000000000000000000000000000000000000;;	//    Rule: Never break between consecutive runes of this category.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 2) Mid:
0000000000000000000000000000000000000000;;	//    Format, MidLetter, MidNumLet, Single_Quote.
0000000000000000000000000000000000000000;;	//    (Cf. case-ignorable: MidLetter, MidNumLet or cat is Mn, Me, Cf, Lm or Sk).
0000000000000000000000000000000000000000;;	//    Rule: Don't break between Letter and Mid, but break between two Mids.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 3) Break:
0000000000000000000000000000000000000000;;	//    Any other category, including NewLine, CR, LF and Double_Quote. These
0000000000000000000000000000000000000000;;	//    categories should always result in a break between two cased letters.
0000000000000000000000000000000000000000;;	//    Rule: Always break.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note 1: the Katakana and MidNum categories can, in esoteric cases, result in
0000000000000000000000000000000000000000;;	// preventing a break between two cased letters. For now we will ignore this
0000000000000000000000000000000000000000;;	// (e.g. [ALetter] [ExtendNumLet] [Katakana] [ExtendNumLet] [ALetter] and
0000000000000000000000000000000000000000;;	// [ALetter] [Numeric] [MidNum] [Numeric] [ALetter].)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note 2: the rule for Mid is very approximate, but works in most cases. To
0000000000000000000000000000000000000000;;	// improve, we could store the categories in the trie value and use a FA to
0000000000000000000000000000000000000000;;	// manage breaks. See TODO comment above.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note 3: according to the spec, it is possible for the Extend category to
0000000000000000000000000000000000000000;;	// introduce breaks between other categories grouped in Letter. However, this
0000000000000000000000000000000000000000;;	// is undesirable for our purposes. ICU prevents breaks in such cases as well.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isBreak returns whether this rune should introduce a break.
0000000000000000000000000000000000000000;;	func (c info) isBreak() bool {
0000000000000000000000000000000000000000;;		return c.cccVal() == cccBreak
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isLetter returns whether the rune is of break type ALetter, Hebrew_Letter,
0000000000000000000000000000000000000000;;	// Numeric, ExtendNumLet, or Extend.
0000000000000000000000000000000000000000;;	func (c info) isLetter() bool {
0000000000000000000000000000000000000000;;		ccc := c.cccVal()
0000000000000000000000000000000000000000;;		if ccc == cccZero {
0000000000000000000000000000000000000000;;			return !c.isCaseIgnorable()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ccc != cccBreak
0000000000000000000000000000000000000000;;	}
