0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package cases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains the definitions of case mappings for all supported
0000000000000000000000000000000000000000;;	// languages. The rules for the language-specific tailorings were taken and
0000000000000000000000000000000000000000;;	// modified from the CLDR transform definitions in common/transforms.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/text/language"
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;		"golang.org/x/text/unicode/norm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A mapFunc takes a context set to the current rune and writes the mapped
0000000000000000000000000000000000000000;;	// version to the same context. It may advance the context to the next rune. It
0000000000000000000000000000000000000000;;	// returns whether a checkpoint is possible: whether the pDst bytes written to
0000000000000000000000000000000000000000;;	// dst so far won't need changing as we see more source bytes.
0000000000000000000000000000000000000000;;	type mapFunc func(*context) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxIgnorable defines the maximum number of ignorables to consider for
0000000000000000000000000000000000000000;;	// lookahead operations.
0000000000000000000000000000000000000000;;	const maxIgnorable = 30
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supported lists the language tags for which we have tailorings.
0000000000000000000000000000000000000000;;	const supported = "und af az el lt nl tr"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		tags := []language.Tag{}
0000000000000000000000000000000000000000;;		for _, s := range strings.Split(supported, " ") {
0000000000000000000000000000000000000000;;			tags = append(tags, language.MustParse(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matcher = language.NewMatcher(tags)
0000000000000000000000000000000000000000;;		Supported = language.NewCoverage(tags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		matcher language.Matcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Supported language.Coverage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We keep the following lists separate, instead of having a single per-
0000000000000000000000000000000000000000;;		// language struct, to give the compiler a chance to remove unused code.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Some uppercase mappers are stateless, so we can precompute the
0000000000000000000000000000000000000000;;		// Transformers and save a bit on runtime allocations.
0000000000000000000000000000000000000000;;		upperFunc = []mapFunc{
0000000000000000000000000000000000000000;;			nil,              // und
0000000000000000000000000000000000000000;;			nil,              // af
0000000000000000000000000000000000000000;;			aztrUpper(upper), // az
0000000000000000000000000000000000000000;;			elUpper,          // el
0000000000000000000000000000000000000000;;			ltUpper(upper),   // lt
0000000000000000000000000000000000000000;;			nil,              // nl
0000000000000000000000000000000000000000;;			aztrUpper(upper), // tr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		undUpper transform.Transformer = &undUpperCaser{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lowerFunc = []mapFunc{
0000000000000000000000000000000000000000;;			lower,     // und
0000000000000000000000000000000000000000;;			lower,     // af
0000000000000000000000000000000000000000;;			aztrLower, // az
0000000000000000000000000000000000000000;;			lower,     // el
0000000000000000000000000000000000000000;;			ltLower,   // lt
0000000000000000000000000000000000000000;;			lower,     // nl
0000000000000000000000000000000000000000;;			aztrLower, // tr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		titleInfos = []struct {
0000000000000000000000000000000000000000;;			title, lower mapFunc
0000000000000000000000000000000000000000;;			rewrite      func(*context)
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{title, lower, nil},                // und
0000000000000000000000000000000000000000;;			{title, lower, afnlRewrite},        // af
0000000000000000000000000000000000000000;;			{aztrUpper(title), aztrLower, nil}, // az
0000000000000000000000000000000000000000;;			{title, lower, nil},                // el
0000000000000000000000000000000000000000;;			{ltUpper(title), ltLower, nil},     // lt
0000000000000000000000000000000000000000;;			{nlTitle, lower, afnlRewrite},      // nl
0000000000000000000000000000000000000000;;			{aztrUpper(title), aztrLower, nil}, // tr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeUpper(t language.Tag, o options) transform.Transformer {
0000000000000000000000000000000000000000;;		_, i, _ := matcher.Match(t)
0000000000000000000000000000000000000000;;		f := upperFunc[i]
0000000000000000000000000000000000000000;;		if f == nil {
0000000000000000000000000000000000000000;;			return undUpper
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &simpleCaser{f: f}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeLower(t language.Tag, o options) transform.Transformer {
0000000000000000000000000000000000000000;;		_, i, _ := matcher.Match(t)
0000000000000000000000000000000000000000;;		f := lowerFunc[i]
0000000000000000000000000000000000000000;;		if o.noFinalSigma {
0000000000000000000000000000000000000000;;			return &simpleCaser{f: f}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &lowerCaser{
0000000000000000000000000000000000000000;;			first:   f,
0000000000000000000000000000000000000000;;			midWord: finalSigma(f),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeTitle(t language.Tag, o options) transform.Transformer {
0000000000000000000000000000000000000000;;		_, i, _ := matcher.Match(t)
0000000000000000000000000000000000000000;;		x := &titleInfos[i]
0000000000000000000000000000000000000000;;		lower := x.lower
0000000000000000000000000000000000000000;;		if o.noLower {
0000000000000000000000000000000000000000;;			lower = (*context).copy
0000000000000000000000000000000000000000;;		} else if !o.noFinalSigma {
0000000000000000000000000000000000000000;;			lower = finalSigma(lower)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &titleCaser{
0000000000000000000000000000000000000000;;			title:   x.title,
0000000000000000000000000000000000000000;;			lower:   lower,
0000000000000000000000000000000000000000;;			rewrite: x.rewrite,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: consider a similar special case for the fast majority lower case. This
0000000000000000000000000000000000000000;;	// is a bit more involved so will require some more precise benchmarking to
0000000000000000000000000000000000000000;;	// justify it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type undUpperCaser struct{ transform.NopResetter }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// undUpperCaser implements the Transformer interface for doing an upper case
0000000000000000000000000000000000000000;;	// mapping for the root locale (und). It eliminates the need for an allocation
0000000000000000000000000000000000000000;;	// as it prevents escaping by not using function pointers.
0000000000000000000000000000000000000000;;	func (t *undUpperCaser) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		c := context{dst: dst, src: src, atEOF: atEOF}
0000000000000000000000000000000000000000;;		for c.next() {
0000000000000000000000000000000000000000;;			upper(&c)
0000000000000000000000000000000000000000;;			c.checkpoint()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.ret()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type simpleCaser struct {
0000000000000000000000000000000000000000;;		context
0000000000000000000000000000000000000000;;		f mapFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// simpleCaser implements the Transformer interface for doing a case operation
0000000000000000000000000000000000000000;;	// on a rune-by-rune basis.
0000000000000000000000000000000000000000;;	func (t *simpleCaser) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		t.context = context{dst: dst, src: src, atEOF: atEOF}
0000000000000000000000000000000000000000;;		c := &t.context
0000000000000000000000000000000000000000;;		for c.next() && t.f(c) {
0000000000000000000000000000000000000000;;			c.checkpoint()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.ret()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lowerCaser implements the Transformer interface. The default Unicode lower
0000000000000000000000000000000000000000;;	// casing requires different treatment for the first and subsequent characters
0000000000000000000000000000000000000000;;	// of a word, most notably to handle the Greek final Sigma.
0000000000000000000000000000000000000000;;	type lowerCaser struct {
0000000000000000000000000000000000000000;;		context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		first, midWord mapFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *lowerCaser) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		t.context = context{dst: dst, src: src, atEOF: atEOF}
0000000000000000000000000000000000000000;;		c := &t.context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for isInterWord := true; c.next(); {
0000000000000000000000000000000000000000;;			if isInterWord {
0000000000000000000000000000000000000000;;				if c.info.isCased() {
0000000000000000000000000000000000000000;;					if !t.first(c) {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					isInterWord = false
0000000000000000000000000000000000000000;;				} else if !c.copy() {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if c.info.isNotCasedAndNotCaseIgnorable() {
0000000000000000000000000000000000000000;;					if !c.copy() {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					isInterWord = true
0000000000000000000000000000000000000000;;				} else if !t.midWord(c) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.checkpoint()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.ret()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// titleCaser implements the Transformer interface. Title casing algorithms
0000000000000000000000000000000000000000;;	// distinguish between the first letter of a word and subsequent letters of the
0000000000000000000000000000000000000000;;	// same word. It uses state to avoid requiring a potentially infinite lookahead.
0000000000000000000000000000000000000000;;	type titleCaser struct {
0000000000000000000000000000000000000000;;		context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rune mappings used by the actual casing algorithms.
0000000000000000000000000000000000000000;;		title, lower mapFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rewrite func(*context)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform implements the standard Unicode title case algorithm as defined in
0000000000000000000000000000000000000000;;	// Chapter 3 of The Unicode Standard:
0000000000000000000000000000000000000000;;	// toTitlecase(X): Find the word boundaries in X according to Unicode Standard
0000000000000000000000000000000000000000;;	// Annex #29, "Unicode Text Segmentation." For each word boundary, find the
0000000000000000000000000000000000000000;;	// first cased character F following the word boundary. If F exists, map F to
0000000000000000000000000000000000000000;;	// Titlecase_Mapping(F); then map all characters C between F and the following
0000000000000000000000000000000000000000;;	// word boundary to Lowercase_Mapping(C).
0000000000000000000000000000000000000000;;	func (t *titleCaser) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		t.context = context{dst: dst, src: src, atEOF: atEOF, isMidWord: t.isMidWord}
0000000000000000000000000000000000000000;;		c := &t.context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !c.next() {
0000000000000000000000000000000000000000;;			return c.ret()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			p := c.info
0000000000000000000000000000000000000000;;			if t.rewrite != nil {
0000000000000000000000000000000000000000;;				t.rewrite(c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			wasMid := p.isCaseIgnorableAndNonBreakStarter()
0000000000000000000000000000000000000000;;			// Break out of this loop on failure to ensure we do not modify the
0000000000000000000000000000000000000000;;			// state incorrectly.
0000000000000000000000000000000000000000;;			if p.isCased() && !p.isCaseIgnorableAndNotCased() {
0000000000000000000000000000000000000000;;				if !c.isMidWord {
0000000000000000000000000000000000000000;;					if !t.title(c) {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					c.isMidWord = true
0000000000000000000000000000000000000000;;				} else if !t.lower(c) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if !c.copy() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: make this an "else if" if we can prove that no rune that does
0000000000000000000000000000000000000000;;			// not match the first condition of the if statement can be a break.
0000000000000000000000000000000000000000;;			if p.isBreak() {
0000000000000000000000000000000000000000;;				c.isMidWord = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// As we save the state of the transformer, it is safe to call
0000000000000000000000000000000000000000;;			// checkpoint after any successful write.
0000000000000000000000000000000000000000;;			c.checkpoint()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !c.next() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if wasMid && c.info.isCaseIgnorableAndNonBreakStarter() {
0000000000000000000000000000000000000000;;				c.isMidWord = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.ret()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// finalSigma adds Greek final Sigma handing to another casing function. It
0000000000000000000000000000000000000000;;	// determines whether a lowercased sigma should be σ or ς, by looking ahead for
0000000000000000000000000000000000000000;;	// case-ignorables and a cased letters.
0000000000000000000000000000000000000000;;	func finalSigma(f mapFunc) mapFunc {
0000000000000000000000000000000000000000;;		return func(c *context) bool {
0000000000000000000000000000000000000000;;			// ::NFD();
0000000000000000000000000000000000000000;;			// # 03A3; 03C2; 03A3; 03A3; Final_Sigma; # GREEK CAPITAL LETTER SIGMA
0000000000000000000000000000000000000000;;			// Σ } [:case-ignorable:]* [:cased:] → σ;
0000000000000000000000000000000000000000;;			// [:cased:] [:case-ignorable:]* { Σ → ς;
0000000000000000000000000000000000000000;;			// ::Any-Lower;
0000000000000000000000000000000000000000;;			// ::NFC();
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !c.hasPrefix("Σ") {
0000000000000000000000000000000000000000;;				return f(c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p := c.pDst
0000000000000000000000000000000000000000;;			c.writeString("ς")
0000000000000000000000000000000000000000;;			// We need to do one more iteration after maxIgnorable, as a cased
0000000000000000000000000000000000000000;;			// letter is not an ignorable and may modify the result.
0000000000000000000000000000000000000000;;			for i := 0; i < maxIgnorable+1; i++ {
0000000000000000000000000000000000000000;;				if !c.next() {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !c.info.isCaseIgnorable() {
0000000000000000000000000000000000000000;;					if c.info.isCased() {
0000000000000000000000000000000000000000;;						// p+1 is guaranteed to be in bounds: if writing ς was
0000000000000000000000000000000000000000;;						// successful, p+1 will contain the second byte of ς. If not,
0000000000000000000000000000000000000000;;						// this function will have returned after c.next returned false.
0000000000000000000000000000000000000000;;						c.dst[p+1]++ // ς → σ
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					c.unreadRune()
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// A case ignorable may also introduce a word break, so we may need
0000000000000000000000000000000000000000;;				// to continue searching even after detecting a break.
0000000000000000000000000000000000000000;;				c.isMidWord = c.isMidWord && !c.info.isBreak()
0000000000000000000000000000000000000000;;				c.copy()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// elUpper implements Greek upper casing, which entails removing a predefined
0000000000000000000000000000000000000000;;	// set of non-blocked modifiers. Note that these accents should not be removed
0000000000000000000000000000000000000000;;	// for title casing!
0000000000000000000000000000000000000000;;	// Example: "Οδός" -> "ΟΔΟΣ".
0000000000000000000000000000000000000000;;	func elUpper(c *context) bool {
0000000000000000000000000000000000000000;;		// From CLDR:
0000000000000000000000000000000000000000;;		// [:Greek:] [^[:ccc=Not_Reordered:][:ccc=Above:]]*? { [\u0313\u0314\u0301\u0300\u0306\u0342\u0308\u0304] → ;
0000000000000000000000000000000000000000;;		// [:Greek:] [^[:ccc=Not_Reordered:][:ccc=Iota_Subscript:]]*? { \u0345 → ;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r, _ := utf8.DecodeRune(c.src[c.pSrc:])
0000000000000000000000000000000000000000;;		oldPDst := c.pDst
0000000000000000000000000000000000000000;;		if !upper(c) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !unicode.Is(unicode.Greek, r) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		// Take the properties of the uppercased rune that is already written to the
0000000000000000000000000000000000000000;;		// destination. This saves us the trouble of having to uppercase the
0000000000000000000000000000000000000000;;		// decomposed rune again.
0000000000000000000000000000000000000000;;		if b := norm.NFD.Properties(c.dst[oldPDst:]).Decomposition(); b != nil {
0000000000000000000000000000000000000000;;			// Restore the destination position and process the decomposed rune.
0000000000000000000000000000000000000000;;			r, sz := utf8.DecodeRune(b)
0000000000000000000000000000000000000000;;			if r <= 0xFF { // See A.6.1
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.pDst = oldPDst
0000000000000000000000000000000000000000;;			// Insert the first rune and ignore the modifiers. See A.6.2.
0000000000000000000000000000000000000000;;			c.writeBytes(b[:sz])
0000000000000000000000000000000000000000;;			i = len(b[sz:]) / 2 // Greek modifiers are always of length 2.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ; i < maxIgnorable && c.next(); i++ {
0000000000000000000000000000000000000000;;			switch r, _ := utf8.DecodeRune(c.src[c.pSrc:]); r {
0000000000000000000000000000000000000000;;			// Above and Iota Subscript
0000000000000000000000000000000000000000;;			case 0x0300, // U+0300 COMBINING GRAVE ACCENT
0000000000000000000000000000000000000000;;				0x0301, // U+0301 COMBINING ACUTE ACCENT
0000000000000000000000000000000000000000;;				0x0304, // U+0304 COMBINING MACRON
0000000000000000000000000000000000000000;;				0x0306, // U+0306 COMBINING BREVE
0000000000000000000000000000000000000000;;				0x0308, // U+0308 COMBINING DIAERESIS
0000000000000000000000000000000000000000;;				0x0313, // U+0313 COMBINING COMMA ABOVE
0000000000000000000000000000000000000000;;				0x0314, // U+0314 COMBINING REVERSED COMMA ABOVE
0000000000000000000000000000000000000000;;				0x0342, // U+0342 COMBINING GREEK PERISPOMENI
0000000000000000000000000000000000000000;;				0x0345: // U+0345 COMBINING GREEK YPOGEGRAMMENI
0000000000000000000000000000000000000000;;				// No-op. Gobble the modifier.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				switch v, _ := trie.lookup(c.src[c.pSrc:]); info(v).cccType() {
0000000000000000000000000000000000000000;;				case cccZero:
0000000000000000000000000000000000000000;;					c.unreadRune()
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// We don't need to test for IotaSubscript as the only rune that
0000000000000000000000000000000000000000;;				// qualifies (U+0345) was already excluded in the switch statement
0000000000000000000000000000000000000000;;				// above. See A.4.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case cccAbove:
0000000000000000000000000000000000000000;;					return c.copy()
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// Some other modifier. We're still allowed to gobble Greek
0000000000000000000000000000000000000000;;					// modifiers after this.
0000000000000000000000000000000000000000;;					c.copy()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i == maxIgnorable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ltLower(c *context) bool {
0000000000000000000000000000000000000000;;		// From CLDR:
0000000000000000000000000000000000000000;;		// # Introduce an explicit dot above when lowercasing capital I's and J's
0000000000000000000000000000000000000000;;		// # whenever there are more accents above.
0000000000000000000000000000000000000000;;		// # (of the accents used in Lithuanian: grave, acute, tilde above, and ogonek)
0000000000000000000000000000000000000000;;		// # 0049; 0069 0307; 0049; 0049; lt More_Above; # LATIN CAPITAL LETTER I
0000000000000000000000000000000000000000;;		// # 004A; 006A 0307; 004A; 004A; lt More_Above; # LATIN CAPITAL LETTER J
0000000000000000000000000000000000000000;;		// # 012E; 012F 0307; 012E; 012E; lt More_Above; # LATIN CAPITAL LETTER I WITH OGONEK
0000000000000000000000000000000000000000;;		// # 00CC; 0069 0307 0300; 00CC; 00CC; lt; # LATIN CAPITAL LETTER I WITH GRAVE
0000000000000000000000000000000000000000;;		// # 00CD; 0069 0307 0301; 00CD; 00CD; lt; # LATIN CAPITAL LETTER I WITH ACUTE
0000000000000000000000000000000000000000;;		// # 0128; 0069 0307 0303; 0128; 0128; lt; # LATIN CAPITAL LETTER I WITH TILDE
0000000000000000000000000000000000000000;;		// ::NFD();
0000000000000000000000000000000000000000;;		// I } [^[:ccc=Not_Reordered:][:ccc=Above:]]* [:ccc=Above:] → i \u0307;
0000000000000000000000000000000000000000;;		// J } [^[:ccc=Not_Reordered:][:ccc=Above:]]* [:ccc=Above:] → j \u0307;
0000000000000000000000000000000000000000;;		// Į } [^[:ccc=Not_Reordered:][:ccc=Above:]]* [:ccc=Above:] → į \u0307;
0000000000000000000000000000000000000000;;		// Ì → i \u0307 \u0300;
0000000000000000000000000000000000000000;;		// Í → i \u0307 \u0301;
0000000000000000000000000000000000000000;;		// Ĩ → i \u0307 \u0303;
0000000000000000000000000000000000000000;;		// ::Any-Lower();
0000000000000000000000000000000000000000;;		// ::NFC();
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		if r := c.src[c.pSrc]; r < utf8.RuneSelf {
0000000000000000000000000000000000000000;;			lower(c)
0000000000000000000000000000000000000000;;			if r != 'I' && r != 'J' {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p := norm.NFD.Properties(c.src[c.pSrc:])
0000000000000000000000000000000000000000;;			if d := p.Decomposition(); len(d) >= 3 && (d[0] == 'I' || d[0] == 'J') {
0000000000000000000000000000000000000000;;				// UTF-8 optimization: the decomposition will only have an above
0000000000000000000000000000000000000000;;				// modifier if the last rune of the decomposition is in [U+300-U+311].
0000000000000000000000000000000000000000;;				// In all other cases, a decomposition starting with I is always
0000000000000000000000000000000000000000;;				// an I followed by modifiers that are not cased themselves. See A.2.
0000000000000000000000000000000000000000;;				if d[1] == 0xCC && d[2] <= 0x91 { // A.2.4.
0000000000000000000000000000000000000000;;					if !c.writeBytes(d[:1]) {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					c.dst[c.pDst-1] += 'a' - 'A' // lower
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Assumption: modifier never changes on lowercase. See A.1.
0000000000000000000000000000000000000000;;					// Assumption: all modifiers added have CCC = Above. See A.2.3.
0000000000000000000000000000000000000000;;					return c.writeString("\u0307") && c.writeBytes(d[1:])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// In all other cases the additional modifiers will have a CCC
0000000000000000000000000000000000000000;;				// that is less than 230 (Above). We will insert the U+0307, if
0000000000000000000000000000000000000000;;				// needed, after these modifiers so that a string in FCD form
0000000000000000000000000000000000000000;;				// will remain so. See A.2.2.
0000000000000000000000000000000000000000;;				lower(c)
0000000000000000000000000000000000000000;;				i = 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return lower(c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ; i < maxIgnorable && c.next(); i++ {
0000000000000000000000000000000000000000;;			switch c.info.cccType() {
0000000000000000000000000000000000000000;;			case cccZero:
0000000000000000000000000000000000000000;;				c.unreadRune()
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case cccAbove:
0000000000000000000000000000000000000000;;				return c.writeString("\u0307") && c.copy() // See A.1.
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				c.copy() // See A.1.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i == maxIgnorable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ltUpper(f mapFunc) mapFunc {
0000000000000000000000000000000000000000;;		return func(c *context) bool {
0000000000000000000000000000000000000000;;			// From CLDR:
0000000000000000000000000000000000000000;;			// ::NFD();
0000000000000000000000000000000000000000;;			// [:Soft_Dotted:] [^[:ccc=Not_Reordered:][:ccc=Above:]]* { \u0307 → ;
0000000000000000000000000000000000000000;;			// ::Any-Upper();
0000000000000000000000000000000000000000;;			// ::NFC();
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: See A.5. A soft-dotted rune never has an exception. This would
0000000000000000000000000000000000000000;;			// allow us to overload the exception bit and encode this property in
0000000000000000000000000000000000000000;;			// info. Need to measure performance impact of this.
0000000000000000000000000000000000000000;;			r, _ := utf8.DecodeRune(c.src[c.pSrc:])
0000000000000000000000000000000000000000;;			oldPDst := c.pDst
0000000000000000000000000000000000000000;;			if !f(c) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !unicode.Is(unicode.Soft_Dotted, r) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We don't need to do an NFD normalization, as a soft-dotted rune never
0000000000000000000000000000000000000000;;			// contains U+0307. See A.3.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i := 0
0000000000000000000000000000000000000000;;			for ; i < maxIgnorable && c.next(); i++ {
0000000000000000000000000000000000000000;;				switch c.info.cccType() {
0000000000000000000000000000000000000000;;				case cccZero:
0000000000000000000000000000000000000000;;					c.unreadRune()
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				case cccAbove:
0000000000000000000000000000000000000000;;					if c.hasPrefix("\u0307") {
0000000000000000000000000000000000000000;;						// We don't do a full NFC, but rather combine runes for
0000000000000000000000000000000000000000;;						// some of the common cases. (Returning NFC or
0000000000000000000000000000000000000000;;						// preserving normal form is neither a requirement nor
0000000000000000000000000000000000000000;;						// a possibility anyway).
0000000000000000000000000000000000000000;;						if !c.next() {
0000000000000000000000000000000000000000;;							return false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if c.dst[oldPDst] == 'I' && c.pDst == oldPDst+1 && c.src[c.pSrc] == 0xcc {
0000000000000000000000000000000000000000;;							s := ""
0000000000000000000000000000000000000000;;							switch c.src[c.pSrc+1] {
0000000000000000000000000000000000000000;;							case 0x80: // U+0300 COMBINING GRAVE ACCENT
0000000000000000000000000000000000000000;;								s = "\u00cc" // U+00CC LATIN CAPITAL LETTER I WITH GRAVE
0000000000000000000000000000000000000000;;							case 0x81: // U+0301 COMBINING ACUTE ACCENT
0000000000000000000000000000000000000000;;								s = "\u00cd" // U+00CD LATIN CAPITAL LETTER I WITH ACUTE
0000000000000000000000000000000000000000;;							case 0x83: // U+0303 COMBINING TILDE
0000000000000000000000000000000000000000;;								s = "\u0128" // U+0128 LATIN CAPITAL LETTER I WITH TILDE
0000000000000000000000000000000000000000;;							case 0x88: // U+0308 COMBINING DIAERESIS
0000000000000000000000000000000000000000;;								s = "\u00cf" // U+00CF LATIN CAPITAL LETTER I WITH DIAERESIS
0000000000000000000000000000000000000000;;							default:
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if s != "" {
0000000000000000000000000000000000000000;;								c.pDst = oldPDst
0000000000000000000000000000000000000000;;								return c.writeString(s)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return c.copy()
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					c.copy()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return i == maxIgnorable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func aztrUpper(f mapFunc) mapFunc {
0000000000000000000000000000000000000000;;		return func(c *context) bool {
0000000000000000000000000000000000000000;;			// i→İ;
0000000000000000000000000000000000000000;;			if c.src[c.pSrc] == 'i' {
0000000000000000000000000000000000000000;;				return c.writeString("İ")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return f(c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func aztrLower(c *context) (done bool) {
0000000000000000000000000000000000000000;;		// From CLDR:
0000000000000000000000000000000000000000;;		// # I and i-dotless; I-dot and i are case pairs in Turkish and Azeri
0000000000000000000000000000000000000000;;		// # 0130; 0069; 0130; 0130; tr; # LATIN CAPITAL LETTER I WITH DOT ABOVE
0000000000000000000000000000000000000000;;		// İ→i;
0000000000000000000000000000000000000000;;		// # When lowercasing, remove dot_above in the sequence I + dot_above, which will turn into i.
0000000000000000000000000000000000000000;;		// # This matches the behavior of the canonically equivalent I-dot_above
0000000000000000000000000000000000000000;;		// # 0307; ; 0307; 0307; tr After_I; # COMBINING DOT ABOVE
0000000000000000000000000000000000000000;;		// # When lowercasing, unless an I is before a dot_above, it turns into a dotless i.
0000000000000000000000000000000000000000;;		// # 0049; 0131; 0049; 0049; tr Not_Before_Dot; # LATIN CAPITAL LETTER I
0000000000000000000000000000000000000000;;		// I([^[:ccc=Not_Reordered:][:ccc=Above:]]*)\u0307 → i$1 ;
0000000000000000000000000000000000000000;;		// I→ı ;
0000000000000000000000000000000000000000;;		// ::Any-Lower();
0000000000000000000000000000000000000000;;		if c.hasPrefix("\u0130") { // İ
0000000000000000000000000000000000000000;;			return c.writeString("i")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.src[c.pSrc] != 'I' {
0000000000000000000000000000000000000000;;			return lower(c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We ignore the lower-case I for now, but insert it later when we know
0000000000000000000000000000000000000000;;		// which form we need.
0000000000000000000000000000000000000000;;		start := c.pSrc + c.sz
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		// We check for up to n ignorables before \u0307. As \u0307 is an
0000000000000000000000000000000000000000;;		// ignorable as well, n is maxIgnorable-1.
0000000000000000000000000000000000000000;;		for ; i < maxIgnorable && c.next(); i++ {
0000000000000000000000000000000000000000;;			switch c.info.cccType() {
0000000000000000000000000000000000000000;;			case cccAbove:
0000000000000000000000000000000000000000;;				if c.hasPrefix("\u0307") {
0000000000000000000000000000000000000000;;					return c.writeString("i") && c.writeBytes(c.src[start:c.pSrc]) // ignore U+0307
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				done = true
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			case cccZero:
0000000000000000000000000000000000000000;;				c.unreadRune()
0000000000000000000000000000000000000000;;				done = true
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// We'll write this rune after we know which starter to use.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i == maxIgnorable {
0000000000000000000000000000000000000000;;			done = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.writeString("ı") && c.writeBytes(c.src[start:c.pSrc+c.sz]) && done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nlTitle(c *context) bool {
0000000000000000000000000000000000000000;;		// From CLDR:
0000000000000000000000000000000000000000;;		// # Special titlecasing for Dutch initial "ij".
0000000000000000000000000000000000000000;;		// ::Any-Title();
0000000000000000000000000000000000000000;;		// # Fix up Ij at the beginning of a "word" (per Any-Title, notUAX #29)
0000000000000000000000000000000000000000;;		// [:^WB=ALetter:] [:WB=Extend:]* [[:WB=MidLetter:][:WB=MidNumLet:]]? { Ij } → IJ ;
0000000000000000000000000000000000000000;;		if c.src[c.pSrc] != 'I' && c.src[c.pSrc] != 'i' {
0000000000000000000000000000000000000000;;			return title(c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !c.writeString("I") || !c.next() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.src[c.pSrc] == 'j' || c.src[c.pSrc] == 'J' {
0000000000000000000000000000000000000000;;			return c.writeString("J")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.unreadRune()
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Not part of CLDR, but see http://unicode.org/cldr/trac/ticket/7078.
0000000000000000000000000000000000000000;;	func afnlRewrite(c *context) {
0000000000000000000000000000000000000000;;		if c.hasPrefix("'") || c.hasPrefix("’") {
0000000000000000000000000000000000000000;;			c.isMidWord = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
