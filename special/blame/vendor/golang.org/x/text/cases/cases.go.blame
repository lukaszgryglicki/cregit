0000000000000000000000000000000000000000;;	// Copyright 2014 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	//go:generate go run gen.go gen_trieval.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package cases provides general and language-specific case mappers.
0000000000000000000000000000000000000000;;	package cases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"golang.org/x/text/language"
0000000000000000000000000000000000000000;;		"golang.org/x/text/transform"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// References:
0000000000000000000000000000000000000000;;	// - Unicode Reference Manual Chapter 3.13, 4.2, and 5.18.
0000000000000000000000000000000000000000;;	// - http://www.unicode.org/reports/tr29/
0000000000000000000000000000000000000000;;	// - http://www.unicode.org/Public/6.3.0/ucd/CaseFolding.txt
0000000000000000000000000000000000000000;;	// - http://www.unicode.org/Public/6.3.0/ucd/SpecialCasing.txt
0000000000000000000000000000000000000000;;	// - http://www.unicode.org/Public/6.3.0/ucd/DerivedCoreProperties.txt
0000000000000000000000000000000000000000;;	// - http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakProperty.txt
0000000000000000000000000000000000000000;;	// - http://www.unicode.org/Public/6.3.0/ucd/auxiliary/WordBreakTest.txt
0000000000000000000000000000000000000000;;	// - http://userguide.icu-project.org/transforms/casemappings
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO:
0000000000000000000000000000000000000000;;	// - Case folding
0000000000000000000000000000000000000000;;	// - Wide and Narrow?
0000000000000000000000000000000000000000;;	// - Segmenter option for title casing.
0000000000000000000000000000000000000000;;	// - ASCII fast paths
0000000000000000000000000000000000000000;;	// - Encode Soft-Dotted property within trie somehow.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Caser transforms given input to a certain case. It implements
0000000000000000000000000000000000000000;;	// transform.Transformer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A Caser may be stateful and should therefore not be shared between
0000000000000000000000000000000000000000;;	// goroutines.
0000000000000000000000000000000000000000;;	type Caser struct {
0000000000000000000000000000000000000000;;		t transform.Transformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns a new byte slice with the result of converting b to the case
0000000000000000000000000000000000000000;;	// form implemented by c.
0000000000000000000000000000000000000000;;	func (c Caser) Bytes(b []byte) []byte {
0000000000000000000000000000000000000000;;		b, _, _ = transform.Bytes(c.t, b)
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string with the result of transforming s to the case form
0000000000000000000000000000000000000000;;	// implemented by c.
0000000000000000000000000000000000000000;;	func (c Caser) String(s string) string {
0000000000000000000000000000000000000000;;		s, _, _ = transform.String(c.t, s)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset resets the Caser to be reused for new input after a previous call to
0000000000000000000000000000000000000000;;	// Transform.
0000000000000000000000000000000000000000;;	func (c Caser) Reset() { c.t.Reset() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transform implements the Transformer interface and transforms the given input
0000000000000000000000000000000000000000;;	// to the case form implemented by c.
0000000000000000000000000000000000000000;;	func (c Caser) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
0000000000000000000000000000000000000000;;		return c.t.Transform(dst, src, atEOF)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Upper returns a Caser for language-specific uppercasing.
0000000000000000000000000000000000000000;;	func Upper(t language.Tag, opts ...Option) Caser {
0000000000000000000000000000000000000000;;		return Caser{makeUpper(t, getOpts(opts...))}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lower returns a Caser for language-specific lowercasing.
0000000000000000000000000000000000000000;;	func Lower(t language.Tag, opts ...Option) Caser {
0000000000000000000000000000000000000000;;		return Caser{makeLower(t, getOpts(opts...))}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Title returns a Caser for language-specific title casing. It uses an
0000000000000000000000000000000000000000;;	// approximation of the default Unicode Word Break algorithm.
0000000000000000000000000000000000000000;;	func Title(t language.Tag, opts ...Option) Caser {
0000000000000000000000000000000000000000;;		return Caser{makeTitle(t, getOpts(opts...))}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fold returns a Caser that implements Unicode case folding. The returned Caser
0000000000000000000000000000000000000000;;	// is stateless and safe to use concurrently by multiple goroutines.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Case folding does not normalize the input and may not preserve a normal form.
0000000000000000000000000000000000000000;;	// Use the collate or search package for more convenient and linguistically
0000000000000000000000000000000000000000;;	// sound comparisons.  Use unicode/precis for string comparisons where security
0000000000000000000000000000000000000000;;	// aspects are a concern.
0000000000000000000000000000000000000000;;	func Fold(opts ...Option) Caser {
0000000000000000000000000000000000000000;;		return Caser{makeFold(getOpts(opts...))}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Option is used to modify the behavior of a Caser.
0000000000000000000000000000000000000000;;	type Option func(o *options)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// NoLower disables the lowercasing of non-leading letters for a title
0000000000000000000000000000000000000000;;		// caser.
0000000000000000000000000000000000000000;;		NoLower Option = noLower
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compact omits mappings in case folding for characters that would grow the
0000000000000000000000000000000000000000;;		// input. (Unimplemented.)
0000000000000000000000000000000000000000;;		Compact Option = compact
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: option to preserve a normal form, if applicable?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type options struct {
0000000000000000000000000000000000000000;;		noLower bool
0000000000000000000000000000000000000000;;		simple  bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: segmenter, max ignorable, alternative versions, etc.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noFinalSigma bool // Only used for testing.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getOpts(o ...Option) (res options) {
0000000000000000000000000000000000000000;;		for _, f := range o {
0000000000000000000000000000000000000000;;			f(&res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func noLower(o *options) {
0000000000000000000000000000000000000000;;		o.noLower = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func compact(o *options) {
0000000000000000000000000000000000000000;;		o.simple = true
0000000000000000000000000000000000000000;;	}
