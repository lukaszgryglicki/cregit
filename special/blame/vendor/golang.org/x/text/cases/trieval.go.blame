0000000000000000000000000000000000000000;;	// This file was generated by go generate; DO NOT EDIT
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package cases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains definitions for interpreting the trie value of the case
0000000000000000000000000000000000000000;;	// trie generated by "go run gen*.go". It is shared by both the generator
0000000000000000000000000000000000000000;;	// program and the resultant package. Sharing is achieved by the generator
0000000000000000000000000000000000000000;;	// copying gen_trieval.go to trieval.go and changing what's above this comment.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// info holds case information for a single rune. It is the value returned
0000000000000000000000000000000000000000;;	// by a trie lookup. Most mapping information can be stored in a single 16-bit
0000000000000000000000000000000000000000;;	// value. If not, for example when a rune is mapped to multiple runes, the value
0000000000000000000000000000000000000000;;	// stores some basic case data and an index into an array with additional data.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The per-rune values have the following format:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   if (exception) {
0000000000000000000000000000000000000000;;	//     15..5  unsigned exception index
0000000000000000000000000000000000000000;;	//         4  unused
0000000000000000000000000000000000000000;;	//   } else {
0000000000000000000000000000000000000000;;	//     15..8  XOR pattern or index to XOR pattern for case mapping
0000000000000000000000000000000000000000;;	//            Only 13..8 are used for XOR patterns.
0000000000000000000000000000000000000000;;	//         7  inverseFold (fold to upper, not to lower)
0000000000000000000000000000000000000000;;	//         6  index: interpret the XOR pattern as an index
0000000000000000000000000000000000000000;;	//      5..4  CCC: zero (normal or break), above or other
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//      3  exception: interpret this value as an exception index
0000000000000000000000000000000000000000;;	//         (TODO: is this bit necessary? Probably implied from case mode.)
0000000000000000000000000000000000000000;;	//   2..0  case mode
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For the non-exceptional cases, a rune must be either uncased, lowercase or
0000000000000000000000000000000000000000;;	// uppercase. If the rune is cased, the XOR pattern maps either a lowercase
0000000000000000000000000000000000000000;;	// rune to uppercase or an uppercase rune to lowercase (applied to the 10
0000000000000000000000000000000000000000;;	// least-significant bits of the rune).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the definitions below for a more detailed description of the various
0000000000000000000000000000000000000000;;	// bits.
0000000000000000000000000000000000000000;;	type info uint16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		casedMask      = 0x0003
0000000000000000000000000000000000000000;;		fullCasedMask  = 0x0007
0000000000000000000000000000000000000000;;		ignorableMask  = 0x0006
0000000000000000000000000000000000000000;;		ignorableValue = 0x0004
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inverseFoldBit = 1 << 7
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		exceptionBit     = 1 << 3
0000000000000000000000000000000000000000;;		exceptionShift   = 5
0000000000000000000000000000000000000000;;		numExceptionBits = 11
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xorIndexBit = 1 << 6
0000000000000000000000000000000000000000;;		xorShift    = 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There is no mapping if all xor bits and the exception bit are zero.
0000000000000000000000000000000000000000;;		hasMappingMask = 0xffc0 | exceptionBit
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The case mode bits encodes the case type of a rune. This includes uncased,
0000000000000000000000000000000000000000;;	// title, upper and lower case and case ignorable. (For a definition of these
0000000000000000000000000000000000000000;;	// terms see Chapter 3 of The Unicode Standard Core Specification.) In some rare
0000000000000000000000000000000000000000;;	// cases, a rune can be both cased and case-ignorable. This is encoded by
0000000000000000000000000000000000000000;;	// cIgnorableCased. A rune of this type is always lower case. Some runes are
0000000000000000000000000000000000000000;;	// cased while not having a mapping.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A common pattern for scripts in the Unicode standard is for upper and lower
0000000000000000000000000000000000000000;;	// case runes to alternate for increasing rune values (e.g. the accented Latin
0000000000000000000000000000000000000000;;	// ranges starting from U+0100 and U+1E00 among others and some Cyrillic
0000000000000000000000000000000000000000;;	// characters). We use this property by defining a cXORCase mode, where the case
0000000000000000000000000000000000000000;;	// mode (always upper or lower case) is derived from the rune value. As the XOR
0000000000000000000000000000000000000000;;	// pattern for case mappings is often identical for successive runes, using
0000000000000000000000000000000000000000;;	// cXORCase can result in large series of identical trie values. This, in turn,
0000000000000000000000000000000000000000;;	// allows us to better compress the trie blocks.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cUncased          info = iota // 000
0000000000000000000000000000000000000000;;		cTitle                        // 001
0000000000000000000000000000000000000000;;		cLower                        // 010
0000000000000000000000000000000000000000;;		cUpper                        // 011
0000000000000000000000000000000000000000;;		cIgnorableUncased             // 100
0000000000000000000000000000000000000000;;		cIgnorableCased               // 101 // lower case if mappings exist
0000000000000000000000000000000000000000;;		cXORCase                      // 11x // case is cLower | ((rune&1) ^ x)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxCaseMode = cUpper
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c info) isCased() bool {
0000000000000000000000000000000000000000;;		return c&casedMask != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c info) isCaseIgnorable() bool {
0000000000000000000000000000000000000000;;		return c&ignorableMask == ignorableValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c info) isCaseIgnorableAndNonBreakStarter() bool {
0000000000000000000000000000000000000000;;		return c&(fullCasedMask|cccMask) == (ignorableValue | cccZero)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c info) isNotCasedAndNotCaseIgnorable() bool {
0000000000000000000000000000000000000000;;		return c&fullCasedMask == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c info) isCaseIgnorableAndNotCased() bool {
0000000000000000000000000000000000000000;;		return c&fullCasedMask == cIgnorableUncased
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The case mapping implementation will need to know about various Canonical
0000000000000000000000000000000000000000;;	// Combining Class (CCC) values. We encode two of these in the trie value:
0000000000000000000000000000000000000000;;	// cccZero (0) and cccAbove (230). If the value is cccOther, it means that
0000000000000000000000000000000000000000;;	// CCC(r) > 0, but not 230. A value of cccBreak means that CCC(r) == 0 and that
0000000000000000000000000000000000000000;;	// the rune also has the break category Break (see below).
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cccBreak info = iota << 4
0000000000000000000000000000000000000000;;		cccZero
0000000000000000000000000000000000000000;;		cccAbove
0000000000000000000000000000000000000000;;		cccOther
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cccMask = cccBreak | cccZero | cccAbove | cccOther
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		starter       = 0
0000000000000000000000000000000000000000;;		above         = 230
0000000000000000000000000000000000000000;;		iotaSubscript = 240
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The exceptions slice holds data that does not fit in a normal info entry.
0000000000000000000000000000000000000000;;	// The entry is pointed to by the exception index in an entry. It has the
0000000000000000000000000000000000000000;;	// following format:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Header
0000000000000000000000000000000000000000;;	// byte 0:
0000000000000000000000000000000000000000;;	//  7..6  unused
0000000000000000000000000000000000000000;;	//  5..4  CCC type (same bits as entry)
0000000000000000000000000000000000000000;;	//     3  unused
0000000000000000000000000000000000000000;;	//  2..0  length of fold
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// byte 1:
0000000000000000000000000000000000000000;;	//   7..6  unused
0000000000000000000000000000000000000000;;	//   5..3  length of 1st mapping of case type
0000000000000000000000000000000000000000;;	//   2..0  length of 2nd mapping of case type
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   case     1st    2nd
0000000000000000000000000000000000000000;;	//   lower -> upper, title
0000000000000000000000000000000000000000;;	//   upper -> lower, title
0000000000000000000000000000000000000000;;	//   title -> lower, upper
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Lengths with the value 0x7 indicate no value and implies no change.
0000000000000000000000000000000000000000;;	// A length of 0 indicates a mapping to zero-length string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Body bytes:
0000000000000000000000000000000000000000;;	//   case folding bytes
0000000000000000000000000000000000000000;;	//   lowercase mapping bytes
0000000000000000000000000000000000000000;;	//   uppercase mapping bytes
0000000000000000000000000000000000000000;;	//   titlecase mapping bytes
0000000000000000000000000000000000000000;;	//   closure mapping bytes (for NFKC_Casefold). (TODO)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Fallbacks:
0000000000000000000000000000000000000000;;	//   missing fold  -> lower
0000000000000000000000000000000000000000;;	//   missing title -> upper
0000000000000000000000000000000000000000;;	//   all missing   -> original rune
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// exceptions starts with a dummy byte to enforce that there is no zero index
0000000000000000000000000000000000000000;;	// value.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		lengthMask = 0x07
0000000000000000000000000000000000000000;;		lengthBits = 3
0000000000000000000000000000000000000000;;		noChange   = 0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// References to generated trie.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var trie = newCaseTrie(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var sparse = sparseBlocks{
0000000000000000000000000000000000000000;;		values:  sparseValues[:],
0000000000000000000000000000000000000000;;		offsets: sparseOffsets[:],
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sparse block lookup code.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// valueRange is an entry in a sparse block.
0000000000000000000000000000000000000000;;	type valueRange struct {
0000000000000000000000000000000000000000;;		value  uint16
0000000000000000000000000000000000000000;;		lo, hi byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sparseBlocks struct {
0000000000000000000000000000000000000000;;		values  []valueRange
0000000000000000000000000000000000000000;;		offsets []uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lookup returns the value from values block n for byte b using binary search.
0000000000000000000000000000000000000000;;	func (s *sparseBlocks) lookup(n uint32, b byte) uint16 {
0000000000000000000000000000000000000000;;		lo := s.offsets[n]
0000000000000000000000000000000000000000;;		hi := s.offsets[n+1]
0000000000000000000000000000000000000000;;		for lo < hi {
0000000000000000000000000000000000000000;;			m := lo + (hi-lo)/2
0000000000000000000000000000000000000000;;			r := s.values[m]
0000000000000000000000000000000000000000;;			if r.lo <= b && b <= r.hi {
0000000000000000000000000000000000000000;;				return r.value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b < r.lo {
0000000000000000000000000000000000000000;;				hi = m
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				lo = m + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lastRuneForTesting is the last rune used for testing. Everything after this
0000000000000000000000000000000000000000;;	// is boring.
0000000000000000000000000000000000000000;;	const lastRuneForTesting = rune(0x1FFFF)
