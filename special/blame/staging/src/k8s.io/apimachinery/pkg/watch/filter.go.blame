0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package watch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterFunc should take an event, possibly modify it in some way, and return
0000000000000000000000000000000000000000;;	// the modified event. If the event should be ignored, then return keep=false.
0000000000000000000000000000000000000000;;	type FilterFunc func(in Event) (out Event, keep bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter passes all events through f before allowing them to pass on.
0000000000000000000000000000000000000000;;	// Putting a filter on a watch, as an unavoidable side-effect due to the way
0000000000000000000000000000000000000000;;	// go channels work, effectively causes the watch's event channel to have its
0000000000000000000000000000000000000000;;	// queue length increased by one.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// WARNING: filter has a fatal flaw, in that it can't properly update the
0000000000000000000000000000000000000000;;	// Type field (Add/Modified/Deleted) to reflect items beginning to pass the
0000000000000000000000000000000000000000;;	// filter when they previously didn't.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func Filter(w Interface, f FilterFunc) Interface {
0000000000000000000000000000000000000000;;		fw := &filteredWatch{
0000000000000000000000000000000000000000;;			incoming: w,
0000000000000000000000000000000000000000;;			result:   make(chan Event),
0000000000000000000000000000000000000000;;			f:        f,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go fw.loop()
0000000000000000000000000000000000000000;;		return fw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type filteredWatch struct {
0000000000000000000000000000000000000000;;		incoming Interface
0000000000000000000000000000000000000000;;		result   chan Event
0000000000000000000000000000000000000000;;		f        FilterFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResultChan returns a channel which will receive filtered events.
0000000000000000000000000000000000000000;;	func (fw *filteredWatch) ResultChan() <-chan Event {
0000000000000000000000000000000000000000;;		return fw.result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops the upstream watch, which will eventually stop this watch.
0000000000000000000000000000000000000000;;	func (fw *filteredWatch) Stop() {
0000000000000000000000000000000000000000;;		fw.incoming.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loop waits for new values, filters them, and resends them.
0000000000000000000000000000000000000000;;	func (fw *filteredWatch) loop() {
0000000000000000000000000000000000000000;;		defer close(fw.result)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			event, ok := <-fw.incoming.ResultChan()
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			filtered, keep := fw.f(event)
0000000000000000000000000000000000000000;;			if keep {
0000000000000000000000000000000000000000;;				fw.result <- filtered
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recorder records all events that are sent from the watch until it is closed.
0000000000000000000000000000000000000000;;	type Recorder struct {
0000000000000000000000000000000000000000;;		Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock   sync.Mutex
0000000000000000000000000000000000000000;;		events []Event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Interface = &Recorder{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRecorder wraps an Interface and records any changes sent across it.
0000000000000000000000000000000000000000;;	func NewRecorder(w Interface) *Recorder {
0000000000000000000000000000000000000000;;		r := &Recorder{}
0000000000000000000000000000000000000000;;		r.Interface = Filter(w, r.record)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// record is a FilterFunc and tracks each received event.
0000000000000000000000000000000000000000;;	func (r *Recorder) record(in Event) (Event, bool) {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;		r.events = append(r.events, in)
0000000000000000000000000000000000000000;;		return in, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Events returns a copy of the events sent across this recorder.
0000000000000000000000000000000000000000;;	func (r *Recorder) Events() []Event {
0000000000000000000000000000000000000000;;		r.lock.Lock()
0000000000000000000000000000000000000000;;		defer r.lock.Unlock()
0000000000000000000000000000000000000000;;		copied := make([]Event, len(r.events))
0000000000000000000000000000000000000000;;		copy(copied, r.events)
0000000000000000000000000000000000000000;;		return copied
0000000000000000000000000000000000000000;;	}
