0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package watch_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		. "k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type myType struct {
0000000000000000000000000000000000000000;;		ID    string
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *myType) GetObjectKind() schema.ObjectKind { return schema.EmptyObjectKind }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBroadcaster(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []Event{
0000000000000000000000000000000000000000;;			{Type: Added, Object: &myType{"foo", "hello world 1"}},
0000000000000000000000000000000000000000;;			{Type: Added, Object: &myType{"bar", "hello world 2"}},
0000000000000000000000000000000000000000;;			{Type: Modified, Object: &myType{"foo", "goodbye world 3"}},
0000000000000000000000000000000000000000;;			{Type: Deleted, Object: &myType{"bar", "hello world 4"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The broadcaster we're testing
0000000000000000000000000000000000000000;;		m := NewBroadcaster(0, WaitIfChannelFull)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add a bunch of watchers
0000000000000000000000000000000000000000;;		const testWatchers = 2
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(testWatchers)
0000000000000000000000000000000000000000;;		for i := 0; i < testWatchers; i++ {
0000000000000000000000000000000000000000;;			// Verify that each watcher gets the events in the correct order
0000000000000000000000000000000000000000;;			go func(watcher int, w Interface) {
0000000000000000000000000000000000000000;;				tableLine := 0
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					event, ok := <-w.ResultChan()
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if e, a := table[tableLine], event; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;						t.Errorf("Watcher %v, line %v: Expected (%v, %#v), got (%v, %#v)",
0000000000000000000000000000000000000000;;							watcher, tableLine, e.Type, e.Object, a.Type, a.Object)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						t.Logf("Got (%v, %#v)", event.Type, event.Object)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					tableLine++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				wg.Done()
0000000000000000000000000000000000000000;;			}(i, m.Watch())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, item := range table {
0000000000000000000000000000000000000000;;			t.Logf("Sending %v", i)
0000000000000000000000000000000000000000;;			m.Action(item.Type, item.Object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.Shutdown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBroadcasterWatcherClose(t *testing.T) {
0000000000000000000000000000000000000000;;		m := NewBroadcaster(0, WaitIfChannelFull)
0000000000000000000000000000000000000000;;		w := m.Watch()
0000000000000000000000000000000000000000;;		w2 := m.Watch()
0000000000000000000000000000000000000000;;		w.Stop()
0000000000000000000000000000000000000000;;		m.Shutdown()
0000000000000000000000000000000000000000;;		if _, open := <-w.ResultChan(); open {
0000000000000000000000000000000000000000;;			t.Errorf("Stop didn't work?")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, open := <-w2.ResultChan(); open {
0000000000000000000000000000000000000000;;			t.Errorf("Shutdown didn't work?")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Extra stops don't hurt things
0000000000000000000000000000000000000000;;		w.Stop()
0000000000000000000000000000000000000000;;		w2.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBroadcasterWatcherStopDeadlock(t *testing.T) {
0000000000000000000000000000000000000000;;		done := make(chan bool)
0000000000000000000000000000000000000000;;		m := NewBroadcaster(0, WaitIfChannelFull)
0000000000000000000000000000000000000000;;		go func(w0, w1 Interface) {
0000000000000000000000000000000000000000;;			// We know Broadcaster is in the distribute loop once one watcher receives
0000000000000000000000000000000000000000;;			// an event. Stop the other watcher while distribute is trying to
0000000000000000000000000000000000000000;;			// send to it.
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-w0.ResultChan():
0000000000000000000000000000000000000000;;				w1.Stop()
0000000000000000000000000000000000000000;;			case <-w1.ResultChan():
0000000000000000000000000000000000000000;;				w0.Stop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(done)
0000000000000000000000000000000000000000;;		}(m.Watch(), m.Watch())
0000000000000000000000000000000000000000;;		m.Action(Added, &myType{})
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Error("timeout: deadlocked")
0000000000000000000000000000000000000000;;		case <-done:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.Shutdown()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBroadcasterDropIfChannelFull(t *testing.T) {
0000000000000000000000000000000000000000;;		m := NewBroadcaster(1, DropIfChannelFull)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		event1 := Event{Type: Added, Object: &myType{"foo", "hello world 1"}}
0000000000000000000000000000000000000000;;		event2 := Event{Type: Added, Object: &myType{"bar", "hello world 2"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add a couple watchers
0000000000000000000000000000000000000000;;		watches := make([]Interface, 2)
0000000000000000000000000000000000000000;;		for i := range watches {
0000000000000000000000000000000000000000;;			watches[i] = m.Watch()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send a couple events before closing the broadcast channel.
0000000000000000000000000000000000000000;;		t.Log("Sending event 1")
0000000000000000000000000000000000000000;;		m.Action(event1.Type, event1.Object)
0000000000000000000000000000000000000000;;		t.Log("Sending event 2")
0000000000000000000000000000000000000000;;		m.Action(event2.Type, event2.Object)
0000000000000000000000000000000000000000;;		m.Shutdown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pull events from the queue.
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(len(watches))
0000000000000000000000000000000000000000;;		for i := range watches {
0000000000000000000000000000000000000000;;			// Verify that each watcher only gets the first event because its watch
0000000000000000000000000000000000000000;;			// queue of length one was full from the first one.
0000000000000000000000000000000000000000;;			go func(watcher int, w Interface) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				e1, ok := <-w.ResultChan()
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Errorf("Watcher %v failed to retrieve first event.", watcher)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := event1, e1; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;					t.Errorf("Watcher %v: Expected (%v, %#v), got (%v, %#v)",
0000000000000000000000000000000000000000;;						watcher, e.Type, e.Object, a.Type, a.Object)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t.Logf("Got (%v, %#v)", e1.Type, e1.Object)
0000000000000000000000000000000000000000;;				e2, ok := <-w.ResultChan()
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					t.Errorf("Watcher %v received second event (%v, %#v) even though it shouldn't have.",
0000000000000000000000000000000000000000;;						watcher, e2.Type, e2.Object)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(i, watches[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
