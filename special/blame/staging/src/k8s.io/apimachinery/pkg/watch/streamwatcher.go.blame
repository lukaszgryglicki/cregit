0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package watch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decoder allows StreamWatcher to watch any stream for which a Decoder can be written.
0000000000000000000000000000000000000000;;	type Decoder interface {
0000000000000000000000000000000000000000;;		// Decode should return the type of event, the decoded object, or an error.
0000000000000000000000000000000000000000;;		// An error will cause StreamWatcher to call Close(). Decode should block until
0000000000000000000000000000000000000000;;		// it has data or an error occurs.
0000000000000000000000000000000000000000;;		Decode() (action EventType, object runtime.Object, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close should close the underlying io.Reader, signalling to the source of
0000000000000000000000000000000000000000;;		// the stream that it is no longer being watched. Close() must cause any
0000000000000000000000000000000000000000;;		// outstanding call to Decode() to return with an error of some sort.
0000000000000000000000000000000000000000;;		Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamWatcher turns any stream for which you can write a Decoder interface
0000000000000000000000000000000000000000;;	// into a watch.Interface.
0000000000000000000000000000000000000000;;	type StreamWatcher struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		source  Decoder
0000000000000000000000000000000000000000;;		result  chan Event
0000000000000000000000000000000000000000;;		stopped bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStreamWatcher creates a StreamWatcher from the given decoder.
0000000000000000000000000000000000000000;;	func NewStreamWatcher(d Decoder) *StreamWatcher {
0000000000000000000000000000000000000000;;		sw := &StreamWatcher{
0000000000000000000000000000000000000000;;			source: d,
0000000000000000000000000000000000000000;;			// It's easy for a consumer to add buffering via an extra
0000000000000000000000000000000000000000;;			// goroutine/channel, but impossible for them to remove it,
0000000000000000000000000000000000000000;;			// so nonbuffered is better.
0000000000000000000000000000000000000000;;			result: make(chan Event),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go sw.receive()
0000000000000000000000000000000000000000;;		return sw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResultChan implements Interface.
0000000000000000000000000000000000000000;;	func (sw *StreamWatcher) ResultChan() <-chan Event {
0000000000000000000000000000000000000000;;		return sw.result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop implements Interface.
0000000000000000000000000000000000000000;;	func (sw *StreamWatcher) Stop() {
0000000000000000000000000000000000000000;;		// Call Close() exactly once by locking and setting a flag.
0000000000000000000000000000000000000000;;		sw.Lock()
0000000000000000000000000000000000000000;;		defer sw.Unlock()
0000000000000000000000000000000000000000;;		if !sw.stopped {
0000000000000000000000000000000000000000;;			sw.stopped = true
0000000000000000000000000000000000000000;;			sw.source.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stopping returns true if Stop() was called previously.
0000000000000000000000000000000000000000;;	func (sw *StreamWatcher) stopping() bool {
0000000000000000000000000000000000000000;;		sw.Lock()
0000000000000000000000000000000000000000;;		defer sw.Unlock()
0000000000000000000000000000000000000000;;		return sw.stopped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// receive reads result from the decoder in a loop and sends down the result channel.
0000000000000000000000000000000000000000;;	func (sw *StreamWatcher) receive() {
0000000000000000000000000000000000000000;;		defer close(sw.result)
0000000000000000000000000000000000000000;;		defer sw.Stop()
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			action, obj, err := sw.source.Decode()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Ignore expected error.
0000000000000000000000000000000000000000;;				if sw.stopping() {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch err {
0000000000000000000000000000000000000000;;				case io.EOF:
0000000000000000000000000000000000000000;;					// watch closed normally
0000000000000000000000000000000000000000;;				case io.ErrUnexpectedEOF:
0000000000000000000000000000000000000000;;					glog.V(1).Infof("Unexpected EOF during watch stream event decoding: %v", err)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					msg := "Unable to decode an event from the watch stream: %v"
0000000000000000000000000000000000000000;;					if net.IsProbableEOF(err) {
0000000000000000000000000000000000000000;;						glog.V(5).Infof(msg, err)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.Errorf(msg, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sw.result <- Event{
0000000000000000000000000000000000000000;;				Type:   action,
0000000000000000000000000000000000000000;;				Object: obj,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
