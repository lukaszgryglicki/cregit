0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package watch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface can be implemented by anything that knows how to watch and report changes.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		// Stops watching. Will close the channel returned by ResultChan(). Releases
0000000000000000000000000000000000000000;;		// any resources used by the watch.
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns a chan which will receive all the events. If an error occurs
0000000000000000000000000000000000000000;;		// or Stop() is called, this channel will be closed, in which case the
0000000000000000000000000000000000000000;;		// watch should be completely cleaned up.
0000000000000000000000000000000000000000;;		ResultChan() <-chan Event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventType defines the possible types of events.
0000000000000000000000000000000000000000;;	type EventType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Added    EventType = "ADDED"
0000000000000000000000000000000000000000;;		Modified EventType = "MODIFIED"
0000000000000000000000000000000000000000;;		Deleted  EventType = "DELETED"
0000000000000000000000000000000000000000;;		Error    EventType = "ERROR"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DefaultChanSize int32 = 100
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Event represents a single event to a watched resource.
0000000000000000000000000000000000000000;;	type Event struct {
0000000000000000000000000000000000000000;;		Type EventType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Object is:
0000000000000000000000000000000000000000;;		//  * If Type is Added or Modified: the new state of the object.
0000000000000000000000000000000000000000;;		//  * If Type is Deleted: the state of the object immediately before deletion.
0000000000000000000000000000000000000000;;		//  * If Type is Error: *api.Status is recommended; other types may make sense
0000000000000000000000000000000000000000;;		//    depending on context.
0000000000000000000000000000000000000000;;		Object runtime.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type emptyWatch chan Event
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEmptyWatch returns a watch interface that returns no results and is closed.
0000000000000000000000000000000000000000;;	// May be used in certain error conditions where no information is available but
0000000000000000000000000000000000000000;;	// an error is not warranted.
0000000000000000000000000000000000000000;;	func NewEmptyWatch() Interface {
0000000000000000000000000000000000000000;;		ch := make(chan Event)
0000000000000000000000000000000000000000;;		close(ch)
0000000000000000000000000000000000000000;;		return emptyWatch(ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop implements Interface
0000000000000000000000000000000000000000;;	func (w emptyWatch) Stop() {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResultChan implements Interface
0000000000000000000000000000000000000000;;	func (w emptyWatch) ResultChan() <-chan Event {
0000000000000000000000000000000000000000;;		return chan Event(w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeWatcher lets you test anything that consumes a watch.Interface; threadsafe.
0000000000000000000000000000000000000000;;	type FakeWatcher struct {
0000000000000000000000000000000000000000;;		result  chan Event
0000000000000000000000000000000000000000;;		Stopped bool
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFake() *FakeWatcher {
0000000000000000000000000000000000000000;;		return &FakeWatcher{
0000000000000000000000000000000000000000;;			result: make(chan Event),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeWithChanSize(size int, blocking bool) *FakeWatcher {
0000000000000000000000000000000000000000;;		return &FakeWatcher{
0000000000000000000000000000000000000000;;			result: make(chan Event, size),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop implements Interface.Stop().
0000000000000000000000000000000000000000;;	func (f *FakeWatcher) Stop() {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		if !f.Stopped {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Stopping fake watcher.")
0000000000000000000000000000000000000000;;			close(f.result)
0000000000000000000000000000000000000000;;			f.Stopped = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeWatcher) IsStopped() bool {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		return f.Stopped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset prepares the watcher to be reused.
0000000000000000000000000000000000000000;;	func (f *FakeWatcher) Reset() {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Stopped = false
0000000000000000000000000000000000000000;;		f.result = make(chan Event)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeWatcher) ResultChan() <-chan Event {
0000000000000000000000000000000000000000;;		return f.result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add sends an add event.
0000000000000000000000000000000000000000;;	func (f *FakeWatcher) Add(obj runtime.Object) {
0000000000000000000000000000000000000000;;		f.result <- Event{Added, obj}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Modify sends a modify event.
0000000000000000000000000000000000000000;;	func (f *FakeWatcher) Modify(obj runtime.Object) {
0000000000000000000000000000000000000000;;		f.result <- Event{Modified, obj}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete sends a delete event.
0000000000000000000000000000000000000000;;	func (f *FakeWatcher) Delete(lastValue runtime.Object) {
0000000000000000000000000000000000000000;;		f.result <- Event{Deleted, lastValue}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error sends an Error event.
0000000000000000000000000000000000000000;;	func (f *FakeWatcher) Error(errValue runtime.Object) {
0000000000000000000000000000000000000000;;		f.result <- Event{Error, errValue}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Action sends an event of the requested type, for table-based testing.
0000000000000000000000000000000000000000;;	func (f *FakeWatcher) Action(action EventType, obj runtime.Object) {
0000000000000000000000000000000000000000;;		f.result <- Event{action, obj}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RaceFreeFakeWatcher lets you test anything that consumes a watch.Interface; threadsafe.
0000000000000000000000000000000000000000;;	type RaceFreeFakeWatcher struct {
0000000000000000000000000000000000000000;;		result  chan Event
0000000000000000000000000000000000000000;;		Stopped bool
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRaceFreeFake() *RaceFreeFakeWatcher {
0000000000000000000000000000000000000000;;		return &RaceFreeFakeWatcher{
0000000000000000000000000000000000000000;;			result: make(chan Event, DefaultChanSize),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop implements Interface.Stop().
0000000000000000000000000000000000000000;;	func (f *RaceFreeFakeWatcher) Stop() {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		if !f.Stopped {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Stopping fake watcher.")
0000000000000000000000000000000000000000;;			close(f.result)
0000000000000000000000000000000000000000;;			f.Stopped = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *RaceFreeFakeWatcher) IsStopped() bool {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		return f.Stopped
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset prepares the watcher to be reused.
0000000000000000000000000000000000000000;;	func (f *RaceFreeFakeWatcher) Reset() {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		f.Stopped = false
0000000000000000000000000000000000000000;;		f.result = make(chan Event, DefaultChanSize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *RaceFreeFakeWatcher) ResultChan() <-chan Event {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		return f.result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add sends an add event.
0000000000000000000000000000000000000000;;	func (f *RaceFreeFakeWatcher) Add(obj runtime.Object) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		if !f.Stopped {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case f.result <- Event{Added, obj}:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Errorf("channel full"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Modify sends a modify event.
0000000000000000000000000000000000000000;;	func (f *RaceFreeFakeWatcher) Modify(obj runtime.Object) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		if !f.Stopped {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case f.result <- Event{Modified, obj}:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Errorf("channel full"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete sends a delete event.
0000000000000000000000000000000000000000;;	func (f *RaceFreeFakeWatcher) Delete(lastValue runtime.Object) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		if !f.Stopped {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case f.result <- Event{Deleted, lastValue}:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Errorf("channel full"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error sends an Error event.
0000000000000000000000000000000000000000;;	func (f *RaceFreeFakeWatcher) Error(errValue runtime.Object) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		if !f.Stopped {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case f.result <- Event{Error, errValue}:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Errorf("channel full"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Action sends an event of the requested type, for table-based testing.
0000000000000000000000000000000000000000;;	func (f *RaceFreeFakeWatcher) Action(action EventType, obj runtime.Object) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		if !f.Stopped {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case f.result <- Event{action, obj}:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Errorf("channel full"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
