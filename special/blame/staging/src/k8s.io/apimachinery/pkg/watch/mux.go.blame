0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package watch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FullChannelBehavior controls how the Broadcaster reacts if a watcher's watch
0000000000000000000000000000000000000000;;	// channel is full.
0000000000000000000000000000000000000000;;	type FullChannelBehavior int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		WaitIfChannelFull FullChannelBehavior = iota
0000000000000000000000000000000000000000;;		DropIfChannelFull
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Buffer the incoming queue a little bit even though it should rarely ever accumulate
0000000000000000000000000000000000000000;;	// anything, just in case a few events are received in such a short window that
0000000000000000000000000000000000000000;;	// Broadcaster can't move them onto the watchers' queues fast enough.
0000000000000000000000000000000000000000;;	const incomingQueueLength = 25
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Broadcaster distributes event notifications among any number of watchers. Every event
0000000000000000000000000000000000000000;;	// is delivered to every watcher.
0000000000000000000000000000000000000000;;	type Broadcaster struct {
0000000000000000000000000000000000000000;;		// TODO: see if this lock is needed now that new watchers go through
0000000000000000000000000000000000000000;;		// the incoming channel.
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watchers     map[int64]*broadcasterWatcher
0000000000000000000000000000000000000000;;		nextWatcher  int64
0000000000000000000000000000000000000000;;		distributing sync.WaitGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		incoming chan Event
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// How large to make watcher's channel.
0000000000000000000000000000000000000000;;		watchQueueLength int
0000000000000000000000000000000000000000;;		// If one of the watch channels is full, don't wait for it to become empty.
0000000000000000000000000000000000000000;;		// Instead just deliver it to the watchers that do have space in their
0000000000000000000000000000000000000000;;		// channels and move on to the next event.
0000000000000000000000000000000000000000;;		// It's more fair to do this on a per-watcher basis than to do it on the
0000000000000000000000000000000000000000;;		// "incoming" channel, which would allow one slow watcher to prevent all
0000000000000000000000000000000000000000;;		// other watchers from getting new events.
0000000000000000000000000000000000000000;;		fullChannelBehavior FullChannelBehavior
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBroadcaster creates a new Broadcaster. queueLength is the maximum number of events to queue per watcher.
0000000000000000000000000000000000000000;;	// It is guaranteed that events will be distributed in the order in which they occur,
0000000000000000000000000000000000000000;;	// but the order in which a single event is distributed among all of the watchers is unspecified.
0000000000000000000000000000000000000000;;	func NewBroadcaster(queueLength int, fullChannelBehavior FullChannelBehavior) *Broadcaster {
0000000000000000000000000000000000000000;;		m := &Broadcaster{
0000000000000000000000000000000000000000;;			watchers:            map[int64]*broadcasterWatcher{},
0000000000000000000000000000000000000000;;			incoming:            make(chan Event, incomingQueueLength),
0000000000000000000000000000000000000000;;			watchQueueLength:    queueLength,
0000000000000000000000000000000000000000;;			fullChannelBehavior: fullChannelBehavior,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.distributing.Add(1)
0000000000000000000000000000000000000000;;		go m.loop()
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const internalRunFunctionMarker = "internal-do-function"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// a function type we can shoehorn into the queue.
0000000000000000000000000000000000000000;;	type functionFakeRuntimeObject func()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj functionFakeRuntimeObject) GetObjectKind() schema.ObjectKind {
0000000000000000000000000000000000000000;;		return schema.EmptyObjectKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Execute f, blocking the incoming queue (and waiting for it to drain first).
0000000000000000000000000000000000000000;;	// The purpose of this terrible hack is so that watchers added after an event
0000000000000000000000000000000000000000;;	// won't ever see that event, and will always see any event after they are
0000000000000000000000000000000000000000;;	// added.
0000000000000000000000000000000000000000;;	func (b *Broadcaster) blockQueue(f func()) {
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		b.incoming <- Event{
0000000000000000000000000000000000000000;;			Type: internalRunFunctionMarker,
0000000000000000000000000000000000000000;;			Object: functionFakeRuntimeObject(func() {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				f()
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch adds a new watcher to the list and returns an Interface for it.
0000000000000000000000000000000000000000;;	// Note: new watchers will only receive new events. They won't get an entire history
0000000000000000000000000000000000000000;;	// of previous events.
0000000000000000000000000000000000000000;;	func (m *Broadcaster) Watch() Interface {
0000000000000000000000000000000000000000;;		var w *broadcasterWatcher
0000000000000000000000000000000000000000;;		m.blockQueue(func() {
0000000000000000000000000000000000000000;;			m.lock.Lock()
0000000000000000000000000000000000000000;;			defer m.lock.Unlock()
0000000000000000000000000000000000000000;;			id := m.nextWatcher
0000000000000000000000000000000000000000;;			m.nextWatcher++
0000000000000000000000000000000000000000;;			w = &broadcasterWatcher{
0000000000000000000000000000000000000000;;				result:  make(chan Event, m.watchQueueLength),
0000000000000000000000000000000000000000;;				stopped: make(chan struct{}),
0000000000000000000000000000000000000000;;				id:      id,
0000000000000000000000000000000000000000;;				m:       m,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.watchers[id] = w
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WatchWithPrefix adds a new watcher to the list and returns an Interface for it. It sends
0000000000000000000000000000000000000000;;	// queuedEvents down the new watch before beginning to send ordinary events from Broadcaster.
0000000000000000000000000000000000000000;;	// The returned watch will have a queue length that is at least large enough to accommodate
0000000000000000000000000000000000000000;;	// all of the items in queuedEvents.
0000000000000000000000000000000000000000;;	func (m *Broadcaster) WatchWithPrefix(queuedEvents []Event) Interface {
0000000000000000000000000000000000000000;;		var w *broadcasterWatcher
0000000000000000000000000000000000000000;;		m.blockQueue(func() {
0000000000000000000000000000000000000000;;			m.lock.Lock()
0000000000000000000000000000000000000000;;			defer m.lock.Unlock()
0000000000000000000000000000000000000000;;			id := m.nextWatcher
0000000000000000000000000000000000000000;;			m.nextWatcher++
0000000000000000000000000000000000000000;;			length := m.watchQueueLength
0000000000000000000000000000000000000000;;			if n := len(queuedEvents) + 1; n > length {
0000000000000000000000000000000000000000;;				length = n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w = &broadcasterWatcher{
0000000000000000000000000000000000000000;;				result:  make(chan Event, length),
0000000000000000000000000000000000000000;;				stopped: make(chan struct{}),
0000000000000000000000000000000000000000;;				id:      id,
0000000000000000000000000000000000000000;;				m:       m,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.watchers[id] = w
0000000000000000000000000000000000000000;;			for _, e := range queuedEvents {
0000000000000000000000000000000000000000;;				w.result <- e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stopWatching stops the given watcher and removes it from the list.
0000000000000000000000000000000000000000;;	func (m *Broadcaster) stopWatching(id int64) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer m.lock.Unlock()
0000000000000000000000000000000000000000;;		w, ok := m.watchers[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// No need to do anything, it's already been removed from the list.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(m.watchers, id)
0000000000000000000000000000000000000000;;		close(w.result)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// closeAll disconnects all watchers (presumably in response to a Shutdown call).
0000000000000000000000000000000000000000;;	func (m *Broadcaster) closeAll() {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer m.lock.Unlock()
0000000000000000000000000000000000000000;;		for _, w := range m.watchers {
0000000000000000000000000000000000000000;;			close(w.result)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Delete everything from the map, since presence/absence in the map is used
0000000000000000000000000000000000000000;;		// by stopWatching to avoid double-closing the channel.
0000000000000000000000000000000000000000;;		m.watchers = map[int64]*broadcasterWatcher{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Action distributes the given event among all watchers.
0000000000000000000000000000000000000000;;	func (m *Broadcaster) Action(action EventType, obj runtime.Object) {
0000000000000000000000000000000000000000;;		m.incoming <- Event{action, obj}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Shutdown disconnects all watchers (but any queued events will still be distributed).
0000000000000000000000000000000000000000;;	// You must not call Action or Watch* after calling Shutdown. This call blocks
0000000000000000000000000000000000000000;;	// until all events have been distributed through the outbound channels. Note
0000000000000000000000000000000000000000;;	// that since they can be buffered, this means that the watchers might not
0000000000000000000000000000000000000000;;	// have received the data yet as it can remain sitting in the buffered
0000000000000000000000000000000000000000;;	// channel.
0000000000000000000000000000000000000000;;	func (m *Broadcaster) Shutdown() {
0000000000000000000000000000000000000000;;		close(m.incoming)
0000000000000000000000000000000000000000;;		m.distributing.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loop receives from m.incoming and distributes to all watchers.
0000000000000000000000000000000000000000;;	func (m *Broadcaster) loop() {
0000000000000000000000000000000000000000;;		// Deliberately not catching crashes here. Yes, bring down the process if there's a
0000000000000000000000000000000000000000;;		// bug in watch.Broadcaster.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			event, ok := <-m.incoming
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if event.Type == internalRunFunctionMarker {
0000000000000000000000000000000000000000;;				event.Object.(functionFakeRuntimeObject)()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.distribute(event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.closeAll()
0000000000000000000000000000000000000000;;		m.distributing.Done()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// distribute sends event to all watchers. Blocking.
0000000000000000000000000000000000000000;;	func (m *Broadcaster) distribute(event Event) {
0000000000000000000000000000000000000000;;		m.lock.Lock()
0000000000000000000000000000000000000000;;		defer m.lock.Unlock()
0000000000000000000000000000000000000000;;		if m.fullChannelBehavior == DropIfChannelFull {
0000000000000000000000000000000000000000;;			for _, w := range m.watchers {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case w.result <- event:
0000000000000000000000000000000000000000;;				case <-w.stopped:
0000000000000000000000000000000000000000;;				default: // Don't block if the event can't be queued.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, w := range m.watchers {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case w.result <- event:
0000000000000000000000000000000000000000;;				case <-w.stopped:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// broadcasterWatcher handles a single watcher of a broadcaster
0000000000000000000000000000000000000000;;	type broadcasterWatcher struct {
0000000000000000000000000000000000000000;;		result  chan Event
0000000000000000000000000000000000000000;;		stopped chan struct{}
0000000000000000000000000000000000000000;;		stop    sync.Once
0000000000000000000000000000000000000000;;		id      int64
0000000000000000000000000000000000000000;;		m       *Broadcaster
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResultChan returns a channel to use for waiting on events.
0000000000000000000000000000000000000000;;	func (mw *broadcasterWatcher) ResultChan() <-chan Event {
0000000000000000000000000000000000000000;;		return mw.result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops watching and removes mw from its list.
0000000000000000000000000000000000000000;;	func (mw *broadcasterWatcher) Stop() {
0000000000000000000000000000000000000000;;		mw.stop.Do(func() {
0000000000000000000000000000000000000000;;			close(mw.stopped)
0000000000000000000000000000000000000000;;			mw.m.stopWatching(mw.id)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
