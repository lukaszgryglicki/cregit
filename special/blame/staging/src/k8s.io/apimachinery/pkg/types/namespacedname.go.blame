0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespacedName comprises a resource name, with a mandatory namespace,
0000000000000000000000000000000000000000;;	// rendered as "<namespace>/<name>".  Being a type captures intent and
0000000000000000000000000000000000000000;;	// helps make sure that UIDs, namespaced names and non-namespaced names
0000000000000000000000000000000000000000;;	// do not get conflated in code.  For most use cases, namespace and name
0000000000000000000000000000000000000000;;	// will already have been format validated at the API entry point, so we
0000000000000000000000000000000000000000;;	// don't do that here.  Where that's not the case (e.g. in testing),
0000000000000000000000000000000000000000;;	// consider using NamespacedNameOrDie() in testing.go in this package.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NamespacedName struct {
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Separator = '/'
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the general purpose string representation
0000000000000000000000000000000000000000;;	func (n NamespacedName) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s%c%s", n.Namespace, Separator, n.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNamespacedNameFromString parses the provided string and returns a NamespacedName.
0000000000000000000000000000000000000000;;	// The expected format is as per String() above.
0000000000000000000000000000000000000000;;	// If the input string is invalid, the returned NamespacedName has all empty string field values.
0000000000000000000000000000000000000000;;	// This allows a single-value return from this function, while still allowing error checks in the caller.
0000000000000000000000000000000000000000;;	// Note that an input string which does not include exactly one Separator is not a valid input (as it could never
0000000000000000000000000000000000000000;;	// have neem returned by String() )
0000000000000000000000000000000000000000;;	func NewNamespacedNameFromString(s string) NamespacedName {
0000000000000000000000000000000000000000;;		nn := NamespacedName{}
0000000000000000000000000000000000000000;;		result := strings.Split(s, string(Separator))
0000000000000000000000000000000000000000;;		if len(result) == 2 {
0000000000000000000000000000000000000000;;			nn.Namespace = result[0]
0000000000000000000000000000000000000000;;			nn.Name = result[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nn
0000000000000000000000000000000000000000;;	}
