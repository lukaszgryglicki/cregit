0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8379c49734496ea9a33e73d3ec9f54dd1a6cd535;pkg/apimachinery/announced/announced.go[pkg/apimachinery/announced/announced.go][staging/src/k8s.io/apimachinery/pkg/apimachinery/announced/announced.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package announced contains tools for announcing API group factories. This is
0000000000000000000000000000000000000000;;	// distinct from registration (in the 'registered' package) in that it's safe
0000000000000000000000000000000000000000;;	// to announce every possible group linked in, but only groups requested at
0000000000000000000000000000000000000000;;	// runtime should be registered. This package contains both a registry, and
0000000000000000000000000000000000000000;;	// factory code (which was formerly copy-pasta in every install package).
0000000000000000000000000000000000000000;;	package announced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/registered"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIGroupFactoryRegistry allows for groups and versions to announce themselves,
0000000000000000000000000000000000000000;;	// which simply makes them available and doesn't take other actions. Later,
0000000000000000000000000000000000000000;;	// users of the registry can select which groups and versions they'd actually
0000000000000000000000000000000000000000;;	// like to register with an APIRegistrationManager.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// (Right now APIRegistrationManager has separate 'registration' and 'enabled'
0000000000000000000000000000000000000000;;	// concepts-- APIGroupFactory is going to take over the former function;
0000000000000000000000000000000000000000;;	// they will overlap untill the refactoring is finished.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The key is the group name. After initialization, this should be treated as
0000000000000000000000000000000000000000;;	// read-only. It is implemented as a map from group name to group factory, and
0000000000000000000000000000000000000000;;	// it is safe to use this knowledge to manually pick out groups to register
0000000000000000000000000000000000000000;;	// (e.g., for testing).
0000000000000000000000000000000000000000;;	type APIGroupFactoryRegistry map[string]*GroupMetaFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gar APIGroupFactoryRegistry) group(groupName string) *GroupMetaFactory {
0000000000000000000000000000000000000000;;		gmf, ok := gar[groupName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			gmf = &GroupMetaFactory{VersionArgs: map[string]*GroupVersionFactoryArgs{}}
0000000000000000000000000000000000000000;;			gar[groupName] = gmf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gmf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AnnounceGroupVersion adds the particular arguments for this group version to the group factory.
0000000000000000000000000000000000000000;;	func (gar APIGroupFactoryRegistry) AnnounceGroupVersion(gvf *GroupVersionFactoryArgs) error {
0000000000000000000000000000000000000000;;		gmf := gar.group(gvf.GroupName)
0000000000000000000000000000000000000000;;		if _, ok := gmf.VersionArgs[gvf.VersionName]; ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("version %q in group %q has already been announced", gvf.VersionName, gvf.GroupName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gmf.VersionArgs[gvf.VersionName] = gvf
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AnnounceGroup adds the group-wide arguments to the group factory.
0000000000000000000000000000000000000000;;	func (gar APIGroupFactoryRegistry) AnnounceGroup(args *GroupMetaFactoryArgs) error {
0000000000000000000000000000000000000000;;		gmf := gar.group(args.GroupName)
0000000000000000000000000000000000000000;;		if gmf.GroupArgs != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("group %q has already been announced", args.GroupName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gmf.GroupArgs = args
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterAndEnableAll throws every factory at the specified API registration
0000000000000000000000000000000000000000;;	// manager, and lets it decide which to register. (If you want to do this a la
0000000000000000000000000000000000000000;;	// cart, you may look through gar itself-- it's just a map.)
0000000000000000000000000000000000000000;;	func (gar APIGroupFactoryRegistry) RegisterAndEnableAll(m *registered.APIRegistrationManager, scheme *runtime.Scheme) error {
0000000000000000000000000000000000000000;;		for groupName, gmf := range gar {
0000000000000000000000000000000000000000;;			if err := gmf.Register(m); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error registering %v: %v", groupName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := gmf.Enable(m, scheme); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error enabling %v: %v", groupName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AnnouncePreconstructedFactory announces a factory which you've manually assembled.
0000000000000000000000000000000000000000;;	// You may call this instead of calling AnnounceGroup and AnnounceGroupVersion.
0000000000000000000000000000000000000000;;	func (gar APIGroupFactoryRegistry) AnnouncePreconstructedFactory(gmf *GroupMetaFactory) error {
0000000000000000000000000000000000000000;;		name := gmf.GroupArgs.GroupName
0000000000000000000000000000000000000000;;		if _, exists := gar[name]; exists {
0000000000000000000000000000000000000000;;			return fmt.Errorf("the group %q has already been announced.", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gar[name] = gmf
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
