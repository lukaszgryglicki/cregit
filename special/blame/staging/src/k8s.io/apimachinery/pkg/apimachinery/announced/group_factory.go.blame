0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
8379c49734496ea9a33e73d3ec9f54dd1a6cd535;pkg/apimachinery/announced/group_factory.go[pkg/apimachinery/announced/group_factory.go][staging/src/k8s.io/apimachinery/pkg/apimachinery/announced/group_factory.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package announced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/registered"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SchemeFunc func(*runtime.Scheme) error
0000000000000000000000000000000000000000;;	type VersionToSchemeFunc map[string]SchemeFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersionFactoryArgs contains all the per-version parts of a GroupMetaFactory.
0000000000000000000000000000000000000000;;	type GroupVersionFactoryArgs struct {
0000000000000000000000000000000000000000;;		GroupName   string
0000000000000000000000000000000000000000;;		VersionName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AddToScheme SchemeFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupMetaFactoryArgs contains the group-level args of a GroupMetaFactory.
0000000000000000000000000000000000000000;;	type GroupMetaFactoryArgs struct {
0000000000000000000000000000000000000000;;		// GroupName is the name of the API-Group
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// example: 'servicecatalog.k8s.io'
0000000000000000000000000000000000000000;;		GroupName              string
0000000000000000000000000000000000000000;;		VersionPreferenceOrder []string
0000000000000000000000000000000000000000;;		// ImportPrefix is the base go package of the API-Group
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// example: 'k8s.io/kubernetes/pkg/apis/autoscaling'
0000000000000000000000000000000000000000;;		ImportPrefix string
0000000000000000000000000000000000000000;;		// RootScopedKinds are resources that are not namespaced.
0000000000000000000000000000000000000000;;		RootScopedKinds sets.String // nil is allowed
0000000000000000000000000000000000000000;;		IgnoredKinds    sets.String // nil is allowed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// May be nil if there are no internal objects.
0000000000000000000000000000000000000000;;		AddInternalObjectsToScheme SchemeFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGroupMetaFactory builds the args for you. This is for if you're
0000000000000000000000000000000000000000;;	// constructing a factory all at once and not using the registry.
0000000000000000000000000000000000000000;;	func NewGroupMetaFactory(groupArgs *GroupMetaFactoryArgs, versions VersionToSchemeFunc) *GroupMetaFactory {
0000000000000000000000000000000000000000;;		gmf := &GroupMetaFactory{
0000000000000000000000000000000000000000;;			GroupArgs:   groupArgs,
0000000000000000000000000000000000000000;;			VersionArgs: map[string]*GroupVersionFactoryArgs{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for v, f := range versions {
0000000000000000000000000000000000000000;;			gmf.VersionArgs[v] = &GroupVersionFactoryArgs{
0000000000000000000000000000000000000000;;				GroupName:   groupArgs.GroupName,
0000000000000000000000000000000000000000;;				VersionName: v,
0000000000000000000000000000000000000000;;				AddToScheme: f,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gmf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Announce adds this Group factory to the global factory registry. It should
0000000000000000000000000000000000000000;;	// only be called if you constructed the GroupMetaFactory yourself via
0000000000000000000000000000000000000000;;	// NewGroupMetaFactory.
0000000000000000000000000000000000000000;;	// Note that this will panic on an error, since it's expected that you'll be
0000000000000000000000000000000000000000;;	// calling this at initialization time and any error is a result of a
0000000000000000000000000000000000000000;;	// programmer importing the wrong set of packages. If this assumption doesn't
0000000000000000000000000000000000000000;;	// work for you, just call DefaultGroupFactoryRegistry.AnnouncePreconstructedFactory
0000000000000000000000000000000000000000;;	// yourself.
0000000000000000000000000000000000000000;;	func (gmf *GroupMetaFactory) Announce(groupFactoryRegistry APIGroupFactoryRegistry) *GroupMetaFactory {
0000000000000000000000000000000000000000;;		if err := groupFactoryRegistry.AnnouncePreconstructedFactory(gmf); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gmf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupMetaFactory has the logic for actually assembling and registering a group.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There are two ways of obtaining one of these.
0000000000000000000000000000000000000000;;	// 1. You can announce your group and versions separately, and then let the
0000000000000000000000000000000000000000;;	//    GroupFactoryRegistry assemble this object for you. (This allows group and
0000000000000000000000000000000000000000;;	//    versions to be imported separately, without referencing each other, to
0000000000000000000000000000000000000000;;	//    keep import trees small.)
0000000000000000000000000000000000000000;;	// 2. You can call NewGroupMetaFactory(), which is mostly a drop-in replacement
0000000000000000000000000000000000000000;;	//    for the old, bad way of doing things. You can then call .Announce() to
0000000000000000000000000000000000000000;;	//    announce your constructed factory to any code that would like to do
0000000000000000000000000000000000000000;;	//    things the new, better way.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that GroupMetaFactory actually does construct GroupMeta objects, but
0000000000000000000000000000000000000000;;	// currently it does so in a way that's very entangled with an
0000000000000000000000000000000000000000;;	// APIRegistrationManager. It's a TODO item to cleanly separate that interface.
0000000000000000000000000000000000000000;;	type GroupMetaFactory struct {
0000000000000000000000000000000000000000;;		GroupArgs *GroupMetaFactoryArgs
0000000000000000000000000000000000000000;;		// map of version name to version factory
0000000000000000000000000000000000000000;;		VersionArgs map[string]*GroupVersionFactoryArgs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// assembled by Register()
0000000000000000000000000000000000000000;;		prioritizedVersionList []schema.GroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register constructs the finalized prioritized version list and sanity checks
0000000000000000000000000000000000000000;;	// the announced group & versions. Then it calls register.
0000000000000000000000000000000000000000;;	func (gmf *GroupMetaFactory) Register(m *registered.APIRegistrationManager) error {
0000000000000000000000000000000000000000;;		if gmf.GroupArgs == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("partially announced groups are not allowed, only got versions: %#v", gmf.VersionArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(gmf.VersionArgs) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("group %v announced but no versions announced", gmf.GroupArgs.GroupName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pvSet := sets.NewString(gmf.GroupArgs.VersionPreferenceOrder...)
0000000000000000000000000000000000000000;;		if pvSet.Len() != len(gmf.GroupArgs.VersionPreferenceOrder) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("preference order for group %v has duplicates: %v", gmf.GroupArgs.GroupName, gmf.GroupArgs.VersionPreferenceOrder)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prioritizedVersions := []schema.GroupVersion{}
0000000000000000000000000000000000000000;;		for _, v := range gmf.GroupArgs.VersionPreferenceOrder {
0000000000000000000000000000000000000000;;			prioritizedVersions = append(
0000000000000000000000000000000000000000;;				prioritizedVersions,
0000000000000000000000000000000000000000;;				schema.GroupVersion{
0000000000000000000000000000000000000000;;					Group:   gmf.GroupArgs.GroupName,
0000000000000000000000000000000000000000;;					Version: v,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Go through versions that weren't explicitly prioritized.
0000000000000000000000000000000000000000;;		unprioritizedVersions := []schema.GroupVersion{}
0000000000000000000000000000000000000000;;		for _, v := range gmf.VersionArgs {
0000000000000000000000000000000000000000;;			if v.GroupName != gmf.GroupArgs.GroupName {
0000000000000000000000000000000000000000;;				return fmt.Errorf("found %v/%v in group %v?", v.GroupName, v.VersionName, gmf.GroupArgs.GroupName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pvSet.Has(v.VersionName) {
0000000000000000000000000000000000000000;;				pvSet.Delete(v.VersionName)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unprioritizedVersions = append(unprioritizedVersions, schema.GroupVersion{Group: v.GroupName, Version: v.VersionName})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(unprioritizedVersions) > 1 {
0000000000000000000000000000000000000000;;			glog.Warningf("group %v has multiple unprioritized versions: %#v. They will have an arbitrary preference order!", gmf.GroupArgs.GroupName, unprioritizedVersions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pvSet.Len() != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("group %v has versions in the priority list that were never announced: %s", gmf.GroupArgs.GroupName, pvSet)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prioritizedVersions = append(prioritizedVersions, unprioritizedVersions...)
0000000000000000000000000000000000000000;;		m.RegisterVersions(prioritizedVersions)
0000000000000000000000000000000000000000;;		gmf.prioritizedVersionList = prioritizedVersions
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gmf *GroupMetaFactory) newRESTMapper(scheme *runtime.Scheme, externalVersions []schema.GroupVersion, groupMeta *apimachinery.GroupMeta) meta.RESTMapper {
0000000000000000000000000000000000000000;;		// the list of kinds that are scoped at the root of the api hierarchy
0000000000000000000000000000000000000000;;		// if a kind is not enumerated here, it is assumed to have a namespace scope
0000000000000000000000000000000000000000;;		rootScoped := sets.NewString()
0000000000000000000000000000000000000000;;		if gmf.GroupArgs.RootScopedKinds != nil {
0000000000000000000000000000000000000000;;			rootScoped = gmf.GroupArgs.RootScopedKinds
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ignoredKinds := sets.NewString()
0000000000000000000000000000000000000000;;		if gmf.GroupArgs.IgnoredKinds != nil {
0000000000000000000000000000000000000000;;			ignoredKinds = gmf.GroupArgs.IgnoredKinds
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return meta.NewDefaultRESTMapperFromScheme(
0000000000000000000000000000000000000000;;			externalVersions,
0000000000000000000000000000000000000000;;			groupMeta.InterfacesFor,
0000000000000000000000000000000000000000;;			gmf.GroupArgs.ImportPrefix,
0000000000000000000000000000000000000000;;			ignoredKinds,
0000000000000000000000000000000000000000;;			rootScoped,
0000000000000000000000000000000000000000;;			scheme,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enable enables group versions that are allowed, adds methods to the scheme, etc.
0000000000000000000000000000000000000000;;	func (gmf *GroupMetaFactory) Enable(m *registered.APIRegistrationManager, scheme *runtime.Scheme) error {
0000000000000000000000000000000000000000;;		externalVersions := []schema.GroupVersion{}
0000000000000000000000000000000000000000;;		for _, v := range gmf.prioritizedVersionList {
0000000000000000000000000000000000000000;;			if !m.IsAllowedVersion(v) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			externalVersions = append(externalVersions, v)
0000000000000000000000000000000000000000;;			if err := m.EnableVersions(v); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gmf.VersionArgs[v.Version].AddToScheme(scheme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(externalVersions) == 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("No version is registered for group %v", gmf.GroupArgs.GroupName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if gmf.GroupArgs.AddInternalObjectsToScheme != nil {
0000000000000000000000000000000000000000;;			gmf.GroupArgs.AddInternalObjectsToScheme(scheme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		preferredExternalVersion := externalVersions[0]
0000000000000000000000000000000000000000;;		accessor := meta.NewAccessor()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		groupMeta := &apimachinery.GroupMeta{
0000000000000000000000000000000000000000;;			GroupVersion:  preferredExternalVersion,
0000000000000000000000000000000000000000;;			GroupVersions: externalVersions,
0000000000000000000000000000000000000000;;			SelfLinker:    runtime.SelfLinker(accessor),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range externalVersions {
0000000000000000000000000000000000000000;;			gvf := gmf.VersionArgs[v.Version]
0000000000000000000000000000000000000000;;			if err := groupMeta.AddVersionInterfaces(
0000000000000000000000000000000000000000;;				schema.GroupVersion{Group: gvf.GroupName, Version: gvf.VersionName},
0000000000000000000000000000000000000000;;				&meta.VersionInterfaces{
0000000000000000000000000000000000000000;;					ObjectConvertor:  scheme,
0000000000000000000000000000000000000000;;					MetadataAccessor: accessor,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupMeta.InterfacesFor = groupMeta.DefaultInterfacesFor
0000000000000000000000000000000000000000;;		groupMeta.RESTMapper = gmf.newRESTMapper(scheme, externalVersions, groupMeta)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := m.RegisterGroup(*groupMeta); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterAndEnable is provided only to allow this code to get added in multiple steps.
0000000000000000000000000000000000000000;;	// It's really bad that this is called in init() methods, but supporting this
0000000000000000000000000000000000000000;;	// temporarily lets us do the change incrementally.
0000000000000000000000000000000000000000;;	func (gmf *GroupMetaFactory) RegisterAndEnable(registry *registered.APIRegistrationManager, scheme *runtime.Scheme) error {
0000000000000000000000000000000000000000;;		if err := gmf.Register(registry); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := gmf.Enable(registry, scheme); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
