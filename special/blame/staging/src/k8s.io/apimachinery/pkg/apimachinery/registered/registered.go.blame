0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package to keep track of API Versions that can be registered and are enabled in api.Scheme.
0000000000000000000000000000000000000000;;	package registered
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIRegistrationManager provides the concept of what API groups are enabled.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: currently, it also provides a "registered" concept. But it's wrong to
0000000000000000000000000000000000000000;;	// have both concepts in the same object. Therefore the "announced" package is
0000000000000000000000000000000000000000;;	// going to take over the registered concept. After all the install packages
0000000000000000000000000000000000000000;;	// are switched to using the announce package instead of this package, then we
0000000000000000000000000000000000000000;;	// can combine the registered/enabled concepts in this object. Simplifying this
0000000000000000000000000000000000000000;;	// isn't easy right now because there are so many callers of this package.
0000000000000000000000000000000000000000;;	type APIRegistrationManager struct {
0000000000000000000000000000000000000000;;		// registeredGroupVersions stores all API group versions for which RegisterGroup is called.
0000000000000000000000000000000000000000;;		registeredVersions map[schema.GroupVersion]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// enabledVersions represents all enabled API versions. It should be a
0000000000000000000000000000000000000000;;		// subset of registeredVersions. Please call EnableVersions() to add
0000000000000000000000000000000000000000;;		// enabled versions.
0000000000000000000000000000000000000000;;		enabledVersions map[schema.GroupVersion]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// map of group meta for all groups.
0000000000000000000000000000000000000000;;		groupMetaMap map[string]*apimachinery.GroupMeta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// envRequestedVersions represents the versions requested via the
0000000000000000000000000000000000000000;;		// KUBE_API_VERSIONS environment variable. The install package of each group
0000000000000000000000000000000000000000;;		// checks this list before add their versions to the latest package and
0000000000000000000000000000000000000000;;		// Scheme.  This list is small and order matters, so represent as a slice
0000000000000000000000000000000000000000;;		envRequestedVersions []schema.GroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAPIRegistrationManager constructs a new manager. The argument ought to be
0000000000000000000000000000000000000000;;	// the value of the KUBE_API_VERSIONS env var, or a value of this which you
0000000000000000000000000000000000000000;;	// wish to test.
0000000000000000000000000000000000000000;;	func NewAPIRegistrationManager(kubeAPIVersions string) (*APIRegistrationManager, error) {
0000000000000000000000000000000000000000;;		m := &APIRegistrationManager{
0000000000000000000000000000000000000000;;			registeredVersions:   map[schema.GroupVersion]struct{}{},
0000000000000000000000000000000000000000;;			enabledVersions:      map[schema.GroupVersion]struct{}{},
0000000000000000000000000000000000000000;;			groupMetaMap:         map[string]*apimachinery.GroupMeta{},
0000000000000000000000000000000000000000;;			envRequestedVersions: []schema.GroupVersion{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(kubeAPIVersions) != 0 {
0000000000000000000000000000000000000000;;			for _, version := range strings.Split(kubeAPIVersions, ",") {
0000000000000000000000000000000000000000;;				gv, err := schema.ParseGroupVersion(version)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("invalid api version: %s in KUBE_API_VERSIONS: %s.",
0000000000000000000000000000000000000000;;						version, kubeAPIVersions)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m.envRequestedVersions = append(m.envRequestedVersions, gv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOrDie(kubeAPIVersions string) *APIRegistrationManager {
0000000000000000000000000000000000000000;;		m, err := NewAPIRegistrationManager(kubeAPIVersions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Could not construct version manager: %v (KUBE_API_VERSIONS=%q)", err, kubeAPIVersions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterVersions adds the given group versions to the list of registered group versions.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) RegisterVersions(availableVersions []schema.GroupVersion) {
0000000000000000000000000000000000000000;;		for _, v := range availableVersions {
0000000000000000000000000000000000000000;;			m.registeredVersions[v] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterGroup adds the given group to the list of registered groups.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) RegisterGroup(groupMeta apimachinery.GroupMeta) error {
0000000000000000000000000000000000000000;;		groupName := groupMeta.GroupVersion.Group
0000000000000000000000000000000000000000;;		if _, found := m.groupMetaMap[groupName]; found {
0000000000000000000000000000000000000000;;			return fmt.Errorf("group %q is already registered in groupsMap: %v", groupName, m.groupMetaMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.groupMetaMap[groupName] = &groupMeta
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnableVersions adds the versions for the given group to the list of enabled versions.
0000000000000000000000000000000000000000;;	// Note that the caller should call RegisterGroup before calling this method.
0000000000000000000000000000000000000000;;	// The caller of this function is responsible to add the versions to scheme and RESTMapper.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) EnableVersions(versions ...schema.GroupVersion) error {
0000000000000000000000000000000000000000;;		var unregisteredVersions []schema.GroupVersion
0000000000000000000000000000000000000000;;		for _, v := range versions {
0000000000000000000000000000000000000000;;			if _, found := m.registeredVersions[v]; !found {
0000000000000000000000000000000000000000;;				unregisteredVersions = append(unregisteredVersions, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.enabledVersions[v] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(unregisteredVersions) != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Please register versions before enabling them: %v", unregisteredVersions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAllowedVersion returns if the version is allowed by the KUBE_API_VERSIONS
0000000000000000000000000000000000000000;;	// environment variable. If the environment variable is empty, then it always
0000000000000000000000000000000000000000;;	// returns true.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) IsAllowedVersion(v schema.GroupVersion) bool {
0000000000000000000000000000000000000000;;		if len(m.envRequestedVersions) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, envGV := range m.envRequestedVersions {
0000000000000000000000000000000000000000;;			if v == envGV {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEnabledVersion returns if a version is enabled.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) IsEnabledVersion(v schema.GroupVersion) bool {
0000000000000000000000000000000000000000;;		_, found := m.enabledVersions[v]
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnabledVersions returns all enabled versions.  Groups are randomly ordered, but versions within groups
0000000000000000000000000000000000000000;;	// are priority order from best to worst
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) EnabledVersions() []schema.GroupVersion {
0000000000000000000000000000000000000000;;		ret := []schema.GroupVersion{}
0000000000000000000000000000000000000000;;		for _, groupMeta := range m.groupMetaMap {
0000000000000000000000000000000000000000;;			for _, version := range groupMeta.GroupVersions {
0000000000000000000000000000000000000000;;				if m.IsEnabledVersion(version) {
0000000000000000000000000000000000000000;;					ret = append(ret, version)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnabledVersionsForGroup returns all enabled versions for a group in order of best to worst
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) EnabledVersionsForGroup(group string) []schema.GroupVersion {
0000000000000000000000000000000000000000;;		groupMeta, ok := m.groupMetaMap[group]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return []schema.GroupVersion{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := []schema.GroupVersion{}
0000000000000000000000000000000000000000;;		for _, version := range groupMeta.GroupVersions {
0000000000000000000000000000000000000000;;			if m.IsEnabledVersion(version) {
0000000000000000000000000000000000000000;;				ret = append(ret, version)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Group returns the metadata of a group if the group is registered, otherwise
0000000000000000000000000000000000000000;;	// an error is returned.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) Group(group string) (*apimachinery.GroupMeta, error) {
0000000000000000000000000000000000000000;;		groupMeta, found := m.groupMetaMap[group]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("group %v has not been registered", group)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupMetaCopy := *groupMeta
0000000000000000000000000000000000000000;;		return &groupMetaCopy, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRegistered takes a string and determines if it's one of the registered groups
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) IsRegistered(group string) bool {
0000000000000000000000000000000000000000;;		_, found := m.groupMetaMap[group]
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRegisteredVersion returns if a version is registered.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) IsRegisteredVersion(v schema.GroupVersion) bool {
0000000000000000000000000000000000000000;;		_, found := m.registeredVersions[v]
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisteredGroupVersions returns all registered group versions.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) RegisteredGroupVersions() []schema.GroupVersion {
0000000000000000000000000000000000000000;;		ret := []schema.GroupVersion{}
0000000000000000000000000000000000000000;;		for groupVersion := range m.registeredVersions {
0000000000000000000000000000000000000000;;			ret = append(ret, groupVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InterfacesFor is a union meta.VersionInterfacesFunc func for all registered types
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) InterfacesFor(version schema.GroupVersion) (*meta.VersionInterfaces, error) {
0000000000000000000000000000000000000000;;		groupMeta, err := m.Group(version.Group)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return groupMeta.InterfacesFor(version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: This is an expedient function, because we don't check if a Group is
0000000000000000000000000000000000000000;;	// supported throughout the code base. We will abandon this function and
0000000000000000000000000000000000000000;;	// checking the error returned by the Group() function.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) GroupOrDie(group string) *apimachinery.GroupMeta {
0000000000000000000000000000000000000000;;		groupMeta, found := m.groupMetaMap[group]
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			if group == "" {
0000000000000000000000000000000000000000;;				panic("The legacy v1 API is not registered.")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Group %s is not registered.", group))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		groupMetaCopy := *groupMeta
0000000000000000000000000000000000000000;;		return &groupMetaCopy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTMapper returns a union RESTMapper of all known types with priorities chosen in the following order:
0000000000000000000000000000000000000000;;	//  1. if KUBE_API_VERSIONS is specified, then KUBE_API_VERSIONS in order, OR
0000000000000000000000000000000000000000;;	//  1. legacy kube group preferred version, extensions preferred version, metrics perferred version, legacy
0000000000000000000000000000000000000000;;	//     kube any version, extensions any version, metrics any version, all other groups alphabetical preferred version,
0000000000000000000000000000000000000000;;	//     all other groups alphabetical.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) RESTMapper(versionPatterns ...schema.GroupVersion) meta.RESTMapper {
0000000000000000000000000000000000000000;;		unionMapper := meta.MultiRESTMapper{}
0000000000000000000000000000000000000000;;		unionedGroups := sets.NewString()
0000000000000000000000000000000000000000;;		for enabledVersion := range m.enabledVersions {
0000000000000000000000000000000000000000;;			if !unionedGroups.Has(enabledVersion.Group) {
0000000000000000000000000000000000000000;;				unionedGroups.Insert(enabledVersion.Group)
0000000000000000000000000000000000000000;;				groupMeta := m.groupMetaMap[enabledVersion.Group]
0000000000000000000000000000000000000000;;				unionMapper = append(unionMapper, groupMeta.RESTMapper)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(versionPatterns) != 0 {
0000000000000000000000000000000000000000;;			resourcePriority := []schema.GroupVersionResource{}
0000000000000000000000000000000000000000;;			kindPriority := []schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;			for _, versionPriority := range versionPatterns {
0000000000000000000000000000000000000000;;				resourcePriority = append(resourcePriority, versionPriority.WithResource(meta.AnyResource))
0000000000000000000000000000000000000000;;				kindPriority = append(kindPriority, versionPriority.WithKind(meta.AnyKind))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return meta.PriorityRESTMapper{Delegate: unionMapper, ResourcePriority: resourcePriority, KindPriority: kindPriority}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(m.envRequestedVersions) != 0 {
0000000000000000000000000000000000000000;;			resourcePriority := []schema.GroupVersionResource{}
0000000000000000000000000000000000000000;;			kindPriority := []schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, versionPriority := range m.envRequestedVersions {
0000000000000000000000000000000000000000;;				resourcePriority = append(resourcePriority, versionPriority.WithResource(meta.AnyResource))
0000000000000000000000000000000000000000;;				kindPriority = append(kindPriority, versionPriority.WithKind(meta.AnyKind))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return meta.PriorityRESTMapper{Delegate: unionMapper, ResourcePriority: resourcePriority, KindPriority: kindPriority}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prioritizedGroups := []string{"", "extensions", "metrics"}
0000000000000000000000000000000000000000;;		resourcePriority, kindPriority := m.prioritiesForGroups(prioritizedGroups...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prioritizedGroupsSet := sets.NewString(prioritizedGroups...)
0000000000000000000000000000000000000000;;		remainingGroups := sets.String{}
0000000000000000000000000000000000000000;;		for enabledVersion := range m.enabledVersions {
0000000000000000000000000000000000000000;;			if !prioritizedGroupsSet.Has(enabledVersion.Group) {
0000000000000000000000000000000000000000;;				remainingGroups.Insert(enabledVersion.Group)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remainingResourcePriority, remainingKindPriority := m.prioritiesForGroups(remainingGroups.List()...)
0000000000000000000000000000000000000000;;		resourcePriority = append(resourcePriority, remainingResourcePriority...)
0000000000000000000000000000000000000000;;		kindPriority = append(kindPriority, remainingKindPriority...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return meta.PriorityRESTMapper{Delegate: unionMapper, ResourcePriority: resourcePriority, KindPriority: kindPriority}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prioritiesForGroups returns the resource and kind priorities for a PriorityRESTMapper, preferring the preferred version of each group first,
0000000000000000000000000000000000000000;;	// then any non-preferred version of the group second.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) prioritiesForGroups(groups ...string) ([]schema.GroupVersionResource, []schema.GroupVersionKind) {
0000000000000000000000000000000000000000;;		resourcePriority := []schema.GroupVersionResource{}
0000000000000000000000000000000000000000;;		kindPriority := []schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, group := range groups {
0000000000000000000000000000000000000000;;			availableVersions := m.EnabledVersionsForGroup(group)
0000000000000000000000000000000000000000;;			if len(availableVersions) > 0 {
0000000000000000000000000000000000000000;;				resourcePriority = append(resourcePriority, availableVersions[0].WithResource(meta.AnyResource))
0000000000000000000000000000000000000000;;				kindPriority = append(kindPriority, availableVersions[0].WithKind(meta.AnyKind))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, group := range groups {
0000000000000000000000000000000000000000;;			resourcePriority = append(resourcePriority, schema.GroupVersionResource{Group: group, Version: meta.AnyVersion, Resource: meta.AnyResource})
0000000000000000000000000000000000000000;;			kindPriority = append(kindPriority, schema.GroupVersionKind{Group: group, Version: meta.AnyVersion, Kind: meta.AnyKind})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resourcePriority, kindPriority
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllPreferredGroupVersions returns the preferred versions of all registered
0000000000000000000000000000000000000000;;	// groups in the form of "group1/version1,group2/version2,..."
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) AllPreferredGroupVersions() string {
0000000000000000000000000000000000000000;;		if len(m.groupMetaMap) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var defaults []string
0000000000000000000000000000000000000000;;		for _, groupMeta := range m.groupMetaMap {
0000000000000000000000000000000000000000;;			defaults = append(defaults, groupMeta.GroupVersion.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(defaults)
0000000000000000000000000000000000000000;;		return strings.Join(defaults, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateEnvRequestedVersions returns a list of versions that are requested in
0000000000000000000000000000000000000000;;	// the KUBE_API_VERSIONS environment variable, but not enabled.
0000000000000000000000000000000000000000;;	func (m *APIRegistrationManager) ValidateEnvRequestedVersions() []schema.GroupVersion {
0000000000000000000000000000000000000000;;		var missingVersions []schema.GroupVersion
0000000000000000000000000000000000000000;;		for _, v := range m.envRequestedVersions {
0000000000000000000000000000000000000000;;			if _, found := m.enabledVersions[v]; !found {
0000000000000000000000000000000000000000;;				missingVersions = append(missingVersions, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return missingVersions
0000000000000000000000000000000000000000;;	}
