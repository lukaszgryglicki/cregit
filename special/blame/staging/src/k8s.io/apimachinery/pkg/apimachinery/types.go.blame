0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apimachinery
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupMeta stores the metadata of a group.
0000000000000000000000000000000000000000;;	type GroupMeta struct {
0000000000000000000000000000000000000000;;		// GroupVersion represents the preferred version of the group.
0000000000000000000000000000000000000000;;		GroupVersion schema.GroupVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GroupVersions is Group + all versions in that group.
0000000000000000000000000000000000000000;;		GroupVersions []schema.GroupVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SelfLinker can set or get the SelfLink field of all API types.
0000000000000000000000000000000000000000;;		// TODO: when versioning changes, make this part of each API definition.
0000000000000000000000000000000000000000;;		// TODO(lavalamp): Combine SelfLinker & ResourceVersioner interfaces, force all uses
0000000000000000000000000000000000000000;;		// to go through the InterfacesFor method below.
0000000000000000000000000000000000000000;;		SelfLinker runtime.SelfLinker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RESTMapper provides the default mapping between REST paths and the objects declared in api.Scheme and all known
0000000000000000000000000000000000000000;;		// versions.
0000000000000000000000000000000000000000;;		RESTMapper meta.RESTMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InterfacesFor returns the default Codec and ResourceVersioner for a given version
0000000000000000000000000000000000000000;;		// string, or an error if the version is not known.
0000000000000000000000000000000000000000;;		// TODO: make this stop being a func pointer and always use the default
0000000000000000000000000000000000000000;;		// function provided below once every place that populates this field has been changed.
0000000000000000000000000000000000000000;;		InterfacesFor func(version schema.GroupVersion) (*meta.VersionInterfaces, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InterfacesByVersion stores the per-version interfaces.
0000000000000000000000000000000000000000;;		InterfacesByVersion map[schema.GroupVersion]*meta.VersionInterfaces
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultInterfacesFor returns the default Codec and ResourceVersioner for a given version
0000000000000000000000000000000000000000;;	// string, or an error if the version is not known.
0000000000000000000000000000000000000000;;	// TODO: Remove the "Default" prefix.
0000000000000000000000000000000000000000;;	func (gm *GroupMeta) DefaultInterfacesFor(version schema.GroupVersion) (*meta.VersionInterfaces, error) {
0000000000000000000000000000000000000000;;		if v, ok := gm.InterfacesByVersion[version]; ok {
0000000000000000000000000000000000000000;;			return v, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unsupported storage version: %s (valid: %v)", version, gm.GroupVersions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddVersionInterfaces adds the given version to the group. Only call during
0000000000000000000000000000000000000000;;	// init, after that GroupMeta objects should be immutable. Not thread safe.
0000000000000000000000000000000000000000;;	// (If you use this, be sure to set .InterfacesFor = .DefaultInterfacesFor)
0000000000000000000000000000000000000000;;	// TODO: remove the "Interfaces" suffix and make this also maintain the
0000000000000000000000000000000000000000;;	// .GroupVersions member.
0000000000000000000000000000000000000000;;	func (gm *GroupMeta) AddVersionInterfaces(version schema.GroupVersion, interfaces *meta.VersionInterfaces) error {
0000000000000000000000000000000000000000;;		if e, a := gm.GroupVersion.Group, version.Group; a != e {
0000000000000000000000000000000000000000;;			return fmt.Errorf("got a version in group %v, but am in group %v", a, e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gm.InterfacesByVersion == nil {
0000000000000000000000000000000000000000;;			gm.InterfacesByVersion = make(map[schema.GroupVersion]*meta.VersionInterfaces)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gm.InterfacesByVersion[version] = interfaces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: refactor to make the below error not possible, this function
0000000000000000000000000000000000000000;;		// should *set* GroupVersions rather than depend on it.
0000000000000000000000000000000000000000;;		for _, v := range gm.GroupVersions {
0000000000000000000000000000000000000000;;			if v == version {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("added a version interface without the corresponding version %v being in the list %#v", version, gm.GroupVersions)
0000000000000000000000000000000000000000;;	}
