0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package conversion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type typePair struct {
0000000000000000000000000000000000000000;;		source reflect.Type
0000000000000000000000000000000000000000;;		dest   reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type typeNamePair struct {
0000000000000000000000000000000000000000;;		fieldType reflect.Type
0000000000000000000000000000000000000000;;		fieldName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DebugLogger allows you to get debugging messages if necessary.
0000000000000000000000000000000000000000;;	type DebugLogger interface {
0000000000000000000000000000000000000000;;		Logf(format string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NameFunc func(t reflect.Type) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var DefaultNameFunc = func(t reflect.Type) string { return t.Name() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GenericConversionFunc func(a, b interface{}, scope Scope) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converter knows how to convert one type to another.
0000000000000000000000000000000000000000;;	type Converter struct {
0000000000000000000000000000000000000000;;		// Map from the conversion pair to a function which can
0000000000000000000000000000000000000000;;		// do the conversion.
0000000000000000000000000000000000000000;;		conversionFuncs          ConversionFuncs
0000000000000000000000000000000000000000;;		generatedConversionFuncs ConversionFuncs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// genericConversions are called during normal conversion to offer a "fast-path"
0000000000000000000000000000000000000000;;		// that avoids all reflection. These methods are not called outside of the .Convert()
0000000000000000000000000000000000000000;;		// method.
0000000000000000000000000000000000000000;;		genericConversions []GenericConversionFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set of conversions that should be treated as a no-op
0000000000000000000000000000000000000000;;		ignoredConversions map[typePair]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is a map from a source field type and name, to a list of destination
0000000000000000000000000000000000000000;;		// field type and name.
0000000000000000000000000000000000000000;;		structFieldDests map[typeNamePair][]typeNamePair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allows for the opposite lookup of structFieldDests. So that SourceFromDest
0000000000000000000000000000000000000000;;		// copy flag also works. So this is a map of destination field name, to potential
0000000000000000000000000000000000000000;;		// source field name and type to look for.
0000000000000000000000000000000000000000;;		structFieldSources map[typeNamePair][]typeNamePair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map from an input type to a function which can apply a key name mapping
0000000000000000000000000000000000000000;;		inputFieldMappingFuncs map[reflect.Type]FieldMappingFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map from an input type to a set of default conversion flags.
0000000000000000000000000000000000000000;;		inputDefaultFlags map[reflect.Type]FieldMatchingFlags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If non-nil, will be called to print helpful debugging info. Quite verbose.
0000000000000000000000000000000000000000;;		Debug DebugLogger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nameFunc is called to retrieve the name of a type; this name is used for the
0000000000000000000000000000000000000000;;		// purpose of deciding whether two types match or not (i.e., will we attempt to
0000000000000000000000000000000000000000;;		// do a conversion). The default returns the go type name.
0000000000000000000000000000000000000000;;		nameFunc func(t reflect.Type) string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConverter creates a new Converter object.
0000000000000000000000000000000000000000;;	func NewConverter(nameFn NameFunc) *Converter {
0000000000000000000000000000000000000000;;		c := &Converter{
0000000000000000000000000000000000000000;;			conversionFuncs:          NewConversionFuncs(),
0000000000000000000000000000000000000000;;			generatedConversionFuncs: NewConversionFuncs(),
0000000000000000000000000000000000000000;;			ignoredConversions:       make(map[typePair]struct{}),
0000000000000000000000000000000000000000;;			nameFunc:                 nameFn,
0000000000000000000000000000000000000000;;			structFieldDests:         make(map[typeNamePair][]typeNamePair),
0000000000000000000000000000000000000000;;			structFieldSources:       make(map[typeNamePair][]typeNamePair),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			inputFieldMappingFuncs: make(map[reflect.Type]FieldMappingFunc),
0000000000000000000000000000000000000000;;			inputDefaultFlags:      make(map[reflect.Type]FieldMatchingFlags),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.RegisterConversionFunc(Convert_Slice_byte_To_Slice_byte)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddGenericConversionFunc adds a function that accepts the ConversionFunc call pattern
0000000000000000000000000000000000000000;;	// (for two conversion types) to the converter. These functions are checked first during
0000000000000000000000000000000000000000;;	// a normal conversion, but are otherwise not called. Use AddConversionFuncs when registering
0000000000000000000000000000000000000000;;	// typed conversions.
0000000000000000000000000000000000000000;;	func (c *Converter) AddGenericConversionFunc(fn GenericConversionFunc) {
0000000000000000000000000000000000000000;;		c.genericConversions = append(c.genericConversions, fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithConversions returns a Converter that is a copy of c but with the additional
0000000000000000000000000000000000000000;;	// fns merged on top.
0000000000000000000000000000000000000000;;	func (c *Converter) WithConversions(fns ConversionFuncs) *Converter {
0000000000000000000000000000000000000000;;		copied := *c
0000000000000000000000000000000000000000;;		copied.conversionFuncs = c.conversionFuncs.Merge(fns)
0000000000000000000000000000000000000000;;		return &copied
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultMeta returns the conversion FieldMappingFunc and meta for a given type.
0000000000000000000000000000000000000000;;	func (c *Converter) DefaultMeta(t reflect.Type) (FieldMatchingFlags, *Meta) {
0000000000000000000000000000000000000000;;		return c.inputDefaultFlags[t], &Meta{
0000000000000000000000000000000000000000;;			KeyNameMapping: c.inputFieldMappingFuncs[t],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert_Slice_byte_To_Slice_byte prevents recursing into every byte
0000000000000000000000000000000000000000;;	func Convert_Slice_byte_To_Slice_byte(in *[]byte, out *[]byte, s Scope) error {
0000000000000000000000000000000000000000;;		if *in == nil {
0000000000000000000000000000000000000000;;			*out = nil
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*out = make([]byte, len(*in))
0000000000000000000000000000000000000000;;		copy(*out, *in)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scope is passed to conversion funcs to allow them to continue an ongoing conversion.
0000000000000000000000000000000000000000;;	// If multiple converters exist in the system, Scope will allow you to use the correct one
0000000000000000000000000000000000000000;;	// from a conversion function--that is, the one your conversion function was called by.
0000000000000000000000000000000000000000;;	type Scope interface {
0000000000000000000000000000000000000000;;		// Call Convert to convert sub-objects. Note that if you call it with your own exact
0000000000000000000000000000000000000000;;		// parameters, you'll run out of stack space before anything useful happens.
0000000000000000000000000000000000000000;;		Convert(src, dest interface{}, flags FieldMatchingFlags) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultConvert performs the default conversion, without calling a conversion func
0000000000000000000000000000000000000000;;		// on the current stack frame. This makes it safe to call from a conversion func.
0000000000000000000000000000000000000000;;		DefaultConvert(src, dest interface{}, flags FieldMatchingFlags) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SrcTags and DestTags contain the struct tags that src and dest had, respectively.
0000000000000000000000000000000000000000;;		// If the enclosing object was not a struct, then these will contain no tags, of course.
0000000000000000000000000000000000000000;;		SrcTag() reflect.StructTag
0000000000000000000000000000000000000000;;		DestTag() reflect.StructTag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Flags returns the flags with which the conversion was started.
0000000000000000000000000000000000000000;;		Flags() FieldMatchingFlags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Meta returns any information originally passed to Convert.
0000000000000000000000000000000000000000;;		Meta() *Meta
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FieldMappingFunc can convert an input field value into different values, depending on
0000000000000000000000000000000000000000;;	// the value of the source or destination struct tags.
0000000000000000000000000000000000000000;;	type FieldMappingFunc func(key string, sourceTag, destTag reflect.StructTag) (source string, dest string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewConversionFuncs() ConversionFuncs {
0000000000000000000000000000000000000000;;		return ConversionFuncs{fns: make(map[typePair]reflect.Value)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ConversionFuncs struct {
0000000000000000000000000000000000000000;;		fns map[typePair]reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds the provided conversion functions to the lookup table - they must have the signature
0000000000000000000000000000000000000000;;	// `func(type1, type2, Scope) error`. Functions are added in the order passed and will override
0000000000000000000000000000000000000000;;	// previously registered pairs.
0000000000000000000000000000000000000000;;	func (c ConversionFuncs) Add(fns ...interface{}) error {
0000000000000000000000000000000000000000;;		for _, fn := range fns {
0000000000000000000000000000000000000000;;			fv := reflect.ValueOf(fn)
0000000000000000000000000000000000000000;;			ft := fv.Type()
0000000000000000000000000000000000000000;;			if err := verifyConversionFunctionSignature(ft); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.fns[typePair{ft.In(0).Elem(), ft.In(1).Elem()}] = fv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge returns a new ConversionFuncs that contains all conversions from
0000000000000000000000000000000000000000;;	// both other and c, with other conversions taking precedence.
0000000000000000000000000000000000000000;;	func (c ConversionFuncs) Merge(other ConversionFuncs) ConversionFuncs {
0000000000000000000000000000000000000000;;		merged := NewConversionFuncs()
0000000000000000000000000000000000000000;;		for k, v := range c.fns {
0000000000000000000000000000000000000000;;			merged.fns[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range other.fns {
0000000000000000000000000000000000000000;;			merged.fns[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return merged
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Meta is supplied by Scheme, when it calls Convert.
0000000000000000000000000000000000000000;;	type Meta struct {
0000000000000000000000000000000000000000;;		// KeyNameMapping is an optional function which may map the listed key (field name)
0000000000000000000000000000000000000000;;		// into a source and destination value.
0000000000000000000000000000000000000000;;		KeyNameMapping FieldMappingFunc
0000000000000000000000000000000000000000;;		// Context is an optional field that callers may use to pass info to conversion functions.
0000000000000000000000000000000000000000;;		Context interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scope contains information about an ongoing conversion.
0000000000000000000000000000000000000000;;	type scope struct {
0000000000000000000000000000000000000000;;		converter *Converter
0000000000000000000000000000000000000000;;		meta      *Meta
0000000000000000000000000000000000000000;;		flags     FieldMatchingFlags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// srcStack & destStack are separate because they may not have a 1:1
0000000000000000000000000000000000000000;;		// relationship.
0000000000000000000000000000000000000000;;		srcStack  scopeStack
0000000000000000000000000000000000000000;;		destStack scopeStack
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type scopeStackElem struct {
0000000000000000000000000000000000000000;;		tag   reflect.StructTag
0000000000000000000000000000000000000000;;		value reflect.Value
0000000000000000000000000000000000000000;;		key   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type scopeStack []scopeStackElem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *scopeStack) pop() {
0000000000000000000000000000000000000000;;		n := len(*s)
0000000000000000000000000000000000000000;;		*s = (*s)[:n-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *scopeStack) push(e scopeStackElem) {
0000000000000000000000000000000000000000;;		*s = append(*s, e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *scopeStack) top() *scopeStackElem {
0000000000000000000000000000000000000000;;		return &(*s)[len(*s)-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s scopeStack) describe() string {
0000000000000000000000000000000000000000;;		desc := ""
0000000000000000000000000000000000000000;;		if len(s) > 1 {
0000000000000000000000000000000000000000;;			desc = "(" + s[1].value.Type().String() + ")"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, v := range s {
0000000000000000000000000000000000000000;;			if i < 2 {
0000000000000000000000000000000000000000;;				// First layer on stack is not real; second is handled specially above.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v.key == "" {
0000000000000000000000000000000000000000;;				desc += fmt.Sprintf(".%v", v.value.Type())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				desc += fmt.Sprintf(".%v", v.key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Formats src & dest as indices for printing.
0000000000000000000000000000000000000000;;	func (s *scope) setIndices(src, dest int) {
0000000000000000000000000000000000000000;;		s.srcStack.top().key = fmt.Sprintf("[%v]", src)
0000000000000000000000000000000000000000;;		s.destStack.top().key = fmt.Sprintf("[%v]", dest)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Formats src & dest as map keys for printing.
0000000000000000000000000000000000000000;;	func (s *scope) setKeys(src, dest interface{}) {
0000000000000000000000000000000000000000;;		s.srcStack.top().key = fmt.Sprintf(`["%v"]`, src)
0000000000000000000000000000000000000000;;		s.destStack.top().key = fmt.Sprintf(`["%v"]`, dest)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert continues a conversion.
0000000000000000000000000000000000000000;;	func (s *scope) Convert(src, dest interface{}, flags FieldMatchingFlags) error {
0000000000000000000000000000000000000000;;		return s.converter.Convert(src, dest, flags, s.meta)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultConvert continues a conversion, performing a default conversion (no conversion func)
0000000000000000000000000000000000000000;;	// for the current stack frame.
0000000000000000000000000000000000000000;;	func (s *scope) DefaultConvert(src, dest interface{}, flags FieldMatchingFlags) error {
0000000000000000000000000000000000000000;;		return s.converter.DefaultConvert(src, dest, flags, s.meta)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SrcTag returns the tag of the struct containing the current source item, if any.
0000000000000000000000000000000000000000;;	func (s *scope) SrcTag() reflect.StructTag {
0000000000000000000000000000000000000000;;		return s.srcStack.top().tag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DestTag returns the tag of the struct containing the current dest item, if any.
0000000000000000000000000000000000000000;;	func (s *scope) DestTag() reflect.StructTag {
0000000000000000000000000000000000000000;;		return s.destStack.top().tag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flags returns the flags with which the current conversion was started.
0000000000000000000000000000000000000000;;	func (s *scope) Flags() FieldMatchingFlags {
0000000000000000000000000000000000000000;;		return s.flags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Meta returns the meta object that was originally passed to Convert.
0000000000000000000000000000000000000000;;	func (s *scope) Meta() *Meta {
0000000000000000000000000000000000000000;;		return s.meta
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// describe prints the path to get to the current (source, dest) values.
0000000000000000000000000000000000000000;;	func (s *scope) describe() (src, dest string) {
0000000000000000000000000000000000000000;;		return s.srcStack.describe(), s.destStack.describe()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// error makes an error that includes information about where we were in the objects
0000000000000000000000000000000000000000;;	// we were asked to convert.
0000000000000000000000000000000000000000;;	func (s *scope) errorf(message string, args ...interface{}) error {
0000000000000000000000000000000000000000;;		srcPath, destPath := s.describe()
0000000000000000000000000000000000000000;;		where := fmt.Sprintf("converting %v to %v: ", srcPath, destPath)
0000000000000000000000000000000000000000;;		return fmt.Errorf(where+message, args...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verifies whether a conversion function has a correct signature.
0000000000000000000000000000000000000000;;	func verifyConversionFunctionSignature(ft reflect.Type) error {
0000000000000000000000000000000000000000;;		if ft.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected func, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.NumIn() != 3 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected three 'in' params, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.NumOut() != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected one 'out' param, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.In(0).Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected pointer arg for 'in' param 0, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.In(1).Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected pointer arg for 'in' param 1, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scopeType := Scope(nil)
0000000000000000000000000000000000000000;;		if e, a := reflect.TypeOf(&scopeType).Elem(), ft.In(2); e != a {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected '%v' arg for 'in' param 2, got '%v' (%v)", e, a, ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var forErrorType error
0000000000000000000000000000000000000000;;		// This convolution is necessary, otherwise TypeOf picks up on the fact
0000000000000000000000000000000000000000;;		// that forErrorType is nil.
0000000000000000000000000000000000000000;;		errorType := reflect.TypeOf(&forErrorType).Elem()
0000000000000000000000000000000000000000;;		if ft.Out(0) != errorType {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected error return, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterConversionFunc registers a conversion func with the
0000000000000000000000000000000000000000;;	// Converter. conversionFunc must take three parameters: a pointer to the input
0000000000000000000000000000000000000000;;	// type, a pointer to the output type, and a conversion.Scope (which should be
0000000000000000000000000000000000000000;;	// used if recursive conversion calls are desired).  It must return an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example:
0000000000000000000000000000000000000000;;	// c.RegisterConversionFunc(
0000000000000000000000000000000000000000;;	//         func(in *Pod, out *v1.Pod, s Scope) error {
0000000000000000000000000000000000000000;;	//                 // conversion logic...
0000000000000000000000000000000000000000;;	//                 return nil
0000000000000000000000000000000000000000;;	//          })
0000000000000000000000000000000000000000;;	func (c *Converter) RegisterConversionFunc(conversionFunc interface{}) error {
0000000000000000000000000000000000000000;;		return c.conversionFuncs.Add(conversionFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Similar to RegisterConversionFunc, but registers conversion function that were
0000000000000000000000000000000000000000;;	// automatically generated.
0000000000000000000000000000000000000000;;	func (c *Converter) RegisterGeneratedConversionFunc(conversionFunc interface{}) error {
0000000000000000000000000000000000000000;;		return c.generatedConversionFuncs.Add(conversionFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterIgnoredConversion registers a "no-op" for conversion, where any requested
0000000000000000000000000000000000000000;;	// conversion between from and to is ignored.
0000000000000000000000000000000000000000;;	func (c *Converter) RegisterIgnoredConversion(from, to interface{}) error {
0000000000000000000000000000000000000000;;		typeFrom := reflect.TypeOf(from)
0000000000000000000000000000000000000000;;		typeTo := reflect.TypeOf(to)
0000000000000000000000000000000000000000;;		if reflect.TypeOf(from).Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected pointer arg for 'from' param 0, got: %v", typeFrom)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if typeTo.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected pointer arg for 'to' param 1, got: %v", typeTo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.ignoredConversions[typePair{typeFrom.Elem(), typeTo.Elem()}] = struct{}{}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsConversionIgnored returns true if the specified objects should be dropped during
0000000000000000000000000000000000000000;;	// conversion.
0000000000000000000000000000000000000000;;	func (c *Converter) IsConversionIgnored(inType, outType reflect.Type) bool {
0000000000000000000000000000000000000000;;		_, found := c.ignoredConversions[typePair{inType, outType}]
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Converter) HasConversionFunc(inType, outType reflect.Type) bool {
0000000000000000000000000000000000000000;;		_, found := c.conversionFuncs.fns[typePair{inType, outType}]
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Converter) ConversionFuncValue(inType, outType reflect.Type) (reflect.Value, bool) {
0000000000000000000000000000000000000000;;		value, found := c.conversionFuncs.fns[typePair{inType, outType}]
0000000000000000000000000000000000000000;;		return value, found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetStructFieldCopy registers a correspondence. Whenever a struct field is encountered
0000000000000000000000000000000000000000;;	// which has a type and name matching srcFieldType and srcFieldName, it wil be copied
0000000000000000000000000000000000000000;;	// into the field in the destination struct matching destFieldType & Name, if such a
0000000000000000000000000000000000000000;;	// field exists.
0000000000000000000000000000000000000000;;	// May be called multiple times, even for the same source field & type--all applicable
0000000000000000000000000000000000000000;;	// copies will be performed.
0000000000000000000000000000000000000000;;	func (c *Converter) SetStructFieldCopy(srcFieldType interface{}, srcFieldName string, destFieldType interface{}, destFieldName string) error {
0000000000000000000000000000000000000000;;		st := reflect.TypeOf(srcFieldType)
0000000000000000000000000000000000000000;;		dt := reflect.TypeOf(destFieldType)
0000000000000000000000000000000000000000;;		srcKey := typeNamePair{st, srcFieldName}
0000000000000000000000000000000000000000;;		destKey := typeNamePair{dt, destFieldName}
0000000000000000000000000000000000000000;;		c.structFieldDests[srcKey] = append(c.structFieldDests[srcKey], destKey)
0000000000000000000000000000000000000000;;		c.structFieldSources[destKey] = append(c.structFieldSources[destKey], srcKey)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterInputDefaults registers a field name mapping function, used when converting
0000000000000000000000000000000000000000;;	// from maps to structs. Inputs to the conversion methods are checked for this type and a mapping
0000000000000000000000000000000000000000;;	// applied automatically if the input matches in. A set of default flags for the input conversion
0000000000000000000000000000000000000000;;	// may also be provided, which will be used when no explicit flags are requested.
0000000000000000000000000000000000000000;;	func (c *Converter) RegisterInputDefaults(in interface{}, fn FieldMappingFunc, defaultFlags FieldMatchingFlags) error {
0000000000000000000000000000000000000000;;		fv := reflect.ValueOf(in)
0000000000000000000000000000000000000000;;		ft := fv.Type()
0000000000000000000000000000000000000000;;		if ft.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected pointer 'in' argument, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.inputFieldMappingFuncs[ft] = fn
0000000000000000000000000000000000000000;;		c.inputDefaultFlags[ft] = defaultFlags
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FieldMatchingFlags contains a list of ways in which struct fields could be
0000000000000000000000000000000000000000;;	// copied. These constants may be | combined.
0000000000000000000000000000000000000000;;	type FieldMatchingFlags int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Loop through destination fields, search for matching source
0000000000000000000000000000000000000000;;		// field to copy it from. Source fields with no corresponding
0000000000000000000000000000000000000000;;		// destination field will be ignored. If SourceToDest is
0000000000000000000000000000000000000000;;		// specified, this flag is ignored. If neither is specified,
0000000000000000000000000000000000000000;;		// or no flags are passed, this flag is the default.
0000000000000000000000000000000000000000;;		DestFromSource FieldMatchingFlags = 0
0000000000000000000000000000000000000000;;		// Loop through source fields, search for matching dest field
0000000000000000000000000000000000000000;;		// to copy it into. Destination fields with no corresponding
0000000000000000000000000000000000000000;;		// source field will be ignored.
0000000000000000000000000000000000000000;;		SourceToDest FieldMatchingFlags = 1 << iota
0000000000000000000000000000000000000000;;		// Don't treat it as an error if the corresponding source or
0000000000000000000000000000000000000000;;		// dest field can't be found.
0000000000000000000000000000000000000000;;		IgnoreMissingFields
0000000000000000000000000000000000000000;;		// Don't require type names to match.
0000000000000000000000000000000000000000;;		AllowDifferentFieldTypeNames
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSet returns true if the given flag or combination of flags is set.
0000000000000000000000000000000000000000;;	func (f FieldMatchingFlags) IsSet(flag FieldMatchingFlags) bool {
0000000000000000000000000000000000000000;;		if flag == DestFromSource {
0000000000000000000000000000000000000000;;			// The bit logic doesn't work on the default value.
0000000000000000000000000000000000000000;;			return f&SourceToDest != SourceToDest
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f&flag == flag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert will translate src to dest if it knows how. Both must be pointers.
0000000000000000000000000000000000000000;;	// If no conversion func is registered and the default copying mechanism
0000000000000000000000000000000000000000;;	// doesn't work on this type pair, an error will be returned.
0000000000000000000000000000000000000000;;	// Read the comments on the various FieldMatchingFlags constants to understand
0000000000000000000000000000000000000000;;	// what the 'flags' parameter does.
0000000000000000000000000000000000000000;;	// 'meta' is given to allow you to pass information to conversion functions,
0000000000000000000000000000000000000000;;	// it is not used by Convert() other than storing it in the scope.
0000000000000000000000000000000000000000;;	// Not safe for objects with cyclic references!
0000000000000000000000000000000000000000;;	func (c *Converter) Convert(src, dest interface{}, flags FieldMatchingFlags, meta *Meta) error {
0000000000000000000000000000000000000000;;		if len(c.genericConversions) > 0 {
0000000000000000000000000000000000000000;;			// TODO: avoid scope allocation
0000000000000000000000000000000000000000;;			s := &scope{converter: c, flags: flags, meta: meta}
0000000000000000000000000000000000000000;;			for _, fn := range c.genericConversions {
0000000000000000000000000000000000000000;;				if ok, err := fn(src, dest, s); ok {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.doConversion(src, dest, flags, meta, c.convert)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultConvert will translate src to dest if it knows how. Both must be pointers.
0000000000000000000000000000000000000000;;	// No conversion func is used. If the default copying mechanism
0000000000000000000000000000000000000000;;	// doesn't work on this type pair, an error will be returned.
0000000000000000000000000000000000000000;;	// Read the comments on the various FieldMatchingFlags constants to understand
0000000000000000000000000000000000000000;;	// what the 'flags' parameter does.
0000000000000000000000000000000000000000;;	// 'meta' is given to allow you to pass information to conversion functions,
0000000000000000000000000000000000000000;;	// it is not used by DefaultConvert() other than storing it in the scope.
0000000000000000000000000000000000000000;;	// Not safe for objects with cyclic references!
0000000000000000000000000000000000000000;;	func (c *Converter) DefaultConvert(src, dest interface{}, flags FieldMatchingFlags, meta *Meta) error {
0000000000000000000000000000000000000000;;		return c.doConversion(src, dest, flags, meta, c.defaultConvert)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type conversionFunc func(sv, dv reflect.Value, scope *scope) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Converter) doConversion(src, dest interface{}, flags FieldMatchingFlags, meta *Meta, f conversionFunc) error {
0000000000000000000000000000000000000000;;		dv, err := EnforcePtr(dest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !dv.CanAddr() && !dv.CanSet() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("can't write to dest")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sv, err := EnforcePtr(src)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := &scope{
0000000000000000000000000000000000000000;;			converter: c,
0000000000000000000000000000000000000000;;			flags:     flags,
0000000000000000000000000000000000000000;;			meta:      meta,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Leave something on the stack, so that calls to struct tag getters never fail.
0000000000000000000000000000000000000000;;		s.srcStack.push(scopeStackElem{})
0000000000000000000000000000000000000000;;		s.destStack.push(scopeStackElem{})
0000000000000000000000000000000000000000;;		return f(sv, dv, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// callCustom calls 'custom' with sv & dv. custom must be a conversion function.
0000000000000000000000000000000000000000;;	func (c *Converter) callCustom(sv, dv, custom reflect.Value, scope *scope) error {
0000000000000000000000000000000000000000;;		if !sv.CanAddr() {
0000000000000000000000000000000000000000;;			sv2 := reflect.New(sv.Type())
0000000000000000000000000000000000000000;;			sv2.Elem().Set(sv)
0000000000000000000000000000000000000000;;			sv = sv2
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sv = sv.Addr()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !dv.CanAddr() {
0000000000000000000000000000000000000000;;			if !dv.CanSet() {
0000000000000000000000000000000000000000;;				return scope.errorf("can't addr or set dest.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dvOrig := dv
0000000000000000000000000000000000000000;;			dv := reflect.New(dvOrig.Type())
0000000000000000000000000000000000000000;;			defer func() { dvOrig.Set(dv) }()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dv = dv.Addr()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args := []reflect.Value{sv, dv, reflect.ValueOf(scope)}
0000000000000000000000000000000000000000;;		ret := custom.Call(args)[0].Interface()
0000000000000000000000000000000000000000;;		// This convolution is necessary because nil interfaces won't convert
0000000000000000000000000000000000000000;;		// to errors.
0000000000000000000000000000000000000000;;		if ret == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret.(error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convert recursively copies sv into dv, calling an appropriate conversion function if
0000000000000000000000000000000000000000;;	// one is registered.
0000000000000000000000000000000000000000;;	func (c *Converter) convert(sv, dv reflect.Value, scope *scope) error {
0000000000000000000000000000000000000000;;		dt, st := dv.Type(), sv.Type()
0000000000000000000000000000000000000000;;		pair := typePair{st, dt}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ignore conversions of this type
0000000000000000000000000000000000000000;;		if _, ok := c.ignoredConversions[pair]; ok {
0000000000000000000000000000000000000000;;			if c.Debug != nil {
0000000000000000000000000000000000000000;;				c.Debug.Logf("Ignoring conversion of '%v' to '%v'", st, dt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert sv to dv.
0000000000000000000000000000000000000000;;		if fv, ok := c.conversionFuncs.fns[pair]; ok {
0000000000000000000000000000000000000000;;			if c.Debug != nil {
0000000000000000000000000000000000000000;;				c.Debug.Logf("Calling custom conversion of '%v' to '%v'", st, dt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return c.callCustom(sv, dv, fv, scope)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fv, ok := c.generatedConversionFuncs.fns[pair]; ok {
0000000000000000000000000000000000000000;;			if c.Debug != nil {
0000000000000000000000000000000000000000;;				c.Debug.Logf("Calling generated conversion of '%v' to '%v'", st, dt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return c.callCustom(sv, dv, fv, scope)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.defaultConvert(sv, dv, scope)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultConvert recursively copies sv into dv. no conversion function is called
0000000000000000000000000000000000000000;;	// for the current stack frame (but conversion functions may be called for nested objects)
0000000000000000000000000000000000000000;;	func (c *Converter) defaultConvert(sv, dv reflect.Value, scope *scope) error {
0000000000000000000000000000000000000000;;		dt, st := dv.Type(), sv.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !dv.CanSet() {
0000000000000000000000000000000000000000;;			return scope.errorf("Cannot set dest. (Tried to deep copy something with unexported fields?)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !scope.flags.IsSet(AllowDifferentFieldTypeNames) && c.nameFunc(dt) != c.nameFunc(st) {
0000000000000000000000000000000000000000;;			return scope.errorf(
0000000000000000000000000000000000000000;;				"type names don't match (%v, %v), and no conversion 'func (%v, %v) error' registered.",
0000000000000000000000000000000000000000;;				c.nameFunc(st), c.nameFunc(dt), st, dt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch st.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map, reflect.Ptr, reflect.Slice, reflect.Interface, reflect.Struct:
0000000000000000000000000000000000000000;;			// Don't copy these via assignment/conversion!
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// This should handle all simple types.
0000000000000000000000000000000000000000;;			if st.AssignableTo(dt) {
0000000000000000000000000000000000000000;;				dv.Set(sv)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if st.ConvertibleTo(dt) {
0000000000000000000000000000000000000000;;				dv.Set(sv.Convert(dt))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Debug != nil {
0000000000000000000000000000000000000000;;			c.Debug.Logf("Trying to convert '%v' to '%v'", st, dt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scope.srcStack.push(scopeStackElem{value: sv})
0000000000000000000000000000000000000000;;		scope.destStack.push(scopeStackElem{value: dv})
0000000000000000000000000000000000000000;;		defer scope.srcStack.pop()
0000000000000000000000000000000000000000;;		defer scope.destStack.pop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch dv.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return c.convertKV(toKVValue(sv), toKVValue(dv), scope)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if sv.IsNil() {
0000000000000000000000000000000000000000;;				// Don't make a zero-length slice.
0000000000000000000000000000000000000000;;				dv.Set(reflect.Zero(dt))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.MakeSlice(dt, sv.Len(), sv.Cap()))
0000000000000000000000000000000000000000;;			for i := 0; i < sv.Len(); i++ {
0000000000000000000000000000000000000000;;				scope.setIndices(i, i)
0000000000000000000000000000000000000000;;				if err := c.convert(sv.Index(i), dv.Index(i), scope); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if sv.IsNil() {
0000000000000000000000000000000000000000;;				// Don't copy a nil ptr!
0000000000000000000000000000000000000000;;				dv.Set(reflect.Zero(dt))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.New(dt.Elem()))
0000000000000000000000000000000000000000;;			switch st.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Ptr, reflect.Interface:
0000000000000000000000000000000000000000;;				return c.convert(sv.Elem(), dv.Elem(), scope)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return c.convert(sv, dv.Elem(), scope)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if sv.IsNil() {
0000000000000000000000000000000000000000;;				// Don't copy a nil ptr!
0000000000000000000000000000000000000000;;				dv.Set(reflect.Zero(dt))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.MakeMap(dt))
0000000000000000000000000000000000000000;;			for _, sk := range sv.MapKeys() {
0000000000000000000000000000000000000000;;				dk := reflect.New(dt.Key()).Elem()
0000000000000000000000000000000000000000;;				if err := c.convert(sk, dk, scope); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dkv := reflect.New(dt.Elem()).Elem()
0000000000000000000000000000000000000000;;				scope.setKeys(sk.Interface(), dk.Interface())
0000000000000000000000000000000000000000;;				// TODO:  sv.MapIndex(sk) may return a value with CanAddr() == false,
0000000000000000000000000000000000000000;;				// because a map[string]struct{} does not allow a pointer reference.
0000000000000000000000000000000000000000;;				// Calling a custom conversion function defined for the map value
0000000000000000000000000000000000000000;;				// will panic. Example is PodInfo map[string]ContainerStatus.
0000000000000000000000000000000000000000;;				if err := c.convert(sv.MapIndex(sk), dkv, scope); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dv.SetMapIndex(dk, dkv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if sv.IsNil() {
0000000000000000000000000000000000000000;;				// Don't copy a nil interface!
0000000000000000000000000000000000000000;;				dv.Set(reflect.Zero(dt))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tmpdv := reflect.New(sv.Elem().Type()).Elem()
0000000000000000000000000000000000000000;;			if err := c.convert(sv.Elem(), tmpdv, scope); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.ValueOf(tmpdv.Interface()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return scope.errorf("couldn't copy '%v' into '%v'; didn't understand types", st, dt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var stringType = reflect.TypeOf("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toKVValue(v reflect.Value) kvValue {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return structAdaptor(v)
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if v.Type().Key().AssignableTo(stringType) {
0000000000000000000000000000000000000000;;				return stringMapAdaptor(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// kvValue lets us write the same conversion logic to work with both maps
0000000000000000000000000000000000000000;;	// and structs. Only maps with string keys make sense for this.
0000000000000000000000000000000000000000;;	type kvValue interface {
0000000000000000000000000000000000000000;;		// returns all keys, as a []string.
0000000000000000000000000000000000000000;;		keys() []string
0000000000000000000000000000000000000000;;		// Will just return "" for maps.
0000000000000000000000000000000000000000;;		tagOf(key string) reflect.StructTag
0000000000000000000000000000000000000000;;		// Will return the zero Value if the key doesn't exist.
0000000000000000000000000000000000000000;;		value(key string) reflect.Value
0000000000000000000000000000000000000000;;		// Maps require explicit setting-- will do nothing for structs.
0000000000000000000000000000000000000000;;		// Returns false on failure.
0000000000000000000000000000000000000000;;		confirmSet(key string, v reflect.Value) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stringMapAdaptor reflect.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a stringMapAdaptor) len() int {
0000000000000000000000000000000000000000;;		return reflect.Value(a).Len()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a stringMapAdaptor) keys() []string {
0000000000000000000000000000000000000000;;		v := reflect.Value(a)
0000000000000000000000000000000000000000;;		keys := make([]string, v.Len())
0000000000000000000000000000000000000000;;		for i, v := range v.MapKeys() {
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t := v.Interface().(type) {
0000000000000000000000000000000000000000;;			case string:
0000000000000000000000000000000000000000;;				keys[i] = t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a stringMapAdaptor) tagOf(key string) reflect.StructTag {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a stringMapAdaptor) value(key string) reflect.Value {
0000000000000000000000000000000000000000;;		return reflect.Value(a).MapIndex(reflect.ValueOf(key))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a stringMapAdaptor) confirmSet(key string, v reflect.Value) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type structAdaptor reflect.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a structAdaptor) len() int {
0000000000000000000000000000000000000000;;		v := reflect.Value(a)
0000000000000000000000000000000000000000;;		return v.Type().NumField()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a structAdaptor) keys() []string {
0000000000000000000000000000000000000000;;		v := reflect.Value(a)
0000000000000000000000000000000000000000;;		t := v.Type()
0000000000000000000000000000000000000000;;		keys := make([]string, t.NumField())
0000000000000000000000000000000000000000;;		for i := range keys {
0000000000000000000000000000000000000000;;			keys[i] = t.Field(i).Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a structAdaptor) tagOf(key string) reflect.StructTag {
0000000000000000000000000000000000000000;;		v := reflect.Value(a)
0000000000000000000000000000000000000000;;		field, ok := v.Type().FieldByName(key)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return field.Tag
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a structAdaptor) value(key string) reflect.Value {
0000000000000000000000000000000000000000;;		v := reflect.Value(a)
0000000000000000000000000000000000000000;;		return v.FieldByName(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a structAdaptor) confirmSet(key string, v reflect.Value) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertKV can convert things that consist of key/value pairs, like structs
0000000000000000000000000000000000000000;;	// and some maps.
0000000000000000000000000000000000000000;;	func (c *Converter) convertKV(skv, dkv kvValue, scope *scope) error {
0000000000000000000000000000000000000000;;		if skv == nil || dkv == nil {
0000000000000000000000000000000000000000;;			// TODO: add keys to stack to support really understandable error messages.
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unable to convert %#v to %#v", skv, dkv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lister := dkv
0000000000000000000000000000000000000000;;		if scope.flags.IsSet(SourceToDest) {
0000000000000000000000000000000000000000;;			lister = skv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var mapping FieldMappingFunc
0000000000000000000000000000000000000000;;		if scope.meta != nil && scope.meta.KeyNameMapping != nil {
0000000000000000000000000000000000000000;;			mapping = scope.meta.KeyNameMapping
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, key := range lister.keys() {
0000000000000000000000000000000000000000;;			if found, err := c.checkField(key, skv, dkv, scope); found {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stag := skv.tagOf(key)
0000000000000000000000000000000000000000;;			dtag := dkv.tagOf(key)
0000000000000000000000000000000000000000;;			skey := key
0000000000000000000000000000000000000000;;			dkey := key
0000000000000000000000000000000000000000;;			if mapping != nil {
0000000000000000000000000000000000000000;;				skey, dkey = scope.meta.KeyNameMapping(key, stag, dtag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			df := dkv.value(dkey)
0000000000000000000000000000000000000000;;			sf := skv.value(skey)
0000000000000000000000000000000000000000;;			if !df.IsValid() || !sf.IsValid() {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case scope.flags.IsSet(IgnoreMissingFields):
0000000000000000000000000000000000000000;;					// No error.
0000000000000000000000000000000000000000;;				case scope.flags.IsSet(SourceToDest):
0000000000000000000000000000000000000000;;					return scope.errorf("%v not present in dest", dkey)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return scope.errorf("%v not present in src", skey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			scope.srcStack.top().key = skey
0000000000000000000000000000000000000000;;			scope.srcStack.top().tag = stag
0000000000000000000000000000000000000000;;			scope.destStack.top().key = dkey
0000000000000000000000000000000000000000;;			scope.destStack.top().tag = dtag
0000000000000000000000000000000000000000;;			if err := c.convert(sf, df, scope); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkField returns true if the field name matches any of the struct
0000000000000000000000000000000000000000;;	// field copying rules. The error should be ignored if it returns false.
0000000000000000000000000000000000000000;;	func (c *Converter) checkField(fieldName string, skv, dkv kvValue, scope *scope) (bool, error) {
0000000000000000000000000000000000000000;;		replacementMade := false
0000000000000000000000000000000000000000;;		if scope.flags.IsSet(DestFromSource) {
0000000000000000000000000000000000000000;;			df := dkv.value(fieldName)
0000000000000000000000000000000000000000;;			if !df.IsValid() {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			destKey := typeNamePair{df.Type(), fieldName}
0000000000000000000000000000000000000000;;			// Check each of the potential source (type, name) pairs to see if they're
0000000000000000000000000000000000000000;;			// present in sv.
0000000000000000000000000000000000000000;;			for _, potentialSourceKey := range c.structFieldSources[destKey] {
0000000000000000000000000000000000000000;;				sf := skv.value(potentialSourceKey.fieldName)
0000000000000000000000000000000000000000;;				if !sf.IsValid() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if sf.Type() == potentialSourceKey.fieldType {
0000000000000000000000000000000000000000;;					// Both the source's name and type matched, so copy.
0000000000000000000000000000000000000000;;					scope.srcStack.top().key = potentialSourceKey.fieldName
0000000000000000000000000000000000000000;;					scope.destStack.top().key = fieldName
0000000000000000000000000000000000000000;;					if err := c.convert(sf, df, scope); err != nil {
0000000000000000000000000000000000000000;;						return true, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dkv.confirmSet(fieldName, df)
0000000000000000000000000000000000000000;;					replacementMade = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return replacementMade, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sf := skv.value(fieldName)
0000000000000000000000000000000000000000;;		if !sf.IsValid() {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srcKey := typeNamePair{sf.Type(), fieldName}
0000000000000000000000000000000000000000;;		// Check each of the potential dest (type, name) pairs to see if they're
0000000000000000000000000000000000000000;;		// present in dv.
0000000000000000000000000000000000000000;;		for _, potentialDestKey := range c.structFieldDests[srcKey] {
0000000000000000000000000000000000000000;;			df := dkv.value(potentialDestKey.fieldName)
0000000000000000000000000000000000000000;;			if !df.IsValid() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if df.Type() == potentialDestKey.fieldType {
0000000000000000000000000000000000000000;;				// Both the dest's name and type matched, so copy.
0000000000000000000000000000000000000000;;				scope.srcStack.top().key = fieldName
0000000000000000000000000000000000000000;;				scope.destStack.top().key = potentialDestKey.fieldName
0000000000000000000000000000000000000000;;				if err := c.convert(sf, df, scope); err != nil {
0000000000000000000000000000000000000000;;					return true, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dkv.confirmSet(potentialDestKey.fieldName, df)
0000000000000000000000000000000000000000;;				replacementMade = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return replacementMade, nil
0000000000000000000000000000000000000000;;	}
