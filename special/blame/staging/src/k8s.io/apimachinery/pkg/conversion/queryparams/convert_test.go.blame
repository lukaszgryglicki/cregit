0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package queryparams_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion/queryparams"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type namedString string
0000000000000000000000000000000000000000;;	type namedBool bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bar struct {
0000000000000000000000000000000000000000;;		Float1   float32 `json:"float1"`
0000000000000000000000000000000000000000;;		Float2   float64 `json:"float2"`
0000000000000000000000000000000000000000;;		Int1     int64   `json:"int1,omitempty"`
0000000000000000000000000000000000000000;;		Int2     int32   `json:"int2,omitempty"`
0000000000000000000000000000000000000000;;		Int3     int16   `json:"int3,omitempty"`
0000000000000000000000000000000000000000;;		Str1     string  `json:"str1,omitempty"`
0000000000000000000000000000000000000000;;		Ignored  int
0000000000000000000000000000000000000000;;		Ignored2 string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *bar) GetObjectKind() schema.ObjectKind { return schema.EmptyObjectKind }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type foo struct {
0000000000000000000000000000000000000000;;		Str       string            `json:"str"`
0000000000000000000000000000000000000000;;		Integer   int               `json:"integer,omitempty"`
0000000000000000000000000000000000000000;;		Slice     []string          `json:"slice,omitempty"`
0000000000000000000000000000000000000000;;		Boolean   bool              `json:"boolean,omitempty"`
0000000000000000000000000000000000000000;;		NamedStr  namedString       `json:"namedStr,omitempty"`
0000000000000000000000000000000000000000;;		NamedBool namedBool         `json:"namedBool,omitempty"`
0000000000000000000000000000000000000000;;		Foobar    bar               `json:"foobar,omitempty"`
0000000000000000000000000000000000000000;;		Testmap   map[string]string `json:"testmap,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *foo) GetObjectKind() schema.ObjectKind { return schema.EmptyObjectKind }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type baz struct {
0000000000000000000000000000000000000000;;		Ptr  *int  `json:"ptr"`
0000000000000000000000000000000000000000;;		Bptr *bool `json:"bptr,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *baz) GetObjectKind() schema.ObjectKind { return schema.EmptyObjectKind }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// childStructs tests some of the types we serialize to query params for log API calls
0000000000000000000000000000000000000000;;	// notably, the nested time struct
0000000000000000000000000000000000000000;;	type childStructs struct {
0000000000000000000000000000000000000000;;		Container    string       `json:"container,omitempty"`
0000000000000000000000000000000000000000;;		Follow       bool         `json:"follow,omitempty"`
0000000000000000000000000000000000000000;;		Previous     bool         `json:"previous,omitempty"`
0000000000000000000000000000000000000000;;		SinceSeconds *int64       `json:"sinceSeconds,omitempty"`
0000000000000000000000000000000000000000;;		SinceTime    *metav1.Time `json:"sinceTime,omitempty"`
0000000000000000000000000000000000000000;;		EmptyTime    *metav1.Time `json:"emptyTime"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *childStructs) GetObjectKind() schema.ObjectKind { return schema.EmptyObjectKind }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateResult(t *testing.T, input interface{}, actual, expected url.Values) {
0000000000000000000000000000000000000000;;		local := url.Values{}
0000000000000000000000000000000000000000;;		for k, v := range expected {
0000000000000000000000000000000000000000;;			local[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range actual {
0000000000000000000000000000000000000000;;			if ev, ok := local[k]; !ok || !reflect.DeepEqual(ev, v) {
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Errorf("%#v: actual value key %s not found in expected map", input, k)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					t.Errorf("%#v: values don't match: actual: %#v, expected: %#v", input, v, ev)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(local, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(local) > 0 {
0000000000000000000000000000000000000000;;			t.Errorf("%#v: expected map has keys that were not found in actual map: %#v", input, local)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConvert(t *testing.T) {
0000000000000000000000000000000000000000;;		sinceSeconds := int64(123)
0000000000000000000000000000000000000000;;		sinceTime := metav1.Date(2000, 1, 1, 12, 34, 56, 0, time.UTC)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input    interface{}
0000000000000000000000000000000000000000;;			expected url.Values
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: &foo{
0000000000000000000000000000000000000000;;					Str: "hello",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"str": {"hello"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: &foo{
0000000000000000000000000000000000000000;;					Str:     "test string",
0000000000000000000000000000000000000000;;					Slice:   []string{"one", "two", "three"},
0000000000000000000000000000000000000000;;					Integer: 234,
0000000000000000000000000000000000000000;;					Boolean: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"str": {"test string"}, "slice": {"one", "two", "three"}, "integer": {"234"}, "boolean": {"true"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: &foo{
0000000000000000000000000000000000000000;;					Str:       "named types",
0000000000000000000000000000000000000000;;					NamedStr:  "value1",
0000000000000000000000000000000000000000;;					NamedBool: true,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"str": {"named types"}, "namedStr": {"value1"}, "namedBool": {"true"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: &foo{
0000000000000000000000000000000000000000;;					Str: "don't ignore embedded struct",
0000000000000000000000000000000000000000;;					Foobar: bar{
0000000000000000000000000000000000000000;;						Float1: 5.0,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"str": {"don't ignore embedded struct"}, "float1": {"5"}, "float2": {"0"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Ignore untagged fields
0000000000000000000000000000000000000000;;				input: &bar{
0000000000000000000000000000000000000000;;					Float1:   23.5,
0000000000000000000000000000000000000000;;					Float2:   100.7,
0000000000000000000000000000000000000000;;					Int1:     1,
0000000000000000000000000000000000000000;;					Int2:     2,
0000000000000000000000000000000000000000;;					Int3:     3,
0000000000000000000000000000000000000000;;					Ignored:  1,
0000000000000000000000000000000000000000;;					Ignored2: "ignored",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"float1": {"23.5"}, "float2": {"100.7"}, "int1": {"1"}, "int2": {"2"}, "int3": {"3"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// include fields that are not tagged omitempty
0000000000000000000000000000000000000000;;				input: &foo{
0000000000000000000000000000000000000000;;					NamedStr: "named str",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"str": {""}, "namedStr": {"named str"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: &baz{
0000000000000000000000000000000000000000;;					Ptr:  intp(5),
0000000000000000000000000000000000000000;;					Bptr: boolp(true),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"ptr": {"5"}, "bptr": {"true"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: &baz{
0000000000000000000000000000000000000000;;					Bptr: boolp(true),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"ptr": {""}, "bptr": {"true"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: &baz{
0000000000000000000000000000000000000000;;					Ptr: intp(5),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"ptr": {"5"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: &childStructs{
0000000000000000000000000000000000000000;;					Container:    "mycontainer",
0000000000000000000000000000000000000000;;					Follow:       true,
0000000000000000000000000000000000000000;;					Previous:     true,
0000000000000000000000000000000000000000;;					SinceSeconds: &sinceSeconds,
0000000000000000000000000000000000000000;;					SinceTime:    &sinceTime, // test a custom marshaller
0000000000000000000000000000000000000000;;					EmptyTime:    nil,        // test a nil custom marshaller without omitempty
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"container": {"mycontainer"}, "follow": {"true"}, "previous": {"true"}, "sinceSeconds": {"123"}, "sinceTime": {"2000-01-01T12:34:56Z"}, "emptyTime": {""}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input: &childStructs{
0000000000000000000000000000000000000000;;					Container:    "mycontainer",
0000000000000000000000000000000000000000;;					Follow:       true,
0000000000000000000000000000000000000000;;					Previous:     true,
0000000000000000000000000000000000000000;;					SinceSeconds: &sinceSeconds,
0000000000000000000000000000000000000000;;					SinceTime:    nil, // test a nil custom marshaller with omitempty
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: url.Values{"container": {"mycontainer"}, "follow": {"true"}, "previous": {"true"}, "sinceSeconds": {"123"}, "emptyTime": {""}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			result, err := queryparams.Convert(test.input)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error while converting %#v: %v", test.input, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			validateResult(t, test.input, result, test.expected)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func intp(n int) *int { return &n }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func boolp(b bool) *bool { return &b }
