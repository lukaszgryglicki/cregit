0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package conversion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var fuzzIters = flag.Int("fuzz-iters", 50, "How many fuzzing iterations to do.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test a weird version/kind embedding format.
0000000000000000000000000000000000000000;;	type MyWeirdCustomEmbeddedVersionKindField struct {
0000000000000000000000000000000000000000;;		ID         string `json:"ID,omitempty"`
0000000000000000000000000000000000000000;;		APIVersion string `json:"myVersionKey,omitempty"`
0000000000000000000000000000000000000000;;		ObjectKind string `json:"myKindKey,omitempty"`
0000000000000000000000000000000000000000;;		Z          string `json:"Z,omitempty"`
0000000000000000000000000000000000000000;;		Y          uint64 `json:"Y,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestType1 struct {
0000000000000000000000000000000000000000;;		MyWeirdCustomEmbeddedVersionKindField `json:",inline"`
0000000000000000000000000000000000000000;;		A                                     string               `json:"A,omitempty"`
0000000000000000000000000000000000000000;;		B                                     int                  `json:"B,omitempty"`
0000000000000000000000000000000000000000;;		C                                     int8                 `json:"C,omitempty"`
0000000000000000000000000000000000000000;;		D                                     int16                `json:"D,omitempty"`
0000000000000000000000000000000000000000;;		E                                     int32                `json:"E,omitempty"`
0000000000000000000000000000000000000000;;		F                                     int64                `json:"F,omitempty"`
0000000000000000000000000000000000000000;;		G                                     uint                 `json:"G,omitempty"`
0000000000000000000000000000000000000000;;		H                                     uint8                `json:"H,omitempty"`
0000000000000000000000000000000000000000;;		I                                     uint16               `json:"I,omitempty"`
0000000000000000000000000000000000000000;;		J                                     uint32               `json:"J,omitempty"`
0000000000000000000000000000000000000000;;		K                                     uint64               `json:"K,omitempty"`
0000000000000000000000000000000000000000;;		L                                     bool                 `json:"L,omitempty"`
0000000000000000000000000000000000000000;;		M                                     map[string]int       `json:"M,omitempty"`
0000000000000000000000000000000000000000;;		N                                     map[string]TestType2 `json:"N,omitempty"`
0000000000000000000000000000000000000000;;		O                                     *TestType2           `json:"O,omitempty"`
0000000000000000000000000000000000000000;;		P                                     []TestType2          `json:"Q,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TestType2 struct {
0000000000000000000000000000000000000000;;		A string `json:"A,omitempty"`
0000000000000000000000000000000000000000;;		B int    `json:"B,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ExternalTestType2 struct {
0000000000000000000000000000000000000000;;		A string `json:"A,omitempty"`
0000000000000000000000000000000000000000;;		B int    `json:"B,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type ExternalTestType1 struct {
0000000000000000000000000000000000000000;;		MyWeirdCustomEmbeddedVersionKindField `json:",inline"`
0000000000000000000000000000000000000000;;		A                                     string                       `json:"A,omitempty"`
0000000000000000000000000000000000000000;;		B                                     int                          `json:"B,omitempty"`
0000000000000000000000000000000000000000;;		C                                     int8                         `json:"C,omitempty"`
0000000000000000000000000000000000000000;;		D                                     int16                        `json:"D,omitempty"`
0000000000000000000000000000000000000000;;		E                                     int32                        `json:"E,omitempty"`
0000000000000000000000000000000000000000;;		F                                     int64                        `json:"F,omitempty"`
0000000000000000000000000000000000000000;;		G                                     uint                         `json:"G,omitempty"`
0000000000000000000000000000000000000000;;		H                                     uint8                        `json:"H,omitempty"`
0000000000000000000000000000000000000000;;		I                                     uint16                       `json:"I,omitempty"`
0000000000000000000000000000000000000000;;		J                                     uint32                       `json:"J,omitempty"`
0000000000000000000000000000000000000000;;		K                                     uint64                       `json:"K,omitempty"`
0000000000000000000000000000000000000000;;		L                                     bool                         `json:"L,omitempty"`
0000000000000000000000000000000000000000;;		M                                     map[string]int               `json:"M,omitempty"`
0000000000000000000000000000000000000000;;		N                                     map[string]ExternalTestType2 `json:"N,omitempty"`
0000000000000000000000000000000000000000;;		O                                     *ExternalTestType2           `json:"O,omitempty"`
0000000000000000000000000000000000000000;;		P                                     []ExternalTestType2          `json:"Q,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testLogger(t *testing.T) DebugLogger {
0000000000000000000000000000000000000000;;		// We don't set logger to eliminate rubbish logs in tests.
0000000000000000000000000000000000000000;;		// If you want to switch it, simply switch it to: "return t"
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_byteSlice(t *testing.T) {
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		src := []byte{1, 2, 3}
0000000000000000000000000000000000000000;;		dest := []byte{}
0000000000000000000000000000000000000000;;		err := c.Convert(&src, &dest, 0, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("expected no error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := src, dest; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_MismatchedTypes(t *testing.T) {
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := c.RegisterConversionFunc(
0000000000000000000000000000000000000000;;			func(in *[]string, out *int, s Scope) error {
0000000000000000000000000000000000000000;;				if str, err := strconv.Atoi((*in)[0]); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					*out = str
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		src := []string{"5"}
0000000000000000000000000000000000000000;;		var dest *int
0000000000000000000000000000000000000000;;		err = c.Convert(&src, &dest, 0, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 5, *dest; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_DefaultConvert(t *testing.T) {
0000000000000000000000000000000000000000;;		type A struct {
0000000000000000000000000000000000000000;;			Foo string
0000000000000000000000000000000000000000;;			Baz int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type B struct {
0000000000000000000000000000000000000000;;			Bar string
0000000000000000000000000000000000000000;;			Baz int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;		c.nameFunc = func(t reflect.Type) string { return "MyType" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure conversion funcs can call DefaultConvert to get default behavior,
0000000000000000000000000000000000000000;;		// then fixup remaining fields manually
0000000000000000000000000000000000000000;;		err := c.RegisterConversionFunc(func(in *A, out *B, s Scope) error {
0000000000000000000000000000000000000000;;			if err := s.DefaultConvert(in, out, IgnoreMissingFields); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Bar = in.Foo
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := A{"hello, intrepid test reader!", 3}
0000000000000000000000000000000000000000;;		y := B{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.Convert(&x, &y, 0, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := x.Foo, y.Bar; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := x.Baz, y.Baz; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_DeepCopy(t *testing.T) {
0000000000000000000000000000000000000000;;		type A struct {
0000000000000000000000000000000000000000;;			Foo *string
0000000000000000000000000000000000000000;;			Bar []string
0000000000000000000000000000000000000000;;			Baz interface{}
0000000000000000000000000000000000000000;;			Qux map[string]string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		foo, baz := "foo", "baz"
0000000000000000000000000000000000000000;;		x := A{
0000000000000000000000000000000000000000;;			Foo: &foo,
0000000000000000000000000000000000000000;;			Bar: []string{"bar"},
0000000000000000000000000000000000000000;;			Baz: &baz,
0000000000000000000000000000000000000000;;			Qux: map[string]string{"qux": "qux"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		y := A{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.Convert(&x, &y, 0, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*x.Foo = "foo2"
0000000000000000000000000000000000000000;;		x.Bar[0] = "bar2"
0000000000000000000000000000000000000000;;		*x.Baz.(*string) = "baz2"
0000000000000000000000000000000000000000;;		x.Qux["qux"] = "qux2"
0000000000000000000000000000000000000000;;		if e, a := *x.Foo, *y.Foo; e == a {
0000000000000000000000000000000000000000;;			t.Errorf("expected difference between %v and %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := x.Bar, y.Bar; reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("expected difference between %v and %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := *x.Baz.(*string), *y.Baz.(*string); e == a {
0000000000000000000000000000000000000000;;			t.Errorf("expected difference between %v and %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := x.Qux, y.Qux; reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("expected difference between %v and %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_CallsRegisteredFunctions(t *testing.T) {
0000000000000000000000000000000000000000;;		type A struct {
0000000000000000000000000000000000000000;;			Foo string
0000000000000000000000000000000000000000;;			Baz int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type B struct {
0000000000000000000000000000000000000000;;			Bar string
0000000000000000000000000000000000000000;;			Baz int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type C struct{}
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;		err := c.RegisterConversionFunc(func(in *A, out *B, s Scope) error {
0000000000000000000000000000000000000000;;			out.Bar = in.Foo
0000000000000000000000000000000000000000;;			return s.Convert(&in.Baz, &out.Baz, 0)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.RegisterConversionFunc(func(in *B, out *A, s Scope) error {
0000000000000000000000000000000000000000;;			out.Foo = in.Bar
0000000000000000000000000000000000000000;;			return s.Convert(&in.Baz, &out.Baz, 0)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := A{"hello, intrepid test reader!", 3}
0000000000000000000000000000000000000000;;		y := B{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.Convert(&x, &y, 0, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := x.Foo, y.Bar; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := x.Baz, y.Baz; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		z := B{"all your test are belong to us", 42}
0000000000000000000000000000000000000000;;		w := A{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.Convert(&z, &w, 0, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := z.Bar, w.Foo; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := z.Baz, w.Baz; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.RegisterConversionFunc(func(in *A, out *C, s Scope) error {
0000000000000000000000000000000000000000;;			return fmt.Errorf("C can't store an A, silly")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.Convert(&A{}, &C{}, 0, nil)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_IgnoredConversion(t *testing.T) {
0000000000000000000000000000000000000000;;		type A struct{}
0000000000000000000000000000000000000000;;		type B struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		if err := c.RegisterConversionFunc(func(in *A, out *B, s Scope) error {
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.RegisterIgnoredConversion(&A{}, &B{}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a := A{}
0000000000000000000000000000000000000000;;		b := B{}
0000000000000000000000000000000000000000;;		if err := c.Convert(&a, &b, 0, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected number of conversion invocations")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_IgnoredConversionNested(t *testing.T) {
0000000000000000000000000000000000000000;;		type C string
0000000000000000000000000000000000000000;;		type A struct {
0000000000000000000000000000000000000000;;			C C
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type B struct {
0000000000000000000000000000000000000000;;			C C
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		typed := C("")
0000000000000000000000000000000000000000;;		if err := c.RegisterIgnoredConversion(&typed, &typed); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a := A{C: C("test")}
0000000000000000000000000000000000000000;;		b := B{C: C("other")}
0000000000000000000000000000000000000000;;		if err := c.Convert(&a, &b, AllowDifferentFieldTypeNames, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b.C != C("other") {
0000000000000000000000000000000000000000;;			t.Errorf("expected no conversion of field C: %#v", b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_GeneratedConversionOverriden(t *testing.T) {
0000000000000000000000000000000000000000;;		type A struct{}
0000000000000000000000000000000000000000;;		type B struct{}
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		if err := c.RegisterConversionFunc(func(in *A, out *B, s Scope) error {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.RegisterGeneratedConversionFunc(func(in *A, out *B, s Scope) error {
0000000000000000000000000000000000000000;;			return fmt.Errorf("generated function should be overriden")
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := A{}
0000000000000000000000000000000000000000;;		b := B{}
0000000000000000000000000000000000000000;;		if err := c.Convert(&a, &b, 0, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_WithConversionOverriden(t *testing.T) {
0000000000000000000000000000000000000000;;		type A struct{}
0000000000000000000000000000000000000000;;		type B struct{}
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		if err := c.RegisterConversionFunc(func(in *A, out *B, s Scope) error {
0000000000000000000000000000000000000000;;			return fmt.Errorf("conversion function should be overriden")
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.RegisterGeneratedConversionFunc(func(in *A, out *B, s Scope) error {
0000000000000000000000000000000000000000;;			return fmt.Errorf("generated function should be overriden")
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ext := NewConversionFuncs()
0000000000000000000000000000000000000000;;		ext.Add(func(in *A, out *B, s Scope) error {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		newc := c.WithConversions(ext)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := A{}
0000000000000000000000000000000000000000;;		b := B{}
0000000000000000000000000000000000000000;;		if err := c.Convert(&a, &b, 0, nil); err == nil || err.Error() != "conversion function should be overriden" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := newc.Convert(&a, &b, 0, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_MapsStringArrays(t *testing.T) {
0000000000000000000000000000000000000000;;		type A struct {
0000000000000000000000000000000000000000;;			Foo   string
0000000000000000000000000000000000000000;;			Baz   int
0000000000000000000000000000000000000000;;			Other string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;		if err := c.RegisterConversionFunc(func(input *[]string, out *string, s Scope) error {
0000000000000000000000000000000000000000;;			if len(*input) == 0 {
0000000000000000000000000000000000000000;;				*out = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*out = (*input)[0]
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := map[string][]string{
0000000000000000000000000000000000000000;;			"Foo":   {"bar"},
0000000000000000000000000000000000000000;;			"Baz":   {"1"},
0000000000000000000000000000000000000000;;			"Other": {"", "test"},
0000000000000000000000000000000000000000;;			"other": {"wrong"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		y := A{"test", 2, "something"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.Convert(&x, &y, AllowDifferentFieldTypeNames, nil); err == nil {
0000000000000000000000000000000000000000;;			t.Error("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.RegisterConversionFunc(func(input *[]string, out *int, s Scope) error {
0000000000000000000000000000000000000000;;			if len(*input) == 0 {
0000000000000000000000000000000000000000;;				*out = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			str := (*input)[0]
0000000000000000000000000000000000000000;;			i, err := strconv.Atoi(str)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*out = i
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.Convert(&x, &y, AllowDifferentFieldTypeNames, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(y, A{"bar", 1, ""}) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected result: %#v", y)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_MapsStringArraysWithMappingKey(t *testing.T) {
0000000000000000000000000000000000000000;;		type A struct {
0000000000000000000000000000000000000000;;			Foo   string `json:"test"`
0000000000000000000000000000000000000000;;			Baz   int
0000000000000000000000000000000000000000;;			Other string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;		if err := c.RegisterConversionFunc(func(input *[]string, out *string, s Scope) error {
0000000000000000000000000000000000000000;;			if len(*input) == 0 {
0000000000000000000000000000000000000000;;				*out = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*out = (*input)[0]
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := map[string][]string{
0000000000000000000000000000000000000000;;			"Foo":  {"bar"},
0000000000000000000000000000000000000000;;			"test": {"baz"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		y := A{"", 0, ""}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.Convert(&x, &y, AllowDifferentFieldTypeNames|IgnoreMissingFields, &Meta{}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(y, A{"bar", 0, ""}) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected result: %#v", y)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapping := func(key string, sourceTag, destTag reflect.StructTag) (source string, dest string) {
0000000000000000000000000000000000000000;;			if s := destTag.Get("json"); len(s) > 0 {
0000000000000000000000000000000000000000;;				return strings.SplitN(s, ",", 2)[0], key
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return key, key
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := c.Convert(&x, &y, AllowDifferentFieldTypeNames|IgnoreMissingFields, &Meta{KeyNameMapping: mapping}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(y, A{"baz", 0, ""}) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected result: %#v", y)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_fuzz(t *testing.T) {
0000000000000000000000000000000000000000;;		// Use the same types from the scheme test.
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			from, to, check interface{}
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&TestType1{}, &ExternalTestType1{}, &TestType1{}},
0000000000000000000000000000000000000000;;			{&ExternalTestType1{}, &TestType1{}, &ExternalTestType1{}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := fuzz.New().NilChance(.5).NumElements(0, 100)
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		c.nameFunc = func(t reflect.Type) string {
0000000000000000000000000000000000000000;;			// Hide the fact that we don't have separate packages for these things.
0000000000000000000000000000000000000000;;			return map[reflect.Type]string{
0000000000000000000000000000000000000000;;				reflect.TypeOf(TestType1{}):         "TestType1",
0000000000000000000000000000000000000000;;				reflect.TypeOf(ExternalTestType1{}): "TestType1",
0000000000000000000000000000000000000000;;				reflect.TypeOf(TestType2{}):         "TestType2",
0000000000000000000000000000000000000000;;				reflect.TypeOf(ExternalTestType2{}): "TestType2",
0000000000000000000000000000000000000000;;			}[t]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, item := range table {
0000000000000000000000000000000000000000;;			for j := 0; j < *fuzzIters; j++ {
0000000000000000000000000000000000000000;;				f.Fuzz(item.from)
0000000000000000000000000000000000000000;;				err := c.Convert(item.from, item.to, 0, nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("(%v, %v): unexpected error: %v", i, j, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = c.Convert(item.to, item.check, 0, nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("(%v, %v): unexpected error: %v", i, j, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := item.from, item.check; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;					t.Errorf("(%v, %v): unexpected diff: %v", i, j, diff.ObjectDiff(e, a))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_MapElemAddr(t *testing.T) {
0000000000000000000000000000000000000000;;		type Foo struct {
0000000000000000000000000000000000000000;;			A map[int]int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type Bar struct {
0000000000000000000000000000000000000000;;			A map[string]string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;		err := c.RegisterConversionFunc(
0000000000000000000000000000000000000000;;			func(in *int, out *string, s Scope) error {
0000000000000000000000000000000000000000;;				*out = fmt.Sprintf("%v", *in)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.RegisterConversionFunc(
0000000000000000000000000000000000000000;;			func(in *string, out *int, s Scope) error {
0000000000000000000000000000000000000000;;				if str, err := strconv.Atoi(*in); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					*out = str
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f := fuzz.New().NilChance(0).NumElements(3, 3)
0000000000000000000000000000000000000000;;		first := Foo{}
0000000000000000000000000000000000000000;;		second := Bar{}
0000000000000000000000000000000000000000;;		f.Fuzz(&first)
0000000000000000000000000000000000000000;;		err = c.Convert(&first, &second, AllowDifferentFieldTypeNames, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		third := Foo{}
0000000000000000000000000000000000000000;;		err = c.Convert(&second, &third, AllowDifferentFieldTypeNames, nil)
0000000000000000000000000000000000000000;;		if e, a := first, third; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected diff: %v", diff.ObjectDiff(e, a))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_tags(t *testing.T) {
0000000000000000000000000000000000000000;;		type Foo struct {
0000000000000000000000000000000000000000;;			A string `test:"foo"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type Bar struct {
0000000000000000000000000000000000000000;;			A string `test:"bar"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;		err := c.RegisterConversionFunc(
0000000000000000000000000000000000000000;;			func(in *string, out *string, s Scope) error {
0000000000000000000000000000000000000000;;				if e, a := "foo", s.SrcTag().Get("test"); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := "bar", s.DestTag().Get("test"); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.Convert(&Foo{}, &Bar{}, AllowDifferentFieldTypeNames, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_meta(t *testing.T) {
0000000000000000000000000000000000000000;;		type Foo struct{ A string }
0000000000000000000000000000000000000000;;		type Bar struct{ A string }
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;		checks := 0
0000000000000000000000000000000000000000;;		err := c.RegisterConversionFunc(
0000000000000000000000000000000000000000;;			func(in *Foo, out *Bar, s Scope) error {
0000000000000000000000000000000000000000;;				if s.Meta() == nil {
0000000000000000000000000000000000000000;;					t.Errorf("Meta did not get passed!")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				checks++
0000000000000000000000000000000000000000;;				s.Convert(&in.A, &out.A, 0)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.RegisterConversionFunc(
0000000000000000000000000000000000000000;;			func(in *string, out *string, s Scope) error {
0000000000000000000000000000000000000000;;				if s.Meta() == nil {
0000000000000000000000000000000000000000;;					t.Errorf("Meta did not get passed a second time!")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				checks++
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.Convert(&Foo{}, &Bar{}, 0, &Meta{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if checks != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("Registered functions did not get called.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_flags(t *testing.T) {
0000000000000000000000000000000000000000;;		type Foo struct{ A string }
0000000000000000000000000000000000000000;;		type Bar struct{ A string }
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			from, to      interface{}
0000000000000000000000000000000000000000;;			flags         FieldMatchingFlags
0000000000000000000000000000000000000000;;			shouldSucceed bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Check that DestFromSource allows extra fields only in source.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				from:          &struct{ A string }{},
0000000000000000000000000000000000000000;;				to:            &struct{ A, B string }{},
0000000000000000000000000000000000000000;;				flags:         DestFromSource,
0000000000000000000000000000000000000000;;				shouldSucceed: false,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				from:          &struct{ A, B string }{},
0000000000000000000000000000000000000000;;				to:            &struct{ A string }{},
0000000000000000000000000000000000000000;;				flags:         DestFromSource,
0000000000000000000000000000000000000000;;				shouldSucceed: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check that SourceToDest allows for extra fields only in dest.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				from:          &struct{ A string }{},
0000000000000000000000000000000000000000;;				to:            &struct{ A, B string }{},
0000000000000000000000000000000000000000;;				flags:         SourceToDest,
0000000000000000000000000000000000000000;;				shouldSucceed: true,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				from:          &struct{ A, B string }{},
0000000000000000000000000000000000000000;;				to:            &struct{ A string }{},
0000000000000000000000000000000000000000;;				flags:         SourceToDest,
0000000000000000000000000000000000000000;;				shouldSucceed: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check that IgnoreMissingFields makes the above failure cases pass.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				from:          &struct{ A string }{},
0000000000000000000000000000000000000000;;				to:            &struct{ A, B string }{},
0000000000000000000000000000000000000000;;				flags:         DestFromSource | IgnoreMissingFields,
0000000000000000000000000000000000000000;;				shouldSucceed: true,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				from:          &struct{ A, B string }{},
0000000000000000000000000000000000000000;;				to:            &struct{ A string }{},
0000000000000000000000000000000000000000;;				flags:         SourceToDest | IgnoreMissingFields,
0000000000000000000000000000000000000000;;				shouldSucceed: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check that the field type name must match unless
0000000000000000000000000000000000000000;;			// AllowDifferentFieldTypeNames is specified.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				from:          &struct{ A, B Foo }{},
0000000000000000000000000000000000000000;;				to:            &struct{ A Bar }{},
0000000000000000000000000000000000000000;;				flags:         DestFromSource,
0000000000000000000000000000000000000000;;				shouldSucceed: false,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				from:          &struct{ A Foo }{},
0000000000000000000000000000000000000000;;				to:            &struct{ A, B Bar }{},
0000000000000000000000000000000000000000;;				flags:         SourceToDest,
0000000000000000000000000000000000000000;;				shouldSucceed: false,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				from:          &struct{ A, B Foo }{},
0000000000000000000000000000000000000000;;				to:            &struct{ A Bar }{},
0000000000000000000000000000000000000000;;				flags:         DestFromSource | AllowDifferentFieldTypeNames,
0000000000000000000000000000000000000000;;				shouldSucceed: true,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				from:          &struct{ A Foo }{},
0000000000000000000000000000000000000000;;				to:            &struct{ A, B Bar }{},
0000000000000000000000000000000000000000;;				flags:         SourceToDest | AllowDifferentFieldTypeNames,
0000000000000000000000000000000000000000;;				shouldSucceed: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f := fuzz.New().NilChance(.5).NumElements(0, 100)
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, item := range table {
0000000000000000000000000000000000000000;;			for j := 0; j < *fuzzIters; j++ {
0000000000000000000000000000000000000000;;				f.Fuzz(item.from)
0000000000000000000000000000000000000000;;				err := c.Convert(item.from, item.to, item.flags, nil)
0000000000000000000000000000000000000000;;				if item.shouldSucceed && err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("(%v, %v): unexpected error: %v", i, j, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !item.shouldSucceed && err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("(%v, %v): unexpected non-error", i, j)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConverter_FieldRename(t *testing.T) {
0000000000000000000000000000000000000000;;		type WeirdMeta struct {
0000000000000000000000000000000000000000;;			Name string
0000000000000000000000000000000000000000;;			Type string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type NameMeta struct {
0000000000000000000000000000000000000000;;			Name string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type TypeMeta struct {
0000000000000000000000000000000000000000;;			Type string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type A struct {
0000000000000000000000000000000000000000;;			WeirdMeta
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type B struct {
0000000000000000000000000000000000000000;;			TypeMeta
0000000000000000000000000000000000000000;;			NameMeta
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := NewConverter(DefaultNameFunc)
0000000000000000000000000000000000000000;;		err := c.SetStructFieldCopy(WeirdMeta{}, "WeirdMeta", TypeMeta{}, "TypeMeta")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.SetStructFieldCopy(WeirdMeta{}, "WeirdMeta", NameMeta{}, "NameMeta")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.SetStructFieldCopy(TypeMeta{}, "TypeMeta", WeirdMeta{}, "WeirdMeta")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.SetStructFieldCopy(NameMeta{}, "NameMeta", WeirdMeta{}, "WeirdMeta")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Debug = testLogger(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aVal := &A{
0000000000000000000000000000000000000000;;			WeirdMeta: WeirdMeta{
0000000000000000000000000000000000000000;;				Name: "Foo",
0000000000000000000000000000000000000000;;				Type: "Bar",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bVal := &B{
0000000000000000000000000000000000000000;;			TypeMeta: TypeMeta{"Bar"},
0000000000000000000000000000000000000000;;			NameMeta: NameMeta{"Foo"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := map[string]struct {
0000000000000000000000000000000000000000;;			from, to, expect interface{}
0000000000000000000000000000000000000000;;			flags            FieldMatchingFlags
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"to": {
0000000000000000000000000000000000000000;;				aVal,
0000000000000000000000000000000000000000;;				&B{},
0000000000000000000000000000000000000000;;				bVal,
0000000000000000000000000000000000000000;;				AllowDifferentFieldTypeNames | SourceToDest | IgnoreMissingFields,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"from": {
0000000000000000000000000000000000000000;;				bVal,
0000000000000000000000000000000000000000;;				&A{},
0000000000000000000000000000000000000000;;				aVal,
0000000000000000000000000000000000000000;;				AllowDifferentFieldTypeNames | SourceToDest,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"toDestFirst": {
0000000000000000000000000000000000000000;;				aVal,
0000000000000000000000000000000000000000;;				&B{},
0000000000000000000000000000000000000000;;				bVal,
0000000000000000000000000000000000000000;;				AllowDifferentFieldTypeNames,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"fromDestFirst": {
0000000000000000000000000000000000000000;;				bVal,
0000000000000000000000000000000000000000;;				&A{},
0000000000000000000000000000000000000000;;				aVal,
0000000000000000000000000000000000000000;;				AllowDifferentFieldTypeNames | IgnoreMissingFields,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, item := range table {
0000000000000000000000000000000000000000;;			err := c.Convert(item.from, item.to, item.flags, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected error: %v", name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.expect, item.to; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected diff: %v", name, diff.ObjectDiff(e, a))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
