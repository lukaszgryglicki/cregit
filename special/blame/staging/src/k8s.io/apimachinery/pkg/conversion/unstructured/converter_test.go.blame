0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
a239f93b629e7ef907f2c22ab7cdb9b72f244c0d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unstructured
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Definte a number of test types.
0000000000000000000000000000000000000000;;	type A struct {
0000000000000000000000000000000000000000;;		A int    `json:"aa,omitempty"`
0000000000000000000000000000000000000000;;		B string `json:"ab,omitempty"`
0000000000000000000000000000000000000000;;		C bool   `json:"ac,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type B struct {
0000000000000000000000000000000000000000;;		A A                 `json:"ba"`
0000000000000000000000000000000000000000;;		B string            `json:"bb"`
0000000000000000000000000000000000000000;;		C map[string]string `json:"bc"`
0000000000000000000000000000000000000000;;		D []string          `json:"bd"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type C struct {
0000000000000000000000000000000000000000;;		A []A `json:"ca"`
0000000000000000000000000000000000000000;;		B `json:",inline"`
0000000000000000000000000000000000000000;;		C string         `json:"cc"`
0000000000000000000000000000000000000000;;		D *int64         `json:"cd"`
0000000000000000000000000000000000000000;;		E map[string]int `json:"ce"`
0000000000000000000000000000000000000000;;		F []bool         `json:"cf"`
0000000000000000000000000000000000000000;;		G []int          `json:"cg"`
0000000000000000000000000000000000000000;;		H float32        `json:"ch"`
0000000000000000000000000000000000000000;;		I []interface{}  `json:"ci"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type D struct {
0000000000000000000000000000000000000000;;		A []interface{} `json:"da"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type E struct {
0000000000000000000000000000000000000000;;		A interface{} `json:"ea"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type F struct {
0000000000000000000000000000000000000000;;		A string            `json:"fa"`
0000000000000000000000000000000000000000;;		B map[string]string `json:"fb"`
0000000000000000000000000000000000000000;;		C []A               `json:"fc"`
0000000000000000000000000000000000000000;;		D int               `json:"fd"`
0000000000000000000000000000000000000000;;		E float32           `json:"fe"`
0000000000000000000000000000000000000000;;		F []string          `json:"ff"`
0000000000000000000000000000000000000000;;		G []int             `json:"fg"`
0000000000000000000000000000000000000000;;		H []bool            `json:"fh"`
0000000000000000000000000000000000000000;;		I []float32         `json:"fi"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement runtime.Object to make types usable for tests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *C) GetObjectKind() schema.ObjectKind {
0000000000000000000000000000000000000000;;		return schema.EmptyObjectKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *D) GetObjectKind() schema.ObjectKind {
0000000000000000000000000000000000000000;;		return schema.EmptyObjectKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *E) GetObjectKind() schema.ObjectKind {
0000000000000000000000000000000000000000;;		return schema.EmptyObjectKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *F) GetObjectKind() schema.ObjectKind {
0000000000000000000000000000000000000000;;		return schema.EmptyObjectKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doRoundTrip(t *testing.T, item runtime.Object) {
0000000000000000000000000000000000000000;;		data, err := json.Marshal(item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error when marshaling object: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unstr := make(map[string]interface{})
0000000000000000000000000000000000000000;;		err = json.Unmarshal(data, &unstr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error when unmarshaling to unstructured: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err = json.Marshal(unstr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error when marshaling unstructured: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unmarshalledObj := reflect.New(reflect.TypeOf(item).Elem()).Interface()
0000000000000000000000000000000000000000;;		err = json.Unmarshal(data, &unmarshalledObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error when unmarshaling to object: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(item, unmarshalledObj) {
0000000000000000000000000000000000000000;;			t.Errorf("Object changed during JSON operations, diff: %v", diff.ObjectReflectDiff(item, unmarshalledObj))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newUnstr, err := DefaultConverter.ToUnstructured(item)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("ToUnstructured failed: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newObj := reflect.New(reflect.TypeOf(item).Elem()).Interface().(runtime.Object)
0000000000000000000000000000000000000000;;		err = DefaultConverter.FromUnstructured(newUnstr, newObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("FromUnstructured failed: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(item, newObj) {
0000000000000000000000000000000000000000;;			t.Errorf("Object changed, diff: %v", diff.ObjectReflectDiff(item, newObj))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRoundTrip(t *testing.T) {
0000000000000000000000000000000000000000;;		intVal := int64(42)
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			obj runtime.Object
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// This (among others) tests nil map, slice and pointer.
0000000000000000000000000000000000000000;;				obj: &C{
0000000000000000000000000000000000000000;;					C: "ccc",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// This (among others) tests empty map and slice.
0000000000000000000000000000000000000000;;				obj: &C{
0000000000000000000000000000000000000000;;					A: []A{},
0000000000000000000000000000000000000000;;					C: "ccc",
0000000000000000000000000000000000000000;;					E: map[string]int{},
0000000000000000000000000000000000000000;;					I: []interface{}{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &C{
0000000000000000000000000000000000000000;;					A: []A{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							A: 1,
0000000000000000000000000000000000000000;;							B: "11",
0000000000000000000000000000000000000000;;							C: true,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							A: 2,
0000000000000000000000000000000000000000;;							B: "22",
0000000000000000000000000000000000000000;;							C: false,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					B: B{
0000000000000000000000000000000000000000;;						A: A{
0000000000000000000000000000000000000000;;							A: 3,
0000000000000000000000000000000000000000;;							B: "33",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						B: "bbb",
0000000000000000000000000000000000000000;;						C: map[string]string{
0000000000000000000000000000000000000000;;							"k1": "v1",
0000000000000000000000000000000000000000;;							"k2": "v2",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;						D: []string{"s1", "s2"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					C: "ccc",
0000000000000000000000000000000000000000;;					D: &intVal,
0000000000000000000000000000000000000000;;					E: map[string]int{
0000000000000000000000000000000000000000;;						"k1": 1,
0000000000000000000000000000000000000000;;						"k2": 2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					F: []bool{true, false, false},
0000000000000000000000000000000000000000;;					G: []int{1, 2, 5},
0000000000000000000000000000000000000000;;					H: 3.3,
0000000000000000000000000000000000000000;;					I: []interface{}{nil, nil, nil},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Test slice of interface{} with empty slices.
0000000000000000000000000000000000000000;;				obj: &D{
0000000000000000000000000000000000000000;;					A: []interface{}{[]interface{}{}, []interface{}{}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Test slice of interface{} with different values.
0000000000000000000000000000000000000000;;				obj: &D{
0000000000000000000000000000000000000000;;					A: []interface{}{3.0, "3.0", nil},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range testCases {
0000000000000000000000000000000000000000;;			doRoundTrip(t, testCases[i].obj)
0000000000000000000000000000000000000000;;			if t.Failed() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verifies that:
0000000000000000000000000000000000000000;;	// 1) serialized json -> object
0000000000000000000000000000000000000000;;	// 2) serialized json -> map[string]interface{} -> object
0000000000000000000000000000000000000000;;	// produces the same object.
0000000000000000000000000000000000000000;;	func doUnrecognized(t *testing.T, jsonData string, item runtime.Object, expectedErr error) {
0000000000000000000000000000000000000000;;		unmarshalledObj := reflect.New(reflect.TypeOf(item).Elem()).Interface()
0000000000000000000000000000000000000000;;		err := json.Unmarshal([]byte(jsonData), &unmarshalledObj)
0000000000000000000000000000000000000000;;		if (err != nil) != (expectedErr != nil) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error when unmarshaling to object: %v, expected: %v", err, expectedErr)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unstr := make(map[string]interface{})
0000000000000000000000000000000000000000;;		err = json.Unmarshal([]byte(jsonData), &unstr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Error when unmarshaling to unstructured: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newObj := reflect.New(reflect.TypeOf(item).Elem()).Interface().(runtime.Object)
0000000000000000000000000000000000000000;;		err = DefaultConverter.FromUnstructured(unstr, newObj)
0000000000000000000000000000000000000000;;		if (err != nil) != (expectedErr != nil) {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error in FromUnstructured: %v, expected: %v", err, expectedErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expectedErr == nil && !reflect.DeepEqual(unmarshalledObj, newObj) {
0000000000000000000000000000000000000000;;			t.Errorf("Object changed, diff: %v", diff.ObjectReflectDiff(unmarshalledObj, newObj))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUnrecognized(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			data string
0000000000000000000000000000000000000000;;			obj  runtime.Object
0000000000000000000000000000000000000000;;			err  error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"da\":[3.0,\"3.0\",null]}",
0000000000000000000000000000000000000000;;				obj:  &D{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"ea\":[3.0,\"3.0\",null]}",
0000000000000000000000000000000000000000;;				obj:  &E{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"ea\":[null,null,null]}",
0000000000000000000000000000000000000000;;				obj:  &E{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"ea\":[[],[null]]}",
0000000000000000000000000000000000000000;;				obj:  &E{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"ea\":{\"a\":[],\"b\":null}}",
0000000000000000000000000000000000000000;;				obj:  &E{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"fa\":\"fa\",\"fb\":{\"a\":\"a\"}}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"fa\":\"fa\",\"fb\":{\"a\":null}}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"fc\":[null]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"fc\":[{\"aa\":123,\"ab\":\"bbb\"}]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Only unknown fields
0000000000000000000000000000000000000000;;				data: "{\"fx\":[{\"aa\":123,\"ab\":\"bbb\"}],\"fz\":123}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"fc\":[{\"aa\":\"aaa\",\"ab\":\"bbb\"}]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal string into Go value of type int"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"fd\":123,\"fe\":3.5}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data: "{\"ff\":[\"abc\"],\"fg\":[123],\"fh\":[true,false]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid string data
0000000000000000000000000000000000000000;;				data: "{\"fa\":123}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number into Go value of type string"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid string data
0000000000000000000000000000000000000000;;				data: "{\"fa\":13.5}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number into Go value of type string"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid string data
0000000000000000000000000000000000000000;;				data: "{\"fa\":true}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal bool into Go value of type string"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []string data
0000000000000000000000000000000000000000;;				data: "{\"ff\":123}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number into Go value of type []string"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []string data
0000000000000000000000000000000000000000;;				data: "{\"ff\":3.5}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number into Go value of type []string"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []string data
0000000000000000000000000000000000000000;;				data: "{\"ff\":[123,345]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number into Go value of type string"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []int data
0000000000000000000000000000000000000000;;				data: "{\"fg\":123}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number into Go value of type []int"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []int data
0000000000000000000000000000000000000000;;				data: "{\"fg\":\"abc\"}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal string into Go value of type []int"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []int data
0000000000000000000000000000000000000000;;				data: "{\"fg\":[\"abc\"]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal string into Go value of type int"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []int data
0000000000000000000000000000000000000000;;				data: "{\"fg\":[3.5]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number 3.5 into Go value of type int"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []int data
0000000000000000000000000000000000000000;;				data: "{\"fg\":[true,false]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number 3.5 into Go value of type int"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []bool data
0000000000000000000000000000000000000000;;				data: "{\"fh\":123}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number into Go value of type []bool"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []bool data
0000000000000000000000000000000000000000;;				data: "{\"fh\":\"abc\"}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal string into Go value of type []bool"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []bool data
0000000000000000000000000000000000000000;;				data: "{\"fh\":[\"abc\"]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal string into Go value of type bool"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []bool data
0000000000000000000000000000000000000000;;				data: "{\"fh\":[3.5]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number into Go value of type bool"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []bool data
0000000000000000000000000000000000000000;;				data: "{\"fh\":[123]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number into Go value of type bool"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []float data
0000000000000000000000000000000000000000;;				data: "{\"fi\":123}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal number into Go value of type []float32"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []float data
0000000000000000000000000000000000000000;;				data: "{\"fi\":\"abc\"}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal string into Go value of type []float32"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []float data
0000000000000000000000000000000000000000;;				data: "{\"fi\":[\"abc\"]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal string into Go value of type float32"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// Invalid []float data
0000000000000000000000000000000000000000;;				data: "{\"fi\":[true]}",
0000000000000000000000000000000000000000;;				obj:  &F{},
0000000000000000000000000000000000000000;;				err:  fmt.Errorf("json: cannot unmarshal bool into Go value of type float32"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range testCases {
0000000000000000000000000000000000000000;;			doUnrecognized(t, testCases[i].data, testCases[i].obj, testCases[i].err)
0000000000000000000000000000000000000000;;			if t.Failed() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFloatIntConversion(t *testing.T) {
0000000000000000000000000000000000000000;;		unstr := map[string]interface{}{"fd": float64(3)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var obj F
0000000000000000000000000000000000000000;;		if err := DefaultConverter.FromUnstructured(unstr, &obj); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected error in FromUnstructured: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := json.Marshal(unstr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error when marshaling unstructured: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var unmarshalled F
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &unmarshalled); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Error when unmarshaling to object: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(obj, unmarshalled) {
0000000000000000000000000000000000000000;;			t.Errorf("Incorrect conversion, diff: %v", diff.ObjectReflectDiff(obj, unmarshalled))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
