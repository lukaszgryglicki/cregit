0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
a239f93b629e7ef907f2c22ab7cdb9b72f244c0d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unstructured
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		encodingjson "encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converter is an interface for converting between interface{}
0000000000000000000000000000000000000000;;	// and map[string]interface representation.
0000000000000000000000000000000000000000;;	type Converter interface {
0000000000000000000000000000000000000000;;		ToUnstructured(obj interface{}) (map[string]interface{}, error)
0000000000000000000000000000000000000000;;		FromUnstructured(u map[string]interface{}, obj interface{}) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type structField struct {
0000000000000000000000000000000000000000;;		structType reflect.Type
0000000000000000000000000000000000000000;;		field      int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fieldInfo struct {
0000000000000000000000000000000000000000;;		name      string
0000000000000000000000000000000000000000;;		nameValue reflect.Value
0000000000000000000000000000000000000000;;		omitempty bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fieldsCacheMap map[structField]*fieldInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fieldsCache struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		value atomic.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFieldsCache() *fieldsCache {
0000000000000000000000000000000000000000;;		cache := &fieldsCache{}
0000000000000000000000000000000000000000;;		cache.value.Store(make(fieldsCacheMap))
0000000000000000000000000000000000000000;;		return cache
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		marshalerType          = reflect.TypeOf(new(encodingjson.Marshaler)).Elem()
0000000000000000000000000000000000000000;;		unmarshalerType        = reflect.TypeOf(new(encodingjson.Unmarshaler)).Elem()
0000000000000000000000000000000000000000;;		mapStringInterfaceType = reflect.TypeOf(map[string]interface{}{})
0000000000000000000000000000000000000000;;		stringType             = reflect.TypeOf(string(""))
0000000000000000000000000000000000000000;;		int64Type              = reflect.TypeOf(int64(0))
0000000000000000000000000000000000000000;;		uint64Type             = reflect.TypeOf(uint64(0))
0000000000000000000000000000000000000000;;		float64Type            = reflect.TypeOf(float64(0))
0000000000000000000000000000000000000000;;		boolType               = reflect.TypeOf(bool(false))
0000000000000000000000000000000000000000;;		fieldCache             = newFieldsCache()
0000000000000000000000000000000000000000;;		DefaultConverter       = NewConverter(parseBool(os.Getenv("KUBE_PATCH_CONVERSION_DETECTOR")))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseBool(key string) bool {
0000000000000000000000000000000000000000;;		if len(key) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value, err := strconv.ParseBool(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("Couldn't parse '%s' as bool for unstructured mismatch detection", key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConverterImpl knows how to convert between interface{} and
0000000000000000000000000000000000000000;;	// Unstructured in both ways.
0000000000000000000000000000000000000000;;	type converterImpl struct {
0000000000000000000000000000000000000000;;		// If true, we will be additionally running conversion via json
0000000000000000000000000000000000000000;;		// to ensure that the result is true.
0000000000000000000000000000000000000000;;		// This is supposed to be set only in tests.
0000000000000000000000000000000000000000;;		mismatchDetection bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewConverter(mismatchDetection bool) Converter {
0000000000000000000000000000000000000000;;		return &converterImpl{
0000000000000000000000000000000000000000;;			mismatchDetection: mismatchDetection,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *converterImpl) FromUnstructured(u map[string]interface{}, obj interface{}) error {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(obj)
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(obj)
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Ptr || value.IsNil() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("FromUnstructured requires a non-nil pointer to an object, got %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := fromUnstructured(reflect.ValueOf(u), value.Elem())
0000000000000000000000000000000000000000;;		if c.mismatchDetection {
0000000000000000000000000000000000000000;;			newObj := reflect.New(t.Elem()).Interface()
0000000000000000000000000000000000000000;;			newErr := fromUnstructuredViaJSON(u, newObj)
0000000000000000000000000000000000000000;;			if (err != nil) != (newErr != nil) {
0000000000000000000000000000000000000000;;				glog.Fatalf("FromUnstructured unexpected error for %v: error: %v", u, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && !apiequality.Semantic.DeepEqual(obj, newObj) {
0000000000000000000000000000000000000000;;				glog.Fatalf("FromUnstructured mismatch for %#v, diff: %v", obj, diff.ObjectReflectDiff(obj, newObj))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fromUnstructuredViaJSON(u map[string]interface{}, obj interface{}) error {
0000000000000000000000000000000000000000;;		data, err := json.Marshal(u)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Unmarshal(data, obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fromUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		sv = unwrapInterface(sv)
0000000000000000000000000000000000000000;;		if !sv.IsValid() {
0000000000000000000000000000000000000000;;			dv.Set(reflect.Zero(dv.Type()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st, dt := sv.Type(), dv.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch dt.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map, reflect.Slice, reflect.Ptr, reflect.Struct, reflect.Interface:
0000000000000000000000000000000000000000;;			// Those require non-trivial conversion.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// This should handle all simple types.
0000000000000000000000000000000000000000;;			if st.AssignableTo(dt) {
0000000000000000000000000000000000000000;;				dv.Set(sv)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We cannot simply use "ConvertibleTo", as JSON doesn't support conversions
0000000000000000000000000000000000000000;;			// between those four groups: bools, integers, floats and string. We need to
0000000000000000000000000000000000000000;;			// do the same.
0000000000000000000000000000000000000000;;			if st.ConvertibleTo(dt) {
0000000000000000000000000000000000000000;;				switch st.Kind() {
0000000000000000000000000000000000000000;;				case reflect.String:
0000000000000000000000000000000000000000;;					switch dt.Kind() {
0000000000000000000000000000000000000000;;					case reflect.String:
0000000000000000000000000000000000000000;;						dv.Set(sv.Convert(dt))
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case reflect.Bool:
0000000000000000000000000000000000000000;;					switch dt.Kind() {
0000000000000000000000000000000000000000;;					case reflect.Bool:
0000000000000000000000000000000000000000;;						dv.Set(sv.Convert(dt))
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
0000000000000000000000000000000000000000;;					reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;					switch dt.Kind() {
0000000000000000000000000000000000000000;;					case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
0000000000000000000000000000000000000000;;						reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;						dv.Set(sv.Convert(dt))
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;					switch dt.Kind() {
0000000000000000000000000000000000000000;;					case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;						dv.Set(sv.Convert(dt))
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if sv.Float() == math.Trunc(sv.Float()) {
0000000000000000000000000000000000000000;;						dv.Set(sv.Convert(dt))
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot convert %s to %s", st.String(), dt.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the object has a custom JSON marshaller/unmarshaller.
0000000000000000000000000000000000000000;;		if reflect.PtrTo(dt).Implements(unmarshalerType) {
0000000000000000000000000000000000000000;;			data, err := json.Marshal(sv.Interface())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error encoding %s to json: %v", st.String(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unmarshaler := dv.Addr().Interface().(encodingjson.Unmarshaler)
0000000000000000000000000000000000000000;;			return unmarshaler.UnmarshalJSON(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch dt.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			return mapFromUnstructured(sv, dv)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			return sliceFromUnstructured(sv, dv)
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			return pointerFromUnstructured(sv, dv)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return structFromUnstructured(sv, dv)
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			return interfaceFromUnstructured(sv, dv)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unrecognized type: %v", dt.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fieldInfoFromField(structType reflect.Type, field int) *fieldInfo {
0000000000000000000000000000000000000000;;		fieldCacheMap := fieldCache.value.Load().(fieldsCacheMap)
0000000000000000000000000000000000000000;;		if info, ok := fieldCacheMap[structField{structType, field}]; ok {
0000000000000000000000000000000000000000;;			return info
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cache miss - we need to compute the field name.
0000000000000000000000000000000000000000;;		info := &fieldInfo{}
0000000000000000000000000000000000000000;;		typeField := structType.Field(field)
0000000000000000000000000000000000000000;;		jsonTag := typeField.Tag.Get("json")
0000000000000000000000000000000000000000;;		if len(jsonTag) == 0 {
0000000000000000000000000000000000000000;;			// Make the first character lowercase.
0000000000000000000000000000000000000000;;			if typeField.Name == "" {
0000000000000000000000000000000000000000;;				info.name = typeField.Name
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				info.name = strings.ToLower(typeField.Name[:1]) + typeField.Name[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			items := strings.Split(jsonTag, ",")
0000000000000000000000000000000000000000;;			info.name = items[0]
0000000000000000000000000000000000000000;;			for i := range items {
0000000000000000000000000000000000000000;;				if items[i] == "omitempty" {
0000000000000000000000000000000000000000;;					info.omitempty = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info.nameValue = reflect.ValueOf(info.name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldCache.Lock()
0000000000000000000000000000000000000000;;		defer fieldCache.Unlock()
0000000000000000000000000000000000000000;;		fieldCacheMap = fieldCache.value.Load().(fieldsCacheMap)
0000000000000000000000000000000000000000;;		newFieldCacheMap := make(fieldsCacheMap)
0000000000000000000000000000000000000000;;		for k, v := range fieldCacheMap {
0000000000000000000000000000000000000000;;			newFieldCacheMap[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newFieldCacheMap[structField{structType, field}] = info
0000000000000000000000000000000000000000;;		fieldCache.value.Store(newFieldCacheMap)
0000000000000000000000000000000000000000;;		return info
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unwrapInterface(v reflect.Value) reflect.Value {
0000000000000000000000000000000000000000;;		for v.Kind() == reflect.Interface {
0000000000000000000000000000000000000000;;			v = v.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mapFromUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		st, dt := sv.Type(), dv.Type()
0000000000000000000000000000000000000000;;		if st.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot restore map from %v", st.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !st.Key().AssignableTo(dt.Key()) && !st.Key().ConvertibleTo(dt.Key()) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot copy map with non-assignable keys: %v %v", st.Key(), dt.Key())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sv.IsNil() {
0000000000000000000000000000000000000000;;			dv.Set(reflect.Zero(dt))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dv.Set(reflect.MakeMap(dt))
0000000000000000000000000000000000000000;;		for _, key := range sv.MapKeys() {
0000000000000000000000000000000000000000;;			value := reflect.New(dt.Elem()).Elem()
0000000000000000000000000000000000000000;;			if val := unwrapInterface(sv.MapIndex(key)); val.IsValid() {
0000000000000000000000000000000000000000;;				if err := fromUnstructured(val, value); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				value.Set(reflect.Zero(dt.Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if st.Key().AssignableTo(dt.Key()) {
0000000000000000000000000000000000000000;;				dv.SetMapIndex(key, value)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				dv.SetMapIndex(key.Convert(dt.Key()), value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sliceFromUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		st, dt := sv.Type(), dv.Type()
0000000000000000000000000000000000000000;;		if st.Kind() == reflect.String && dt.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;			// We store original []byte representation as string.
0000000000000000000000000000000000000000;;			// This conversion is allowed, but we need to be careful about
0000000000000000000000000000000000000000;;			// marshaling data appropriately.
0000000000000000000000000000000000000000;;			if len(sv.Interface().(string)) > 0 {
0000000000000000000000000000000000000000;;				marshalled, err := json.Marshal(sv.Interface())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error encoding %s to json: %v", st, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// TODO: Is this Unmarshal needed?
0000000000000000000000000000000000000000;;				var data []byte
0000000000000000000000000000000000000000;;				err = json.Unmarshal(marshalled, &data)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("error decoding from json: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dv.SetBytes(data)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				dv.Set(reflect.Zero(dt))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if st.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot restore slice from %v", st.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sv.IsNil() {
0000000000000000000000000000000000000000;;			dv.Set(reflect.Zero(dt))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dv.Set(reflect.MakeSlice(dt, sv.Len(), sv.Cap()))
0000000000000000000000000000000000000000;;		for i := 0; i < sv.Len(); i++ {
0000000000000000000000000000000000000000;;			if err := fromUnstructured(sv.Index(i), dv.Index(i)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pointerFromUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		st, dt := sv.Type(), dv.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if st.Kind() == reflect.Ptr && sv.IsNil() {
0000000000000000000000000000000000000000;;			dv.Set(reflect.Zero(dt))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dv.Set(reflect.New(dt.Elem()))
0000000000000000000000000000000000000000;;		switch st.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr, reflect.Interface:
0000000000000000000000000000000000000000;;			return fromUnstructured(sv.Elem(), dv.Elem())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fromUnstructured(sv, dv.Elem())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structFromUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		st, dt := sv.Type(), dv.Type()
0000000000000000000000000000000000000000;;		if st.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot restore struct from: %v", st.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < dt.NumField(); i++ {
0000000000000000000000000000000000000000;;			fieldInfo := fieldInfoFromField(dt, i)
0000000000000000000000000000000000000000;;			fv := dv.Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(fieldInfo.name) == 0 {
0000000000000000000000000000000000000000;;				// This field is inlined.
0000000000000000000000000000000000000000;;				if err := fromUnstructured(sv, fv); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				value := unwrapInterface(sv.MapIndex(fieldInfo.nameValue))
0000000000000000000000000000000000000000;;				if value.IsValid() {
0000000000000000000000000000000000000000;;					if err := fromUnstructured(value, fv); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fv.Set(reflect.Zero(fv.Type()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func interfaceFromUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		// TODO: Is this conversion safe?
0000000000000000000000000000000000000000;;		dv.Set(sv)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *converterImpl) ToUnstructured(obj interface{}) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(obj)
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(obj)
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Ptr || value.IsNil() {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ToUnstructured requires a non-nil pointer to an object, got %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u := &map[string]interface{}{}
0000000000000000000000000000000000000000;;		err := toUnstructured(value.Elem(), reflect.ValueOf(u).Elem())
0000000000000000000000000000000000000000;;		if c.mismatchDetection {
0000000000000000000000000000000000000000;;			newUnstr := &map[string]interface{}{}
0000000000000000000000000000000000000000;;			newErr := toUnstructuredViaJSON(obj, newUnstr)
0000000000000000000000000000000000000000;;			if (err != nil) != (newErr != nil) {
0000000000000000000000000000000000000000;;				glog.Fatalf("ToUnstructured unexpected error for %v: error: %v", obj, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil && !apiequality.Semantic.DeepEqual(u, newUnstr) {
0000000000000000000000000000000000000000;;				glog.Fatalf("ToUnstructured mismatch for %#v, diff: %v", u, diff.ObjectReflectDiff(u, newUnstr))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *u, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toUnstructuredViaJSON(obj interface{}, u *map[string]interface{}) error {
0000000000000000000000000000000000000000;;		data, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Unmarshal(data, u)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		st, dt := sv.Type(), dv.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the object has a custom JSON marshaller/unmarshaller.
0000000000000000000000000000000000000000;;		if st.Implements(marshalerType) {
0000000000000000000000000000000000000000;;			if sv.Kind() == reflect.Ptr && sv.IsNil() {
0000000000000000000000000000000000000000;;				// We're done - we don't need to store anything.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			marshaler := sv.Interface().(encodingjson.Marshaler)
0000000000000000000000000000000000000000;;			data, err := marshaler.MarshalJSON()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if bytes.Equal(data, []byte("null")) {
0000000000000000000000000000000000000000;;				// We're done - we don't need to store anything.
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case len(data) > 0 && data[0] == '"':
0000000000000000000000000000000000000000;;					var result string
0000000000000000000000000000000000000000;;					err := json.Unmarshal(data, &result)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("error decoding from json: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dv.Set(reflect.ValueOf(result))
0000000000000000000000000000000000000000;;				case len(data) > 0 && data[0] == '{':
0000000000000000000000000000000000000000;;					result := make(map[string]interface{})
0000000000000000000000000000000000000000;;					err := json.Unmarshal(data, &result)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("error decoding from json: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dv.Set(reflect.ValueOf(result))
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					var result int64
0000000000000000000000000000000000000000;;					err := json.Unmarshal(data, &result)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("error decoding from json: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dv.Set(reflect.ValueOf(result))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch st.Kind() {
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			if dt.Kind() == reflect.Interface && dv.NumMethod() == 0 {
0000000000000000000000000000000000000000;;				dv.Set(reflect.New(stringType))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.ValueOf(sv.String()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			if dt.Kind() == reflect.Interface && dv.NumMethod() == 0 {
0000000000000000000000000000000000000000;;				dv.Set(reflect.New(boolType))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.ValueOf(sv.Bool()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			if dt.Kind() == reflect.Interface && dv.NumMethod() == 0 {
0000000000000000000000000000000000000000;;				dv.Set(reflect.New(int64Type))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.ValueOf(sv.Int()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			if dt.Kind() == reflect.Interface && dv.NumMethod() == 0 {
0000000000000000000000000000000000000000;;				dv.Set(reflect.New(uint64Type))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.ValueOf(sv.Uint()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			if dt.Kind() == reflect.Interface && dv.NumMethod() == 0 {
0000000000000000000000000000000000000000;;				dv.Set(reflect.New(float64Type))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.ValueOf(sv.Float()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			return mapToUnstructured(sv, dv)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			return sliceToUnstructured(sv, dv)
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			return pointerToUnstructured(sv, dv)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return structToUnstructured(sv, dv)
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			return interfaceToUnstructured(sv, dv)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unrecognized type: %v", st.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mapToUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		st, dt := sv.Type(), dv.Type()
0000000000000000000000000000000000000000;;		if sv.IsNil() {
0000000000000000000000000000000000000000;;			dv.Set(reflect.Zero(dt))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dt.Kind() == reflect.Interface && dv.NumMethod() == 0 {
0000000000000000000000000000000000000000;;			if st.Key().Kind() == reflect.String {
0000000000000000000000000000000000000000;;				switch st.Elem().Kind() {
0000000000000000000000000000000000000000;;				// TODO It should be possible to reuse the slice for primitive types.
0000000000000000000000000000000000000000;;				// However, it is panicing in the following form.
0000000000000000000000000000000000000000;;				// case reflect.String, reflect.Bool,
0000000000000000000000000000000000000000;;				// 	reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
0000000000000000000000000000000000000000;;				// 	reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;				// 	sv.Set(sv)
0000000000000000000000000000000000000000;;				// 	return nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// We need to do a proper conversion.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.MakeMap(mapStringInterfaceType))
0000000000000000000000000000000000000000;;			dv = dv.Elem()
0000000000000000000000000000000000000000;;			dt = dv.Type()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dt.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot convert struct to: %v", dt.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !st.Key().AssignableTo(dt.Key()) && !st.Key().ConvertibleTo(dt.Key()) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot copy map with non-assignable keys: %v %v", st.Key(), dt.Key())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, key := range sv.MapKeys() {
0000000000000000000000000000000000000000;;			value := reflect.New(dt.Elem()).Elem()
0000000000000000000000000000000000000000;;			if err := toUnstructured(sv.MapIndex(key), value); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if st.Key().AssignableTo(dt.Key()) {
0000000000000000000000000000000000000000;;				dv.SetMapIndex(key, value)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				dv.SetMapIndex(key.Convert(dt.Key()), value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sliceToUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		st, dt := sv.Type(), dv.Type()
0000000000000000000000000000000000000000;;		if sv.IsNil() {
0000000000000000000000000000000000000000;;			dv.Set(reflect.Zero(dt))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if st.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;			dv.Set(reflect.New(stringType))
0000000000000000000000000000000000000000;;			data, err := json.Marshal(sv.Bytes())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var result string
0000000000000000000000000000000000000000;;			if err = json.Unmarshal(data, &result); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dv.Set(reflect.ValueOf(result))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dt.Kind() == reflect.Interface && dv.NumMethod() == 0 {
0000000000000000000000000000000000000000;;			switch st.Elem().Kind() {
0000000000000000000000000000000000000000;;			// TODO It should be possible to reuse the slice for primitive types.
0000000000000000000000000000000000000000;;			// However, it is panicing in the following form.
0000000000000000000000000000000000000000;;			// case reflect.String, reflect.Bool,
0000000000000000000000000000000000000000;;			// 	reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
0000000000000000000000000000000000000000;;			// 	reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			// 	sv.Set(sv)
0000000000000000000000000000000000000000;;			// 	return nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// We need to do a proper conversion.
0000000000000000000000000000000000000000;;				dv.Set(reflect.MakeSlice(reflect.SliceOf(dt), sv.Len(), sv.Cap()))
0000000000000000000000000000000000000000;;				dv = dv.Elem()
0000000000000000000000000000000000000000;;				dt = dv.Type()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dt.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot convert slice to: %v", dt.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < sv.Len(); i++ {
0000000000000000000000000000000000000000;;			if err := toUnstructured(sv.Index(i), dv.Index(i)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pointerToUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		if sv.IsNil() {
0000000000000000000000000000000000000000;;			// We're done - we don't need to store anything.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return toUnstructured(sv.Elem(), dv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isZero(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.String:
0000000000000000000000000000000000000000;;			return v.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return !v.Bool()
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return v.Int() == 0
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			return v.Uint() == 0
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v.Float() == 0
0000000000000000000000000000000000000000;;		case reflect.Map, reflect.Slice:
0000000000000000000000000000000000000000;;			// TODO: It seems that 0-len maps are ignored in it.
0000000000000000000000000000000000000000;;			return v.IsNil() || v.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Ptr, reflect.Interface:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structToUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		st, dt := sv.Type(), dv.Type()
0000000000000000000000000000000000000000;;		if dt.Kind() == reflect.Interface && dv.NumMethod() == 0 {
0000000000000000000000000000000000000000;;			dv.Set(reflect.MakeMap(mapStringInterfaceType))
0000000000000000000000000000000000000000;;			dv = dv.Elem()
0000000000000000000000000000000000000000;;			dt = dv.Type()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dt.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot convert struct to: %v", dt.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		realMap := dv.Interface().(map[string]interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < st.NumField(); i++ {
0000000000000000000000000000000000000000;;			fieldInfo := fieldInfoFromField(st, i)
0000000000000000000000000000000000000000;;			fv := sv.Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if fieldInfo.name == "-" {
0000000000000000000000000000000000000000;;				// This field should be skipped.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fieldInfo.omitempty && isZero(fv) {
0000000000000000000000000000000000000000;;				// omitempty fields should be ignored.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(fieldInfo.name) == 0 {
0000000000000000000000000000000000000000;;				// This field is inlined.
0000000000000000000000000000000000000000;;				if err := toUnstructured(fv, dv); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch fv.Type().Kind() {
0000000000000000000000000000000000000000;;			case reflect.String:
0000000000000000000000000000000000000000;;				realMap[fieldInfo.name] = fv.String()
0000000000000000000000000000000000000000;;			case reflect.Bool:
0000000000000000000000000000000000000000;;				realMap[fieldInfo.name] = fv.Bool()
0000000000000000000000000000000000000000;;			case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;				realMap[fieldInfo.name] = fv.Int()
0000000000000000000000000000000000000000;;			case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;				realMap[fieldInfo.name] = fv.Uint()
0000000000000000000000000000000000000000;;			case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;				realMap[fieldInfo.name] = fv.Float()
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				subv := reflect.New(dt.Elem()).Elem()
0000000000000000000000000000000000000000;;				if err := toUnstructured(fv, subv); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dv.SetMapIndex(fieldInfo.nameValue, subv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func interfaceToUnstructured(sv, dv reflect.Value) error {
0000000000000000000000000000000000000000;;		if !sv.IsValid() || sv.IsNil() {
0000000000000000000000000000000000000000;;			dv.Set(reflect.Zero(dv.Type()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return toUnstructured(sv.Elem(), dv)
0000000000000000000000000000000000000000;;	}
