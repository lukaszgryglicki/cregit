0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package conversion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cloner knows how to copy one type to another.
0000000000000000000000000000000000000000;;	type Cloner struct {
0000000000000000000000000000000000000000;;		// Map from the type to a function which can do the deep copy.
0000000000000000000000000000000000000000;;		deepCopyFuncs          map[reflect.Type]reflect.Value
0000000000000000000000000000000000000000;;		generatedDeepCopyFuncs map[reflect.Type]func(in interface{}, out interface{}, c *Cloner) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCloner creates a new Cloner object.
0000000000000000000000000000000000000000;;	func NewCloner() *Cloner {
0000000000000000000000000000000000000000;;		c := &Cloner{
0000000000000000000000000000000000000000;;			deepCopyFuncs:          map[reflect.Type]reflect.Value{},
0000000000000000000000000000000000000000;;			generatedDeepCopyFuncs: map[reflect.Type]func(in interface{}, out interface{}, c *Cloner) error{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.RegisterDeepCopyFunc(byteSliceDeepCopy); err != nil {
0000000000000000000000000000000000000000;;			// If one of the deep-copy functions is malformed, detect it immediately.
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prevent recursing into every byte...
0000000000000000000000000000000000000000;;	func byteSliceDeepCopy(in *[]byte, out *[]byte, c *Cloner) error {
0000000000000000000000000000000000000000;;		if *in != nil {
0000000000000000000000000000000000000000;;			*out = make([]byte, len(*in))
0000000000000000000000000000000000000000;;			copy(*out, *in)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			*out = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verifies whether a deep-copy function has a correct signature.
0000000000000000000000000000000000000000;;	func verifyDeepCopyFunctionSignature(ft reflect.Type) error {
0000000000000000000000000000000000000000;;		if ft.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected func, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.NumIn() != 3 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected three 'in' params, got %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.NumOut() != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected one 'out' param, got %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.In(0).Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected pointer arg for 'in' param 0, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.In(1) != ft.In(0) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected 'in' param 0 the same as param 1, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var forClonerType Cloner
0000000000000000000000000000000000000000;;		if expected := reflect.TypeOf(&forClonerType); ft.In(2) != expected {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected '%v' arg for 'in' param 2, got: '%v'", expected, ft.In(2))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var forErrorType error
0000000000000000000000000000000000000000;;		// This convolution is necessary, otherwise TypeOf picks up on the fact
0000000000000000000000000000000000000000;;		// that forErrorType is nil
0000000000000000000000000000000000000000;;		errorType := reflect.TypeOf(&forErrorType).Elem()
0000000000000000000000000000000000000000;;		if ft.Out(0) != errorType {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected error return, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterGeneratedDeepCopyFunc registers a copying func with the Cloner.
0000000000000000000000000000000000000000;;	// deepCopyFunc must take three parameters: a type input, a pointer to a
0000000000000000000000000000000000000000;;	// type output, and a pointer to Cloner. It should return an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Example:
0000000000000000000000000000000000000000;;	// c.RegisterGeneratedDeepCopyFunc(
0000000000000000000000000000000000000000;;	//         func(in Pod, out *Pod, c *Cloner) error {
0000000000000000000000000000000000000000;;	//                 // deep copy logic...
0000000000000000000000000000000000000000;;	//                 return nil
0000000000000000000000000000000000000000;;	//          })
0000000000000000000000000000000000000000;;	func (c *Cloner) RegisterDeepCopyFunc(deepCopyFunc interface{}) error {
0000000000000000000000000000000000000000;;		fv := reflect.ValueOf(deepCopyFunc)
0000000000000000000000000000000000000000;;		ft := fv.Type()
0000000000000000000000000000000000000000;;		if err := verifyDeepCopyFunctionSignature(ft); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.deepCopyFuncs[ft.In(0)] = fv
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GeneratedDeepCopyFunc bundles an untyped generated deep-copy function of a type
0000000000000000000000000000000000000000;;	// with a reflection type object used as a key to lookup the deep-copy function.
0000000000000000000000000000000000000000;;	type GeneratedDeepCopyFunc struct {
0000000000000000000000000000000000000000;;		Fn     func(in interface{}, out interface{}, c *Cloner) error
0000000000000000000000000000000000000000;;		InType reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Similar to RegisterDeepCopyFunc, but registers deep copy function that were
0000000000000000000000000000000000000000;;	// automatically generated.
0000000000000000000000000000000000000000;;	func (c *Cloner) RegisterGeneratedDeepCopyFunc(fn GeneratedDeepCopyFunc) error {
0000000000000000000000000000000000000000;;		c.generatedDeepCopyFuncs[fn.InType] = fn.Fn
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeepCopy will perform a deep copy of a given object.
0000000000000000000000000000000000000000;;	func (c *Cloner) DeepCopy(in interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		// Can be invalid if we run DeepCopy(X) where X is a nil interface type.
0000000000000000000000000000000000000000;;		// For example, we get an invalid value when someone tries to deep-copy
0000000000000000000000000000000000000000;;		// a nil labels.Selector.
0000000000000000000000000000000000000000;;		// This does not occur if X is nil and is a pointer to a concrete type.
0000000000000000000000000000000000000000;;		if in == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inValue := reflect.ValueOf(in)
0000000000000000000000000000000000000000;;		outValue, err := c.deepCopy(inValue)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return outValue.Interface(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloner) deepCopy(src reflect.Value) (reflect.Value, error) {
0000000000000000000000000000000000000000;;		inType := src.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch src.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:
0000000000000000000000000000000000000000;;			if src.IsNil() {
0000000000000000000000000000000000000000;;				return src, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fv, ok := c.deepCopyFuncs[inType]; ok {
0000000000000000000000000000000000000000;;			return c.customDeepCopy(src, fv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fv, ok := c.generatedDeepCopyFuncs[inType]; ok {
0000000000000000000000000000000000000000;;			var outValue reflect.Value
0000000000000000000000000000000000000000;;			outValue = reflect.New(inType.Elem())
0000000000000000000000000000000000000000;;			err := fv(src.Interface(), outValue.Interface(), c)
0000000000000000000000000000000000000000;;			return outValue, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.defaultDeepCopy(src)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloner) customDeepCopy(src, fv reflect.Value) (reflect.Value, error) {
0000000000000000000000000000000000000000;;		outValue := reflect.New(src.Type().Elem())
0000000000000000000000000000000000000000;;		args := []reflect.Value{src, outValue, reflect.ValueOf(c)}
0000000000000000000000000000000000000000;;		result := fv.Call(args)[0].Interface()
0000000000000000000000000000000000000000;;		// This convolution is necessary because nil interfaces won't convert
0000000000000000000000000000000000000000;;		// to error.
0000000000000000000000000000000000000000;;		if result == nil {
0000000000000000000000000000000000000000;;			return outValue, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return outValue, result.(error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cloner) defaultDeepCopy(src reflect.Value) (reflect.Value, error) {
0000000000000000000000000000000000000000;;		switch src.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Chan, reflect.Func, reflect.UnsafePointer, reflect.Uintptr:
0000000000000000000000000000000000000000;;			return src, fmt.Errorf("cannot deep copy kind: %s", src.Kind())
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			dst := reflect.New(src.Type())
0000000000000000000000000000000000000000;;			for i := 0; i < src.Len(); i++ {
0000000000000000000000000000000000000000;;				copyVal, err := c.deepCopy(src.Index(i))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return src, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst.Elem().Index(i).Set(copyVal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return dst.Elem(), nil
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if src.IsNil() {
0000000000000000000000000000000000000000;;				return src, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return c.deepCopy(src.Elem())
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if src.IsNil() {
0000000000000000000000000000000000000000;;				return src, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst := reflect.MakeMap(src.Type())
0000000000000000000000000000000000000000;;			for _, k := range src.MapKeys() {
0000000000000000000000000000000000000000;;				copyVal, err := c.deepCopy(src.MapIndex(k))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return src, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst.SetMapIndex(k, copyVal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return dst, nil
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if src.IsNil() {
0000000000000000000000000000000000000000;;				return src, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst := reflect.New(src.Type().Elem())
0000000000000000000000000000000000000000;;			copyVal, err := c.deepCopy(src.Elem())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return src, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst.Elem().Set(copyVal)
0000000000000000000000000000000000000000;;			return dst, nil
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if src.IsNil() {
0000000000000000000000000000000000000000;;				return src, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst := reflect.MakeSlice(src.Type(), 0, src.Len())
0000000000000000000000000000000000000000;;			for i := 0; i < src.Len(); i++ {
0000000000000000000000000000000000000000;;				copyVal, err := c.deepCopy(src.Index(i))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return src, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst = reflect.Append(dst, copyVal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return dst, nil
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			dst := reflect.New(src.Type())
0000000000000000000000000000000000000000;;			for i := 0; i < src.NumField(); i++ {
0000000000000000000000000000000000000000;;				if !dst.Elem().Field(i).CanSet() {
0000000000000000000000000000000000000000;;					// Can't set private fields. At this point, the
0000000000000000000000000000000000000000;;					// best we can do is a shallow copy. For
0000000000000000000000000000000000000000;;					// example, time.Time is a value type with
0000000000000000000000000000000000000000;;					// private members that can be shallow copied.
0000000000000000000000000000000000000000;;					return src, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				copyVal, err := c.deepCopy(src.Field(i))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return src, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst.Elem().Field(i).Set(copyVal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return dst.Elem(), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Value types like numbers, booleans, and strings.
0000000000000000000000000000000000000000;;			return src, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
