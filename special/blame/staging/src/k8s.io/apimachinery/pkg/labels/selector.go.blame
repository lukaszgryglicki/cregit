0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package labels
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/selection"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Requirements is AND of all requirements.
0000000000000000000000000000000000000000;;	type Requirements []Requirement
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Selector represents a label selector.
0000000000000000000000000000000000000000;;	type Selector interface {
0000000000000000000000000000000000000000;;		// Matches returns true if this selector matches the given set of labels.
0000000000000000000000000000000000000000;;		Matches(Labels) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Empty returns true if this selector does not restrict the selection space.
0000000000000000000000000000000000000000;;		Empty() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// String returns a human readable string that represents this selector.
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add adds requirements to the Selector
0000000000000000000000000000000000000000;;		Add(r ...Requirement) Selector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Requirements converts this interface into Requirements to expose
0000000000000000000000000000000000000000;;		// more detailed selection information.
0000000000000000000000000000000000000000;;		// If there are querying parameters, it will return converted requirements and selectable=true.
0000000000000000000000000000000000000000;;		// If this selector doesn't want to select anything, it will return selectable=false.
0000000000000000000000000000000000000000;;		Requirements() (requirements Requirements, selectable bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Everything returns a selector that matches all labels.
0000000000000000000000000000000000000000;;	func Everything() Selector {
0000000000000000000000000000000000000000;;		return internalSelector{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nothingSelector struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n nothingSelector) Matches(_ Labels) bool              { return false }
0000000000000000000000000000000000000000;;	func (n nothingSelector) Empty() bool                        { return false }
0000000000000000000000000000000000000000;;	func (n nothingSelector) String() string                     { return "" }
0000000000000000000000000000000000000000;;	func (n nothingSelector) Add(_ ...Requirement) Selector      { return n }
0000000000000000000000000000000000000000;;	func (n nothingSelector) Requirements() (Requirements, bool) { return nil, false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nothing returns a selector that matches no labels
0000000000000000000000000000000000000000;;	func Nothing() Selector {
0000000000000000000000000000000000000000;;		return nothingSelector{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSelector returns a nil selector
0000000000000000000000000000000000000000;;	func NewSelector() Selector {
0000000000000000000000000000000000000000;;		return internalSelector(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type internalSelector []Requirement
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByKey sorts requirements by key to obtain deterministic parser
0000000000000000000000000000000000000000;;	type ByKey []Requirement
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a ByKey) Len() int { return len(a) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a ByKey) Swap(i, j int) { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a ByKey) Less(i, j int) bool { return a[i].key < a[j].key }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Requirement contains values, a key, and an operator that relates the key and values.
0000000000000000000000000000000000000000;;	// The zero value of Requirement is invalid.
0000000000000000000000000000000000000000;;	// Requirement implements both set based match and exact match
0000000000000000000000000000000000000000;;	// Requirement should be initialized via NewRequirement constructor for creating a valid Requirement.
0000000000000000000000000000000000000000;;	type Requirement struct {
0000000000000000000000000000000000000000;;		key      string
0000000000000000000000000000000000000000;;		operator selection.Operator
0000000000000000000000000000000000000000;;		// In huge majority of cases we have at most one value here.
0000000000000000000000000000000000000000;;		// It is generally faster to operate on a single-element slice
0000000000000000000000000000000000000000;;		// than on a single-element map, so we have a slice here.
0000000000000000000000000000000000000000;;		strValues []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRequirement is the constructor for a Requirement.
0000000000000000000000000000000000000000;;	// If any of these rules is violated, an error is returned:
0000000000000000000000000000000000000000;;	// (1) The operator can only be In, NotIn, Equals, DoubleEquals, NotEquals, Exists, or DoesNotExist.
0000000000000000000000000000000000000000;;	// (2) If the operator is In or NotIn, the values set must be non-empty.
0000000000000000000000000000000000000000;;	// (3) If the operator is Equals, DoubleEquals, or NotEquals, the values set must contain one value.
0000000000000000000000000000000000000000;;	// (4) If the operator is Exists or DoesNotExist, the value set must be empty.
0000000000000000000000000000000000000000;;	// (5) If the operator is Gt or Lt, the values set must contain only one value, which will be interpreted as an integer.
0000000000000000000000000000000000000000;;	// (6) The key is invalid due to its length, or sequence
0000000000000000000000000000000000000000;;	//     of characters. See validateLabelKey for more details.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The empty string is a valid value in the input values set.
0000000000000000000000000000000000000000;;	func NewRequirement(key string, op selection.Operator, vals []string) (*Requirement, error) {
0000000000000000000000000000000000000000;;		if err := validateLabelKey(key); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch op {
0000000000000000000000000000000000000000;;		case selection.In, selection.NotIn:
0000000000000000000000000000000000000000;;			if len(vals) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("for 'in', 'notin' operators, values set can't be empty")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case selection.Equals, selection.DoubleEquals, selection.NotEquals:
0000000000000000000000000000000000000000;;			if len(vals) != 1 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("exact-match compatibility requires one single value")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case selection.Exists, selection.DoesNotExist:
0000000000000000000000000000000000000000;;			if len(vals) != 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("values set must be empty for exists and does not exist")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case selection.GreaterThan, selection.LessThan:
0000000000000000000000000000000000000000;;			if len(vals) != 1 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("for 'Gt', 'Lt' operators, exactly one value is required")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range vals {
0000000000000000000000000000000000000000;;				if _, err := strconv.ParseInt(vals[i], 10, 64); err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("for 'Gt', 'Lt' operators, the value must be an integer")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("operator '%v' is not recognized", op)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range vals {
0000000000000000000000000000000000000000;;			if err := validateLabelValue(vals[i]); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(vals)
0000000000000000000000000000000000000000;;		return &Requirement{key: key, operator: op, strValues: vals}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Requirement) hasValue(value string) bool {
0000000000000000000000000000000000000000;;		for i := range r.strValues {
0000000000000000000000000000000000000000;;			if r.strValues[i] == value {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matches returns true if the Requirement matches the input Labels.
0000000000000000000000000000000000000000;;	// There is a match in the following cases:
0000000000000000000000000000000000000000;;	// (1) The operator is Exists and Labels has the Requirement's key.
0000000000000000000000000000000000000000;;	// (2) The operator is In, Labels has the Requirement's key and Labels'
0000000000000000000000000000000000000000;;	//     value for that key is in Requirement's value set.
0000000000000000000000000000000000000000;;	// (3) The operator is NotIn, Labels has the Requirement's key and
0000000000000000000000000000000000000000;;	//     Labels' value for that key is not in Requirement's value set.
0000000000000000000000000000000000000000;;	// (4) The operator is DoesNotExist or NotIn and Labels does not have the
0000000000000000000000000000000000000000;;	//     Requirement's key.
0000000000000000000000000000000000000000;;	// (5) The operator is GreaterThanOperator or LessThanOperator, and Labels has
0000000000000000000000000000000000000000;;	//     the Requirement's key and the corresponding value satisfies mathematical inequality.
0000000000000000000000000000000000000000;;	func (r *Requirement) Matches(ls Labels) bool {
0000000000000000000000000000000000000000;;		switch r.operator {
0000000000000000000000000000000000000000;;		case selection.In, selection.Equals, selection.DoubleEquals:
0000000000000000000000000000000000000000;;			if !ls.Has(r.key) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return r.hasValue(ls.Get(r.key))
0000000000000000000000000000000000000000;;		case selection.NotIn, selection.NotEquals:
0000000000000000000000000000000000000000;;			if !ls.Has(r.key) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return !r.hasValue(ls.Get(r.key))
0000000000000000000000000000000000000000;;		case selection.Exists:
0000000000000000000000000000000000000000;;			return ls.Has(r.key)
0000000000000000000000000000000000000000;;		case selection.DoesNotExist:
0000000000000000000000000000000000000000;;			return !ls.Has(r.key)
0000000000000000000000000000000000000000;;		case selection.GreaterThan, selection.LessThan:
0000000000000000000000000000000000000000;;			if !ls.Has(r.key) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lsValue, err := strconv.ParseInt(ls.Get(r.key), 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("ParseInt failed for value %+v in label %+v, %+v", ls.Get(r.key), ls, err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// There should be only one strValue in r.strValues, and can be converted to a integer.
0000000000000000000000000000000000000000;;			if len(r.strValues) != 1 {
0000000000000000000000000000000000000000;;				glog.V(10).Infof("Invalid values count %+v of requirement %#v, for 'Gt', 'Lt' operators, exactly one value is required", len(r.strValues), r)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var rValue int64
0000000000000000000000000000000000000000;;			for i := range r.strValues {
0000000000000000000000000000000000000000;;				rValue, err = strconv.ParseInt(r.strValues[i], 10, 64)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(10).Infof("ParseInt failed for value %+v in requirement %#v, for 'Gt', 'Lt' operators, the value must be an integer", r.strValues[i], r)
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return (r.operator == selection.GreaterThan && lsValue > rValue) || (r.operator == selection.LessThan && lsValue < rValue)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Key returns requirement key
0000000000000000000000000000000000000000;;	func (r *Requirement) Key() string {
0000000000000000000000000000000000000000;;		return r.key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Operator returns requirement operator
0000000000000000000000000000000000000000;;	func (r *Requirement) Operator() selection.Operator {
0000000000000000000000000000000000000000;;		return r.operator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Values returns requirement values
0000000000000000000000000000000000000000;;	func (r *Requirement) Values() sets.String {
0000000000000000000000000000000000000000;;		ret := sets.String{}
0000000000000000000000000000000000000000;;		for i := range r.strValues {
0000000000000000000000000000000000000000;;			ret.Insert(r.strValues[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty returns true if the internalSelector doesn't restrict selection space
0000000000000000000000000000000000000000;;	func (lsel internalSelector) Empty() bool {
0000000000000000000000000000000000000000;;		if lsel == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(lsel) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a human-readable string that represents this
0000000000000000000000000000000000000000;;	// Requirement. If called on an invalid Requirement, an error is
0000000000000000000000000000000000000000;;	// returned. See NewRequirement for creating a valid Requirement.
0000000000000000000000000000000000000000;;	func (r *Requirement) String() string {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		if r.operator == selection.DoesNotExist {
0000000000000000000000000000000000000000;;			buffer.WriteString("!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buffer.WriteString(r.key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch r.operator {
0000000000000000000000000000000000000000;;		case selection.Equals:
0000000000000000000000000000000000000000;;			buffer.WriteString("=")
0000000000000000000000000000000000000000;;		case selection.DoubleEquals:
0000000000000000000000000000000000000000;;			buffer.WriteString("==")
0000000000000000000000000000000000000000;;		case selection.NotEquals:
0000000000000000000000000000000000000000;;			buffer.WriteString("!=")
0000000000000000000000000000000000000000;;		case selection.In:
0000000000000000000000000000000000000000;;			buffer.WriteString(" in ")
0000000000000000000000000000000000000000;;		case selection.NotIn:
0000000000000000000000000000000000000000;;			buffer.WriteString(" notin ")
0000000000000000000000000000000000000000;;		case selection.GreaterThan:
0000000000000000000000000000000000000000;;			buffer.WriteString(">")
0000000000000000000000000000000000000000;;		case selection.LessThan:
0000000000000000000000000000000000000000;;			buffer.WriteString("<")
0000000000000000000000000000000000000000;;		case selection.Exists, selection.DoesNotExist:
0000000000000000000000000000000000000000;;			return buffer.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch r.operator {
0000000000000000000000000000000000000000;;		case selection.In, selection.NotIn:
0000000000000000000000000000000000000000;;			buffer.WriteString("(")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.strValues) == 1 {
0000000000000000000000000000000000000000;;			buffer.WriteString(r.strValues[0])
0000000000000000000000000000000000000000;;		} else { // only > 1 since == 0 prohibited by NewRequirement
0000000000000000000000000000000000000000;;			buffer.WriteString(strings.Join(r.strValues, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch r.operator {
0000000000000000000000000000000000000000;;		case selection.In, selection.NotIn:
0000000000000000000000000000000000000000;;			buffer.WriteString(")")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buffer.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds requirements to the selector. It copies the current selector returning a new one
0000000000000000000000000000000000000000;;	func (lsel internalSelector) Add(reqs ...Requirement) Selector {
0000000000000000000000000000000000000000;;		var sel internalSelector
0000000000000000000000000000000000000000;;		for ix := range lsel {
0000000000000000000000000000000000000000;;			sel = append(sel, lsel[ix])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, r := range reqs {
0000000000000000000000000000000000000000;;			sel = append(sel, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(ByKey(sel))
0000000000000000000000000000000000000000;;		return sel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matches for a internalSelector returns true if all
0000000000000000000000000000000000000000;;	// its Requirements match the input Labels. If any
0000000000000000000000000000000000000000;;	// Requirement does not match, false is returned.
0000000000000000000000000000000000000000;;	func (lsel internalSelector) Matches(l Labels) bool {
0000000000000000000000000000000000000000;;		for ix := range lsel {
0000000000000000000000000000000000000000;;			if matches := lsel[ix].Matches(l); !matches {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (lsel internalSelector) Requirements() (Requirements, bool) { return Requirements(lsel), true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a comma-separated string of all
0000000000000000000000000000000000000000;;	// the internalSelector Requirements' human-readable strings.
0000000000000000000000000000000000000000;;	func (lsel internalSelector) String() string {
0000000000000000000000000000000000000000;;		var reqs []string
0000000000000000000000000000000000000000;;		for ix := range lsel {
0000000000000000000000000000000000000000;;			reqs = append(reqs, lsel[ix].String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(reqs, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token represents constant definition for lexer token
0000000000000000000000000000000000000000;;	type Token int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ErrorToken represents scan error
0000000000000000000000000000000000000000;;		ErrorToken Token = iota
0000000000000000000000000000000000000000;;		// EndOfStringToken represents end of string
0000000000000000000000000000000000000000;;		EndOfStringToken
0000000000000000000000000000000000000000;;		// ClosedParToken represents close parenthesis
0000000000000000000000000000000000000000;;		ClosedParToken
0000000000000000000000000000000000000000;;		// CommaToken represents the comma
0000000000000000000000000000000000000000;;		CommaToken
0000000000000000000000000000000000000000;;		// DoesNotExistToken represents logic not
0000000000000000000000000000000000000000;;		DoesNotExistToken
0000000000000000000000000000000000000000;;		// DoubleEqualsToken represents double equals
0000000000000000000000000000000000000000;;		DoubleEqualsToken
0000000000000000000000000000000000000000;;		// EqualsToken represents equal
0000000000000000000000000000000000000000;;		EqualsToken
0000000000000000000000000000000000000000;;		// GreaterThanToken represents greater than
0000000000000000000000000000000000000000;;		GreaterThanToken
0000000000000000000000000000000000000000;;		// IdentifierToken represents identifier, e.g. keys and values
0000000000000000000000000000000000000000;;		IdentifierToken
0000000000000000000000000000000000000000;;		// InToken represents in
0000000000000000000000000000000000000000;;		InToken
0000000000000000000000000000000000000000;;		// LessThanToken represents less than
0000000000000000000000000000000000000000;;		LessThanToken
0000000000000000000000000000000000000000;;		// NotEqualsToken represents not equal
0000000000000000000000000000000000000000;;		NotEqualsToken
0000000000000000000000000000000000000000;;		// NotInToken represents not in
0000000000000000000000000000000000000000;;		NotInToken
0000000000000000000000000000000000000000;;		// OpenParToken represents open parenthesis
0000000000000000000000000000000000000000;;		OpenParToken
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// string2token contains the mapping between lexer Token and token literal
0000000000000000000000000000000000000000;;	// (except IdentifierToken, EndOfStringToken and ErrorToken since it makes no sense)
0000000000000000000000000000000000000000;;	var string2token = map[string]Token{
0000000000000000000000000000000000000000;;		")":     ClosedParToken,
0000000000000000000000000000000000000000;;		",":     CommaToken,
0000000000000000000000000000000000000000;;		"!":     DoesNotExistToken,
0000000000000000000000000000000000000000;;		"==":    DoubleEqualsToken,
0000000000000000000000000000000000000000;;		"=":     EqualsToken,
0000000000000000000000000000000000000000;;		">":     GreaterThanToken,
0000000000000000000000000000000000000000;;		"in":    InToken,
0000000000000000000000000000000000000000;;		"<":     LessThanToken,
0000000000000000000000000000000000000000;;		"!=":    NotEqualsToken,
0000000000000000000000000000000000000000;;		"notin": NotInToken,
0000000000000000000000000000000000000000;;		"(":     OpenParToken,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScannedItem contains the Token and the literal produced by the lexer.
0000000000000000000000000000000000000000;;	type ScannedItem struct {
0000000000000000000000000000000000000000;;		tok     Token
0000000000000000000000000000000000000000;;		literal string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isWhitespace returns true if the rune is a space, tab, or newline.
0000000000000000000000000000000000000000;;	func isWhitespace(ch byte) bool {
0000000000000000000000000000000000000000;;		return ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isSpecialSymbol detect if the character ch can be an operator
0000000000000000000000000000000000000000;;	func isSpecialSymbol(ch byte) bool {
0000000000000000000000000000000000000000;;		switch ch {
0000000000000000000000000000000000000000;;		case '=', '!', '(', ')', ',', '>', '<':
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lexer represents the Lexer struct for label selector.
0000000000000000000000000000000000000000;;	// It contains necessary informationt to tokenize the input string
0000000000000000000000000000000000000000;;	type Lexer struct {
0000000000000000000000000000000000000000;;		// s stores the string to be tokenized
0000000000000000000000000000000000000000;;		s string
0000000000000000000000000000000000000000;;		// pos is the position currently tokenized
0000000000000000000000000000000000000000;;		pos int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// read return the character currently lexed
0000000000000000000000000000000000000000;;	// increment the position and check the buffer overflow
0000000000000000000000000000000000000000;;	func (l *Lexer) read() (b byte) {
0000000000000000000000000000000000000000;;		b = 0
0000000000000000000000000000000000000000;;		if l.pos < len(l.s) {
0000000000000000000000000000000000000000;;			b = l.s[l.pos]
0000000000000000000000000000000000000000;;			l.pos++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unread 'undoes' the last read character
0000000000000000000000000000000000000000;;	func (l *Lexer) unread() {
0000000000000000000000000000000000000000;;		l.pos--
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanIDOrKeyword scans string to recognize literal token (for example 'in') or an identifier.
0000000000000000000000000000000000000000;;	func (l *Lexer) scanIDOrKeyword() (tok Token, lit string) {
0000000000000000000000000000000000000000;;		var buffer []byte
0000000000000000000000000000000000000000;;	IdentifierLoop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			switch ch := l.read(); {
0000000000000000000000000000000000000000;;			case ch == 0:
0000000000000000000000000000000000000000;;				break IdentifierLoop
0000000000000000000000000000000000000000;;			case isSpecialSymbol(ch) || isWhitespace(ch):
0000000000000000000000000000000000000000;;				l.unread()
0000000000000000000000000000000000000000;;				break IdentifierLoop
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				buffer = append(buffer, ch)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := string(buffer)
0000000000000000000000000000000000000000;;		if val, ok := string2token[s]; ok { // is a literal token?
0000000000000000000000000000000000000000;;			return val, s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return IdentifierToken, s // otherwise is an identifier
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanSpecialSymbol scans string starting with special symbol.
0000000000000000000000000000000000000000;;	// special symbol identify non literal operators. "!=", "==", "="
0000000000000000000000000000000000000000;;	func (l *Lexer) scanSpecialSymbol() (Token, string) {
0000000000000000000000000000000000000000;;		lastScannedItem := ScannedItem{}
0000000000000000000000000000000000000000;;		var buffer []byte
0000000000000000000000000000000000000000;;	SpecialSymbolLoop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			switch ch := l.read(); {
0000000000000000000000000000000000000000;;			case ch == 0:
0000000000000000000000000000000000000000;;				break SpecialSymbolLoop
0000000000000000000000000000000000000000;;			case isSpecialSymbol(ch):
0000000000000000000000000000000000000000;;				buffer = append(buffer, ch)
0000000000000000000000000000000000000000;;				if token, ok := string2token[string(buffer)]; ok {
0000000000000000000000000000000000000000;;					lastScannedItem = ScannedItem{tok: token, literal: string(buffer)}
0000000000000000000000000000000000000000;;				} else if lastScannedItem.tok != 0 {
0000000000000000000000000000000000000000;;					l.unread()
0000000000000000000000000000000000000000;;					break SpecialSymbolLoop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				l.unread()
0000000000000000000000000000000000000000;;				break SpecialSymbolLoop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lastScannedItem.tok == 0 {
0000000000000000000000000000000000000000;;			return ErrorToken, fmt.Sprintf("error expected: keyword found '%s'", buffer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lastScannedItem.tok, lastScannedItem.literal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// skipWhiteSpaces consumes all blank characters
0000000000000000000000000000000000000000;;	// returning the first non blank character
0000000000000000000000000000000000000000;;	func (l *Lexer) skipWhiteSpaces(ch byte) byte {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if !isWhitespace(ch) {
0000000000000000000000000000000000000000;;				return ch
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ch = l.read()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lex returns a pair of Token and the literal
0000000000000000000000000000000000000000;;	// literal is meaningfull only for IdentifierToken token
0000000000000000000000000000000000000000;;	func (l *Lexer) Lex() (tok Token, lit string) {
0000000000000000000000000000000000000000;;		switch ch := l.skipWhiteSpaces(l.read()); {
0000000000000000000000000000000000000000;;		case ch == 0:
0000000000000000000000000000000000000000;;			return EndOfStringToken, ""
0000000000000000000000000000000000000000;;		case isSpecialSymbol(ch):
0000000000000000000000000000000000000000;;			l.unread()
0000000000000000000000000000000000000000;;			return l.scanSpecialSymbol()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			l.unread()
0000000000000000000000000000000000000000;;			return l.scanIDOrKeyword()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parser data structure contains the label selector parser data structure
0000000000000000000000000000000000000000;;	type Parser struct {
0000000000000000000000000000000000000000;;		l            *Lexer
0000000000000000000000000000000000000000;;		scannedItems []ScannedItem
0000000000000000000000000000000000000000;;		position     int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParserContext represents context during parsing:
0000000000000000000000000000000000000000;;	// some literal for example 'in' and 'notin' can be
0000000000000000000000000000000000000000;;	// recognized as operator for example 'x in (a)' but
0000000000000000000000000000000000000000;;	// it can be recognized as value for example 'value in (in)'
0000000000000000000000000000000000000000;;	type ParserContext int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// KeyAndOperator represents key and operator
0000000000000000000000000000000000000000;;		KeyAndOperator ParserContext = iota
0000000000000000000000000000000000000000;;		// Values represents values
0000000000000000000000000000000000000000;;		Values
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lookahead func returns the current token and string. No increment of current position
0000000000000000000000000000000000000000;;	func (p *Parser) lookahead(context ParserContext) (Token, string) {
0000000000000000000000000000000000000000;;		tok, lit := p.scannedItems[p.position].tok, p.scannedItems[p.position].literal
0000000000000000000000000000000000000000;;		if context == Values {
0000000000000000000000000000000000000000;;			switch tok {
0000000000000000000000000000000000000000;;			case InToken, NotInToken:
0000000000000000000000000000000000000000;;				tok = IdentifierToken
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tok, lit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// consume returns current token and string. Increments the the position
0000000000000000000000000000000000000000;;	func (p *Parser) consume(context ParserContext) (Token, string) {
0000000000000000000000000000000000000000;;		p.position++
0000000000000000000000000000000000000000;;		tok, lit := p.scannedItems[p.position-1].tok, p.scannedItems[p.position-1].literal
0000000000000000000000000000000000000000;;		if context == Values {
0000000000000000000000000000000000000000;;			switch tok {
0000000000000000000000000000000000000000;;			case InToken, NotInToken:
0000000000000000000000000000000000000000;;				tok = IdentifierToken
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tok, lit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scan runs through the input string and stores the ScannedItem in an array
0000000000000000000000000000000000000000;;	// Parser can now lookahead and consume the tokens
0000000000000000000000000000000000000000;;	func (p *Parser) scan() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			token, literal := p.l.Lex()
0000000000000000000000000000000000000000;;			p.scannedItems = append(p.scannedItems, ScannedItem{token, literal})
0000000000000000000000000000000000000000;;			if token == EndOfStringToken {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parse runs the left recursive descending algorithm
0000000000000000000000000000000000000000;;	// on input string. It returns a list of Requirement objects.
0000000000000000000000000000000000000000;;	func (p *Parser) parse() (internalSelector, error) {
0000000000000000000000000000000000000000;;		p.scan() // init scannedItems
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var requirements internalSelector
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			tok, lit := p.lookahead(Values)
0000000000000000000000000000000000000000;;			switch tok {
0000000000000000000000000000000000000000;;			case IdentifierToken, DoesNotExistToken:
0000000000000000000000000000000000000000;;				r, err := p.parseRequirement()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unable to parse requirement: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				requirements = append(requirements, *r)
0000000000000000000000000000000000000000;;				t, l := p.consume(Values)
0000000000000000000000000000000000000000;;				switch t {
0000000000000000000000000000000000000000;;				case EndOfStringToken:
0000000000000000000000000000000000000000;;					return requirements, nil
0000000000000000000000000000000000000000;;				case CommaToken:
0000000000000000000000000000000000000000;;					t2, l2 := p.lookahead(Values)
0000000000000000000000000000000000000000;;					if t2 != IdentifierToken && t2 != DoesNotExistToken {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("found '%s', expected: identifier after ','", l2)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("found '%s', expected: ',' or 'end of string'", l)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case EndOfStringToken:
0000000000000000000000000000000000000000;;				return requirements, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("found '%s', expected: !, identifier, or 'end of string'", lit)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) parseRequirement() (*Requirement, error) {
0000000000000000000000000000000000000000;;		key, operator, err := p.parseKeyAndInferOperator()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if operator == selection.Exists || operator == selection.DoesNotExist { // operator found lookahead set checked
0000000000000000000000000000000000000000;;			return NewRequirement(key, operator, []string{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		operator, err = p.parseOperator()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var values sets.String
0000000000000000000000000000000000000000;;		switch operator {
0000000000000000000000000000000000000000;;		case selection.In, selection.NotIn:
0000000000000000000000000000000000000000;;			values, err = p.parseValues()
0000000000000000000000000000000000000000;;		case selection.Equals, selection.DoubleEquals, selection.NotEquals, selection.GreaterThan, selection.LessThan:
0000000000000000000000000000000000000000;;			values, err = p.parseExactValue()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewRequirement(key, operator, values.List())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseKeyAndInferOperator parse literals.
0000000000000000000000000000000000000000;;	// in case of no operator '!, in, notin, ==, =, !=' are found
0000000000000000000000000000000000000000;;	// the 'exists' operator is inferred
0000000000000000000000000000000000000000;;	func (p *Parser) parseKeyAndInferOperator() (string, selection.Operator, error) {
0000000000000000000000000000000000000000;;		var operator selection.Operator
0000000000000000000000000000000000000000;;		tok, literal := p.consume(Values)
0000000000000000000000000000000000000000;;		if tok == DoesNotExistToken {
0000000000000000000000000000000000000000;;			operator = selection.DoesNotExist
0000000000000000000000000000000000000000;;			tok, literal = p.consume(Values)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tok != IdentifierToken {
0000000000000000000000000000000000000000;;			err := fmt.Errorf("found '%s', expected: identifier", literal)
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := validateLabelKey(literal); err != nil {
0000000000000000000000000000000000000000;;			return "", "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t, _ := p.lookahead(Values); t == EndOfStringToken || t == CommaToken {
0000000000000000000000000000000000000000;;			if operator != selection.DoesNotExist {
0000000000000000000000000000000000000000;;				operator = selection.Exists
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return literal, operator, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseOperator return operator and eventually matchType
0000000000000000000000000000000000000000;;	// matchType can be exact
0000000000000000000000000000000000000000;;	func (p *Parser) parseOperator() (op selection.Operator, err error) {
0000000000000000000000000000000000000000;;		tok, lit := p.consume(KeyAndOperator)
0000000000000000000000000000000000000000;;		switch tok {
0000000000000000000000000000000000000000;;		// DoesNotExistToken shouldn't be here because it's a unary operator, not a binary operator
0000000000000000000000000000000000000000;;		case InToken:
0000000000000000000000000000000000000000;;			op = selection.In
0000000000000000000000000000000000000000;;		case EqualsToken:
0000000000000000000000000000000000000000;;			op = selection.Equals
0000000000000000000000000000000000000000;;		case DoubleEqualsToken:
0000000000000000000000000000000000000000;;			op = selection.DoubleEquals
0000000000000000000000000000000000000000;;		case GreaterThanToken:
0000000000000000000000000000000000000000;;			op = selection.GreaterThan
0000000000000000000000000000000000000000;;		case LessThanToken:
0000000000000000000000000000000000000000;;			op = selection.LessThan
0000000000000000000000000000000000000000;;		case NotInToken:
0000000000000000000000000000000000000000;;			op = selection.NotIn
0000000000000000000000000000000000000000;;		case NotEqualsToken:
0000000000000000000000000000000000000000;;			op = selection.NotEquals
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("found '%s', expected: '=', '!=', '==', 'in', notin'", lit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return op, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseValues parses the values for set based matching (x,y,z)
0000000000000000000000000000000000000000;;	func (p *Parser) parseValues() (sets.String, error) {
0000000000000000000000000000000000000000;;		tok, lit := p.consume(Values)
0000000000000000000000000000000000000000;;		if tok != OpenParToken {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("found '%s' expected: '('", lit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tok, lit = p.lookahead(Values)
0000000000000000000000000000000000000000;;		switch tok {
0000000000000000000000000000000000000000;;		case IdentifierToken, CommaToken:
0000000000000000000000000000000000000000;;			s, err := p.parseIdentifiersList() // handles general cases
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return s, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tok, _ = p.consume(Values); tok != ClosedParToken {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("found '%s', expected: ')'", lit)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s, nil
0000000000000000000000000000000000000000;;		case ClosedParToken: // handles "()"
0000000000000000000000000000000000000000;;			p.consume(Values)
0000000000000000000000000000000000000000;;			return sets.NewString(""), nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("found '%s', expected: ',', ')' or identifier", lit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseIdentifiersList parses a (possibly empty) list of
0000000000000000000000000000000000000000;;	// of comma separated (possibly empty) identifiers
0000000000000000000000000000000000000000;;	func (p *Parser) parseIdentifiersList() (sets.String, error) {
0000000000000000000000000000000000000000;;		s := sets.NewString()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			tok, lit := p.consume(Values)
0000000000000000000000000000000000000000;;			switch tok {
0000000000000000000000000000000000000000;;			case IdentifierToken:
0000000000000000000000000000000000000000;;				s.Insert(lit)
0000000000000000000000000000000000000000;;				tok2, lit2 := p.lookahead(Values)
0000000000000000000000000000000000000000;;				switch tok2 {
0000000000000000000000000000000000000000;;				case CommaToken:
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case ClosedParToken:
0000000000000000000000000000000000000000;;					return s, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("found '%s', expected: ',' or ')'", lit2)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case CommaToken: // handled here since we can have "(,"
0000000000000000000000000000000000000000;;				if s.Len() == 0 {
0000000000000000000000000000000000000000;;					s.Insert("") // to handle (,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tok2, _ := p.lookahead(Values)
0000000000000000000000000000000000000000;;				if tok2 == ClosedParToken {
0000000000000000000000000000000000000000;;					s.Insert("") // to handle ,)  Double "" removed by StringSet
0000000000000000000000000000000000000000;;					return s, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tok2 == CommaToken {
0000000000000000000000000000000000000000;;					p.consume(Values)
0000000000000000000000000000000000000000;;					s.Insert("") // to handle ,, Double "" removed by StringSet
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default: // it can be operator
0000000000000000000000000000000000000000;;				return s, fmt.Errorf("found '%s', expected: ',', or identifier", lit)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseExactValue parses the only value for exact match style
0000000000000000000000000000000000000000;;	func (p *Parser) parseExactValue() (sets.String, error) {
0000000000000000000000000000000000000000;;		s := sets.NewString()
0000000000000000000000000000000000000000;;		tok, lit := p.lookahead(Values)
0000000000000000000000000000000000000000;;		if tok == EndOfStringToken || tok == CommaToken {
0000000000000000000000000000000000000000;;			s.Insert("")
0000000000000000000000000000000000000000;;			return s, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tok, lit = p.consume(Values)
0000000000000000000000000000000000000000;;		if tok == IdentifierToken {
0000000000000000000000000000000000000000;;			s.Insert(lit)
0000000000000000000000000000000000000000;;			return s, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("found '%s', expected: identifier", lit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse takes a string representing a selector and returns a selector
0000000000000000000000000000000000000000;;	// object, or an error. This parsing function differs from ParseSelector
0000000000000000000000000000000000000000;;	// as they parse different selectors with different syntaxes.
0000000000000000000000000000000000000000;;	// The input will cause an error if it does not follow this form:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  <selector-syntax>         ::= <requirement> | <requirement> "," <selector-syntax>
0000000000000000000000000000000000000000;;	//  <requirement>             ::= [!] KEY [ <set-based-restriction> | <exact-match-restriction> ]
0000000000000000000000000000000000000000;;	//  <set-based-restriction>   ::= "" | <inclusion-exclusion> <value-set>
0000000000000000000000000000000000000000;;	//  <inclusion-exclusion>     ::= <inclusion> | <exclusion>
0000000000000000000000000000000000000000;;	//  <exclusion>               ::= "notin"
0000000000000000000000000000000000000000;;	//  <inclusion>               ::= "in"
0000000000000000000000000000000000000000;;	//  <value-set>               ::= "(" <values> ")"
0000000000000000000000000000000000000000;;	//  <values>                  ::= VALUE | VALUE "," <values>
0000000000000000000000000000000000000000;;	//  <exact-match-restriction> ::= ["="|"=="|"!="] VALUE
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// KEY is a sequence of one or more characters following [ DNS_SUBDOMAIN "/" ] DNS_LABEL. Max length is 63 characters.
0000000000000000000000000000000000000000;;	// VALUE is a sequence of zero or more characters "([A-Za-z0-9_-\.])". Max length is 63 characters.
0000000000000000000000000000000000000000;;	// Delimiter is white space: (' ', '\t')
0000000000000000000000000000000000000000;;	// Example of valid syntax:
0000000000000000000000000000000000000000;;	//  "x in (foo,,baz),y,z notin ()"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note:
0000000000000000000000000000000000000000;;	//  (1) Inclusion - " in " - denotes that the KEY exists and is equal to any of the
0000000000000000000000000000000000000000;;	//      VALUEs in its requirement
0000000000000000000000000000000000000000;;	//  (2) Exclusion - " notin " - denotes that the KEY is not equal to any
0000000000000000000000000000000000000000;;	//      of the VALUEs in its requirement or does not exist
0000000000000000000000000000000000000000;;	//  (3) The empty string is a valid VALUE
0000000000000000000000000000000000000000;;	//  (4) A requirement with just a KEY - as in "y" above - denotes that
0000000000000000000000000000000000000000;;	//      the KEY exists and can be any VALUE.
0000000000000000000000000000000000000000;;	//  (5) A requirement with just !KEY requires that the KEY not exist.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func Parse(selector string) (Selector, error) {
0000000000000000000000000000000000000000;;		parsedSelector, err := parse(selector)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return parsedSelector, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parse parses the string representation of the selector and returns the internalSelector struct.
0000000000000000000000000000000000000000;;	// The callers of this method can then decide how to return the internalSelector struct to their
0000000000000000000000000000000000000000;;	// callers. This function has two callers now, one returns a Selector interface and the other
0000000000000000000000000000000000000000;;	// returns a list of requirements.
0000000000000000000000000000000000000000;;	func parse(selector string) (internalSelector, error) {
0000000000000000000000000000000000000000;;		p := &Parser{l: &Lexer{s: selector, pos: 0}}
0000000000000000000000000000000000000000;;		items, err := p.parse()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(ByKey(items)) // sort to grant determistic parsing
0000000000000000000000000000000000000000;;		return internalSelector(items), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateLabelKey(k string) error {
0000000000000000000000000000000000000000;;		if errs := validation.IsQualifiedName(k); len(errs) != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid label key %q: %s", k, strings.Join(errs, "; "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateLabelValue(v string) error {
0000000000000000000000000000000000000000;;		if errs := validation.IsValidLabelValue(v); len(errs) != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid label value: %q: %s", v, strings.Join(errs, "; "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectorFromSet returns a Selector which will match exactly the given Set. A
0000000000000000000000000000000000000000;;	// nil and empty Sets are considered equivalent to Everything().
0000000000000000000000000000000000000000;;	func SelectorFromSet(ls Set) Selector {
0000000000000000000000000000000000000000;;		if ls == nil || len(ls) == 0 {
0000000000000000000000000000000000000000;;			return internalSelector{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var requirements internalSelector
0000000000000000000000000000000000000000;;		for label, value := range ls {
0000000000000000000000000000000000000000;;			r, err := NewRequirement(label, selection.Equals, []string{value})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				requirements = append(requirements, *r)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				//TODO: double check errors when input comes from serialization?
0000000000000000000000000000000000000000;;				return internalSelector{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// sort to have deterministic string representation
0000000000000000000000000000000000000000;;		sort.Sort(ByKey(requirements))
0000000000000000000000000000000000000000;;		return requirements
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectorFromValidatedSet returns a Selector which will match exactly the given Set.
0000000000000000000000000000000000000000;;	// A nil and empty Sets are considered equivalent to Everything().
0000000000000000000000000000000000000000;;	// It assumes that Set is already validated and doesn't do any validation.
0000000000000000000000000000000000000000;;	func SelectorFromValidatedSet(ls Set) Selector {
0000000000000000000000000000000000000000;;		if ls == nil || len(ls) == 0 {
0000000000000000000000000000000000000000;;			return internalSelector{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var requirements internalSelector
0000000000000000000000000000000000000000;;		for label, value := range ls {
0000000000000000000000000000000000000000;;			requirements = append(requirements, Requirement{key: label, operator: selection.Equals, strValues: []string{value}})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// sort to have deterministic string representation
0000000000000000000000000000000000000000;;		sort.Sort(ByKey(requirements))
0000000000000000000000000000000000000000;;		return requirements
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseToRequirements takes a string representing a selector and returns a list of
0000000000000000000000000000000000000000;;	// requirements. This function is suitable for those callers that perform additional
0000000000000000000000000000000000000000;;	// processing on selector requirements.
0000000000000000000000000000000000000000;;	// See the documentation for Parse() function for more details.
0000000000000000000000000000000000000000;;	// TODO: Consider exporting the internalSelector type instead.
0000000000000000000000000000000000000000;;	func ParseToRequirements(selector string) ([]Requirement, error) {
0000000000000000000000000000000000000000;;		return parse(selector)
0000000000000000000000000000000000000000;;	}
