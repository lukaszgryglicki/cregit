0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package labels
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func matches(t *testing.T, ls Set, want string) {
0000000000000000000000000000000000000000;;		if ls.String() != want {
0000000000000000000000000000000000000000;;			t.Errorf("Expected '%s', but got '%s'", want, ls.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetString(t *testing.T) {
0000000000000000000000000000000000000000;;		matches(t, Set{"x": "y"}, "x=y")
0000000000000000000000000000000000000000;;		matches(t, Set{"foo": "bar"}, "foo=bar")
0000000000000000000000000000000000000000;;		matches(t, Set{"foo": "bar", "baz": "qup"}, "baz=qup,foo=bar")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Make our label representation robust enough to handle labels
0000000000000000000000000000000000000000;;		// with ",=!" characters in their names.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelHas(t *testing.T) {
0000000000000000000000000000000000000000;;		labelHasTests := []struct {
0000000000000000000000000000000000000000;;			Ls  Labels
0000000000000000000000000000000000000000;;			Key string
0000000000000000000000000000000000000000;;			Has bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{Set{"x": "y"}, "x", true},
0000000000000000000000000000000000000000;;			{Set{"x": ""}, "x", true},
0000000000000000000000000000000000000000;;			{Set{"x": "y"}, "foo", false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, lh := range labelHasTests {
0000000000000000000000000000000000000000;;			if has := lh.Ls.Has(lh.Key); has != lh.Has {
0000000000000000000000000000000000000000;;				t.Errorf("%#v.Has(%#v) => %v, expected %v", lh.Ls, lh.Key, has, lh.Has)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelGet(t *testing.T) {
0000000000000000000000000000000000000000;;		ls := Set{"x": "y"}
0000000000000000000000000000000000000000;;		if ls.Get("x") != "y" {
0000000000000000000000000000000000000000;;			t.Errorf("Set.Get is broken")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelConflict(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			labels1  map[string]string
0000000000000000000000000000000000000000;;			labels2  map[string]string
0000000000000000000000000000000000000000;;			conflict bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels1:  map[string]string{},
0000000000000000000000000000000000000000;;				labels2:  map[string]string{},
0000000000000000000000000000000000000000;;				conflict: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels1:  map[string]string{"env": "test"},
0000000000000000000000000000000000000000;;				labels2:  map[string]string{"infra": "true"},
0000000000000000000000000000000000000000;;				conflict: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels1:  map[string]string{"env": "test"},
0000000000000000000000000000000000000000;;				labels2:  map[string]string{"infra": "true", "env": "test"},
0000000000000000000000000000000000000000;;				conflict: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels1:  map[string]string{"env": "test"},
0000000000000000000000000000000000000000;;				labels2:  map[string]string{"env": "dev"},
0000000000000000000000000000000000000000;;				conflict: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels1:  map[string]string{"env": "test", "infra": "false"},
0000000000000000000000000000000000000000;;				labels2:  map[string]string{"infra": "true", "color": "blue"},
0000000000000000000000000000000000000000;;				conflict: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			conflict := Conflicts(Set(test.labels1), Set(test.labels2))
0000000000000000000000000000000000000000;;			if conflict != test.conflict {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %v but got: %v", test.conflict, conflict)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelMerge(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			labels1      map[string]string
0000000000000000000000000000000000000000;;			labels2      map[string]string
0000000000000000000000000000000000000000;;			mergedLabels map[string]string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels1:      map[string]string{},
0000000000000000000000000000000000000000;;				labels2:      map[string]string{},
0000000000000000000000000000000000000000;;				mergedLabels: map[string]string{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels1:      map[string]string{"infra": "true"},
0000000000000000000000000000000000000000;;				labels2:      map[string]string{},
0000000000000000000000000000000000000000;;				mergedLabels: map[string]string{"infra": "true"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				labels1:      map[string]string{"infra": "true"},
0000000000000000000000000000000000000000;;				labels2:      map[string]string{"env": "test", "color": "blue"},
0000000000000000000000000000000000000000;;				mergedLabels: map[string]string{"infra": "true", "env": "test", "color": "blue"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			mergedLabels := Merge(Set(test.labels1), Set(test.labels2))
0000000000000000000000000000000000000000;;			if !Equals(mergedLabels, test.mergedLabels) {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %v but got: %v", test.mergedLabels, mergedLabels)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelSelectorParse(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			selector string
0000000000000000000000000000000000000000;;			labels   map[string]string
0000000000000000000000000000000000000000;;			valid    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x=a",
0000000000000000000000000000000000000000;;				labels:   map[string]string{"x": "a"},
0000000000000000000000000000000000000000;;				valid:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x=a,y=b,z=c",
0000000000000000000000000000000000000000;;				labels:   map[string]string{"x": "a", "y": "b", "z": "c"},
0000000000000000000000000000000000000000;;				valid:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: " x = a , y = b , z = c ",
0000000000000000000000000000000000000000;;				labels:   map[string]string{"x": "a", "y": "b", "z": "c"},
0000000000000000000000000000000000000000;;				valid:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "color=green,env=test,service=front",
0000000000000000000000000000000000000000;;				labels:   map[string]string{"color": "green", "env": "test", "service": "front"},
0000000000000000000000000000000000000000;;				valid:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "color=green, env=test, service=front",
0000000000000000000000000000000000000000;;				labels:   map[string]string{"color": "green", "env": "test", "service": "front"},
0000000000000000000000000000000000000000;;				valid:    true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: ",",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x,y",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x=$y",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x!=y",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x==y",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x=a||y=b",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x in (y)",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x notin (y)",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				selector: "x y",
0000000000000000000000000000000000000000;;				labels:   map[string]string{},
0000000000000000000000000000000000000000;;				valid:    false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			labels, err := ConvertSelectorToLabelsMap(test.selector)
0000000000000000000000000000000000000000;;			if test.valid && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("selector: %s, expected no error but got: %s", test.selector, err)
0000000000000000000000000000000000000000;;			} else if !test.valid && err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("selector: %s, expected an error", test.selector)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !Equals(Set(labels), test.labels) {
0000000000000000000000000000000000000000;;				t.Errorf("expected: %s but got: %s", test.labels, labels)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
