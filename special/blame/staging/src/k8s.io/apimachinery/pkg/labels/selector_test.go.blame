0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package labels
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/selection"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelectorParse(t *testing.T) {
0000000000000000000000000000000000000000;;		testGoodStrings := []string{
0000000000000000000000000000000000000000;;			"x=a,y=b,z=c",
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			"x!=a,y=b",
0000000000000000000000000000000000000000;;			"x=",
0000000000000000000000000000000000000000;;			"x= ",
0000000000000000000000000000000000000000;;			"x=,z= ",
0000000000000000000000000000000000000000;;			"x= ,z= ",
0000000000000000000000000000000000000000;;			"!x",
0000000000000000000000000000000000000000;;			"x>1",
0000000000000000000000000000000000000000;;			"x>1,z<5",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testBadStrings := []string{
0000000000000000000000000000000000000000;;			"x=a||y=b",
0000000000000000000000000000000000000000;;			"x==a==b",
0000000000000000000000000000000000000000;;			"!x=a",
0000000000000000000000000000000000000000;;			"x<a",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range testGoodStrings {
0000000000000000000000000000000000000000;;			lq, err := Parse(test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: error %v (%#v)\n", test, err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.Replace(test, " ", "", -1) != lq.String() {
0000000000000000000000000000000000000000;;				t.Errorf("%v restring gave: %v\n", test, lq.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range testBadStrings {
0000000000000000000000000000000000000000;;			_, err := Parse(test)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: did not get expected error\n", test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeterministicParse(t *testing.T) {
0000000000000000000000000000000000000000;;		s1, err := Parse("x=a,a=x")
0000000000000000000000000000000000000000;;		s2, err2 := Parse("a=x,x=a")
0000000000000000000000000000000000000000;;		if err != nil || err2 != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected parse error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s1.String() != s2.String() {
0000000000000000000000000000000000000000;;			t.Errorf("Non-deterministic parse")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectMatch(t *testing.T, selector string, ls Set) {
0000000000000000000000000000000000000000;;		lq, err := Parse(selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to parse %v as a selector\n", selector)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !lq.Matches(ls) {
0000000000000000000000000000000000000000;;			t.Errorf("Wanted %s to match '%s', but it did not.\n", selector, ls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectNoMatch(t *testing.T, selector string, ls Set) {
0000000000000000000000000000000000000000;;		lq, err := Parse(selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to parse %v as a selector\n", selector)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lq.Matches(ls) {
0000000000000000000000000000000000000000;;			t.Errorf("Wanted '%s' to not match '%s', but it did.", selector, ls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEverything(t *testing.T) {
0000000000000000000000000000000000000000;;		if !Everything().Matches(Set{"x": "y"}) {
0000000000000000000000000000000000000000;;			t.Errorf("Nil selector didn't match")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !Everything().Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("Everything was not empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelectorMatches(t *testing.T) {
0000000000000000000000000000000000000000;;		expectMatch(t, "", Set{"x": "y"})
0000000000000000000000000000000000000000;;		expectMatch(t, "x=y", Set{"x": "y"})
0000000000000000000000000000000000000000;;		expectMatch(t, "x=y,z=w", Set{"x": "y", "z": "w"})
0000000000000000000000000000000000000000;;		expectMatch(t, "x!=y,z!=w", Set{"x": "z", "z": "a"})
0000000000000000000000000000000000000000;;		expectMatch(t, "notin=in", Set{"notin": "in"}) // in and notin in exactMatch
0000000000000000000000000000000000000000;;		expectMatch(t, "x", Set{"x": "z"})
0000000000000000000000000000000000000000;;		expectMatch(t, "!x", Set{"y": "z"})
0000000000000000000000000000000000000000;;		expectMatch(t, "x>1", Set{"x": "2"})
0000000000000000000000000000000000000000;;		expectMatch(t, "x<1", Set{"x": "0"})
0000000000000000000000000000000000000000;;		expectNoMatch(t, "x=z", Set{})
0000000000000000000000000000000000000000;;		expectNoMatch(t, "x=y", Set{"x": "z"})
0000000000000000000000000000000000000000;;		expectNoMatch(t, "x=y,z=w", Set{"x": "w", "z": "w"})
0000000000000000000000000000000000000000;;		expectNoMatch(t, "x!=y,z!=w", Set{"x": "z", "z": "w"})
0000000000000000000000000000000000000000;;		expectNoMatch(t, "x", Set{"y": "z"})
0000000000000000000000000000000000000000;;		expectNoMatch(t, "!x", Set{"x": "z"})
0000000000000000000000000000000000000000;;		expectNoMatch(t, "x>1", Set{"x": "0"})
0000000000000000000000000000000000000000;;		expectNoMatch(t, "x<1", Set{"x": "2"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelset := Set{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectMatch(t, "foo=bar", labelset)
0000000000000000000000000000000000000000;;		expectMatch(t, "baz=blah", labelset)
0000000000000000000000000000000000000000;;		expectMatch(t, "foo=bar,baz=blah", labelset)
0000000000000000000000000000000000000000;;		expectNoMatch(t, "foo=blah", labelset)
0000000000000000000000000000000000000000;;		expectNoMatch(t, "baz=bar", labelset)
0000000000000000000000000000000000000000;;		expectNoMatch(t, "foo=bar,foobar=bar,baz=blah", labelset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectMatchDirect(t *testing.T, selector, ls Set) {
0000000000000000000000000000000000000000;;		if !SelectorFromSet(selector).Matches(ls) {
0000000000000000000000000000000000000000;;			t.Errorf("Wanted %s to match '%s', but it did not.\n", selector, ls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectNoMatchDirect(t *testing.T, selector, ls Set) {
0000000000000000000000000000000000000000;;		if SelectorFromSet(selector).Matches(ls) {
0000000000000000000000000000000000000000;;			t.Errorf("Wanted '%s' to not match '%s', but it did.", selector, ls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetMatches(t *testing.T) {
0000000000000000000000000000000000000000;;		labelset := Set{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectMatchDirect(t, Set{}, labelset)
0000000000000000000000000000000000000000;;		expectMatchDirect(t, Set{"foo": "bar"}, labelset)
0000000000000000000000000000000000000000;;		expectMatchDirect(t, Set{"baz": "blah"}, labelset)
0000000000000000000000000000000000000000;;		expectMatchDirect(t, Set{"foo": "bar", "baz": "blah"}, labelset)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//TODO: bad values not handled for the moment in SelectorFromSet
0000000000000000000000000000000000000000;;		//expectNoMatchDirect(t, Set{"foo": "=blah"}, labelset)
0000000000000000000000000000000000000000;;		//expectNoMatchDirect(t, Set{"baz": "=bar"}, labelset)
0000000000000000000000000000000000000000;;		//expectNoMatchDirect(t, Set{"foo": "=bar", "foobar": "bar", "baz": "blah"}, labelset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNilMapIsValid(t *testing.T) {
0000000000000000000000000000000000000000;;		selector := Set(nil).AsSelector()
0000000000000000000000000000000000000000;;		if selector == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Selector for nil set should be Everything")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !selector.Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("Selector for nil set should be Empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetIsEmpty(t *testing.T) {
0000000000000000000000000000000000000000;;		if !(Set{}).AsSelector().Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("Empty set should be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !(NewSelector()).Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("Nil Selector should be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLexer(t *testing.T) {
0000000000000000000000000000000000000000;;		testcases := []struct {
0000000000000000000000000000000000000000;;			s string
0000000000000000000000000000000000000000;;			t Token
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"", EndOfStringToken},
0000000000000000000000000000000000000000;;			{",", CommaToken},
0000000000000000000000000000000000000000;;			{"notin", NotInToken},
0000000000000000000000000000000000000000;;			{"in", InToken},
0000000000000000000000000000000000000000;;			{"=", EqualsToken},
0000000000000000000000000000000000000000;;			{"==", DoubleEqualsToken},
0000000000000000000000000000000000000000;;			{">", GreaterThanToken},
0000000000000000000000000000000000000000;;			{"<", LessThanToken},
0000000000000000000000000000000000000000;;			//Note that Lex returns the longest valid token found
0000000000000000000000000000000000000000;;			{"!", DoesNotExistToken},
0000000000000000000000000000000000000000;;			{"!=", NotEqualsToken},
0000000000000000000000000000000000000000;;			{"(", OpenParToken},
0000000000000000000000000000000000000000;;			{")", ClosedParToken},
0000000000000000000000000000000000000000;;			//Non-"special" characters are considered part of an identifier
0000000000000000000000000000000000000000;;			{"~", IdentifierToken},
0000000000000000000000000000000000000000;;			{"||", IdentifierToken},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range testcases {
0000000000000000000000000000000000000000;;			l := &Lexer{s: v.s, pos: 0}
0000000000000000000000000000000000000000;;			token, lit := l.Lex()
0000000000000000000000000000000000000000;;			if token != v.t {
0000000000000000000000000000000000000000;;				t.Errorf("Got %d it should be %d for '%s'", token, v.t, v.s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v.t != ErrorToken && lit != v.s {
0000000000000000000000000000000000000000;;				t.Errorf("Got '%s' it should be '%s'", lit, v.s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func min(l, r int) (m int) {
0000000000000000000000000000000000000000;;		m = r
0000000000000000000000000000000000000000;;		if l < r {
0000000000000000000000000000000000000000;;			m = l
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLexerSequence(t *testing.T) {
0000000000000000000000000000000000000000;;		testcases := []struct {
0000000000000000000000000000000000000000;;			s string
0000000000000000000000000000000000000000;;			t []Token
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"key in ( value )", []Token{IdentifierToken, InToken, OpenParToken, IdentifierToken, ClosedParToken}},
0000000000000000000000000000000000000000;;			{"key notin ( value )", []Token{IdentifierToken, NotInToken, OpenParToken, IdentifierToken, ClosedParToken}},
0000000000000000000000000000000000000000;;			{"key in ( value1, value2 )", []Token{IdentifierToken, InToken, OpenParToken, IdentifierToken, CommaToken, IdentifierToken, ClosedParToken}},
0000000000000000000000000000000000000000;;			{"key", []Token{IdentifierToken}},
0000000000000000000000000000000000000000;;			{"!key", []Token{DoesNotExistToken, IdentifierToken}},
0000000000000000000000000000000000000000;;			{"()", []Token{OpenParToken, ClosedParToken}},
0000000000000000000000000000000000000000;;			{"x in (),y", []Token{IdentifierToken, InToken, OpenParToken, ClosedParToken, CommaToken, IdentifierToken}},
0000000000000000000000000000000000000000;;			{"== != (), = notin", []Token{DoubleEqualsToken, NotEqualsToken, OpenParToken, ClosedParToken, CommaToken, EqualsToken, NotInToken}},
0000000000000000000000000000000000000000;;			{"key>2", []Token{IdentifierToken, GreaterThanToken, IdentifierToken}},
0000000000000000000000000000000000000000;;			{"key<1", []Token{IdentifierToken, LessThanToken, IdentifierToken}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range testcases {
0000000000000000000000000000000000000000;;			var literals []string
0000000000000000000000000000000000000000;;			var tokens []Token
0000000000000000000000000000000000000000;;			l := &Lexer{s: v.s, pos: 0}
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				token, lit := l.Lex()
0000000000000000000000000000000000000000;;				if token == EndOfStringToken {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tokens = append(tokens, token)
0000000000000000000000000000000000000000;;				literals = append(literals, lit)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(tokens) != len(v.t) {
0000000000000000000000000000000000000000;;				t.Errorf("Bad number of tokens for '%s %d, %d", v.s, len(tokens), len(v.t))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < min(len(tokens), len(v.t)); i++ {
0000000000000000000000000000000000000000;;				if tokens[i] != v.t[i] {
0000000000000000000000000000000000000000;;					t.Errorf("Test '%s': Mismatching in token type found '%v' it should be '%v'", v.s, tokens[i], v.t[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func TestParserLookahead(t *testing.T) {
0000000000000000000000000000000000000000;;		testcases := []struct {
0000000000000000000000000000000000000000;;			s string
0000000000000000000000000000000000000000;;			t []Token
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"key in ( value )", []Token{IdentifierToken, InToken, OpenParToken, IdentifierToken, ClosedParToken, EndOfStringToken}},
0000000000000000000000000000000000000000;;			{"key notin ( value )", []Token{IdentifierToken, NotInToken, OpenParToken, IdentifierToken, ClosedParToken, EndOfStringToken}},
0000000000000000000000000000000000000000;;			{"key in ( value1, value2 )", []Token{IdentifierToken, InToken, OpenParToken, IdentifierToken, CommaToken, IdentifierToken, ClosedParToken, EndOfStringToken}},
0000000000000000000000000000000000000000;;			{"key", []Token{IdentifierToken, EndOfStringToken}},
0000000000000000000000000000000000000000;;			{"!key", []Token{DoesNotExistToken, IdentifierToken, EndOfStringToken}},
0000000000000000000000000000000000000000;;			{"()", []Token{OpenParToken, ClosedParToken, EndOfStringToken}},
0000000000000000000000000000000000000000;;			{"", []Token{EndOfStringToken}},
0000000000000000000000000000000000000000;;			{"x in (),y", []Token{IdentifierToken, InToken, OpenParToken, ClosedParToken, CommaToken, IdentifierToken, EndOfStringToken}},
0000000000000000000000000000000000000000;;			{"== != (), = notin", []Token{DoubleEqualsToken, NotEqualsToken, OpenParToken, ClosedParToken, CommaToken, EqualsToken, NotInToken, EndOfStringToken}},
0000000000000000000000000000000000000000;;			{"key>2", []Token{IdentifierToken, GreaterThanToken, IdentifierToken, EndOfStringToken}},
0000000000000000000000000000000000000000;;			{"key<1", []Token{IdentifierToken, LessThanToken, IdentifierToken, EndOfStringToken}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range testcases {
0000000000000000000000000000000000000000;;			p := &Parser{l: &Lexer{s: v.s, pos: 0}, position: 0}
0000000000000000000000000000000000000000;;			p.scan()
0000000000000000000000000000000000000000;;			if len(p.scannedItems) != len(v.t) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %d items found %d", len(v.t), len(p.scannedItems))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				token, lit := p.lookahead(KeyAndOperator)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				token2, lit2 := p.consume(KeyAndOperator)
0000000000000000000000000000000000000000;;				if token == EndOfStringToken {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if token != token2 || lit != lit2 {
0000000000000000000000000000000000000000;;					t.Errorf("Bad values")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequirementConstructor(t *testing.T) {
0000000000000000000000000000000000000000;;		requirementConstructorTests := []struct {
0000000000000000000000000000000000000000;;			Key     string
0000000000000000000000000000000000000000;;			Op      selection.Operator
0000000000000000000000000000000000000000;;			Vals    sets.String
0000000000000000000000000000000000000000;;			Success bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"x", selection.In, nil, false},
0000000000000000000000000000000000000000;;			{"x", selection.NotIn, sets.NewString(), false},
0000000000000000000000000000000000000000;;			{"x", selection.In, sets.NewString("foo"), true},
0000000000000000000000000000000000000000;;			{"x", selection.NotIn, sets.NewString("foo"), true},
0000000000000000000000000000000000000000;;			{"x", selection.Exists, nil, true},
0000000000000000000000000000000000000000;;			{"x", selection.DoesNotExist, nil, true},
0000000000000000000000000000000000000000;;			{"1foo", selection.In, sets.NewString("bar"), true},
0000000000000000000000000000000000000000;;			{"1234", selection.In, sets.NewString("bar"), true},
0000000000000000000000000000000000000000;;			{"y", selection.GreaterThan, sets.NewString("1"), true},
0000000000000000000000000000000000000000;;			{"z", selection.LessThan, sets.NewString("6"), true},
0000000000000000000000000000000000000000;;			{"foo", selection.GreaterThan, sets.NewString("bar"), false},
0000000000000000000000000000000000000000;;			{"barz", selection.LessThan, sets.NewString("blah"), false},
0000000000000000000000000000000000000000;;			{strings.Repeat("a", 254), selection.Exists, nil, false}, //breaks DNS rule that len(key) <= 253
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, rc := range requirementConstructorTests {
0000000000000000000000000000000000000000;;			if _, err := NewRequirement(rc.Key, rc.Op, rc.Vals.List()); err == nil && !rc.Success {
0000000000000000000000000000000000000000;;				t.Errorf("expected error with key:%#v op:%v vals:%v, got no error", rc.Key, rc.Op, rc.Vals)
0000000000000000000000000000000000000000;;			} else if err != nil && rc.Success {
0000000000000000000000000000000000000000;;				t.Errorf("expected no error with key:%#v op:%v vals:%v, got:%v", rc.Key, rc.Op, rc.Vals, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestToString(t *testing.T) {
0000000000000000000000000000000000000000;;		var req Requirement
0000000000000000000000000000000000000000;;		toStringTests := []struct {
0000000000000000000000000000000000000000;;			In    *internalSelector
0000000000000000000000000000000000000000;;			Out   string
0000000000000000000000000000000000000000;;			Valid bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{&internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.In, sets.NewString("abc", "def"), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.NotIn, sets.NewString("jkl"), t),
0000000000000000000000000000000000000000;;				getRequirement("z", selection.Exists, nil, t)},
0000000000000000000000000000000000000000;;				"x in (abc,def),y notin (jkl),z", true},
0000000000000000000000000000000000000000;;			{&internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.NotIn, sets.NewString("abc", "def"), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.NotEquals, sets.NewString("jkl"), t),
0000000000000000000000000000000000000000;;				getRequirement("z", selection.DoesNotExist, nil, t)},
0000000000000000000000000000000000000000;;				"x notin (abc,def),y!=jkl,!z", true},
0000000000000000000000000000000000000000;;			{&internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.In, sets.NewString("abc", "def"), t),
0000000000000000000000000000000000000000;;				req}, // adding empty req for the trailing ','
0000000000000000000000000000000000000000;;				"x in (abc,def),", false},
0000000000000000000000000000000000000000;;			{&internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.NotIn, sets.NewString("abc"), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.In, sets.NewString("jkl", "mno"), t),
0000000000000000000000000000000000000000;;				getRequirement("z", selection.NotIn, sets.NewString(""), t)},
0000000000000000000000000000000000000000;;				"x notin (abc),y in (jkl,mno),z notin ()", true},
0000000000000000000000000000000000000000;;			{&internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.Equals, sets.NewString("abc"), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.DoubleEquals, sets.NewString("jkl"), t),
0000000000000000000000000000000000000000;;				getRequirement("z", selection.NotEquals, sets.NewString("a"), t),
0000000000000000000000000000000000000000;;				getRequirement("z", selection.Exists, nil, t)},
0000000000000000000000000000000000000000;;				"x=abc,y==jkl,z!=a,z", true},
0000000000000000000000000000000000000000;;			{&internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.GreaterThan, sets.NewString("2"), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.LessThan, sets.NewString("8"), t),
0000000000000000000000000000000000000000;;				getRequirement("z", selection.Exists, nil, t)},
0000000000000000000000000000000000000000;;				"x>2,y<8,z", true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ts := range toStringTests {
0000000000000000000000000000000000000000;;			if out := ts.In.String(); out == "" && ts.Valid {
0000000000000000000000000000000000000000;;				t.Errorf("%#v.String() => '%v' expected no error", ts.In, out)
0000000000000000000000000000000000000000;;			} else if out != ts.Out {
0000000000000000000000000000000000000000;;				t.Errorf("%#v.String() => '%v' want '%v'", ts.In, out, ts.Out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequirementSelectorMatching(t *testing.T) {
0000000000000000000000000000000000000000;;		var req Requirement
0000000000000000000000000000000000000000;;		labelSelectorMatchingTests := []struct {
0000000000000000000000000000000000000000;;			Set   Set
0000000000000000000000000000000000000000;;			Sel   Selector
0000000000000000000000000000000000000000;;			Match bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{Set{"x": "foo", "y": "baz"}, &internalSelector{
0000000000000000000000000000000000000000;;				req,
0000000000000000000000000000000000000000;;			}, false},
0000000000000000000000000000000000000000;;			{Set{"x": "foo", "y": "baz"}, &internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.In, sets.NewString("foo"), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.NotIn, sets.NewString("alpha"), t),
0000000000000000000000000000000000000000;;			}, true},
0000000000000000000000000000000000000000;;			{Set{"x": "foo", "y": "baz"}, &internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.In, sets.NewString("foo"), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.In, sets.NewString("alpha"), t),
0000000000000000000000000000000000000000;;			}, false},
0000000000000000000000000000000000000000;;			{Set{"y": ""}, &internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.NotIn, sets.NewString(""), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.Exists, nil, t),
0000000000000000000000000000000000000000;;			}, true},
0000000000000000000000000000000000000000;;			{Set{"y": ""}, &internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.DoesNotExist, nil, t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.Exists, nil, t),
0000000000000000000000000000000000000000;;			}, true},
0000000000000000000000000000000000000000;;			{Set{"y": ""}, &internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.NotIn, sets.NewString(""), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.DoesNotExist, nil, t),
0000000000000000000000000000000000000000;;			}, false},
0000000000000000000000000000000000000000;;			{Set{"y": "baz"}, &internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.In, sets.NewString(""), t),
0000000000000000000000000000000000000000;;			}, false},
0000000000000000000000000000000000000000;;			{Set{"z": "2"}, &internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("z", selection.GreaterThan, sets.NewString("1"), t),
0000000000000000000000000000000000000000;;			}, true},
0000000000000000000000000000000000000000;;			{Set{"z": "v2"}, &internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("z", selection.GreaterThan, sets.NewString("1"), t),
0000000000000000000000000000000000000000;;			}, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, lsm := range labelSelectorMatchingTests {
0000000000000000000000000000000000000000;;			if match := lsm.Sel.Matches(lsm.Set); match != lsm.Match {
0000000000000000000000000000000000000000;;				t.Errorf("%+v.Matches(%#v) => %v, want %v", lsm.Sel, lsm.Set, match, lsm.Match)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetSelectorParser(t *testing.T) {
0000000000000000000000000000000000000000;;		setSelectorParserTests := []struct {
0000000000000000000000000000000000000000;;			In    string
0000000000000000000000000000000000000000;;			Out   Selector
0000000000000000000000000000000000000000;;			Match bool
0000000000000000000000000000000000000000;;			Valid bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"", NewSelector(), true, true},
0000000000000000000000000000000000000000;;			{"\rx", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.Exists, nil, t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"this-is-a-dns.domain.com/key-with-dash", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("this-is-a-dns.domain.com/key-with-dash", selection.Exists, nil, t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"this-is-another-dns.domain.com/key-with-dash in (so,what)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("this-is-another-dns.domain.com/key-with-dash", selection.In, sets.NewString("so", "what"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"0.1.2.domain/99 notin (10.10.100.1, tick.tack.clock)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("0.1.2.domain/99", selection.NotIn, sets.NewString("10.10.100.1", "tick.tack.clock"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"foo  in	 (abc)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("foo", selection.In, sets.NewString("abc"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x notin\n (abc)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.NotIn, sets.NewString("abc"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x  notin	\t	(abc,def)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.NotIn, sets.NewString("abc", "def"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x in (abc,def)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.In, sets.NewString("abc", "def"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x in (abc,)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.In, sets.NewString("abc", ""), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x in ()", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.In, sets.NewString(""), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x notin (abc,,def),bar,z in (),w", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("bar", selection.Exists, nil, t),
0000000000000000000000000000000000000000;;				getRequirement("w", selection.Exists, nil, t),
0000000000000000000000000000000000000000;;				getRequirement("x", selection.NotIn, sets.NewString("abc", "", "def"), t),
0000000000000000000000000000000000000000;;				getRequirement("z", selection.In, sets.NewString(""), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x,y in (a)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("y", selection.In, sets.NewString("a"), t),
0000000000000000000000000000000000000000;;				getRequirement("x", selection.Exists, nil, t),
0000000000000000000000000000000000000000;;			}, false, true},
0000000000000000000000000000000000000000;;			{"x=a", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.Equals, sets.NewString("a"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x>1", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.GreaterThan, sets.NewString("1"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x<7", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.LessThan, sets.NewString("7"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x=a,y!=b", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.Equals, sets.NewString("a"), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.NotEquals, sets.NewString("b"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x=a,y!=b,z in (h,i,j)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.Equals, sets.NewString("a"), t),
0000000000000000000000000000000000000000;;				getRequirement("y", selection.NotEquals, sets.NewString("b"), t),
0000000000000000000000000000000000000000;;				getRequirement("z", selection.In, sets.NewString("h", "i", "j"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x=a||y=b", internalSelector{}, false, false},
0000000000000000000000000000000000000000;;			{"x,,y", nil, true, false},
0000000000000000000000000000000000000000;;			{",x,y", nil, true, false},
0000000000000000000000000000000000000000;;			{"x nott in (y)", nil, true, false},
0000000000000000000000000000000000000000;;			{"x notin ( )", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.NotIn, sets.NewString(""), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"x notin (, a)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("x", selection.NotIn, sets.NewString("", "a"), t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"a in (xyz),", nil, true, false},
0000000000000000000000000000000000000000;;			{"a in (xyz)b notin ()", nil, true, false},
0000000000000000000000000000000000000000;;			{"a ", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("a", selection.Exists, nil, t),
0000000000000000000000000000000000000000;;			}, true, true},
0000000000000000000000000000000000000000;;			{"a in (x,y,notin, z,in)", internalSelector{
0000000000000000000000000000000000000000;;				getRequirement("a", selection.In, sets.NewString("in", "notin", "x", "y", "z"), t),
0000000000000000000000000000000000000000;;			}, true, true}, // operator 'in' inside list of identifiers
0000000000000000000000000000000000000000;;			{"a in (xyz abc)", nil, false, false}, // no comma
0000000000000000000000000000000000000000;;			{"a notin(", nil, true, false},        // bad formed
0000000000000000000000000000000000000000;;			{"a (", nil, false, false},            // cpar
0000000000000000000000000000000000000000;;			{"(", nil, false, false},              // opar
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ssp := range setSelectorParserTests {
0000000000000000000000000000000000000000;;			if sel, err := Parse(ssp.In); err != nil && ssp.Valid {
0000000000000000000000000000000000000000;;				t.Errorf("Parse(%s) => %v expected no error", ssp.In, err)
0000000000000000000000000000000000000000;;			} else if err == nil && !ssp.Valid {
0000000000000000000000000000000000000000;;				t.Errorf("Parse(%s) => %+v expected error", ssp.In, sel)
0000000000000000000000000000000000000000;;			} else if ssp.Match && !reflect.DeepEqual(sel, ssp.Out) {
0000000000000000000000000000000000000000;;				t.Errorf("Parse(%s) => parse output '%#v' doesn't match '%#v' expected match", ssp.In, sel, ssp.Out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRequirement(key string, op selection.Operator, vals sets.String, t *testing.T) Requirement {
0000000000000000000000000000000000000000;;		req, err := NewRequirement(key, op, vals.List())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("NewRequirement(%v, %v, %v) resulted in error:%v", key, op, vals, err)
0000000000000000000000000000000000000000;;			return Requirement{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *req
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdd(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name        string
0000000000000000000000000000000000000000;;			sel         Selector
0000000000000000000000000000000000000000;;			key         string
0000000000000000000000000000000000000000;;			operator    selection.Operator
0000000000000000000000000000000000000000;;			values      []string
0000000000000000000000000000000000000000;;			refSelector Selector
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"keyInOperator",
0000000000000000000000000000000000000000;;				internalSelector{},
0000000000000000000000000000000000000000;;				"key",
0000000000000000000000000000000000000000;;				selection.In,
0000000000000000000000000000000000000000;;				[]string{"value"},
0000000000000000000000000000000000000000;;				internalSelector{Requirement{"key", selection.In, []string{"value"}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"keyEqualsOperator",
0000000000000000000000000000000000000000;;				internalSelector{Requirement{"key", selection.In, []string{"value"}}},
0000000000000000000000000000000000000000;;				"key2",
0000000000000000000000000000000000000000;;				selection.Equals,
0000000000000000000000000000000000000000;;				[]string{"value2"},
0000000000000000000000000000000000000000;;				internalSelector{
0000000000000000000000000000000000000000;;					Requirement{"key", selection.In, []string{"value"}},
0000000000000000000000000000000000000000;;					Requirement{"key2", selection.Equals, []string{"value2"}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ts := range testCases {
0000000000000000000000000000000000000000;;			req, err := NewRequirement(ts.key, ts.operator, ts.values)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s - Unable to create labels.Requirement", ts.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ts.sel = ts.sel.Add(*req)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(ts.sel, ts.refSelector) {
0000000000000000000000000000000000000000;;				t.Errorf("%s - Expected %v found %v", ts.name, ts.refSelector, ts.sel)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
