0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package labels
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Labels allows you to present labels independently from their storage.
0000000000000000000000000000000000000000;;	type Labels interface {
0000000000000000000000000000000000000000;;		// Has returns whether the provided label exists.
0000000000000000000000000000000000000000;;		Has(label string) (exists bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get returns the value for the provided label.
0000000000000000000000000000000000000000;;		Get(label string) (value string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set is a map of label:value. It implements Labels.
0000000000000000000000000000000000000000;;	type Set map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns all labels listed as a human readable string.
0000000000000000000000000000000000000000;;	// Conveniently, exactly the format that ParseSelector takes.
0000000000000000000000000000000000000000;;	func (ls Set) String() string {
0000000000000000000000000000000000000000;;		selector := make([]string, 0, len(ls))
0000000000000000000000000000000000000000;;		for key, value := range ls {
0000000000000000000000000000000000000000;;			selector = append(selector, key+"="+value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Sort for determinism.
0000000000000000000000000000000000000000;;		sort.StringSlice(selector).Sort()
0000000000000000000000000000000000000000;;		return strings.Join(selector, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns whether the provided label exists in the map.
0000000000000000000000000000000000000000;;	func (ls Set) Has(label string) bool {
0000000000000000000000000000000000000000;;		_, exists := ls[label]
0000000000000000000000000000000000000000;;		return exists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the value in the map for the provided label.
0000000000000000000000000000000000000000;;	func (ls Set) Get(label string) string {
0000000000000000000000000000000000000000;;		return ls[label]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsSelector converts labels into a selectors.
0000000000000000000000000000000000000000;;	func (ls Set) AsSelector() Selector {
0000000000000000000000000000000000000000;;		return SelectorFromSet(ls)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsSelectorPreValidated converts labels into a selector, but
0000000000000000000000000000000000000000;;	// assumes that labels are already validated and thus don't
0000000000000000000000000000000000000000;;	// preform any validation.
0000000000000000000000000000000000000000;;	// According to our measurements this is significantly faster
0000000000000000000000000000000000000000;;	// in codepaths that matter at high scale.
0000000000000000000000000000000000000000;;	func (ls Set) AsSelectorPreValidated() Selector {
0000000000000000000000000000000000000000;;		return SelectorFromValidatedSet(ls)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FormatLabels convert label map into plain string
0000000000000000000000000000000000000000;;	func FormatLabels(labelMap map[string]string) string {
0000000000000000000000000000000000000000;;		l := Set(labelMap).String()
0000000000000000000000000000000000000000;;		if l == "" {
0000000000000000000000000000000000000000;;			l = "<none>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Conflicts takes 2 maps and returns true if there a key match between
0000000000000000000000000000000000000000;;	// the maps but the value doesn't match, and returns false in other cases
0000000000000000000000000000000000000000;;	func Conflicts(labels1, labels2 Set) bool {
0000000000000000000000000000000000000000;;		small := labels1
0000000000000000000000000000000000000000;;		big := labels2
0000000000000000000000000000000000000000;;		if len(labels2) < len(labels1) {
0000000000000000000000000000000000000000;;			small = labels2
0000000000000000000000000000000000000000;;			big = labels1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range small {
0000000000000000000000000000000000000000;;			if val, match := big[k]; match {
0000000000000000000000000000000000000000;;				if val != v {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge combines given maps, and does not check for any conflicts
0000000000000000000000000000000000000000;;	// between the maps. In case of conflicts, second map (labels2) wins
0000000000000000000000000000000000000000;;	func Merge(labels1, labels2 Set) Set {
0000000000000000000000000000000000000000;;		mergedMap := Set{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range labels1 {
0000000000000000000000000000000000000000;;			mergedMap[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range labels2 {
0000000000000000000000000000000000000000;;			mergedMap[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mergedMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equals returns true if the given maps are equal
0000000000000000000000000000000000000000;;	func Equals(labels1, labels2 Set) bool {
0000000000000000000000000000000000000000;;		if len(labels1) != len(labels2) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range labels1 {
0000000000000000000000000000000000000000;;			value, ok := labels2[k]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if value != v {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AreLabelsInWhiteList verifies if the provided label list
0000000000000000000000000000000000000000;;	// is in the provided whitelist and returns true, otherwise false.
0000000000000000000000000000000000000000;;	func AreLabelsInWhiteList(labels, whitelist Set) bool {
0000000000000000000000000000000000000000;;		if len(whitelist) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range labels {
0000000000000000000000000000000000000000;;			value, ok := whitelist[k]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if value != v {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertSelectorToLabelsMap converts selector string to labels map
0000000000000000000000000000000000000000;;	// and validates keys and values
0000000000000000000000000000000000000000;;	func ConvertSelectorToLabelsMap(selector string) (Set, error) {
0000000000000000000000000000000000000000;;		labelsMap := Set{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(selector) == 0 {
0000000000000000000000000000000000000000;;			return labelsMap, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels := strings.Split(selector, ",")
0000000000000000000000000000000000000000;;		for _, label := range labels {
0000000000000000000000000000000000000000;;			l := strings.Split(label, "=")
0000000000000000000000000000000000000000;;			if len(l) != 2 {
0000000000000000000000000000000000000000;;				return labelsMap, fmt.Errorf("invalid selector: %s", l)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key := strings.TrimSpace(l[0])
0000000000000000000000000000000000000000;;			if err := validateLabelKey(key); err != nil {
0000000000000000000000000000000000000000;;				return labelsMap, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value := strings.TrimSpace(l[1])
0000000000000000000000000000000000000000;;			if err := validateLabelValue(value); err != nil {
0000000000000000000000000000000000000000;;				return labelsMap, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			labelsMap[key] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labelsMap, nil
0000000000000000000000000000000000000000;;	}
