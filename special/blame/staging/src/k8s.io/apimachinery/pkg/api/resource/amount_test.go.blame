0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7a0fd96a0e277dc6b58d744af9d5b6242c8ca1f6;pkg/api/resource/amount_test.go[pkg/api/resource/amount_test.go][staging/src/k8s.io/apimachinery/pkg/api/resource/amount_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInt64AmountAsInt64(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			value  int64
0000000000000000000000000000000000000000;;			scale  Scale
0000000000000000000000000000000000000000;;			result int64
0000000000000000000000000000000000000000;;			ok     bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{100, 0, 100, true},
0000000000000000000000000000000000000000;;			{100, 1, 1000, true},
0000000000000000000000000000000000000000;;			{100, -5, 0, false},
0000000000000000000000000000000000000000;;			{100, 100, 0, false},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			r, ok := int64Amount{value: test.value, scale: test.scale}.AsInt64()
0000000000000000000000000000000000000000;;			if r != test.result {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected result: %d", test, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok != test.ok {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected ok: %t", test, ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInt64AmountAdd(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			a, b, c int64Amount
0000000000000000000000000000000000000000;;			ok      bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{int64Amount{value: 100, scale: 1}, int64Amount{value: 10, scale: 2}, int64Amount{value: 200, scale: 1}, true},
0000000000000000000000000000000000000000;;			{int64Amount{value: 100, scale: 1}, int64Amount{value: 1, scale: 2}, int64Amount{value: 110, scale: 1}, true},
0000000000000000000000000000000000000000;;			{int64Amount{value: 100, scale: 1}, int64Amount{value: 1, scale: 100}, int64Amount{value: 1, scale: 100}, false},
0000000000000000000000000000000000000000;;			{int64Amount{value: -5, scale: 2}, int64Amount{value: 50, scale: 1}, int64Amount{value: 0, scale: 1}, true},
0000000000000000000000000000000000000000;;			{int64Amount{value: -5, scale: 2}, int64Amount{value: 5, scale: 2}, int64Amount{value: 0, scale: 2}, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{int64Amount{value: mostPositive, scale: -1}, int64Amount{value: 1, scale: -1}, int64Amount{value: 0, scale: -1}, false},
0000000000000000000000000000000000000000;;			{int64Amount{value: mostPositive, scale: -1}, int64Amount{value: 0, scale: -1}, int64Amount{value: mostPositive, scale: -1}, true},
0000000000000000000000000000000000000000;;			{int64Amount{value: mostPositive / 10, scale: 1}, int64Amount{value: 10, scale: 0}, int64Amount{value: mostPositive, scale: -1}, false},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			c := test.a
0000000000000000000000000000000000000000;;			ok := c.Add(test.b)
0000000000000000000000000000000000000000;;			if ok != test.ok {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected ok: %t", test, ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				if c != test.c {
0000000000000000000000000000000000000000;;					t.Errorf("%v: unexpected result: %d", test, c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if c != test.a {
0000000000000000000000000000000000000000;;					t.Errorf("%v: overflow addition mutated source: %d", test, c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// addition is commutative
0000000000000000000000000000000000000000;;			c = test.b
0000000000000000000000000000000000000000;;			if ok := c.Add(test.a); ok != test.ok {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected ok: %t", test, ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				if c != test.c {
0000000000000000000000000000000000000000;;					t.Errorf("%v: unexpected result: %d", test, c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if c != test.b {
0000000000000000000000000000000000000000;;					t.Errorf("%v: overflow addition mutated source: %d", test, c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func TestInt64AsCanonicalString(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			value    int64
0000000000000000000000000000000000000000;;			scale    Scale
0000000000000000000000000000000000000000;;			result   string
0000000000000000000000000000000000000000;;			exponent int32
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{100, 0, "100", 0},
0000000000000000000000000000000000000000;;			{100, 1, "1", 3},
0000000000000000000000000000000000000000;;			{100, -1, "10", 0},
0000000000000000000000000000000000000000;;			{10800, -10, "1080", -9},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			r, exp := int64Amount{value: test.value, scale: test.scale}.AsCanonicalBytes(nil)
0000000000000000000000000000000000000000;;			if string(r) != test.result {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected result: %s", test, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exp != test.exponent {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected exponent: %d", test, exp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAmountSign(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			i      int64Amount
0000000000000000000000000000000000000000;;			expect int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{int64Amount{value: -50, scale: 1}, -1},
0000000000000000000000000000000000000000;;			{int64Amount{value: 0, scale: 1}, 0},
0000000000000000000000000000000000000000;;			{int64Amount{value: 300, scale: 1}, 1},
0000000000000000000000000000000000000000;;			{int64Amount{value: -50, scale: -8}, -1},
0000000000000000000000000000000000000000;;			{int64Amount{value: 50, scale: -8}, 1},
0000000000000000000000000000000000000000;;			{int64Amount{value: 0, scale: -8}, 0},
0000000000000000000000000000000000000000;;			{int64Amount{value: -50, scale: 0}, -1},
0000000000000000000000000000000000000000;;			{int64Amount{value: 50, scale: 0}, 1},
0000000000000000000000000000000000000000;;			{int64Amount{value: 0, scale: 0}, 0},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, testCase := range table {
0000000000000000000000000000000000000000;;			if result := testCase.i.Sign(); result != testCase.expect {
0000000000000000000000000000000000000000;;				t.Errorf("i: %v, Expected: %v, Actual: %v", testCase.i, testCase.expect, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
