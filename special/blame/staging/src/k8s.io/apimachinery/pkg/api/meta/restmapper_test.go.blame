0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package meta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeConvertor struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fakeConvertor) Convert(in, out, context interface{}) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fakeConvertor) ConvertToVersion(in runtime.Object, _ runtime.GroupVersioner) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return in, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fakeConvertor) ConvertFieldLabel(version, kind, label, value string) (string, string, error) {
0000000000000000000000000000000000000000;;		return label, value, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var validAccessor = resourceAccessor{}
0000000000000000000000000000000000000000;;	var validConvertor = fakeConvertor{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeInterfaces(version schema.GroupVersion) (*VersionInterfaces, error) {
0000000000000000000000000000000000000000;;		return &VersionInterfaces{ObjectConvertor: validConvertor, MetadataAccessor: validAccessor}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var unmatchedErr = errors.New("no version")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmatchedVersionInterfaces(version schema.GroupVersion) (*VersionInterfaces, error) {
0000000000000000000000000000000000000000;;		return nil, unmatchedErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapperVersionAndKindForResource(t *testing.T) {
0000000000000000000000000000000000000000;;		testGroup := "test.group"
0000000000000000000000000000000000000000;;		testVersion := "test"
0000000000000000000000000000000000000000;;		testGroupVersion := schema.GroupVersion{Group: testGroup, Version: testVersion}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Resource               schema.GroupVersionResource
0000000000000000000000000000000000000000;;			GroupVersionToRegister schema.GroupVersion
0000000000000000000000000000000000000000;;			ExpectedGVK            schema.GroupVersionKind
0000000000000000000000000000000000000000;;			Err                    bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{Resource: schema.GroupVersionResource{Resource: "internalobjec"}, Err: true},
0000000000000000000000000000000000000000;;			{Resource: schema.GroupVersionResource{Resource: "internalObjec"}, Err: true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{Resource: schema.GroupVersionResource{Resource: "internalobject"}, ExpectedGVK: testGroupVersion.WithKind("InternalObject")},
0000000000000000000000000000000000000000;;			{Resource: schema.GroupVersionResource{Resource: "internalobjects"}, ExpectedGVK: testGroupVersion.WithKind("InternalObject")},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			mapper := NewDefaultRESTMapper([]schema.GroupVersion{testGroupVersion}, fakeInterfaces)
0000000000000000000000000000000000000000;;			if len(testCase.ExpectedGVK.Kind) != 0 {
0000000000000000000000000000000000000000;;				mapper.Add(testCase.ExpectedGVK, RESTScopeNamespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actualGVK, err := mapper.KindFor(testCase.Resource)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hasErr := err != nil
0000000000000000000000000000000000000000;;			if hasErr != testCase.Err {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error behavior %t: %v", i, testCase.Err, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if actualGVK != testCase.ExpectedGVK {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected version and kind: e=%s a=%s", i, testCase.ExpectedGVK, actualGVK)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapperGroupForResource(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Resource         schema.GroupVersionResource
0000000000000000000000000000000000000000;;			GroupVersionKind schema.GroupVersionKind
0000000000000000000000000000000000000000;;			Err              bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{Resource: schema.GroupVersionResource{Resource: "myObject"}, GroupVersionKind: schema.GroupVersionKind{Group: "testapi", Version: "test", Kind: "MyObject"}},
0000000000000000000000000000000000000000;;			{Resource: schema.GroupVersionResource{Resource: "myobject"}, GroupVersionKind: schema.GroupVersionKind{Group: "testapi2", Version: "test", Kind: "MyObject"}},
0000000000000000000000000000000000000000;;			{Resource: schema.GroupVersionResource{Resource: "myObje"}, Err: true, GroupVersionKind: schema.GroupVersionKind{Group: "testapi", Version: "test", Kind: "MyObject"}},
0000000000000000000000000000000000000000;;			{Resource: schema.GroupVersionResource{Resource: "myobje"}, Err: true, GroupVersionKind: schema.GroupVersionKind{Group: "testapi", Version: "test", Kind: "MyObject"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			mapper := NewDefaultRESTMapper([]schema.GroupVersion{testCase.GroupVersionKind.GroupVersion()}, fakeInterfaces)
0000000000000000000000000000000000000000;;			mapper.Add(testCase.GroupVersionKind, RESTScopeNamespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actualGVK, err := mapper.KindFor(testCase.Resource)
0000000000000000000000000000000000000000;;			if testCase.Err {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d: expected error", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;			} else if actualGVK != testCase.GroupVersionKind {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected group %q, got %q", i, testCase.GroupVersionKind, actualGVK)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapperKindsFor(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Name                     string
0000000000000000000000000000000000000000;;			PreferredOrder           []schema.GroupVersion
0000000000000000000000000000000000000000;;			KindsToRegister          []schema.GroupVersionKind
0000000000000000000000000000000000000000;;			PartialResourceToRequest schema.GroupVersionResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ExpectedKinds   []schema.GroupVersionKind
0000000000000000000000000000000000000000;;			ExpectedKindErr string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// exact matches are preferred
0000000000000000000000000000000000000000;;				Name: "groups, with group exact",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "first-group-1", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group-1", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PartialResourceToRequest: schema.GroupVersionResource{Group: "first-group", Resource: "my-kind"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedKinds: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// group prefixes work
0000000000000000000000000000000000000000;;				Name: "groups, with group prefix",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PartialResourceToRequest: schema.GroupVersionResource{Group: "first", Resource: "my-kind"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedKinds: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// group prefixes can be ambiguous
0000000000000000000000000000000000000000;;				Name: "groups, with ambiguous group prefix",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "first-group-1", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group-1", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PartialResourceToRequest: schema.GroupVersionResource{Group: "first", Resource: "my-kind"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedKinds: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group-1", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedKindErr: " matches multiple kinds ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "ambiguous groups, with preference order",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PartialResourceToRequest: schema.GroupVersionResource{Resource: "my-kinds"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedKinds: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedKindErr: " matches multiple kinds ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "ambiguous groups, with explicit group match",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PartialResourceToRequest: schema.GroupVersionResource{Group: "first-group", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedKinds: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "ambiguous groups, with ambiguous version match",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PartialResourceToRequest: schema.GroupVersionResource{Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedKinds: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedKindErr: " matches multiple kinds ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			tcName := testCase.Name
0000000000000000000000000000000000000000;;			mapper := NewDefaultRESTMapper(testCase.PreferredOrder, fakeInterfaces)
0000000000000000000000000000000000000000;;			for _, kind := range testCase.KindsToRegister {
0000000000000000000000000000000000000000;;				mapper.Add(kind, RESTScopeNamespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actualKinds, err := mapper.KindsFor(testCase.PartialResourceToRequest)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", tcName, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(testCase.ExpectedKinds, actualKinds) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tcName, testCase.ExpectedKinds, actualKinds)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			singleKind, err := mapper.KindFor(testCase.PartialResourceToRequest)
0000000000000000000000000000000000000000;;			if err == nil && len(testCase.ExpectedKindErr) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected error: %v", tcName, testCase.ExpectedKindErr)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if len(testCase.ExpectedKindErr) == 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error: %v", tcName, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if !strings.Contains(err.Error(), testCase.ExpectedKindErr) {
0000000000000000000000000000000000000000;;						t.Errorf("%s: expected %v, got %v", tcName, testCase.ExpectedKindErr, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if testCase.ExpectedKinds[0] != singleKind {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v, got %v", tcName, testCase.ExpectedKinds[0], singleKind)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapperResourcesFor(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Name                             string
0000000000000000000000000000000000000000;;			PreferredOrder                   []schema.GroupVersion
0000000000000000000000000000000000000000;;			KindsToRegister                  []schema.GroupVersionKind
0000000000000000000000000000000000000000;;			PluralPartialResourceToRequest   schema.GroupVersionResource
0000000000000000000000000000000000000000;;			SingularPartialResourceToRequest schema.GroupVersionResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ExpectedResources   []schema.GroupVersionResource
0000000000000000000000000000000000000000;;			ExpectedResourceErr string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// exact matches are preferred
0000000000000000000000000000000000000000;;				Name: "groups, with group exact",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "first-group-1", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group-1", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PluralPartialResourceToRequest:   schema.GroupVersionResource{Group: "first-group", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				SingularPartialResourceToRequest: schema.GroupVersionResource{Group: "first-group", Resource: "my-kind"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedResources: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// group prefixes work
0000000000000000000000000000000000000000;;				Name: "groups, with group prefix",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PluralPartialResourceToRequest:   schema.GroupVersionResource{Group: "first", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				SingularPartialResourceToRequest: schema.GroupVersionResource{Group: "first", Resource: "my-kind"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedResources: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// group prefixes can be ambiguous
0000000000000000000000000000000000000000;;				Name: "groups, with ambiguous group prefix",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "first-group-1", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group-1", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PluralPartialResourceToRequest:   schema.GroupVersionResource{Group: "first", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				SingularPartialResourceToRequest: schema.GroupVersionResource{Group: "first", Resource: "my-kind"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedResources: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "first-group-1", Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedResourceErr: " matches multiple resources ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "ambiguous groups, with preference order",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PluralPartialResourceToRequest:   schema.GroupVersionResource{Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				SingularPartialResourceToRequest: schema.GroupVersionResource{Resource: "my-kind"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedResources: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedResourceErr: " matches multiple resources ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "ambiguous groups, with explicit group match",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PluralPartialResourceToRequest:   schema.GroupVersionResource{Group: "first-group", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				SingularPartialResourceToRequest: schema.GroupVersionResource{Group: "first-group", Resource: "my-kind"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedResources: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Name: "ambiguous groups, with ambiguous version match",
0000000000000000000000000000000000000000;;				PreferredOrder: []schema.GroupVersion{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				KindsToRegister: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "my-kind"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Kind: "your-kind"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PluralPartialResourceToRequest:   schema.GroupVersionResource{Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				SingularPartialResourceToRequest: schema.GroupVersionResource{Version: "first-version", Resource: "my-kind"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ExpectedResources: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "first-group", Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;					{Group: "second-group", Version: "first-version", Resource: "my-kinds"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ExpectedResourceErr: " matches multiple resources ",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			tcName := testCase.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, partialResource := range []schema.GroupVersionResource{testCase.PluralPartialResourceToRequest, testCase.SingularPartialResourceToRequest} {
0000000000000000000000000000000000000000;;				mapper := NewDefaultRESTMapper(testCase.PreferredOrder, fakeInterfaces)
0000000000000000000000000000000000000000;;				for _, kind := range testCase.KindsToRegister {
0000000000000000000000000000000000000000;;					mapper.Add(kind, RESTScopeNamespace)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				actualResources, err := mapper.ResourcesFor(partialResource)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error: %v", tcName, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(testCase.ExpectedResources, actualResources) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v, got %v", tcName, testCase.ExpectedResources, actualResources)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				singleResource, err := mapper.ResourceFor(partialResource)
0000000000000000000000000000000000000000;;				if err == nil && len(testCase.ExpectedResourceErr) != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected error: %v", tcName, testCase.ExpectedResourceErr)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if len(testCase.ExpectedResourceErr) == 0 {
0000000000000000000000000000000000000000;;						t.Errorf("%s: unexpected error: %v", tcName, err)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if !strings.Contains(err.Error(), testCase.ExpectedResourceErr) {
0000000000000000000000000000000000000000;;							t.Errorf("%s: expected %v, got %v", tcName, testCase.ExpectedResourceErr, err)
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if testCase.ExpectedResources[0] != singleResource {
0000000000000000000000000000000000000000;;						t.Errorf("%s: expected %v, got %v", tcName, testCase.ExpectedResources[0], singleResource)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestKindToResource(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Kind             string
0000000000000000000000000000000000000000;;			Plural, Singular string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{Kind: "Pod", Plural: "pods", Singular: "pod"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{Kind: "ReplicationController", Plural: "replicationcontrollers", Singular: "replicationcontroller"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add "ies" when ending with "y"
0000000000000000000000000000000000000000;;			{Kind: "ImageRepository", Plural: "imagerepositories", Singular: "imagerepository"},
0000000000000000000000000000000000000000;;			// Add "es" when ending with "s"
0000000000000000000000000000000000000000;;			{Kind: "miss", Plural: "misses", Singular: "miss"},
0000000000000000000000000000000000000000;;			// Add "s" otherwise
0000000000000000000000000000000000000000;;			{Kind: "lowercase", Plural: "lowercases", Singular: "lowercase"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			version := schema.GroupVersion{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			plural, singular := UnsafeGuessKindToResource(version.WithKind(testCase.Kind))
0000000000000000000000000000000000000000;;			if singular != version.WithResource(testCase.Singular) || plural != version.WithResource(testCase.Plural) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected plural and singular: %v %v", i, plural, singular)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapperResourceSingularizer(t *testing.T) {
0000000000000000000000000000000000000000;;		testGroupVersion := schema.GroupVersion{Group: "tgroup", Version: "test"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Kind     string
0000000000000000000000000000000000000000;;			Plural   string
0000000000000000000000000000000000000000;;			Singular string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{Kind: "Pod", Plural: "pods", Singular: "pod"},
0000000000000000000000000000000000000000;;			{Kind: "ReplicationController", Plural: "replicationcontrollers", Singular: "replicationcontroller"},
0000000000000000000000000000000000000000;;			{Kind: "ImageRepository", Plural: "imagerepositories", Singular: "imagerepository"},
0000000000000000000000000000000000000000;;			{Kind: "Status", Plural: "statuses", Singular: "status"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{Kind: "lowercase", Plural: "lowercases", Singular: "lowercase"},
0000000000000000000000000000000000000000;;			// TODO this test is broken.  This updates to reflect actual behavior.  Kinds are expected to be singular
0000000000000000000000000000000000000000;;			// old (incorrect), coment: Don't add extra s if the original object is already plural
0000000000000000000000000000000000000000;;			{Kind: "lowercases", Plural: "lowercaseses", Singular: "lowercases"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			mapper := NewDefaultRESTMapper([]schema.GroupVersion{testGroupVersion}, fakeInterfaces)
0000000000000000000000000000000000000000;;			// create singular/plural mapping
0000000000000000000000000000000000000000;;			mapper.Add(testGroupVersion.WithKind(testCase.Kind), RESTScopeNamespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			singular, err := mapper.ResourceSingularizer(testCase.Plural)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if singular != testCase.Singular {
0000000000000000000000000000000000000000;;				t.Errorf("%d: mismatched singular: got %v, expected %v", i, singular, testCase.Singular)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapperRESTMapping(t *testing.T) {
0000000000000000000000000000000000000000;;		testGroup := "tgroup"
0000000000000000000000000000000000000000;;		testGroupVersion := schema.GroupVersion{Group: testGroup, Version: "test"}
0000000000000000000000000000000000000000;;		internalGroupVersion := schema.GroupVersion{Group: testGroup, Version: "test"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Kind             string
0000000000000000000000000000000000000000;;			APIGroupVersions []schema.GroupVersion
0000000000000000000000000000000000000000;;			DefaultVersions  []schema.GroupVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Resource             string
0000000000000000000000000000000000000000;;			ExpectedGroupVersion *schema.GroupVersion
0000000000000000000000000000000000000000;;			Err                  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{Kind: "Unknown", Err: true},
0000000000000000000000000000000000000000;;			{Kind: "InternalObject", Err: true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{DefaultVersions: []schema.GroupVersion{testGroupVersion}, Kind: "Unknown", Err: true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{DefaultVersions: []schema.GroupVersion{testGroupVersion}, Kind: "InternalObject", APIGroupVersions: []schema.GroupVersion{{Group: testGroup, Version: "test"}}, Resource: "internalobjects"},
0000000000000000000000000000000000000000;;			{DefaultVersions: []schema.GroupVersion{testGroupVersion}, Kind: "InternalObject", APIGroupVersions: []schema.GroupVersion{{Group: testGroup, Version: "test"}}, Resource: "internalobjects"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{DefaultVersions: []schema.GroupVersion{testGroupVersion}, Kind: "InternalObject", APIGroupVersions: []schema.GroupVersion{{Group: testGroup, Version: "test"}}, Resource: "internalobjects"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{DefaultVersions: []schema.GroupVersion{testGroupVersion}, Kind: "InternalObject", APIGroupVersions: []schema.GroupVersion{}, Resource: "internalobjects", ExpectedGroupVersion: &schema.GroupVersion{Group: testGroup, Version: "test"}},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{DefaultVersions: []schema.GroupVersion{testGroupVersion}, Kind: "InternalObject", APIGroupVersions: []schema.GroupVersion{{Group: testGroup, Version: "test"}}, Resource: "internalobjects"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: add test for a resource that exists in one version but not another
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			mapper := NewDefaultRESTMapper(testCase.DefaultVersions, fakeInterfaces)
0000000000000000000000000000000000000000;;			mapper.Add(internalGroupVersion.WithKind("InternalObject"), RESTScopeNamespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			preferredVersions := []string{}
0000000000000000000000000000000000000000;;			for _, gv := range testCase.APIGroupVersions {
0000000000000000000000000000000000000000;;				preferredVersions = append(preferredVersions, gv.Version)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gk := schema.GroupKind{Group: testGroup, Kind: testCase.Kind}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapping, err := mapper.RESTMapping(gk, preferredVersions...)
0000000000000000000000000000000000000000;;			hasErr := err != nil
0000000000000000000000000000000000000000;;			if hasErr != testCase.Err {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error behavior %t: %v", i, testCase.Err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasErr {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mapping.Resource != testCase.Resource {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected resource: %#v", i, mapping)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if mapping.MetadataAccessor == nil || mapping.ObjectConvertor == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: missing codec and accessor: %#v", i, mapping)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			groupVersion := testCase.ExpectedGroupVersion
0000000000000000000000000000000000000000;;			if groupVersion == nil {
0000000000000000000000000000000000000000;;				groupVersion = &testCase.APIGroupVersions[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mapping.GroupVersionKind.GroupVersion() != *groupVersion {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected version: %#v", i, mapping)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapperRESTMappingSelectsVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		expectedGroupVersion1 := schema.GroupVersion{Group: "tgroup", Version: "test1"}
0000000000000000000000000000000000000000;;		expectedGroupVersion2 := schema.GroupVersion{Group: "tgroup", Version: "test2"}
0000000000000000000000000000000000000000;;		expectedGroupVersion3 := schema.GroupVersion{Group: "tgroup", Version: "test3"}
0000000000000000000000000000000000000000;;		internalObjectGK := schema.GroupKind{Group: "tgroup", Kind: "InternalObject"}
0000000000000000000000000000000000000000;;		otherObjectGK := schema.GroupKind{Group: "tgroup", Kind: "OtherObject"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper := NewDefaultRESTMapper([]schema.GroupVersion{expectedGroupVersion1, expectedGroupVersion2}, fakeInterfaces)
0000000000000000000000000000000000000000;;		mapper.Add(expectedGroupVersion1.WithKind("InternalObject"), RESTScopeNamespace)
0000000000000000000000000000000000000000;;		mapper.Add(expectedGroupVersion2.WithKind("OtherObject"), RESTScopeNamespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pick default matching object kind based on search order
0000000000000000000000000000000000000000;;		mapping, err := mapper.RESTMapping(otherObjectGK)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mapping.Resource != "otherobjects" || mapping.GroupVersionKind.GroupVersion() != expectedGroupVersion2 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected mapping: %#v", mapping)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapping, err = mapper.RESTMapping(internalObjectGK)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mapping.Resource != "internalobjects" || mapping.GroupVersionKind.GroupVersion() != expectedGroupVersion1 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected mapping: %#v", mapping)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mismatch of version
0000000000000000000000000000000000000000;;		mapping, err = mapper.RESTMapping(internalObjectGK, expectedGroupVersion2.Version)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapping, err = mapper.RESTMapping(otherObjectGK, expectedGroupVersion1.Version)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// not in the search versions
0000000000000000000000000000000000000000;;		mapping, err = mapper.RESTMapping(otherObjectGK, expectedGroupVersion3.Version)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// explicit search order
0000000000000000000000000000000000000000;;		mapping, err = mapper.RESTMapping(otherObjectGK, expectedGroupVersion3.Version, expectedGroupVersion1.Version)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapping, err = mapper.RESTMapping(otherObjectGK, expectedGroupVersion3.Version, expectedGroupVersion2.Version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mapping.Resource != "otherobjects" || mapping.GroupVersionKind.GroupVersion() != expectedGroupVersion2 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected mapping: %#v", mapping)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapperRESTMappings(t *testing.T) {
0000000000000000000000000000000000000000;;		testGroup := "tgroup"
0000000000000000000000000000000000000000;;		testGroupVersion := schema.GroupVersion{Group: testGroup, Version: "v1"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			Kind                string
0000000000000000000000000000000000000000;;			APIGroupVersions    []schema.GroupVersion
0000000000000000000000000000000000000000;;			DefaultVersions     []schema.GroupVersion
0000000000000000000000000000000000000000;;			AddGroupVersionKind []schema.GroupVersionKind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ExpectedRESTMappings []*RESTMapping
0000000000000000000000000000000000000000;;			Err                  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{Kind: "Unknown", Err: true},
0000000000000000000000000000000000000000;;			{Kind: "InternalObject", Err: true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{DefaultVersions: []schema.GroupVersion{testGroupVersion}, Kind: "Unknown", Err: true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ask for specific version - not available - thus error
0000000000000000000000000000000000000000;;			{DefaultVersions: []schema.GroupVersion{testGroupVersion}, Kind: "InternalObject", APIGroupVersions: []schema.GroupVersion{{Group: testGroup, Version: "v2"}}, Err: true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ask for specific version - available - check ExpectedRESTMappings
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				DefaultVersions:      []schema.GroupVersion{testGroupVersion},
0000000000000000000000000000000000000000;;				Kind:                 "InternalObject",
0000000000000000000000000000000000000000;;				APIGroupVersions:     []schema.GroupVersion{{Group: testGroup, Version: "v2"}},
0000000000000000000000000000000000000000;;				AddGroupVersionKind:  []schema.GroupVersionKind{schema.GroupVersion{Group: testGroup, Version: "v2"}.WithKind("InternalObject")},
0000000000000000000000000000000000000000;;				ExpectedRESTMappings: []*RESTMapping{{Resource: "internalobjects", GroupVersionKind: schema.GroupVersionKind{Group: testGroup, Version: "v2", Kind: "InternalObject"}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ask for specific versions - only one available - check ExpectedRESTMappings
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				DefaultVersions:      []schema.GroupVersion{testGroupVersion},
0000000000000000000000000000000000000000;;				Kind:                 "InternalObject",
0000000000000000000000000000000000000000;;				APIGroupVersions:     []schema.GroupVersion{{Group: testGroup, Version: "v3"}, {Group: testGroup, Version: "v2"}},
0000000000000000000000000000000000000000;;				AddGroupVersionKind:  []schema.GroupVersionKind{schema.GroupVersion{Group: testGroup, Version: "v2"}.WithKind("InternalObject")},
0000000000000000000000000000000000000000;;				ExpectedRESTMappings: []*RESTMapping{{Resource: "internalobjects", GroupVersionKind: schema.GroupVersionKind{Group: testGroup, Version: "v2", Kind: "InternalObject"}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// do not ask for specific version - search through default versions - check ExpectedRESTMappings
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				DefaultVersions:      []schema.GroupVersion{testGroupVersion, {Group: testGroup, Version: "v2"}},
0000000000000000000000000000000000000000;;				Kind:                 "InternalObject",
0000000000000000000000000000000000000000;;				AddGroupVersionKind:  []schema.GroupVersionKind{schema.GroupVersion{Group: testGroup, Version: "v1"}.WithKind("InternalObject"), schema.GroupVersion{Group: testGroup, Version: "v2"}.WithKind("InternalObject")},
0000000000000000000000000000000000000000;;				ExpectedRESTMappings: []*RESTMapping{{Resource: "internalobjects", GroupVersionKind: schema.GroupVersionKind{Group: testGroup, Version: "v1", Kind: "InternalObject"}}, {Resource: "internalobjects", GroupVersionKind: schema.GroupVersionKind{Group: testGroup, Version: "v2", Kind: "InternalObject"}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			mapper := NewDefaultRESTMapper(testCase.DefaultVersions, fakeInterfaces)
0000000000000000000000000000000000000000;;			for _, gvk := range testCase.AddGroupVersionKind {
0000000000000000000000000000000000000000;;				mapper.Add(gvk, RESTScopeNamespace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			preferredVersions := []string{}
0000000000000000000000000000000000000000;;			for _, gv := range testCase.APIGroupVersions {
0000000000000000000000000000000000000000;;				preferredVersions = append(preferredVersions, gv.Version)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gk := schema.GroupKind{Group: testGroup, Kind: testCase.Kind}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mappings, err := mapper.RESTMappings(gk, preferredVersions...)
0000000000000000000000000000000000000000;;			hasErr := err != nil
0000000000000000000000000000000000000000;;			if hasErr != testCase.Err {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error behavior %t: %v", i, testCase.Err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasErr {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(mappings) != len(testCase.ExpectedRESTMappings) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected number = %d of rest mappings was returned, expected = %d", i, len(mappings), len(testCase.ExpectedRESTMappings))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j, mapping := range mappings {
0000000000000000000000000000000000000000;;				exp := testCase.ExpectedRESTMappings[j]
0000000000000000000000000000000000000000;;				if mapping.Resource != exp.Resource {
0000000000000000000000000000000000000000;;					t.Errorf("%d - %d: unexpected resource: %#v", i, j, mapping)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if mapping.MetadataAccessor == nil || mapping.ObjectConvertor == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d - %d: missing codec and accessor: %#v", i, j, mapping)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if mapping.GroupVersionKind != exp.GroupVersionKind {
0000000000000000000000000000000000000000;;					t.Errorf("%d - %d: unexpected GroupVersionKind: %#v", i, j, mapping)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRESTMapperReportsErrorOnBadVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		expectedGroupVersion1 := schema.GroupVersion{Group: "tgroup", Version: "test1"}
0000000000000000000000000000000000000000;;		expectedGroupVersion2 := schema.GroupVersion{Group: "tgroup", Version: "test2"}
0000000000000000000000000000000000000000;;		internalObjectGK := schema.GroupKind{Group: "tgroup", Kind: "InternalObject"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper := NewDefaultRESTMapper([]schema.GroupVersion{expectedGroupVersion1, expectedGroupVersion2}, unmatchedVersionInterfaces)
0000000000000000000000000000000000000000;;		mapper.Add(expectedGroupVersion1.WithKind("InternalObject"), RESTScopeNamespace)
0000000000000000000000000000000000000000;;		_, err := mapper.RESTMapping(internalObjectGK, expectedGroupVersion1.Version)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
