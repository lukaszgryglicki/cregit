0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
b6f41b9b6d756eca050354b933348dec59b3bdac;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValueFuzz(t *testing.T) {
0000000000000000000000000000000000000000;;		type (
0000000000000000000000000000000000000000;;			Y struct {
0000000000000000000000000000000000000000;;				I int
0000000000000000000000000000000000000000;;				B bool
0000000000000000000000000000000000000000;;				F float32
0000000000000000000000000000000000000000;;				U uint
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			X struct {
0000000000000000000000000000000000000000;;				Ptr   *X
0000000000000000000000000000000000000000;;				Y     Y
0000000000000000000000000000000000000000;;				Map   map[string]int
0000000000000000000000000000000000000000;;				Slice []int
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := X{
0000000000000000000000000000000000000000;;			Ptr:   &X{},
0000000000000000000000000000000000000000;;			Map:   map[string]int{"foo": 42},
0000000000000000000000000000000000000000;;			Slice: []int{1, 2, 3},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := x.Ptr
0000000000000000000000000000000000000000;;		m := x.Map
0000000000000000000000000000000000000000;;		s := x.Slice
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ValueFuzz(x)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if x.Ptr.Y.I == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("x.Ptr.Y.I should have changed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if x.Map["foo"] == 42 {
0000000000000000000000000000000000000000;;			t.Errorf("x.Map[foo] should have changed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if x.Slice[0] == 1 {
0000000000000000000000000000000000000000;;			t.Errorf("x.Slice[0] should have changed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if x.Ptr != p {
0000000000000000000000000000000000000000;;			t.Errorf("x.Ptr changed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m["foo"] = 7
0000000000000000000000000000000000000000;;		if x.Map["foo"] != m["foo"] {
0000000000000000000000000000000000000000;;			t.Errorf("x.Map changed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s[0] = 7
0000000000000000000000000000000000000000;;		if x.Slice[0] != s[0] {
0000000000000000000000000000000000000000;;			t.Errorf("x.Slice changed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
