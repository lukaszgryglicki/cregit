0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
3272af7b8b69c62f547b74e73eb0bfc1884164cf;pkg/api/resource/quantity_test.go[pkg/api/resource/quantity_test.go][staging/src/k8s.io/apimachinery/pkg/api/resource/quantity_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fuzz "github.com/google/gofuzz"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inf "gopkg.in/inf.v0"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var useInfDec bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func amount(i int64, exponent int) infDecAmount {
0000000000000000000000000000000000000000;;		// See the below test-- scale is the negative of an exponent.
0000000000000000000000000000000000000000;;		return infDecAmount{inf.NewDec(i, inf.Scale(-exponent))}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dec(i int64, exponent int) infDecAmount {
0000000000000000000000000000000000000000;;		// See the below test-- scale is the negative of an exponent.
0000000000000000000000000000000000000000;;		return infDecAmount{inf.NewDec(i, inf.Scale(-exponent))}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decQuantity(i int64, exponent int, format Format) Quantity {
0000000000000000000000000000000000000000;;		return Quantity{d: dec(i, exponent), Format: format}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func intQuantity(i int64, exponent Scale, format Format) Quantity {
0000000000000000000000000000000000000000;;		return Quantity{i: int64Amount{value: i, scale: exponent}, Format: format}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDec(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			got    infDecAmount
0000000000000000000000000000000000000000;;			expect string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{dec(1, 0), "1"},
0000000000000000000000000000000000000000;;			{dec(1, 1), "10"},
0000000000000000000000000000000000000000;;			{dec(5, 2), "500"},
0000000000000000000000000000000000000000;;			{dec(8, 3), "8000"},
0000000000000000000000000000000000000000;;			{dec(2, 0), "2"},
0000000000000000000000000000000000000000;;			{dec(1, -1), "0.1"},
0000000000000000000000000000000000000000;;			{dec(3, -2), "0.03"},
0000000000000000000000000000000000000000;;			{dec(4, -3), "0.004"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			if e, a := item.expect, item.got.Dec.String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestQuantityParseZero ensures that when a 0 quantity is passed, its string value is 0
0000000000000000000000000000000000000000;;	func TestQuantityParseZero(t *testing.T) {
0000000000000000000000000000000000000000;;		zero := MustParse("0")
0000000000000000000000000000000000000000;;		if expected, actual := "0", zero.String(); expected != actual {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual %v", expected, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestQuantityParseNonNumericError ensures that when a non-numeric string is parsed
0000000000000000000000000000000000000000;;	// it panics
0000000000000000000000000000000000000000;;	func TestQuantityParseNonNumericPanic(t *testing.T) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if r := recover(); r == nil {
0000000000000000000000000000000000000000;;				t.Errorf("MustParse did not panic")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		_ = MustParse("Non-Numeric")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestQuantityAddZeroPreservesSuffix verifies that a suffix is preserved
0000000000000000000000000000000000000000;;	// independent of the order of operations when adding a zero and non-zero val
0000000000000000000000000000000000000000;;	func TestQuantityAddZeroPreservesSuffix(t *testing.T) {
0000000000000000000000000000000000000000;;		testValues := []string{"100m", "1Gi"}
0000000000000000000000000000000000000000;;		zero := MustParse("0")
0000000000000000000000000000000000000000;;		for _, testValue := range testValues {
0000000000000000000000000000000000000000;;			value := MustParse(testValue)
0000000000000000000000000000000000000000;;			v1 := *value.Copy()
0000000000000000000000000000000000000000;;			// ensure non-zero + zero = non-zero (suffix preserved)
0000000000000000000000000000000000000000;;			v1.Add(zero)
0000000000000000000000000000000000000000;;			// ensure zero + non-zero = non-zero (suffix preserved)
0000000000000000000000000000000000000000;;			v2 := *zero.Copy()
0000000000000000000000000000000000000000;;			v2.Add(value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v1.String() != testValue {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, actual %v", testValue, v1.String())
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v2.String() != testValue {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, actual %v", testValue, v2.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestQuantitySubZeroPreservesSuffix verifies that a suffix is preserved
0000000000000000000000000000000000000000;;	// independent of the order of operations when subtracting a zero and non-zero val
0000000000000000000000000000000000000000;;	func TestQuantitySubZeroPreservesSuffix(t *testing.T) {
0000000000000000000000000000000000000000;;		testValues := []string{"100m", "1Gi"}
0000000000000000000000000000000000000000;;		zero := MustParse("0")
0000000000000000000000000000000000000000;;		for _, testValue := range testValues {
0000000000000000000000000000000000000000;;			value := MustParse(testValue)
0000000000000000000000000000000000000000;;			v1 := *value.Copy()
0000000000000000000000000000000000000000;;			// ensure non-zero - zero = non-zero (suffix preserved)
0000000000000000000000000000000000000000;;			v1.Sub(zero)
0000000000000000000000000000000000000000;;			// ensure we preserved the input value
0000000000000000000000000000000000000000;;			if v1.String() != testValue {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, actual %v", testValue, v1.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ensure zero - non-zero = -non-zero (suffix preserved)
0000000000000000000000000000000000000000;;			v2 := *zero.Copy()
0000000000000000000000000000000000000000;;			v2.Sub(value)
0000000000000000000000000000000000000000;;			negVal := *value.Copy()
0000000000000000000000000000000000000000;;			negVal.Neg()
0000000000000000000000000000000000000000;;			if v2.String() != negVal.String() {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, actual %v", negVal.String(), v2.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verifies that you get 0 as canonical value if internal value is 0, and not 0<suffix>
0000000000000000000000000000000000000000;;	func TestQuantityCanocicalizeZero(t *testing.T) {
0000000000000000000000000000000000000000;;		val := MustParse("1000m")
0000000000000000000000000000000000000000;;		val.i.Sub(int64Amount{value: 1})
0000000000000000000000000000000000000000;;		zero := Quantity{i: val.i, Format: DecimalSI}
0000000000000000000000000000000000000000;;		if expected, actual := "0", zero.String(); expected != actual {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, actual %v", expected, actual)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQuantityCmp(t *testing.T) {
0000000000000000000000000000000000000000;;		// Test when d is nil
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			x      string
0000000000000000000000000000000000000000;;			y      string
0000000000000000000000000000000000000000;;			expect int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"0", "0", 0},
0000000000000000000000000000000000000000;;			{"100m", "50m", 1},
0000000000000000000000000000000000000000;;			{"50m", "100m", -1},
0000000000000000000000000000000000000000;;			{"10000T", "100Gi", 1},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, testCase := range table {
0000000000000000000000000000000000000000;;			q1 := MustParse(testCase.x)
0000000000000000000000000000000000000000;;			q2 := MustParse(testCase.y)
0000000000000000000000000000000000000000;;			if result := q1.Cmp(q2); result != testCase.expect {
0000000000000000000000000000000000000000;;				t.Errorf("X: %v, Y: %v, Expected: %v, Actual: %v", testCase.x, testCase.y, testCase.expect, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Test when i is {0,0}
0000000000000000000000000000000000000000;;		table2 := []struct {
0000000000000000000000000000000000000000;;			x      *inf.Dec
0000000000000000000000000000000000000000;;			y      *inf.Dec
0000000000000000000000000000000000000000;;			expect int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{dec(0, 0).Dec, dec(0, 0).Dec, 0},
0000000000000000000000000000000000000000;;			{nil, dec(0, 0).Dec, 0},
0000000000000000000000000000000000000000;;			{dec(0, 0).Dec, nil, 0},
0000000000000000000000000000000000000000;;			{nil, nil, 0},
0000000000000000000000000000000000000000;;			{nil, dec(10, 0).Dec, -1},
0000000000000000000000000000000000000000;;			{nil, dec(-10, 0).Dec, 1},
0000000000000000000000000000000000000000;;			{dec(10, 0).Dec, nil, 1},
0000000000000000000000000000000000000000;;			{dec(-10, 0).Dec, nil, -1},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, testCase := range table2 {
0000000000000000000000000000000000000000;;			q1 := Quantity{d: infDecAmount{testCase.x}, Format: DecimalSI}
0000000000000000000000000000000000000000;;			q2 := Quantity{d: infDecAmount{testCase.y}, Format: DecimalSI}
0000000000000000000000000000000000000000;;			if result := q1.Cmp(q2); result != testCase.expect {
0000000000000000000000000000000000000000;;				t.Errorf("X: %v, Y: %v, Expected: %v, Actual: %v", testCase.x, testCase.y, testCase.expect, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseQuantityString(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			input              string
0000000000000000000000000000000000000000;;			positive           bool
0000000000000000000000000000000000000000;;			value              string
0000000000000000000000000000000000000000;;			num, denom, suffix string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"0.025Ti", true, "0.025", "0", "025", "Ti"},
0000000000000000000000000000000000000000;;			{"1.025Ti", true, "1.025", "1", "025", "Ti"},
0000000000000000000000000000000000000000;;			{"-1.025Ti", false, "-1.025", "1", "025", "Ti"},
0000000000000000000000000000000000000000;;			{".", true, ".", "0", "", ""},
0000000000000000000000000000000000000000;;			{"-.", false, "-.", "0", "", ""},
0000000000000000000000000000000000000000;;			{"1E-3", true, "1", "1", "", "E-3"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range table {
0000000000000000000000000000000000000000;;			positive, value, num, denom, suffix, err := parseQuantityString(test.input)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: error: %v", test.input, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if positive != test.positive || value != test.value || num != test.num || denom != test.denom || suffix != test.suffix {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unmatched: %t %q %q %q %q", test.input, positive, value, num, denom, suffix)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQuantityParse(t *testing.T) {
0000000000000000000000000000000000000000;;		if _, err := ParseQuantity(""); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected empty string to return error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			input  string
0000000000000000000000000000000000000000;;			expect Quantity
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"0", decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0n", decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0u", decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0m", decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0Ki", decQuantity(0, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"0k", decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0Mi", decQuantity(0, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"0M", decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0Gi", decQuantity(0, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"0G", decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0Ti", decQuantity(0, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"0T", decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Quantity less numbers are allowed
0000000000000000000000000000000000000000;;			{"1", decQuantity(1, 0, DecimalSI)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Binary suffixes
0000000000000000000000000000000000000000;;			{"1Ki", decQuantity(1024, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"8Ki", decQuantity(8*1024, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"7Mi", decQuantity(7*1024*1024, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"6Gi", decQuantity(6*1024*1024*1024, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"5Ti", decQuantity(5*1024*1024*1024*1024, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"4Pi", decQuantity(4*1024*1024*1024*1024*1024, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"3Ei", decQuantity(3*1024*1024*1024*1024*1024*1024, 0, BinarySI)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"10Ti", decQuantity(10*1024*1024*1024*1024, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"100Ti", decQuantity(100*1024*1024*1024*1024, 0, BinarySI)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Decimal suffixes
0000000000000000000000000000000000000000;;			{"5n", decQuantity(5, -9, DecimalSI)},
0000000000000000000000000000000000000000;;			{"4u", decQuantity(4, -6, DecimalSI)},
0000000000000000000000000000000000000000;;			{"3m", decQuantity(3, -3, DecimalSI)},
0000000000000000000000000000000000000000;;			{"9", decQuantity(9, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"8k", decQuantity(8, 3, DecimalSI)},
0000000000000000000000000000000000000000;;			{"50k", decQuantity(5, 4, DecimalSI)},
0000000000000000000000000000000000000000;;			{"7M", decQuantity(7, 6, DecimalSI)},
0000000000000000000000000000000000000000;;			{"6G", decQuantity(6, 9, DecimalSI)},
0000000000000000000000000000000000000000;;			{"5T", decQuantity(5, 12, DecimalSI)},
0000000000000000000000000000000000000000;;			{"40T", decQuantity(4, 13, DecimalSI)},
0000000000000000000000000000000000000000;;			{"300T", decQuantity(3, 14, DecimalSI)},
0000000000000000000000000000000000000000;;			{"2P", decQuantity(2, 15, DecimalSI)},
0000000000000000000000000000000000000000;;			{"1E", decQuantity(1, 18, DecimalSI)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Decimal exponents
0000000000000000000000000000000000000000;;			{"1E-3", decQuantity(1, -3, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1e3", decQuantity(1, 3, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1E6", decQuantity(1, 6, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1e9", decQuantity(1, 9, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1E12", decQuantity(1, 12, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1e15", decQuantity(1, 15, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1E18", decQuantity(1, 18, DecimalExponent)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Nonstandard but still parsable
0000000000000000000000000000000000000000;;			{"1e14", decQuantity(1, 14, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1e13", decQuantity(1, 13, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1e3", decQuantity(1, 3, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"100.035k", decQuantity(100035, 0, DecimalSI)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Things that look like floating point
0000000000000000000000000000000000000000;;			{"0.001", decQuantity(1, -3, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.0005k", decQuantity(5, -1, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.005", decQuantity(5, -3, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.05", decQuantity(5, -2, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.5", decQuantity(5, -1, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.00050k", decQuantity(5, -1, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.00500", decQuantity(5, -3, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.05000", decQuantity(5, -2, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.50000", decQuantity(5, -1, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.5e0", decQuantity(5, -1, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"0.5e-1", decQuantity(5, -2, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"0.5e-2", decQuantity(5, -3, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"0.5e0", decQuantity(5, -1, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"10.035M", decQuantity(10035, 3, DecimalSI)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"1.2e3", decQuantity(12, 2, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1.3E+6", decQuantity(13, 5, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1.40e9", decQuantity(14, 8, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1.53E12", decQuantity(153, 10, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1.6e15", decQuantity(16, 14, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"1.7E18", decQuantity(17, 17, DecimalExponent)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"9.01", decQuantity(901, -2, DecimalSI)},
0000000000000000000000000000000000000000;;			{"8.1k", decQuantity(81, 2, DecimalSI)},
0000000000000000000000000000000000000000;;			{"7.123456M", decQuantity(7123456, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"6.987654321G", decQuantity(6987654321, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"5.444T", decQuantity(5444, 9, DecimalSI)},
0000000000000000000000000000000000000000;;			{"40.1T", decQuantity(401, 11, DecimalSI)},
0000000000000000000000000000000000000000;;			{"300.2T", decQuantity(3002, 11, DecimalSI)},
0000000000000000000000000000000000000000;;			{"2.5P", decQuantity(25, 14, DecimalSI)},
0000000000000000000000000000000000000000;;			{"1.01E", decQuantity(101, 16, DecimalSI)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Things that saturate/round
0000000000000000000000000000000000000000;;			{"3.001n", decQuantity(4, -9, DecimalSI)},
0000000000000000000000000000000000000000;;			{"1.1E-9", decQuantity(2, -9, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"0.0000000001", decQuantity(1, -9, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.0000000005", decQuantity(1, -9, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.00000000050", decQuantity(1, -9, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.5e-9", decQuantity(1, -9, DecimalExponent)},
0000000000000000000000000000000000000000;;			{"0.9n", decQuantity(1, -9, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.00000012345", decQuantity(124, -9, DecimalSI)},
0000000000000000000000000000000000000000;;			{"0.00000012354", decQuantity(124, -9, DecimalSI)},
0000000000000000000000000000000000000000;;			{"9Ei", Quantity{d: maxAllowed, Format: BinarySI}},
0000000000000000000000000000000000000000;;			{"9223372036854775807Ki", Quantity{d: maxAllowed, Format: BinarySI}},
0000000000000000000000000000000000000000;;			{"12E", decQuantity(12, 18, DecimalSI)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We'll accept fractional binary stuff, too.
0000000000000000000000000000000000000000;;			{"100.035Ki", decQuantity(10243584, -2, BinarySI)},
0000000000000000000000000000000000000000;;			{"0.5Mi", decQuantity(.5*1024*1024, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{"0.05Gi", decQuantity(536870912, -1, BinarySI)},
0000000000000000000000000000000000000000;;			{"0.025Ti", decQuantity(274877906944, -1, BinarySI)},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Things written by trolls
0000000000000000000000000000000000000000;;			{"0.000000000001Ki", decQuantity(2, -9, DecimalSI)}, // rounds up, changes format
0000000000000000000000000000000000000000;;			{".001", decQuantity(1, -3, DecimalSI)},
0000000000000000000000000000000000000000;;			{".0001k", decQuantity(100, -3, DecimalSI)},
0000000000000000000000000000000000000000;;			{"1.", decQuantity(1, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{"1.G", decQuantity(1, 9, DecimalSI)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, asDec := range []bool{false, true} {
0000000000000000000000000000000000000000;;			for _, item := range table {
0000000000000000000000000000000000000000;;				got, err := ParseQuantity(item.input)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v: unexpected error: %v", item.input, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if asDec {
0000000000000000000000000000000000000000;;					got.AsDec()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if e, a := item.expect, got; e.Cmp(a) != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected %v, got %v", item.input, e.String(), a.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := item.expect.Format, got.Format; e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected %#v, got %#v", item.input, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if asDec {
0000000000000000000000000000000000000000;;					if i, ok := got.AsInt64(); i != 0 || ok {
0000000000000000000000000000000000000000;;						t.Errorf("%v: expected inf.Dec to return false for AsInt64: %d", item.input, i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i, ok := item.expect.AsInt64()
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				j, ok := got.AsInt64()
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					if got.d.Dec == nil && got.i.scale >= 0 {
0000000000000000000000000000000000000000;;						t.Errorf("%v: is an int64Amount, but can't return AsInt64: %v", item.input, got)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i != j {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected equivalent representation as int64: %d %d", item.input, i, j)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, item := range table {
0000000000000000000000000000000000000000;;				got, err := ParseQuantity(item.input)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v: unexpected error: %v", item.input, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if asDec {
0000000000000000000000000000000000000000;;					got.AsDec()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// verify that we can decompose the input and get the same result by building up from the base.
0000000000000000000000000000000000000000;;				positive, _, num, denom, suffix, err := parseQuantityString(item.input)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v: unexpected error: %v", item.input, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if got.Sign() >= 0 && !positive || got.Sign() < 0 && positive {
0000000000000000000000000000000000000000;;					t.Errorf("%v: positive was incorrect: %t", item.input, positive)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var value string
0000000000000000000000000000000000000000;;				if !positive {
0000000000000000000000000000000000000000;;					value = "-"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				value += num
0000000000000000000000000000000000000000;;				if len(denom) > 0 {
0000000000000000000000000000000000000000;;					value += "." + denom
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				value += suffix
0000000000000000000000000000000000000000;;				if len(value) == 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%v: did not parse correctly, %q %q %q", item.input, num, denom, suffix)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				expected, err := ParseQuantity(value)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v: unexpected error for %s: %v", item.input, value, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if expected.Cmp(got) != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%v: not the same as %s", item.input, value)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try the negative version of everything
0000000000000000000000000000000000000000;;			desired := &inf.Dec{}
0000000000000000000000000000000000000000;;			expect := Quantity{d: infDecAmount{Dec: desired}}
0000000000000000000000000000000000000000;;			for _, item := range table {
0000000000000000000000000000000000000000;;				got, err := ParseQuantity("-" + strings.TrimLeftFunc(item.input, unicode.IsSpace))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("-%v: unexpected error: %v", item.input, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if asDec {
0000000000000000000000000000000000000000;;					got.AsDec()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expected := item.expect
0000000000000000000000000000000000000000;;				desired.Neg(expected.AsDec())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if e, a := expect, got; e.Cmp(a) != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected %s, got %s", item.input, e.String(), a.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := expected.Format, got.Format; e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected %#v, got %#v", item.input, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try everything with an explicit +
0000000000000000000000000000000000000000;;			for _, item := range table {
0000000000000000000000000000000000000000;;				got, err := ParseQuantity("+" + strings.TrimLeftFunc(item.input, unicode.IsSpace))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("-%v: unexpected error: %v", item.input, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if asDec {
0000000000000000000000000000000000000000;;					got.AsDec()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if e, a := item.expect, got; e.Cmp(a) != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%v(%t): expected %s, got %s", item.input, asDec, e.String(), a.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := item.expect.Format, got.Format; e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected %#v, got %#v", item.input, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		invalid := []string{
0000000000000000000000000000000000000000;;			"1.1.M",
0000000000000000000000000000000000000000;;			"1+1.0M",
0000000000000000000000000000000000000000;;			"0.1mi",
0000000000000000000000000000000000000000;;			"0.1am",
0000000000000000000000000000000000000000;;			"aoeu",
0000000000000000000000000000000000000000;;			".5i",
0000000000000000000000000000000000000000;;			"1i",
0000000000000000000000000000000000000000;;			"-3.01i",
0000000000000000000000000000000000000000;;			"-3.01e-",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// trailing whitespace is forbidden
0000000000000000000000000000000000000000;;			" 1",
0000000000000000000000000000000000000000;;			"1 ",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range invalid {
0000000000000000000000000000000000000000;;			_, err := ParseQuantity(item)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v parsed unexpectedly", item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQuantityRoundUp(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			in     string
0000000000000000000000000000000000000000;;			scale  Scale
0000000000000000000000000000000000000000;;			expect Quantity
0000000000000000000000000000000000000000;;			ok     bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"9.01", -3, decQuantity(901, -2, DecimalSI), true},
0000000000000000000000000000000000000000;;			{"9.01", -2, decQuantity(901, -2, DecimalSI), true},
0000000000000000000000000000000000000000;;			{"9.01", -1, decQuantity(91, -1, DecimalSI), false},
0000000000000000000000000000000000000000;;			{"9.01", 0, decQuantity(10, 0, DecimalSI), false},
0000000000000000000000000000000000000000;;			{"9.01", 1, decQuantity(10, 0, DecimalSI), false},
0000000000000000000000000000000000000000;;			{"9.01", 2, decQuantity(100, 0, DecimalSI), false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"-9.01", -3, decQuantity(-901, -2, DecimalSI), true},
0000000000000000000000000000000000000000;;			{"-9.01", -2, decQuantity(-901, -2, DecimalSI), true},
0000000000000000000000000000000000000000;;			{"-9.01", -1, decQuantity(-91, -1, DecimalSI), false},
0000000000000000000000000000000000000000;;			{"-9.01", 0, decQuantity(-10, 0, DecimalSI), false},
0000000000000000000000000000000000000000;;			{"-9.01", 1, decQuantity(-10, 0, DecimalSI), false},
0000000000000000000000000000000000000000;;			{"-9.01", 2, decQuantity(-100, 0, DecimalSI), false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, asDec := range []bool{false, true} {
0000000000000000000000000000000000000000;;			for _, item := range table {
0000000000000000000000000000000000000000;;				got, err := ParseQuantity(item.in)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				expect := *item.expect.Copy()
0000000000000000000000000000000000000000;;				if asDec {
0000000000000000000000000000000000000000;;					got.AsDec()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ok := got.RoundUp(item.scale); ok != item.ok {
0000000000000000000000000000000000000000;;					t.Errorf("%s(%d,%t): unexpected ok: %t", item.in, item.scale, asDec, ok)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if got.Cmp(expect) != 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%s(%d,%t): unexpected round: %s vs %s", item.in, item.scale, asDec, got.String(), expect.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQuantityCmpInt64AndDec(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			a, b Quantity
0000000000000000000000000000000000000000;;			cmp  int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{intQuantity(901, -2, DecimalSI), intQuantity(901, -2, DecimalSI), 0},
0000000000000000000000000000000000000000;;			{intQuantity(90, -1, DecimalSI), intQuantity(901, -2, DecimalSI), -1},
0000000000000000000000000000000000000000;;			{intQuantity(901, -2, DecimalSI), intQuantity(900, -2, DecimalSI), 1},
0000000000000000000000000000000000000000;;			{intQuantity(0, 0, DecimalSI), intQuantity(0, 0, DecimalSI), 0},
0000000000000000000000000000000000000000;;			{intQuantity(0, 1, DecimalSI), intQuantity(0, -1, DecimalSI), 0},
0000000000000000000000000000000000000000;;			{intQuantity(0, -1, DecimalSI), intQuantity(0, 1, DecimalSI), 0},
0000000000000000000000000000000000000000;;			{intQuantity(800, -3, DecimalSI), intQuantity(1, 0, DecimalSI), -1},
0000000000000000000000000000000000000000;;			{intQuantity(800, -3, DecimalSI), intQuantity(79, -2, DecimalSI), 1},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{intQuantity(mostPositive, 0, DecimalSI), intQuantity(1, -1, DecimalSI), 1},
0000000000000000000000000000000000000000;;			{intQuantity(mostPositive, 1, DecimalSI), intQuantity(1, 0, DecimalSI), 1},
0000000000000000000000000000000000000000;;			{intQuantity(mostPositive, 1, DecimalSI), intQuantity(1, 1, DecimalSI), 1},
0000000000000000000000000000000000000000;;			{intQuantity(mostPositive, 1, DecimalSI), intQuantity(0, 1, DecimalSI), 1},
0000000000000000000000000000000000000000;;			{intQuantity(mostPositive, -16, DecimalSI), intQuantity(1, 3, DecimalSI), -1},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{intQuantity(mostNegative, 0, DecimalSI), intQuantity(0, 0, DecimalSI), -1},
0000000000000000000000000000000000000000;;			{intQuantity(mostNegative, -18, DecimalSI), intQuantity(-1, 0, DecimalSI), -1},
0000000000000000000000000000000000000000;;			{intQuantity(mostNegative, -19, DecimalSI), intQuantity(-1, 0, DecimalSI), 1},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{intQuantity(1*1000000*1000000*1000000, -17, DecimalSI), intQuantity(1, 1, DecimalSI), 0},
0000000000000000000000000000000000000000;;			{intQuantity(1*1000000*1000000*1000000, -17, DecimalSI), intQuantity(-10, 0, DecimalSI), 1},
0000000000000000000000000000000000000000;;			{intQuantity(-1*1000000*1000000*1000000, -17, DecimalSI), intQuantity(-10, 0, DecimalSI), 0},
0000000000000000000000000000000000000000;;			{intQuantity(1*1000000*1000000*1000000, -17, DecimalSI), intQuantity(1, 0, DecimalSI), 1},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{intQuantity(1*1000000*1000000*1000000+1, -17, DecimalSI), intQuantity(1, 1, DecimalSI), 1},
0000000000000000000000000000000000000000;;			{intQuantity(1*1000000*1000000*1000000-1, -17, DecimalSI), intQuantity(1, 1, DecimalSI), -1},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			if cmp := item.a.Cmp(item.b); cmp != item.cmp {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected Cmp: %d", item, cmp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cmp := item.b.Cmp(item.a); cmp != -item.cmp {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected inverted Cmp: %d", item, cmp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			a, b := *item.a.Copy(), *item.b.Copy()
0000000000000000000000000000000000000000;;			a.AsDec()
0000000000000000000000000000000000000000;;			if cmp := a.Cmp(b); cmp != item.cmp {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected Cmp: %d", item, cmp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cmp := b.Cmp(a); cmp != -item.cmp {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected inverted Cmp: %d", item, cmp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			a, b := *item.a.Copy(), *item.b.Copy()
0000000000000000000000000000000000000000;;			b.AsDec()
0000000000000000000000000000000000000000;;			if cmp := a.Cmp(b); cmp != item.cmp {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected Cmp: %d", item, cmp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cmp := b.Cmp(a); cmp != -item.cmp {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected inverted Cmp: %d", item, cmp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			a, b := *item.a.Copy(), *item.b.Copy()
0000000000000000000000000000000000000000;;			a.AsDec()
0000000000000000000000000000000000000000;;			b.AsDec()
0000000000000000000000000000000000000000;;			if cmp := a.Cmp(b); cmp != item.cmp {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected Cmp: %d", item, cmp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cmp := b.Cmp(a); cmp != -item.cmp {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected inverted Cmp: %d", item, cmp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQuantityNeg(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			a   Quantity
0000000000000000000000000000000000000000;;			out string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{intQuantity(901, -2, DecimalSI), "-9010m"},
0000000000000000000000000000000000000000;;			{decQuantity(901, -2, DecimalSI), "-9010m"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, item := range table {
0000000000000000000000000000000000000000;;			out := *item.a.Copy()
0000000000000000000000000000000000000000;;			out.Neg()
0000000000000000000000000000000000000000;;			if out.Cmp(item.a) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%d: negating an item should not mutate the source: %s", i, out.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out.String() != item.out {
0000000000000000000000000000000000000000;;				t.Errorf("%d: negating did not equal exact value: %s", i, out.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQuantityString(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			in        Quantity
0000000000000000000000000000000000000000;;			expect    string
0000000000000000000000000000000000000000;;			alternate string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{decQuantity(1024*1024*1024, 0, BinarySI), "1Gi", "1024Mi"},
0000000000000000000000000000000000000000;;			{decQuantity(300*1024*1024, 0, BinarySI), "300Mi", "307200Ki"},
0000000000000000000000000000000000000000;;			{decQuantity(6*1024, 0, BinarySI), "6Ki", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1001*1024*1024*1024, 0, BinarySI), "1001Gi", "1025024Mi"},
0000000000000000000000000000000000000000;;			{decQuantity(1024*1024*1024*1024, 0, BinarySI), "1Ti", "1024Gi"},
0000000000000000000000000000000000000000;;			{decQuantity(5, 0, BinarySI), "5", "5000m"},
0000000000000000000000000000000000000000;;			{decQuantity(500, -3, BinarySI), "500m", "0.5"},
0000000000000000000000000000000000000000;;			{decQuantity(1, 9, DecimalSI), "1G", "1000M"},
0000000000000000000000000000000000000000;;			{decQuantity(1000, 6, DecimalSI), "1G", "0.001T"},
0000000000000000000000000000000000000000;;			{decQuantity(1000000, 3, DecimalSI), "1G", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1000000000, 0, DecimalSI), "1G", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1, -3, DecimalSI), "1m", "1000u"},
0000000000000000000000000000000000000000;;			{decQuantity(80, -3, DecimalSI), "80m", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1080, -3, DecimalSI), "1080m", "1.08"},
0000000000000000000000000000000000000000;;			{decQuantity(108, -2, DecimalSI), "1080m", "1080000000n"},
0000000000000000000000000000000000000000;;			{decQuantity(10800, -4, DecimalSI), "1080m", ""},
0000000000000000000000000000000000000000;;			{decQuantity(300, 6, DecimalSI), "300M", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1, 12, DecimalSI), "1T", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1234567, 6, DecimalSI), "1234567M", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1234567, -3, BinarySI), "1234567m", ""},
0000000000000000000000000000000000000000;;			{decQuantity(3, 3, DecimalSI), "3k", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1025, 0, BinarySI), "1025", ""},
0000000000000000000000000000000000000000;;			{decQuantity(0, 0, DecimalSI), "0", ""},
0000000000000000000000000000000000000000;;			{decQuantity(0, 0, BinarySI), "0", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1, 9, DecimalExponent), "1e9", ".001e12"},
0000000000000000000000000000000000000000;;			{decQuantity(1, -3, DecimalExponent), "1e-3", "0.001e0"},
0000000000000000000000000000000000000000;;			{decQuantity(1, -9, DecimalExponent), "1e-9", "1000e-12"},
0000000000000000000000000000000000000000;;			{decQuantity(80, -3, DecimalExponent), "80e-3", ""},
0000000000000000000000000000000000000000;;			{decQuantity(300, 6, DecimalExponent), "300e6", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1, 12, DecimalExponent), "1e12", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1, 3, DecimalExponent), "1e3", ""},
0000000000000000000000000000000000000000;;			{decQuantity(3, 3, DecimalExponent), "3e3", ""},
0000000000000000000000000000000000000000;;			{decQuantity(3, 3, DecimalSI), "3k", ""},
0000000000000000000000000000000000000000;;			{decQuantity(0, 0, DecimalExponent), "0", "00"},
0000000000000000000000000000000000000000;;			{decQuantity(1, -9, DecimalSI), "1n", ""},
0000000000000000000000000000000000000000;;			{decQuantity(80, -9, DecimalSI), "80n", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1080, -9, DecimalSI), "1080n", ""},
0000000000000000000000000000000000000000;;			{decQuantity(108, -8, DecimalSI), "1080n", ""},
0000000000000000000000000000000000000000;;			{decQuantity(10800, -10, DecimalSI), "1080n", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1, -6, DecimalSI), "1u", ""},
0000000000000000000000000000000000000000;;			{decQuantity(80, -6, DecimalSI), "80u", ""},
0000000000000000000000000000000000000000;;			{decQuantity(1080, -6, DecimalSI), "1080u", ""},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			got := item.in.String()
0000000000000000000000000000000000000000;;			if e, a := item.expect, got; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: expected %v, got %v", item.in, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			q, err := ParseQuantity(item.expect)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected error: %v", item.expect, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(q.s) == 0 || q.s != item.expect {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: did not copy canonical string on parse: %s", item.expect, q.s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(item.alternate) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			q, err = ParseQuantity(item.alternate)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected error: %v", item.expect, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(q.s) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected nested string: %v", item.expect, q.s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if q.String() != item.expect {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: unexpected alternate canonical: %v", item.expect, q.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(q.s) == 0 || q.s != item.expect {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: did not set canonical string on ToString: %s", item.expect, q.s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		desired := &inf.Dec{} // Avoid modifying the values in the table.
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			if item.in.Cmp(Quantity{}) == 0 {
0000000000000000000000000000000000000000;;				// Don't expect it to print "-0" ever
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			q := item.in
0000000000000000000000000000000000000000;;			q.d = infDecAmount{desired.Neg(q.AsDec())}
0000000000000000000000000000000000000000;;			if e, a := "-"+item.expect, q.String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: expected %v, got %v", item.in, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQuantityParseEmit(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			in     string
0000000000000000000000000000000000000000;;			expect string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"1Ki", "1Ki"},
0000000000000000000000000000000000000000;;			{"1Mi", "1Mi"},
0000000000000000000000000000000000000000;;			{"1Gi", "1Gi"},
0000000000000000000000000000000000000000;;			{"1024Mi", "1Gi"},
0000000000000000000000000000000000000000;;			{"1000M", "1G"},
0000000000000000000000000000000000000000;;			{".001Ki", "1024m"},
0000000000000000000000000000000000000000;;			{".000001Ki", "1024u"},
0000000000000000000000000000000000000000;;			{".000000001Ki", "1024n"},
0000000000000000000000000000000000000000;;			{".000000000001Ki", "2n"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			q, err := ParseQuantity(item.in)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Couldn't parse %v", item.in)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.expect, q.String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: expected %v, got %v", item.in, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			q, err := ParseQuantity("-" + item.in)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Couldn't parse %v", item.in)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if q.Cmp(Quantity{}) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := "-"+item.expect, q.String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%#v: expected %v, got %v (%#v)", item.in, e, a, q.i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var fuzzer = fuzz.New().Funcs(
0000000000000000000000000000000000000000;;		func(q *Quantity, c fuzz.Continue) {
0000000000000000000000000000000000000000;;			q.i = Zero
0000000000000000000000000000000000000000;;			if c.RandBool() {
0000000000000000000000000000000000000000;;				q.Format = BinarySI
0000000000000000000000000000000000000000;;				if c.RandBool() {
0000000000000000000000000000000000000000;;					dec := &inf.Dec{}
0000000000000000000000000000000000000000;;					q.d = infDecAmount{Dec: dec}
0000000000000000000000000000000000000000;;					dec.SetScale(0)
0000000000000000000000000000000000000000;;					dec.SetUnscaled(c.Int63())
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Be sure to test cases like 1Mi
0000000000000000000000000000000000000000;;				dec := &inf.Dec{}
0000000000000000000000000000000000000000;;				q.d = infDecAmount{Dec: dec}
0000000000000000000000000000000000000000;;				dec.SetScale(0)
0000000000000000000000000000000000000000;;				dec.SetUnscaled(c.Int63n(1024) << uint(10*c.Intn(5)))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.RandBool() {
0000000000000000000000000000000000000000;;				q.Format = DecimalSI
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				q.Format = DecimalExponent
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.RandBool() {
0000000000000000000000000000000000000000;;				dec := &inf.Dec{}
0000000000000000000000000000000000000000;;				q.d = infDecAmount{Dec: dec}
0000000000000000000000000000000000000000;;				dec.SetScale(inf.Scale(c.Intn(4)))
0000000000000000000000000000000000000000;;				dec.SetUnscaled(c.Int63())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Be sure to test cases like 1M
0000000000000000000000000000000000000000;;			dec := &inf.Dec{}
0000000000000000000000000000000000000000;;			q.d = infDecAmount{Dec: dec}
0000000000000000000000000000000000000000;;			dec.SetScale(inf.Scale(3 - c.Intn(15)))
0000000000000000000000000000000000000000;;			dec.SetUnscaled(c.Int63n(1000))
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQuantityDeepCopy(t *testing.T) {
0000000000000000000000000000000000000000;;		// Test when d is nil
0000000000000000000000000000000000000000;;		slice := []string{"0", "100m", "50m", "10000T"}
0000000000000000000000000000000000000000;;		for _, testCase := range slice {
0000000000000000000000000000000000000000;;			q := MustParse(testCase)
0000000000000000000000000000000000000000;;			if result := q.DeepCopy(); result != q {
0000000000000000000000000000000000000000;;				t.Errorf("Expected: %v, Actual: %v", q, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		table := []*inf.Dec{
0000000000000000000000000000000000000000;;			dec(0, 0).Dec,
0000000000000000000000000000000000000000;;			dec(10, 0).Dec,
0000000000000000000000000000000000000000;;			dec(-10, 0).Dec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Test when i is {0,0}
0000000000000000000000000000000000000000;;		for _, testCase := range table {
0000000000000000000000000000000000000000;;			q := Quantity{d: infDecAmount{testCase}, Format: DecimalSI}
0000000000000000000000000000000000000000;;			result := q.DeepCopy()
0000000000000000000000000000000000000000;;			if q.d.Cmp(result.AsDec()) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Expected: %v, Actual: %v", q.String(), result.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = Quantity{d: infDecAmount{dec(2, 0).Dec}, Format: DecimalSI}
0000000000000000000000000000000000000000;;			if q.d.Cmp(result.AsDec()) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Modifying result has affected q")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJSON(t *testing.T) {
0000000000000000000000000000000000000000;;		for i := 0; i < 500; i++ {
0000000000000000000000000000000000000000;;			q := &Quantity{}
0000000000000000000000000000000000000000;;			fuzzer.Fuzz(q)
0000000000000000000000000000000000000000;;			b, err := json.Marshal(q)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("error encoding %v: %v", q, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			q2 := &Quantity{}
0000000000000000000000000000000000000000;;			err = json.Unmarshal(b, q2)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("%d: %s", i, string(b))
0000000000000000000000000000000000000000;;				t.Errorf("%v: error decoding %v: %v", q, string(b), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if q2.Cmp(*q) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Expected equal: %v, %v (json was '%v')", q, q2, string(b))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJSONWhitespace(t *testing.T) {
0000000000000000000000000000000000000000;;		q := Quantity{}
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			in     string
0000000000000000000000000000000000000000;;			expect string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{`" 1"`, "1"},
0000000000000000000000000000000000000000;;			{`"1 "`, "1"},
0000000000000000000000000000000000000000;;			{`1`, "1"},
0000000000000000000000000000000000000000;;			{` 1`, "1"},
0000000000000000000000000000000000000000;;			{`1 `, "1"},
0000000000000000000000000000000000000000;;			{`10`, "10"},
0000000000000000000000000000000000000000;;			{`-1`, "-1"},
0000000000000000000000000000000000000000;;			{` -1`, "-1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range testCases {
0000000000000000000000000000000000000000;;			if err := json.Unmarshal([]byte(test.in), &q); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%q: %v", test.in, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if q.String() != test.expect {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected string: %q", q.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMilliNewSet(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			value  int64
0000000000000000000000000000000000000000;;			format Format
0000000000000000000000000000000000000000;;			expect string
0000000000000000000000000000000000000000;;			exact  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{1, DecimalSI, "1m", true},
0000000000000000000000000000000000000000;;			{1000, DecimalSI, "1", true},
0000000000000000000000000000000000000000;;			{1234000, DecimalSI, "1234", true},
0000000000000000000000000000000000000000;;			{1024, BinarySI, "1024m", false}, // Format changes
0000000000000000000000000000000000000000;;			{1000000, "invalidFormatDefaultsToExponent", "1e3", true},
0000000000000000000000000000000000000000;;			{1024 * 1024, BinarySI, "1048576m", false}, // Format changes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			q := NewMilliQuantity(item.value, item.format)
0000000000000000000000000000000000000000;;			if e, a := item.expect, q.String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, got %v; %#v", e, a, q)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !item.exact {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			q2, err := ParseQuantity(q.String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Round trip failed on %v", q)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.value, q2.MilliValue(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			q := NewQuantity(0, item.format)
0000000000000000000000000000000000000000;;			q.SetMilli(item.value)
0000000000000000000000000000000000000000;;			if e, a := item.expect, q.String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Set: Expected %v, got %v; %#v", e, a, q)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewSet(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			value  int64
0000000000000000000000000000000000000000;;			format Format
0000000000000000000000000000000000000000;;			expect string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{1, DecimalSI, "1"},
0000000000000000000000000000000000000000;;			{1000, DecimalSI, "1k"},
0000000000000000000000000000000000000000;;			{1234000, DecimalSI, "1234k"},
0000000000000000000000000000000000000000;;			{1024, BinarySI, "1Ki"},
0000000000000000000000000000000000000000;;			{1000000, "invalidFormatDefaultsToExponent", "1e6"},
0000000000000000000000000000000000000000;;			{1024 * 1024, BinarySI, "1Mi"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, asDec := range []bool{false, true} {
0000000000000000000000000000000000000000;;			for _, item := range table {
0000000000000000000000000000000000000000;;				q := NewQuantity(item.value, item.format)
0000000000000000000000000000000000000000;;				if asDec {
0000000000000000000000000000000000000000;;					q.ToDec()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := item.expect, q.String(); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("Expected %v, got %v; %#v", e, a, q)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				q2, err := ParseQuantity(q.String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Round trip failed on %v", q)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := item.value, q2.Value(); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, item := range table {
0000000000000000000000000000000000000000;;				q := NewQuantity(0, item.format)
0000000000000000000000000000000000000000;;				q.Set(item.value)
0000000000000000000000000000000000000000;;				if asDec {
0000000000000000000000000000000000000000;;					q.ToDec()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := item.expect, q.String(); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("Set: Expected %v, got %v; %#v", e, a, q)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNewScaledSet(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			value  int64
0000000000000000000000000000000000000000;;			scale  Scale
0000000000000000000000000000000000000000;;			expect string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{1, Nano, "1n"},
0000000000000000000000000000000000000000;;			{1000, Nano, "1u"},
0000000000000000000000000000000000000000;;			{1, Micro, "1u"},
0000000000000000000000000000000000000000;;			{1000, Micro, "1m"},
0000000000000000000000000000000000000000;;			{1, Milli, "1m"},
0000000000000000000000000000000000000000;;			{1000, Milli, "1"},
0000000000000000000000000000000000000000;;			{1, 0, "1"},
0000000000000000000000000000000000000000;;			{0, Nano, "0"},
0000000000000000000000000000000000000000;;			{0, Micro, "0"},
0000000000000000000000000000000000000000;;			{0, Milli, "0"},
0000000000000000000000000000000000000000;;			{0, 0, "0"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			q := NewScaledQuantity(item.value, item.scale)
0000000000000000000000000000000000000000;;			if e, a := item.expect, q.String(); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, got %v; %#v", e, a, q)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			q2, err := ParseQuantity(q.String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Round trip failed on %v", q)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.value, q2.ScaledValue(item.scale); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			q3 := NewQuantity(0, DecimalSI)
0000000000000000000000000000000000000000;;			q3.SetScaled(item.value, item.scale)
0000000000000000000000000000000000000000;;			if q.Cmp(*q3) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v and %v to be equal", q, q3)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaledValue(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			fromScale Scale
0000000000000000000000000000000000000000;;			toScale   Scale
0000000000000000000000000000000000000000;;			expected  int64
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{Nano, Nano, 1},
0000000000000000000000000000000000000000;;			{Nano, Micro, 1},
0000000000000000000000000000000000000000;;			{Nano, Milli, 1},
0000000000000000000000000000000000000000;;			{Nano, 0, 1},
0000000000000000000000000000000000000000;;			{Micro, Nano, 1000},
0000000000000000000000000000000000000000;;			{Micro, Micro, 1},
0000000000000000000000000000000000000000;;			{Micro, Milli, 1},
0000000000000000000000000000000000000000;;			{Micro, 0, 1},
0000000000000000000000000000000000000000;;			{Milli, Nano, 1000 * 1000},
0000000000000000000000000000000000000000;;			{Milli, Micro, 1000},
0000000000000000000000000000000000000000;;			{Milli, Milli, 1},
0000000000000000000000000000000000000000;;			{Milli, 0, 1},
0000000000000000000000000000000000000000;;			{0, Nano, 1000 * 1000 * 1000},
0000000000000000000000000000000000000000;;			{0, Micro, 1000 * 1000},
0000000000000000000000000000000000000000;;			{0, Milli, 1000},
0000000000000000000000000000000000000000;;			{0, 0, 1},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			q := NewScaledQuantity(1, item.fromScale)
0000000000000000000000000000000000000000;;			if e, a := item.expected, q.ScaledValue(item.toScale); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v to %v: Expected %v, got %v", item.fromScale, item.toScale, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUninitializedNoCrash(t *testing.T) {
0000000000000000000000000000000000000000;;		var q Quantity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q.Value()
0000000000000000000000000000000000000000;;		q.MilliValue()
0000000000000000000000000000000000000000;;		q.Copy()
0000000000000000000000000000000000000000;;		_ = q.String()
0000000000000000000000000000000000000000;;		q.MarshalJSON()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCopy(t *testing.T) {
0000000000000000000000000000000000000000;;		q := NewQuantity(5, DecimalSI)
0000000000000000000000000000000000000000;;		c := q.Copy()
0000000000000000000000000000000000000000;;		c.Set(6)
0000000000000000000000000000000000000000;;		if q.Value() == 6 {
0000000000000000000000000000000000000000;;			t.Errorf("Copy didn't")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQFlagSet(t *testing.T) {
0000000000000000000000000000000000000000;;		qf := qFlag{&Quantity{}}
0000000000000000000000000000000000000000;;		qf.Set("1Ki")
0000000000000000000000000000000000000000;;		if e, a := "1Ki", qf.String(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected result %v != %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestQFlagIsPFlag(t *testing.T) {
0000000000000000000000000000000000000000;;		var pfv pflag.Value = qFlag{}
0000000000000000000000000000000000000000;;		if e, a := "quantity", pfv.Type(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected result %v != %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSub(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			a        Quantity
0000000000000000000000000000000000000000;;			b        Quantity
0000000000000000000000000000000000000000;;			expected Quantity
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{decQuantity(10, 0, DecimalSI), decQuantity(1, 1, DecimalSI), decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{decQuantity(10, 0, DecimalSI), decQuantity(1, 0, BinarySI), decQuantity(9, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{decQuantity(10, 0, BinarySI), decQuantity(1, 0, DecimalSI), decQuantity(9, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{Quantity{Format: DecimalSI}, decQuantity(50, 0, DecimalSI), decQuantity(-50, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{decQuantity(50, 0, DecimalSI), Quantity{Format: DecimalSI}, decQuantity(50, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{Quantity{Format: DecimalSI}, Quantity{Format: DecimalSI}, decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			test.a.Sub(test.b)
0000000000000000000000000000000000000000;;			if test.a.Cmp(test.expected) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] Expected %q, got %q", i, test.expected.String(), test.a.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNeg(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			a        Quantity
0000000000000000000000000000000000000000;;			b        Quantity
0000000000000000000000000000000000000000;;			expected Quantity
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{a: intQuantity(0, 0, DecimalSI), expected: intQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{a: Quantity{}, expected: Quantity{}},
0000000000000000000000000000000000000000;;			{a: intQuantity(10, 0, BinarySI), expected: intQuantity(-10, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{a: intQuantity(-10, 0, BinarySI), expected: intQuantity(10, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{a: decQuantity(0, 0, DecimalSI), expected: intQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{a: decQuantity(10, 0, BinarySI), expected: intQuantity(-10, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{a: decQuantity(-10, 0, BinarySI), expected: intQuantity(10, 0, BinarySI)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			a := test.a.Copy()
0000000000000000000000000000000000000000;;			a.Neg()
0000000000000000000000000000000000000000;;			// ensure value is same
0000000000000000000000000000000000000000;;			if a.Cmp(test.expected) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] Expected %q, got %q", i, test.expected.String(), a.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAdd(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			a        Quantity
0000000000000000000000000000000000000000;;			b        Quantity
0000000000000000000000000000000000000000;;			expected Quantity
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{decQuantity(10, 0, DecimalSI), decQuantity(1, 1, DecimalSI), decQuantity(20, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{decQuantity(10, 0, DecimalSI), decQuantity(1, 0, BinarySI), decQuantity(11, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{decQuantity(10, 0, BinarySI), decQuantity(1, 0, DecimalSI), decQuantity(11, 0, BinarySI)},
0000000000000000000000000000000000000000;;			{Quantity{Format: DecimalSI}, decQuantity(50, 0, DecimalSI), decQuantity(50, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{decQuantity(50, 0, DecimalSI), Quantity{Format: DecimalSI}, decQuantity(50, 0, DecimalSI)},
0000000000000000000000000000000000000000;;			{Quantity{Format: DecimalSI}, Quantity{Format: DecimalSI}, decQuantity(0, 0, DecimalSI)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			test.a.Add(test.b)
0000000000000000000000000000000000000000;;			if test.a.Cmp(test.expected) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] Expected %q, got %q", i, test.expected.String(), test.a.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddSubRoundTrip(t *testing.T) {
0000000000000000000000000000000000000000;;		for k := -10; k <= 10; k++ {
0000000000000000000000000000000000000000;;			q := Quantity{Format: DecimalSI}
0000000000000000000000000000000000000000;;			var order []int64
0000000000000000000000000000000000000000;;			for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;				j := rand.Int63()
0000000000000000000000000000000000000000;;				order = append(order, j)
0000000000000000000000000000000000000000;;				q.Add(*NewScaledQuantity(j, Scale(k)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, j := range order {
0000000000000000000000000000000000000000;;				q.Sub(*NewScaledQuantity(j, Scale(k)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !q.IsZero() {
0000000000000000000000000000000000000000;;				t.Errorf("addition and subtraction did not cancel: %s", &q)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddSubRoundTripAcrossScales(t *testing.T) {
0000000000000000000000000000000000000000;;		q := Quantity{Format: DecimalSI}
0000000000000000000000000000000000000000;;		var order []int64
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			j := rand.Int63()
0000000000000000000000000000000000000000;;			order = append(order, j)
0000000000000000000000000000000000000000;;			q.Add(*NewScaledQuantity(j, Scale(j%20-10)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, j := range order {
0000000000000000000000000000000000000000;;			q.Sub(*NewScaledQuantity(j, Scale(j%20-10)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !q.IsZero() {
0000000000000000000000000000000000000000;;			t.Errorf("addition and subtraction did not cancel: %s", &q)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNegateRoundTrip(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, asDec := range []bool{false, true} {
0000000000000000000000000000000000000000;;			for k := -10; k <= 10; k++ {
0000000000000000000000000000000000000000;;				for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;					j := rand.Int63()
0000000000000000000000000000000000000000;;					q := *NewScaledQuantity(j, Scale(k))
0000000000000000000000000000000000000000;;					if asDec {
0000000000000000000000000000000000000000;;						q.AsDec()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					b := q.Copy()
0000000000000000000000000000000000000000;;					b.Neg()
0000000000000000000000000000000000000000;;					b.Neg()
0000000000000000000000000000000000000000;;					if b.Cmp(q) != 0 {
0000000000000000000000000000000000000000;;						t.Errorf("double negation did not cancel: %s", &q)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func benchmarkQuantities() []Quantity {
0000000000000000000000000000000000000000;;		return []Quantity{
0000000000000000000000000000000000000000;;			intQuantity(1024*1024*1024, 0, BinarySI),
0000000000000000000000000000000000000000;;			intQuantity(1024*1024*1024*1024, 0, BinarySI),
0000000000000000000000000000000000000000;;			intQuantity(1000000, 3, DecimalSI),
0000000000000000000000000000000000000000;;			intQuantity(1000000000, 0, DecimalSI),
0000000000000000000000000000000000000000;;			intQuantity(1, -3, DecimalSI),
0000000000000000000000000000000000000000;;			intQuantity(80, -3, DecimalSI),
0000000000000000000000000000000000000000;;			intQuantity(1080, -3, DecimalSI),
0000000000000000000000000000000000000000;;			intQuantity(0, 0, BinarySI),
0000000000000000000000000000000000000000;;			intQuantity(1, 9, DecimalExponent),
0000000000000000000000000000000000000000;;			intQuantity(1, -9, DecimalSI),
0000000000000000000000000000000000000000;;			intQuantity(1000000, 10, DecimalSI),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkQuantityString(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			q := values[i%len(values)]
0000000000000000000000000000000000000000;;			q.s = ""
0000000000000000000000000000000000000000;;			s = q.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			b.Fatal(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkQuantityStringPrecalc(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		for i := range values {
0000000000000000000000000000000000000000;;			_ = values[i].String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			q := values[i%len(values)]
0000000000000000000000000000000000000000;;			s = q.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			b.Fatal(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkQuantityStringBinarySI(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		for i := range values {
0000000000000000000000000000000000000000;;			values[i].Format = BinarySI
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			q := values[i%len(values)]
0000000000000000000000000000000000000000;;			q.s = ""
0000000000000000000000000000000000000000;;			s = q.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			b.Fatal(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkQuantityMarshalJSON(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			q := values[i%len(values)]
0000000000000000000000000000000000000000;;			q.s = ""
0000000000000000000000000000000000000000;;			if _, err := q.MarshalJSON(); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkQuantityUnmarshalJSON(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		var json [][]byte
0000000000000000000000000000000000000000;;		for _, v := range values {
0000000000000000000000000000000000000000;;			data, _ := v.MarshalJSON()
0000000000000000000000000000000000000000;;			json = append(json, data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			var q Quantity
0000000000000000000000000000000000000000;;			if err := q.UnmarshalJSON(json[i%len(values)]); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkParseQuantity(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		var strings []string
0000000000000000000000000000000000000000;;		for _, v := range values {
0000000000000000000000000000000000000000;;			strings = append(strings, v.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			if _, err := ParseQuantity(strings[i%len(values)]); err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkCanonicalize(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		buffer := make([]byte, 0, 100)
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			s, _ := values[i%len(values)].CanonicalizeBytes(buffer)
0000000000000000000000000000000000000000;;			if len(s) == 0 {
0000000000000000000000000000000000000000;;				b.Fatal(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkQuantityRoundUp(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			q := values[i%len(values)]
0000000000000000000000000000000000000000;;			copied := q
0000000000000000000000000000000000000000;;			copied.RoundUp(-3)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkQuantityCopy(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			values[i%len(values)].Copy()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkQuantityAdd(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		base := &Quantity{}
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			q := values[i%len(values)]
0000000000000000000000000000000000000000;;			base.d.Dec = nil
0000000000000000000000000000000000000000;;			base.i = int64Amount{value: 100}
0000000000000000000000000000000000000000;;			base.Add(q)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkQuantityCmp(b *testing.B) {
0000000000000000000000000000000000000000;;		values := benchmarkQuantities()
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			q := values[i%len(values)]
0000000000000000000000000000000000000000;;			if q.Cmp(q) != 0 {
0000000000000000000000000000000000000000;;				b.Fatal(q)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
