0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package meta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VersionInterfaces contains the interfaces one should use for dealing with types of a particular version.
0000000000000000000000000000000000000000;;	type VersionInterfaces struct {
0000000000000000000000000000000000000000;;		runtime.ObjectConvertor
0000000000000000000000000000000000000000;;		MetadataAccessor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ListMetaAccessor interface {
0000000000000000000000000000000000000000;;		GetListMeta() List
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List lets you work with list metadata from any of the versioned or
0000000000000000000000000000000000000000;;	// internal API objects. Attempting to set or retrieve a field on an object that does
0000000000000000000000000000000000000000;;	// not support that field will be a no-op and return a default value.
0000000000000000000000000000000000000000;;	type List metav1.List
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type exposes the type and APIVersion of versioned or internal API objects.
0000000000000000000000000000000000000000;;	type Type metav1.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadataAccessor lets you work with object and list metadata from any of the versioned or
0000000000000000000000000000000000000000;;	// internal API objects. Attempting to set or retrieve a field on an object that does
0000000000000000000000000000000000000000;;	// not support that field (Name, UID, Namespace on lists) will be a no-op and return
0000000000000000000000000000000000000000;;	// a default value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// MetadataAccessor exposes Interface in a way that can be used with multiple objects.
0000000000000000000000000000000000000000;;	type MetadataAccessor interface {
0000000000000000000000000000000000000000;;		APIVersion(obj runtime.Object) (string, error)
0000000000000000000000000000000000000000;;		SetAPIVersion(obj runtime.Object, version string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Kind(obj runtime.Object) (string, error)
0000000000000000000000000000000000000000;;		SetKind(obj runtime.Object, kind string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Namespace(obj runtime.Object) (string, error)
0000000000000000000000000000000000000000;;		SetNamespace(obj runtime.Object, namespace string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Name(obj runtime.Object) (string, error)
0000000000000000000000000000000000000000;;		SetName(obj runtime.Object, name string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GenerateName(obj runtime.Object) (string, error)
0000000000000000000000000000000000000000;;		SetGenerateName(obj runtime.Object, name string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		UID(obj runtime.Object) (types.UID, error)
0000000000000000000000000000000000000000;;		SetUID(obj runtime.Object, uid types.UID) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SelfLink(obj runtime.Object) (string, error)
0000000000000000000000000000000000000000;;		SetSelfLink(obj runtime.Object, selfLink string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Labels(obj runtime.Object) (map[string]string, error)
0000000000000000000000000000000000000000;;		SetLabels(obj runtime.Object, labels map[string]string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Annotations(obj runtime.Object) (map[string]string, error)
0000000000000000000000000000000000000000;;		SetAnnotations(obj runtime.Object, annotations map[string]string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtime.ResourceVersioner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RESTScopeName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		RESTScopeNameNamespace RESTScopeName = "namespace"
0000000000000000000000000000000000000000;;		RESTScopeNameRoot      RESTScopeName = "root"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTScope contains the information needed to deal with REST resources that are in a resource hierarchy
0000000000000000000000000000000000000000;;	type RESTScope interface {
0000000000000000000000000000000000000000;;		// Name of the scope
0000000000000000000000000000000000000000;;		Name() RESTScopeName
0000000000000000000000000000000000000000;;		// ParamName is the optional name of the parameter that should be inserted in the resource url
0000000000000000000000000000000000000000;;		// If empty, no param will be inserted
0000000000000000000000000000000000000000;;		ParamName() string
0000000000000000000000000000000000000000;;		// ArgumentName is the optional name that should be used for the variable holding the value.
0000000000000000000000000000000000000000;;		ArgumentName() string
0000000000000000000000000000000000000000;;		// ParamDescription is the optional description to use to document the parameter in api documentation
0000000000000000000000000000000000000000;;		ParamDescription() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTMapping contains the information needed to deal with objects of a specific
0000000000000000000000000000000000000000;;	// resource and kind in a RESTful manner.
0000000000000000000000000000000000000000;;	type RESTMapping struct {
0000000000000000000000000000000000000000;;		// Resource is a string representing the name of this resource as a REST client would see it
0000000000000000000000000000000000000000;;		Resource string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GroupVersionKind schema.GroupVersionKind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scope contains the information needed to deal with REST Resources that are in a resource hierarchy
0000000000000000000000000000000000000000;;		Scope RESTScope
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		runtime.ObjectConvertor
0000000000000000000000000000000000000000;;		MetadataAccessor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTMapper allows clients to map resources to kind, and map kind and version
0000000000000000000000000000000000000000;;	// to interfaces for manipulating those objects. It is primarily intended for
0000000000000000000000000000000000000000;;	// consumers of Kubernetes compatible REST APIs as defined in docs/devel/api-conventions.md.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Kubernetes API provides versioned resources and object kinds which are scoped
0000000000000000000000000000000000000000;;	// to API groups. In other words, kinds and resources should not be assumed to be
0000000000000000000000000000000000000000;;	// unique across groups.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: split into sub-interfaces
0000000000000000000000000000000000000000;;	type RESTMapper interface {
0000000000000000000000000000000000000000;;		// KindFor takes a partial resource and returns the single match.  Returns an error if there are multiple matches
0000000000000000000000000000000000000000;;		KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KindsFor takes a partial resource and returns the list of potential kinds in priority order
0000000000000000000000000000000000000000;;		KindsFor(resource schema.GroupVersionResource) ([]schema.GroupVersionKind, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ResourceFor takes a partial resource and returns the single match.  Returns an error if there are multiple matches
0000000000000000000000000000000000000000;;		ResourceFor(input schema.GroupVersionResource) (schema.GroupVersionResource, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ResourcesFor takes a partial resource and returns the list of potential resource in priority order
0000000000000000000000000000000000000000;;		ResourcesFor(input schema.GroupVersionResource) ([]schema.GroupVersionResource, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RESTMapping identifies a preferred resource mapping for the provided group kind.
0000000000000000000000000000000000000000;;		RESTMapping(gk schema.GroupKind, versions ...string) (*RESTMapping, error)
0000000000000000000000000000000000000000;;		// RESTMappings returns all resource mappings for the provided group kind if no
0000000000000000000000000000000000000000;;		// version search is provided. Otherwise identifies a preferred resource mapping for
0000000000000000000000000000000000000000;;		// the provided version(s).
0000000000000000000000000000000000000000;;		RESTMappings(gk schema.GroupKind, versions ...string) ([]*RESTMapping, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ResourceSingularizer(resource string) (singular string, err error)
0000000000000000000000000000000000000000;;	}
