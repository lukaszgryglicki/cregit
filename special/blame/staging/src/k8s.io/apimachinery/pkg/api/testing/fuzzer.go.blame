0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
f94423c99f17717423ba03eca7b1884260ebdf7c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		runtimeserializer "k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GenericFuzzerFuncs(t TestingCommon, codecs runtimeserializer.CodecFactory) []interface{} {
0000000000000000000000000000000000000000;;		return []interface{}{
0000000000000000000000000000000000000000;;			func(q *resource.Quantity, c fuzz.Continue) {
0000000000000000000000000000000000000000;;				*q = *resource.NewQuantity(c.Int63n(1000), resource.DecimalExponent)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(j *int, c fuzz.Continue) {
0000000000000000000000000000000000000000;;				*j = int(c.Int31())
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(j **int, c fuzz.Continue) {
0000000000000000000000000000000000000000;;				if c.RandBool() {
0000000000000000000000000000000000000000;;					i := int(c.Int31())
0000000000000000000000000000000000000000;;					*j = &i
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					*j = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(j *runtime.TypeMeta, c fuzz.Continue) {
0000000000000000000000000000000000000000;;				// We have to customize the randomization of TypeMetas because their
0000000000000000000000000000000000000000;;				// APIVersion and Kind must remain blank in memory.
0000000000000000000000000000000000000000;;				j.APIVersion = ""
0000000000000000000000000000000000000000;;				j.Kind = ""
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(j *metav1.TypeMeta, c fuzz.Continue) {
0000000000000000000000000000000000000000;;				// We have to customize the randomization of TypeMetas because their
0000000000000000000000000000000000000000;;				// APIVersion and Kind must remain blank in memory.
0000000000000000000000000000000000000000;;				j.APIVersion = ""
0000000000000000000000000000000000000000;;				j.Kind = ""
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(j *metav1.ObjectMeta, c fuzz.Continue) {
0000000000000000000000000000000000000000;;				j.Name = c.RandString()
0000000000000000000000000000000000000000;;				j.ResourceVersion = strconv.FormatUint(c.RandUint64(), 10)
0000000000000000000000000000000000000000;;				j.SelfLink = c.RandString()
0000000000000000000000000000000000000000;;				j.UID = types.UID(c.RandString())
0000000000000000000000000000000000000000;;				j.GenerateName = c.RandString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var sec, nsec int64
0000000000000000000000000000000000000000;;				c.Fuzz(&sec)
0000000000000000000000000000000000000000;;				c.Fuzz(&nsec)
0000000000000000000000000000000000000000;;				j.CreationTimestamp = metav1.Unix(sec, nsec).Rfc3339Copy()
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(j *metav1.ListMeta, c fuzz.Continue) {
0000000000000000000000000000000000000000;;				j.ResourceVersion = strconv.FormatUint(c.RandUint64(), 10)
0000000000000000000000000000000000000000;;				j.SelfLink = c.RandString()
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(j *runtime.Object, c fuzz.Continue) {
0000000000000000000000000000000000000000;;				// TODO: uncomment when round trip starts from a versioned object
0000000000000000000000000000000000000000;;				if true { //c.RandBool() {
0000000000000000000000000000000000000000;;					*j = &runtime.Unknown{
0000000000000000000000000000000000000000;;						// We do not set TypeMeta here because it is not carried through a round trip
0000000000000000000000000000000000000000;;						Raw:         []byte(`{"apiVersion":"unknown.group/unknown","kind":"Something","someKey":"someValue"}`),
0000000000000000000000000000000000000000;;						ContentType: runtime.ContentTypeJSON,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					types := []runtime.Object{&metav1.Status{}, &metav1.APIGroup{}}
0000000000000000000000000000000000000000;;					t := types[c.Rand.Intn(len(types))]
0000000000000000000000000000000000000000;;					c.Fuzz(t)
0000000000000000000000000000000000000000;;					*j = t
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(r *runtime.RawExtension, c fuzz.Continue) {
0000000000000000000000000000000000000000;;				// Pick an arbitrary type and fuzz it
0000000000000000000000000000000000000000;;				types := []runtime.Object{&metav1.Status{}, &metav1.APIGroup{}}
0000000000000000000000000000000000000000;;				obj := types[c.Rand.Intn(len(types))]
0000000000000000000000000000000000000000;;				c.Fuzz(obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Find a codec for converting the object to raw bytes.  This is necessary for the
0000000000000000000000000000000000000000;;				// api version and kind to be correctly set be serialization.
0000000000000000000000000000000000000000;;				var codec = TestCodec(codecs, metav1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Convert the object to raw bytes
0000000000000000000000000000000000000000;;				bytes, err := runtime.Encode(codec, obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Failed to encode object: %v", err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Set the bytes field on the RawExtension
0000000000000000000000000000000000000000;;				r.Raw = bytes
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestingCommon abstracts testing.T and testing.B
0000000000000000000000000000000000000000;;	type TestingCommon interface {
0000000000000000000000000000000000000000;;		Log(args ...interface{})
0000000000000000000000000000000000000000;;		Logf(format string, args ...interface{})
0000000000000000000000000000000000000000;;		Error(args ...interface{})
0000000000000000000000000000000000000000;;		Errorf(format string, args ...interface{})
0000000000000000000000000000000000000000;;		Fatal(args ...interface{})
0000000000000000000000000000000000000000;;		Fatalf(format string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ TestingCommon = &testing.T{}
0000000000000000000000000000000000000000;;		_ TestingCommon = &testing.B{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FuzzerFor can randomly populate api objects that are destined for version.
0000000000000000000000000000000000000000;;	func FuzzerFor(funcs []interface{}, src rand.Source) *fuzz.Fuzzer {
0000000000000000000000000000000000000000;;		f := fuzz.New().NilChance(.5).NumElements(0, 1)
0000000000000000000000000000000000000000;;		if src != nil {
0000000000000000000000000000000000000000;;			f.RandSource(src)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Funcs(funcs...)
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeFuzzerFuncs will merge the given funcLists, overriding early funcs with later ones if there first
0000000000000000000000000000000000000000;;	// argument has the same type.
0000000000000000000000000000000000000000;;	func MergeFuzzerFuncs(t TestingCommon, funcLists ...[]interface{}) []interface{} {
0000000000000000000000000000000000000000;;		funcMap := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for _, list := range funcLists {
0000000000000000000000000000000000000000;;			for _, f := range list {
0000000000000000000000000000000000000000;;				fT := reflect.TypeOf(f)
0000000000000000000000000000000000000000;;				if fT.Kind() != reflect.Func || fT.NumIn() != 2 {
0000000000000000000000000000000000000000;;					t.Errorf("Fuzzer func with invalid type: %v", fT)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				funcMap[fT.In(0).String()] = f
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := []interface{}{}
0000000000000000000000000000000000000000;;		for _, f := range funcMap {
0000000000000000000000000000000000000000;;			result = append(result, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultFuzzers(t TestingCommon, codecFactory runtimeserializer.CodecFactory, fuzzerFuncs []interface{}) *fuzz.Fuzzer {
0000000000000000000000000000000000000000;;		seed := rand.Int63()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return FuzzerFor(
0000000000000000000000000000000000000000;;			MergeFuzzerFuncs(t,
0000000000000000000000000000000000000000;;				GenericFuzzerFuncs(t, codecFactory),
0000000000000000000000000000000000000000;;				fuzzerFuncs,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;			rand.NewSource(seed),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
