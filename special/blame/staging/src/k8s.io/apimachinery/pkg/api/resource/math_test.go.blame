0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7a0fd96a0e277dc6b58d744af9d5b6242c8ca1f6;pkg/api/resource/math_test.go[pkg/api/resource/math_test.go][staging/src/k8s.io/apimachinery/pkg/api/resource/math_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDetectOverflowAdd(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			a, b int64
0000000000000000000000000000000000000000;;			c    int64
0000000000000000000000000000000000000000;;			ok   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{0, 0, 0, true},
0000000000000000000000000000000000000000;;			{-1, 1, 0, true},
0000000000000000000000000000000000000000;;			{0, 1, 1, true},
0000000000000000000000000000000000000000;;			{2, 2, 4, true},
0000000000000000000000000000000000000000;;			{2, -2, 0, true},
0000000000000000000000000000000000000000;;			{-2, -2, -4, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{mostNegative, -1, 0, false},
0000000000000000000000000000000000000000;;			{mostNegative, 1, mostNegative + 1, true},
0000000000000000000000000000000000000000;;			{mostPositive, -1, mostPositive - 1, true},
0000000000000000000000000000000000000000;;			{mostPositive, 1, 0, false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{mostNegative, mostPositive, -1, true},
0000000000000000000000000000000000000000;;			{mostPositive, mostNegative, -1, true},
0000000000000000000000000000000000000000;;			{mostPositive, mostPositive, 0, false},
0000000000000000000000000000000000000000;;			{mostNegative, mostNegative, 0, false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{-mostPositive, mostNegative, 0, false},
0000000000000000000000000000000000000000;;			{mostNegative, -mostPositive, 0, false},
0000000000000000000000000000000000000000;;			{-mostPositive, -mostPositive, 0, false},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			c, ok := int64Add(test.a, test.b)
0000000000000000000000000000000000000000;;			if c != test.c {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected result: %d", test, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok != test.ok {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected overflow: %t", test, ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// addition is commutative
0000000000000000000000000000000000000000;;			d, ok2 := int64Add(test.b, test.a)
0000000000000000000000000000000000000000;;			if c != d || ok != ok2 {
0000000000000000000000000000000000000000;;				t.Errorf("%v: not commutative: %d %t", test, d, ok2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDetectOverflowMultiply(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			a, b int64
0000000000000000000000000000000000000000;;			c    int64
0000000000000000000000000000000000000000;;			ok   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{0, 0, 0, true},
0000000000000000000000000000000000000000;;			{-1, 1, -1, true},
0000000000000000000000000000000000000000;;			{-1, -1, 1, true},
0000000000000000000000000000000000000000;;			{1, 1, 1, true},
0000000000000000000000000000000000000000;;			{0, 1, 0, true},
0000000000000000000000000000000000000000;;			{1, 0, 0, true},
0000000000000000000000000000000000000000;;			{2, 2, 4, true},
0000000000000000000000000000000000000000;;			{2, -2, -4, true},
0000000000000000000000000000000000000000;;			{-2, -2, 4, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{mostNegative, -1, 0, false},
0000000000000000000000000000000000000000;;			{mostNegative, 1, mostNegative, true},
0000000000000000000000000000000000000000;;			{mostPositive, -1, -mostPositive, true},
0000000000000000000000000000000000000000;;			{mostPositive, 1, mostPositive, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{mostNegative, mostPositive, 0, false},
0000000000000000000000000000000000000000;;			{mostPositive, mostNegative, 0, false},
0000000000000000000000000000000000000000;;			{mostPositive, mostPositive, 1, false},
0000000000000000000000000000000000000000;;			{mostNegative, mostNegative, 0, false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{-mostPositive, mostNegative, 0, false},
0000000000000000000000000000000000000000;;			{mostNegative, -mostPositive, 0, false},
0000000000000000000000000000000000000000;;			{-mostPositive, -mostPositive, 1, false},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			c, ok := int64Multiply(test.a, test.b)
0000000000000000000000000000000000000000;;			if c != test.c {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected result: %d", test, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok != test.ok {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected overflow: %t", test, ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// multiplication is commutative
0000000000000000000000000000000000000000;;			d, ok2 := int64Multiply(test.b, test.a)
0000000000000000000000000000000000000000;;			if c != d || ok != ok2 {
0000000000000000000000000000000000000000;;				t.Errorf("%v: not commutative: %d %t", test, d, ok2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDetectOverflowScale(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, a := range []int64{0, -1, 1, 10, -10, mostPositive, mostNegative, -mostPositive} {
0000000000000000000000000000000000000000;;			for _, b := range []int64{1, 2, 10, 100, 1000, mostPositive} {
0000000000000000000000000000000000000000;;				expect, expectOk := int64Multiply(a, b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				c, ok := int64MultiplyScale(a, b)
0000000000000000000000000000000000000000;;				if c != expect {
0000000000000000000000000000000000000000;;					t.Errorf("%d*%d: unexpected result: %d", a, b, c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ok != expectOk {
0000000000000000000000000000000000000000;;					t.Errorf("%d*%d: unexpected overflow: %t", a, b, ok)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, test := range []struct {
0000000000000000000000000000000000000000;;				base int64
0000000000000000000000000000000000000000;;				fn   func(a int64) (int64, bool)
0000000000000000000000000000000000000000;;			}{
0000000000000000000000000000000000000000;;				{10, int64MultiplyScale10},
0000000000000000000000000000000000000000;;				{100, int64MultiplyScale100},
0000000000000000000000000000000000000000;;				{1000, int64MultiplyScale1000},
0000000000000000000000000000000000000000;;			} {
0000000000000000000000000000000000000000;;				expect, expectOk := int64Multiply(a, test.base)
0000000000000000000000000000000000000000;;				c, ok := test.fn(a)
0000000000000000000000000000000000000000;;				if c != expect {
0000000000000000000000000000000000000000;;					t.Errorf("%d*%d: unexpected result: %d", a, test.base, c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ok != expectOk {
0000000000000000000000000000000000000000;;					t.Errorf("%d*%d: unexpected overflow: %t", a, test.base, ok)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRemoveInt64Factors(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			value  int64
0000000000000000000000000000000000000000;;			max    int64
0000000000000000000000000000000000000000;;			result int64
0000000000000000000000000000000000000000;;			scale  int32
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{100, 10, 1, 2},
0000000000000000000000000000000000000000;;			{100, 10, 1, 2},
0000000000000000000000000000000000000000;;			{100, 100, 1, 1},
0000000000000000000000000000000000000000;;			{1, 10, 1, 0},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			r, s := removeInt64Factors(test.value, test.max)
0000000000000000000000000000000000000000;;			if r != test.result {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected result: %d", test, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s != test.scale {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected scale: %d", test, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNegativeScaleInt64(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, test := range []struct {
0000000000000000000000000000000000000000;;			base   int64
0000000000000000000000000000000000000000;;			scale  Scale
0000000000000000000000000000000000000000;;			result int64
0000000000000000000000000000000000000000;;			exact  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{1234567, 0, 1234567, true},
0000000000000000000000000000000000000000;;			{1234567, 1, 123457, false},
0000000000000000000000000000000000000000;;			{1234567, 2, 12346, false},
0000000000000000000000000000000000000000;;			{1234567, 3, 1235, false},
0000000000000000000000000000000000000000;;			{1234567, 4, 124, false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{-1234567, 0, -1234567, true},
0000000000000000000000000000000000000000;;			{-1234567, 1, -123457, false},
0000000000000000000000000000000000000000;;			{-1234567, 2, -12346, false},
0000000000000000000000000000000000000000;;			{-1234567, 3, -1235, false},
0000000000000000000000000000000000000000;;			{-1234567, 4, -124, false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{1000, 0, 1000, true},
0000000000000000000000000000000000000000;;			{1000, 1, 100, true},
0000000000000000000000000000000000000000;;			{1000, 2, 10, true},
0000000000000000000000000000000000000000;;			{1000, 3, 1, true},
0000000000000000000000000000000000000000;;			{1000, 4, 1, false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{-1000, 0, -1000, true},
0000000000000000000000000000000000000000;;			{-1000, 1, -100, true},
0000000000000000000000000000000000000000;;			{-1000, 2, -10, true},
0000000000000000000000000000000000000000;;			{-1000, 3, -1, true},
0000000000000000000000000000000000000000;;			{-1000, 4, -1, false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{0, 0, 0, true},
0000000000000000000000000000000000000000;;			{0, 1, 0, true},
0000000000000000000000000000000000000000;;			{0, 2, 0, true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// negative scale is undefined behavior
0000000000000000000000000000000000000000;;			{1000, -1, 1000, true},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			result, exact := negativeScaleInt64(test.base, test.scale)
0000000000000000000000000000000000000000;;			if result != test.result {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected result: %d", test, result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if exact != test.exact {
0000000000000000000000000000000000000000;;				t.Errorf("%v: unexpected exact: %t", test, exact)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
