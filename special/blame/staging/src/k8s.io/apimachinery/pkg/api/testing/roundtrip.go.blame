0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
b88bd8b183cd9c99a6a120d205bbf7e3860fd2e0;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package testing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/protobuf"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/announced"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/registered"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		runtimeserializer "k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InstallFunc func(groupFactoryRegistry announced.APIGroupFactoryRegistry, registry *registered.APIRegistrationManager, scheme *runtime.Scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTripTestForAPIGroup is convenient to call from your install package to make sure that a "bare" install of your group provides
0000000000000000000000000000000000000000;;	// enough information to round trip
0000000000000000000000000000000000000000;;	func RoundTripTestForAPIGroup(t *testing.T, installFn InstallFunc, fuzzingFuncs []interface{}) {
0000000000000000000000000000000000000000;;		groupFactoryRegistry := make(announced.APIGroupFactoryRegistry)
0000000000000000000000000000000000000000;;		registry := registered.NewOrDie("")
0000000000000000000000000000000000000000;;		scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		installFn(groupFactoryRegistry, registry, scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RoundTripTestForScheme(t, scheme, fuzzingFuncs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTripTestForScheme is convenient to call if you already have a scheme and want to make sure that its well-formed
0000000000000000000000000000000000000000;;	func RoundTripTestForScheme(t *testing.T, scheme *runtime.Scheme, fuzzingFuncs []interface{}) {
0000000000000000000000000000000000000000;;		codecFactory := runtimeserializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;		fuzzer := DefaultFuzzers(t, codecFactory, fuzzingFuncs)
0000000000000000000000000000000000000000;;		RoundTripTypesWithoutProtobuf(t, scheme, codecFactory, fuzzer, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTripProtobufTestForAPIGroup is convenient to call from your install package to make sure that a "bare" install of your group provides
0000000000000000000000000000000000000000;;	// enough information to round trip
0000000000000000000000000000000000000000;;	func RoundTripProtobufTestForAPIGroup(t *testing.T, installFn InstallFunc, fuzzingFuncs []interface{}) {
0000000000000000000000000000000000000000;;		groupFactoryRegistry := make(announced.APIGroupFactoryRegistry)
0000000000000000000000000000000000000000;;		registry := registered.NewOrDie("")
0000000000000000000000000000000000000000;;		scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		installFn(groupFactoryRegistry, registry, scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RoundTripProtobufTestForScheme(t, scheme, fuzzingFuncs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTripProtobufTestForScheme is convenient to call if you already have a scheme and want to make sure that its well-formed
0000000000000000000000000000000000000000;;	func RoundTripProtobufTestForScheme(t *testing.T, scheme *runtime.Scheme, fuzzingFuncs []interface{}) {
0000000000000000000000000000000000000000;;		codecFactory := runtimeserializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;		fuzzer := DefaultFuzzers(t, codecFactory, fuzzingFuncs)
0000000000000000000000000000000000000000;;		RoundTripTypes(t, scheme, codecFactory, fuzzer, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var FuzzIters = flag.Int("fuzz-iters", 20, "How many fuzzing iterations to do.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// globalNonRoundTrippableTypes are kinds that are effectively reserved across all GroupVersions
0000000000000000000000000000000000000000;;	// They don't roundtrip
0000000000000000000000000000000000000000;;	var globalNonRoundTrippableTypes = sets.NewString(
0000000000000000000000000000000000000000;;		"ExportOptions",
0000000000000000000000000000000000000000;;		"GetOptions",
0000000000000000000000000000000000000000;;		// WatchEvent does not include kind and version and can only be deserialized
0000000000000000000000000000000000000000;;		// implicitly (if the caller expects the specific object). The watch call defines
0000000000000000000000000000000000000000;;		// the schema by content type, rather than via kind/version included in each
0000000000000000000000000000000000000000;;		// object.
0000000000000000000000000000000000000000;;		"WatchEvent",
0000000000000000000000000000000000000000;;		// ListOptions is now part of the meta group
0000000000000000000000000000000000000000;;		"ListOptions",
0000000000000000000000000000000000000000;;		// Delete options is only read in metav1
0000000000000000000000000000000000000000;;		"DeleteOptions",
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTripTypesWithoutProtobuf applies the round-trip test to all round-trippable Kinds
0000000000000000000000000000000000000000;;	// in the scheme.  It will skip all the GroupVersionKinds in the skip list.
0000000000000000000000000000000000000000;;	func RoundTripTypesWithoutProtobuf(t *testing.T, scheme *runtime.Scheme, codecFactory runtimeserializer.CodecFactory, fuzzer *fuzz.Fuzzer, nonRoundTrippableTypes map[schema.GroupVersionKind]bool) {
0000000000000000000000000000000000000000;;		roundTripTypes(t, scheme, codecFactory, fuzzer, nonRoundTrippableTypes, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RoundTripTypes(t *testing.T, scheme *runtime.Scheme, codecFactory runtimeserializer.CodecFactory, fuzzer *fuzz.Fuzzer, nonRoundTrippableTypes map[schema.GroupVersionKind]bool) {
0000000000000000000000000000000000000000;;		roundTripTypes(t, scheme, codecFactory, fuzzer, nonRoundTrippableTypes, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func roundTripTypes(t *testing.T, scheme *runtime.Scheme, codecFactory runtimeserializer.CodecFactory, fuzzer *fuzz.Fuzzer, nonRoundTrippableTypes map[schema.GroupVersionKind]bool, skipProtobuf bool) {
0000000000000000000000000000000000000000;;		for _, group := range groupsFromScheme(scheme) {
0000000000000000000000000000000000000000;;			t.Logf("starting group %q", group)
0000000000000000000000000000000000000000;;			internalVersion := schema.GroupVersion{Group: group, Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;			internalKindToGoType := scheme.KnownTypes(internalVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for kind := range internalKindToGoType {
0000000000000000000000000000000000000000;;				if globalNonRoundTrippableTypes.Has(kind) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				internalGVK := internalVersion.WithKind(kind)
0000000000000000000000000000000000000000;;				roundTripSpecificKind(t, internalGVK, scheme, codecFactory, fuzzer, nonRoundTrippableTypes, skipProtobuf)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t.Logf("finished group %q", group)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RoundTripSpecificKindWithoutProtobuf(t *testing.T, gvk schema.GroupVersionKind, scheme *runtime.Scheme, codecFactory runtimeserializer.CodecFactory, fuzzer *fuzz.Fuzzer, nonRoundTrippableTypes map[schema.GroupVersionKind]bool) {
0000000000000000000000000000000000000000;;		roundTripSpecificKind(t, gvk, scheme, codecFactory, fuzzer, nonRoundTrippableTypes, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RoundTripSpecificKind(t *testing.T, gvk schema.GroupVersionKind, scheme *runtime.Scheme, codecFactory runtimeserializer.CodecFactory, fuzzer *fuzz.Fuzzer, nonRoundTrippableTypes map[schema.GroupVersionKind]bool) {
0000000000000000000000000000000000000000;;		roundTripSpecificKind(t, gvk, scheme, codecFactory, fuzzer, nonRoundTrippableTypes, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func roundTripSpecificKind(t *testing.T, gvk schema.GroupVersionKind, scheme *runtime.Scheme, codecFactory runtimeserializer.CodecFactory, fuzzer *fuzz.Fuzzer, nonRoundTrippableTypes map[schema.GroupVersionKind]bool, skipProtobuf bool) {
0000000000000000000000000000000000000000;;		if nonRoundTrippableTypes[gvk] {
0000000000000000000000000000000000000000;;			t.Logf("skipping %v", gvk)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("round tripping %v", gvk)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try a few times, since runTest uses random values.
0000000000000000000000000000000000000000;;		for i := 0; i < *FuzzIters; i++ {
0000000000000000000000000000000000000000;;			if gvk.Version == runtime.APIVersionInternal {
0000000000000000000000000000000000000000;;				roundTripToAllExternalVersions(t, scheme, codecFactory, fuzzer, gvk, nonRoundTrippableTypes, skipProtobuf)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				roundTripOfExternalType(t, scheme, codecFactory, fuzzer, gvk, skipProtobuf)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.Failed() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fuzzInternalObject fuzzes an arbitrary runtime object using the appropriate
0000000000000000000000000000000000000000;;	// fuzzer registered with the apitesting package.
0000000000000000000000000000000000000000;;	func fuzzInternalObject(t *testing.T, fuzzer *fuzz.Fuzzer, object runtime.Object) runtime.Object {
0000000000000000000000000000000000000000;;		fuzzer.Fuzz(object)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j, err := meta.TypeAccessor(object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error %v for %#v", err, object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		j.SetKind("")
0000000000000000000000000000000000000000;;		j.SetAPIVersion("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func groupsFromScheme(scheme *runtime.Scheme) []string {
0000000000000000000000000000000000000000;;		ret := sets.String{}
0000000000000000000000000000000000000000;;		for gvk := range scheme.AllKnownTypes() {
0000000000000000000000000000000000000000;;			ret.Insert(gvk.Group)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret.List()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func roundTripToAllExternalVersions(t *testing.T, scheme *runtime.Scheme, codecFactory runtimeserializer.CodecFactory, fuzzer *fuzz.Fuzzer, internalGVK schema.GroupVersionKind, nonRoundTrippableTypes map[schema.GroupVersionKind]bool, skipProtobuf bool) {
0000000000000000000000000000000000000000;;		object, err := scheme.New(internalGVK)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't make a %v? %v", internalGVK, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := meta.TypeAccessor(object); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%q is not a TypeMeta and cannot be tested - add it to nonRoundTrippableInternalTypes: %v", internalGVK, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fuzzInternalObject(t, fuzzer, object)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find all potential serializations in the scheme.
0000000000000000000000000000000000000000;;		// TODO fix this up to handle kinds that cross registered with different names.
0000000000000000000000000000000000000000;;		for externalGVK, externalGoType := range scheme.AllKnownTypes() {
0000000000000000000000000000000000000000;;			if externalGVK.Version == runtime.APIVersionInternal {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if externalGVK.GroupKind() != internalGVK.GroupKind() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if nonRoundTrippableTypes[externalGVK] {
0000000000000000000000000000000000000000;;				t.Logf("\tskipping  %v %v", externalGVK, externalGoType)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Logf("\tround tripping to %v %v", externalGVK, externalGoType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			roundTrip(t, scheme, TestCodec(codecFactory, externalGVK.GroupVersion()), object)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO remove this hack after we're past the intermediate steps
0000000000000000000000000000000000000000;;			if !skipProtobuf && externalGVK.Group != "kubeadm.k8s.io" {
0000000000000000000000000000000000000000;;				s := protobuf.NewSerializer(scheme, scheme, "application/arbitrary.content.type")
0000000000000000000000000000000000000000;;				protobufCodec := codecFactory.CodecForVersions(s, s, externalGVK.GroupVersion(), nil)
0000000000000000000000000000000000000000;;				roundTrip(t, scheme, protobufCodec, object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func roundTripOfExternalType(t *testing.T, scheme *runtime.Scheme, codecFactory runtimeserializer.CodecFactory, fuzzer *fuzz.Fuzzer, externalGVK schema.GroupVersionKind, skipProtobuf bool) {
0000000000000000000000000000000000000000;;		object, err := scheme.New(externalGVK)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Couldn't make a %v? %v", externalGVK, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typeAcc, err := meta.TypeAccessor(object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("%q is not a TypeMeta and cannot be tested - add it to nonRoundTrippableInternalTypes: %v", externalGVK, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fuzzInternalObject(t, fuzzer, object)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		externalGoType := reflect.TypeOf(object).PkgPath()
0000000000000000000000000000000000000000;;		t.Logf("\tround tripping external type %v %v", externalGVK, externalGoType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typeAcc.SetKind(externalGVK.Kind)
0000000000000000000000000000000000000000;;		typeAcc.SetAPIVersion(externalGVK.GroupVersion().String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		roundTrip(t, scheme, json.NewSerializer(json.DefaultMetaFactory, scheme, scheme, false), object)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO remove this hack after we're past the intermediate steps
0000000000000000000000000000000000000000;;		if !skipProtobuf {
0000000000000000000000000000000000000000;;			roundTrip(t, scheme, protobuf.NewSerializer(scheme, scheme, "application/protobuf"), object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// roundTrip applies a single round-trip test to the given runtime object
0000000000000000000000000000000000000000;;	// using the given codec.  The round-trip test ensures that an object can be
0000000000000000000000000000000000000000;;	// deep-copied, converted, marshaled and back without loss of data.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For internal types this means
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   internal -> external -> json/protobuf -> external -> internal.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For external types this means
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   external -> json/protobuf -> external.
0000000000000000000000000000000000000000;;	func roundTrip(t *testing.T, scheme *runtime.Scheme, codec runtime.Codec, object runtime.Object) {
0000000000000000000000000000000000000000;;		printer := spew.ConfigState{DisableMethods: true}
0000000000000000000000000000000000000000;;		original := object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// deep copy the original object
0000000000000000000000000000000000000000;;		copied, err := scheme.DeepCopy(object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unable to copy: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		object = copied.(runtime.Object)
0000000000000000000000000000000000000000;;		name := reflect.TypeOf(object).Elem().Name()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// encode (serialize) the deep copy using the provided codec
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(codec, object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if runtime.IsNotRegisteredError(err) {
0000000000000000000000000000000000000000;;				t.Logf("%v: not registered: %v (%s)", name, err, printer.Sprintf("%#v", object))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Errorf("%v: %v (%s)", name, err, printer.Sprintf("%#v", object))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure that the deep copy is equal to the original; neither the deep
0000000000000000000000000000000000000000;;		// copy or conversion should alter the object
0000000000000000000000000000000000000000;;		// TODO eliminate this global
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(original, object) {
0000000000000000000000000000000000000000;;			t.Errorf("0: %v: encode altered the object, diff: %v", name, diff.ObjectReflectDiff(original, object))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// encode (serialize) a second time to verify that it was not varying
0000000000000000000000000000000000000000;;		secondData, err := runtime.Encode(codec, object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if runtime.IsNotRegisteredError(err) {
0000000000000000000000000000000000000000;;				t.Logf("%v: not registered: %v (%s)", name, err, printer.Sprintf("%#v", object))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t.Errorf("%v: %v (%s)", name, err, printer.Sprintf("%#v", object))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// serialization to the wire must be stable to ensure that we don't write twice to the DB
0000000000000000000000000000000000000000;;		// when the object hasn't changed.
0000000000000000000000000000000000000000;;		if !bytes.Equal(data, secondData) {
0000000000000000000000000000000000000000;;			t.Errorf("%v: serialization is not stable: %s", name, printer.Sprintf("%#v", object))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// decode (deserialize) the encoded data back into an object
0000000000000000000000000000000000000000;;		obj2, err := runtime.Decode(codec, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("0: %v: %v\nCodec: %#v\nData: %s\nSource: %#v", name, err, codec, dataAsString(data), printer.Sprintf("%#v", object))
0000000000000000000000000000000000000000;;			panic("failed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure that the object produced from decoding the encoded data is equal
0000000000000000000000000000000000000000;;		// to the original object
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(original, obj2) {
0000000000000000000000000000000000000000;;			t.Errorf("1: %v: diff: %v\nCodec: %#v\nSource:\n\n%#v\n\nEncoded:\n\n%s\n\nFinal:\n\n%#v", name, diff.ObjectReflectDiff(object, obj2), codec, printer.Sprintf("%#v", object), dataAsString(data), printer.Sprintf("%#v", obj2))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// decode the encoded data into a new object (instead of letting the codec
0000000000000000000000000000000000000000;;		// create a new object)
0000000000000000000000000000000000000000;;		obj3 := reflect.New(reflect.TypeOf(object).Elem()).Interface().(runtime.Object)
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(codec, data, obj3); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("2: %v: %v", name, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure that the new runtime object is equal to the original after being
0000000000000000000000000000000000000000;;		// decoded into
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(object, obj3) {
0000000000000000000000000000000000000000;;			t.Errorf("3: %v: diff: %v\nCodec: %#v", name, diff.ObjectReflectDiff(object, obj3), codec)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do structure-preserving fuzzing of the deep-copied object. If it shares anything with the original,
0000000000000000000000000000000000000000;;		// the deep-copy was actually only a shallow copy. Then original and obj3 will be different after fuzzing.
0000000000000000000000000000000000000000;;		// NOTE: we use the encoding+decoding here as an alternative, guaranteed deep-copy to compare against.
0000000000000000000000000000000000000000;;		ValueFuzz(object)
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(original, obj3) {
0000000000000000000000000000000000000000;;			t.Errorf("0: %v: fuzzing a copy altered the original, diff: %v", name, diff.ObjectReflectDiff(original, object))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dataAsString returns the given byte array as a string; handles detecting
0000000000000000000000000000000000000000;;	// protocol buffers.
0000000000000000000000000000000000000000;;	func dataAsString(data []byte) string {
0000000000000000000000000000000000000000;;		dataString := string(data)
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(dataString, "{") {
0000000000000000000000000000000000000000;;			dataString = "\n" + hex.Dump(data)
0000000000000000000000000000000000000000;;			proto.NewBuffer(make([]byte, 0, 1024)).DebugPrint("decoded object", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dataString
0000000000000000000000000000000000000000;;	}
