0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
cd21aada46990c01e2bf823e54b41a8fd3213620;pkg/api/errors/errors.go[pkg/api/errors/errors.go][staging/src/k8s.io/apimachinery/pkg/api/errors/errors.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package errors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTP Status codes not in the golang http package.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		StatusUnprocessableEntity = 422
0000000000000000000000000000000000000000;;		StatusTooManyRequests     = 429
0000000000000000000000000000000000000000;;		// StatusServerTimeout is an indication that a transient server error has
0000000000000000000000000000000000000000;;		// occurred and the client *should* retry, with an optional Retry-After
0000000000000000000000000000000000000000;;		// header to specify the back off window.
0000000000000000000000000000000000000000;;		StatusServerTimeout = 504
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusError is an error intended for consumption by a REST API server; it can also be
0000000000000000000000000000000000000000;;	// reconstructed by clients from a REST response. Public to allow easy type switches.
0000000000000000000000000000000000000000;;	type StatusError struct {
0000000000000000000000000000000000000000;;		ErrStatus metav1.Status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIStatus is exposed by errors that can be converted to an api.Status object
0000000000000000000000000000000000000000;;	// for finer grained details.
0000000000000000000000000000000000000000;;	type APIStatus interface {
0000000000000000000000000000000000000000;;		Status() metav1.Status
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ error = &StatusError{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error implements the Error interface.
0000000000000000000000000000000000000000;;	func (e *StatusError) Error() string {
0000000000000000000000000000000000000000;;		return e.ErrStatus.Message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status allows access to e's status without having to know the detailed workings
0000000000000000000000000000000000000000;;	// of StatusError.
0000000000000000000000000000000000000000;;	func (e *StatusError) Status() metav1.Status {
0000000000000000000000000000000000000000;;		return e.ErrStatus
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DebugError reports extended info about the error to debug output.
0000000000000000000000000000000000000000;;	func (e *StatusError) DebugError() (string, []interface{}) {
0000000000000000000000000000000000000000;;		if out, err := json.MarshalIndent(e.ErrStatus, "", "  "); err == nil {
0000000000000000000000000000000000000000;;			return "server response object: %s", []interface{}{string(out)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "server response object: %#v", []interface{}{e.ErrStatus}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnexpectedObjectError can be returned by FromObject if it's passed a non-status object.
0000000000000000000000000000000000000000;;	type UnexpectedObjectError struct {
0000000000000000000000000000000000000000;;		Object runtime.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns an error message describing 'u'.
0000000000000000000000000000000000000000;;	func (u *UnexpectedObjectError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("unexpected object: %v", u.Object)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromObject generates an StatusError from an metav1.Status, if that is the type of obj; otherwise,
0000000000000000000000000000000000000000;;	// returns an UnexpecteObjectError.
0000000000000000000000000000000000000000;;	func FromObject(obj runtime.Object) error {
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case *metav1.Status:
0000000000000000000000000000000000000000;;			return &StatusError{*t}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &UnexpectedObjectError{obj}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNotFound returns a new error which indicates that the resource of the kind and the name was not found.
0000000000000000000000000000000000000000;;	func NewNotFound(qualifiedResource schema.GroupResource, name string) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:   http.StatusNotFound,
0000000000000000000000000000000000000000;;			Reason: metav1.StatusReasonNotFound,
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Group: qualifiedResource.Group,
0000000000000000000000000000000000000000;;				Kind:  qualifiedResource.Resource,
0000000000000000000000000000000000000000;;				Name:  name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Message: fmt.Sprintf("%s %q not found", qualifiedResource.String(), name),
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAlreadyExists returns an error indicating the item requested exists by that identifier.
0000000000000000000000000000000000000000;;	func NewAlreadyExists(qualifiedResource schema.GroupResource, name string) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:   http.StatusConflict,
0000000000000000000000000000000000000000;;			Reason: metav1.StatusReasonAlreadyExists,
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Group: qualifiedResource.Group,
0000000000000000000000000000000000000000;;				Kind:  qualifiedResource.Resource,
0000000000000000000000000000000000000000;;				Name:  name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Message: fmt.Sprintf("%s %q already exists", qualifiedResource.String(), name),
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUnauthorized returns an error indicating the client is not authorized to perform the requested
0000000000000000000000000000000000000000;;	// action.
0000000000000000000000000000000000000000;;	func NewUnauthorized(reason string) *StatusError {
0000000000000000000000000000000000000000;;		message := reason
0000000000000000000000000000000000000000;;		if len(message) == 0 {
0000000000000000000000000000000000000000;;			message = "not authorized"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:    http.StatusUnauthorized,
0000000000000000000000000000000000000000;;			Reason:  metav1.StatusReasonUnauthorized,
0000000000000000000000000000000000000000;;			Message: message,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewForbidden returns an error indicating the requested action was forbidden
0000000000000000000000000000000000000000;;	func NewForbidden(qualifiedResource schema.GroupResource, name string, err error) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:   http.StatusForbidden,
0000000000000000000000000000000000000000;;			Reason: metav1.StatusReasonForbidden,
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Group: qualifiedResource.Group,
0000000000000000000000000000000000000000;;				Kind:  qualifiedResource.Resource,
0000000000000000000000000000000000000000;;				Name:  name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Message: fmt.Sprintf("%s %q is forbidden: %v", qualifiedResource.String(), name, err),
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConflict returns an error indicating the item can't be updated as provided.
0000000000000000000000000000000000000000;;	func NewConflict(qualifiedResource schema.GroupResource, name string, err error) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:   http.StatusConflict,
0000000000000000000000000000000000000000;;			Reason: metav1.StatusReasonConflict,
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Group: qualifiedResource.Group,
0000000000000000000000000000000000000000;;				Kind:  qualifiedResource.Resource,
0000000000000000000000000000000000000000;;				Name:  name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Message: fmt.Sprintf("Operation cannot be fulfilled on %s %q: %v", qualifiedResource.String(), name, err),
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGone returns an error indicating the item no longer available at the server and no forwarding address is known.
0000000000000000000000000000000000000000;;	func NewGone(message string) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:    http.StatusGone,
0000000000000000000000000000000000000000;;			Reason:  metav1.StatusReasonGone,
0000000000000000000000000000000000000000;;			Message: message,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInvalid returns an error indicating the item is invalid and cannot be processed.
0000000000000000000000000000000000000000;;	func NewInvalid(qualifiedKind schema.GroupKind, name string, errs field.ErrorList) *StatusError {
0000000000000000000000000000000000000000;;		causes := make([]metav1.StatusCause, 0, len(errs))
0000000000000000000000000000000000000000;;		for i := range errs {
0000000000000000000000000000000000000000;;			err := errs[i]
0000000000000000000000000000000000000000;;			causes = append(causes, metav1.StatusCause{
0000000000000000000000000000000000000000;;				Type:    metav1.CauseType(err.Type),
0000000000000000000000000000000000000000;;				Message: err.ErrorBody(),
0000000000000000000000000000000000000000;;				Field:   err.Field,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:   StatusUnprocessableEntity, // RFC 4918: StatusUnprocessableEntity
0000000000000000000000000000000000000000;;			Reason: metav1.StatusReasonInvalid,
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Group:  qualifiedKind.Group,
0000000000000000000000000000000000000000;;				Kind:   qualifiedKind.Kind,
0000000000000000000000000000000000000000;;				Name:   name,
0000000000000000000000000000000000000000;;				Causes: causes,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Message: fmt.Sprintf("%s %q is invalid: %v", qualifiedKind.String(), name, errs.ToAggregate()),
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBadRequest creates an error that indicates that the request is invalid and can not be processed.
0000000000000000000000000000000000000000;;	func NewBadRequest(reason string) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:    http.StatusBadRequest,
0000000000000000000000000000000000000000;;			Reason:  metav1.StatusReasonBadRequest,
0000000000000000000000000000000000000000;;			Message: reason,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServiceUnavailable creates an error that indicates that the requested service is unavailable.
0000000000000000000000000000000000000000;;	func NewServiceUnavailable(reason string) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:    http.StatusServiceUnavailable,
0000000000000000000000000000000000000000;;			Reason:  metav1.StatusReasonServiceUnavailable,
0000000000000000000000000000000000000000;;			Message: reason,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMethodNotSupported returns an error indicating the requested action is not supported on this kind.
0000000000000000000000000000000000000000;;	func NewMethodNotSupported(qualifiedResource schema.GroupResource, action string) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:   http.StatusMethodNotAllowed,
0000000000000000000000000000000000000000;;			Reason: metav1.StatusReasonMethodNotAllowed,
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Group: qualifiedResource.Group,
0000000000000000000000000000000000000000;;				Kind:  qualifiedResource.Resource,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Message: fmt.Sprintf("%s is not supported on resources of kind %q", action, qualifiedResource.String()),
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServerTimeout returns an error indicating the requested action could not be completed due to a
0000000000000000000000000000000000000000;;	// transient error, and the client should try again.
0000000000000000000000000000000000000000;;	func NewServerTimeout(qualifiedResource schema.GroupResource, operation string, retryAfterSeconds int) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:   http.StatusInternalServerError,
0000000000000000000000000000000000000000;;			Reason: metav1.StatusReasonServerTimeout,
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Group:             qualifiedResource.Group,
0000000000000000000000000000000000000000;;				Kind:              qualifiedResource.Resource,
0000000000000000000000000000000000000000;;				Name:              operation,
0000000000000000000000000000000000000000;;				RetryAfterSeconds: int32(retryAfterSeconds),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Message: fmt.Sprintf("The %s operation against %s could not be completed at this time, please try again.", operation, qualifiedResource.String()),
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServerTimeoutForKind should not exist.  Server timeouts happen when accessing resources, the Kind is just what we
0000000000000000000000000000000000000000;;	// happened to be looking at when the request failed.  This delegates to keep code sane, but we should work towards removing this.
0000000000000000000000000000000000000000;;	func NewServerTimeoutForKind(qualifiedKind schema.GroupKind, operation string, retryAfterSeconds int) *StatusError {
0000000000000000000000000000000000000000;;		return NewServerTimeout(schema.GroupResource{Group: qualifiedKind.Group, Resource: qualifiedKind.Kind}, operation, retryAfterSeconds)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInternalError returns an error indicating the item is invalid and cannot be processed.
0000000000000000000000000000000000000000;;	func NewInternalError(err error) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:   http.StatusInternalServerError,
0000000000000000000000000000000000000000;;			Reason: metav1.StatusReasonInternalError,
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Causes: []metav1.StatusCause{{Message: err.Error()}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Message: fmt.Sprintf("Internal error occurred: %v", err),
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTimeoutError returns an error indicating that a timeout occurred before the request
0000000000000000000000000000000000000000;;	// could be completed.  Clients may retry, but the operation may still complete.
0000000000000000000000000000000000000000;;	func NewTimeoutError(message string, retryAfterSeconds int) *StatusError {
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status:  metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:    StatusServerTimeout,
0000000000000000000000000000000000000000;;			Reason:  metav1.StatusReasonTimeout,
0000000000000000000000000000000000000000;;			Message: fmt.Sprintf("Timeout: %s", message),
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				RetryAfterSeconds: int32(retryAfterSeconds),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGenericServerResponse returns a new error for server responses that are not in a recognizable form.
0000000000000000000000000000000000000000;;	func NewGenericServerResponse(code int, verb string, qualifiedResource schema.GroupResource, name, serverMessage string, retryAfterSeconds int, isUnexpectedResponse bool) *StatusError {
0000000000000000000000000000000000000000;;		reason := metav1.StatusReasonUnknown
0000000000000000000000000000000000000000;;		message := fmt.Sprintf("the server responded with the status code %d but did not return more information", code)
0000000000000000000000000000000000000000;;		switch code {
0000000000000000000000000000000000000000;;		case http.StatusConflict:
0000000000000000000000000000000000000000;;			if verb == "POST" {
0000000000000000000000000000000000000000;;				reason = metav1.StatusReasonAlreadyExists
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				reason = metav1.StatusReasonConflict
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = "the server reported a conflict"
0000000000000000000000000000000000000000;;		case http.StatusNotFound:
0000000000000000000000000000000000000000;;			reason = metav1.StatusReasonNotFound
0000000000000000000000000000000000000000;;			message = "the server could not find the requested resource"
0000000000000000000000000000000000000000;;		case http.StatusBadRequest:
0000000000000000000000000000000000000000;;			reason = metav1.StatusReasonBadRequest
0000000000000000000000000000000000000000;;			message = "the server rejected our request for an unknown reason"
0000000000000000000000000000000000000000;;		case http.StatusUnauthorized:
0000000000000000000000000000000000000000;;			reason = metav1.StatusReasonUnauthorized
0000000000000000000000000000000000000000;;			message = "the server has asked for the client to provide credentials"
0000000000000000000000000000000000000000;;		case http.StatusForbidden:
0000000000000000000000000000000000000000;;			reason = metav1.StatusReasonForbidden
0000000000000000000000000000000000000000;;			// the server message has details about who is trying to perform what action.  Keep its message.
0000000000000000000000000000000000000000;;			message = serverMessage
0000000000000000000000000000000000000000;;		case http.StatusMethodNotAllowed:
0000000000000000000000000000000000000000;;			reason = metav1.StatusReasonMethodNotAllowed
0000000000000000000000000000000000000000;;			message = "the server does not allow this method on the requested resource"
0000000000000000000000000000000000000000;;		case StatusUnprocessableEntity:
0000000000000000000000000000000000000000;;			reason = metav1.StatusReasonInvalid
0000000000000000000000000000000000000000;;			message = "the server rejected our request due to an error in our request"
0000000000000000000000000000000000000000;;		case StatusServerTimeout:
0000000000000000000000000000000000000000;;			reason = metav1.StatusReasonServerTimeout
0000000000000000000000000000000000000000;;			message = "the server cannot complete the requested operation at this time, try again later"
0000000000000000000000000000000000000000;;		case StatusTooManyRequests:
0000000000000000000000000000000000000000;;			reason = metav1.StatusReasonTimeout
0000000000000000000000000000000000000000;;			message = "the server has received too many requests and has asked us to try again later"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if code >= 500 {
0000000000000000000000000000000000000000;;				reason = metav1.StatusReasonInternalError
0000000000000000000000000000000000000000;;				message = fmt.Sprintf("an error on the server (%q) has prevented the request from succeeding", serverMessage)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case !qualifiedResource.Empty() && len(name) > 0:
0000000000000000000000000000000000000000;;			message = fmt.Sprintf("%s (%s %s %s)", message, strings.ToLower(verb), qualifiedResource.String(), name)
0000000000000000000000000000000000000000;;		case !qualifiedResource.Empty():
0000000000000000000000000000000000000000;;			message = fmt.Sprintf("%s (%s %s)", message, strings.ToLower(verb), qualifiedResource.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var causes []metav1.StatusCause
0000000000000000000000000000000000000000;;		if isUnexpectedResponse {
0000000000000000000000000000000000000000;;			causes = []metav1.StatusCause{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Type:    metav1.CauseTypeUnexpectedServerResponse,
0000000000000000000000000000000000000000;;					Message: serverMessage,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			causes = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &StatusError{metav1.Status{
0000000000000000000000000000000000000000;;			Status: metav1.StatusFailure,
0000000000000000000000000000000000000000;;			Code:   int32(code),
0000000000000000000000000000000000000000;;			Reason: reason,
0000000000000000000000000000000000000000;;			Details: &metav1.StatusDetails{
0000000000000000000000000000000000000000;;				Group: qualifiedResource.Group,
0000000000000000000000000000000000000000;;				Kind:  qualifiedResource.Resource,
0000000000000000000000000000000000000000;;				Name:  name,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Causes:            causes,
0000000000000000000000000000000000000000;;				RetryAfterSeconds: int32(retryAfterSeconds),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Message: message,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNotFound returns true if the specified error was created by NewNotFound.
0000000000000000000000000000000000000000;;	func IsNotFound(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonNotFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAlreadyExists determines if the err is an error which indicates that a specified resource already exists.
0000000000000000000000000000000000000000;;	func IsAlreadyExists(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonAlreadyExists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsConflict determines if the err is an error which indicates the provided update conflicts.
0000000000000000000000000000000000000000;;	func IsConflict(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonConflict
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInvalid determines if the err is an error which indicates the provided resource is not valid.
0000000000000000000000000000000000000000;;	func IsInvalid(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonInvalid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsMethodNotSupported determines if the err is an error which indicates the provided action could not
0000000000000000000000000000000000000000;;	// be performed because it is not supported by the server.
0000000000000000000000000000000000000000;;	func IsMethodNotSupported(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonMethodNotAllowed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsBadRequest determines if err is an error which indicates that the request is invalid.
0000000000000000000000000000000000000000;;	func IsBadRequest(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonBadRequest
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUnauthorized determines if err is an error which indicates that the request is unauthorized and
0000000000000000000000000000000000000000;;	// requires authentication by the user.
0000000000000000000000000000000000000000;;	func IsUnauthorized(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonUnauthorized
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsForbidden determines if err is an error which indicates that the request is forbidden and cannot
0000000000000000000000000000000000000000;;	// be completed as requested.
0000000000000000000000000000000000000000;;	func IsForbidden(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonForbidden
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsTimeout determines if err is an error which indicates that request times out due to long
0000000000000000000000000000000000000000;;	// processing.
0000000000000000000000000000000000000000;;	func IsTimeout(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsServerTimeout determines if err is an error which indicates that the request needs to be retried
0000000000000000000000000000000000000000;;	// by the client.
0000000000000000000000000000000000000000;;	func IsServerTimeout(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonServerTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInternalError determines if err is an error which indicates an internal server error.
0000000000000000000000000000000000000000;;	func IsInternalError(err error) bool {
0000000000000000000000000000000000000000;;		return reasonForError(err) == metav1.StatusReasonInternalError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsTooManyRequests determines if err is an error which indicates that there are too many requests
0000000000000000000000000000000000000000;;	// that the server cannot handle.
0000000000000000000000000000000000000000;;	// TODO: update IsTooManyRequests() when the TooManyRequests(429) error returned from the API server has a non-empty Reason field
0000000000000000000000000000000000000000;;	func IsTooManyRequests(err error) bool {
0000000000000000000000000000000000000000;;		switch t := err.(type) {
0000000000000000000000000000000000000000;;		case APIStatus:
0000000000000000000000000000000000000000;;			return t.Status().Code == StatusTooManyRequests
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUnexpectedServerError returns true if the server response was not in the expected API format,
0000000000000000000000000000000000000000;;	// and may be the result of another HTTP actor.
0000000000000000000000000000000000000000;;	func IsUnexpectedServerError(err error) bool {
0000000000000000000000000000000000000000;;		switch t := err.(type) {
0000000000000000000000000000000000000000;;		case APIStatus:
0000000000000000000000000000000000000000;;			if d := t.Status().Details; d != nil {
0000000000000000000000000000000000000000;;				for _, cause := range d.Causes {
0000000000000000000000000000000000000000;;					if cause.Type == metav1.CauseTypeUnexpectedServerResponse {
0000000000000000000000000000000000000000;;						return true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUnexpectedObjectError determines if err is due to an unexpected object from the master.
0000000000000000000000000000000000000000;;	func IsUnexpectedObjectError(err error) bool {
0000000000000000000000000000000000000000;;		_, ok := err.(*UnexpectedObjectError)
0000000000000000000000000000000000000000;;		return err != nil && ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SuggestsClientDelay returns true if this error suggests a client delay as well as the
0000000000000000000000000000000000000000;;	// suggested seconds to wait, or false if the error does not imply a wait.
0000000000000000000000000000000000000000;;	func SuggestsClientDelay(err error) (int, bool) {
0000000000000000000000000000000000000000;;		switch t := err.(type) {
0000000000000000000000000000000000000000;;		case APIStatus:
0000000000000000000000000000000000000000;;			if t.Status().Details != nil {
0000000000000000000000000000000000000000;;				switch t.Status().Reason {
0000000000000000000000000000000000000000;;				case metav1.StatusReasonServerTimeout, metav1.StatusReasonTimeout:
0000000000000000000000000000000000000000;;					return int(t.Status().Details.RetryAfterSeconds), true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reasonForError(err error) metav1.StatusReason {
0000000000000000000000000000000000000000;;		switch t := err.(type) {
0000000000000000000000000000000000000000;;		case APIStatus:
0000000000000000000000000000000000000000;;			return t.Status().Reason
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metav1.StatusReasonUnknown
0000000000000000000000000000000000000000;;	}
