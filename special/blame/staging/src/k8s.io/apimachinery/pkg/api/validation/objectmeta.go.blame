0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
c5f9c25a8db30e943c73e90b734a5dad8868cf1e;pkg/api/validation/genericvalidation/validation.go[pkg/api/validation/genericvalidation/validation.go][staging/src/k8s.io/apimachinery/pkg/api/validation/objectmeta.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		v1validation "k8s.io/apimachinery/pkg/apis/meta/v1/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: delete this global variable when we enable the validation of common
0000000000000000000000000000000000000000;;	// fields by default.
0000000000000000000000000000000000000000;;	var RepairMalformedUpdates bool = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const FieldImmutableErrorMsg string = `field is immutable`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const totalAnnotationSizeLimitB int = 256 * (1 << 10) // 256 kB
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BannedOwners is a black list of object that are not allowed to be owners.
0000000000000000000000000000000000000000;;	var BannedOwners = map[schema.GroupVersionKind]struct{}{
0000000000000000000000000000000000000000;;		{Group: "", Version: "v1", Kind: "Event"}: {},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateClusterName can be used to check whether the given cluster name is valid.
0000000000000000000000000000000000000000;;	var ValidateClusterName = NameIsDNS1035Label
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateAnnotations validates that a set of annotations are correctly defined.
0000000000000000000000000000000000000000;;	func ValidateAnnotations(annotations map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		var totalSize int64
0000000000000000000000000000000000000000;;		for k, v := range annotations {
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsQualifiedName(strings.ToLower(k)) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, k, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			totalSize += (int64)(len(k)) + (int64)(len(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if totalSize > (int64)(totalAnnotationSizeLimitB) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.TooLong(fldPath, "", totalAnnotationSizeLimitB))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateOwnerReference(ownerReference metav1.OwnerReference, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		gvk := schema.FromAPIVersionAndKind(ownerReference.APIVersion, ownerReference.Kind)
0000000000000000000000000000000000000000;;		// gvk.Group is empty for the legacy group.
0000000000000000000000000000000000000000;;		if len(gvk.Version) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("apiVersion"), ownerReference.APIVersion, "version must not be empty"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(gvk.Kind) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("kind"), ownerReference.Kind, "kind must not be empty"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ownerReference.Name) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("name"), ownerReference.Name, "name must not be empty"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ownerReference.UID) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("uid"), ownerReference.UID, "uid must not be empty"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := BannedOwners[gvk]; ok {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, ownerReference, fmt.Sprintf("%s is disallowed from being an owner", gvk)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateOwnerReferences(ownerReferences []metav1.OwnerReference, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		controllerName := ""
0000000000000000000000000000000000000000;;		for _, ref := range ownerReferences {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, validateOwnerReference(ref, fldPath)...)
0000000000000000000000000000000000000000;;			if ref.Controller != nil && *ref.Controller {
0000000000000000000000000000000000000000;;				if controllerName != "" {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath, ownerReferences,
0000000000000000000000000000000000000000;;						fmt.Sprintf("Only one reference can have Controller set to true. Found \"true\" in references for %v and %v", controllerName, ref.Name)))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					controllerName = ref.Name
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate finalizer names
0000000000000000000000000000000000000000;;	func ValidateFinalizerName(stringValue string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, msg := range validation.IsQualifiedName(stringValue) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, stringValue, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateNoNewFinalizers(newFinalizers []string, oldFinalizers []string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		extra := sets.NewString(newFinalizers...).Difference(sets.NewString(oldFinalizers...))
0000000000000000000000000000000000000000;;		if len(extra) != 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Forbidden(fldPath, fmt.Sprintf("no new finalizers can be added if the object is being deleted, found new finalizers %#v", extra.List())))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateImmutableField(newVal, oldVal interface{}, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if !apiequality.Semantic.DeepEqual(oldVal, newVal) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, newVal, FieldImmutableErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateObjectMeta validates an object's metadata on creation. It expects that name generation has already
0000000000000000000000000000000000000000;;	// been performed.
0000000000000000000000000000000000000000;;	// It doesn't return an error for rootscoped resources with namespace, because namespace should already be cleared before.
0000000000000000000000000000000000000000;;	func ValidateObjectMeta(objMeta *metav1.ObjectMeta, requiresNamespace bool, nameFn ValidateNameFunc, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		metadata, err := meta.Accessor(objMeta)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, objMeta, err.Error()))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ValidateObjectMetaAccessor(metadata, requiresNamespace, nameFn, fldPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateObjectMeta validates an object's metadata on creation. It expects that name generation has already
0000000000000000000000000000000000000000;;	// been performed.
0000000000000000000000000000000000000000;;	// It doesn't return an error for rootscoped resources with namespace, because namespace should already be cleared before.
0000000000000000000000000000000000000000;;	func ValidateObjectMetaAccessor(meta metav1.Object, requiresNamespace bool, nameFn ValidateNameFunc, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(meta.GetGenerateName()) != 0 {
0000000000000000000000000000000000000000;;			for _, msg := range nameFn(meta.GetGenerateName(), true) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("generateName"), meta.GetGenerateName(), msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the generated name validates, but the calculated value does not, it's a problem with generation, and we
0000000000000000000000000000000000000000;;		// report it here. This may confuse users, but indicates a programming bug and still must be validated.
0000000000000000000000000000000000000000;;		// If there are multiple fields out of which one is required then add an or as a separator
0000000000000000000000000000000000000000;;		if len(meta.GetName()) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Required(fldPath.Child("name"), "name or generateName is required"))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, msg := range nameFn(meta.GetName(), false) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("name"), meta.GetName(), msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if requiresNamespace {
0000000000000000000000000000000000000000;;			if len(meta.GetNamespace()) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath.Child("namespace"), ""))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for _, msg := range ValidateNamespaceName(meta.GetNamespace(), false) {
0000000000000000000000000000000000000000;;					allErrs = append(allErrs, field.Invalid(fldPath.Child("namespace"), meta.GetNamespace(), msg))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if len(meta.GetNamespace()) != 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("namespace"), "not allowed on this type"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(meta.GetClusterName()) != 0 {
0000000000000000000000000000000000000000;;			for _, msg := range ValidateClusterName(meta.GetClusterName(), false) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("clusterName"), meta.GetClusterName(), msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateNonnegativeField(meta.GetGeneration(), fldPath.Child("generation"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, v1validation.ValidateLabels(meta.GetLabels(), fldPath.Child("labels"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateAnnotations(meta.GetAnnotations(), fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateOwnerReferences(meta.GetOwnerReferences(), fldPath.Child("ownerReferences"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateInitializers(meta.GetInitializers(), fldPath.Child("initializers"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateFinalizers(meta.GetFinalizers(), fldPath.Child("finalizers"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateInitializers(initializers *metav1.Initializers, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrs field.ErrorList
0000000000000000000000000000000000000000;;		if initializers == nil {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, initializer := range initializers.Pending {
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsQualifiedName(initializer.Name) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath.Child("pending").Index(i), initializer.Name, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, validateInitializersResult(initializers.Result, fldPath.Child("result"))...)
0000000000000000000000000000000000000000;;		if len(initializers.Pending) == 0 && initializers.Result == nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("pending"), nil, "must be non-empty when result is not set"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateInitializersResult(result *metav1.Status, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrs field.ErrorList
0000000000000000000000000000000000000000;;		if result == nil {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch result.Status {
0000000000000000000000000000000000000000;;		case metav1.StatusFailure:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("status"), result.Status, "must be 'Failure'"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateFinalizers tests if the finalizers name are valid, and if there are conflicting finalizers.
0000000000000000000000000000000000000000;;	func ValidateFinalizers(finalizers []string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		hasFinalizerOrphanDependents := false
0000000000000000000000000000000000000000;;		hasFinalizerDeleteDependents := false
0000000000000000000000000000000000000000;;		for _, finalizer := range finalizers {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateFinalizerName(finalizer, fldPath)...)
0000000000000000000000000000000000000000;;			if finalizer == metav1.FinalizerOrphanDependents {
0000000000000000000000000000000000000000;;				hasFinalizerOrphanDependents = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if finalizer == metav1.FinalizerDeleteDependents {
0000000000000000000000000000000000000000;;				hasFinalizerDeleteDependents = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasFinalizerDeleteDependents && hasFinalizerOrphanDependents {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, finalizers, fmt.Sprintf("finalizer %s and %s cannot be both set", metav1.FinalizerOrphanDependents, metav1.FinalizerDeleteDependents)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateObjectMetaUpdate validates an object's metadata when updated
0000000000000000000000000000000000000000;;	func ValidateObjectMetaUpdate(newMeta, oldMeta *metav1.ObjectMeta, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		newMetadata, err := meta.Accessor(newMeta)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, newMeta, err.Error()))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldMetadata, err := meta.Accessor(oldMeta)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, oldMeta, err.Error()))
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ValidateObjectMetaAccessorUpdate(newMetadata, oldMetadata, fldPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateObjectMetaAccessorUpdate(newMeta, oldMeta metav1.Object, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrs field.ErrorList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !RepairMalformedUpdates && newMeta.GetUID() != oldMeta.GetUID() {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("uid"), newMeta.GetUID(), "field is immutable"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// in the event it is left empty, set it, to allow clients more flexibility
0000000000000000000000000000000000000000;;		// TODO: remove the following code that repairs the update request when we retire the clients that modify the immutable fields.
0000000000000000000000000000000000000000;;		// Please do not copy this pattern elsewhere; validation functions should not be modifying the objects they are passed!
0000000000000000000000000000000000000000;;		if RepairMalformedUpdates {
0000000000000000000000000000000000000000;;			if len(newMeta.GetUID()) == 0 {
0000000000000000000000000000000000000000;;				newMeta.SetUID(oldMeta.GetUID())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// ignore changes to timestamp
0000000000000000000000000000000000000000;;			if oldCreationTime := oldMeta.GetCreationTimestamp(); oldCreationTime.IsZero() {
0000000000000000000000000000000000000000;;				oldMeta.SetCreationTimestamp(newMeta.GetCreationTimestamp())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				newMeta.SetCreationTimestamp(oldMeta.GetCreationTimestamp())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// an object can never remove a deletion timestamp or clear/change grace period seconds
0000000000000000000000000000000000000000;;			if !oldMeta.GetDeletionTimestamp().IsZero() {
0000000000000000000000000000000000000000;;				newMeta.SetDeletionTimestamp(oldMeta.GetDeletionTimestamp())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if oldMeta.GetDeletionGracePeriodSeconds() != nil && newMeta.GetDeletionGracePeriodSeconds() == nil {
0000000000000000000000000000000000000000;;				newMeta.SetDeletionGracePeriodSeconds(oldMeta.GetDeletionGracePeriodSeconds())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: needs to check if newMeta==nil && oldMeta !=nil after the repair logic is removed.
0000000000000000000000000000000000000000;;		if newMeta.GetDeletionGracePeriodSeconds() != nil && (oldMeta.GetDeletionGracePeriodSeconds() == nil || *newMeta.GetDeletionGracePeriodSeconds() != *oldMeta.GetDeletionGracePeriodSeconds()) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("deletionGracePeriodSeconds"), newMeta.GetDeletionGracePeriodSeconds(), "field is immutable; may only be changed via deletion"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if newMeta.GetDeletionTimestamp() != nil && (oldMeta.GetDeletionTimestamp() == nil || !newMeta.GetDeletionTimestamp().Equal(*oldMeta.GetDeletionTimestamp())) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("deletionTimestamp"), newMeta.GetDeletionTimestamp(), "field is immutable; may only be changed via deletion"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finalizers cannot be added if the object is already being deleted.
0000000000000000000000000000000000000000;;		if oldMeta.GetDeletionTimestamp() != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateNoNewFinalizers(newMeta.GetFinalizers(), oldMeta.GetFinalizers(), fldPath.Child("finalizers"))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reject updates that don't specify a resource version
0000000000000000000000000000000000000000;;		if len(newMeta.GetResourceVersion()) == 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("resourceVersion"), newMeta.GetResourceVersion(), "must be specified for an update"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generation shouldn't be decremented
0000000000000000000000000000000000000000;;		if newMeta.GetGeneration() < oldMeta.GetGeneration() {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("generation"), newMeta.GetGeneration(), "must not be decremented"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateInitializersUpdate(newMeta.GetInitializers(), oldMeta.GetInitializers(), fldPath.Child("initializers"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateImmutableField(newMeta.GetName(), oldMeta.GetName(), fldPath.Child("name"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateImmutableField(newMeta.GetNamespace(), oldMeta.GetNamespace(), fldPath.Child("namespace"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateImmutableField(newMeta.GetUID(), oldMeta.GetUID(), fldPath.Child("uid"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateImmutableField(newMeta.GetCreationTimestamp(), oldMeta.GetCreationTimestamp(), fldPath.Child("creationTimestamp"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateImmutableField(newMeta.GetClusterName(), oldMeta.GetClusterName(), fldPath.Child("clusterName"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, v1validation.ValidateLabels(newMeta.GetLabels(), fldPath.Child("labels"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateAnnotations(newMeta.GetAnnotations(), fldPath.Child("annotations"))...)
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateOwnerReferences(newMeta.GetOwnerReferences(), fldPath.Child("ownerReferences"))...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateInitializersUpdate checks the update of the metadata initializers field
0000000000000000000000000000000000000000;;	func ValidateInitializersUpdate(newInit, oldInit *metav1.Initializers, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		var allErrs field.ErrorList
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case oldInit == nil && newInit != nil:
0000000000000000000000000000000000000000;;			// Initializers may not be set on new objects
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, nil, "field is immutable once initialization has completed"))
0000000000000000000000000000000000000000;;		case oldInit != nil && newInit == nil:
0000000000000000000000000000000000000000;;			// this is a valid transition and means initialization was successful
0000000000000000000000000000000000000000;;		case oldInit != nil && newInit != nil:
0000000000000000000000000000000000000000;;			// validate changes to initializers
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case oldInit.Result == nil && newInit.Result != nil:
0000000000000000000000000000000000000000;;				// setting a result is allowed
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, validateInitializersResult(newInit.Result, fldPath.Child("result"))...)
0000000000000000000000000000000000000000;;			case oldInit.Result != nil:
0000000000000000000000000000000000000000;;				// setting Result implies permanent failure, and all future updates will be prevented
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, ValidateImmutableField(newInit.Result, oldInit.Result, fldPath.Child("result"))...)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// leaving the result nil is allowed
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
