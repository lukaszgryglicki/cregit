0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package meta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MultiRESTMapper is a wrapper for multiple RESTMappers.
0000000000000000000000000000000000000000;;	type MultiRESTMapper []RESTMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m MultiRESTMapper) String() string {
0000000000000000000000000000000000000000;;		nested := []string{}
0000000000000000000000000000000000000000;;		for _, t := range m {
0000000000000000000000000000000000000000;;			currString := fmt.Sprintf("%v", t)
0000000000000000000000000000000000000000;;			splitStrings := strings.Split(currString, "\n")
0000000000000000000000000000000000000000;;			nested = append(nested, strings.Join(splitStrings, "\n\t"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("MultiRESTMapper{\n\t%s\n}", strings.Join(nested, "\n\t"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceSingularizer converts a REST resource name from plural to singular (e.g., from pods to pod)
0000000000000000000000000000000000000000;;	// This implementation supports multiple REST schemas and return the first match.
0000000000000000000000000000000000000000;;	func (m MultiRESTMapper) ResourceSingularizer(resource string) (singular string, err error) {
0000000000000000000000000000000000000000;;		for _, t := range m {
0000000000000000000000000000000000000000;;			singular, err = t.ResourceSingularizer(resource)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m MultiRESTMapper) ResourcesFor(resource schema.GroupVersionResource) ([]schema.GroupVersionResource, error) {
0000000000000000000000000000000000000000;;		allGVRs := []schema.GroupVersionResource{}
0000000000000000000000000000000000000000;;		for _, t := range m {
0000000000000000000000000000000000000000;;			gvrs, err := t.ResourcesFor(resource)
0000000000000000000000000000000000000000;;			// ignore "no match" errors, but any other error percolates back up
0000000000000000000000000000000000000000;;			if IsNoMatchError(err) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// walk the existing values to de-dup
0000000000000000000000000000000000000000;;			for _, curr := range gvrs {
0000000000000000000000000000000000000000;;				found := false
0000000000000000000000000000000000000000;;				for _, existing := range allGVRs {
0000000000000000000000000000000000000000;;					if curr == existing {
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					allGVRs = append(allGVRs, curr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(allGVRs) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NoResourceMatchError{PartialResource: resource}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allGVRs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m MultiRESTMapper) KindsFor(resource schema.GroupVersionResource) (gvk []schema.GroupVersionKind, err error) {
0000000000000000000000000000000000000000;;		allGVKs := []schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;		for _, t := range m {
0000000000000000000000000000000000000000;;			gvks, err := t.KindsFor(resource)
0000000000000000000000000000000000000000;;			// ignore "no match" errors, but any other error percolates back up
0000000000000000000000000000000000000000;;			if IsNoMatchError(err) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// walk the existing values to de-dup
0000000000000000000000000000000000000000;;			for _, curr := range gvks {
0000000000000000000000000000000000000000;;				found := false
0000000000000000000000000000000000000000;;				for _, existing := range allGVKs {
0000000000000000000000000000000000000000;;					if curr == existing {
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					allGVKs = append(allGVKs, curr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(allGVKs) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NoResourceMatchError{PartialResource: resource}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return allGVKs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m MultiRESTMapper) ResourceFor(resource schema.GroupVersionResource) (schema.GroupVersionResource, error) {
0000000000000000000000000000000000000000;;		resources, err := m.ResourcesFor(resource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionResource{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(resources) == 1 {
0000000000000000000000000000000000000000;;			return resources[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schema.GroupVersionResource{}, &AmbiguousResourceError{PartialResource: resource, MatchingResources: resources}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m MultiRESTMapper) KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		kinds, err := m.KindsFor(resource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionKind{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(kinds) == 1 {
0000000000000000000000000000000000000000;;			return kinds[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schema.GroupVersionKind{}, &AmbiguousResourceError{PartialResource: resource, MatchingKinds: kinds}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTMapping provides the REST mapping for the resource based on the
0000000000000000000000000000000000000000;;	// kind and version. This implementation supports multiple REST schemas and
0000000000000000000000000000000000000000;;	// return the first match.
0000000000000000000000000000000000000000;;	func (m MultiRESTMapper) RESTMapping(gk schema.GroupKind, versions ...string) (*RESTMapping, error) {
0000000000000000000000000000000000000000;;		allMappings := []*RESTMapping{}
0000000000000000000000000000000000000000;;		errors := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, t := range m {
0000000000000000000000000000000000000000;;			currMapping, err := t.RESTMapping(gk, versions...)
0000000000000000000000000000000000000000;;			// ignore "no match" errors, but any other error percolates back up
0000000000000000000000000000000000000000;;			if IsNoMatchError(err) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			allMappings = append(allMappings, currMapping)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we got exactly one mapping, then use it even if other requested failed
0000000000000000000000000000000000000000;;		if len(allMappings) == 1 {
0000000000000000000000000000000000000000;;			return allMappings[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allMappings) > 1 {
0000000000000000000000000000000000000000;;			var kinds []schema.GroupVersionKind
0000000000000000000000000000000000000000;;			for _, m := range allMappings {
0000000000000000000000000000000000000000;;				kinds = append(kinds, m.GroupVersionKind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, &AmbiguousKindError{PartialKind: gk.WithVersion(""), MatchingKinds: kinds}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errors) > 0 {
0000000000000000000000000000000000000000;;			return nil, utilerrors.NewAggregate(errors)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, &NoKindMatchError{PartialKind: gk.WithVersion("")}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTMappings returns all possible RESTMappings for the provided group kind, or an error
0000000000000000000000000000000000000000;;	// if the type is not recognized.
0000000000000000000000000000000000000000;;	func (m MultiRESTMapper) RESTMappings(gk schema.GroupKind, versions ...string) ([]*RESTMapping, error) {
0000000000000000000000000000000000000000;;		var allMappings []*RESTMapping
0000000000000000000000000000000000000000;;		var errors []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, t := range m {
0000000000000000000000000000000000000000;;			currMappings, err := t.RESTMappings(gk, versions...)
0000000000000000000000000000000000000000;;			// ignore "no match" errors, but any other error percolates back up
0000000000000000000000000000000000000000;;			if IsNoMatchError(err) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errors = append(errors, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allMappings = append(allMappings, currMappings...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errors) > 0 {
0000000000000000000000000000000000000000;;			return nil, utilerrors.NewAggregate(errors)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allMappings) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NoKindMatchError{PartialKind: gk.WithVersion("")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allMappings, nil
0000000000000000000000000000000000000000;;	}
