0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package meta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultiRESTMapperResourceFor(t *testing.T) {
0000000000000000000000000000000000000000;;		tcs := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapper MultiRESTMapper
0000000000000000000000000000000000000000;;			input  schema.GroupVersionResource
0000000000000000000000000000000000000000;;			result schema.GroupVersionResource
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "empty",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionResource{},
0000000000000000000000000000000000000000;;				err:    &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "ignore not found",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{err: &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "IGNORE_THIS"}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionResource{},
0000000000000000000000000000000000000000;;				err:    &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "accept first failure",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{err: errors.New("fail on this")}, fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{{Resource: "unused"}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionResource{},
0000000000000000000000000000000000000000;;				err:    errors.New("fail on this"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tcs {
0000000000000000000000000000000000000000;;			actualResult, actualErr := tc.mapper.ResourceFor(tc.input)
0000000000000000000000000000000000000000;;			if e, a := tc.result, actualResult; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case tc.err == nil && actualErr == nil:
0000000000000000000000000000000000000000;;			case tc.err == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", tc.name, actualErr)
0000000000000000000000000000000000000000;;			case actualErr == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected error: %v got nil", tc.name, tc.err)
0000000000000000000000000000000000000000;;			case tc.err.Error() != actualErr.Error():
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, tc.err, actualErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultiRESTMapperResourcesFor(t *testing.T) {
0000000000000000000000000000000000000000;;		tcs := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapper MultiRESTMapper
0000000000000000000000000000000000000000;;			input  schema.GroupVersionResource
0000000000000000000000000000000000000000;;			result []schema.GroupVersionResource
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "empty",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: nil,
0000000000000000000000000000000000000000;;				err:    &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "ignore not found",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{err: &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "IGNORE_THIS"}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: nil,
0000000000000000000000000000000000000000;;				err:    &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "accept first failure",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{err: errors.New("fail on this")}, fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{{Resource: "unused"}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: nil,
0000000000000000000000000000000000000000;;				err:    errors.New("fail on this"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "union and dedup",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{
0000000000000000000000000000000000000000;;					fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{{Resource: "dupe"}, {Resource: "first"}}},
0000000000000000000000000000000000000000;;					fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{{Resource: "dupe"}, {Resource: "second"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: []schema.GroupVersionResource{{Resource: "dupe"}, {Resource: "first"}, {Resource: "second"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "skip not and continue",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{
0000000000000000000000000000000000000000;;					fixedRESTMapper{err: &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "IGNORE_THIS"}}},
0000000000000000000000000000000000000000;;					fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{{Resource: "first"}, {Resource: "second"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: []schema.GroupVersionResource{{Resource: "first"}, {Resource: "second"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tcs {
0000000000000000000000000000000000000000;;			actualResult, actualErr := tc.mapper.ResourcesFor(tc.input)
0000000000000000000000000000000000000000;;			if e, a := tc.result, actualResult; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case tc.err == nil && actualErr == nil:
0000000000000000000000000000000000000000;;			case tc.err == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", tc.name, actualErr)
0000000000000000000000000000000000000000;;			case actualErr == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected error: %v got nil", tc.name, tc.err)
0000000000000000000000000000000000000000;;			case tc.err.Error() != actualErr.Error():
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, tc.err, actualErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultiRESTMapperKindsFor(t *testing.T) {
0000000000000000000000000000000000000000;;		tcs := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapper MultiRESTMapper
0000000000000000000000000000000000000000;;			input  schema.GroupVersionResource
0000000000000000000000000000000000000000;;			result []schema.GroupVersionKind
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "empty",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: nil,
0000000000000000000000000000000000000000;;				err:    &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "ignore not found",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{err: &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "IGNORE_THIS"}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: nil,
0000000000000000000000000000000000000000;;				err:    &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "accept first failure",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{err: errors.New("fail on this")}, fixedRESTMapper{kindsFor: []schema.GroupVersionKind{{Kind: "unused"}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: nil,
0000000000000000000000000000000000000000;;				err:    errors.New("fail on this"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "union and dedup",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{
0000000000000000000000000000000000000000;;					fixedRESTMapper{kindsFor: []schema.GroupVersionKind{{Kind: "dupe"}, {Kind: "first"}}},
0000000000000000000000000000000000000000;;					fixedRESTMapper{kindsFor: []schema.GroupVersionKind{{Kind: "dupe"}, {Kind: "second"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: []schema.GroupVersionKind{{Kind: "dupe"}, {Kind: "first"}, {Kind: "second"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "skip not and continue",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{
0000000000000000000000000000000000000000;;					fixedRESTMapper{err: &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "IGNORE_THIS"}}},
0000000000000000000000000000000000000000;;					fixedRESTMapper{kindsFor: []schema.GroupVersionKind{{Kind: "first"}, {Kind: "second"}}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: []schema.GroupVersionKind{{Kind: "first"}, {Kind: "second"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tcs {
0000000000000000000000000000000000000000;;			actualResult, actualErr := tc.mapper.KindsFor(tc.input)
0000000000000000000000000000000000000000;;			if e, a := tc.result, actualResult; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case tc.err == nil && actualErr == nil:
0000000000000000000000000000000000000000;;			case tc.err == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", tc.name, actualErr)
0000000000000000000000000000000000000000;;			case actualErr == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected error: %v got nil", tc.name, tc.err)
0000000000000000000000000000000000000000;;			case tc.err.Error() != actualErr.Error():
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, tc.err, actualErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultiRESTMapperKindFor(t *testing.T) {
0000000000000000000000000000000000000000;;		tcs := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapper MultiRESTMapper
0000000000000000000000000000000000000000;;			input  schema.GroupVersionResource
0000000000000000000000000000000000000000;;			result schema.GroupVersionKind
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "empty",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionKind{},
0000000000000000000000000000000000000000;;				err:    &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "ignore not found",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{err: &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "IGNORE_THIS"}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionKind{},
0000000000000000000000000000000000000000;;				err:    &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Resource: "foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "accept first failure",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{err: errors.New("fail on this")}, fixedRESTMapper{kindsFor: []schema.GroupVersionKind{{Kind: "unused"}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupVersionResource{Resource: "foo"},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionKind{},
0000000000000000000000000000000000000000;;				err:    errors.New("fail on this"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tcs {
0000000000000000000000000000000000000000;;			actualResult, actualErr := tc.mapper.KindFor(tc.input)
0000000000000000000000000000000000000000;;			if e, a := tc.result, actualResult; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case tc.err == nil && actualErr == nil:
0000000000000000000000000000000000000000;;			case tc.err == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", tc.name, actualErr)
0000000000000000000000000000000000000000;;			case actualErr == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected error: %v got nil", tc.name, tc.err)
0000000000000000000000000000000000000000;;			case tc.err.Error() != actualErr.Error():
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, tc.err, actualErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultiRESTMapperRESTMappings(t *testing.T) {
0000000000000000000000000000000000000000;;		mapping1, mapping2 := &RESTMapping{}, &RESTMapping{}
0000000000000000000000000000000000000000;;		tcs := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapper MultiRESTMapper
0000000000000000000000000000000000000000;;			input  schema.GroupKind
0000000000000000000000000000000000000000;;			result []*RESTMapping
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "empty",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{},
0000000000000000000000000000000000000000;;				input:  schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				result: nil,
0000000000000000000000000000000000000000;;				err:    &NoKindMatchError{PartialKind: schema.GroupVersionKind{Kind: "Foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "ignore not found",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{err: &NoKindMatchError{PartialKind: schema.GroupVersionKind{Kind: "IGNORE_THIS"}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				result: nil,
0000000000000000000000000000000000000000;;				err:    &NoKindMatchError{PartialKind: schema.GroupVersionKind{Kind: "Foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "accept first failure",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{err: errors.New("fail on this")}, fixedRESTMapper{mappings: []*RESTMapping{mapping1}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				result: nil,
0000000000000000000000000000000000000000;;				err:    errors.New("fail on this"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "return both",
0000000000000000000000000000000000000000;;				mapper: MultiRESTMapper{fixedRESTMapper{mappings: []*RESTMapping{mapping1}}, fixedRESTMapper{mappings: []*RESTMapping{mapping2}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				result: []*RESTMapping{mapping1, mapping2},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tcs {
0000000000000000000000000000000000000000;;			actualResult, actualErr := tc.mapper.RESTMappings(tc.input)
0000000000000000000000000000000000000000;;			if e, a := tc.result, actualResult; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case tc.err == nil && actualErr == nil:
0000000000000000000000000000000000000000;;			case tc.err == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", tc.name, actualErr)
0000000000000000000000000000000000000000;;			case actualErr == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected error: %v got nil", tc.name, tc.err)
0000000000000000000000000000000000000000;;			case tc.err.Error() != actualErr.Error():
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, tc.err, actualErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fixedRESTMapper struct {
0000000000000000000000000000000000000000;;		resourcesFor []schema.GroupVersionResource
0000000000000000000000000000000000000000;;		kindsFor     []schema.GroupVersionKind
0000000000000000000000000000000000000000;;		resourceFor  schema.GroupVersionResource
0000000000000000000000000000000000000000;;		kindFor      schema.GroupVersionKind
0000000000000000000000000000000000000000;;		mappings     []*RESTMapping
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m fixedRESTMapper) ResourceSingularizer(resource string) (singular string, err error) {
0000000000000000000000000000000000000000;;		return "", m.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m fixedRESTMapper) ResourcesFor(resource schema.GroupVersionResource) ([]schema.GroupVersionResource, error) {
0000000000000000000000000000000000000000;;		return m.resourcesFor, m.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m fixedRESTMapper) KindsFor(resource schema.GroupVersionResource) (gvk []schema.GroupVersionKind, err error) {
0000000000000000000000000000000000000000;;		return m.kindsFor, m.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m fixedRESTMapper) ResourceFor(resource schema.GroupVersionResource) (schema.GroupVersionResource, error) {
0000000000000000000000000000000000000000;;		return m.resourceFor, m.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m fixedRESTMapper) KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		return m.kindFor, m.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m fixedRESTMapper) RESTMapping(gk schema.GroupKind, versions ...string) (mapping *RESTMapping, err error) {
0000000000000000000000000000000000000000;;		return nil, m.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m fixedRESTMapper) RESTMappings(gk schema.GroupKind, versions ...string) (mappings []*RESTMapping, err error) {
0000000000000000000000000000000000000000;;		return m.mappings, m.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m fixedRESTMapper) ResourceIsValid(resource schema.GroupVersionResource) bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
