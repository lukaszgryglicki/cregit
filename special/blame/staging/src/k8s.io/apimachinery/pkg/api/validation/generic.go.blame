0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
0325f0c0f7a4aa232275a6acdcbc123796a951e2;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const IsNegativeErrorMsg string = `must be greater than or equal to 0`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNameFunc validates that the provided name is valid for a given resource type.
0000000000000000000000000000000000000000;;	// Not all resources have the same validation rules for names. Prefix is true
0000000000000000000000000000000000000000;;	// if the name will have a value appended to it.  If the name is not valid,
0000000000000000000000000000000000000000;;	// this returns a list of descriptions of individual characteristics of the
0000000000000000000000000000000000000000;;	// value that were not valid.  Otherwise this returns an empty list or nil.
0000000000000000000000000000000000000000;;	type ValidateNameFunc func(name string, prefix bool) []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameIsDNSSubdomain is a ValidateNameFunc for names that must be a DNS subdomain.
0000000000000000000000000000000000000000;;	func NameIsDNSSubdomain(name string, prefix bool) []string {
0000000000000000000000000000000000000000;;		if prefix {
0000000000000000000000000000000000000000;;			name = maskTrailingDash(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return validation.IsDNS1123Subdomain(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameIsDNSLabel is a ValidateNameFunc for names that must be a DNS 1123 label.
0000000000000000000000000000000000000000;;	func NameIsDNSLabel(name string, prefix bool) []string {
0000000000000000000000000000000000000000;;		if prefix {
0000000000000000000000000000000000000000;;			name = maskTrailingDash(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return validation.IsDNS1123Label(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameIsDNS1035Label is a ValidateNameFunc for names that must be a DNS 952 label.
0000000000000000000000000000000000000000;;	func NameIsDNS1035Label(name string, prefix bool) []string {
0000000000000000000000000000000000000000;;		if prefix {
0000000000000000000000000000000000000000;;			name = maskTrailingDash(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return validation.IsDNS1035Label(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateNamespaceName can be used to check whether the given namespace name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateNamespaceName = NameIsDNSLabel
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateServiceAccountName can be used to check whether the given service account name is valid.
0000000000000000000000000000000000000000;;	// Prefix indicates this name will be used as part of generation, in which case
0000000000000000000000000000000000000000;;	// trailing dashes are allowed.
0000000000000000000000000000000000000000;;	var ValidateServiceAccountName = NameIsDNSSubdomain
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maskTrailingDash replaces the final character of a string with a subdomain safe
0000000000000000000000000000000000000000;;	// value if is a dash.
0000000000000000000000000000000000000000;;	func maskTrailingDash(name string) string {
0000000000000000000000000000000000000000;;		if strings.HasSuffix(name, "-") {
0000000000000000000000000000000000000000;;			return name[:len(name)-2] + "a"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validates that given value is not negative.
0000000000000000000000000000000000000000;;	func ValidateNonnegativeField(value int64, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if value < 0 {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, value, IsNegativeErrorMsg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
