0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package meta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsListType returns true if the provided Object has a slice called Items
0000000000000000000000000000000000000000;;	func IsListType(obj runtime.Object) bool {
0000000000000000000000000000000000000000;;		// if we're a runtime.Unstructured, check whether this is a list.
0000000000000000000000000000000000000000;;		// TODO: refactor GetItemsPtr to use an interface that returns []runtime.Object
0000000000000000000000000000000000000000;;		if unstructured, ok := obj.(runtime.Unstructured); ok {
0000000000000000000000000000000000000000;;			return unstructured.IsList()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := GetItemsPtr(obj)
0000000000000000000000000000000000000000;;		return err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetItemsPtr returns a pointer to the list object's Items member.
0000000000000000000000000000000000000000;;	// If 'list' doesn't have an Items member, it's not really a list type
0000000000000000000000000000000000000000;;	// and an error will be returned.
0000000000000000000000000000000000000000;;	// This function will either return a pointer to a slice, or an error, but not both.
0000000000000000000000000000000000000000;;	func GetItemsPtr(list runtime.Object) (interface{}, error) {
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(list)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items := v.FieldByName("Items")
0000000000000000000000000000000000000000;;		if !items.IsValid() {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no Items field in %#v", list)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch items.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Interface, reflect.Ptr:
0000000000000000000000000000000000000000;;			target := reflect.TypeOf(items.Interface()).Elem()
0000000000000000000000000000000000000000;;			if target.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("items: Expected slice, got %s", target.Kind())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return items.Interface(), nil
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			return items.Addr().Interface(), nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("items: Expected slice, got %s", items.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EachListItem invokes fn on each runtime.Object in the list. Any error immediately terminates
0000000000000000000000000000000000000000;;	// the loop.
0000000000000000000000000000000000000000;;	func EachListItem(obj runtime.Object, fn func(runtime.Object) error) error {
0000000000000000000000000000000000000000;;		if unstructured, ok := obj.(runtime.Unstructured); ok {
0000000000000000000000000000000000000000;;			return unstructured.EachListItem(fn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Change to an interface call?
0000000000000000000000000000000000000000;;		itemsPtr, err := GetItemsPtr(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items, err := conversion.EnforcePtr(itemsPtr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		len := items.Len()
0000000000000000000000000000000000000000;;		if len == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		takeAddr := false
0000000000000000000000000000000000000000;;		if elemType := items.Type().Elem(); elemType.Kind() != reflect.Ptr && elemType.Kind() != reflect.Interface {
0000000000000000000000000000000000000000;;			if !items.Index(0).CanAddr() {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to take address of items in %T for EachListItem", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			takeAddr = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len; i++ {
0000000000000000000000000000000000000000;;			raw := items.Index(i)
0000000000000000000000000000000000000000;;			if takeAddr {
0000000000000000000000000000000000000000;;				raw = raw.Addr()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch item := raw.Interface().(type) {
0000000000000000000000000000000000000000;;			case *runtime.RawExtension:
0000000000000000000000000000000000000000;;				if err := fn(item.Object); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case runtime.Object:
0000000000000000000000000000000000000000;;				if err := fn(item); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				obj, ok := item.(runtime.Object)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return fmt.Errorf("%v: item[%v]: Expected object, got %#v(%s)", obj, i, raw.Interface(), raw.Kind())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := fn(obj); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractList returns obj's Items element as an array of runtime.Objects.
0000000000000000000000000000000000000000;;	// Returns an error if obj is not a List type (does not have an Items member).
0000000000000000000000000000000000000000;;	func ExtractList(obj runtime.Object) ([]runtime.Object, error) {
0000000000000000000000000000000000000000;;		itemsPtr, err := GetItemsPtr(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items, err := conversion.EnforcePtr(itemsPtr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list := make([]runtime.Object, items.Len())
0000000000000000000000000000000000000000;;		for i := range list {
0000000000000000000000000000000000000000;;			raw := items.Index(i)
0000000000000000000000000000000000000000;;			switch item := raw.Interface().(type) {
0000000000000000000000000000000000000000;;			case runtime.RawExtension:
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case item.Object != nil:
0000000000000000000000000000000000000000;;					list[i] = item.Object
0000000000000000000000000000000000000000;;				case item.Raw != nil:
0000000000000000000000000000000000000000;;					// TODO: Set ContentEncoding and ContentType correctly.
0000000000000000000000000000000000000000;;					list[i] = &runtime.Unknown{Raw: item.Raw}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					list[i] = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case runtime.Object:
0000000000000000000000000000000000000000;;				list[i] = item
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				var found bool
0000000000000000000000000000000000000000;;				if list[i], found = raw.Addr().Interface().(runtime.Object); !found {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("%v: item[%v]: Expected object, got %#v(%s)", obj, i, raw.Interface(), raw.Kind())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectSliceType is the type of a slice of Objects
0000000000000000000000000000000000000000;;	var objectSliceType = reflect.TypeOf([]runtime.Object{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetList sets the given list object's Items member have the elements given in
0000000000000000000000000000000000000000;;	// objects.
0000000000000000000000000000000000000000;;	// Returns an error if list is not a List type (does not have an Items member),
0000000000000000000000000000000000000000;;	// or if any of the objects are not of the right type.
0000000000000000000000000000000000000000;;	func SetList(list runtime.Object, objects []runtime.Object) error {
0000000000000000000000000000000000000000;;		itemsPtr, err := GetItemsPtr(list)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items, err := conversion.EnforcePtr(itemsPtr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if items.Type() == objectSliceType {
0000000000000000000000000000000000000000;;			items.Set(reflect.ValueOf(objects))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		slice := reflect.MakeSlice(items.Type(), len(objects), len(objects))
0000000000000000000000000000000000000000;;		for i := range objects {
0000000000000000000000000000000000000000;;			dest := slice.Index(i)
0000000000000000000000000000000000000000;;			if dest.Type() == reflect.TypeOf(runtime.RawExtension{}) {
0000000000000000000000000000000000000000;;				dest = dest.FieldByName("Object")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check to see if you're directly assignable
0000000000000000000000000000000000000000;;			if reflect.TypeOf(objects[i]).AssignableTo(dest.Type()) {
0000000000000000000000000000000000000000;;				dest.Set(reflect.ValueOf(objects[i]))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			src, err := conversion.EnforcePtr(objects[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if src.Type().AssignableTo(dest.Type()) {
0000000000000000000000000000000000000000;;				dest.Set(src)
0000000000000000000000000000000000000000;;			} else if src.Type().ConvertibleTo(dest.Type()) {
0000000000000000000000000000000000000000;;				dest.Set(src.Convert(dest.Type()))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("item[%d]: can't assign or convert %v into %v", i, src.Type(), dest.Type())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items.Set(slice)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
