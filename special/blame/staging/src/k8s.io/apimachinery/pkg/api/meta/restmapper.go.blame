0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: move everything in this file to pkg/api/rest
0000000000000000000000000000000000000000;;	package meta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements RESTScope interface
0000000000000000000000000000000000000000;;	type restScope struct {
0000000000000000000000000000000000000000;;		name             RESTScopeName
0000000000000000000000000000000000000000;;		paramName        string
0000000000000000000000000000000000000000;;		argumentName     string
0000000000000000000000000000000000000000;;		paramDescription string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *restScope) Name() RESTScopeName {
0000000000000000000000000000000000000000;;		return r.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *restScope) ParamName() string {
0000000000000000000000000000000000000000;;		return r.paramName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *restScope) ArgumentName() string {
0000000000000000000000000000000000000000;;		return r.argumentName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *restScope) ParamDescription() string {
0000000000000000000000000000000000000000;;		return r.paramDescription
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var RESTScopeNamespace = &restScope{
0000000000000000000000000000000000000000;;		name:             RESTScopeNameNamespace,
0000000000000000000000000000000000000000;;		paramName:        "namespaces",
0000000000000000000000000000000000000000;;		argumentName:     "namespace",
0000000000000000000000000000000000000000;;		paramDescription: "object name and auth scope, such as for teams and projects",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var RESTScopeRoot = &restScope{
0000000000000000000000000000000000000000;;		name: RESTScopeNameRoot,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultRESTMapper exposes mappings between the types defined in a
0000000000000000000000000000000000000000;;	// runtime.Scheme. It assumes that all types defined the provided scheme
0000000000000000000000000000000000000000;;	// can be mapped with the provided MetadataAccessor and Codec interfaces.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The resource name of a Kind is defined as the lowercase,
0000000000000000000000000000000000000000;;	// English-plural version of the Kind string.
0000000000000000000000000000000000000000;;	// When converting from resource to Kind, the singular version of the
0000000000000000000000000000000000000000;;	// resource name is also accepted for convenience.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: Only accept plural for some operations for increased control?
0000000000000000000000000000000000000000;;	// (`get pod bar` vs `get pods bar`)
0000000000000000000000000000000000000000;;	type DefaultRESTMapper struct {
0000000000000000000000000000000000000000;;		defaultGroupVersions []schema.GroupVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceToKind       map[schema.GroupVersionResource]schema.GroupVersionKind
0000000000000000000000000000000000000000;;		kindToPluralResource map[schema.GroupVersionKind]schema.GroupVersionResource
0000000000000000000000000000000000000000;;		kindToScope          map[schema.GroupVersionKind]RESTScope
0000000000000000000000000000000000000000;;		singularToPlural     map[schema.GroupVersionResource]schema.GroupVersionResource
0000000000000000000000000000000000000000;;		pluralToSingular     map[schema.GroupVersionResource]schema.GroupVersionResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		interfacesFunc VersionInterfacesFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *DefaultRESTMapper) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("DefaultRESTMapper{kindToPluralResource=%v}", m.kindToPluralResource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ RESTMapper = &DefaultRESTMapper{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VersionInterfacesFunc returns the appropriate typer, and metadata accessor for a
0000000000000000000000000000000000000000;;	// given api version, or an error if no such api version exists.
0000000000000000000000000000000000000000;;	type VersionInterfacesFunc func(version schema.GroupVersion) (*VersionInterfaces, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultRESTMapper initializes a mapping between Kind and APIVersion
0000000000000000000000000000000000000000;;	// to a resource name and back based on the objects in a runtime.Scheme
0000000000000000000000000000000000000000;;	// and the Kubernetes API conventions. Takes a group name, a priority list of the versions
0000000000000000000000000000000000000000;;	// to search when an object has no default version (set empty to return an error),
0000000000000000000000000000000000000000;;	// and a function that retrieves the correct metadata for a given version.
0000000000000000000000000000000000000000;;	func NewDefaultRESTMapper(defaultGroupVersions []schema.GroupVersion, f VersionInterfacesFunc) *DefaultRESTMapper {
0000000000000000000000000000000000000000;;		resourceToKind := make(map[schema.GroupVersionResource]schema.GroupVersionKind)
0000000000000000000000000000000000000000;;		kindToPluralResource := make(map[schema.GroupVersionKind]schema.GroupVersionResource)
0000000000000000000000000000000000000000;;		kindToScope := make(map[schema.GroupVersionKind]RESTScope)
0000000000000000000000000000000000000000;;		singularToPlural := make(map[schema.GroupVersionResource]schema.GroupVersionResource)
0000000000000000000000000000000000000000;;		pluralToSingular := make(map[schema.GroupVersionResource]schema.GroupVersionResource)
0000000000000000000000000000000000000000;;		// TODO: verify name mappings work correctly when versions differ
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &DefaultRESTMapper{
0000000000000000000000000000000000000000;;			resourceToKind:       resourceToKind,
0000000000000000000000000000000000000000;;			kindToPluralResource: kindToPluralResource,
0000000000000000000000000000000000000000;;			kindToScope:          kindToScope,
0000000000000000000000000000000000000000;;			defaultGroupVersions: defaultGroupVersions,
0000000000000000000000000000000000000000;;			singularToPlural:     singularToPlural,
0000000000000000000000000000000000000000;;			pluralToSingular:     pluralToSingular,
0000000000000000000000000000000000000000;;			interfacesFunc:       f,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *DefaultRESTMapper) Add(kind schema.GroupVersionKind, scope RESTScope) {
0000000000000000000000000000000000000000;;		plural, singular := UnsafeGuessKindToResource(kind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.singularToPlural[singular] = plural
0000000000000000000000000000000000000000;;		m.pluralToSingular[plural] = singular
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.resourceToKind[singular] = kind
0000000000000000000000000000000000000000;;		m.resourceToKind[plural] = kind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.kindToPluralResource[kind] = plural
0000000000000000000000000000000000000000;;		m.kindToScope[kind] = scope
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unpluralizedSuffixes is a list of resource suffixes that are the same plural and singular
0000000000000000000000000000000000000000;;	// This is only is only necessary because some bits of code are lazy and don't actually use the RESTMapper like they should.
0000000000000000000000000000000000000000;;	// TODO eliminate this so that different callers can correctly map to resources.  This probably means updating all
0000000000000000000000000000000000000000;;	// callers to use the RESTMapper they mean.
0000000000000000000000000000000000000000;;	var unpluralizedSuffixes = []string{
0000000000000000000000000000000000000000;;		"endpoints",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsafeGuessKindToResource converts Kind to a resource name.
0000000000000000000000000000000000000000;;	// Broken. This method only "sort of" works when used outside of this package.  It assumes that Kinds and Resources match
0000000000000000000000000000000000000000;;	// and they aren't guaranteed to do so.
0000000000000000000000000000000000000000;;	func UnsafeGuessKindToResource(kind schema.GroupVersionKind) ( /*plural*/ schema.GroupVersionResource /*singular*/, schema.GroupVersionResource) {
0000000000000000000000000000000000000000;;		kindName := kind.Kind
0000000000000000000000000000000000000000;;		if len(kindName) == 0 {
0000000000000000000000000000000000000000;;			return schema.GroupVersionResource{}, schema.GroupVersionResource{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		singularName := strings.ToLower(kindName)
0000000000000000000000000000000000000000;;		singular := kind.GroupVersion().WithResource(singularName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, skip := range unpluralizedSuffixes {
0000000000000000000000000000000000000000;;			if strings.HasSuffix(singularName, skip) {
0000000000000000000000000000000000000000;;				return singular, singular
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch string(singularName[len(singularName)-1]) {
0000000000000000000000000000000000000000;;		case "s":
0000000000000000000000000000000000000000;;			return kind.GroupVersion().WithResource(singularName + "es"), singular
0000000000000000000000000000000000000000;;		case "y":
0000000000000000000000000000000000000000;;			return kind.GroupVersion().WithResource(strings.TrimSuffix(singularName, "y") + "ies"), singular
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return kind.GroupVersion().WithResource(singularName + "s"), singular
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceSingularizer implements RESTMapper
0000000000000000000000000000000000000000;;	// It converts a resource name from plural to singular (e.g., from pods to pod)
0000000000000000000000000000000000000000;;	func (m *DefaultRESTMapper) ResourceSingularizer(resourceType string) (string, error) {
0000000000000000000000000000000000000000;;		partialResource := schema.GroupVersionResource{Resource: resourceType}
0000000000000000000000000000000000000000;;		resources, err := m.ResourcesFor(partialResource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return resourceType, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		singular := schema.GroupVersionResource{}
0000000000000000000000000000000000000000;;		for _, curr := range resources {
0000000000000000000000000000000000000000;;			currSingular, ok := m.pluralToSingular[curr]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if singular.Empty() {
0000000000000000000000000000000000000000;;				singular = currSingular
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if currSingular.Resource != singular.Resource {
0000000000000000000000000000000000000000;;				return resourceType, fmt.Errorf("multiple possible singular resources (%v) found for %v", resources, resourceType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if singular.Empty() {
0000000000000000000000000000000000000000;;			return resourceType, fmt.Errorf("no singular of resource %v has been defined", resourceType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return singular.Resource, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// coerceResourceForMatching makes the resource lower case and converts internal versions to unspecified (legacy behavior)
0000000000000000000000000000000000000000;;	func coerceResourceForMatching(resource schema.GroupVersionResource) schema.GroupVersionResource {
0000000000000000000000000000000000000000;;		resource.Resource = strings.ToLower(resource.Resource)
0000000000000000000000000000000000000000;;		if resource.Version == runtime.APIVersionInternal {
0000000000000000000000000000000000000000;;			resource.Version = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *DefaultRESTMapper) ResourcesFor(input schema.GroupVersionResource) ([]schema.GroupVersionResource, error) {
0000000000000000000000000000000000000000;;		resource := coerceResourceForMatching(input)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasResource := len(resource.Resource) > 0
0000000000000000000000000000000000000000;;		hasGroup := len(resource.Group) > 0
0000000000000000000000000000000000000000;;		hasVersion := len(resource.Version) > 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !hasResource {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("a resource must be present, got: %v", resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := []schema.GroupVersionResource{}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case hasGroup && hasVersion:
0000000000000000000000000000000000000000;;			// fully qualified.  Find the exact match
0000000000000000000000000000000000000000;;			for plural, singular := range m.pluralToSingular {
0000000000000000000000000000000000000000;;				if singular == resource {
0000000000000000000000000000000000000000;;					ret = append(ret, plural)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if plural == resource {
0000000000000000000000000000000000000000;;					ret = append(ret, plural)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case hasGroup:
0000000000000000000000000000000000000000;;			// given a group, prefer an exact match.  If you don't find one, resort to a prefix match on group
0000000000000000000000000000000000000000;;			foundExactMatch := false
0000000000000000000000000000000000000000;;			requestedGroupResource := resource.GroupResource()
0000000000000000000000000000000000000000;;			for plural, singular := range m.pluralToSingular {
0000000000000000000000000000000000000000;;				if singular.GroupResource() == requestedGroupResource {
0000000000000000000000000000000000000000;;					foundExactMatch = true
0000000000000000000000000000000000000000;;					ret = append(ret, plural)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if plural.GroupResource() == requestedGroupResource {
0000000000000000000000000000000000000000;;					foundExactMatch = true
0000000000000000000000000000000000000000;;					ret = append(ret, plural)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if you didn't find an exact match, match on group prefixing. This allows storageclass.storage to match
0000000000000000000000000000000000000000;;			// storageclass.storage.k8s.io
0000000000000000000000000000000000000000;;			if !foundExactMatch {
0000000000000000000000000000000000000000;;				for plural, singular := range m.pluralToSingular {
0000000000000000000000000000000000000000;;					if !strings.HasPrefix(plural.Group, requestedGroupResource.Group) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if singular.Resource == requestedGroupResource.Resource {
0000000000000000000000000000000000000000;;						ret = append(ret, plural)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if plural.Resource == requestedGroupResource.Resource {
0000000000000000000000000000000000000000;;						ret = append(ret, plural)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case hasVersion:
0000000000000000000000000000000000000000;;			for plural, singular := range m.pluralToSingular {
0000000000000000000000000000000000000000;;				if singular.Version == resource.Version && singular.Resource == resource.Resource {
0000000000000000000000000000000000000000;;					ret = append(ret, plural)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if plural.Version == resource.Version && plural.Resource == resource.Resource {
0000000000000000000000000000000000000000;;					ret = append(ret, plural)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			for plural, singular := range m.pluralToSingular {
0000000000000000000000000000000000000000;;				if singular.Resource == resource.Resource {
0000000000000000000000000000000000000000;;					ret = append(ret, plural)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if plural.Resource == resource.Resource {
0000000000000000000000000000000000000000;;					ret = append(ret, plural)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ret) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NoResourceMatchError{PartialResource: resource}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Sort(resourceByPreferredGroupVersion{ret, m.defaultGroupVersions})
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *DefaultRESTMapper) ResourceFor(resource schema.GroupVersionResource) (schema.GroupVersionResource, error) {
0000000000000000000000000000000000000000;;		resources, err := m.ResourcesFor(resource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionResource{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(resources) == 1 {
0000000000000000000000000000000000000000;;			return resources[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schema.GroupVersionResource{}, &AmbiguousResourceError{PartialResource: resource, MatchingResources: resources}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *DefaultRESTMapper) KindsFor(input schema.GroupVersionResource) ([]schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		resource := coerceResourceForMatching(input)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasResource := len(resource.Resource) > 0
0000000000000000000000000000000000000000;;		hasGroup := len(resource.Group) > 0
0000000000000000000000000000000000000000;;		hasVersion := len(resource.Version) > 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !hasResource {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("a resource must be present, got: %v", resource)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := []schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// fully qualified.  Find the exact match
0000000000000000000000000000000000000000;;		case hasGroup && hasVersion:
0000000000000000000000000000000000000000;;			kind, exists := m.resourceToKind[resource]
0000000000000000000000000000000000000000;;			if exists {
0000000000000000000000000000000000000000;;				ret = append(ret, kind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case hasGroup:
0000000000000000000000000000000000000000;;			foundExactMatch := false
0000000000000000000000000000000000000000;;			requestedGroupResource := resource.GroupResource()
0000000000000000000000000000000000000000;;			for currResource, currKind := range m.resourceToKind {
0000000000000000000000000000000000000000;;				if currResource.GroupResource() == requestedGroupResource {
0000000000000000000000000000000000000000;;					foundExactMatch = true
0000000000000000000000000000000000000000;;					ret = append(ret, currKind)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if you didn't find an exact match, match on group prefixing. This allows storageclass.storage to match
0000000000000000000000000000000000000000;;			// storageclass.storage.k8s.io
0000000000000000000000000000000000000000;;			if !foundExactMatch {
0000000000000000000000000000000000000000;;				for currResource, currKind := range m.resourceToKind {
0000000000000000000000000000000000000000;;					if !strings.HasPrefix(currResource.Group, requestedGroupResource.Group) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if currResource.Resource == requestedGroupResource.Resource {
0000000000000000000000000000000000000000;;						ret = append(ret, currKind)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case hasVersion:
0000000000000000000000000000000000000000;;			for currResource, currKind := range m.resourceToKind {
0000000000000000000000000000000000000000;;				if currResource.Version == resource.Version && currResource.Resource == resource.Resource {
0000000000000000000000000000000000000000;;					ret = append(ret, currKind)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			for currResource, currKind := range m.resourceToKind {
0000000000000000000000000000000000000000;;				if currResource.Resource == resource.Resource {
0000000000000000000000000000000000000000;;					ret = append(ret, currKind)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ret) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NoResourceMatchError{PartialResource: input}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Sort(kindByPreferredGroupVersion{ret, m.defaultGroupVersions})
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *DefaultRESTMapper) KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		kinds, err := m.KindsFor(resource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionKind{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(kinds) == 1 {
0000000000000000000000000000000000000000;;			return kinds[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schema.GroupVersionKind{}, &AmbiguousResourceError{PartialResource: resource, MatchingKinds: kinds}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type kindByPreferredGroupVersion struct {
0000000000000000000000000000000000000000;;		list      []schema.GroupVersionKind
0000000000000000000000000000000000000000;;		sortOrder []schema.GroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o kindByPreferredGroupVersion) Len() int      { return len(o.list) }
0000000000000000000000000000000000000000;;	func (o kindByPreferredGroupVersion) Swap(i, j int) { o.list[i], o.list[j] = o.list[j], o.list[i] }
0000000000000000000000000000000000000000;;	func (o kindByPreferredGroupVersion) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		lhs := o.list[i]
0000000000000000000000000000000000000000;;		rhs := o.list[j]
0000000000000000000000000000000000000000;;		if lhs == rhs {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lhs.GroupVersion() == rhs.GroupVersion() {
0000000000000000000000000000000000000000;;			return lhs.Kind < rhs.Kind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// otherwise, the difference is in the GroupVersion, so we need to sort with respect to the preferred order
0000000000000000000000000000000000000000;;		lhsIndex := -1
0000000000000000000000000000000000000000;;		rhsIndex := -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range o.sortOrder {
0000000000000000000000000000000000000000;;			if o.sortOrder[i] == lhs.GroupVersion() {
0000000000000000000000000000000000000000;;				lhsIndex = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if o.sortOrder[i] == rhs.GroupVersion() {
0000000000000000000000000000000000000000;;				rhsIndex = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rhsIndex == -1 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return lhsIndex < rhsIndex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type resourceByPreferredGroupVersion struct {
0000000000000000000000000000000000000000;;		list      []schema.GroupVersionResource
0000000000000000000000000000000000000000;;		sortOrder []schema.GroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o resourceByPreferredGroupVersion) Len() int      { return len(o.list) }
0000000000000000000000000000000000000000;;	func (o resourceByPreferredGroupVersion) Swap(i, j int) { o.list[i], o.list[j] = o.list[j], o.list[i] }
0000000000000000000000000000000000000000;;	func (o resourceByPreferredGroupVersion) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		lhs := o.list[i]
0000000000000000000000000000000000000000;;		rhs := o.list[j]
0000000000000000000000000000000000000000;;		if lhs == rhs {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lhs.GroupVersion() == rhs.GroupVersion() {
0000000000000000000000000000000000000000;;			return lhs.Resource < rhs.Resource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// otherwise, the difference is in the GroupVersion, so we need to sort with respect to the preferred order
0000000000000000000000000000000000000000;;		lhsIndex := -1
0000000000000000000000000000000000000000;;		rhsIndex := -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range o.sortOrder {
0000000000000000000000000000000000000000;;			if o.sortOrder[i] == lhs.GroupVersion() {
0000000000000000000000000000000000000000;;				lhsIndex = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if o.sortOrder[i] == rhs.GroupVersion() {
0000000000000000000000000000000000000000;;				rhsIndex = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rhsIndex == -1 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return lhsIndex < rhsIndex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTMapping returns a struct representing the resource path and conversion interfaces a
0000000000000000000000000000000000000000;;	// RESTClient should use to operate on the provided group/kind in order of versions. If a version search
0000000000000000000000000000000000000000;;	// order is not provided, the search order provided to DefaultRESTMapper will be used to resolve which
0000000000000000000000000000000000000000;;	// version should be used to access the named group/kind.
0000000000000000000000000000000000000000;;	func (m *DefaultRESTMapper) RESTMapping(gk schema.GroupKind, versions ...string) (*RESTMapping, error) {
0000000000000000000000000000000000000000;;		mappings, err := m.RESTMappings(gk, versions...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(mappings) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NoKindMatchError{PartialKind: gk.WithVersion("")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// since we rely on RESTMappings method
0000000000000000000000000000000000000000;;		// take the first match and return to the caller
0000000000000000000000000000000000000000;;		// as this was the existing behavior.
0000000000000000000000000000000000000000;;		return mappings[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RESTMappings returns the RESTMappings for the provided group kind. If a version search order
0000000000000000000000000000000000000000;;	// is not provided, the search order provided to DefaultRESTMapper will be used.
0000000000000000000000000000000000000000;;	func (m *DefaultRESTMapper) RESTMappings(gk schema.GroupKind, versions ...string) ([]*RESTMapping, error) {
0000000000000000000000000000000000000000;;		mappings := make([]*RESTMapping, 0)
0000000000000000000000000000000000000000;;		potentialGVK := make([]schema.GroupVersionKind, 0)
0000000000000000000000000000000000000000;;		hadVersion := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pick an appropriate version
0000000000000000000000000000000000000000;;		for _, version := range versions {
0000000000000000000000000000000000000000;;			if len(version) == 0 || version == runtime.APIVersionInternal {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currGVK := gk.WithVersion(version)
0000000000000000000000000000000000000000;;			hadVersion = true
0000000000000000000000000000000000000000;;			if _, ok := m.kindToPluralResource[currGVK]; ok {
0000000000000000000000000000000000000000;;				potentialGVK = append(potentialGVK, currGVK)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Use the default preferred versions
0000000000000000000000000000000000000000;;		if !hadVersion && len(potentialGVK) == 0 {
0000000000000000000000000000000000000000;;			for _, gv := range m.defaultGroupVersions {
0000000000000000000000000000000000000000;;				if gv.Group != gk.Group {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				potentialGVK = append(potentialGVK, gk.WithVersion(gv.Version))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(potentialGVK) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NoKindMatchError{PartialKind: gk.WithVersion("")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, gvk := range potentialGVK {
0000000000000000000000000000000000000000;;			//Ensure we have a REST mapping
0000000000000000000000000000000000000000;;			res, ok := m.kindToPluralResource[gvk]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ensure we have a REST scope
0000000000000000000000000000000000000000;;			scope, ok := m.kindToScope[gvk]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("the provided version %q and kind %q cannot be mapped to a supported scope", gvk.GroupVersion(), gvk.Kind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			interfaces, err := m.interfacesFunc(gvk.GroupVersion())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("the provided version %q has no relevant versions: %v", gvk.GroupVersion().String(), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mappings = append(mappings, &RESTMapping{
0000000000000000000000000000000000000000;;				Resource:         res.Resource,
0000000000000000000000000000000000000000;;				GroupVersionKind: gvk,
0000000000000000000000000000000000000000;;				Scope:            scope,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ObjectConvertor:  interfaces.ObjectConvertor,
0000000000000000000000000000000000000000;;				MetadataAccessor: interfaces.MetadataAccessor,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(mappings) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NoResourceMatchError{PartialResource: schema.GroupVersionResource{Group: gk.Group, Resource: gk.Kind}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mappings, nil
0000000000000000000000000000000000000000;;	}
