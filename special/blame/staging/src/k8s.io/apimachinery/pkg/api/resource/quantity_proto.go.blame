0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
332ebfd58d909c618b2515742de2cdcbcd2b7238;pkg/api/resource/quantity_proto.go[pkg/api/resource/quantity_proto.go][staging/src/k8s.io/apimachinery/pkg/api/resource/quantity_proto.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/proto"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ proto.Sizer = &Quantity{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Quantity) Marshal() (data []byte, err error) {
0000000000000000000000000000000000000000;;		size := m.Size()
0000000000000000000000000000000000000000;;		data = make([]byte, size)
0000000000000000000000000000000000000000;;		n, err := m.MarshalTo(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data[:n], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalTo is a customized version of the generated Protobuf unmarshaler for a struct
0000000000000000000000000000000000000000;;	// with a single string field.
0000000000000000000000000000000000000000;;	func (m *Quantity) MarshalTo(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		var i int
0000000000000000000000000000000000000000;;		_ = i
0000000000000000000000000000000000000000;;		var l int
0000000000000000000000000000000000000000;;		_ = l
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data[i] = 0xa
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		// BEGIN CUSTOM MARSHAL
0000000000000000000000000000000000000000;;		out := m.String()
0000000000000000000000000000000000000000;;		i = encodeVarintGenerated(data, i, uint64(len(out)))
0000000000000000000000000000000000000000;;		i += copy(data[i:], out)
0000000000000000000000000000000000000000;;		// END CUSTOM MARSHAL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeVarintGenerated(data []byte, offset int, v uint64) int {
0000000000000000000000000000000000000000;;		for v >= 1<<7 {
0000000000000000000000000000000000000000;;			data[offset] = uint8(v&0x7f | 0x80)
0000000000000000000000000000000000000000;;			v >>= 7
0000000000000000000000000000000000000000;;			offset++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data[offset] = uint8(v)
0000000000000000000000000000000000000000;;		return offset + 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *Quantity) Size() (n int) {
0000000000000000000000000000000000000000;;		var l int
0000000000000000000000000000000000000000;;		_ = l
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BEGIN CUSTOM SIZE
0000000000000000000000000000000000000000;;		l = len(m.String())
0000000000000000000000000000000000000000;;		// END CUSTOM SIZE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n += 1 + l + sovGenerated(uint64(l))
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sovGenerated(x uint64) (n int) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;			x >>= 7
0000000000000000000000000000000000000000;;			if x == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal is a customized version of the generated Protobuf unmarshaler for a struct
0000000000000000000000000000000000000000;;	// with a single string field.
0000000000000000000000000000000000000000;;	func (m *Quantity) Unmarshal(data []byte) error {
0000000000000000000000000000000000000000;;		l := len(data)
0000000000000000000000000000000000000000;;		iNdEx := 0
0000000000000000000000000000000000000000;;		for iNdEx < l {
0000000000000000000000000000000000000000;;			preIndex := iNdEx
0000000000000000000000000000000000000000;;			var wire uint64
0000000000000000000000000000000000000000;;			for shift := uint(0); ; shift += 7 {
0000000000000000000000000000000000000000;;				if shift >= 64 {
0000000000000000000000000000000000000000;;					return ErrIntOverflowGenerated
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if iNdEx >= l {
0000000000000000000000000000000000000000;;					return io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b := data[iNdEx]
0000000000000000000000000000000000000000;;				iNdEx++
0000000000000000000000000000000000000000;;				wire |= (uint64(b) & 0x7F) << shift
0000000000000000000000000000000000000000;;				if b < 0x80 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fieldNum := int32(wire >> 3)
0000000000000000000000000000000000000000;;			wireType := int(wire & 0x7)
0000000000000000000000000000000000000000;;			if wireType == 4 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("proto: Quantity: wiretype end group for non-group")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fieldNum <= 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("proto: Quantity: illegal tag %d (wire type %d)", fieldNum, wire)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch fieldNum {
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				if wireType != 2 {
0000000000000000000000000000000000000000;;					return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var stringLen uint64
0000000000000000000000000000000000000000;;				for shift := uint(0); ; shift += 7 {
0000000000000000000000000000000000000000;;					if shift >= 64 {
0000000000000000000000000000000000000000;;						return ErrIntOverflowGenerated
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if iNdEx >= l {
0000000000000000000000000000000000000000;;						return io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					b := data[iNdEx]
0000000000000000000000000000000000000000;;					iNdEx++
0000000000000000000000000000000000000000;;					stringLen |= (uint64(b) & 0x7F) << shift
0000000000000000000000000000000000000000;;					if b < 0x80 {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				intStringLen := int(stringLen)
0000000000000000000000000000000000000000;;				if intStringLen < 0 {
0000000000000000000000000000000000000000;;					return ErrInvalidLengthGenerated
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				postIndex := iNdEx + intStringLen
0000000000000000000000000000000000000000;;				if postIndex > l {
0000000000000000000000000000000000000000;;					return io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s := string(data[iNdEx:postIndex])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// BEGIN CUSTOM DECODE
0000000000000000000000000000000000000000;;				p, err := ParseQuantity(s)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*m = p
0000000000000000000000000000000000000000;;				// END CUSTOM DECODE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				iNdEx = postIndex
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				iNdEx = preIndex
0000000000000000000000000000000000000000;;				skippy, err := skipGenerated(data[iNdEx:])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if skippy < 0 {
0000000000000000000000000000000000000000;;					return ErrInvalidLengthGenerated
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if (iNdEx + skippy) > l {
0000000000000000000000000000000000000000;;					return io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				iNdEx += skippy
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if iNdEx > l {
0000000000000000000000000000000000000000;;			return io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func skipGenerated(data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		l := len(data)
0000000000000000000000000000000000000000;;		iNdEx := 0
0000000000000000000000000000000000000000;;		for iNdEx < l {
0000000000000000000000000000000000000000;;			var wire uint64
0000000000000000000000000000000000000000;;			for shift := uint(0); ; shift += 7 {
0000000000000000000000000000000000000000;;				if shift >= 64 {
0000000000000000000000000000000000000000;;					return 0, ErrIntOverflowGenerated
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if iNdEx >= l {
0000000000000000000000000000000000000000;;					return 0, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b := data[iNdEx]
0000000000000000000000000000000000000000;;				iNdEx++
0000000000000000000000000000000000000000;;				wire |= (uint64(b) & 0x7F) << shift
0000000000000000000000000000000000000000;;				if b < 0x80 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wireType := int(wire & 0x7)
0000000000000000000000000000000000000000;;			switch wireType {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				for shift := uint(0); ; shift += 7 {
0000000000000000000000000000000000000000;;					if shift >= 64 {
0000000000000000000000000000000000000000;;						return 0, ErrIntOverflowGenerated
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if iNdEx >= l {
0000000000000000000000000000000000000000;;						return 0, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					iNdEx++
0000000000000000000000000000000000000000;;					if data[iNdEx-1] < 0x80 {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return iNdEx, nil
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				iNdEx += 8
0000000000000000000000000000000000000000;;				return iNdEx, nil
0000000000000000000000000000000000000000;;			case 2:
0000000000000000000000000000000000000000;;				var length int
0000000000000000000000000000000000000000;;				for shift := uint(0); ; shift += 7 {
0000000000000000000000000000000000000000;;					if shift >= 64 {
0000000000000000000000000000000000000000;;						return 0, ErrIntOverflowGenerated
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if iNdEx >= l {
0000000000000000000000000000000000000000;;						return 0, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					b := data[iNdEx]
0000000000000000000000000000000000000000;;					iNdEx++
0000000000000000000000000000000000000000;;					length |= (int(b) & 0x7F) << shift
0000000000000000000000000000000000000000;;					if b < 0x80 {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				iNdEx += length
0000000000000000000000000000000000000000;;				if length < 0 {
0000000000000000000000000000000000000000;;					return 0, ErrInvalidLengthGenerated
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return iNdEx, nil
0000000000000000000000000000000000000000;;			case 3:
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					var innerWire uint64
0000000000000000000000000000000000000000;;					var start int = iNdEx
0000000000000000000000000000000000000000;;					for shift := uint(0); ; shift += 7 {
0000000000000000000000000000000000000000;;						if shift >= 64 {
0000000000000000000000000000000000000000;;							return 0, ErrIntOverflowGenerated
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if iNdEx >= l {
0000000000000000000000000000000000000000;;							return 0, io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						b := data[iNdEx]
0000000000000000000000000000000000000000;;						iNdEx++
0000000000000000000000000000000000000000;;						innerWire |= (uint64(b) & 0x7F) << shift
0000000000000000000000000000000000000000;;						if b < 0x80 {
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					innerWireType := int(innerWire & 0x7)
0000000000000000000000000000000000000000;;					if innerWireType == 4 {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					next, err := skipGenerated(data[start:])
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return 0, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					iNdEx = start + next
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return iNdEx, nil
0000000000000000000000000000000000000000;;			case 4:
0000000000000000000000000000000000000000;;				return iNdEx, nil
0000000000000000000000000000000000000000;;			case 5:
0000000000000000000000000000000000000000;;				iNdEx += 4
0000000000000000000000000000000000000000;;				return iNdEx, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrInvalidLengthGenerated = fmt.Errorf("proto: negative length found during unmarshaling")
0000000000000000000000000000000000000000;;		ErrIntOverflowGenerated   = fmt.Errorf("proto: integer overflow")
0000000000000000000000000000000000000000;;	)
