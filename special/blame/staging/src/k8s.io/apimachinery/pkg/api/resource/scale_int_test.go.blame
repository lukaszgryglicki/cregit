0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c6fe75a7e40d0364a929084e2582439522992c2b;pkg/api/resource/scale_int_test.go[pkg/api/resource/scale_int_test.go][staging/src/k8s.io/apimachinery/pkg/api/resource/scale_int_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScaledValueInternal(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			unscaled *big.Int
0000000000000000000000000000000000000000;;			scale    int
0000000000000000000000000000000000000000;;			newScale int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			want int64
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// remain scale
0000000000000000000000000000000000000000;;			{big.NewInt(1000), 0, 0, 1000},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// scale down
0000000000000000000000000000000000000000;;			{big.NewInt(1000), 0, -3, 1},
0000000000000000000000000000000000000000;;			{big.NewInt(1000), 3, 0, 1},
0000000000000000000000000000000000000000;;			{big.NewInt(0), 3, 0, 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// always round up
0000000000000000000000000000000000000000;;			{big.NewInt(999), 3, 0, 1},
0000000000000000000000000000000000000000;;			{big.NewInt(500), 3, 0, 1},
0000000000000000000000000000000000000000;;			{big.NewInt(499), 3, 0, 1},
0000000000000000000000000000000000000000;;			{big.NewInt(1), 3, 0, 1},
0000000000000000000000000000000000000000;;			// large scaled value does not lose precision
0000000000000000000000000000000000000000;;			{big.NewInt(0).Sub(maxInt64, bigOne), 1, 0, (math.MaxInt64-1)/10 + 1},
0000000000000000000000000000000000000000;;			// large intermidiate result.
0000000000000000000000000000000000000000;;			{big.NewInt(1).Exp(big.NewInt(10), big.NewInt(100), nil), 100, 0, 1},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// scale up
0000000000000000000000000000000000000000;;			{big.NewInt(0), 0, 3, 0},
0000000000000000000000000000000000000000;;			{big.NewInt(1), 0, 3, 1000},
0000000000000000000000000000000000000000;;			{big.NewInt(1), -3, 0, 1000},
0000000000000000000000000000000000000000;;			{big.NewInt(1000), -3, 2, 100000000},
0000000000000000000000000000000000000000;;			{big.NewInt(0).Div(big.NewInt(math.MaxInt64), bigThousand), 0, 3,
0000000000000000000000000000000000000000;;				(math.MaxInt64 / 1000) * 1000},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tt := range tests {
0000000000000000000000000000000000000000;;			old := (&big.Int{}).Set(tt.unscaled)
0000000000000000000000000000000000000000;;			got := scaledValue(tt.unscaled, tt.scale, tt.newScale)
0000000000000000000000000000000000000000;;			if got != tt.want {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: got = %v, want %v", i, got, tt.want)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tt.unscaled.Cmp(old) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("#%d: unscaled = %v, want %v", i, tt.unscaled, old)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkScaledValueSmall(b *testing.B) {
0000000000000000000000000000000000000000;;		s := big.NewInt(1000)
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			scaledValue(s, 3, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkScaledValueLarge(b *testing.B) {
0000000000000000000000000000000000000000;;		s := big.NewInt(math.MaxInt64)
0000000000000000000000000000000000000000;;		s.Mul(s, big.NewInt(1000))
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			scaledValue(s, 10, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
