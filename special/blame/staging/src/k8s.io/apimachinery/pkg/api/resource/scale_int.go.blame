0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
c6fe75a7e40d0364a929084e2582439522992c2b;pkg/api/resource/scale_int.go[pkg/api/resource/scale_int.go][staging/src/k8s.io/apimachinery/pkg/api/resource/scale_int.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package resource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// A sync pool to reduce allocation.
0000000000000000000000000000000000000000;;		intPool  sync.Pool
0000000000000000000000000000000000000000;;		maxInt64 = big.NewInt(math.MaxInt64)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		intPool.New = func() interface{} {
0000000000000000000000000000000000000000;;			return &big.Int{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scaledValue scales given unscaled value from scale to new Scale and returns
0000000000000000000000000000000000000000;;	// an int64. It ALWAYS rounds up the result when scale down. The final result might
0000000000000000000000000000000000000000;;	// overflow.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// scale, newScale represents the scale of the unscaled decimal.
0000000000000000000000000000000000000000;;	// The mathematical value of the decimal is unscaled * 10**(-scale).
0000000000000000000000000000000000000000;;	func scaledValue(unscaled *big.Int, scale, newScale int) int64 {
0000000000000000000000000000000000000000;;		dif := scale - newScale
0000000000000000000000000000000000000000;;		if dif == 0 {
0000000000000000000000000000000000000000;;			return unscaled.Int64()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle scale up
0000000000000000000000000000000000000000;;		// This is an easy case, we do not need to care about rounding and overflow.
0000000000000000000000000000000000000000;;		// If any intermediate operation causes overflow, the result will overflow.
0000000000000000000000000000000000000000;;		if dif < 0 {
0000000000000000000000000000000000000000;;			return unscaled.Int64() * int64(math.Pow10(-dif))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle scale down
0000000000000000000000000000000000000000;;		// We have to be careful about the intermediate operations.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fast path when unscaled < max.Int64 and exp(10,dif) < max.Int64
0000000000000000000000000000000000000000;;		const log10MaxInt64 = 19
0000000000000000000000000000000000000000;;		if unscaled.Cmp(maxInt64) < 0 && dif < log10MaxInt64 {
0000000000000000000000000000000000000000;;			divide := int64(math.Pow10(dif))
0000000000000000000000000000000000000000;;			result := unscaled.Int64() / divide
0000000000000000000000000000000000000000;;			mod := unscaled.Int64() % divide
0000000000000000000000000000000000000000;;			if mod != 0 {
0000000000000000000000000000000000000000;;				return result + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We should only convert back to int64 when getting the result.
0000000000000000000000000000000000000000;;		divisor := intPool.Get().(*big.Int)
0000000000000000000000000000000000000000;;		exp := intPool.Get().(*big.Int)
0000000000000000000000000000000000000000;;		result := intPool.Get().(*big.Int)
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			intPool.Put(divisor)
0000000000000000000000000000000000000000;;			intPool.Put(exp)
0000000000000000000000000000000000000000;;			intPool.Put(result)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// divisor = 10^(dif)
0000000000000000000000000000000000000000;;		// TODO: create loop up table if exp costs too much.
0000000000000000000000000000000000000000;;		divisor.Exp(bigTen, exp.SetInt64(int64(dif)), nil)
0000000000000000000000000000000000000000;;		// reuse exp
0000000000000000000000000000000000000000;;		remainder := exp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// result = unscaled / divisor
0000000000000000000000000000000000000000;;		// remainder = unscaled % divisor
0000000000000000000000000000000000000000;;		result.DivMod(unscaled, divisor, remainder)
0000000000000000000000000000000000000000;;		if remainder.Sign() != 0 {
0000000000000000000000000000000000000000;;			return result.Int64() + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result.Int64()
0000000000000000000000000000000000000000;;	}
