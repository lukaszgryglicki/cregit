0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package meta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPriorityRESTMapperResourceForErrorHandling(t *testing.T) {
0000000000000000000000000000000000000000;;		tcs := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			delegate         RESTMapper
0000000000000000000000000000000000000000;;			resourcePatterns []schema.GroupVersionResource
0000000000000000000000000000000000000000;;			result           schema.GroupVersionResource
0000000000000000000000000000000000000000;;			err              string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "single hit",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{{Resource: "single-hit"}}},
0000000000000000000000000000000000000000;;				result:   schema.GroupVersionResource{Resource: "single-hit"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "ambiguous match",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Resource: "first"},
0000000000000000000000000000000000000000;;					{Group: "two", Version: "b", Resource: "second"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				err: "matches multiple resources",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "group selection",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Resource: "first"},
0000000000000000000000000000000000000000;;					{Group: "two", Version: "b", Resource: "second"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				resourcePatterns: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "one", Version: AnyVersion, Resource: AnyResource},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionResource{Group: "one", Version: "a", Resource: "first"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "empty match continues",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Resource: "first"},
0000000000000000000000000000000000000000;;					{Group: "two", Version: "b", Resource: "second"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				resourcePatterns: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "fail", Version: AnyVersion, Resource: AnyResource},
0000000000000000000000000000000000000000;;					{Group: "one", Version: AnyVersion, Resource: AnyResource},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionResource{Group: "one", Version: "a", Resource: "first"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "group followed by version selection",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Resource: "first"},
0000000000000000000000000000000000000000;;					{Group: "two", Version: "b", Resource: "second"},
0000000000000000000000000000000000000000;;					{Group: "one", Version: "c", Resource: "third"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				resourcePatterns: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "one", Version: AnyVersion, Resource: AnyResource},
0000000000000000000000000000000000000000;;					{Group: AnyGroup, Version: "a", Resource: AnyResource},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionResource{Group: "one", Version: "a", Resource: "first"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "resource selection",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{resourcesFor: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Resource: "first"},
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Resource: "second"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				resourcePatterns: []schema.GroupVersionResource{
0000000000000000000000000000000000000000;;					{Group: AnyGroup, Version: AnyVersion, Resource: "second"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionResource{Group: "one", Version: "a", Resource: "second"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tcs {
0000000000000000000000000000000000000000;;			mapper := PriorityRESTMapper{Delegate: tc.delegate, ResourcePriority: tc.resourcePatterns}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actualResult, actualErr := mapper.ResourceFor(schema.GroupVersionResource{})
0000000000000000000000000000000000000000;;			if e, a := tc.result, actualResult; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(tc.err) == 0 && actualErr == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(tc.err) > 0 && actualErr == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: missing expected err: %v", tc.name, tc.err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.Contains(actualErr.Error(), tc.err) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, tc.err, actualErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPriorityRESTMapperKindForErrorHandling(t *testing.T) {
0000000000000000000000000000000000000000;;		tcs := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			delegate     RESTMapper
0000000000000000000000000000000000000000;;			kindPatterns []schema.GroupVersionKind
0000000000000000000000000000000000000000;;			result       schema.GroupVersionKind
0000000000000000000000000000000000000000;;			err          string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "single hit",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{kindsFor: []schema.GroupVersionKind{{Kind: "single-hit"}}},
0000000000000000000000000000000000000000;;				result:   schema.GroupVersionKind{Kind: "single-hit"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "ambiguous match",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{kindsFor: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Kind: "first"},
0000000000000000000000000000000000000000;;					{Group: "two", Version: "b", Kind: "second"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				err: "matches multiple kinds",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "group selection",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{kindsFor: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Kind: "first"},
0000000000000000000000000000000000000000;;					{Group: "two", Version: "b", Kind: "second"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				kindPatterns: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "one", Version: AnyVersion, Kind: AnyKind},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionKind{Group: "one", Version: "a", Kind: "first"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "empty match continues",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{kindsFor: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Kind: "first"},
0000000000000000000000000000000000000000;;					{Group: "two", Version: "b", Kind: "second"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				kindPatterns: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "fail", Version: AnyVersion, Kind: AnyKind},
0000000000000000000000000000000000000000;;					{Group: "one", Version: AnyVersion, Kind: AnyKind},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionKind{Group: "one", Version: "a", Kind: "first"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "group followed by version selection",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{kindsFor: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Kind: "first"},
0000000000000000000000000000000000000000;;					{Group: "two", Version: "b", Kind: "second"},
0000000000000000000000000000000000000000;;					{Group: "one", Version: "c", Kind: "third"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				kindPatterns: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "one", Version: AnyVersion, Kind: AnyKind},
0000000000000000000000000000000000000000;;					{Group: AnyGroup, Version: "a", Kind: AnyKind},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionKind{Group: "one", Version: "a", Kind: "first"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "kind selection",
0000000000000000000000000000000000000000;;				delegate: fixedRESTMapper{kindsFor: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Kind: "first"},
0000000000000000000000000000000000000000;;					{Group: "one", Version: "a", Kind: "second"},
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;				kindPatterns: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;					{Group: AnyGroup, Version: AnyVersion, Kind: "second"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result: schema.GroupVersionKind{Group: "one", Version: "a", Kind: "second"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tcs {
0000000000000000000000000000000000000000;;			mapper := PriorityRESTMapper{Delegate: tc.delegate, KindPriority: tc.kindPatterns}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actualResult, actualErr := mapper.KindFor(schema.GroupVersionResource{})
0000000000000000000000000000000000000000;;			if e, a := tc.result, actualResult; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(tc.err) == 0 && actualErr == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(tc.err) > 0 && actualErr == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: missing expected err: %v", tc.name, tc.err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.Contains(actualErr.Error(), tc.err) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, tc.err, actualErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPriorityRESTMapperRESTMapping(t *testing.T) {
0000000000000000000000000000000000000000;;		mapping1 := &RESTMapping{
0000000000000000000000000000000000000000;;			GroupVersionKind: schema.GroupVersionKind{Kind: "Foo", Version: "v1alpha1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapping2 := &RESTMapping{
0000000000000000000000000000000000000000;;			GroupVersionKind: schema.GroupVersionKind{Kind: "Foo", Version: "v1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mapping3 := &RESTMapping{
0000000000000000000000000000000000000000;;			GroupVersionKind: schema.GroupVersionKind{Group: "other", Kind: "Foo", Version: "v1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allMappers := MultiRESTMapper{
0000000000000000000000000000000000000000;;			fixedRESTMapper{mappings: []*RESTMapping{mapping1}},
0000000000000000000000000000000000000000;;			fixedRESTMapper{mappings: []*RESTMapping{mapping2}},
0000000000000000000000000000000000000000;;			fixedRESTMapper{mappings: []*RESTMapping{mapping3}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tcs := []struct {
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mapper PriorityRESTMapper
0000000000000000000000000000000000000000;;			input  schema.GroupKind
0000000000000000000000000000000000000000;;			result *RESTMapping
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "empty",
0000000000000000000000000000000000000000;;				mapper: PriorityRESTMapper{Delegate: MultiRESTMapper{}},
0000000000000000000000000000000000000000;;				input:  schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				err:    &NoKindMatchError{PartialKind: schema.GroupVersionKind{Kind: "Foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "ignore not found",
0000000000000000000000000000000000000000;;				mapper: PriorityRESTMapper{Delegate: MultiRESTMapper{fixedRESTMapper{err: &NoKindMatchError{PartialKind: schema.GroupVersionKind{Kind: "IGNORE_THIS"}}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				err:    &NoKindMatchError{PartialKind: schema.GroupVersionKind{Kind: "Foo"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:   "accept first failure",
0000000000000000000000000000000000000000;;				mapper: PriorityRESTMapper{Delegate: MultiRESTMapper{fixedRESTMapper{err: errors.New("fail on this")}, fixedRESTMapper{mappings: []*RESTMapping{mapping1}}}},
0000000000000000000000000000000000000000;;				input:  schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				err:    errors.New("fail on this"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "return error for ambiguous",
0000000000000000000000000000000000000000;;				mapper: PriorityRESTMapper{
0000000000000000000000000000000000000000;;					Delegate: allMappers,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				input: schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				err: &AmbiguousKindError{
0000000000000000000000000000000000000000;;					PartialKind: schema.GroupVersionKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;					MatchingKinds: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;						{Kind: "Foo", Version: "v1alpha1"},
0000000000000000000000000000000000000000;;						{Kind: "Foo", Version: "v1"},
0000000000000000000000000000000000000000;;						{Group: "other", Kind: "Foo", Version: "v1"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "accept only item",
0000000000000000000000000000000000000000;;				mapper: PriorityRESTMapper{
0000000000000000000000000000000000000000;;					Delegate: fixedRESTMapper{mappings: []*RESTMapping{mapping1}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				input:  schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				result: mapping1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "return single priority",
0000000000000000000000000000000000000000;;				mapper: PriorityRESTMapper{
0000000000000000000000000000000000000000;;					Delegate:     allMappers,
0000000000000000000000000000000000000000;;					KindPriority: []schema.GroupVersionKind{{Version: "v1", Kind: AnyKind}, {Version: "v1alpha1", Kind: AnyKind}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				input:  schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				result: mapping2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "return out of group match",
0000000000000000000000000000000000000000;;				mapper: PriorityRESTMapper{
0000000000000000000000000000000000000000;;					Delegate:     allMappers,
0000000000000000000000000000000000000000;;					KindPriority: []schema.GroupVersionKind{{Group: AnyGroup, Version: "v1", Kind: AnyKind}, {Group: "other", Version: AnyVersion, Kind: AnyKind}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				input:  schema.GroupKind{Kind: "Foo"},
0000000000000000000000000000000000000000;;				result: mapping3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tcs {
0000000000000000000000000000000000000000;;			actualResult, actualErr := tc.mapper.RESTMapping(tc.input)
0000000000000000000000000000000000000000;;			if e, a := tc.result, actualResult; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case tc.err == nil && actualErr == nil:
0000000000000000000000000000000000000000;;			case tc.err == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", tc.name, actualErr)
0000000000000000000000000000000000000000;;			case actualErr == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected error: %v got nil", tc.name, tc.err)
0000000000000000000000000000000000000000;;			case tc.err.Error() != actualErr.Error():
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", tc.name, tc.err, actualErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPriorityRESTMapperRESTMappingHonorsUserVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		mappingV2alpha1 := &RESTMapping{
0000000000000000000000000000000000000000;;			GroupVersionKind: schema.GroupVersionKind{Group: "Bar", Kind: "Foo", Version: "v2alpha1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mappingV1 := &RESTMapping{
0000000000000000000000000000000000000000;;			GroupVersionKind: schema.GroupVersionKind{Group: "Bar", Kind: "Foo", Version: "v1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		allMappers := MultiRESTMapper{
0000000000000000000000000000000000000000;;			fixedRESTMapper{mappings: []*RESTMapping{mappingV2alpha1}},
0000000000000000000000000000000000000000;;			fixedRESTMapper{mappings: []*RESTMapping{mappingV1}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapper := PriorityRESTMapper{
0000000000000000000000000000000000000000;;			Delegate:     allMappers,
0000000000000000000000000000000000000000;;			KindPriority: []schema.GroupVersionKind{{Group: "Bar", Version: "v2alpha1", Kind: AnyKind}, {Group: "Bar", Version: AnyVersion, Kind: AnyKind}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outMapping1, err := mapper.RESTMapping(schema.GroupKind{Group: "Bar", Kind: "Foo"}, "v1")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if outMapping1 != mappingV1 {
0000000000000000000000000000000000000000;;			t.Errorf("asked for version %v, expected mapping for %v, got mapping for %v", "v1", mappingV1.GroupVersionKind, outMapping1.GroupVersionKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outMapping2, err := mapper.RESTMapping(schema.GroupKind{Group: "Bar", Kind: "Foo"}, "v2alpha1")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if outMapping2 != mappingV2alpha1 {
0000000000000000000000000000000000000000;;			t.Errorf("asked for version %v, expected mapping for %v, got mapping for %v", "v2alpha1", mappingV2alpha1.GroupVersionKind, outMapping2.GroupVersionKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
