0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package meta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		AnyGroup    = "*"
0000000000000000000000000000000000000000;;		AnyVersion  = "*"
0000000000000000000000000000000000000000;;		AnyResource = "*"
0000000000000000000000000000000000000000;;		AnyKind     = "*"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PriorityRESTMapper is a wrapper for automatically choosing a particular Resource or Kind
0000000000000000000000000000000000000000;;	// when multiple matches are possible
0000000000000000000000000000000000000000;;	type PriorityRESTMapper struct {
0000000000000000000000000000000000000000;;		// Delegate is the RESTMapper to use to locate all the Kind and Resource matches
0000000000000000000000000000000000000000;;		Delegate RESTMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ResourcePriority is a list of priority patterns to apply to matching resources.
0000000000000000000000000000000000000000;;		// The list of all matching resources is narrowed based on the patterns until only one remains.
0000000000000000000000000000000000000000;;		// A pattern with no matches is skipped.  A pattern with more than one match uses its
0000000000000000000000000000000000000000;;		// matches as the list to continue matching against.
0000000000000000000000000000000000000000;;		ResourcePriority []schema.GroupVersionResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KindPriority is a list of priority patterns to apply to matching kinds.
0000000000000000000000000000000000000000;;		// The list of all matching kinds is narrowed based on the patterns until only one remains.
0000000000000000000000000000000000000000;;		// A pattern with no matches is skipped.  A pattern with more than one match uses its
0000000000000000000000000000000000000000;;		// matches as the list to continue matching against.
0000000000000000000000000000000000000000;;		KindPriority []schema.GroupVersionKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m PriorityRESTMapper) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("PriorityRESTMapper{\n\t%v\n\t%v\n\t%v\n}", m.ResourcePriority, m.KindPriority, m.Delegate)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceFor finds all resources, then passes them through the ResourcePriority patterns to find a single matching hit.
0000000000000000000000000000000000000000;;	func (m PriorityRESTMapper) ResourceFor(partiallySpecifiedResource schema.GroupVersionResource) (schema.GroupVersionResource, error) {
0000000000000000000000000000000000000000;;		originalGVRs, err := m.Delegate.ResourcesFor(partiallySpecifiedResource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionResource{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(originalGVRs) == 1 {
0000000000000000000000000000000000000000;;			return originalGVRs[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remainingGVRs := append([]schema.GroupVersionResource{}, originalGVRs...)
0000000000000000000000000000000000000000;;		for _, pattern := range m.ResourcePriority {
0000000000000000000000000000000000000000;;			matchedGVRs := []schema.GroupVersionResource{}
0000000000000000000000000000000000000000;;			for _, gvr := range remainingGVRs {
0000000000000000000000000000000000000000;;				if resourceMatches(pattern, gvr) {
0000000000000000000000000000000000000000;;					matchedGVRs = append(matchedGVRs, gvr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch len(matchedGVRs) {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				// if you have no matches, then nothing matched this pattern just move to the next
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				// one match, return
0000000000000000000000000000000000000000;;				return matchedGVRs[0], nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// more than one match, use the matched hits as the list moving to the next pattern.
0000000000000000000000000000000000000000;;				// this way you can have a series of selection criteria
0000000000000000000000000000000000000000;;				remainingGVRs = matchedGVRs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schema.GroupVersionResource{}, &AmbiguousResourceError{PartialResource: partiallySpecifiedResource, MatchingResources: originalGVRs}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KindFor finds all kinds, then passes them through the KindPriority patterns to find a single matching hit.
0000000000000000000000000000000000000000;;	func (m PriorityRESTMapper) KindFor(partiallySpecifiedResource schema.GroupVersionResource) (schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		originalGVKs, err := m.Delegate.KindsFor(partiallySpecifiedResource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionKind{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(originalGVKs) == 1 {
0000000000000000000000000000000000000000;;			return originalGVKs[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remainingGVKs := append([]schema.GroupVersionKind{}, originalGVKs...)
0000000000000000000000000000000000000000;;		for _, pattern := range m.KindPriority {
0000000000000000000000000000000000000000;;			matchedGVKs := []schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;			for _, gvr := range remainingGVKs {
0000000000000000000000000000000000000000;;				if kindMatches(pattern, gvr) {
0000000000000000000000000000000000000000;;					matchedGVKs = append(matchedGVKs, gvr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch len(matchedGVKs) {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				// if you have no matches, then nothing matched this pattern just move to the next
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				// one match, return
0000000000000000000000000000000000000000;;				return matchedGVKs[0], nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// more than one match, use the matched hits as the list moving to the next pattern.
0000000000000000000000000000000000000000;;				// this way you can have a series of selection criteria
0000000000000000000000000000000000000000;;				remainingGVKs = matchedGVKs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return schema.GroupVersionKind{}, &AmbiguousResourceError{PartialResource: partiallySpecifiedResource, MatchingKinds: originalGVKs}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func resourceMatches(pattern schema.GroupVersionResource, resource schema.GroupVersionResource) bool {
0000000000000000000000000000000000000000;;		if pattern.Group != AnyGroup && pattern.Group != resource.Group {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pattern.Version != AnyVersion && pattern.Version != resource.Version {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pattern.Resource != AnyResource && pattern.Resource != resource.Resource {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func kindMatches(pattern schema.GroupVersionKind, kind schema.GroupVersionKind) bool {
0000000000000000000000000000000000000000;;		if pattern.Group != AnyGroup && pattern.Group != kind.Group {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pattern.Version != AnyVersion && pattern.Version != kind.Version {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pattern.Kind != AnyKind && pattern.Kind != kind.Kind {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m PriorityRESTMapper) RESTMapping(gk schema.GroupKind, versions ...string) (mapping *RESTMapping, err error) {
0000000000000000000000000000000000000000;;		mappings, err := m.Delegate.RESTMappings(gk)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// any versions the user provides take priority
0000000000000000000000000000000000000000;;		priorities := m.KindPriority
0000000000000000000000000000000000000000;;		if len(versions) > 0 {
0000000000000000000000000000000000000000;;			priorities = make([]schema.GroupVersionKind, 0, len(m.KindPriority)+len(versions))
0000000000000000000000000000000000000000;;			for _, version := range versions {
0000000000000000000000000000000000000000;;				gv := schema.GroupVersion{
0000000000000000000000000000000000000000;;					Version: version,
0000000000000000000000000000000000000000;;					Group:   gk.Group,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				priorities = append(priorities, gv.WithKind(AnyKind))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			priorities = append(priorities, m.KindPriority...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remaining := append([]*RESTMapping{}, mappings...)
0000000000000000000000000000000000000000;;		for _, pattern := range priorities {
0000000000000000000000000000000000000000;;			var matching []*RESTMapping
0000000000000000000000000000000000000000;;			for _, m := range remaining {
0000000000000000000000000000000000000000;;				if kindMatches(pattern, m.GroupVersionKind) {
0000000000000000000000000000000000000000;;					matching = append(matching, m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch len(matching) {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				// if you have no matches, then nothing matched this pattern just move to the next
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				// one match, return
0000000000000000000000000000000000000000;;				return matching[0], nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// more than one match, use the matched hits as the list moving to the next pattern.
0000000000000000000000000000000000000000;;				// this way you can have a series of selection criteria
0000000000000000000000000000000000000000;;				remaining = matching
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(remaining) == 1 {
0000000000000000000000000000000000000000;;			return remaining[0], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var kinds []schema.GroupVersionKind
0000000000000000000000000000000000000000;;		for _, m := range mappings {
0000000000000000000000000000000000000000;;			kinds = append(kinds, m.GroupVersionKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, &AmbiguousKindError{PartialKind: gk.WithVersion(""), MatchingKinds: kinds}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m PriorityRESTMapper) RESTMappings(gk schema.GroupKind, versions ...string) ([]*RESTMapping, error) {
0000000000000000000000000000000000000000;;		return m.Delegate.RESTMappings(gk, versions...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m PriorityRESTMapper) ResourceSingularizer(resource string) (singular string, err error) {
0000000000000000000000000000000000000000;;		return m.Delegate.ResourceSingularizer(resource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m PriorityRESTMapper) ResourcesFor(partiallySpecifiedResource schema.GroupVersionResource) ([]schema.GroupVersionResource, error) {
0000000000000000000000000000000000000000;;		return m.Delegate.ResourcesFor(partiallySpecifiedResource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m PriorityRESTMapper) KindsFor(partiallySpecifiedResource schema.GroupVersionResource) (gvk []schema.GroupVersionKind, err error) {
0000000000000000000000000000000000000000;;		return m.Delegate.KindsFor(partiallySpecifiedResource)
0000000000000000000000000000000000000000;;	}
