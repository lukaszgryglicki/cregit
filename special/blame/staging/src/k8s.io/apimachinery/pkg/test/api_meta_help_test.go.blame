0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
3270c76c34d0e476aa0eb2d7e7e1d28c27e08462;pkg/api/meta/help_test.go[pkg/api/meta/help_test.go][staging/src/k8s.io/apimachinery/pkg/test/api_meta_help_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/testapigroup"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIsList(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			obj    runtime.Object
0000000000000000000000000000000000000000;;			isList bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{&testapigroup.CarpList{}, true},
0000000000000000000000000000000000000000;;			{&testapigroup.Carp{}, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range tests {
0000000000000000000000000000000000000000;;			if e, a := item.isList, meta.IsListType(item.obj); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Expected %v, got %v", reflect.TypeOf(item.obj), e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExtractList(t *testing.T) {
0000000000000000000000000000000000000000;;		list1 := []runtime.Object{
0000000000000000000000000000000000000000;;			&testapigroup.Carp{ObjectMeta: metav1.ObjectMeta{Name: "1"}},
0000000000000000000000000000000000000000;;			&testapigroup.Carp{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list2 := &v1.List{
0000000000000000000000000000000000000000;;			Items: []runtime.RawExtension{
0000000000000000000000000000000000000000;;				{Raw: []byte("foo")},
0000000000000000000000000000000000000000;;				{Raw: []byte("bar")},
0000000000000000000000000000000000000000;;				{Object: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "other"}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list3 := &fakePtrValueList{
0000000000000000000000000000000000000000;;			Items: []*testapigroup.Carp{
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "1"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list4 := &testapigroup.CarpList{
0000000000000000000000000000000000000000;;			Items: []testapigroup.Carp{
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "1"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "3"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list5 := &v1.PodList{
0000000000000000000000000000000000000000;;			Items: []v1.Pod{
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "1"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "3"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			in    runtime.Object
0000000000000000000000000000000000000000;;			out   []interface{}
0000000000000000000000000000000000000000;;			equal bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &List{},
0000000000000000000000000000000000000000;;				out: []interface{}{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &v1.List{},
0000000000000000000000000000000000000000;;				out: []interface{}{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &v1.PodList{},
0000000000000000000000000000000000000000;;				out: []interface{}{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &List{Items: list1},
0000000000000000000000000000000000000000;;				out: []interface{}{list1[0], list1[1]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:    list2,
0000000000000000000000000000000000000000;;				out:   []interface{}{&runtime.Unknown{Raw: list2.Items[0].Raw}, &runtime.Unknown{Raw: list2.Items[1].Raw}, list2.Items[2].Object},
0000000000000000000000000000000000000000;;				equal: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  list3,
0000000000000000000000000000000000000000;;				out: []interface{}{list3.Items[0], list3.Items[1]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  list4,
0000000000000000000000000000000000000000;;				out: []interface{}{&list4.Items[0], &list4.Items[1], &list4.Items[2]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  list5,
0000000000000000000000000000000000000000;;				out: []interface{}{&list5.Items[0], &list5.Items[1], &list5.Items[2]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			list, err := meta.ExtractList(test.in)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: extract: Unexpected error %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := len(test.out), len(list); e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: extract: Expected %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j, e := range test.out {
0000000000000000000000000000000000000000;;				if e != list[j] {
0000000000000000000000000000000000000000;;					if !test.equal {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: extract: Expected list[%d] to be %#v, but found %#v", i, j, e, list[j])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !reflect.DeepEqual(e, list[j]) {
0000000000000000000000000000000000000000;;						t.Fatalf("%d: extract: Expected list[%d] to be %#v, but found %#v", i, j, e, list[j])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEachListItem(t *testing.T) {
0000000000000000000000000000000000000000;;		list1 := []runtime.Object{
0000000000000000000000000000000000000000;;			&testapigroup.Carp{ObjectMeta: metav1.ObjectMeta{Name: "1"}},
0000000000000000000000000000000000000000;;			&testapigroup.Carp{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list2 := &v1.List{
0000000000000000000000000000000000000000;;			Items: []runtime.RawExtension{
0000000000000000000000000000000000000000;;				{Raw: []byte("foo")},
0000000000000000000000000000000000000000;;				{Raw: []byte("bar")},
0000000000000000000000000000000000000000;;				{Object: &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "other"}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list3 := &fakePtrValueList{
0000000000000000000000000000000000000000;;			Items: []*testapigroup.Carp{
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "1"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list4 := &testapigroup.CarpList{
0000000000000000000000000000000000000000;;			Items: []testapigroup.Carp{
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "1"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "3"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list5 := &v1.PodList{
0000000000000000000000000000000000000000;;			Items: []v1.Pod{
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "1"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;				{ObjectMeta: metav1.ObjectMeta{Name: "3"}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			in  runtime.Object
0000000000000000000000000000000000000000;;			out []interface{}
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &List{},
0000000000000000000000000000000000000000;;				out: []interface{}{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &v1.List{},
0000000000000000000000000000000000000000;;				out: []interface{}{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &v1.PodList{},
0000000000000000000000000000000000000000;;				out: []interface{}{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &List{Items: list1},
0000000000000000000000000000000000000000;;				out: []interface{}{list1[0], list1[1]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  list2,
0000000000000000000000000000000000000000;;				out: []interface{}{nil, nil, list2.Items[2].Object},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  list3,
0000000000000000000000000000000000000000;;				out: []interface{}{list3.Items[0], list3.Items[1]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  list4,
0000000000000000000000000000000000000000;;				out: []interface{}{&list4.Items[0], &list4.Items[1], &list4.Items[2]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  list5,
0000000000000000000000000000000000000000;;				out: []interface{}{&list5.Items[0], &list5.Items[1], &list5.Items[2]},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			list := []runtime.Object{}
0000000000000000000000000000000000000000;;			err := meta.EachListItem(test.in, func(obj runtime.Object) error {
0000000000000000000000000000000000000000;;				list = append(list, obj)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: each: Unexpected error %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := len(test.out), len(list); e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: each: Expected %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j, e := range test.out {
0000000000000000000000000000000000000000;;				if e != list[j] {
0000000000000000000000000000000000000000;;					t.Fatalf("%d: each: Expected list[%d] to be %#v, but found %#v", i, j, e, list[j])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePtrInterfaceList struct {
0000000000000000000000000000000000000000;;		Items *[]runtime.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj fakePtrInterfaceList) GetObjectKind() schema.ObjectKind {
0000000000000000000000000000000000000000;;		return schema.EmptyObjectKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExtractListOfInterfacePtrs(t *testing.T) {
0000000000000000000000000000000000000000;;		pl := &fakePtrInterfaceList{
0000000000000000000000000000000000000000;;			Items: &[]runtime.Object{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list, err := meta.ExtractList(pl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(list) > 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected empty list, got %#v", list)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePtrValueList struct {
0000000000000000000000000000000000000000;;		Items []*testapigroup.Carp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj fakePtrValueList) GetObjectKind() schema.ObjectKind {
0000000000000000000000000000000000000000;;		return schema.EmptyObjectKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetList(t *testing.T) {
0000000000000000000000000000000000000000;;		pl := &testapigroup.CarpList{}
0000000000000000000000000000000000000000;;		list := []runtime.Object{
0000000000000000000000000000000000000000;;			&testapigroup.Carp{ObjectMeta: metav1.ObjectMeta{Name: "1"}},
0000000000000000000000000000000000000000;;			&testapigroup.Carp{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;			&testapigroup.Carp{ObjectMeta: metav1.ObjectMeta{Name: "3"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := meta.SetList(pl, list)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := len(list), len(pl.Items); e != a {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range list {
0000000000000000000000000000000000000000;;			if e, a := list[i].(*testapigroup.Carp).Name, pl.Items[i].Name; e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetListToRuntimeObjectArray(t *testing.T) {
0000000000000000000000000000000000000000;;		pl := &List{}
0000000000000000000000000000000000000000;;		list := []runtime.Object{
0000000000000000000000000000000000000000;;			&testapigroup.Carp{ObjectMeta: metav1.ObjectMeta{Name: "1"}},
0000000000000000000000000000000000000000;;			&testapigroup.Carp{ObjectMeta: metav1.ObjectMeta{Name: "2"}},
0000000000000000000000000000000000000000;;			&testapigroup.Carp{ObjectMeta: metav1.ObjectMeta{Name: "3"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := meta.SetList(pl, list)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := len(list), len(pl.Items); e != a {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range list {
0000000000000000000000000000000000000000;;			if e, a := list[i], pl.Items[i]; e != a {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: unmatched: %s", i, diff.ObjectDiff(e, a))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetListToMatchingType(t *testing.T) {
0000000000000000000000000000000000000000;;		pl := &unstructured.UnstructuredList{}
0000000000000000000000000000000000000000;;		list := []runtime.Object{
0000000000000000000000000000000000000000;;			&unstructured.Unstructured{Object: map[string]interface{}{"foo": 1}},
0000000000000000000000000000000000000000;;			&unstructured.Unstructured{Object: map[string]interface{}{"foo": 2}},
0000000000000000000000000000000000000000;;			&unstructured.Unstructured{Object: map[string]interface{}{"foo": 3}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := meta.SetList(pl, list)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := len(list), len(pl.Items); e != a {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range list {
0000000000000000000000000000000000000000;;			if e, a := list[i], &pl.Items[i]; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Fatalf("%d: unmatched: %s", i, diff.ObjectDiff(e, a))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetExtractListRoundTrip(t *testing.T) {
0000000000000000000000000000000000000000;;		fuzzer := fuzz.New().NilChance(0).NumElements(1, 5)
0000000000000000000000000000000000000000;;		for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;			start := &testapigroup.CarpList{}
0000000000000000000000000000000000000000;;			fuzzer.Fuzz(&start.Items)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			list, err := meta.ExtractList(start)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			got := &testapigroup.CarpList{}
0000000000000000000000000000000000000000;;			err = meta.SetList(got, list)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := start, got; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Fatalf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
