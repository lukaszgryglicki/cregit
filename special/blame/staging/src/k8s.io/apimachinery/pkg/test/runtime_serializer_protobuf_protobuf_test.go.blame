0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
994291cbb7eb45d2a39ef2de5fab5df681afa858;pkg/runtime/serializer/protobuf/protobuf_test.go[pkg/runtime/serializer/protobuf/protobuf_test.go][staging/src/k8s.io/apimachinery/pkg/test/runtime_serializer_protobuf_protobuf_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apiequality "k8s.io/apimachinery/pkg/api/equality"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/protobuf"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testObject struct {
0000000000000000000000000000000000000000;;		gvk schema.GroupVersionKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *testObject) GetObjectKind() schema.ObjectKind                { return d }
0000000000000000000000000000000000000000;;	func (d *testObject) SetGroupVersionKind(gvk schema.GroupVersionKind) { d.gvk = gvk }
0000000000000000000000000000000000000000;;	func (d *testObject) GroupVersionKind() schema.GroupVersionKind       { return d.gvk }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testMarshalable struct {
0000000000000000000000000000000000000000;;		testObject
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *testMarshalable) Marshal() ([]byte, error) {
0000000000000000000000000000000000000000;;		return d.data, d.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testBufferedMarshalable struct {
0000000000000000000000000000000000000000;;		testObject
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *testBufferedMarshalable) Marshal() ([]byte, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("not invokable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *testBufferedMarshalable) MarshalTo(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		copy(data, d.data)
0000000000000000000000000000000000000000;;		return len(d.data), d.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *testBufferedMarshalable) Size() int {
0000000000000000000000000000000000000000;;		return len(d.data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRecognize(t *testing.T) {
0000000000000000000000000000000000000000;;		s := protobuf.NewSerializer(nil, nil, "application/protobuf")
0000000000000000000000000000000000000000;;		ignores := [][]byte{
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			{},
0000000000000000000000000000000000000000;;			[]byte("k8s"),
0000000000000000000000000000000000000000;;			{0x6b, 0x38, 0x73, 0x01},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, data := range ignores {
0000000000000000000000000000000000000000;;			if ok, _, err := s.RecognizesData(bytes.NewBuffer(data)); err != nil || ok {
0000000000000000000000000000000000000000;;				t.Errorf("%d: should not recognize data: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		recognizes := [][]byte{
0000000000000000000000000000000000000000;;			{0x6b, 0x38, 0x73, 0x00},
0000000000000000000000000000000000000000;;			{0x6b, 0x38, 0x73, 0x00, 0x01},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, data := range recognizes {
0000000000000000000000000000000000000000;;			if ok, _, err := s.RecognizesData(bytes.NewBuffer(data)); err != nil || !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%d: should recognize data: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEncode(t *testing.T) {
0000000000000000000000000000000000000000;;		obj1 := &testMarshalable{testObject: testObject{}, data: []byte{}}
0000000000000000000000000000000000000000;;		wire1 := []byte{
0000000000000000000000000000000000000000;;			0x6b, 0x38, 0x73, 0x00, // prefix
0000000000000000000000000000000000000000;;			0x0a, 0x04,
0000000000000000000000000000000000000000;;			0x0a, 0x00, // apiversion
0000000000000000000000000000000000000000;;			0x12, 0x00, // kind
0000000000000000000000000000000000000000;;			0x12, 0x00, // data
0000000000000000000000000000000000000000;;			0x1a, 0x00, // content-type
0000000000000000000000000000000000000000;;			0x22, 0x00, // content-encoding
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj2 := &testMarshalable{
0000000000000000000000000000000000000000;;			testObject: testObject{gvk: schema.GroupVersionKind{Kind: "test", Group: "other", Version: "version"}},
0000000000000000000000000000000000000000;;			data:       []byte{0x01, 0x02, 0x03},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wire2 := []byte{
0000000000000000000000000000000000000000;;			0x6b, 0x38, 0x73, 0x00, // prefix
0000000000000000000000000000000000000000;;			0x0a, 0x15,
0000000000000000000000000000000000000000;;			0x0a, 0x0d, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x2f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, // apiversion
0000000000000000000000000000000000000000;;			0x12, 0x04, 0x74, 0x65, 0x73, 0x74, // kind
0000000000000000000000000000000000000000;;			0x12, 0x03, 0x01, 0x02, 0x03, // data
0000000000000000000000000000000000000000;;			0x1a, 0x00, // content-type
0000000000000000000000000000000000000000;;			0x22, 0x00, // content-encoding
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err1 := fmt.Errorf("a test error")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			obj   runtime.Object
0000000000000000000000000000000000000000;;			data  []byte
0000000000000000000000000000000000000000;;			errFn func(error) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:   &testObject{},
0000000000000000000000000000000000000000;;				errFn: protobuf.IsNotMarshalable,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:  obj1,
0000000000000000000000000000000000000000;;				data: wire1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:   &testMarshalable{testObject: obj1.testObject, err: err1},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return err == err1 },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// if this test fails, writing the "fast path" marshal is not the same as the "slow path"
0000000000000000000000000000000000000000;;				obj:  &testBufferedMarshalable{testObject: obj1.testObject, data: obj1.data},
0000000000000000000000000000000000000000;;				data: wire1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:  obj2,
0000000000000000000000000000000000000000;;				data: wire2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				// if this test fails, writing the "fast path" marshal is not the same as the "slow path"
0000000000000000000000000000000000000000;;				obj:  &testBufferedMarshalable{testObject: obj2.testObject, data: obj2.data},
0000000000000000000000000000000000000000;;				data: wire2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:   &testBufferedMarshalable{testObject: obj1.testObject, err: err1},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return err == err1 },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			s := protobuf.NewSerializer(nil, nil, "application/protobuf")
0000000000000000000000000000000000000000;;			data, err := runtime.Encode(s, test.obj)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == nil && test.errFn != nil:
0000000000000000000000000000000000000000;;				t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case err != nil && test.errFn == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				if !test.errFn(err) {
0000000000000000000000000000000000000000;;					t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if data != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d: should not have returned nil data", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.data != nil && !bytes.Equal(test.data, data) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected data:\n%s", i, hex.Dump(data))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ok, _, err := s.RecognizesData(bytes.NewBuffer(data)); !ok || err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: did not recognize data generated by call: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProtobufDecode(t *testing.T) {
0000000000000000000000000000000000000000;;		wire1 := []byte{
0000000000000000000000000000000000000000;;			0x6b, 0x38, 0x73, 0x00, // prefix
0000000000000000000000000000000000000000;;			0x0a, 0x04,
0000000000000000000000000000000000000000;;			0x0a, 0x00, // apiversion
0000000000000000000000000000000000000000;;			0x12, 0x00, // kind
0000000000000000000000000000000000000000;;			0x12, 0x00, // data
0000000000000000000000000000000000000000;;			0x1a, 0x00, // content-type
0000000000000000000000000000000000000000;;			0x22, 0x00, // content-encoding
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wire2 := []byte{
0000000000000000000000000000000000000000;;			0x6b, 0x38, 0x73, 0x00, // prefix
0000000000000000000000000000000000000000;;			0x0a, 0x15,
0000000000000000000000000000000000000000;;			0x0a, 0x0d, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x2f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, // apiversion
0000000000000000000000000000000000000000;;			0x12, 0x04, 0x74, 0x65, 0x73, 0x74, // kind
0000000000000000000000000000000000000000;;			0x12, 0x07, 0x6b, 0x38, 0x73, 0x00, 0x01, 0x02, 0x03, // data
0000000000000000000000000000000000000000;;			0x1a, 0x00, // content-type
0000000000000000000000000000000000000000;;			0x22, 0x00, // content-encoding
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//err1 := fmt.Errorf("a test error")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			obj   runtime.Object
0000000000000000000000000000000000000000;;			data  []byte
0000000000000000000000000000000000000000;;			errFn func(error) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:   &runtime.Unknown{},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return err.Error() == "empty data" },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				data:  []byte{0x6b},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool { return strings.Contains(err.Error(), "does not appear to be a protobuf message") },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &runtime.Unknown{
0000000000000000000000000000000000000000;;					Raw: []byte{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				data: wire1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj: &runtime.Unknown{
0000000000000000000000000000000000000000;;					TypeMeta: runtime.TypeMeta{
0000000000000000000000000000000000000000;;						APIVersion: "other/version",
0000000000000000000000000000000000000000;;						Kind:       "test",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					// content type is set because the prefix matches the content
0000000000000000000000000000000000000000;;					ContentType: "application/protobuf",
0000000000000000000000000000000000000000;;					Raw:         []byte{0x6b, 0x38, 0x73, 0x00, 0x01, 0x02, 0x03},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				data: wire2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			s := protobuf.NewSerializer(nil, nil, "application/protobuf")
0000000000000000000000000000000000000000;;			unk := &runtime.Unknown{}
0000000000000000000000000000000000000000;;			err := runtime.DecodeInto(s, test.data, unk)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == nil && test.errFn != nil:
0000000000000000000000000000000000000000;;				t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case err != nil && test.errFn == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				if !test.errFn(err) {
0000000000000000000000000000000000000000;;					t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(unk, test.obj) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected object:\n%#v", i, unk)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDecodeObjects(t *testing.T) {
0000000000000000000000000000000000000000;;		obj1 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "cool",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: v1.PodSpec{
0000000000000000000000000000000000000000;;				Containers: []v1.Container{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Name: "test",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj1wire, err := obj1.Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wire1, err := (&runtime.Unknown{
0000000000000000000000000000000000000000;;			TypeMeta: runtime.TypeMeta{Kind: "Pod", APIVersion: "v1"},
0000000000000000000000000000000000000000;;			Raw:      obj1wire,
0000000000000000000000000000000000000000;;		}).Marshal()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unk2 := &runtime.Unknown{
0000000000000000000000000000000000000000;;			TypeMeta: runtime.TypeMeta{Kind: "Pod", APIVersion: "v1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wire2 := make([]byte, len(wire1)*2)
0000000000000000000000000000000000000000;;		n, err := unk2.NestedMarshalTo(wire2, obj1, uint64(obj1.Size()))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != len(wire1) || !bytes.Equal(wire1, wire2[:n]) {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected wire:\n%s", hex.Dump(wire2[:n]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wire1 = append([]byte{0x6b, 0x38, 0x73, 0x00}, wire1...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			obj   runtime.Object
0000000000000000000000000000000000000000;;			data  []byte
0000000000000000000000000000000000000000;;			errFn func(error) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:  obj1,
0000000000000000000000000000000000000000;;				data: wire1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			scheme.AddKnownTypes(schema.GroupVersion{Version: "v1"}, &v1.Pod{})
0000000000000000000000000000000000000000;;			v1.AddToScheme(scheme)
0000000000000000000000000000000000000000;;			s := protobuf.NewSerializer(scheme, scheme, "application/protobuf")
0000000000000000000000000000000000000000;;			obj, err := runtime.Decode(s, test.data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == nil && test.errFn != nil:
0000000000000000000000000000000000000000;;				t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case err != nil && test.errFn == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				if !test.errFn(err) {
0000000000000000000000000000000000000000;;					t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if obj != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d: should not have returned an object", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !apiequality.Semantic.DeepEqual(obj, test.obj) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected object:\n%s", i, diff.ObjectGoPrintDiff(test.obj, obj))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
