0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
37781eaef9c2eb03c209f38487f69d52bdbc17ed;pkg/api/jsonbase_test.go[pkg/api/jsonbase_test.go][staging/src/k8s.io/apimachinery/pkg/test/api_meta_meta_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/testapigroup"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAPIObjectMeta(t *testing.T) {
0000000000000000000000000000000000000000;;		j := &testapigroup.Carp{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: "/a", Kind: "b"},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace:       "bar",
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				GenerateName:    "prefix",
0000000000000000000000000000000000000000;;				UID:             "uid",
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;				SelfLink:        "some/place/only/we/know",
0000000000000000000000000000000000000000;;				Labels:          map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Annotations:     map[string]string{"x": "y"},
0000000000000000000000000000000000000000;;				Finalizers: []string{
0000000000000000000000000000000000000000;;					"finalizer.1",
0000000000000000000000000000000000000000;;					"finalizer.2",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var _ metav1.Object = &j.ObjectMeta
0000000000000000000000000000000000000000;;		var _ metav1.ObjectMetaAccessor = j
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(j)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if accessor != metav1.Object(j) {
0000000000000000000000000000000000000000;;			t.Fatalf("should have returned the same pointer: %#v\n\n%#v", accessor, j)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "bar", accessor.GetNamespace(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "foo", accessor.GetName(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "prefix", accessor.GetGenerateName(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "uid", string(accessor.GetUID()); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "1", accessor.GetResourceVersion(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "some/place/only/we/know", accessor.GetSelfLink(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := []string{"finalizer.1", "finalizer.2"}, accessor.GetFinalizers(); !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typeAccessor, err := meta.TypeAccessor(j)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "a", typeAccessor.GetAPIVersion(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "b", typeAccessor.GetKind(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		accessor.SetNamespace("baz")
0000000000000000000000000000000000000000;;		accessor.SetName("bar")
0000000000000000000000000000000000000000;;		accessor.SetGenerateName("generate")
0000000000000000000000000000000000000000;;		accessor.SetUID("other")
0000000000000000000000000000000000000000;;		typeAccessor.SetAPIVersion("c")
0000000000000000000000000000000000000000;;		typeAccessor.SetKind("d")
0000000000000000000000000000000000000000;;		accessor.SetResourceVersion("2")
0000000000000000000000000000000000000000;;		accessor.SetSelfLink("google.com")
0000000000000000000000000000000000000000;;		accessor.SetFinalizers([]string{"finalizer.3"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prove that accessor changes the original object.
0000000000000000000000000000000000000000;;		if e, a := "baz", j.Namespace; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "bar", j.Name; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "generate", j.GenerateName; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := types.UID("other"), j.UID; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "c", j.APIVersion; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "d", j.Kind; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "2", j.ResourceVersion; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "google.com", j.SelfLink; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := []string{"finalizer.3"}, j.Finalizers; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typeAccessor.SetAPIVersion("d")
0000000000000000000000000000000000000000;;		typeAccessor.SetKind("e")
0000000000000000000000000000000000000000;;		if e, a := "d", j.APIVersion; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "e", j.Kind; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGenericTypeMeta(t *testing.T) {
0000000000000000000000000000000000000000;;		type TypeMeta struct {
0000000000000000000000000000000000000000;;			Kind              string                  `json:"kind,omitempty"`
0000000000000000000000000000000000000000;;			Namespace         string                  `json:"namespace,omitempty"`
0000000000000000000000000000000000000000;;			Name              string                  `json:"name,omitempty"`
0000000000000000000000000000000000000000;;			GenerateName      string                  `json:"generateName,omitempty"`
0000000000000000000000000000000000000000;;			UID               string                  `json:"uid,omitempty"`
0000000000000000000000000000000000000000;;			CreationTimestamp metav1.Time             `json:"creationTimestamp,omitempty"`
0000000000000000000000000000000000000000;;			SelfLink          string                  `json:"selfLink,omitempty"`
0000000000000000000000000000000000000000;;			ResourceVersion   string                  `json:"resourceVersion,omitempty"`
0000000000000000000000000000000000000000;;			APIVersion        string                  `json:"apiVersion,omitempty"`
0000000000000000000000000000000000000000;;			Labels            map[string]string       `json:"labels,omitempty"`
0000000000000000000000000000000000000000;;			Annotations       map[string]string       `json:"annotations,omitempty"`
0000000000000000000000000000000000000000;;			OwnerReferences   []metav1.OwnerReference `json:"ownerReferences,omitempty"`
0000000000000000000000000000000000000000;;			Finalizers        []string                `json:"finalizers,omitempty"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j := struct{ TypeMeta }{TypeMeta{APIVersion: "a", Kind: "b"}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typeAccessor, err := meta.TypeAccessor(&j)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "a", typeAccessor.GetAPIVersion(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "b", typeAccessor.GetKind(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typeAccessor.SetAPIVersion("c")
0000000000000000000000000000000000000000;;		typeAccessor.SetKind("d")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := "c", j.APIVersion; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "d", j.Kind; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typeAccessor.SetAPIVersion("d")
0000000000000000000000000000000000000000;;		typeAccessor.SetKind("e")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := "d", j.APIVersion; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := "e", j.Kind; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InternalTypeMeta struct {
0000000000000000000000000000000000000000;;		Kind              string                  `json:"kind,omitempty"`
0000000000000000000000000000000000000000;;		Namespace         string                  `json:"namespace,omitempty"`
0000000000000000000000000000000000000000;;		Name              string                  `json:"name,omitempty"`
0000000000000000000000000000000000000000;;		GenerateName      string                  `json:"generateName,omitempty"`
0000000000000000000000000000000000000000;;		UID               string                  `json:"uid,omitempty"`
0000000000000000000000000000000000000000;;		CreationTimestamp metav1.Time             `json:"creationTimestamp,omitempty"`
0000000000000000000000000000000000000000;;		SelfLink          string                  `json:"selfLink,omitempty"`
0000000000000000000000000000000000000000;;		ResourceVersion   string                  `json:"resourceVersion,omitempty"`
0000000000000000000000000000000000000000;;		APIVersion        string                  `json:"apiVersion,omitempty"`
0000000000000000000000000000000000000000;;		Labels            map[string]string       `json:"labels,omitempty"`
0000000000000000000000000000000000000000;;		Annotations       map[string]string       `json:"annotations,omitempty"`
0000000000000000000000000000000000000000;;		Finalizers        []string                `json:"finalizers,omitempty"`
0000000000000000000000000000000000000000;;		OwnerReferences   []metav1.OwnerReference `json:"ownerReferences,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *InternalTypeMeta) GetResourceVersion() string   { return m.ResourceVersion }
0000000000000000000000000000000000000000;;	func (m *InternalTypeMeta) SetResourceVersion(rv string) { m.ResourceVersion = rv }
0000000000000000000000000000000000000000;;	func (m *InternalTypeMeta) GetSelfLink() string          { return m.SelfLink }
0000000000000000000000000000000000000000;;	func (m *InternalTypeMeta) SetSelfLink(link string)      { m.SelfLink = link }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MyAPIObject struct {
0000000000000000000000000000000000000000;;		TypeMeta InternalTypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *MyAPIObject) GetListMeta() metav1.List { return &obj.TypeMeta }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *MyAPIObject) GetObjectKind() schema.ObjectKind { return obj }
0000000000000000000000000000000000000000;;	func (obj *MyAPIObject) SetGroupVersionKind(gvk schema.GroupVersionKind) {
0000000000000000000000000000000000000000;;		obj.TypeMeta.APIVersion, obj.TypeMeta.Kind = gvk.ToAPIVersionAndKind()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (obj *MyAPIObject) GroupVersionKind() schema.GroupVersionKind {
0000000000000000000000000000000000000000;;		return schema.FromAPIVersionAndKind(obj.TypeMeta.APIVersion, obj.TypeMeta.Kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MyIncorrectlyMarkedAsAPIObject struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *MyIncorrectlyMarkedAsAPIObject) GetObjectKind() schema.ObjectKind {
0000000000000000000000000000000000000000;;		return schema.EmptyObjectKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestResourceVersionerOfAPI(t *testing.T) {
0000000000000000000000000000000000000000;;		type T struct {
0000000000000000000000000000000000000000;;			runtime.Object
0000000000000000000000000000000000000000;;			Expected string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testCases := map[string]T{
0000000000000000000000000000000000000000;;			"empty api object":                   {&MyAPIObject{}, ""},
0000000000000000000000000000000000000000;;			"api object with version":            {&MyAPIObject{TypeMeta: InternalTypeMeta{ResourceVersion: "1"}}, "1"},
0000000000000000000000000000000000000000;;			"pointer to api object with version": {&MyAPIObject{TypeMeta: InternalTypeMeta{ResourceVersion: "1"}}, "1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		versioning := meta.NewAccessor()
0000000000000000000000000000000000000000;;		for key, testCase := range testCases {
0000000000000000000000000000000000000000;;			actual, err := versioning.ResourceVersion(testCase.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error %#v", key, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual != testCase.Expected {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", key, testCase.Expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		failingCases := map[string]struct {
0000000000000000000000000000000000000000;;			runtime.Object
0000000000000000000000000000000000000000;;			Expected string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"not a valid object to try": {&MyIncorrectlyMarkedAsAPIObject{}, "1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key, testCase := range failingCases {
0000000000000000000000000000000000000000;;			_, err := versioning.ResourceVersion(testCase.Object)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected error, got nil", key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setCases := map[string]struct {
0000000000000000000000000000000000000000;;			runtime.Object
0000000000000000000000000000000000000000;;			Expected string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"pointer to api object with version": {&MyAPIObject{TypeMeta: InternalTypeMeta{ResourceVersion: "1"}}, "1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key, testCase := range setCases {
0000000000000000000000000000000000000000;;			if err := versioning.SetResourceVersion(testCase.Object, "5"); err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error %#v", key, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actual, err := versioning.ResourceVersion(testCase.Object)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error %#v", key, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actual != "5" {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", key, "5", actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTypeMetaSelfLinker(t *testing.T) {
0000000000000000000000000000000000000000;;		table := map[string]struct {
0000000000000000000000000000000000000000;;			obj     runtime.Object
0000000000000000000000000000000000000000;;			expect  string
0000000000000000000000000000000000000000;;			try     string
0000000000000000000000000000000000000000;;			succeed bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"normal": {
0000000000000000000000000000000000000000;;				obj:     &MyAPIObject{TypeMeta: InternalTypeMeta{SelfLink: "foobar"}},
0000000000000000000000000000000000000000;;				expect:  "foobar",
0000000000000000000000000000000000000000;;				try:     "newbar",
0000000000000000000000000000000000000000;;				succeed: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"fail": {
0000000000000000000000000000000000000000;;				obj:     &MyIncorrectlyMarkedAsAPIObject{},
0000000000000000000000000000000000000000;;				succeed: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		linker := runtime.SelfLinker(meta.NewAccessor())
0000000000000000000000000000000000000000;;		for name, item := range table {
0000000000000000000000000000000000000000;;			got, err := linker.SelfLink(item.obj)
0000000000000000000000000000000000000000;;			if e, a := item.succeed, err == nil; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %v, got %v", name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.expect, got; item.succeed && e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %v, got %v", name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = linker.SetSelfLink(item.obj, item.try)
0000000000000000000000000000000000000000;;			if e, a := item.succeed, err == nil; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %v, got %v", name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if item.succeed {
0000000000000000000000000000000000000000;;				got, err := linker.SelfLink(item.obj)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected no err, got %v", name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := item.try, got; e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected %v, got %v", name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MyAPIObject2 struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta
0000000000000000000000000000000000000000;;		metav1.ObjectMeta
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getObjectMetaAndOwnerReferences() (myAPIObject2 MyAPIObject2, metaOwnerReferences []metav1.OwnerReference) {
0000000000000000000000000000000000000000;;		fuzz.New().NilChance(.5).NumElements(1, 5).Fuzz(&myAPIObject2)
0000000000000000000000000000000000000000;;		references := myAPIObject2.ObjectMeta.OwnerReferences
0000000000000000000000000000000000000000;;		// This is necessary for the test to pass because the getter will return a
0000000000000000000000000000000000000000;;		// non-nil slice.
0000000000000000000000000000000000000000;;		metaOwnerReferences = make([]metav1.OwnerReference, 0)
0000000000000000000000000000000000000000;;		for i := 0; i < len(references); i++ {
0000000000000000000000000000000000000000;;			metaOwnerReferences = append(metaOwnerReferences, metav1.OwnerReference{
0000000000000000000000000000000000000000;;				Kind:               references[i].Kind,
0000000000000000000000000000000000000000;;				Name:               references[i].Name,
0000000000000000000000000000000000000000;;				UID:                references[i].UID,
0000000000000000000000000000000000000000;;				APIVersion:         references[i].APIVersion,
0000000000000000000000000000000000000000;;				Controller:         references[i].Controller,
0000000000000000000000000000000000000000;;				BlockOwnerDeletion: references[i].BlockOwnerDeletion,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(references) == 0 {
0000000000000000000000000000000000000000;;			// This is necessary for the test to pass because the setter will make a
0000000000000000000000000000000000000000;;			// non-nil slice.
0000000000000000000000000000000000000000;;			myAPIObject2.ObjectMeta.OwnerReferences = make([]metav1.OwnerReference, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return myAPIObject2, metaOwnerReferences
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testGetOwnerReferences(t *testing.T) {
0000000000000000000000000000000000000000;;		obj, expected := getObjectMetaAndOwnerReferences()
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(&obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		references := accessor.GetOwnerReferences()
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(references, expected) {
0000000000000000000000000000000000000000;;			t.Errorf("expect %#v\n got %#v", expected, references)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testSetOwnerReferences(t *testing.T) {
0000000000000000000000000000000000000000;;		expected, references := getObjectMetaAndOwnerReferences()
0000000000000000000000000000000000000000;;		obj := MyAPIObject2{}
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(&obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		accessor.SetOwnerReferences(references)
0000000000000000000000000000000000000000;;		if e, a := expected.ObjectMeta.OwnerReferences, obj.ObjectMeta.OwnerReferences; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("expect %#v\n got %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAccessOwnerReferences(t *testing.T) {
0000000000000000000000000000000000000000;;		fuzzIter := 5
0000000000000000000000000000000000000000;;		for i := 0; i < fuzzIter; i++ {
0000000000000000000000000000000000000000;;			testGetOwnerReferences(t)
0000000000000000000000000000000000000000;;			testSetOwnerReferences(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BenchmarkAccessorSetFastPath shows the interface fast path
0000000000000000000000000000000000000000;;	func BenchmarkAccessorSetFastPath(b *testing.B) {
0000000000000000000000000000000000000000;;		obj := &testapigroup.Carp{
0000000000000000000000000000000000000000;;			TypeMeta: metav1.TypeMeta{APIVersion: "/a", Kind: "b"},
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Namespace:       "bar",
0000000000000000000000000000000000000000;;				Name:            "foo",
0000000000000000000000000000000000000000;;				GenerateName:    "prefix",
0000000000000000000000000000000000000000;;				UID:             "uid",
0000000000000000000000000000000000000000;;				ResourceVersion: "1",
0000000000000000000000000000000000000000;;				SelfLink:        "some/place/only/we/know",
0000000000000000000000000000000000000000;;				Labels:          map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				Annotations:     map[string]string{"x": "y"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ResetTimer()
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			acc, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				b.Fatal(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			acc.SetNamespace("something")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.StopTimer()
0000000000000000000000000000000000000000;;	}
