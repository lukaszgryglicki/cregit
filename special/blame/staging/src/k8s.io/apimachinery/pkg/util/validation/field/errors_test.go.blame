0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package field
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMakeFuncs(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			fn       func() *Error
0000000000000000000000000000000000000000;;			expected ErrorType
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				func() *Error { return Invalid(NewPath("f"), "v", "d") },
0000000000000000000000000000000000000000;;				ErrorTypeInvalid,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				func() *Error { return NotSupported(NewPath("f"), "v", nil) },
0000000000000000000000000000000000000000;;				ErrorTypeNotSupported,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				func() *Error { return Duplicate(NewPath("f"), "v") },
0000000000000000000000000000000000000000;;				ErrorTypeDuplicate,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				func() *Error { return NotFound(NewPath("f"), "v") },
0000000000000000000000000000000000000000;;				ErrorTypeNotFound,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				func() *Error { return Required(NewPath("f"), "d") },
0000000000000000000000000000000000000000;;				ErrorTypeRequired,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				func() *Error { return InternalError(NewPath("f"), fmt.Errorf("e")) },
0000000000000000000000000000000000000000;;				ErrorTypeInternal,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			err := testCase.fn()
0000000000000000000000000000000000000000;;			if err.Type != testCase.expected {
0000000000000000000000000000000000000000;;				t.Errorf("expected Type %q, got %q", testCase.expected, err.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestErrorUsefulMessage(t *testing.T) {
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			s := Invalid(nil, nil, "").Error()
0000000000000000000000000000000000000000;;			t.Logf("message: %v", s)
0000000000000000000000000000000000000000;;			if !strings.Contains(s, "null") {
0000000000000000000000000000000000000000;;				t.Errorf("error message did not contain 'null': %s", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := Invalid(NewPath("foo"), "bar", "deet").Error()
0000000000000000000000000000000000000000;;		t.Logf("message: %v", s)
0000000000000000000000000000000000000000;;		for _, part := range []string{"foo", "bar", "deet", ErrorTypeInvalid.String()} {
0000000000000000000000000000000000000000;;			if !strings.Contains(s, part) {
0000000000000000000000000000000000000000;;				t.Errorf("error message did not contain expected part '%v'", part)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type complicated struct {
0000000000000000000000000000000000000000;;			Baz   int
0000000000000000000000000000000000000000;;			Qux   string
0000000000000000000000000000000000000000;;			Inner interface{}
0000000000000000000000000000000000000000;;			KV    map[string]int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s = Invalid(
0000000000000000000000000000000000000000;;			NewPath("foo"),
0000000000000000000000000000000000000000;;			&complicated{
0000000000000000000000000000000000000000;;				Baz:   1,
0000000000000000000000000000000000000000;;				Qux:   "aoeu",
0000000000000000000000000000000000000000;;				Inner: &complicated{Qux: "asdf"},
0000000000000000000000000000000000000000;;				KV:    map[string]int{"Billy": 2},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"detail",
0000000000000000000000000000000000000000;;		).Error()
0000000000000000000000000000000000000000;;		t.Logf("message: %v", s)
0000000000000000000000000000000000000000;;		for _, part := range []string{
0000000000000000000000000000000000000000;;			"foo", ErrorTypeInvalid.String(),
0000000000000000000000000000000000000000;;			"Baz", "Qux", "Inner", "KV", "detail",
0000000000000000000000000000000000000000;;			"1", "aoeu", "Billy", "2",
0000000000000000000000000000000000000000;;			// "asdf", TODO: reenable once we have a better nested printer
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			if !strings.Contains(s, part) {
0000000000000000000000000000000000000000;;				t.Errorf("error message did not contain expected part '%v'", part)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestToAggregate(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := struct {
0000000000000000000000000000000000000000;;			ErrList         []ErrorList
0000000000000000000000000000000000000000;;			NumExpectedErrs []int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			[]ErrorList{
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				{},
0000000000000000000000000000000000000000;;				{Invalid(NewPath("f"), "v", "d")},
0000000000000000000000000000000000000000;;				{Invalid(NewPath("f"), "v", "d"), Invalid(NewPath("f"), "v", "d")},
0000000000000000000000000000000000000000;;				{Invalid(NewPath("f"), "v", "d"), InternalError(NewPath(""), fmt.Errorf("e"))},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			[]int{
0000000000000000000000000000000000000000;;				0,
0000000000000000000000000000000000000000;;				0,
0000000000000000000000000000000000000000;;				1,
0000000000000000000000000000000000000000;;				1,
0000000000000000000000000000000000000000;;				2,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(testCases.ErrList) != len(testCases.NumExpectedErrs) {
0000000000000000000000000000000000000000;;			t.Errorf("Mismatch: length of NumExpectedErrs does not match length of ErrList")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, tc := range testCases.ErrList {
0000000000000000000000000000000000000000;;			agg := tc.ToAggregate()
0000000000000000000000000000000000000000;;			numErrs := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if agg != nil {
0000000000000000000000000000000000000000;;				numErrs = len(agg.Errors())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if numErrs != testCases.NumExpectedErrs[i] {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] Expected %d, got %d", i, testCases.NumExpectedErrs[i], numErrs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(tc) == 0 {
0000000000000000000000000000000000000000;;				if agg != nil {
0000000000000000000000000000000000000000;;					t.Errorf("[%d] Expected nil, got %#v", i, agg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if agg == nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] Expected non-nil", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestErrListFilter(t *testing.T) {
0000000000000000000000000000000000000000;;		list := ErrorList{
0000000000000000000000000000000000000000;;			Invalid(NewPath("test.field"), "", ""),
0000000000000000000000000000000000000000;;			Invalid(NewPath("field.test"), "", ""),
0000000000000000000000000000000000000000;;			Duplicate(NewPath("test"), "value"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(list.Filter(NewErrorTypeMatcher(ErrorTypeDuplicate))) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("should not filter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(list.Filter(NewErrorTypeMatcher(ErrorTypeInvalid))) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("should filter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
