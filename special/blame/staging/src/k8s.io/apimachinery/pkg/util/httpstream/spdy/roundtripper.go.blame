0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
351764b6cae066588e87a3efee44135d8f7e8120;pkg/util/httpstream/spdy/roundtripper.go[pkg/util/httpstream/spdy/roundtripper.go][staging/src/k8s.io/apimachinery/pkg/util/httpstream/spdy/roundtripper.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package spdy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httputil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/third_party/forked/golang/netutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SpdyRoundTripper knows how to upgrade an HTTP request to one that supports
0000000000000000000000000000000000000000;;	// multiplexed streams. After RoundTrip() is invoked, Conn will be set
0000000000000000000000000000000000000000;;	// and usable. SpdyRoundTripper implements the UpgradeRoundTripper interface.
0000000000000000000000000000000000000000;;	type SpdyRoundTripper struct {
0000000000000000000000000000000000000000;;		//tlsConfig holds the TLS configuration settings to use when connecting
0000000000000000000000000000000000000000;;		//to the remote server.
0000000000000000000000000000000000000000;;		tlsConfig *tls.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* TODO according to http://golang.org/pkg/net/http/#RoundTripper, a RoundTripper
0000000000000000000000000000000000000000;;		   must be safe for use by multiple concurrent goroutines. If this is absolutely
0000000000000000000000000000000000000000;;		   necessary, we could keep a map from http.Request to net.Conn. In practice,
0000000000000000000000000000000000000000;;		   a client will create an http.Client, set the transport to a new insteace of
0000000000000000000000000000000000000000;;		   SpdyRoundTripper, and use it a single time, so this hopefully won't be an issue.
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		// conn is the underlying network connection to the remote server.
0000000000000000000000000000000000000000;;		conn net.Conn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dialer is the dialer used to connect.  Used if non-nil.
0000000000000000000000000000000000000000;;		Dialer *net.Dialer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// proxier knows which proxy to use given a request, defaults to http.ProxyFromEnvironment
0000000000000000000000000000000000000000;;		// Used primarily for mocking the proxy discovery in tests.
0000000000000000000000000000000000000000;;		proxier func(req *http.Request) (*url.URL, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// followRedirects indicates if the round tripper should examine responses for redirects and
0000000000000000000000000000000000000000;;		// follow them.
0000000000000000000000000000000000000000;;		followRedirects bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ utilnet.TLSClientConfigHolder = &SpdyRoundTripper{}
0000000000000000000000000000000000000000;;	var _ httpstream.UpgradeRoundTripper = &SpdyRoundTripper{}
0000000000000000000000000000000000000000;;	var _ utilnet.Dialer = &SpdyRoundTripper{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRoundTripper creates a new SpdyRoundTripper that will use
0000000000000000000000000000000000000000;;	// the specified tlsConfig.
0000000000000000000000000000000000000000;;	func NewRoundTripper(tlsConfig *tls.Config, followRedirects bool) httpstream.UpgradeRoundTripper {
0000000000000000000000000000000000000000;;		return NewSpdyRoundTripper(tlsConfig, followRedirects)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSpdyRoundTripper creates a new SpdyRoundTripper that will use
0000000000000000000000000000000000000000;;	// the specified tlsConfig. This function is mostly meant for unit tests.
0000000000000000000000000000000000000000;;	func NewSpdyRoundTripper(tlsConfig *tls.Config, followRedirects bool) *SpdyRoundTripper {
0000000000000000000000000000000000000000;;		return &SpdyRoundTripper{tlsConfig: tlsConfig, followRedirects: followRedirects}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TLSClientConfig implements pkg/util/net.TLSClientConfigHolder for proper TLS checking during
0000000000000000000000000000000000000000;;	// proxying with a spdy roundtripper.
0000000000000000000000000000000000000000;;	func (s *SpdyRoundTripper) TLSClientConfig() *tls.Config {
0000000000000000000000000000000000000000;;		return s.tlsConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial implements k8s.io/apimachinery/pkg/util/net.Dialer.
0000000000000000000000000000000000000000;;	func (s *SpdyRoundTripper) Dial(req *http.Request) (net.Conn, error) {
0000000000000000000000000000000000000000;;		conn, err := s.dial(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := req.Write(conn); err != nil {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dial dials the host specified by req, using TLS if appropriate, optionally
0000000000000000000000000000000000000000;;	// using a proxy server if one is configured via environment variables.
0000000000000000000000000000000000000000;;	func (s *SpdyRoundTripper) dial(req *http.Request) (net.Conn, error) {
0000000000000000000000000000000000000000;;		proxier := s.proxier
0000000000000000000000000000000000000000;;		if proxier == nil {
0000000000000000000000000000000000000000;;			proxier = http.ProxyFromEnvironment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxyURL, err := proxier(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if proxyURL == nil {
0000000000000000000000000000000000000000;;			return s.dialWithoutProxy(req.URL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure we use a canonical host with proxyReq
0000000000000000000000000000000000000000;;		targetHost := netutil.CanonicalAddr(req.URL)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// proxying logic adapted from http://blog.h6t.eu/post/74098062923/golang-websocket-with-http-proxy-support
0000000000000000000000000000000000000000;;		proxyReq := http.Request{
0000000000000000000000000000000000000000;;			Method: "CONNECT",
0000000000000000000000000000000000000000;;			URL:    &url.URL{},
0000000000000000000000000000000000000000;;			Host:   targetHost,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pa := s.proxyAuth(proxyURL); pa != "" {
0000000000000000000000000000000000000000;;			proxyReq.Header = http.Header{}
0000000000000000000000000000000000000000;;			proxyReq.Header.Set("Proxy-Authorization", pa)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyDialConn, err := s.dialWithoutProxy(proxyURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyClientConn := httputil.NewProxyClientConn(proxyDialConn, nil)
0000000000000000000000000000000000000000;;		_, err = proxyClientConn.Do(&proxyReq)
0000000000000000000000000000000000000000;;		if err != nil && err != httputil.ErrPersistEOF {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rwc, _ := proxyClientConn.Hijack()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if req.URL.Scheme != "https" {
0000000000000000000000000000000000000000;;			return rwc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host, _, err := net.SplitHostPort(targetHost)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.tlsConfig == nil {
0000000000000000000000000000000000000000;;			s.tlsConfig = &tls.Config{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(s.tlsConfig.ServerName) == 0 {
0000000000000000000000000000000000000000;;			s.tlsConfig.ServerName = host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsConn := tls.Client(rwc, s.tlsConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// need to manually call Handshake() so we can call VerifyHostname() below
0000000000000000000000000000000000000000;;		if err := tlsConn.Handshake(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return if we were configured to skip validation
0000000000000000000000000000000000000000;;		if s.tlsConfig != nil && s.tlsConfig.InsecureSkipVerify {
0000000000000000000000000000000000000000;;			return tlsConn, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := tlsConn.VerifyHostname(host); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tlsConn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dialWithoutProxy dials the host specified by url, using TLS if appropriate.
0000000000000000000000000000000000000000;;	func (s *SpdyRoundTripper) dialWithoutProxy(url *url.URL) (net.Conn, error) {
0000000000000000000000000000000000000000;;		dialAddr := netutil.CanonicalAddr(url)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if url.Scheme == "http" {
0000000000000000000000000000000000000000;;			if s.Dialer == nil {
0000000000000000000000000000000000000000;;				return net.Dial("tcp", dialAddr)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return s.Dialer.Dial("tcp", dialAddr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO validate the TLSClientConfig is set up?
0000000000000000000000000000000000000000;;		var conn *tls.Conn
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if s.Dialer == nil {
0000000000000000000000000000000000000000;;			conn, err = tls.Dial("tcp", dialAddr, s.tlsConfig)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			conn, err = tls.DialWithDialer(s.Dialer, "tcp", dialAddr, s.tlsConfig)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return if we were configured to skip validation
0000000000000000000000000000000000000000;;		if s.tlsConfig != nil && s.tlsConfig.InsecureSkipVerify {
0000000000000000000000000000000000000000;;			return conn, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host, _, err := net.SplitHostPort(dialAddr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = conn.VerifyHostname(host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// proxyAuth returns, for a given proxy URL, the value to be used for the Proxy-Authorization header
0000000000000000000000000000000000000000;;	func (s *SpdyRoundTripper) proxyAuth(proxyURL *url.URL) string {
0000000000000000000000000000000000000000;;		if proxyURL == nil || proxyURL.User == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		credentials := proxyURL.User.String()
0000000000000000000000000000000000000000;;		encodedAuth := base64.StdEncoding.EncodeToString([]byte(credentials))
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Basic %s", encodedAuth)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTrip executes the Request and upgrades it. After a successful upgrade,
0000000000000000000000000000000000000000;;	// clients may call SpdyRoundTripper.Connection() to retrieve the upgraded
0000000000000000000000000000000000000000;;	// connection.
0000000000000000000000000000000000000000;;	func (s *SpdyRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		header := utilnet.CloneHeader(req.Header)
0000000000000000000000000000000000000000;;		header.Add(httpstream.HeaderConnection, httpstream.HeaderUpgrade)
0000000000000000000000000000000000000000;;		header.Add(httpstream.HeaderUpgrade, HeaderSpdy31)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			conn        net.Conn
0000000000000000000000000000000000000000;;			rawResponse []byte
0000000000000000000000000000000000000000;;			err         error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.followRedirects {
0000000000000000000000000000000000000000;;			conn, rawResponse, err = utilnet.ConnectWithRedirects(req.Method, req.URL, header, req.Body, s)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			clone := utilnet.CloneRequest(req)
0000000000000000000000000000000000000000;;			clone.Header = header
0000000000000000000000000000000000000000;;			conn, err = s.Dial(clone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		responseReader := bufio.NewReader(
0000000000000000000000000000000000000000;;			io.MultiReader(
0000000000000000000000000000000000000000;;				bytes.NewBuffer(rawResponse),
0000000000000000000000000000000000000000;;				conn,
0000000000000000000000000000000000000000;;			),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.ReadResponse(responseReader, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if conn != nil {
0000000000000000000000000000000000000000;;				conn.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.conn = conn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConnection validates the upgrade response, creating and returning a new
0000000000000000000000000000000000000000;;	// httpstream.Connection if there were no errors.
0000000000000000000000000000000000000000;;	func (s *SpdyRoundTripper) NewConnection(resp *http.Response) (httpstream.Connection, error) {
0000000000000000000000000000000000000000;;		connectionHeader := strings.ToLower(resp.Header.Get(httpstream.HeaderConnection))
0000000000000000000000000000000000000000;;		upgradeHeader := strings.ToLower(resp.Header.Get(httpstream.HeaderUpgrade))
0000000000000000000000000000000000000000;;		if (resp.StatusCode != http.StatusSwitchingProtocols) || !strings.Contains(connectionHeader, strings.ToLower(httpstream.HeaderUpgrade)) || !strings.Contains(upgradeHeader, strings.ToLower(HeaderSpdy31)) {
0000000000000000000000000000000000000000;;			defer resp.Body.Close()
0000000000000000000000000000000000000000;;			responseError := ""
0000000000000000000000000000000000000000;;			responseErrorBytes, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				responseError = "unable to read error from server response"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// TODO: I don't belong here, I should be abstracted from this class
0000000000000000000000000000000000000000;;				if obj, _, err := statusCodecs.UniversalDecoder().Decode(responseErrorBytes, nil, &metav1.Status{}); err == nil {
0000000000000000000000000000000000000000;;					if status, ok := obj.(*metav1.Status); ok {
0000000000000000000000000000000000000000;;						return nil, &apierrors.StatusError{ErrStatus: *status}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				responseError = string(responseErrorBytes)
0000000000000000000000000000000000000000;;				responseError = strings.TrimSpace(responseError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to upgrade connection: %s", responseError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewClientConnection(s.conn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// statusScheme is private scheme for the decoding here until someone fixes the TODO in NewConnection
0000000000000000000000000000000000000000;;	var statusScheme = runtime.NewScheme()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParameterCodec knows about query parameters used with the meta v1 API spec.
0000000000000000000000000000000000000000;;	var statusCodecs = serializer.NewCodecFactory(statusScheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		statusScheme.AddUnversionedTypes(metav1.SchemeGroupVersion,
0000000000000000000000000000000000000000;;			&metav1.Status{},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
