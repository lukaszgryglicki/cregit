0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package wait
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For any test of the style:
0000000000000000000000000000000000000000;;	//   ...
0000000000000000000000000000000000000000;;	//   <- time.After(timeout):
0000000000000000000000000000000000000000;;	//      t.Errorf("Timed out")
0000000000000000000000000000000000000000;;	// The value for timeout should effectively be "forever." Obviously we don't want our tests to truly lock up forever, but 30s
0000000000000000000000000000000000000000;;	// is long enough that it is effectively forever for the things that can slow down a run on a heavily contended machine
0000000000000000000000000000000000000000;;	// (GC, seeks, etc), but not so long as to make a developer ctrl-c a test run if they do happen to break that test.
0000000000000000000000000000000000000000;;	var ForeverTestTimeout = time.Second * 30
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NeverStop may be passed to Until to make it never stop.
0000000000000000000000000000000000000000;;	var NeverStop <-chan struct{} = make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Forever calls f every period for ever.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Forever is syntactic sugar on top of Until.
0000000000000000000000000000000000000000;;	func Forever(f func(), period time.Duration) {
0000000000000000000000000000000000000000;;		Until(f, period, NeverStop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Until loops until stop channel is closed, running f every period.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Until is syntactic sugar on top of JitterUntil with zero jitter factor and
0000000000000000000000000000000000000000;;	// with sliding = true (which means the timer for period starts after the f
0000000000000000000000000000000000000000;;	// completes).
0000000000000000000000000000000000000000;;	func Until(f func(), period time.Duration, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		JitterUntil(f, period, 0.0, true, stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NonSlidingUntil loops until stop channel is closed, running f every
0000000000000000000000000000000000000000;;	// period.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NonSlidingUntil is syntactic sugar on top of JitterUntil with zero jitter
0000000000000000000000000000000000000000;;	// factor, with sliding = false (meaning the timer for period starts at the same
0000000000000000000000000000000000000000;;	// time as the function starts).
0000000000000000000000000000000000000000;;	func NonSlidingUntil(f func(), period time.Duration, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		JitterUntil(f, period, 0.0, false, stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JitterUntil loops until stop channel is closed, running f every period.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If jitterFactor is positive, the period is jittered before every run of f.
0000000000000000000000000000000000000000;;	// If jitterFactor is not positive, the period is unchanged and not jittered.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If sliding is true, the period is computed after f runs. If it is false then
0000000000000000000000000000000000000000;;	// period includes the runtime for f.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Close stopCh to stop. f may not be invoked if stop channel is already
0000000000000000000000000000000000000000;;	// closed. Pass NeverStop to if you don't want it stop.
0000000000000000000000000000000000000000;;	func JitterUntil(f func(), period time.Duration, jitterFactor float64, sliding bool, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		var t *time.Timer
0000000000000000000000000000000000000000;;		var sawTimeout bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			jitteredPeriod := period
0000000000000000000000000000000000000000;;			if jitterFactor > 0.0 {
0000000000000000000000000000000000000000;;				jitteredPeriod = Jitter(period, jitterFactor)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !sliding {
0000000000000000000000000000000000000000;;				t = resetOrReuseTimer(t, jitteredPeriod, sawTimeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;				f()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if sliding {
0000000000000000000000000000000000000000;;				t = resetOrReuseTimer(t, jitteredPeriod, sawTimeout)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// NOTE: b/c there is no priority selection in golang
0000000000000000000000000000000000000000;;			// it is possible for this to race, meaning we could
0000000000000000000000000000000000000000;;			// trigger t.C and stopCh, and t.C select falls through.
0000000000000000000000000000000000000000;;			// In order to mitigate we re-check stopCh at the beginning
0000000000000000000000000000000000000000;;			// of every loop to prevent extra executions of f().
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-t.C:
0000000000000000000000000000000000000000;;				sawTimeout = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Jitter returns a time.Duration between duration and duration + maxFactor *
0000000000000000000000000000000000000000;;	// duration.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This allows clients to avoid converging on periodic behavior. If maxFactor
0000000000000000000000000000000000000000;;	// is 0.0, a suggested default value will be chosen.
0000000000000000000000000000000000000000;;	func Jitter(duration time.Duration, maxFactor float64) time.Duration {
0000000000000000000000000000000000000000;;		if maxFactor <= 0.0 {
0000000000000000000000000000000000000000;;			maxFactor = 1.0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wait := duration + time.Duration(rand.Float64()*maxFactor*float64(duration))
0000000000000000000000000000000000000000;;		return wait
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrWaitTimeout is returned when the condition exited without success.
0000000000000000000000000000000000000000;;	var ErrWaitTimeout = errors.New("timed out waiting for the condition")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConditionFunc returns true if the condition is satisfied, or an error
0000000000000000000000000000000000000000;;	// if the loop should be aborted.
0000000000000000000000000000000000000000;;	type ConditionFunc func() (done bool, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Backoff holds parameters applied to a Backoff function.
0000000000000000000000000000000000000000;;	type Backoff struct {
0000000000000000000000000000000000000000;;		Duration time.Duration // the base duration
0000000000000000000000000000000000000000;;		Factor   float64       // Duration is multiplied by factor each iteration
0000000000000000000000000000000000000000;;		Jitter   float64       // The amount of jitter applied each iteration
0000000000000000000000000000000000000000;;		Steps    int           // Exit with error after this many steps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExponentialBackoff repeats a condition check with exponential backoff.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It checks the condition up to Steps times, increasing the wait by multiplying
0000000000000000000000000000000000000000;;	// the previous duration by Factor.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If Jitter is greater than zero, a random amount of each duration is added
0000000000000000000000000000000000000000;;	// (between duration and duration*(1+jitter)).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the condition never returns true, ErrWaitTimeout is returned. All other
0000000000000000000000000000000000000000;;	// errors terminate immediately.
0000000000000000000000000000000000000000;;	func ExponentialBackoff(backoff Backoff, condition ConditionFunc) error {
0000000000000000000000000000000000000000;;		duration := backoff.Duration
0000000000000000000000000000000000000000;;		for i := 0; i < backoff.Steps; i++ {
0000000000000000000000000000000000000000;;			if i != 0 {
0000000000000000000000000000000000000000;;				adjusted := duration
0000000000000000000000000000000000000000;;				if backoff.Jitter > 0.0 {
0000000000000000000000000000000000000000;;					adjusted = Jitter(duration, backoff.Jitter)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(adjusted)
0000000000000000000000000000000000000000;;				duration = time.Duration(float64(duration) * backoff.Factor)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok, err := condition(); err != nil || ok {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ErrWaitTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Poll tries a condition func until it returns true, an error, or the timeout
0000000000000000000000000000000000000000;;	// is reached.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Poll always waits the interval before the run of 'condition'.
0000000000000000000000000000000000000000;;	// 'condition' will always be invoked at least once.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some intervals may be missed if the condition takes too long or the time
0000000000000000000000000000000000000000;;	// window is too short.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If you want to Poll something forever, see PollInfinite.
0000000000000000000000000000000000000000;;	func Poll(interval, timeout time.Duration, condition ConditionFunc) error {
0000000000000000000000000000000000000000;;		return pollInternal(poller(interval, timeout), condition)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pollInternal(wait WaitFunc, condition ConditionFunc) error {
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(done)
0000000000000000000000000000000000000000;;		return WaitFor(wait, condition, done)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PollImmediate tries a condition func until it returns true, an error, or the timeout
0000000000000000000000000000000000000000;;	// is reached.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Poll always checks 'condition' before waiting for the interval. 'condition'
0000000000000000000000000000000000000000;;	// will always be invoked at least once.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some intervals may be missed if the condition takes too long or the time
0000000000000000000000000000000000000000;;	// window is too short.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If you want to Poll something forever, see PollInfinite.
0000000000000000000000000000000000000000;;	func PollImmediate(interval, timeout time.Duration, condition ConditionFunc) error {
0000000000000000000000000000000000000000;;		return pollImmediateInternal(poller(interval, timeout), condition)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pollImmediateInternal(wait WaitFunc, condition ConditionFunc) error {
0000000000000000000000000000000000000000;;		done, err := condition()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if done {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pollInternal(wait, condition)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PollInfinite tries a condition func until it returns true or an error
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// PollInfinite always waits the interval before the run of 'condition'.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some intervals may be missed if the condition takes too long or the time
0000000000000000000000000000000000000000;;	// window is too short.
0000000000000000000000000000000000000000;;	func PollInfinite(interval time.Duration, condition ConditionFunc) error {
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(done)
0000000000000000000000000000000000000000;;		return PollUntil(interval, condition, done)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PollImmediateInfinite tries a condition func until it returns true or an error
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// PollImmediateInfinite runs the 'condition' before waiting for the interval.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some intervals may be missed if the condition takes too long or the time
0000000000000000000000000000000000000000;;	// window is too short.
0000000000000000000000000000000000000000;;	func PollImmediateInfinite(interval time.Duration, condition ConditionFunc) error {
0000000000000000000000000000000000000000;;		done, err := condition()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if done {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return PollInfinite(interval, condition)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PollUntil tries a condition func until it returns true, an error or stopCh is
0000000000000000000000000000000000000000;;	// closed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// PolUntil always waits interval before the first run of 'condition'.
0000000000000000000000000000000000000000;;	// 'condition' will always be invoked at least once.
0000000000000000000000000000000000000000;;	func PollUntil(interval time.Duration, condition ConditionFunc, stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		return WaitFor(poller(interval, 0), condition, stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitFunc creates a channel that receives an item every time a test
0000000000000000000000000000000000000000;;	// should be executed and is closed when the last test should be invoked.
0000000000000000000000000000000000000000;;	type WaitFunc func(done <-chan struct{}) <-chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitFor continually checks 'fn' as driven by 'wait'.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// WaitFor gets a channel from 'wait()'', and then invokes 'fn' once for every value
0000000000000000000000000000000000000000;;	// placed on the channel and once more when the channel is closed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If 'fn' returns an error the loop ends and that error is returned, and if
0000000000000000000000000000000000000000;;	// 'fn' returns true the loop ends and nil is returned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ErrWaitTimeout will be returned if the channel is closed without fn ever
0000000000000000000000000000000000000000;;	// returning true.
0000000000000000000000000000000000000000;;	func WaitFor(wait WaitFunc, fn ConditionFunc, done <-chan struct{}) error {
0000000000000000000000000000000000000000;;		c := wait(done)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			_, open := <-c
0000000000000000000000000000000000000000;;			ok, err := fn()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !open {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ErrWaitTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// poller returns a WaitFunc that will send to the channel every interval until
0000000000000000000000000000000000000000;;	// timeout has elapsed and then closes the channel.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Over very short intervals you may receive no ticks before the channel is
0000000000000000000000000000000000000000;;	// closed. A timeout of 0 is interpreted as an infinity.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Output ticks are not buffered. If the channel is not ready to receive an
0000000000000000000000000000000000000000;;	// item, the tick is skipped.
0000000000000000000000000000000000000000;;	func poller(interval, timeout time.Duration) WaitFunc {
0000000000000000000000000000000000000000;;		return WaitFunc(func(done <-chan struct{}) <-chan struct{} {
0000000000000000000000000000000000000000;;			ch := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer close(ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				tick := time.NewTicker(interval)
0000000000000000000000000000000000000000;;				defer tick.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var after <-chan time.Time
0000000000000000000000000000000000000000;;				if timeout != 0 {
0000000000000000000000000000000000000000;;					// time.After is more convenient, but it
0000000000000000000000000000000000000000;;					// potentially leaves timers around much longer
0000000000000000000000000000000000000000;;					// than necessary if we exit early.
0000000000000000000000000000000000000000;;					timer := time.NewTimer(timeout)
0000000000000000000000000000000000000000;;					after = timer.C
0000000000000000000000000000000000000000;;					defer timer.Stop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case <-tick.C:
0000000000000000000000000000000000000000;;						// If the consumer isn't ready for this signal drop it and
0000000000000000000000000000000000000000;;						// check the other channels.
0000000000000000000000000000000000000000;;						select {
0000000000000000000000000000000000000000;;						case ch <- struct{}{}:
0000000000000000000000000000000000000000;;						default:
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case <-after:
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					case <-done:
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ch
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resetOrReuseTimer avoids allocating a new timer if one is already in use.
0000000000000000000000000000000000000000;;	// Not safe for multiple threads.
0000000000000000000000000000000000000000;;	func resetOrReuseTimer(t *time.Timer, d time.Duration, sawTimeout bool) *time.Timer {
0000000000000000000000000000000000000000;;		if t == nil {
0000000000000000000000000000000000000000;;			return time.NewTimer(d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !t.Stop() && !sawTimeout {
0000000000000000000000000000000000000000;;			<-t.C
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Reset(d)
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
