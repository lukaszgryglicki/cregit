0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package field
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error is an implementation of the 'error' interface, which represents a
0000000000000000000000000000000000000000;;	// field-level validation error.
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		Type     ErrorType
0000000000000000000000000000000000000000;;		Field    string
0000000000000000000000000000000000000000;;		BadValue interface{}
0000000000000000000000000000000000000000;;		Detail   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ error = &Error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error implements the error interface.
0000000000000000000000000000000000000000;;	func (v *Error) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s: %s", v.Field, v.ErrorBody())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorBody returns the error message without the field name.  This is useful
0000000000000000000000000000000000000000;;	// for building nice-looking higher-level error reporting.
0000000000000000000000000000000000000000;;	func (v *Error) ErrorBody() string {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		switch v.Type {
0000000000000000000000000000000000000000;;		case ErrorTypeRequired, ErrorTypeForbidden, ErrorTypeTooLong, ErrorTypeInternal:
0000000000000000000000000000000000000000;;			s = fmt.Sprintf("%s", v.Type)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			value := v.BadValue
0000000000000000000000000000000000000000;;			valueType := reflect.TypeOf(value)
0000000000000000000000000000000000000000;;			if value == nil || valueType == nil {
0000000000000000000000000000000000000000;;				value = "null"
0000000000000000000000000000000000000000;;			} else if valueType.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				if reflectValue := reflect.ValueOf(value); reflectValue.IsNil() {
0000000000000000000000000000000000000000;;					value = "null"
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					value = reflectValue.Elem().Interface()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t := value.(type) {
0000000000000000000000000000000000000000;;			case int64, int32, float64, float32, bool:
0000000000000000000000000000000000000000;;				// use simple printer for simple types
0000000000000000000000000000000000000000;;				s = fmt.Sprintf("%s: %v", v.Type, value)
0000000000000000000000000000000000000000;;			case string:
0000000000000000000000000000000000000000;;				s = fmt.Sprintf("%s: %q", v.Type, t)
0000000000000000000000000000000000000000;;			case fmt.Stringer:
0000000000000000000000000000000000000000;;				// anything that defines String() is better than raw struct
0000000000000000000000000000000000000000;;				s = fmt.Sprintf("%s: %s", v.Type, t.String())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// fallback to raw struct
0000000000000000000000000000000000000000;;				// TODO: internal types have panic guards against json.Marshalling to prevent
0000000000000000000000000000000000000000;;				// accidental use of internal types in external serialized form.  For now, use
0000000000000000000000000000000000000000;;				// %#v, although it would be better to show a more expressive output in the future
0000000000000000000000000000000000000000;;				s = fmt.Sprintf("%s: %#v", v.Type, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(v.Detail) != 0 {
0000000000000000000000000000000000000000;;			s += fmt.Sprintf(": %s", v.Detail)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorType is a machine readable value providing more detail about why
0000000000000000000000000000000000000000;;	// a field is invalid.  These values are expected to match 1-1 with
0000000000000000000000000000000000000000;;	// CauseType in api/types.go.
0000000000000000000000000000000000000000;;	type ErrorType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: These values are duplicated in api/types.go, but there's a circular dep.  Fix it.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ErrorTypeNotFound is used to report failure to find a requested value
0000000000000000000000000000000000000000;;		// (e.g. looking up an ID).  See NotFound().
0000000000000000000000000000000000000000;;		ErrorTypeNotFound ErrorType = "FieldValueNotFound"
0000000000000000000000000000000000000000;;		// ErrorTypeRequired is used to report required values that are not
0000000000000000000000000000000000000000;;		// provided (e.g. empty strings, null values, or empty arrays).  See
0000000000000000000000000000000000000000;;		// Required().
0000000000000000000000000000000000000000;;		ErrorTypeRequired ErrorType = "FieldValueRequired"
0000000000000000000000000000000000000000;;		// ErrorTypeDuplicate is used to report collisions of values that must be
0000000000000000000000000000000000000000;;		// unique (e.g. unique IDs).  See Duplicate().
0000000000000000000000000000000000000000;;		ErrorTypeDuplicate ErrorType = "FieldValueDuplicate"
0000000000000000000000000000000000000000;;		// ErrorTypeInvalid is used to report malformed values (e.g. failed regex
0000000000000000000000000000000000000000;;		// match, too long, out of bounds).  See Invalid().
0000000000000000000000000000000000000000;;		ErrorTypeInvalid ErrorType = "FieldValueInvalid"
0000000000000000000000000000000000000000;;		// ErrorTypeNotSupported is used to report unknown values for enumerated
0000000000000000000000000000000000000000;;		// fields (e.g. a list of valid values).  See NotSupported().
0000000000000000000000000000000000000000;;		ErrorTypeNotSupported ErrorType = "FieldValueNotSupported"
0000000000000000000000000000000000000000;;		// ErrorTypeForbidden is used to report valid (as per formatting rules)
0000000000000000000000000000000000000000;;		// values which would be accepted under some conditions, but which are not
0000000000000000000000000000000000000000;;		// permitted by the current conditions (such as security policy).  See
0000000000000000000000000000000000000000;;		// Forbidden().
0000000000000000000000000000000000000000;;		ErrorTypeForbidden ErrorType = "FieldValueForbidden"
0000000000000000000000000000000000000000;;		// ErrorTypeTooLong is used to report that the given value is too long.
0000000000000000000000000000000000000000;;		// This is similar to ErrorTypeInvalid, but the error will not include the
0000000000000000000000000000000000000000;;		// too-long value.  See TooLong().
0000000000000000000000000000000000000000;;		ErrorTypeTooLong ErrorType = "FieldValueTooLong"
0000000000000000000000000000000000000000;;		// ErrorTypeInternal is used to report other errors that are not related
0000000000000000000000000000000000000000;;		// to user input.  See InternalError().
0000000000000000000000000000000000000000;;		ErrorTypeInternal ErrorType = "InternalError"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String converts a ErrorType into its corresponding canonical error message.
0000000000000000000000000000000000000000;;	func (t ErrorType) String() string {
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case ErrorTypeNotFound:
0000000000000000000000000000000000000000;;			return "Not found"
0000000000000000000000000000000000000000;;		case ErrorTypeRequired:
0000000000000000000000000000000000000000;;			return "Required value"
0000000000000000000000000000000000000000;;		case ErrorTypeDuplicate:
0000000000000000000000000000000000000000;;			return "Duplicate value"
0000000000000000000000000000000000000000;;		case ErrorTypeInvalid:
0000000000000000000000000000000000000000;;			return "Invalid value"
0000000000000000000000000000000000000000;;		case ErrorTypeNotSupported:
0000000000000000000000000000000000000000;;			return "Unsupported value"
0000000000000000000000000000000000000000;;		case ErrorTypeForbidden:
0000000000000000000000000000000000000000;;			return "Forbidden"
0000000000000000000000000000000000000000;;		case ErrorTypeTooLong:
0000000000000000000000000000000000000000;;			return "Too long"
0000000000000000000000000000000000000000;;		case ErrorTypeInternal:
0000000000000000000000000000000000000000;;			return "Internal error"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unrecognized validation error: %q", string(t)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotFound returns a *Error indicating "value not found".  This is
0000000000000000000000000000000000000000;;	// used to report failure to find a requested value (e.g. looking up an ID).
0000000000000000000000000000000000000000;;	func NotFound(field *Path, value interface{}) *Error {
0000000000000000000000000000000000000000;;		return &Error{ErrorTypeNotFound, field.String(), value, ""}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Required returns a *Error indicating "value required".  This is used
0000000000000000000000000000000000000000;;	// to report required values that are not provided (e.g. empty strings, null
0000000000000000000000000000000000000000;;	// values, or empty arrays).
0000000000000000000000000000000000000000;;	func Required(field *Path, detail string) *Error {
0000000000000000000000000000000000000000;;		return &Error{ErrorTypeRequired, field.String(), "", detail}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Duplicate returns a *Error indicating "duplicate value".  This is
0000000000000000000000000000000000000000;;	// used to report collisions of values that must be unique (e.g. names or IDs).
0000000000000000000000000000000000000000;;	func Duplicate(field *Path, value interface{}) *Error {
0000000000000000000000000000000000000000;;		return &Error{ErrorTypeDuplicate, field.String(), value, ""}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Invalid returns a *Error indicating "invalid value".  This is used
0000000000000000000000000000000000000000;;	// to report malformed values (e.g. failed regex match, too long, out of bounds).
0000000000000000000000000000000000000000;;	func Invalid(field *Path, value interface{}, detail string) *Error {
0000000000000000000000000000000000000000;;		return &Error{ErrorTypeInvalid, field.String(), value, detail}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotSupported returns a *Error indicating "unsupported value".
0000000000000000000000000000000000000000;;	// This is used to report unknown values for enumerated fields (e.g. a list of
0000000000000000000000000000000000000000;;	// valid values).
0000000000000000000000000000000000000000;;	func NotSupported(field *Path, value interface{}, validValues []string) *Error {
0000000000000000000000000000000000000000;;		detail := ""
0000000000000000000000000000000000000000;;		if validValues != nil && len(validValues) > 0 {
0000000000000000000000000000000000000000;;			detail = "supported values: " + strings.Join(validValues, ", ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Error{ErrorTypeNotSupported, field.String(), value, detail}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Forbidden returns a *Error indicating "forbidden".  This is used to
0000000000000000000000000000000000000000;;	// report valid (as per formatting rules) values which would be accepted under
0000000000000000000000000000000000000000;;	// some conditions, but which are not permitted by current conditions (e.g.
0000000000000000000000000000000000000000;;	// security policy).
0000000000000000000000000000000000000000;;	func Forbidden(field *Path, detail string) *Error {
0000000000000000000000000000000000000000;;		return &Error{ErrorTypeForbidden, field.String(), "", detail}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TooLong returns a *Error indicating "too long".  This is used to
0000000000000000000000000000000000000000;;	// report that the given value is too long.  This is similar to
0000000000000000000000000000000000000000;;	// Invalid, but the returned error will not include the too-long
0000000000000000000000000000000000000000;;	// value.
0000000000000000000000000000000000000000;;	func TooLong(field *Path, value interface{}, maxLength int) *Error {
0000000000000000000000000000000000000000;;		return &Error{ErrorTypeTooLong, field.String(), value, fmt.Sprintf("must have at most %d characters", maxLength)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InternalError returns a *Error indicating "internal error".  This is used
0000000000000000000000000000000000000000;;	// to signal that an error was found that was not directly related to user
0000000000000000000000000000000000000000;;	// input.  The err argument must be non-nil.
0000000000000000000000000000000000000000;;	func InternalError(field *Path, err error) *Error {
0000000000000000000000000000000000000000;;		return &Error{ErrorTypeInternal, field.String(), nil, err.Error()}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorList holds a set of Errors.  It is plausible that we might one day have
0000000000000000000000000000000000000000;;	// non-field errors in this same umbrella package, but for now we don't, so
0000000000000000000000000000000000000000;;	// we can keep it simple and leave ErrorList here.
0000000000000000000000000000000000000000;;	type ErrorList []*Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewErrorTypeMatcher returns an errors.Matcher that returns true
0000000000000000000000000000000000000000;;	// if the provided error is a Error and has the provided ErrorType.
0000000000000000000000000000000000000000;;	func NewErrorTypeMatcher(t ErrorType) utilerrors.Matcher {
0000000000000000000000000000000000000000;;		return func(err error) bool {
0000000000000000000000000000000000000000;;			if e, ok := err.(*Error); ok {
0000000000000000000000000000000000000000;;				return e.Type == t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToAggregate converts the ErrorList into an errors.Aggregate.
0000000000000000000000000000000000000000;;	func (list ErrorList) ToAggregate() utilerrors.Aggregate {
0000000000000000000000000000000000000000;;		errs := make([]error, 0, len(list))
0000000000000000000000000000000000000000;;		errorMsgs := sets.NewString()
0000000000000000000000000000000000000000;;		for _, err := range list {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("%v", err)
0000000000000000000000000000000000000000;;			if errorMsgs.Has(msg) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			errorMsgs.Insert(msg)
0000000000000000000000000000000000000000;;			errs = append(errs, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return utilerrors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fromAggregate(agg utilerrors.Aggregate) ErrorList {
0000000000000000000000000000000000000000;;		errs := agg.Errors()
0000000000000000000000000000000000000000;;		list := make(ErrorList, len(errs))
0000000000000000000000000000000000000000;;		for i := range errs {
0000000000000000000000000000000000000000;;			list[i] = errs[i].(*Error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter removes items from the ErrorList that match the provided fns.
0000000000000000000000000000000000000000;;	func (list ErrorList) Filter(fns ...utilerrors.Matcher) ErrorList {
0000000000000000000000000000000000000000;;		err := utilerrors.FilterOut(list.ToAggregate(), fns...)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// FilterOut takes an Aggregate and returns an Aggregate
0000000000000000000000000000000000000000;;		return fromAggregate(err.(utilerrors.Aggregate))
0000000000000000000000000000000000000000;;	}
