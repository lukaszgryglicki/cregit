0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const qnameCharFmt string = "[A-Za-z0-9]"
0000000000000000000000000000000000000000;;	const qnameExtCharFmt string = "[-A-Za-z0-9_.]"
0000000000000000000000000000000000000000;;	const qualifiedNameFmt string = "(" + qnameCharFmt + qnameExtCharFmt + "*)?" + qnameCharFmt
0000000000000000000000000000000000000000;;	const qualifiedNameErrMsg string = "must consist of alphanumeric characters, '-', '_' or '.', and must start and end with an alphanumeric character"
0000000000000000000000000000000000000000;;	const qualifiedNameMaxLength int = 63
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var qualifiedNameRegexp = regexp.MustCompile("^" + qualifiedNameFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsQualifiedName tests whether the value passed is what Kubernetes calls a
0000000000000000000000000000000000000000;;	// "qualified name".  This is a format used in various places throughout the
0000000000000000000000000000000000000000;;	// system.  If the value is not valid, a list of error strings is returned.
0000000000000000000000000000000000000000;;	// Otherwise an empty list (or nil) is returned.
0000000000000000000000000000000000000000;;	func IsQualifiedName(value string) []string {
0000000000000000000000000000000000000000;;		var errs []string
0000000000000000000000000000000000000000;;		parts := strings.Split(value, "/")
0000000000000000000000000000000000000000;;		var name string
0000000000000000000000000000000000000000;;		switch len(parts) {
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			name = parts[0]
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			var prefix string
0000000000000000000000000000000000000000;;			prefix, name = parts[0], parts[1]
0000000000000000000000000000000000000000;;			if len(prefix) == 0 {
0000000000000000000000000000000000000000;;				errs = append(errs, "prefix part "+EmptyError())
0000000000000000000000000000000000000000;;			} else if msgs := IsDNS1123Subdomain(prefix); len(msgs) != 0 {
0000000000000000000000000000000000000000;;				errs = append(errs, prefixEach(msgs, "prefix part ")...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return append(errs, "a qualified name "+RegexError(qualifiedNameErrMsg, qualifiedNameFmt, "MyName", "my.name", "123-abc")+
0000000000000000000000000000000000000000;;				" with an optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(name) == 0 {
0000000000000000000000000000000000000000;;			errs = append(errs, "name part "+EmptyError())
0000000000000000000000000000000000000000;;		} else if len(name) > qualifiedNameMaxLength {
0000000000000000000000000000000000000000;;			errs = append(errs, "name part "+MaxLenError(qualifiedNameMaxLength))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !qualifiedNameRegexp.MatchString(name) {
0000000000000000000000000000000000000000;;			errs = append(errs, "name part "+RegexError(qualifiedNameErrMsg, qualifiedNameFmt, "MyName", "my.name", "123-abc"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const labelValueFmt string = "(" + qualifiedNameFmt + ")?"
0000000000000000000000000000000000000000;;	const labelValueErrMsg string = "a valid label must be an empty string or consist of alphanumeric characters, '-', '_' or '.', and must start and end with an alphanumeric character"
0000000000000000000000000000000000000000;;	const LabelValueMaxLength int = 63
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var labelValueRegexp = regexp.MustCompile("^" + labelValueFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidLabelValue tests whether the value passed is a valid label value.  If
0000000000000000000000000000000000000000;;	// the value is not valid, a list of error strings is returned.  Otherwise an
0000000000000000000000000000000000000000;;	// empty list (or nil) is returned.
0000000000000000000000000000000000000000;;	func IsValidLabelValue(value string) []string {
0000000000000000000000000000000000000000;;		var errs []string
0000000000000000000000000000000000000000;;		if len(value) > LabelValueMaxLength {
0000000000000000000000000000000000000000;;			errs = append(errs, MaxLenError(LabelValueMaxLength))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !labelValueRegexp.MatchString(value) {
0000000000000000000000000000000000000000;;			errs = append(errs, RegexError(labelValueErrMsg, labelValueFmt, "MyValue", "my_value", "12345"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const dns1123LabelFmt string = "[a-z0-9]([-a-z0-9]*[a-z0-9])?"
0000000000000000000000000000000000000000;;	const dns1123LabelErrMsg string = "a DNS-1123 label must consist of lower case alphanumeric characters or '-', and must start and end with an alphanumeric character"
0000000000000000000000000000000000000000;;	const DNS1123LabelMaxLength int = 63
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var dns1123LabelRegexp = regexp.MustCompile("^" + dns1123LabelFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDNS1123Label tests for a string that conforms to the definition of a label in
0000000000000000000000000000000000000000;;	// DNS (RFC 1123).
0000000000000000000000000000000000000000;;	func IsDNS1123Label(value string) []string {
0000000000000000000000000000000000000000;;		var errs []string
0000000000000000000000000000000000000000;;		if len(value) > DNS1123LabelMaxLength {
0000000000000000000000000000000000000000;;			errs = append(errs, MaxLenError(DNS1123LabelMaxLength))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !dns1123LabelRegexp.MatchString(value) {
0000000000000000000000000000000000000000;;			errs = append(errs, RegexError(dns1123LabelErrMsg, dns1123LabelFmt, "my-name", "123-abc"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const dns1123SubdomainFmt string = dns1123LabelFmt + "(\\." + dns1123LabelFmt + ")*"
0000000000000000000000000000000000000000;;	const dns1123SubdomainErrorMsg string = "a DNS-1123 subdomain must consist of lower case alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character"
0000000000000000000000000000000000000000;;	const DNS1123SubdomainMaxLength int = 253
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var dns1123SubdomainRegexp = regexp.MustCompile("^" + dns1123SubdomainFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDNS1123Subdomain tests for a string that conforms to the definition of a
0000000000000000000000000000000000000000;;	// subdomain in DNS (RFC 1123).
0000000000000000000000000000000000000000;;	func IsDNS1123Subdomain(value string) []string {
0000000000000000000000000000000000000000;;		var errs []string
0000000000000000000000000000000000000000;;		if len(value) > DNS1123SubdomainMaxLength {
0000000000000000000000000000000000000000;;			errs = append(errs, MaxLenError(DNS1123SubdomainMaxLength))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !dns1123SubdomainRegexp.MatchString(value) {
0000000000000000000000000000000000000000;;			errs = append(errs, RegexError(dns1123SubdomainErrorMsg, dns1123SubdomainFmt, "example.com"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const dns1035LabelFmt string = "[a-z]([-a-z0-9]*[a-z0-9])?"
0000000000000000000000000000000000000000;;	const dns1035LabelErrMsg string = "a DNS-1035 label must consist of lower case alphanumeric characters or '-', and must start and end with an alphanumeric character"
0000000000000000000000000000000000000000;;	const DNS1035LabelMaxLength int = 63
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var dns1035LabelRegexp = regexp.MustCompile("^" + dns1035LabelFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDNS1035Label tests for a string that conforms to the definition of a label in
0000000000000000000000000000000000000000;;	// DNS (RFC 1035).
0000000000000000000000000000000000000000;;	func IsDNS1035Label(value string) []string {
0000000000000000000000000000000000000000;;		var errs []string
0000000000000000000000000000000000000000;;		if len(value) > DNS1035LabelMaxLength {
0000000000000000000000000000000000000000;;			errs = append(errs, MaxLenError(DNS1035LabelMaxLength))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !dns1035LabelRegexp.MatchString(value) {
0000000000000000000000000000000000000000;;			errs = append(errs, RegexError(dns1035LabelErrMsg, dns1035LabelFmt, "my-name", "abc-123"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// wildcard definition - RFC 1034 section 4.3.3.
0000000000000000000000000000000000000000;;	// examples:
0000000000000000000000000000000000000000;;	// - valid: *.bar.com, *.foo.bar.com
0000000000000000000000000000000000000000;;	// - invalid: *.*.bar.com, *.foo.*.com, *bar.com, f*.bar.com, *
0000000000000000000000000000000000000000;;	const wildcardDNS1123SubdomainFmt = "\\*\\." + dns1123SubdomainFmt
0000000000000000000000000000000000000000;;	const wildcardDNS1123SubdomainErrMsg = "a wildcard DNS-1123 subdomain must start with '*.', followed by a valid DNS subdomain, which must consist of lower case alphanumeric characters, '-' or '.' and end with an alphanumeric character"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsWildcardDNS1123Subdomain tests for a string that conforms to the definition of a
0000000000000000000000000000000000000000;;	// wildcard subdomain in DNS (RFC 1034 section 4.3.3).
0000000000000000000000000000000000000000;;	func IsWildcardDNS1123Subdomain(value string) []string {
0000000000000000000000000000000000000000;;		wildcardDNS1123SubdomainRegexp := regexp.MustCompile("^" + wildcardDNS1123SubdomainFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errs []string
0000000000000000000000000000000000000000;;		if len(value) > DNS1123SubdomainMaxLength {
0000000000000000000000000000000000000000;;			errs = append(errs, MaxLenError(DNS1123SubdomainMaxLength))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !wildcardDNS1123SubdomainRegexp.MatchString(value) {
0000000000000000000000000000000000000000;;			errs = append(errs, RegexError(wildcardDNS1123SubdomainErrMsg, wildcardDNS1123SubdomainFmt, "*.example.com"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const cIdentifierFmt string = "[A-Za-z_][A-Za-z0-9_]*"
0000000000000000000000000000000000000000;;	const identifierErrMsg string = "a valid C identifier must start with alphabetic character or '_', followed by a string of alphanumeric characters or '_'"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cIdentifierRegexp = regexp.MustCompile("^" + cIdentifierFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsCIdentifier tests for a string that conforms the definition of an identifier
0000000000000000000000000000000000000000;;	// in C. This checks the format, but not the length.
0000000000000000000000000000000000000000;;	func IsCIdentifier(value string) []string {
0000000000000000000000000000000000000000;;		if !cIdentifierRegexp.MatchString(value) {
0000000000000000000000000000000000000000;;			return []string{RegexError(identifierErrMsg, cIdentifierFmt, "my_name", "MY_NAME", "MyName")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidPortNum tests that the argument is a valid, non-zero port number.
0000000000000000000000000000000000000000;;	func IsValidPortNum(port int) []string {
0000000000000000000000000000000000000000;;		if 1 <= port && port <= 65535 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []string{InclusiveRangeError(1, 65535)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Now in libcontainer UID/GID limits is 0 ~ 1<<31 - 1
0000000000000000000000000000000000000000;;	// TODO: once we have a type for UID/GID we should make these that type.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		minUserID  = 0
0000000000000000000000000000000000000000;;		maxUserID  = math.MaxInt32
0000000000000000000000000000000000000000;;		minGroupID = 0
0000000000000000000000000000000000000000;;		maxGroupID = math.MaxInt32
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidGroupID tests that the argument is a valid Unix GID.
0000000000000000000000000000000000000000;;	func IsValidGroupID(gid int64) []string {
0000000000000000000000000000000000000000;;		if minGroupID <= gid && gid <= maxGroupID {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []string{InclusiveRangeError(minGroupID, maxGroupID)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidUserID tests that the argument is a valid Unix UID.
0000000000000000000000000000000000000000;;	func IsValidUserID(uid int64) []string {
0000000000000000000000000000000000000000;;		if minUserID <= uid && uid <= maxUserID {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []string{InclusiveRangeError(minUserID, maxUserID)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var portNameCharsetRegex = regexp.MustCompile("^[-a-z0-9]+$")
0000000000000000000000000000000000000000;;	var portNameOneLetterRegexp = regexp.MustCompile("[a-z]")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidPortName check that the argument is valid syntax. It must be
0000000000000000000000000000000000000000;;	// non-empty and no more than 15 characters long. It may contain only [-a-z0-9]
0000000000000000000000000000000000000000;;	// and must contain at least one letter [a-z]. It must not start or end with a
0000000000000000000000000000000000000000;;	// hyphen, nor contain adjacent hyphens.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note: We only allow lower-case characters, even though RFC 6335 is case
0000000000000000000000000000000000000000;;	// insensitive.
0000000000000000000000000000000000000000;;	func IsValidPortName(port string) []string {
0000000000000000000000000000000000000000;;		var errs []string
0000000000000000000000000000000000000000;;		if len(port) > 15 {
0000000000000000000000000000000000000000;;			errs = append(errs, MaxLenError(15))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !portNameCharsetRegex.MatchString(port) {
0000000000000000000000000000000000000000;;			errs = append(errs, "must contain only alpha-numeric characters (a-z, 0-9), and hyphens (-)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !portNameOneLetterRegexp.MatchString(port) {
0000000000000000000000000000000000000000;;			errs = append(errs, "must contain at least one letter or number (a-z, 0-9)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.Contains(port, "--") {
0000000000000000000000000000000000000000;;			errs = append(errs, "must not contain consecutive hyphens")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(port) > 0 && (port[0] == '-' || port[len(port)-1] == '-') {
0000000000000000000000000000000000000000;;			errs = append(errs, "must not begin or end with a hyphen")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidIP tests that the argument is a valid IP address.
0000000000000000000000000000000000000000;;	func IsValidIP(value string) []string {
0000000000000000000000000000000000000000;;		if net.ParseIP(value) == nil {
0000000000000000000000000000000000000000;;			return []string{"must be a valid IP address, (e.g. 10.9.8.7)"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const percentFmt string = "[0-9]+%"
0000000000000000000000000000000000000000;;	const percentErrMsg string = "a valid percent string must be a numeric string followed by an ending '%'"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var percentRegexp = regexp.MustCompile("^" + percentFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsValidPercent(percent string) []string {
0000000000000000000000000000000000000000;;		if !percentRegexp.MatchString(percent) {
0000000000000000000000000000000000000000;;			return []string{RegexError(percentErrMsg, percentFmt, "1%", "93%")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const httpHeaderNameFmt string = "[-A-Za-z0-9]+"
0000000000000000000000000000000000000000;;	const httpHeaderNameErrMsg string = "a valid HTTP header must consist of alphanumeric characters or '-'"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var httpHeaderNameRegexp = regexp.MustCompile("^" + httpHeaderNameFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHTTPHeaderName checks that a string conforms to the Go HTTP library's
0000000000000000000000000000000000000000;;	// definition of a valid header field name (a stricter subset than RFC7230).
0000000000000000000000000000000000000000;;	func IsHTTPHeaderName(value string) []string {
0000000000000000000000000000000000000000;;		if !httpHeaderNameRegexp.MatchString(value) {
0000000000000000000000000000000000000000;;			return []string{RegexError(httpHeaderNameErrMsg, httpHeaderNameFmt, "X-Header-Name")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const configMapKeyFmt = `[-._a-zA-Z0-9]+`
0000000000000000000000000000000000000000;;	const configMapKeyErrMsg string = "a valid config key must consist of alphanumeric characters, '-', '_' or '.'"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var configMapKeyRegexp = regexp.MustCompile("^" + configMapKeyFmt + "$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsConfigMapKey tests for a string that is a valid key for a ConfigMap or Secret
0000000000000000000000000000000000000000;;	func IsConfigMapKey(value string) []string {
0000000000000000000000000000000000000000;;		var errs []string
0000000000000000000000000000000000000000;;		if len(value) > DNS1123SubdomainMaxLength {
0000000000000000000000000000000000000000;;			errs = append(errs, MaxLenError(DNS1123SubdomainMaxLength))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !configMapKeyRegexp.MatchString(value) {
0000000000000000000000000000000000000000;;			errs = append(errs, RegexError(configMapKeyErrMsg, configMapKeyFmt, "key.name", "KEY_NAME", "key-name"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if value == "." {
0000000000000000000000000000000000000000;;			errs = append(errs, `must not be '.'`)
0000000000000000000000000000000000000000;;		} else if value == ".." {
0000000000000000000000000000000000000000;;			errs = append(errs, `must not be '..'`)
0000000000000000000000000000000000000000;;		} else if strings.HasPrefix(value, "..") {
0000000000000000000000000000000000000000;;			errs = append(errs, `must not start with '..'`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxLenError returns a string explanation of a "string too long" validation
0000000000000000000000000000000000000000;;	// failure.
0000000000000000000000000000000000000000;;	func MaxLenError(length int) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("must be no more than %d characters", length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegexError returns a string explanation of a regex validation failure.
0000000000000000000000000000000000000000;;	func RegexError(msg string, fmt string, examples ...string) string {
0000000000000000000000000000000000000000;;		if len(examples) == 0 {
0000000000000000000000000000000000000000;;			return msg + " (regex used for validation is '" + fmt + "')"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg += " (e.g. "
0000000000000000000000000000000000000000;;		for i := range examples {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				msg += " or "
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg += "'" + examples[i] + "', "
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg += "regex used for validation is '" + fmt + "')"
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EmptyError returns a string explanation of a "must not be empty" validation
0000000000000000000000000000000000000000;;	// failure.
0000000000000000000000000000000000000000;;	func EmptyError() string {
0000000000000000000000000000000000000000;;		return "must be non-empty"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prefixEach(msgs []string, prefix string) []string {
0000000000000000000000000000000000000000;;		for i := range msgs {
0000000000000000000000000000000000000000;;			msgs[i] = prefix + msgs[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msgs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InclusiveRangeError returns a string explanation of a numeric "must be
0000000000000000000000000000000000000000;;	// between" validation failure.
0000000000000000000000000000000000000000;;	func InclusiveRangeError(lo, hi int) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(`must be between %d and %d, inclusive`, lo, hi)
0000000000000000000000000000000000000000;;	}
