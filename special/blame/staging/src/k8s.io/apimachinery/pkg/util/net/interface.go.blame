0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package net
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AddressFamily uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		familyIPv4 AddressFamily = 4
0000000000000000000000000000000000000000;;		familyIPv6 AddressFamily = 6
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Route struct {
0000000000000000000000000000000000000000;;		Interface   string
0000000000000000000000000000000000000000;;		Destination net.IP
0000000000000000000000000000000000000000;;		Gateway     net.IP
0000000000000000000000000000000000000000;;		// TODO: add more fields here if needed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRoutes obtains the IPv4 routes, and filters out non-default routes.
0000000000000000000000000000000000000000;;	func getRoutes(input io.Reader) ([]Route, error) {
0000000000000000000000000000000000000000;;		routes := []Route{}
0000000000000000000000000000000000000000;;		if input == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("input is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scanner := bufio.NewReader(input)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			line, err := scanner.ReadString('\n')
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//ignore the headers in the route info
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, "Iface") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fields := strings.Fields(line)
0000000000000000000000000000000000000000;;			dest, err := parseHexToIPv4(fields[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gw, err := parseHexToIPv4(fields[2])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !dest.Equal(net.IPv4zero) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			routes = append(routes, Route{
0000000000000000000000000000000000000000;;				Interface:   fields[0],
0000000000000000000000000000000000000000;;				Destination: dest,
0000000000000000000000000000000000000000;;				Gateway:     gw,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return routes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseHexToIPv4 takes the hex IP address string from route file and converts it
0000000000000000000000000000000000000000;;	// from little endian to big endian for creation of a net.IP address.
0000000000000000000000000000000000000000;;	// a net.IP, using big endian ordering.
0000000000000000000000000000000000000000;;	func parseHexToIPv4(str string) (net.IP, error) {
0000000000000000000000000000000000000000;;		if str == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("input is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bytes, err := hex.DecodeString(str)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(bytes) != net.IPv4len {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid IPv4 address in route")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return net.IP([]byte{bytes[3], bytes[2], bytes[1], bytes[0]}), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isInterfaceUp(intf *net.Interface) bool {
0000000000000000000000000000000000000000;;		if intf == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if intf.Flags&net.FlagUp != 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Interface %v is up", intf.Name)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isLoopbackOrPointToPoint(intf *net.Interface) bool {
0000000000000000000000000000000000000000;;		return intf.Flags&(net.FlagLoopback|net.FlagPointToPoint) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func inFamily(ip net.IP, expectedFamily AddressFamily) bool {
0000000000000000000000000000000000000000;;		ipFamily := familyIPv4
0000000000000000000000000000000000000000;;		if ip.To4() == nil {
0000000000000000000000000000000000000000;;			ipFamily = familyIPv6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ipFamily == expectedFamily
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getMatchingGlobalIP method checks all the IP addresses of a Interface looking
0000000000000000000000000000000000000000;;	// for a valid non-loopback/link-local address of the requested family and returns
0000000000000000000000000000000000000000;;	// it, if found.
0000000000000000000000000000000000000000;;	func getMatchingGlobalIP(addrs []net.Addr, family AddressFamily) (net.IP, error) {
0000000000000000000000000000000000000000;;		if len(addrs) > 0 {
0000000000000000000000000000000000000000;;			for i := range addrs {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Checking addr  %s.", addrs[i].String())
0000000000000000000000000000000000000000;;				ip, _, err := net.ParseCIDR(addrs[i].String())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if inFamily(ip, family) {
0000000000000000000000000000000000000000;;					if ip.IsGlobalUnicast() {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("IP found %v", ip)
0000000000000000000000000000000000000000;;						return ip, nil
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("non-global IP found %v", ip)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("%v is not an IPv%d address", ip, int(family))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getIPFromInterface(intfName string, forFamily AddressFamily, nw networkInterfacer) (net.IP, error) {
0000000000000000000000000000000000000000;;		intf, err := nw.InterfaceByName(intfName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isInterfaceUp(intf) {
0000000000000000000000000000000000000000;;			addrs, err := nw.Addrs(intf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Interface %q has %d addresses :%v.", intfName, len(addrs), addrs)
0000000000000000000000000000000000000000;;			matchingIP, err := getMatchingGlobalIP(addrs, forFamily)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if matchingIP != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Found valid IPv%d address %v for interface %q.", int(forFamily), matchingIP, intfName)
0000000000000000000000000000000000000000;;				return matchingIP, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// memberOF tells if the IP is of the desired family. Used for checking interface addresses.
0000000000000000000000000000000000000000;;	func memberOf(ip net.IP, family AddressFamily) bool {
0000000000000000000000000000000000000000;;		if ip.To4() != nil {
0000000000000000000000000000000000000000;;			return family == familyIPv4
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return family == familyIPv6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// chooseIPFromHostInterfaces looks at all system interfaces, trying to find one that is up that
0000000000000000000000000000000000000000;;	// has a global unicast address (non-loopback, non-link local, non-point2point), and returns the IP.
0000000000000000000000000000000000000000;;	// Searches for IPv4 addresses, and then IPv6 addresses.
0000000000000000000000000000000000000000;;	func chooseIPFromHostInterfaces(nw networkInterfacer) (net.IP, error) {
0000000000000000000000000000000000000000;;		intfs, err := nw.Interfaces()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(intfs) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no interfaces found on host.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, family := range []AddressFamily{familyIPv4, familyIPv6} {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Looking for system interface with a global IPv%d address", uint(family))
0000000000000000000000000000000000000000;;			for _, intf := range intfs {
0000000000000000000000000000000000000000;;				if !isInterfaceUp(&intf) {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Skipping: down interface %q", intf.Name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isLoopbackOrPointToPoint(&intf) {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Skipping: LB or P2P interface %q", intf.Name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				addrs, err := nw.Addrs(&intf)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(addrs) == 0 {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Skipping: no addresses on interface %q", intf.Name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, addr := range addrs {
0000000000000000000000000000000000000000;;					ip, _, err := net.ParseCIDR(addr.String())
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("Unable to parse CIDR for interface %q: %s", intf.Name, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !memberOf(ip, family) {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Skipping: no address family match for %q on interface %q.", ip, intf.Name)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// TODO: Decide if should open up to allow IPv6 LLAs in future.
0000000000000000000000000000000000000000;;					if !ip.IsGlobalUnicast() {
0000000000000000000000000000000000000000;;						glog.V(4).Infof("Skipping: non-global address %q on interface %q.", ip, intf.Name)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Found global unicast address %q on interface %q.", ip, intf.Name)
0000000000000000000000000000000000000000;;					return ip, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no acceptable interface with global unicast address found on host")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//ChooseHostInterface is a method used fetch an IP for a daemon.
0000000000000000000000000000000000000000;;	//It uses data from /proc/net/route file.
0000000000000000000000000000000000000000;;	//For a node with no internet connection ,it returns error
0000000000000000000000000000000000000000;;	//For a multi n/w interface node it returns the IP of the interface with gateway on it.
0000000000000000000000000000000000000000;;	func ChooseHostInterface() (net.IP, error) {
0000000000000000000000000000000000000000;;		var nw networkInterfacer = networkInterface{}
0000000000000000000000000000000000000000;;		inFile, err := os.Open("/proc/net/route")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return chooseIPFromHostInterfaces(nw)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer inFile.Close()
0000000000000000000000000000000000000000;;		return chooseHostInterfaceFromRoute(inFile, nw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// networkInterfacer defines an interface for several net library functions. Production
0000000000000000000000000000000000000000;;	// code will forward to net library functions, and unit tests will override the methods
0000000000000000000000000000000000000000;;	// for testing purposes.
0000000000000000000000000000000000000000;;	type networkInterfacer interface {
0000000000000000000000000000000000000000;;		InterfaceByName(intfName string) (*net.Interface, error)
0000000000000000000000000000000000000000;;		Addrs(intf *net.Interface) ([]net.Addr, error)
0000000000000000000000000000000000000000;;		Interfaces() ([]net.Interface, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// networkInterface implements the networkInterfacer interface for production code, just
0000000000000000000000000000000000000000;;	// wrapping the underlying net library function calls.
0000000000000000000000000000000000000000;;	type networkInterface struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ networkInterface) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return net.InterfaceByName(intfName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ networkInterface) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		return intf.Addrs()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ networkInterface) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return net.Interfaces()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func chooseHostInterfaceFromRoute(inFile io.Reader, nw networkInterfacer) (net.IP, error) {
0000000000000000000000000000000000000000;;		routes, err := getRoutes(inFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(routes) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No default routes.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: append IPv6 routes for processing - currently only have IPv4 routes
0000000000000000000000000000000000000000;;		for _, family := range []AddressFamily{familyIPv4, familyIPv6} {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Looking for default routes with IPv%d addresses", uint(family))
0000000000000000000000000000000000000000;;			for _, route := range routes {
0000000000000000000000000000000000000000;;				// TODO: When have IPv6 routes, filter here to speed up processing
0000000000000000000000000000000000000000;;				// if route.Family != family {
0000000000000000000000000000000000000000;;				// 	continue
0000000000000000000000000000000000000000;;				// }
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Default route transits interface %q", route.Interface)
0000000000000000000000000000000000000000;;				finalIP, err := getIPFromInterface(route.Interface, family, nw)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if finalIP != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Found active IP %v ", finalIP)
0000000000000000000000000000000000000000;;					return finalIP, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("No active IP found by looking at default routes")
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unable to select an IP from default routes.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If bind-address is usable, return it directly
0000000000000000000000000000000000000000;;	// If bind-address is not usable (unset, 0.0.0.0, or loopback), we will use the host's default
0000000000000000000000000000000000000000;;	// interface.
0000000000000000000000000000000000000000;;	func ChooseBindAddress(bindAddress net.IP) (net.IP, error) {
0000000000000000000000000000000000000000;;		if bindAddress == nil || bindAddress.IsUnspecified() || bindAddress.IsLoopback() {
0000000000000000000000000000000000000000;;			hostIP, err := ChooseHostInterface()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bindAddress = hostIP
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bindAddress, nil
0000000000000000000000000000000000000000;;	}
