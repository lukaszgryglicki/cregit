0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/pkg/util/clock/clock.go[staging/src/k8s.io/client-go/1.4/pkg/util/clock/clock.go][staging/src/k8s.io/apimachinery/pkg/util/clock/clock.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clock allows for injecting fake or real clocks into code that
0000000000000000000000000000000000000000;;	// needs to do arbitrary things based on time.
0000000000000000000000000000000000000000;;	type Clock interface {
0000000000000000000000000000000000000000;;		Now() time.Time
0000000000000000000000000000000000000000;;		Since(time.Time) time.Duration
0000000000000000000000000000000000000000;;		After(d time.Duration) <-chan time.Time
0000000000000000000000000000000000000000;;		NewTimer(d time.Duration) Timer
0000000000000000000000000000000000000000;;		Sleep(d time.Duration)
0000000000000000000000000000000000000000;;		Tick(d time.Duration) <-chan time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ = Clock(RealClock{})
0000000000000000000000000000000000000000;;		_ = Clock(&FakeClock{})
0000000000000000000000000000000000000000;;		_ = Clock(&IntervalClock{})
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RealClock really calls time.Now()
0000000000000000000000000000000000000000;;	type RealClock struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Now returns the current time.
0000000000000000000000000000000000000000;;	func (RealClock) Now() time.Time {
0000000000000000000000000000000000000000;;		return time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Since returns time since the specified timestamp.
0000000000000000000000000000000000000000;;	func (RealClock) Since(ts time.Time) time.Duration {
0000000000000000000000000000000000000000;;		return time.Since(ts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Same as time.After(d).
0000000000000000000000000000000000000000;;	func (RealClock) After(d time.Duration) <-chan time.Time {
0000000000000000000000000000000000000000;;		return time.After(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (RealClock) NewTimer(d time.Duration) Timer {
0000000000000000000000000000000000000000;;		return &realTimer{
0000000000000000000000000000000000000000;;			timer: time.NewTimer(d),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (RealClock) Tick(d time.Duration) <-chan time.Time {
0000000000000000000000000000000000000000;;		return time.Tick(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (RealClock) Sleep(d time.Duration) {
0000000000000000000000000000000000000000;;		time.Sleep(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeClock implements Clock, but returns an arbitrary time.
0000000000000000000000000000000000000000;;	type FakeClock struct {
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;		time time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// waiters are waiting for the fake time to pass their specified time
0000000000000000000000000000000000000000;;		waiters []fakeClockWaiter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeClockWaiter struct {
0000000000000000000000000000000000000000;;		targetTime    time.Time
0000000000000000000000000000000000000000;;		stepInterval  time.Duration
0000000000000000000000000000000000000000;;		skipIfBlocked bool
0000000000000000000000000000000000000000;;		destChan      chan time.Time
0000000000000000000000000000000000000000;;		fired         bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeClock(t time.Time) *FakeClock {
0000000000000000000000000000000000000000;;		return &FakeClock{
0000000000000000000000000000000000000000;;			time: t,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Now returns f's time.
0000000000000000000000000000000000000000;;	func (f *FakeClock) Now() time.Time {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		return f.time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Since returns time since the time in f.
0000000000000000000000000000000000000000;;	func (f *FakeClock) Since(ts time.Time) time.Duration {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		return f.time.Sub(ts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fake version of time.After(d).
0000000000000000000000000000000000000000;;	func (f *FakeClock) After(d time.Duration) <-chan time.Time {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		stopTime := f.time.Add(d)
0000000000000000000000000000000000000000;;		ch := make(chan time.Time, 1) // Don't block!
0000000000000000000000000000000000000000;;		f.waiters = append(f.waiters, fakeClockWaiter{
0000000000000000000000000000000000000000;;			targetTime: stopTime,
0000000000000000000000000000000000000000;;			destChan:   ch,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fake version of time.NewTimer(d).
0000000000000000000000000000000000000000;;	func (f *FakeClock) NewTimer(d time.Duration) Timer {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		stopTime := f.time.Add(d)
0000000000000000000000000000000000000000;;		ch := make(chan time.Time, 1) // Don't block!
0000000000000000000000000000000000000000;;		timer := &fakeTimer{
0000000000000000000000000000000000000000;;			fakeClock: f,
0000000000000000000000000000000000000000;;			waiter: fakeClockWaiter{
0000000000000000000000000000000000000000;;				targetTime: stopTime,
0000000000000000000000000000000000000000;;				destChan:   ch,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.waiters = append(f.waiters, timer.waiter)
0000000000000000000000000000000000000000;;		return timer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeClock) Tick(d time.Duration) <-chan time.Time {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		tickTime := f.time.Add(d)
0000000000000000000000000000000000000000;;		ch := make(chan time.Time, 1) // hold one tick
0000000000000000000000000000000000000000;;		f.waiters = append(f.waiters, fakeClockWaiter{
0000000000000000000000000000000000000000;;			targetTime:    tickTime,
0000000000000000000000000000000000000000;;			stepInterval:  d,
0000000000000000000000000000000000000000;;			skipIfBlocked: true,
0000000000000000000000000000000000000000;;			destChan:      ch,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Move clock by Duration, notify anyone that's called After, Tick, or NewTimer
0000000000000000000000000000000000000000;;	func (f *FakeClock) Step(d time.Duration) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		f.setTimeLocked(f.time.Add(d))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sets the time.
0000000000000000000000000000000000000000;;	func (f *FakeClock) SetTime(t time.Time) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		f.setTimeLocked(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Actually changes the time and checks any waiters. f must be write-locked.
0000000000000000000000000000000000000000;;	func (f *FakeClock) setTimeLocked(t time.Time) {
0000000000000000000000000000000000000000;;		f.time = t
0000000000000000000000000000000000000000;;		newWaiters := make([]fakeClockWaiter, 0, len(f.waiters))
0000000000000000000000000000000000000000;;		for i := range f.waiters {
0000000000000000000000000000000000000000;;			w := &f.waiters[i]
0000000000000000000000000000000000000000;;			if !w.targetTime.After(t) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if w.skipIfBlocked {
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case w.destChan <- t:
0000000000000000000000000000000000000000;;						w.fired = true
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					w.destChan <- t
0000000000000000000000000000000000000000;;					w.fired = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if w.stepInterval > 0 {
0000000000000000000000000000000000000000;;					for !w.targetTime.After(t) {
0000000000000000000000000000000000000000;;						w.targetTime = w.targetTime.Add(w.stepInterval)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					newWaiters = append(newWaiters, *w)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				newWaiters = append(newWaiters, f.waiters[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.waiters = newWaiters
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true if After has been called on f but not yet satisfied (so you can
0000000000000000000000000000000000000000;;	// write race-free tests).
0000000000000000000000000000000000000000;;	func (f *FakeClock) HasWaiters() bool {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		return len(f.waiters) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeClock) Sleep(d time.Duration) {
0000000000000000000000000000000000000000;;		f.Step(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntervalClock implements Clock, but each invocation of Now steps the clock forward the specified duration
0000000000000000000000000000000000000000;;	type IntervalClock struct {
0000000000000000000000000000000000000000;;		Time     time.Time
0000000000000000000000000000000000000000;;		Duration time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Now returns i's time.
0000000000000000000000000000000000000000;;	func (i *IntervalClock) Now() time.Time {
0000000000000000000000000000000000000000;;		i.Time = i.Time.Add(i.Duration)
0000000000000000000000000000000000000000;;		return i.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Since returns time since the time in i.
0000000000000000000000000000000000000000;;	func (i *IntervalClock) Since(ts time.Time) time.Duration {
0000000000000000000000000000000000000000;;		return i.Time.Sub(ts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unimplemented, will panic.
0000000000000000000000000000000000000000;;	// TODO: make interval clock use FakeClock so this can be implemented.
0000000000000000000000000000000000000000;;	func (*IntervalClock) After(d time.Duration) <-chan time.Time {
0000000000000000000000000000000000000000;;		panic("IntervalClock doesn't implement After")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unimplemented, will panic.
0000000000000000000000000000000000000000;;	// TODO: make interval clock use FakeClock so this can be implemented.
0000000000000000000000000000000000000000;;	func (*IntervalClock) NewTimer(d time.Duration) Timer {
0000000000000000000000000000000000000000;;		panic("IntervalClock doesn't implement NewTimer")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unimplemented, will panic.
0000000000000000000000000000000000000000;;	// TODO: make interval clock use FakeClock so this can be implemented.
0000000000000000000000000000000000000000;;	func (*IntervalClock) Tick(d time.Duration) <-chan time.Time {
0000000000000000000000000000000000000000;;		panic("IntervalClock doesn't implement Tick")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*IntervalClock) Sleep(d time.Duration) {
0000000000000000000000000000000000000000;;		panic("IntervalClock doesn't implement Sleep")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Timer allows for injecting fake or real timers into code that
0000000000000000000000000000000000000000;;	// needs to do arbitrary things based on time.
0000000000000000000000000000000000000000;;	type Timer interface {
0000000000000000000000000000000000000000;;		C() <-chan time.Time
0000000000000000000000000000000000000000;;		Stop() bool
0000000000000000000000000000000000000000;;		Reset(d time.Duration) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ = Timer(&realTimer{})
0000000000000000000000000000000000000000;;		_ = Timer(&fakeTimer{})
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// realTimer is backed by an actual time.Timer.
0000000000000000000000000000000000000000;;	type realTimer struct {
0000000000000000000000000000000000000000;;		timer *time.Timer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// C returns the underlying timer's channel.
0000000000000000000000000000000000000000;;	func (r *realTimer) C() <-chan time.Time {
0000000000000000000000000000000000000000;;		return r.timer.C
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop calls Stop() on the underlying timer.
0000000000000000000000000000000000000000;;	func (r *realTimer) Stop() bool {
0000000000000000000000000000000000000000;;		return r.timer.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset calls Reset() on the underlying timer.
0000000000000000000000000000000000000000;;	func (r *realTimer) Reset(d time.Duration) bool {
0000000000000000000000000000000000000000;;		return r.timer.Reset(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fakeTimer implements Timer based on a FakeClock.
0000000000000000000000000000000000000000;;	type fakeTimer struct {
0000000000000000000000000000000000000000;;		fakeClock *FakeClock
0000000000000000000000000000000000000000;;		waiter    fakeClockWaiter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// C returns the channel that notifies when this timer has fired.
0000000000000000000000000000000000000000;;	func (f *fakeTimer) C() <-chan time.Time {
0000000000000000000000000000000000000000;;		return f.waiter.destChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops the timer and returns true if the timer has not yet fired, or false otherwise.
0000000000000000000000000000000000000000;;	func (f *fakeTimer) Stop() bool {
0000000000000000000000000000000000000000;;		f.fakeClock.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.fakeClock.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newWaiters := make([]fakeClockWaiter, 0, len(f.fakeClock.waiters))
0000000000000000000000000000000000000000;;		for i := range f.fakeClock.waiters {
0000000000000000000000000000000000000000;;			w := &f.fakeClock.waiters[i]
0000000000000000000000000000000000000000;;			if w != &f.waiter {
0000000000000000000000000000000000000000;;				newWaiters = append(newWaiters, *w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.fakeClock.waiters = newWaiters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return !f.waiter.fired
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset resets the timer to the fake clock's "now" + d. It returns true if the timer has not yet
0000000000000000000000000000000000000000;;	// fired, or false otherwise.
0000000000000000000000000000000000000000;;	func (f *fakeTimer) Reset(d time.Duration) bool {
0000000000000000000000000000000000000000;;		f.fakeClock.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.fakeClock.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		active := !f.waiter.fired
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.waiter.fired = false
0000000000000000000000000000000000000000;;		f.waiter.targetTime = f.fakeClock.time.Add(d)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return active
0000000000000000000000000000000000000000;;	}
