0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
64b335bfbec386bb362685bad2e33715a34fa293;pkg/util/httpstream/httpstream_test.go[pkg/util/httpstream/httpstream_test.go][staging/src/k8s.io/apimachinery/pkg/util/httpstream/httpstream_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package httpstream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type responseWriter struct {
0000000000000000000000000000000000000000;;		header     http.Header
0000000000000000000000000000000000000000;;		statusCode *int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newResponseWriter() *responseWriter {
0000000000000000000000000000000000000000;;		return &responseWriter{
0000000000000000000000000000000000000000;;			header: make(http.Header),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responseWriter) Header() http.Header {
0000000000000000000000000000000000000000;;		return r.header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responseWriter) WriteHeader(code int) {
0000000000000000000000000000000000000000;;		r.statusCode = &code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responseWriter) Write([]byte) (int, error) {
0000000000000000000000000000000000000000;;		return 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHandshake(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := map[string]struct {
0000000000000000000000000000000000000000;;			clientProtocols  []string
0000000000000000000000000000000000000000;;			serverProtocols  []string
0000000000000000000000000000000000000000;;			expectedProtocol string
0000000000000000000000000000000000000000;;			expectError      bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"no client protocols": {
0000000000000000000000000000000000000000;;				clientProtocols:  []string{},
0000000000000000000000000000000000000000;;				serverProtocols:  []string{"a", "b"},
0000000000000000000000000000000000000000;;				expectedProtocol: "",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"no common protocol": {
0000000000000000000000000000000000000000;;				clientProtocols:  []string{"c"},
0000000000000000000000000000000000000000;;				serverProtocols:  []string{"a", "b"},
0000000000000000000000000000000000000000;;				expectedProtocol: "",
0000000000000000000000000000000000000000;;				expectError:      true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"common protocol": {
0000000000000000000000000000000000000000;;				clientProtocols:  []string{"b"},
0000000000000000000000000000000000000000;;				serverProtocols:  []string{"a", "b"},
0000000000000000000000000000000000000000;;				expectedProtocol: "b",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, test := range tests {
0000000000000000000000000000000000000000;;			req, err := http.NewRequest("GET", "http://www.example.com/", nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: error creating request: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, p := range test.clientProtocols {
0000000000000000000000000000000000000000;;				req.Header.Add(HeaderProtocolVersion, p)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w := newResponseWriter()
0000000000000000000000000000000000000000;;			negotiated, err := Handshake(req, w, test.serverProtocols)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify negotiated protocol
0000000000000000000000000000000000000000;;			if e, a := test.expectedProtocol, negotiated; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%s: protocol: expected %q, got %q", name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectError {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected error but did not get one", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if w.statusCode == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected w.statusCode to be set", name)
0000000000000000000000000000000000000000;;				} else if e, a := http.StatusForbidden, *w.statusCode; e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%s: w.statusCode: expected %d, got %d", name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := test.serverProtocols, w.Header()[HeaderAcceptedProtocolVersions]; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: accepted server protocols: expected %v, got %v", name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.expectError && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if w.statusCode != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected non-nil w.statusCode: %d", name, w.statusCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(test.expectedProtocol) == 0 {
0000000000000000000000000000000000000000;;				if len(w.Header()[HeaderProtocolVersion]) > 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected protocol version response header: %s", name, w.Header()[HeaderProtocolVersion])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verify response headers
0000000000000000000000000000000000000000;;			if e, a := []string{test.expectedProtocol}, w.Header()[HeaderProtocolVersion]; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: protocol response header: expected %v, got %v", name, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
