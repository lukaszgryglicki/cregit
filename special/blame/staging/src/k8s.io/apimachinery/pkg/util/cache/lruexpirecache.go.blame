0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
367bf65f6d973b3b60fc9476f4a54cbbb7fb68b4;pkg/util/cache/lruexpirecache.go[pkg/util/cache/lruexpirecache.go][staging/src/k8s.io/apimachinery/pkg/util/cache/lruexpirecache.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/hashicorp/golang-lru"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clock defines an interface for obtaining the current time
0000000000000000000000000000000000000000;;	type Clock interface {
0000000000000000000000000000000000000000;;		Now() time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// realClock implements the Clock interface by calling time.Now()
0000000000000000000000000000000000000000;;	type realClock struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (realClock) Now() time.Time { return time.Now() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LRUExpireCache is a cache that ensures the mostly recently accessed keys are returned with
0000000000000000000000000000000000000000;;	// a ttl beyond which keys are forcibly expired.
0000000000000000000000000000000000000000;;	type LRUExpireCache struct {
0000000000000000000000000000000000000000;;		// clock is used to obtain the current time
0000000000000000000000000000000000000000;;		clock Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache *lru.Cache
0000000000000000000000000000000000000000;;		lock  sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLRUExpireCache creates an expiring cache with the given size
0000000000000000000000000000000000000000;;	func NewLRUExpireCache(maxSize int) *LRUExpireCache {
0000000000000000000000000000000000000000;;		return NewLRUExpireCacheWithClock(maxSize, realClock{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLRUExpireCacheWithClock creates an expiring cache with the given size, using the specified clock to obtain the current time.
0000000000000000000000000000000000000000;;	func NewLRUExpireCacheWithClock(maxSize int, clock Clock) *LRUExpireCache {
0000000000000000000000000000000000000000;;		cache, err := lru.New(maxSize)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// if called with an invalid size
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &LRUExpireCache{clock: clock, cache: cache}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cacheEntry struct {
0000000000000000000000000000000000000000;;		value      interface{}
0000000000000000000000000000000000000000;;		expireTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds the value to the cache at key with the specified maximum duration.
0000000000000000000000000000000000000000;;	func (c *LRUExpireCache) Add(key interface{}, value interface{}, ttl time.Duration) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.cache.Add(key, &cacheEntry{value, c.clock.Now().Add(ttl)})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the value at the specified key from the cache if it exists and is not
0000000000000000000000000000000000000000;;	// expired, or returns false.
0000000000000000000000000000000000000000;;	func (c *LRUExpireCache) Get(key interface{}) (interface{}, bool) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		e, ok := c.cache.Get(key)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.clock.Now().After(e.(*cacheEntry).expireTime) {
0000000000000000000000000000000000000000;;			c.cache.Remove(key)
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.(*cacheEntry).value, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes the specified key from the cache if it exists
0000000000000000000000000000000000000000;;	func (c *LRUExpireCache) Remove(key interface{}) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.cache.Remove(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns all the keys in the cache, even if they are expired. Subsequent calls to
0000000000000000000000000000000000000000;;	// get may return not found. It returns all keys from oldest to newest.
0000000000000000000000000000000000000000;;	func (c *LRUExpireCache) Keys() []interface{} {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		return c.cache.Keys()
0000000000000000000000000000000000000000;;	}
