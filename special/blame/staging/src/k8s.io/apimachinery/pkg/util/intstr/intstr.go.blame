0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
6db7e1dcaf9c6b459f5329529ddad06f8d35a337;pkg/util/intstr/intstr.go[pkg/util/intstr/intstr.go][staging/src/k8s.io/apimachinery/pkg/util/intstr/intstr.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package intstr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"runtime/debug"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/openapi"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntOrString is a type that can hold an int32 or a string.  When used in
0000000000000000000000000000000000000000;;	// JSON or YAML marshalling and unmarshalling, it produces or consumes the
0000000000000000000000000000000000000000;;	// inner type.  This allows you to have, for example, a JSON field that can
0000000000000000000000000000000000000000;;	// accept a name or number.
0000000000000000000000000000000000000000;;	// TODO: Rename to Int32OrString
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +protobuf=true
0000000000000000000000000000000000000000;;	// +protobuf.options.(gogoproto.goproto_stringer)=false
0000000000000000000000000000000000000000;;	// +k8s:openapi-gen=true
0000000000000000000000000000000000000000;;	type IntOrString struct {
0000000000000000000000000000000000000000;;		Type   Type   `protobuf:"varint,1,opt,name=type,casttype=Type"`
0000000000000000000000000000000000000000;;		IntVal int32  `protobuf:"varint,2,opt,name=intVal"`
0000000000000000000000000000000000000000;;		StrVal string `protobuf:"bytes,3,opt,name=strVal"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type represents the stored type of IntOrString.
0000000000000000000000000000000000000000;;	type Type int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Int    Type = iota // The IntOrString holds an int.
0000000000000000000000000000000000000000;;		String             // The IntOrString holds a string.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromInt creates an IntOrString object with an int32 value. It is
0000000000000000000000000000000000000000;;	// your responsibility not to call this method with a value greater
0000000000000000000000000000000000000000;;	// than int32.
0000000000000000000000000000000000000000;;	// TODO: convert to (val int32)
0000000000000000000000000000000000000000;;	func FromInt(val int) IntOrString {
0000000000000000000000000000000000000000;;		if val > math.MaxInt32 || val < math.MinInt32 {
0000000000000000000000000000000000000000;;			glog.Errorf("value: %d overflows int32\n%s\n", val, debug.Stack())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return IntOrString{Type: Int, IntVal: int32(val)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromString creates an IntOrString object with a string value.
0000000000000000000000000000000000000000;;	func FromString(val string) IntOrString {
0000000000000000000000000000000000000000;;		return IntOrString{Type: String, StrVal: val}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the given string and try to convert it to an integer before
0000000000000000000000000000000000000000;;	// setting it as a string value.
0000000000000000000000000000000000000000;;	func Parse(val string) IntOrString {
0000000000000000000000000000000000000000;;		i, err := strconv.Atoi(val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return FromString(val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return FromInt(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements the json.Unmarshaller interface.
0000000000000000000000000000000000000000;;	func (intstr *IntOrString) UnmarshalJSON(value []byte) error {
0000000000000000000000000000000000000000;;		if value[0] == '"' {
0000000000000000000000000000000000000000;;			intstr.Type = String
0000000000000000000000000000000000000000;;			return json.Unmarshal(value, &intstr.StrVal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		intstr.Type = Int
0000000000000000000000000000000000000000;;		return json.Unmarshal(value, &intstr.IntVal)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string value, or the Itoa of the int value.
0000000000000000000000000000000000000000;;	func (intstr *IntOrString) String() string {
0000000000000000000000000000000000000000;;		if intstr.Type == String {
0000000000000000000000000000000000000000;;			return intstr.StrVal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.Itoa(intstr.IntValue())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntValue returns the IntVal if type Int, or if
0000000000000000000000000000000000000000;;	// it is a String, will attempt a conversion to int.
0000000000000000000000000000000000000000;;	func (intstr *IntOrString) IntValue() int {
0000000000000000000000000000000000000000;;		if intstr.Type == String {
0000000000000000000000000000000000000000;;			i, _ := strconv.Atoi(intstr.StrVal)
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(intstr.IntVal)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements the json.Marshaller interface.
0000000000000000000000000000000000000000;;	func (intstr IntOrString) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		switch intstr.Type {
0000000000000000000000000000000000000000;;		case Int:
0000000000000000000000000000000000000000;;			return json.Marshal(intstr.IntVal)
0000000000000000000000000000000000000000;;		case String:
0000000000000000000000000000000000000000;;			return json.Marshal(intstr.StrVal)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return []byte{}, fmt.Errorf("impossible IntOrString.Type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ IntOrString) OpenAPIDefinition() openapi.OpenAPIDefinition {
0000000000000000000000000000000000000000;;		return openapi.OpenAPIDefinition{
0000000000000000000000000000000000000000;;			Schema: spec.Schema{
0000000000000000000000000000000000000000;;				SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;					Type:   []string{"string"},
0000000000000000000000000000000000000000;;					Format: "int-or-string",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (intstr *IntOrString) Fuzz(c fuzz.Continue) {
0000000000000000000000000000000000000000;;		if intstr == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.RandBool() {
0000000000000000000000000000000000000000;;			intstr.Type = Int
0000000000000000000000000000000000000000;;			c.Fuzz(&intstr.IntVal)
0000000000000000000000000000000000000000;;			intstr.StrVal = ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			intstr.Type = String
0000000000000000000000000000000000000000;;			intstr.IntVal = 0
0000000000000000000000000000000000000000;;			c.Fuzz(&intstr.StrVal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetValueFromIntOrPercent(intOrPercent *IntOrString, total int, roundUp bool) (int, error) {
0000000000000000000000000000000000000000;;		value, isPercent, err := getIntOrPercentValue(intOrPercent)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("invalid value for IntOrString: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isPercent {
0000000000000000000000000000000000000000;;			if roundUp {
0000000000000000000000000000000000000000;;				value = int(math.Ceil(float64(value) * (float64(total)) / 100))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				value = int(math.Floor(float64(value) * (float64(total)) / 100))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return value, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getIntOrPercentValue(intOrStr *IntOrString) (int, bool, error) {
0000000000000000000000000000000000000000;;		switch intOrStr.Type {
0000000000000000000000000000000000000000;;		case Int:
0000000000000000000000000000000000000000;;			return intOrStr.IntValue(), false, nil
0000000000000000000000000000000000000000;;		case String:
0000000000000000000000000000000000000000;;			s := strings.Replace(intOrStr.StrVal, "%", "", -1)
0000000000000000000000000000000000000000;;			v, err := strconv.Atoi(s)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, false, fmt.Errorf("invalid value %q: %v", intOrStr.StrVal, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return int(v), true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false, fmt.Errorf("invalid type: neither int nor percentage")
0000000000000000000000000000000000000000;;	}
