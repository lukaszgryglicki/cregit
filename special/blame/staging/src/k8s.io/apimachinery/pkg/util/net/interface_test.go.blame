0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package net
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const gatewayfirst = `Iface	Destination	Gateway 	Flags	RefCnt	Use	Metric	Mask		MTU	Window	IRTT                                                       
0000000000000000000000000000000000000000;;	eth3	00000000	0100FE0A	0003	0	0	1024	00000000	0	0	0                                                                   
0000000000000000000000000000000000000000;;	eth3	0000FE0A	00000000	0001	0	0	0	0080FFFF	0	0	0                                                                      
0000000000000000000000000000000000000000;;	docker0	000011AC	00000000	0001	0	0	0	0000FFFF	0	0	0                                                                            
0000000000000000000000000000000000000000;;	virbr0	007AA8C0	00000000	0001	0	0	0	00FFFFFF	0	0	0
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	const gatewaylast = `Iface	Destination	Gateway 	Flags	RefCnt	Use	Metric	Mask		MTU	Window	IRTT  
0000000000000000000000000000000000000000;;	docker0	000011AC	00000000	0001	0	0	0	0000FFFF	0	0	0                                                                            
0000000000000000000000000000000000000000;;	virbr0	007AA8C0	00000000	0001	0	0	0	00FFFFFF	0	0	0                                                                                                                     
0000000000000000000000000000000000000000;;	eth3	0000FE0A	00000000	0001	0	0	0	0080FFFF	0	0	0       
0000000000000000000000000000000000000000;;	eth3	00000000	0100FE0A	0003	0	0	1024	00000000	0	0	0                                                                 
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	const gatewaymiddle = `Iface	Destination	Gateway 	Flags	RefCnt	Use	Metric	Mask		MTU	Window	IRTT                                                                                                                     
0000000000000000000000000000000000000000;;	eth3	0000FE0A	00000000	0001	0	0	0	0080FFFF	0	0	0                                                                      
0000000000000000000000000000000000000000;;	docker0	000011AC	00000000	0001	0	0	0	0000FFFF	0	0	0       
0000000000000000000000000000000000000000;;	eth3	00000000	0100FE0A	0003	0	0	1024	00000000	0	0	0                                                                         
0000000000000000000000000000000000000000;;	virbr0	007AA8C0	00000000	0001	0	0	0	00FFFFFF	0	0	0
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	const noInternetConnection = `Iface	Destination	Gateway 	Flags	RefCnt	Use	Metric	Mask		MTU	Window	IRTT                                                       
0000000000000000000000000000000000000000;;	docker0	000011AC	00000000	0001	0	0	0	0000FFFF	0	0	0                                                                            
0000000000000000000000000000000000000000;;	virbr0	007AA8C0	00000000	0001	0	0	0	00FFFFFF	0	0	0            
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	const nothing = `Iface	Destination	Gateway 	Flags	RefCnt	Use	Metric	Mask		MTU	Window	IRTT                                                            
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	const badDestination = `Iface	Destination	Gateway 	Flags	RefCnt	Use	Metric	Mask		MTU	Window	IRTT                                                       
0000000000000000000000000000000000000000;;	eth3	00000000	0100FE0A	0003	0	0	1024	00000000	0	0	0                                                                   
0000000000000000000000000000000000000000;;	eth3	0000FE0AA1	00000000	0001	0	0	0	0080FFFF	0	0	0                                                                      
0000000000000000000000000000000000000000;;	docker0	000011AC	00000000	0001	0	0	0	0000FFFF	0	0	0                                                                            
0000000000000000000000000000000000000000;;	virbr0	007AA8C0	00000000	0001	0	0	0	00FFFFFF	0	0	0
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	const badGateway = `Iface	Destination	Gateway 	Flags	RefCnt	Use	Metric	Mask		MTU	Window	IRTT
0000000000000000000000000000000000000000;;	eth3	00000000	0100FE0AA1	0003	0	0	1024	00000000	0	0	0                                                                   
0000000000000000000000000000000000000000;;	eth3	0000FE0A	00000000	0001	0	0	0	0080FFFF	0	0	0                                                                      
0000000000000000000000000000000000000000;;	docker0	000011AC	00000000	0001	0	0	0	0000FFFF	0	0	0                                                                            
0000000000000000000000000000000000000000;;	virbr0	007AA8C0	00000000	0001	0	0	0	00FFFFFF	0	0	0
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	const route_Invalidhex = `Iface	Destination	Gateway 	Flags	RefCnt	Use	Metric	Mask		MTU	Window	IRTT
0000000000000000000000000000000000000000;;	eth3	00000000	0100FE0AA	0003	0	0	1024	00000000	0	0	0                                                                   
0000000000000000000000000000000000000000;;	eth3	0000FE0A	00000000	0001	0	0	0	0080FFFF	0	0	0                                                                      
0000000000000000000000000000000000000000;;	docker0	000011AC	00000000	0001	0	0	0	0000FFFF	0	0	0                                                                            
0000000000000000000000000000000000000000;;	virbr0	007AA8C0	00000000	0001	0	0	0	00FFFFFF	0	0	0
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Based on DigitalOcean COREOS
0000000000000000000000000000000000000000;;	const gatewayfirstLinkLocal = `Iface   Destination     Gateway         Flags   RefCnt  Use     Metric  Mask            MTU     Window  IRTT                                                       
0000000000000000000000000000000000000000;;	eth0    00000000        0120372D        0001    0       0       0       00000000        0       0       0                                                                               
0000000000000000000000000000000000000000;;	eth0    00000000        00000000        0001    0       0       2048    00000000        0       0       0                                                                            
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		flagUp       = net.FlagUp | net.FlagBroadcast | net.FlagMulticast
0000000000000000000000000000000000000000;;		flagDown     = net.FlagBroadcast | net.FlagMulticast
0000000000000000000000000000000000000000;;		flagLoopback = net.FlagUp | net.FlagLoopback
0000000000000000000000000000000000000000;;		flagP2P      = net.FlagUp | net.FlagPointToPoint
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeIntf(index int, name string, flags net.Flags) net.Interface {
0000000000000000000000000000000000000000;;		mac := net.HardwareAddr{0, 0x32, 0x7d, 0x69, 0xf7, byte(0x30 + index)}
0000000000000000000000000000000000000000;;		return net.Interface{
0000000000000000000000000000000000000000;;			Index:        index,
0000000000000000000000000000000000000000;;			MTU:          1500,
0000000000000000000000000000000000000000;;			Name:         name,
0000000000000000000000000000000000000000;;			HardwareAddr: mac,
0000000000000000000000000000000000000000;;			Flags:        flags}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		downIntf     = makeIntf(1, "eth3", flagDown)
0000000000000000000000000000000000000000;;		loopbackIntf = makeIntf(1, "lo", flagLoopback)
0000000000000000000000000000000000000000;;		p2pIntf      = makeIntf(1, "lo", flagP2P)
0000000000000000000000000000000000000000;;		upIntf       = makeIntf(1, "eth3", flagUp)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ipv4Route = Route{Interface: "eth3", Gateway: net.ParseIP("10.254.0.1")}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetRoutes(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			tcase      string
0000000000000000000000000000000000000000;;			route      string
0000000000000000000000000000000000000000;;			count      int
0000000000000000000000000000000000000000;;			expected   *Route
0000000000000000000000000000000000000000;;			errStrFrag string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"gatewayfirst", gatewayfirst, 1, &ipv4Route, ""},
0000000000000000000000000000000000000000;;			{"gatewaymiddle", gatewaymiddle, 1, &ipv4Route, ""},
0000000000000000000000000000000000000000;;			{"gatewaylast", gatewaylast, 1, &ipv4Route, ""},
0000000000000000000000000000000000000000;;			{"no routes", nothing, 0, nil, ""},
0000000000000000000000000000000000000000;;			{"badDestination", badDestination, 0, nil, "invalid IPv4"},
0000000000000000000000000000000000000000;;			{"badGateway", badGateway, 0, nil, "invalid IPv4"},
0000000000000000000000000000000000000000;;			{"route_Invalidhex", route_Invalidhex, 0, nil, "odd length hex string"},
0000000000000000000000000000000000000000;;			{"no default routes", noInternetConnection, 0, nil, ""},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			r := strings.NewReader(tc.route)
0000000000000000000000000000000000000000;;			routes, err := getRoutes(r)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !strings.Contains(err.Error(), tc.errStrFrag) {
0000000000000000000000000000000000000000;;					t.Errorf("case[%s]: Error string %q does not contain %q", tc.tcase, err, tc.errStrFrag)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if tc.errStrFrag != "" {
0000000000000000000000000000000000000000;;				t.Errorf("case[%s]: Error %q expected, but not seen", tc.tcase, tc.errStrFrag)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if tc.count != len(routes) {
0000000000000000000000000000000000000000;;					t.Errorf("case[%s]: expected %d routes, have %v", tc.tcase, tc.count, routes)
0000000000000000000000000000000000000000;;				} else if tc.count == 1 && !tc.expected.Gateway.Equal(routes[0].Gateway) {
0000000000000000000000000000000000000000;;					t.Errorf("case[%s]: expected %v, got %v .err : %v", tc.tcase, tc.expected, routes, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseIP(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			tcase    string
0000000000000000000000000000000000000000;;			ip       string
0000000000000000000000000000000000000000;;			success  bool
0000000000000000000000000000000000000000;;			expected net.IP
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"empty", "", false, nil},
0000000000000000000000000000000000000000;;			{"too short", "AA", false, nil},
0000000000000000000000000000000000000000;;			{"too long", "0011223344", false, nil},
0000000000000000000000000000000000000000;;			{"invalid", "invalid!", false, nil},
0000000000000000000000000000000000000000;;			{"zero", "00000000", true, net.IP{0, 0, 0, 0}},
0000000000000000000000000000000000000000;;			{"ffff", "FFFFFFFF", true, net.IP{0xff, 0xff, 0xff, 0xff}},
0000000000000000000000000000000000000000;;			{"valid", "12345678", true, net.IP{120, 86, 52, 18}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			ip, err := parseHexToIPv4(tc.ip)
0000000000000000000000000000000000000000;;			if !ip.Equal(tc.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("case[%v]: expected %q, got %q . err : %v", tc.tcase, tc.expected, ip, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestIsInterfaceUp(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			tcase    string
0000000000000000000000000000000000000000;;			intf     *net.Interface
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"up", &net.Interface{Index: 0, MTU: 0, Name: "eth3", HardwareAddr: nil, Flags: net.FlagUp}, true},
0000000000000000000000000000000000000000;;			{"down", &net.Interface{Index: 0, MTU: 0, Name: "eth3", HardwareAddr: nil, Flags: 0}, false},
0000000000000000000000000000000000000000;;			{"no interface", nil, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			it := isInterfaceUp(tc.intf)
0000000000000000000000000000000000000000;;			if it != tc.expected {
0000000000000000000000000000000000000000;;				t.Errorf("case[%v]: expected %v, got %v .", tc.tcase, tc.expected, it)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type addrStruct struct{ val string }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a addrStruct) Network() string {
0000000000000000000000000000000000000000;;		return a.val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (a addrStruct) String() string {
0000000000000000000000000000000000000000;;		return a.val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFinalIP(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			tcase    string
0000000000000000000000000000000000000000;;			addr     []net.Addr
0000000000000000000000000000000000000000;;			family   AddressFamily
0000000000000000000000000000000000000000;;			expected net.IP
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"no ipv4", []net.Addr{addrStruct{val: "2001::5/64"}}, familyIPv4, nil},
0000000000000000000000000000000000000000;;			{"no ipv6", []net.Addr{addrStruct{val: "10.128.0.4/32"}}, familyIPv6, nil},
0000000000000000000000000000000000000000;;			{"invalidV4CIDR", []net.Addr{addrStruct{val: "10.20.30.40.50/24"}}, familyIPv4, nil},
0000000000000000000000000000000000000000;;			{"invalidV6CIDR", []net.Addr{addrStruct{val: "fe80::2f7:67fff:fe6e:2956/64"}}, familyIPv6, nil},
0000000000000000000000000000000000000000;;			{"loopback", []net.Addr{addrStruct{val: "127.0.0.1/24"}}, familyIPv4, nil},
0000000000000000000000000000000000000000;;			{"loopbackv6", []net.Addr{addrStruct{val: "::1/128"}}, familyIPv6, nil},
0000000000000000000000000000000000000000;;			{"link local v4", []net.Addr{addrStruct{val: "169.254.1.10/16"}}, familyIPv4, nil},
0000000000000000000000000000000000000000;;			{"link local v6", []net.Addr{addrStruct{val: "fe80::2f7:6fff:fe6e:2956/64"}}, familyIPv6, nil},
0000000000000000000000000000000000000000;;			{"ip4", []net.Addr{addrStruct{val: "10.254.12.132/17"}}, familyIPv4, net.ParseIP("10.254.12.132")},
0000000000000000000000000000000000000000;;			{"ip6", []net.Addr{addrStruct{val: "2001::5/64"}}, familyIPv6, net.ParseIP("2001::5")},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"no addresses", []net.Addr{}, familyIPv4, nil},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			ip, err := getMatchingGlobalIP(tc.addr, tc.family)
0000000000000000000000000000000000000000;;			if !ip.Equal(tc.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("case[%v]: expected %v, got %v .err : %v", tc.tcase, tc.expected, ip, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddrs(t *testing.T) {
0000000000000000000000000000000000000000;;		var nw networkInterfacer = validNetworkInterface{}
0000000000000000000000000000000000000000;;		intf := net.Interface{Index: 0, MTU: 0, Name: "eth3", HardwareAddr: nil, Flags: 0}
0000000000000000000000000000000000000000;;		addrs, err := nw.Addrs(&intf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected no error got : %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(addrs) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("expected addrs: 2 got null")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has a valid IPv4 address (IPv6 is LLA)
0000000000000000000000000000000000000000;;	type validNetworkInterface struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ validNetworkInterface) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return &upIntf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ validNetworkInterface) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		var ifat []net.Addr
0000000000000000000000000000000000000000;;		ifat = []net.Addr{
0000000000000000000000000000000000000000;;			addrStruct{val: "fe80::2f7:6fff:fe6e:2956/64"}, addrStruct{val: "10.254.71.145/17"}}
0000000000000000000000000000000000000000;;		return ifat, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ validNetworkInterface) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return []net.Interface{upIntf}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface with only IPv6 address
0000000000000000000000000000000000000000;;	type ipv6NetworkInterface struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ ipv6NetworkInterface) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return &upIntf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ ipv6NetworkInterface) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		var ifat []net.Addr
0000000000000000000000000000000000000000;;		ifat = []net.Addr{addrStruct{val: "2001::200/64"}}
0000000000000000000000000000000000000000;;		return ifat, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ ipv6NetworkInterface) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return []net.Interface{upIntf}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Only with link local addresses
0000000000000000000000000000000000000000;;	type networkInterfaceWithOnlyLinkLocals struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ networkInterfaceWithOnlyLinkLocals) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return &upIntf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ networkInterfaceWithOnlyLinkLocals) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		var ifat []net.Addr
0000000000000000000000000000000000000000;;		ifat = []net.Addr{addrStruct{val: "169.254.162.166/16"}, addrStruct{val: "fe80::200/10"}}
0000000000000000000000000000000000000000;;		return ifat, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ networkInterfaceWithOnlyLinkLocals) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return []net.Interface{upIntf}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unable to get interface(s)
0000000000000000000000000000000000000000;;	type failGettingNetworkInterface struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ failGettingNetworkInterface) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unable get Interface")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ failGettingNetworkInterface) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ failGettingNetworkInterface) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("mock failed getting all interfaces")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// No interfaces
0000000000000000000000000000000000000000;;	type noNetworkInterface struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ noNetworkInterface) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("no such network interface")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ noNetworkInterface) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ noNetworkInterface) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return []net.Interface{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface is down
0000000000000000000000000000000000000000;;	type downNetworkInterface struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ downNetworkInterface) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return &downIntf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ downNetworkInterface) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		var ifat []net.Addr
0000000000000000000000000000000000000000;;		ifat = []net.Addr{
0000000000000000000000000000000000000000;;			addrStruct{val: "fe80::2f7:6fff:fe6e:2956/64"}, addrStruct{val: "10.254.71.145/17"}}
0000000000000000000000000000000000000000;;		return ifat, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ downNetworkInterface) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return []net.Interface{downIntf}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Loopback interface
0000000000000000000000000000000000000000;;	type loopbackNetworkInterface struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ loopbackNetworkInterface) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return &loopbackIntf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ loopbackNetworkInterface) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		var ifat []net.Addr
0000000000000000000000000000000000000000;;		ifat = []net.Addr{
0000000000000000000000000000000000000000;;			addrStruct{val: "::1/128"}, addrStruct{val: "127.0.0.1/8"}}
0000000000000000000000000000000000000000;;		return ifat, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ loopbackNetworkInterface) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return []net.Interface{loopbackIntf}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Point to point interface
0000000000000000000000000000000000000000;;	type p2pNetworkInterface struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ p2pNetworkInterface) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return &p2pIntf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ p2pNetworkInterface) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		var ifat []net.Addr
0000000000000000000000000000000000000000;;		ifat = []net.Addr{
0000000000000000000000000000000000000000;;			addrStruct{val: "::1/128"}, addrStruct{val: "127.0.0.1/8"}}
0000000000000000000000000000000000000000;;		return ifat, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ p2pNetworkInterface) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return []net.Interface{p2pIntf}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unable to get IP addresses for interface
0000000000000000000000000000000000000000;;	type networkInterfaceFailGetAddrs struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ networkInterfaceFailGetAddrs) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return &upIntf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ networkInterfaceFailGetAddrs) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unable to get Addrs")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ networkInterfaceFailGetAddrs) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return []net.Interface{upIntf}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// No addresses for interface
0000000000000000000000000000000000000000;;	type networkInterfaceWithNoAddrs struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ networkInterfaceWithNoAddrs) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return &upIntf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ networkInterfaceWithNoAddrs) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		ifat := []net.Addr{}
0000000000000000000000000000000000000000;;		return ifat, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ networkInterfaceWithNoAddrs) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return []net.Interface{upIntf}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Invalid addresses for interface
0000000000000000000000000000000000000000;;	type networkInterfaceWithInvalidAddr struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ networkInterfaceWithInvalidAddr) InterfaceByName(intfName string) (*net.Interface, error) {
0000000000000000000000000000000000000000;;		return &upIntf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ networkInterfaceWithInvalidAddr) Addrs(intf *net.Interface) ([]net.Addr, error) {
0000000000000000000000000000000000000000;;		var ifat []net.Addr
0000000000000000000000000000000000000000;;		ifat = []net.Addr{addrStruct{val: "10.20.30.40.50/24"}}
0000000000000000000000000000000000000000;;		return ifat, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (_ networkInterfaceWithInvalidAddr) Interfaces() ([]net.Interface, error) {
0000000000000000000000000000000000000000;;		return []net.Interface{upIntf}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetIPFromInterface(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			tcase      string
0000000000000000000000000000000000000000;;			nwname     string
0000000000000000000000000000000000000000;;			family     AddressFamily
0000000000000000000000000000000000000000;;			nw         networkInterfacer
0000000000000000000000000000000000000000;;			expected   net.IP
0000000000000000000000000000000000000000;;			errStrFrag string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"ipv4", "eth3", familyIPv4, validNetworkInterface{}, net.ParseIP("10.254.71.145"), ""},
0000000000000000000000000000000000000000;;			{"ipv6", "eth3", familyIPv6, ipv6NetworkInterface{}, net.ParseIP("2001::200"), ""},
0000000000000000000000000000000000000000;;			{"no ipv4", "eth3", familyIPv4, ipv6NetworkInterface{}, nil, ""},
0000000000000000000000000000000000000000;;			{"no ipv6", "eth3", familyIPv6, validNetworkInterface{}, nil, ""},
0000000000000000000000000000000000000000;;			{"I/F down", "eth3", familyIPv4, downNetworkInterface{}, nil, ""},
0000000000000000000000000000000000000000;;			{"I/F get fail", "eth3", familyIPv4, noNetworkInterface{}, nil, "no such network interface"},
0000000000000000000000000000000000000000;;			{"fail get addr", "eth3", familyIPv4, networkInterfaceFailGetAddrs{}, nil, "unable to get Addrs"},
0000000000000000000000000000000000000000;;			{"bad addr", "eth3", familyIPv4, networkInterfaceWithInvalidAddr{}, nil, "invalid CIDR"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			ip, err := getIPFromInterface(tc.nwname, tc.family, tc.nw)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if !strings.Contains(err.Error(), tc.errStrFrag) {
0000000000000000000000000000000000000000;;					t.Errorf("case[%s]: Error string %q does not contain %q", tc.tcase, err, tc.errStrFrag)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if tc.errStrFrag != "" {
0000000000000000000000000000000000000000;;				t.Errorf("case[%s]: Error %q expected, but not seen", tc.tcase, tc.errStrFrag)
0000000000000000000000000000000000000000;;			} else if !ip.Equal(tc.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("case[%v]: expected %v, got %+v .err : %v", tc.tcase, tc.expected, ip, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestChooseHostInterfaceFromRoute(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			tcase    string
0000000000000000000000000000000000000000;;			inFile   io.Reader
0000000000000000000000000000000000000000;;			nw       networkInterfacer
0000000000000000000000000000000000000000;;			expected net.IP
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"ipv4", strings.NewReader(gatewayfirst), validNetworkInterface{}, net.ParseIP("10.254.71.145")},
0000000000000000000000000000000000000000;;			{"ipv6", strings.NewReader(gatewaymiddle), ipv6NetworkInterface{}, net.ParseIP("2001::200")},
0000000000000000000000000000000000000000;;			{"no non-link-local ip", strings.NewReader(gatewaymiddle), networkInterfaceWithOnlyLinkLocals{}, nil},
0000000000000000000000000000000000000000;;			{"no routes", strings.NewReader(nothing), validNetworkInterface{}, nil},
0000000000000000000000000000000000000000;;			{"no route file", nil, validNetworkInterface{}, nil},
0000000000000000000000000000000000000000;;			{"no interfaces", nil, noNetworkInterface{}, nil},
0000000000000000000000000000000000000000;;			{"no interface addrs", strings.NewReader(gatewaymiddle), networkInterfaceWithNoAddrs{}, nil},
0000000000000000000000000000000000000000;;			{"fail get addrs", strings.NewReader(gatewaymiddle), networkInterfaceFailGetAddrs{}, nil},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			ip, err := chooseHostInterfaceFromRoute(tc.inFile, tc.nw)
0000000000000000000000000000000000000000;;			if !ip.Equal(tc.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("case[%v]: expected %v, got %+v .err : %v", tc.tcase, tc.expected, ip, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func TestMemberOf(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			tcase    string
0000000000000000000000000000000000000000;;			ip       net.IP
0000000000000000000000000000000000000000;;			family   AddressFamily
0000000000000000000000000000000000000000;;			expected bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"ipv4 is 4", net.ParseIP("10.20.30.40"), familyIPv4, true},
0000000000000000000000000000000000000000;;			{"ipv4 is 6", net.ParseIP("10.10.10.10"), familyIPv6, false},
0000000000000000000000000000000000000000;;			{"ipv6 is 4", net.ParseIP("2001::100"), familyIPv4, false},
0000000000000000000000000000000000000000;;			{"ipv6 is 6", net.ParseIP("2001::100"), familyIPv6, true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			if memberOf(tc.ip, tc.family) != tc.expected {
0000000000000000000000000000000000000000;;				t.Errorf("case[%s]: expected %+v", tc.tcase, tc.expected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGetIPFromHostInterfaces(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			tcase      string
0000000000000000000000000000000000000000;;			nw         networkInterfacer
0000000000000000000000000000000000000000;;			expected   net.IP
0000000000000000000000000000000000000000;;			errStrFrag string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"fail get I/Fs", failGettingNetworkInterface{}, nil, "failed getting all interfaces"},
0000000000000000000000000000000000000000;;			{"no interfaces", noNetworkInterface{}, nil, "no interfaces"},
0000000000000000000000000000000000000000;;			{"I/F not up", downNetworkInterface{}, nil, "no acceptable"},
0000000000000000000000000000000000000000;;			{"loopback only", loopbackNetworkInterface{}, nil, "no acceptable"},
0000000000000000000000000000000000000000;;			{"P2P I/F only", p2pNetworkInterface{}, nil, "no acceptable"},
0000000000000000000000000000000000000000;;			{"fail get addrs", networkInterfaceFailGetAddrs{}, nil, "unable to get Addrs"},
0000000000000000000000000000000000000000;;			{"no addresses", networkInterfaceWithNoAddrs{}, nil, "no acceptable"},
0000000000000000000000000000000000000000;;			{"invalid addr", networkInterfaceWithInvalidAddr{}, nil, "invalid CIDR"},
0000000000000000000000000000000000000000;;			{"no matches", networkInterfaceWithOnlyLinkLocals{}, nil, "no acceptable"},
0000000000000000000000000000000000000000;;			{"ipv4", validNetworkInterface{}, net.ParseIP("10.254.71.145"), ""},
0000000000000000000000000000000000000000;;			{"ipv6", ipv6NetworkInterface{}, net.ParseIP("2001::200"), ""},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range testCases {
0000000000000000000000000000000000000000;;			ip, err := chooseIPFromHostInterfaces(tc.nw)
0000000000000000000000000000000000000000;;			if !ip.Equal(tc.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("case[%s]: expected %+v, got %+v with err : %v", tc.tcase, tc.expected, ip, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !strings.Contains(err.Error(), tc.errStrFrag) {
0000000000000000000000000000000000000000;;				t.Errorf("case[%s]: unable to find %q in error string %q", tc.tcase, tc.errStrFrag, err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
