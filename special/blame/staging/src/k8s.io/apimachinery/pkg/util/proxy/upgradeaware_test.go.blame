0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
a4381495a8e8dfc088ef3de32d9f162c92ce78eb;pkg/registry/generic/rest/proxy_test.go[pkg/registry/generic/rest/proxy_test.go][staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package proxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/http/httputil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/assert"
0000000000000000000000000000000000000000;;		"github.com/stretchr/testify/require"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/websocket"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const fakeStatusCode = 567
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeResponder struct {
0000000000000000000000000000000000000000;;		t      *testing.T
0000000000000000000000000000000000000000;;		called bool
0000000000000000000000000000000000000000;;		err    error
0000000000000000000000000000000000000000;;		// called chan error
0000000000000000000000000000000000000000;;		w http.ResponseWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *fakeResponder) Error(err error) {
0000000000000000000000000000000000000000;;		if r.called {
0000000000000000000000000000000000000000;;			r.t.Errorf("Error responder called again!\nprevious error: %v\nnew error: %v", r.err, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.w != nil {
0000000000000000000000000000000000000000;;			r.w.WriteHeader(fakeStatusCode)
0000000000000000000000000000000000000000;;			_, writeErr := r.w.Write([]byte(err.Error()))
0000000000000000000000000000000000000000;;			assert.NoError(r.t, writeErr)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.t.Logf("No ResponseWriter set")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.called = true
0000000000000000000000000000000000000000;;		r.err = err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeConn struct {
0000000000000000000000000000000000000000;;		err error // The error to return when io is performed over the connection.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeConn) Read([]byte) (int, error)        { return 0, f.err }
0000000000000000000000000000000000000000;;	func (f *fakeConn) Write([]byte) (int, error)       { return 0, f.err }
0000000000000000000000000000000000000000;;	func (f *fakeConn) Close() error                    { return nil }
0000000000000000000000000000000000000000;;	func (fakeConn) LocalAddr() net.Addr                { return nil }
0000000000000000000000000000000000000000;;	func (fakeConn) RemoteAddr() net.Addr               { return nil }
0000000000000000000000000000000000000000;;	func (fakeConn) SetDeadline(t time.Time) error      { return nil }
0000000000000000000000000000000000000000;;	func (fakeConn) SetReadDeadline(t time.Time) error  { return nil }
0000000000000000000000000000000000000000;;	func (fakeConn) SetWriteDeadline(t time.Time) error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SimpleBackendHandler struct {
0000000000000000000000000000000000000000;;		requestURL     url.URL
0000000000000000000000000000000000000000;;		requestHeader  http.Header
0000000000000000000000000000000000000000;;		requestBody    []byte
0000000000000000000000000000000000000000;;		requestMethod  string
0000000000000000000000000000000000000000;;		responseBody   string
0000000000000000000000000000000000000000;;		responseHeader map[string]string
0000000000000000000000000000000000000000;;		t              *testing.T
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SimpleBackendHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		s.requestURL = *req.URL
0000000000000000000000000000000000000000;;		s.requestHeader = req.Header
0000000000000000000000000000000000000000;;		s.requestMethod = req.Method
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		s.requestBody, err = ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			s.t.Errorf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.responseHeader != nil {
0000000000000000000000000000000000000000;;			for k, v := range s.responseHeader {
0000000000000000000000000000000000000000;;				w.Header().Add(k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write([]byte(s.responseBody))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateParameters(t *testing.T, name string, actual url.Values, expected map[string]string) {
0000000000000000000000000000000000000000;;		for k, v := range expected {
0000000000000000000000000000000000000000;;			actualValue, ok := actual[k]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected parameter %s not received", name, k)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actualValue[0] != v {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Parameter %s values don't match. Actual: %#v, Expected: %s",
0000000000000000000000000000000000000000;;					name, k, actualValue, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateHeaders(t *testing.T, name string, actual http.Header, expected map[string]string, notExpected []string) {
0000000000000000000000000000000000000000;;		for k, v := range expected {
0000000000000000000000000000000000000000;;			actualValue, ok := actual[k]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected header %s not received", name, k)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actualValue[0] != v {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Header %s values don't match. Actual: %s, Expected: %s",
0000000000000000000000000000000000000000;;					name, k, actualValue, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if notExpected == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, h := range notExpected {
0000000000000000000000000000000000000000;;			if _, present := actual[h]; present {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected header: %s", name, h)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestServeHTTP(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name                  string
0000000000000000000000000000000000000000;;			method                string
0000000000000000000000000000000000000000;;			requestPath           string
0000000000000000000000000000000000000000;;			expectedPath          string
0000000000000000000000000000000000000000;;			requestBody           string
0000000000000000000000000000000000000000;;			requestParams         map[string]string
0000000000000000000000000000000000000000;;			requestHeader         map[string]string
0000000000000000000000000000000000000000;;			responseHeader        map[string]string
0000000000000000000000000000000000000000;;			expectedRespHeader    map[string]string
0000000000000000000000000000000000000000;;			notExpectedRespHeader []string
0000000000000000000000000000000000000000;;			upgradeRequired       bool
0000000000000000000000000000000000000000;;			expectError           func(err error) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "root path, simple get",
0000000000000000000000000000000000000000;;				method:       "GET",
0000000000000000000000000000000000000000;;				requestPath:  "/",
0000000000000000000000000000000000000000;;				expectedPath: "/",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:            "no upgrade header sent",
0000000000000000000000000000000000000000;;				method:          "GET",
0000000000000000000000000000000000000000;;				requestPath:     "/",
0000000000000000000000000000000000000000;;				upgradeRequired: true,
0000000000000000000000000000000000000000;;				expectError: func(err error) bool {
0000000000000000000000000000000000000000;;					return err != nil && strings.Contains(err.Error(), "Upgrade request required")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "simple path, get",
0000000000000000000000000000000000000000;;				method:       "GET",
0000000000000000000000000000000000000000;;				requestPath:  "/path/to/test",
0000000000000000000000000000000000000000;;				expectedPath: "/path/to/test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "request params",
0000000000000000000000000000000000000000;;				method:        "POST",
0000000000000000000000000000000000000000;;				requestPath:   "/some/path/",
0000000000000000000000000000000000000000;;				expectedPath:  "/some/path/",
0000000000000000000000000000000000000000;;				requestParams: map[string]string{"param1": "value/1", "param2": "value%2"},
0000000000000000000000000000000000000000;;				requestBody:   "test request body",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "request headers",
0000000000000000000000000000000000000000;;				method:        "PUT",
0000000000000000000000000000000000000000;;				requestPath:   "/some/path",
0000000000000000000000000000000000000000;;				expectedPath:  "/some/path",
0000000000000000000000000000000000000000;;				requestHeader: map[string]string{"Header1": "value1", "Header2": "value2"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "empty path - slash should be added",
0000000000000000000000000000000000000000;;				method:       "GET",
0000000000000000000000000000000000000000;;				requestPath:  "",
0000000000000000000000000000000000000000;;				expectedPath: "/",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:         "remove CORS headers",
0000000000000000000000000000000000000000;;				method:       "GET",
0000000000000000000000000000000000000000;;				requestPath:  "/some/path",
0000000000000000000000000000000000000000;;				expectedPath: "/some/path",
0000000000000000000000000000000000000000;;				responseHeader: map[string]string{
0000000000000000000000000000000000000000;;					"Header1":                      "value1",
0000000000000000000000000000000000000000;;					"Access-Control-Allow-Origin":  "some.server",
0000000000000000000000000000000000000000;;					"Access-Control-Allow-Methods": "GET"},
0000000000000000000000000000000000000000;;				expectedRespHeader: map[string]string{
0000000000000000000000000000000000000000;;					"Header1": "value1",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				notExpectedRespHeader: []string{
0000000000000000000000000000000000000000;;					"Access-Control-Allow-Origin",
0000000000000000000000000000000000000000;;					"Access-Control-Allow-Methods",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			func() {
0000000000000000000000000000000000000000;;				backendResponse := "<html><head></head><body><a href=\"/test/path\">Hello</a></body></html>"
0000000000000000000000000000000000000000;;				backendResponseHeader := test.responseHeader
0000000000000000000000000000000000000000;;				// Test a simple header if not specified in the test
0000000000000000000000000000000000000000;;				if backendResponseHeader == nil && test.expectedRespHeader == nil {
0000000000000000000000000000000000000000;;					backendResponseHeader = map[string]string{"Content-Type": "text/html"}
0000000000000000000000000000000000000000;;					test.expectedRespHeader = map[string]string{"Content-Type": "text/html"}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				backendHandler := &SimpleBackendHandler{
0000000000000000000000000000000000000000;;					responseBody:   backendResponse,
0000000000000000000000000000000000000000;;					responseHeader: backendResponseHeader,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				backendServer := httptest.NewServer(backendHandler)
0000000000000000000000000000000000000000;;				defer backendServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				responder := &fakeResponder{t: t}
0000000000000000000000000000000000000000;;				backendURL, _ := url.Parse(backendServer.URL)
0000000000000000000000000000000000000000;;				backendURL.Path = test.requestPath
0000000000000000000000000000000000000000;;				proxyHandler := &UpgradeAwareHandler{
0000000000000000000000000000000000000000;;					Location:        backendURL,
0000000000000000000000000000000000000000;;					Responder:       responder,
0000000000000000000000000000000000000000;;					UpgradeRequired: test.upgradeRequired,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				proxyServer := httptest.NewServer(proxyHandler)
0000000000000000000000000000000000000000;;				defer proxyServer.Close()
0000000000000000000000000000000000000000;;				proxyURL, _ := url.Parse(proxyServer.URL)
0000000000000000000000000000000000000000;;				proxyURL.Path = test.requestPath
0000000000000000000000000000000000000000;;				paramValues := url.Values{}
0000000000000000000000000000000000000000;;				for k, v := range test.requestParams {
0000000000000000000000000000000000000000;;					paramValues[k] = []string{v}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				proxyURL.RawQuery = paramValues.Encode()
0000000000000000000000000000000000000000;;				var requestBody io.Reader
0000000000000000000000000000000000000000;;				if test.requestBody != "" {
0000000000000000000000000000000000000000;;					requestBody = bytes.NewBufferString(test.requestBody)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				req, err := http.NewRequest(test.method, proxyURL.String(), requestBody)
0000000000000000000000000000000000000000;;				if test.requestHeader != nil {
0000000000000000000000000000000000000000;;					header := http.Header{}
0000000000000000000000000000000000000000;;					for k, v := range test.requestHeader {
0000000000000000000000000000000000000000;;						header.Add(k, v)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					req.Header = header
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Error creating client request: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				client := &http.Client{}
0000000000000000000000000000000000000000;;				res, err := client.Do(req)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Error from proxy request: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if test.expectError != nil {
0000000000000000000000000000000000000000;;					if !responder.called {
0000000000000000000000000000000000000000;;						t.Errorf("%d: responder was not invoked", i)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !test.expectError(responder.err) {
0000000000000000000000000000000000000000;;						t.Errorf("%d: unexpected error: %v", i, responder.err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Validate backend request
0000000000000000000000000000000000000000;;				// Method
0000000000000000000000000000000000000000;;				if backendHandler.requestMethod != test.method {
0000000000000000000000000000000000000000;;					t.Errorf("Unexpected request method: %s. Expected: %s",
0000000000000000000000000000000000000000;;						backendHandler.requestMethod, test.method)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Body
0000000000000000000000000000000000000000;;				if string(backendHandler.requestBody) != test.requestBody {
0000000000000000000000000000000000000000;;					t.Errorf("Unexpected request body: %s. Expected: %s",
0000000000000000000000000000000000000000;;						string(backendHandler.requestBody), test.requestBody)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Path
0000000000000000000000000000000000000000;;				if backendHandler.requestURL.Path != test.expectedPath {
0000000000000000000000000000000000000000;;					t.Errorf("Unexpected request path: %s", backendHandler.requestURL.Path)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Parameters
0000000000000000000000000000000000000000;;				validateParameters(t, test.name, backendHandler.requestURL.Query(), test.requestParams)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Headers
0000000000000000000000000000000000000000;;				validateHeaders(t, test.name+" backend request", backendHandler.requestHeader,
0000000000000000000000000000000000000000;;					test.requestHeader, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Validate proxy response
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Response Headers
0000000000000000000000000000000000000000;;				validateHeaders(t, test.name+" backend headers", res.Header, test.expectedRespHeader, test.notExpectedRespHeader)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Validate Body
0000000000000000000000000000000000000000;;				responseBody, err := ioutil.ReadAll(res.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("Unexpected error reading response body: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if rb := string(responseBody); rb != backendResponse {
0000000000000000000000000000000000000000;;					t.Errorf("Did not get expected response body: %s. Expected: %s", rb, backendResponse)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Error
0000000000000000000000000000000000000000;;				if responder.called {
0000000000000000000000000000000000000000;;					t.Errorf("Unexpected proxy handler error: %v", responder.err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProxyUpgrade(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		localhostPool := x509.NewCertPool()
0000000000000000000000000000000000000000;;		if !localhostPool.AppendCertsFromPEM(localhostCert) {
0000000000000000000000000000000000000000;;			t.Errorf("error setting up localhostCert pool")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testcases := map[string]struct {
0000000000000000000000000000000000000000;;			ServerFunc     func(http.Handler) *httptest.Server
0000000000000000000000000000000000000000;;			ProxyTransport http.RoundTripper
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"http": {
0000000000000000000000000000000000000000;;				ServerFunc:     httptest.NewServer,
0000000000000000000000000000000000000000;;				ProxyTransport: nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"https (invalid hostname + InsecureSkipVerify)": {
0000000000000000000000000000000000000000;;				ServerFunc: func(h http.Handler) *httptest.Server {
0000000000000000000000000000000000000000;;					cert, err := tls.X509KeyPair(exampleCert, exampleKey)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("https (invalid hostname): proxy_test: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts := httptest.NewUnstartedServer(h)
0000000000000000000000000000000000000000;;					ts.TLS = &tls.Config{
0000000000000000000000000000000000000000;;						Certificates: []tls.Certificate{cert},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts.StartTLS()
0000000000000000000000000000000000000000;;					return ts
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ProxyTransport: utilnet.SetTransportDefaults(&http.Transport{TLSClientConfig: &tls.Config{InsecureSkipVerify: true}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"https (valid hostname + RootCAs)": {
0000000000000000000000000000000000000000;;				ServerFunc: func(h http.Handler) *httptest.Server {
0000000000000000000000000000000000000000;;					cert, err := tls.X509KeyPair(localhostCert, localhostKey)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("https (valid hostname): proxy_test: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts := httptest.NewUnstartedServer(h)
0000000000000000000000000000000000000000;;					ts.TLS = &tls.Config{
0000000000000000000000000000000000000000;;						Certificates: []tls.Certificate{cert},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts.StartTLS()
0000000000000000000000000000000000000000;;					return ts
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ProxyTransport: utilnet.SetTransportDefaults(&http.Transport{TLSClientConfig: &tls.Config{RootCAs: localhostPool}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"https (valid hostname + RootCAs + custom dialer)": {
0000000000000000000000000000000000000000;;				ServerFunc: func(h http.Handler) *httptest.Server {
0000000000000000000000000000000000000000;;					cert, err := tls.X509KeyPair(localhostCert, localhostKey)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("https (valid hostname): proxy_test: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts := httptest.NewUnstartedServer(h)
0000000000000000000000000000000000000000;;					ts.TLS = &tls.Config{
0000000000000000000000000000000000000000;;						Certificates: []tls.Certificate{cert},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts.StartTLS()
0000000000000000000000000000000000000000;;					return ts
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ProxyTransport: utilnet.SetTransportDefaults(&http.Transport{Dial: net.Dial, TLSClientConfig: &tls.Config{RootCAs: localhostPool}}),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, tc := range testcases {
0000000000000000000000000000000000000000;;			for _, redirect := range []bool{false, true} {
0000000000000000000000000000000000000000;;				tcName := k
0000000000000000000000000000000000000000;;				backendPath := "/hello"
0000000000000000000000000000000000000000;;				if redirect {
0000000000000000000000000000000000000000;;					tcName += " with redirect"
0000000000000000000000000000000000000000;;					backendPath = "/redirect"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				func() { // Cleanup after each test case.
0000000000000000000000000000000000000000;;					backend := http.NewServeMux()
0000000000000000000000000000000000000000;;					backend.Handle("/hello", websocket.Handler(func(ws *websocket.Conn) {
0000000000000000000000000000000000000000;;						defer ws.Close()
0000000000000000000000000000000000000000;;						body := make([]byte, 5)
0000000000000000000000000000000000000000;;						ws.Read(body)
0000000000000000000000000000000000000000;;						ws.Write([]byte("hello " + string(body)))
0000000000000000000000000000000000000000;;					}))
0000000000000000000000000000000000000000;;					backend.Handle("/redirect", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;						http.Redirect(w, r, "/hello", http.StatusFound)
0000000000000000000000000000000000000000;;					}))
0000000000000000000000000000000000000000;;					backendServer := tc.ServerFunc(backend)
0000000000000000000000000000000000000000;;					defer backendServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					serverURL, _ := url.Parse(backendServer.URL)
0000000000000000000000000000000000000000;;					serverURL.Path = backendPath
0000000000000000000000000000000000000000;;					proxyHandler := &UpgradeAwareHandler{
0000000000000000000000000000000000000000;;						Location:           serverURL,
0000000000000000000000000000000000000000;;						Transport:          tc.ProxyTransport,
0000000000000000000000000000000000000000;;						InterceptRedirects: redirect,
0000000000000000000000000000000000000000;;						Responder:          &noErrorsAllowed{t: t},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					proxy := httptest.NewServer(proxyHandler)
0000000000000000000000000000000000000000;;					defer proxy.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					ws, err := websocket.Dial("ws://"+proxy.Listener.Addr().String()+"/some/path", "", "http://127.0.0.1/")
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: websocket dial err: %s", tcName, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					defer ws.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if _, err := ws.Write([]byte("world")); err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: write err: %s", tcName, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					response := make([]byte, 20)
0000000000000000000000000000000000000000;;					n, err := ws.Read(response)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: read err: %s", tcName, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if e, a := "hello world", string(response[0:n]); e != a {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: expected '%#v', got '%#v'", tcName, e, a)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type noErrorsAllowed struct {
0000000000000000000000000000000000000000;;		t *testing.T
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *noErrorsAllowed) Error(err error) {
0000000000000000000000000000000000000000;;		r.t.Error(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProxyUpgradeErrorResponse(t *testing.T) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			responder   *fakeResponder
0000000000000000000000000000000000000000;;			expectedErr = errors.New("EXPECTED")
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		proxy := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			transport := http.DefaultTransport.(*http.Transport)
0000000000000000000000000000000000000000;;			transport.Dial = func(network, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;				return &fakeConn{err: expectedErr}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			responder = &fakeResponder{t: t, w: w}
0000000000000000000000000000000000000000;;			proxyHandler := &UpgradeAwareHandler{
0000000000000000000000000000000000000000;;				Location: &url.URL{
0000000000000000000000000000000000000000;;					Host: "fake-backend",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				UpgradeRequired: true,
0000000000000000000000000000000000000000;;				Responder:       responder,
0000000000000000000000000000000000000000;;				Transport:       transport,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			proxyHandler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;		}))
0000000000000000000000000000000000000000;;		defer proxy.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Send request to proxy server.
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", "http://"+proxy.Listener.Addr().String()+"/some/path", nil)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		req.Header.Set(httpstream.HeaderConnection, httpstream.HeaderUpgrade)
0000000000000000000000000000000000000000;;		resp, err := http.DefaultClient.Do(req)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expect error response.
0000000000000000000000000000000000000000;;		assert.True(t, responder.called)
0000000000000000000000000000000000000000;;		assert.Equal(t, fakeStatusCode, resp.StatusCode)
0000000000000000000000000000000000000000;;		msg, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		require.NoError(t, err)
0000000000000000000000000000000000000000;;		assert.Contains(t, string(msg), expectedErr.Error())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDefaultProxyTransport(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name,
0000000000000000000000000000000000000000;;			url,
0000000000000000000000000000000000000000;;			location,
0000000000000000000000000000000000000000;;			expectedScheme,
0000000000000000000000000000000000000000;;			expectedHost,
0000000000000000000000000000000000000000;;			expectedPathPrepend string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:                "simple path",
0000000000000000000000000000000000000000;;				url:                 "http://test.server:8080/a/test/location",
0000000000000000000000000000000000000000;;				location:            "http://localhost/location",
0000000000000000000000000000000000000000;;				expectedScheme:      "http",
0000000000000000000000000000000000000000;;				expectedHost:        "test.server:8080",
0000000000000000000000000000000000000000;;				expectedPathPrepend: "/a/test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:                "empty path",
0000000000000000000000000000000000000000;;				url:                 "http://test.server:8080/a/test/",
0000000000000000000000000000000000000000;;				location:            "http://localhost",
0000000000000000000000000000000000000000;;				expectedScheme:      "http",
0000000000000000000000000000000000000000;;				expectedHost:        "test.server:8080",
0000000000000000000000000000000000000000;;				expectedPathPrepend: "/a/test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:                "location ending in slash",
0000000000000000000000000000000000000000;;				url:                 "http://test.server:8080/a/test/",
0000000000000000000000000000000000000000;;				location:            "http://localhost/",
0000000000000000000000000000000000000000;;				expectedScheme:      "http",
0000000000000000000000000000000000000000;;				expectedHost:        "test.server:8080",
0000000000000000000000000000000000000000;;				expectedPathPrepend: "/a/test",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			locURL, _ := url.Parse(test.location)
0000000000000000000000000000000000000000;;			URL, _ := url.Parse(test.url)
0000000000000000000000000000000000000000;;			h := UpgradeAwareHandler{
0000000000000000000000000000000000000000;;				Location: locURL,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result := h.defaultProxyTransport(URL, nil)
0000000000000000000000000000000000000000;;			transport := result.(*corsRemovingTransport).RoundTripper.(*Transport)
0000000000000000000000000000000000000000;;			if transport.Scheme != test.expectedScheme {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected scheme. Actual: %s, Expected: %s", test.name, transport.Scheme, test.expectedScheme)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if transport.Host != test.expectedHost {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected host. Actual: %s, Expected: %s", test.name, transport.Host, test.expectedHost)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if transport.PathPrepend != test.expectedPathPrepend {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected path prepend. Actual: %s, Expected: %s", test.name, transport.PathPrepend, test.expectedPathPrepend)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestProxyRequestContentLengthAndTransferEncoding(t *testing.T) {
0000000000000000000000000000000000000000;;		chunk := func(data []byte) []byte {
0000000000000000000000000000000000000000;;			out := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			chunker := httputil.NewChunkedWriter(out)
0000000000000000000000000000000000000000;;			for _, b := range data {
0000000000000000000000000000000000000000;;				if _, err := chunker.Write([]byte{b}); err != nil {
0000000000000000000000000000000000000000;;					panic(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			chunker.Close()
0000000000000000000000000000000000000000;;			out.Write([]byte("\r\n"))
0000000000000000000000000000000000000000;;			return out.Bytes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zip := func(data []byte) []byte {
0000000000000000000000000000000000000000;;			out := &bytes.Buffer{}
0000000000000000000000000000000000000000;;			zipper := gzip.NewWriter(out)
0000000000000000000000000000000000000000;;			if _, err := zipper.Write(data); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			zipper.Close()
0000000000000000000000000000000000000000;;			return out.Bytes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sampleData := []byte("abcde")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := map[string]struct {
0000000000000000000000000000000000000000;;			reqHeaders http.Header
0000000000000000000000000000000000000000;;			reqBody    []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectedHeaders http.Header
0000000000000000000000000000000000000000;;			expectedBody    []byte
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"content-length": {
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length": []string{"5"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqBody: sampleData,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    []string{"5"},
0000000000000000000000000000000000000000;;					"Content-Encoding":  nil, // none set
0000000000000000000000000000000000000000;;					"Transfer-Encoding": nil, // none set
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedBody: sampleData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"content-length + identity transfer-encoding": {
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    []string{"5"},
0000000000000000000000000000000000000000;;					"Transfer-Encoding": []string{"identity"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqBody: sampleData,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    []string{"5"},
0000000000000000000000000000000000000000;;					"Content-Encoding":  nil, // none set
0000000000000000000000000000000000000000;;					"Transfer-Encoding": nil, // gets removed
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedBody: sampleData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"content-length + gzip content-encoding": {
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":   []string{strconv.Itoa(len(zip(sampleData)))},
0000000000000000000000000000000000000000;;					"Content-Encoding": []string{"gzip"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqBody: zip(sampleData),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    []string{strconv.Itoa(len(zip(sampleData)))},
0000000000000000000000000000000000000000;;					"Content-Encoding":  []string{"gzip"},
0000000000000000000000000000000000000000;;					"Transfer-Encoding": nil, // none set
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedBody: zip(sampleData),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"chunked transfer-encoding": {
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Transfer-Encoding": []string{"chunked"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqBody: chunk(sampleData),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    nil, // none set
0000000000000000000000000000000000000000;;					"Content-Encoding":  nil, // none set
0000000000000000000000000000000000000000;;					"Transfer-Encoding": nil, // Transfer-Encoding gets removed
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedBody: sampleData, // sample data is unchunked
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"chunked transfer-encoding + gzip content-encoding": {
0000000000000000000000000000000000000000;;				reqHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Encoding":  []string{"gzip"},
0000000000000000000000000000000000000000;;					"Transfer-Encoding": []string{"chunked"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				reqBody: chunk(zip(sampleData)),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;					"Content-Length":    nil, // none set
0000000000000000000000000000000000000000;;					"Content-Encoding":  []string{"gzip"},
0000000000000000000000000000000000000000;;					"Transfer-Encoding": nil, // gets removed
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedBody: zip(sampleData), // sample data is unchunked, but content-encoding is preserved
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// "Transfer-Encoding: gzip" is not supported by go
0000000000000000000000000000000000000000;;			// See http/transfer.go#fixTransferEncoding (https://golang.org/src/net/http/transfer.go#L427)
0000000000000000000000000000000000000000;;			// Once it is supported, this test case should succeed
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// "gzip+chunked transfer-encoding": {
0000000000000000000000000000000000000000;;			// 	reqHeaders: http.Header{
0000000000000000000000000000000000000000;;			// 		"Transfer-Encoding": []string{"chunked,gzip"},
0000000000000000000000000000000000000000;;			// 	},
0000000000000000000000000000000000000000;;			// 	reqBody: chunk(zip(sampleData)),
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// 	expectedHeaders: http.Header{
0000000000000000000000000000000000000000;;			// 		"Content-Length":    nil, // no content-length headers
0000000000000000000000000000000000000000;;			// 		"Transfer-Encoding": nil, // Transfer-Encoding gets removed
0000000000000000000000000000000000000000;;			// 	},
0000000000000000000000000000000000000000;;			// 	expectedBody: sampleData,
0000000000000000000000000000000000000000;;			// },
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		successfulResponse := "backend passed tests"
0000000000000000000000000000000000000000;;		for k, item := range table {
0000000000000000000000000000000000000000;;			// Start the downstream server
0000000000000000000000000000000000000000;;			downstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				// Verify headers
0000000000000000000000000000000000000000;;				for header, v := range item.expectedHeaders {
0000000000000000000000000000000000000000;;					if !reflect.DeepEqual(v, req.Header[header]) {
0000000000000000000000000000000000000000;;						t.Errorf("%s: Expected headers for %s to be %v, got %v", k, header, v, req.Header[header])
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Read body
0000000000000000000000000000000000000000;;				body, err := ioutil.ReadAll(req.Body)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				req.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Verify length
0000000000000000000000000000000000000000;;				if req.ContentLength > 0 && req.ContentLength != int64(len(body)) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: ContentLength was %d, len(data) was %d", k, req.ContentLength, len(body))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Verify content
0000000000000000000000000000000000000000;;				if !bytes.Equal(item.expectedBody, body) {
0000000000000000000000000000000000000000;;					t.Errorf("%s: Expected %q, got %q", k, string(item.expectedBody), string(body))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Write successful response
0000000000000000000000000000000000000000;;				w.Write([]byte(successfulResponse))
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;			defer downstreamServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			responder := &fakeResponder{t: t}
0000000000000000000000000000000000000000;;			backendURL, _ := url.Parse(downstreamServer.URL)
0000000000000000000000000000000000000000;;			proxyHandler := &UpgradeAwareHandler{
0000000000000000000000000000000000000000;;				Location:        backendURL,
0000000000000000000000000000000000000000;;				Responder:       responder,
0000000000000000000000000000000000000000;;				UpgradeRequired: false,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			proxyServer := httptest.NewServer(proxyHandler)
0000000000000000000000000000000000000000;;			defer proxyServer.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Dial the proxy server
0000000000000000000000000000000000000000;;			conn, err := net.Dial(proxyServer.Listener.Addr().Network(), proxyServer.Listener.Addr().String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error %v", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add standard http 1.1 headers
0000000000000000000000000000000000000000;;			if item.reqHeaders == nil {
0000000000000000000000000000000000000000;;				item.reqHeaders = http.Header{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			item.reqHeaders.Add("Connection", "close")
0000000000000000000000000000000000000000;;			item.reqHeaders.Add("Host", proxyServer.Listener.Addr().String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write the request headers
0000000000000000000000000000000000000000;;			if _, err := fmt.Fprint(conn, "POST / HTTP/1.1\r\n"); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s unexpected error %v", k, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for header, values := range item.reqHeaders {
0000000000000000000000000000000000000000;;				for _, value := range values {
0000000000000000000000000000000000000000;;					if _, err := fmt.Fprintf(conn, "%s: %s\r\n", header, value); err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Header separator
0000000000000000000000000000000000000000;;			if _, err := fmt.Fprint(conn, "\r\n"); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Body
0000000000000000000000000000000000000000;;			if _, err := conn.Write(item.reqBody); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read response
0000000000000000000000000000000000000000;;			response, err := ioutil.ReadAll(conn)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error %v", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !strings.HasSuffix(string(response), successfulResponse) {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Did not get successful response: %s", k, string(response))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exampleCert was generated from crypto/tls/generate_cert.go with the following command:
0000000000000000000000000000000000000000;;	//    go run generate_cert.go  --rsa-bits 512 --host example.com --ca --start-date "Jan 1 00:00:00 1970" --duration=1000000h
0000000000000000000000000000000000000000;;	var exampleCert = []byte(`-----BEGIN CERTIFICATE-----
0000000000000000000000000000000000000000;;	MIIBdzCCASGgAwIBAgIRAOVTAdPnfbS5V85mfS90TfIwDQYJKoZIhvcNAQELBQAw
0000000000000000000000000000000000000000;;	EjEQMA4GA1UEChMHQWNtZSBDbzAgFw03MDAxMDEwMDAwMDBaGA8yMDg0MDEyOTE2
0000000000000000000000000000000000000000;;	MDAwMFowEjEQMA4GA1UEChMHQWNtZSBDbzBcMA0GCSqGSIb3DQEBAQUAA0sAMEgC
0000000000000000000000000000000000000000;;	QQCoVSqeu8TBvF+70T7Jm4340YQNhds6IxjRoifenYodAO1dnKGrcbF266DJGunh
0000000000000000000000000000000000000000;;	nIjQH7B12tduhl0fLK4Ezf7/AgMBAAGjUDBOMA4GA1UdDwEB/wQEAwICpDATBgNV
0000000000000000000000000000000000000000;;	HSUEDDAKBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MBYGA1UdEQQPMA2CC2V4
0000000000000000000000000000000000000000;;	YW1wbGUuY29tMA0GCSqGSIb3DQEBCwUAA0EAk1kVa5uZ/AzwYDVcS9bpM/czwjjV
0000000000000000000000000000000000000000;;	xq3VeSCfmNa2uNjbFvodmCRwZOHUvipAMGCUCV6j5vMrJ8eMj8tCQ36W9A==
0000000000000000000000000000000000000000;;	-----END CERTIFICATE-----`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var exampleKey = []byte(`-----BEGIN RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIBOgIBAAJBAKhVKp67xMG8X7vRPsmbjfjRhA2F2zojGNGiJ96dih0A7V2coatx
0000000000000000000000000000000000000000;;	sXbroMka6eGciNAfsHXa126GXR8srgTN/v8CAwEAAQJASdzdD7vKsUwMIejGCUb1
0000000000000000000000000000000000000000;;	fAnLTPfAY3lFCa+CmR89nE22dAoRDv+5RbnBsZ58BazPNJHrsVPRlfXB3OQmSQr0
0000000000000000000000000000000000000000;;	SQIhANoJhs+xOJE/i8nJv0uAbzKyiD1YkvRkta0GpUOULyAVAiEAxaQus3E/SuqD
0000000000000000000000000000000000000000;;	P7y5NeJnE7X6XkyC35zrsJRkz7orE8MCIHdDjsI8pjyNDeGqwUCDWE/a6DrmIDwe
0000000000000000000000000000000000000000;;	emHSqMN2YvChAiEAnxLCM9NWaenOsaIoP+J1rDuvw+4499nJKVqGuVrSCRkCIEqK
0000000000000000000000000000000000000000;;	4KSchPMc3x8M/uhw9oWTtKFmjA/PPh0FsWCdKrEy
0000000000000000000000000000000000000000;;	-----END RSA PRIVATE KEY-----`)
