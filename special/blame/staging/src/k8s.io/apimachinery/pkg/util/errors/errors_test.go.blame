0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package errors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEmptyAggregate(t *testing.T) {
0000000000000000000000000000000000000000;;		var slice []error
0000000000000000000000000000000000000000;;		var agg Aggregate
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		agg = NewAggregate(slice)
0000000000000000000000000000000000000000;;		if agg != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected nil, got %#v", agg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = NewAggregate(slice)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected nil, got %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This is not normally possible, but pedantry demands I test it.
0000000000000000000000000000000000000000;;		agg = aggregate(slice) // empty aggregate
0000000000000000000000000000000000000000;;		if s := agg.Error(); s != "" {
0000000000000000000000000000000000000000;;			t.Errorf("expected empty string, got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := agg.Errors(); len(s) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("expected empty slice, got %#v", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = agg.(error)
0000000000000000000000000000000000000000;;		if s := err.Error(); s != "" {
0000000000000000000000000000000000000000;;			t.Errorf("expected empty string, got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAggregateWithNil(t *testing.T) {
0000000000000000000000000000000000000000;;		var slice []error
0000000000000000000000000000000000000000;;		slice = []error{nil}
0000000000000000000000000000000000000000;;		var agg Aggregate
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		agg = NewAggregate(slice)
0000000000000000000000000000000000000000;;		if agg != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected nil, got %#v", agg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = NewAggregate(slice)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected nil, got %#v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Append a non-nil error
0000000000000000000000000000000000000000;;		slice = append(slice, fmt.Errorf("err"))
0000000000000000000000000000000000000000;;		agg = NewAggregate(slice)
0000000000000000000000000000000000000000;;		if agg == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected non-nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := agg.Error(); s != "err" {
0000000000000000000000000000000000000000;;			t.Errorf("expected 'err', got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := agg.Errors(); len(s) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected one-element slice, got %#v", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := agg.Errors()[0].Error(); s != "err" {
0000000000000000000000000000000000000000;;			t.Errorf("expected 'err', got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = agg.(error)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected non-nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := err.Error(); s != "err" {
0000000000000000000000000000000000000000;;			t.Errorf("expected 'err', got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSingularAggregate(t *testing.T) {
0000000000000000000000000000000000000000;;		var slice []error = []error{fmt.Errorf("err")}
0000000000000000000000000000000000000000;;		var agg Aggregate
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		agg = NewAggregate(slice)
0000000000000000000000000000000000000000;;		if agg == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected non-nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := agg.Error(); s != "err" {
0000000000000000000000000000000000000000;;			t.Errorf("expected 'err', got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := agg.Errors(); len(s) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected one-element slice, got %#v", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := agg.Errors()[0].Error(); s != "err" {
0000000000000000000000000000000000000000;;			t.Errorf("expected 'err', got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = agg.(error)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected non-nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := err.Error(); s != "err" {
0000000000000000000000000000000000000000;;			t.Errorf("expected 'err', got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPluralAggregate(t *testing.T) {
0000000000000000000000000000000000000000;;		var slice []error = []error{fmt.Errorf("abc"), fmt.Errorf("123")}
0000000000000000000000000000000000000000;;		var agg Aggregate
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		agg = NewAggregate(slice)
0000000000000000000000000000000000000000;;		if agg == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected non-nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := agg.Error(); s != "[abc, 123]" {
0000000000000000000000000000000000000000;;			t.Errorf("expected '[abc, 123]', got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := agg.Errors(); len(s) != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("expected two-elements slice, got %#v", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := agg.Errors()[0].Error(); s != "abc" {
0000000000000000000000000000000000000000;;			t.Errorf("expected '[abc, 123]', got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = agg.(error)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("expected non-nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s := err.Error(); s != "[abc, 123]" {
0000000000000000000000000000000000000000;;			t.Errorf("expected '[abc, 123]', got %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFilterOut(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			err      error
0000000000000000000000000000000000000000;;			filter   []Matcher
0000000000000000000000000000000000000000;;			expected error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				[]Matcher{},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{},
0000000000000000000000000000000000000000;;				[]Matcher{},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;				[]Matcher{},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;				[]Matcher{func(err error) bool { return false }},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;				[]Matcher{func(err error) bool { return true }},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;				[]Matcher{func(err error) bool { return false }, func(err error) bool { return false }},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;				[]Matcher{func(err error) bool { return false }, func(err error) bool { return true }},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc"), fmt.Errorf("def"), fmt.Errorf("ghi")},
0000000000000000000000000000000000000000;;				[]Matcher{func(err error) bool { return err.Error() == "def" }},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc"), fmt.Errorf("ghi")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{aggregate{fmt.Errorf("abc")}},
0000000000000000000000000000000000000000;;				[]Matcher{},
0000000000000000000000000000000000000000;;				aggregate{aggregate{fmt.Errorf("abc")}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{aggregate{fmt.Errorf("abc"), aggregate{fmt.Errorf("def")}}},
0000000000000000000000000000000000000000;;				[]Matcher{},
0000000000000000000000000000000000000000;;				aggregate{aggregate{fmt.Errorf("abc"), aggregate{fmt.Errorf("def")}}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{aggregate{fmt.Errorf("abc"), aggregate{fmt.Errorf("def")}}},
0000000000000000000000000000000000000000;;				[]Matcher{func(err error) bool { return err.Error() == "def" }},
0000000000000000000000000000000000000000;;				aggregate{aggregate{fmt.Errorf("abc")}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			err := FilterOut(testCase.err, testCase.filter...)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(testCase.expected, err) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected %v, got %v", i, testCase.expected, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFlatten(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			agg      Aggregate
0000000000000000000000000000000000000000;;			expected Aggregate
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc"), fmt.Errorf("def"), fmt.Errorf("ghi")},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc"), fmt.Errorf("def"), fmt.Errorf("ghi")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{aggregate{fmt.Errorf("abc")}},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{aggregate{aggregate{fmt.Errorf("abc")}}},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{aggregate{fmt.Errorf("abc"), aggregate{fmt.Errorf("def")}}},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc"), fmt.Errorf("def")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				aggregate{aggregate{aggregate{fmt.Errorf("abc")}, fmt.Errorf("def"), aggregate{fmt.Errorf("ghi")}}},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc"), fmt.Errorf("def"), fmt.Errorf("ghi")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			agg := Flatten(testCase.agg)
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(testCase.expected, agg) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected %v, got %v", i, testCase.expected, agg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCreateAggregateFromMessageCountMap(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			mcm      MessageCountMap
0000000000000000000000000000000000000000;;			expected Aggregate
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"input has single instance of one message",
0000000000000000000000000000000000000000;;				MessageCountMap{"abc": 1},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"input has multiple messages",
0000000000000000000000000000000000000000;;				MessageCountMap{"abc": 2, "ghi": 1},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc (repeated 2 times)"), fmt.Errorf("ghi")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"input has multiple messages",
0000000000000000000000000000000000000000;;				MessageCountMap{"ghi": 1, "abc": 2},
0000000000000000000000000000000000000000;;				aggregate{fmt.Errorf("abc (repeated 2 times)"), fmt.Errorf("ghi")},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var expected, agg []error
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			t.Run(testCase.name, func(t *testing.T) {
0000000000000000000000000000000000000000;;				if testCase.expected != nil {
0000000000000000000000000000000000000000;;					expected = testCase.expected.Errors()
0000000000000000000000000000000000000000;;					sort.Slice(expected, func(i, j int) bool { return expected[i].Error() < expected[j].Error() })
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if testCase.mcm != nil {
0000000000000000000000000000000000000000;;					agg = CreateAggregateFromMessageCountMap(testCase.mcm).Errors()
0000000000000000000000000000000000000000;;					sort.Slice(agg, func(i, j int) bool { return agg[i].Error() < agg[j].Error() })
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(expected, agg) {
0000000000000000000000000000000000000000;;					t.Errorf("expected %v, got %v", expected, agg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAggregateGoroutines(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			errs     []error
0000000000000000000000000000000000000000;;			expected map[string]bool // can't compare directly to Aggregate due to non-deterministic ordering
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]error{},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]error{nil},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]error{nil, nil},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]error{fmt.Errorf("1")},
0000000000000000000000000000000000000000;;				map[string]bool{"1": true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]error{fmt.Errorf("1"), nil},
0000000000000000000000000000000000000000;;				map[string]bool{"1": true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]error{fmt.Errorf("1"), fmt.Errorf("267")},
0000000000000000000000000000000000000000;;				map[string]bool{"1": true, "267": true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]error{fmt.Errorf("1"), nil, fmt.Errorf("1234")},
0000000000000000000000000000000000000000;;				map[string]bool{"1": true, "1234": true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				[]error{nil, fmt.Errorf("1"), nil, fmt.Errorf("1234"), fmt.Errorf("22")},
0000000000000000000000000000000000000000;;				map[string]bool{"1": true, "1234": true, "22": true},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			funcs := make([]func() error, len(testCase.errs))
0000000000000000000000000000000000000000;;			for i := range testCase.errs {
0000000000000000000000000000000000000000;;				err := testCase.errs[i]
0000000000000000000000000000000000000000;;				funcs[i] = func() error { return err }
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			agg := AggregateGoroutines(funcs...)
0000000000000000000000000000000000000000;;			if agg == nil {
0000000000000000000000000000000000000000;;				if len(testCase.expected) > 0 {
0000000000000000000000000000000000000000;;					t.Errorf("%d: expected %v, got nil", i, testCase.expected)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(agg.Errors()) != len(testCase.expected) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected %d errors in aggregate, got %v", i, len(testCase.expected), agg)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, err := range agg.Errors() {
0000000000000000000000000000000000000000;;				if !testCase.expected[err.Error()] {
0000000000000000000000000000000000000000;;					t.Errorf("%d: expected %v, got aggregate containing %v", i, testCase.expected, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
