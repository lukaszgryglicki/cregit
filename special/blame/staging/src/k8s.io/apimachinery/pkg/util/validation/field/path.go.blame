0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package field
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Path represents the path from some root to a particular field.
0000000000000000000000000000000000000000;;	type Path struct {
0000000000000000000000000000000000000000;;		name   string // the name of this field or "" if this is an index
0000000000000000000000000000000000000000;;		index  string // if name == "", this is a subscript (index or map key) of the previous element
0000000000000000000000000000000000000000;;		parent *Path  // nil if this is the root element
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPath creates a root Path object.
0000000000000000000000000000000000000000;;	func NewPath(name string, moreNames ...string) *Path {
0000000000000000000000000000000000000000;;		r := &Path{name: name, parent: nil}
0000000000000000000000000000000000000000;;		for _, anotherName := range moreNames {
0000000000000000000000000000000000000000;;			r = &Path{name: anotherName, parent: r}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Root returns the root element of this Path.
0000000000000000000000000000000000000000;;	func (p *Path) Root() *Path {
0000000000000000000000000000000000000000;;		for ; p.parent != nil; p = p.parent {
0000000000000000000000000000000000000000;;			// Do nothing.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Child creates a new Path that is a child of the method receiver.
0000000000000000000000000000000000000000;;	func (p *Path) Child(name string, moreNames ...string) *Path {
0000000000000000000000000000000000000000;;		r := NewPath(name, moreNames...)
0000000000000000000000000000000000000000;;		r.Root().parent = p
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Index indicates that the previous Path is to be subscripted by an int.
0000000000000000000000000000000000000000;;	// This sets the same underlying value as Key.
0000000000000000000000000000000000000000;;	func (p *Path) Index(index int) *Path {
0000000000000000000000000000000000000000;;		return &Path{index: strconv.Itoa(index), parent: p}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Key indicates that the previous Path is to be subscripted by a string.
0000000000000000000000000000000000000000;;	// This sets the same underlying value as Index.
0000000000000000000000000000000000000000;;	func (p *Path) Key(key string) *Path {
0000000000000000000000000000000000000000;;		return &Path{index: key, parent: p}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String produces a string representation of the Path.
0000000000000000000000000000000000000000;;	func (p *Path) String() string {
0000000000000000000000000000000000000000;;		// make a slice to iterate
0000000000000000000000000000000000000000;;		elems := []*Path{}
0000000000000000000000000000000000000000;;		for ; p != nil; p = p.parent {
0000000000000000000000000000000000000000;;			elems = append(elems, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// iterate, but it has to be backwards
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		for i := range elems {
0000000000000000000000000000000000000000;;			p := elems[len(elems)-1-i]
0000000000000000000000000000000000000000;;			if p.parent != nil && len(p.name) > 0 {
0000000000000000000000000000000000000000;;				// This is either the root or it is a subscript.
0000000000000000000000000000000000000000;;				buf.WriteString(".")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(p.name) > 0 {
0000000000000000000000000000000000000000;;				buf.WriteString(p.name)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(buf, "[%s]", p.index)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
