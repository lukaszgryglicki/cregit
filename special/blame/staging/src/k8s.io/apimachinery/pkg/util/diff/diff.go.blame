0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package diff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"text/tabwriter"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringDiff diffs a and b and returns a human readable diff.
0000000000000000000000000000000000000000;;	func StringDiff(a, b string) string {
0000000000000000000000000000000000000000;;		ba := []byte(a)
0000000000000000000000000000000000000000;;		bb := []byte(b)
0000000000000000000000000000000000000000;;		out := []byte{}
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for ; i < len(ba) && i < len(bb); i++ {
0000000000000000000000000000000000000000;;			if ba[i] != bb[i] {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, ba[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out = append(out, []byte("\n\nA: ")...)
0000000000000000000000000000000000000000;;		out = append(out, ba[i:]...)
0000000000000000000000000000000000000000;;		out = append(out, []byte("\n\nB: ")...)
0000000000000000000000000000000000000000;;		out = append(out, bb[i:]...)
0000000000000000000000000000000000000000;;		out = append(out, []byte("\n\n")...)
0000000000000000000000000000000000000000;;		return string(out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectDiff writes the two objects out as JSON and prints out the identical part of
0000000000000000000000000000000000000000;;	// the objects followed by the remaining part of 'a' and finally the remaining part of 'b'.
0000000000000000000000000000000000000000;;	// For debugging tests.
0000000000000000000000000000000000000000;;	func ObjectDiff(a, b interface{}) string {
0000000000000000000000000000000000000000;;		ab, err := json.Marshal(a)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("a: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bb, err := json.Marshal(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("b: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return StringDiff(string(ab), string(bb))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectGoPrintDiff is like ObjectDiff, but uses go-spew to print the objects,
0000000000000000000000000000000000000000;;	// which shows absolutely everything by recursing into every single pointer
0000000000000000000000000000000000000000;;	// (go's %#v formatters OTOH stop at a certain point). This is needed when you
0000000000000000000000000000000000000000;;	// can't figure out why reflect.DeepEqual is returning false and nothing is
0000000000000000000000000000000000000000;;	// showing you differences. This will.
0000000000000000000000000000000000000000;;	func ObjectGoPrintDiff(a, b interface{}) string {
0000000000000000000000000000000000000000;;		s := spew.ConfigState{DisableMethods: true}
0000000000000000000000000000000000000000;;		return StringDiff(
0000000000000000000000000000000000000000;;			s.Sprintf("%#v", a),
0000000000000000000000000000000000000000;;			s.Sprintf("%#v", b),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ObjectReflectDiff(a, b interface{}) string {
0000000000000000000000000000000000000000;;		vA, vB := reflect.ValueOf(a), reflect.ValueOf(b)
0000000000000000000000000000000000000000;;		if vA.Type() != vB.Type() {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("type A %T and type B %T do not match", a, b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		diffs := objectReflectDiff(field.NewPath("object"), vA, vB)
0000000000000000000000000000000000000000;;		if len(diffs) == 0 {
0000000000000000000000000000000000000000;;			return "<no diffs>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := []string{""}
0000000000000000000000000000000000000000;;		for _, d := range diffs {
0000000000000000000000000000000000000000;;			out = append(out,
0000000000000000000000000000000000000000;;				fmt.Sprintf("%s:", d.path),
0000000000000000000000000000000000000000;;				limit(fmt.Sprintf("  a: %#v", d.a), 80),
0000000000000000000000000000000000000000;;				limit(fmt.Sprintf("  b: %#v", d.b), 80),
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(out, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func limit(s string, max int) string {
0000000000000000000000000000000000000000;;		if len(s) > max {
0000000000000000000000000000000000000000;;			return s[:max]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func public(s string) bool {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s[:1] == strings.ToUpper(s[:1])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type diff struct {
0000000000000000000000000000000000000000;;		path *field.Path
0000000000000000000000000000000000000000;;		a, b interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type orderedDiffs []diff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d orderedDiffs) Len() int      { return len(d) }
0000000000000000000000000000000000000000;;	func (d orderedDiffs) Swap(i, j int) { d[i], d[j] = d[j], d[i] }
0000000000000000000000000000000000000000;;	func (d orderedDiffs) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		a, b := d[i].path.String(), d[j].path.String()
0000000000000000000000000000000000000000;;		if a < b {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func objectReflectDiff(path *field.Path, a, b reflect.Value) []diff {
0000000000000000000000000000000000000000;;		switch a.Type().Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			var changes []diff
0000000000000000000000000000000000000000;;			for i := 0; i < a.Type().NumField(); i++ {
0000000000000000000000000000000000000000;;				if !public(a.Type().Field(i).Name) {
0000000000000000000000000000000000000000;;					if reflect.DeepEqual(a.Interface(), b.Interface()) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return []diff{{path: path, a: fmt.Sprintf("%#v", a), b: fmt.Sprintf("%#v", b)}}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if sub := objectReflectDiff(path.Child(a.Type().Field(i).Name), a.Field(i), b.Field(i)); len(sub) > 0 {
0000000000000000000000000000000000000000;;					changes = append(changes, sub...)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if !reflect.DeepEqual(a.Field(i).Interface(), b.Field(i).Interface()) {
0000000000000000000000000000000000000000;;						changes = append(changes, diff{path: path, a: a.Field(i).Interface(), b: b.Field(i).Interface()})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return changes
0000000000000000000000000000000000000000;;		case reflect.Ptr, reflect.Interface:
0000000000000000000000000000000000000000;;			if a.IsNil() || b.IsNil() {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case a.IsNil() && b.IsNil():
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				case a.IsNil():
0000000000000000000000000000000000000000;;					return []diff{{path: path, a: nil, b: b.Interface()}}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return []diff{{path: path, a: a.Interface(), b: nil}}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return objectReflectDiff(path, a.Elem(), b.Elem())
0000000000000000000000000000000000000000;;		case reflect.Chan:
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(a.Interface(), b.Interface()) {
0000000000000000000000000000000000000000;;				return []diff{{path: path, a: a.Interface(), b: b.Interface()}}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			lA, lB := a.Len(), b.Len()
0000000000000000000000000000000000000000;;			l := lA
0000000000000000000000000000000000000000;;			if lB < lA {
0000000000000000000000000000000000000000;;				l = lB
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lA == lB && lA == 0 {
0000000000000000000000000000000000000000;;				if a.IsNil() != b.IsNil() {
0000000000000000000000000000000000000000;;					return []diff{{path: path, a: a.Interface(), b: b.Interface()}}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(a.Index(i), b.Index(i)) {
0000000000000000000000000000000000000000;;					return objectReflectDiff(path.Index(i), a.Index(i), b.Index(i))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var diffs []diff
0000000000000000000000000000000000000000;;			for i := l; i < lA; i++ {
0000000000000000000000000000000000000000;;				diffs = append(diffs, diff{path: path.Index(i), a: a.Index(i), b: nil})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := l; i < lB; i++ {
0000000000000000000000000000000000000000;;				diffs = append(diffs, diff{path: path.Index(i), a: nil, b: b.Index(i)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(diffs) == 0 {
0000000000000000000000000000000000000000;;				diffs = append(diffs, diff{path: path, a: a, b: b})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return diffs
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(a.Interface(), b.Interface()) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			aKeys := make(map[interface{}]interface{})
0000000000000000000000000000000000000000;;			for _, key := range a.MapKeys() {
0000000000000000000000000000000000000000;;				aKeys[key.Interface()] = a.MapIndex(key).Interface()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var missing []diff
0000000000000000000000000000000000000000;;			for _, key := range b.MapKeys() {
0000000000000000000000000000000000000000;;				if _, ok := aKeys[key.Interface()]; ok {
0000000000000000000000000000000000000000;;					delete(aKeys, key.Interface())
0000000000000000000000000000000000000000;;					if reflect.DeepEqual(a.MapIndex(key).Interface(), b.MapIndex(key).Interface()) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					missing = append(missing, objectReflectDiff(path.Key(fmt.Sprintf("%s", key.Interface())), a.MapIndex(key), b.MapIndex(key))...)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				missing = append(missing, diff{path: path.Key(fmt.Sprintf("%s", key.Interface())), a: nil, b: b.MapIndex(key).Interface()})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for key, value := range aKeys {
0000000000000000000000000000000000000000;;				missing = append(missing, diff{path: path.Key(fmt.Sprintf("%s", key)), a: value, b: nil})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(missing) == 0 {
0000000000000000000000000000000000000000;;				missing = append(missing, diff{path: path, a: a.Interface(), b: b.Interface()})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Sort(orderedDiffs(missing))
0000000000000000000000000000000000000000;;			return missing
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(a.Interface(), b.Interface()) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !a.CanInterface() {
0000000000000000000000000000000000000000;;				return []diff{{path: path, a: fmt.Sprintf("%#v", a), b: fmt.Sprintf("%#v", b)}}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []diff{{path: path, a: a.Interface(), b: b.Interface()}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectGoPrintSideBySide prints a and b as textual dumps side by side,
0000000000000000000000000000000000000000;;	// enabling easy visual scanning for mismatches.
0000000000000000000000000000000000000000;;	func ObjectGoPrintSideBySide(a, b interface{}) string {
0000000000000000000000000000000000000000;;		s := spew.ConfigState{
0000000000000000000000000000000000000000;;			Indent: " ",
0000000000000000000000000000000000000000;;			// Extra deep spew.
0000000000000000000000000000000000000000;;			DisableMethods: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sA := s.Sdump(a)
0000000000000000000000000000000000000000;;		sB := s.Sdump(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		linesA := strings.Split(sA, "\n")
0000000000000000000000000000000000000000;;		linesB := strings.Split(sB, "\n")
0000000000000000000000000000000000000000;;		width := 0
0000000000000000000000000000000000000000;;		for _, s := range linesA {
0000000000000000000000000000000000000000;;			l := len(s)
0000000000000000000000000000000000000000;;			if l > width {
0000000000000000000000000000000000000000;;				width = l
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, s := range linesB {
0000000000000000000000000000000000000000;;			l := len(s)
0000000000000000000000000000000000000000;;			if l > width {
0000000000000000000000000000000000000000;;				width = l
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		w := tabwriter.NewWriter(buf, width, 0, 1, ' ', 0)
0000000000000000000000000000000000000000;;		max := len(linesA)
0000000000000000000000000000000000000000;;		if len(linesB) > max {
0000000000000000000000000000000000000000;;			max = len(linesB)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < max; i++ {
0000000000000000000000000000000000000000;;			var a, b string
0000000000000000000000000000000000000000;;			if i < len(linesA) {
0000000000000000000000000000000000000000;;				a = linesA[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i < len(linesB) {
0000000000000000000000000000000000000000;;				b = linesB[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%s\t%s\n", a, b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Flush()
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
