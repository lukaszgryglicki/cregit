0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
33c8eedc24a4d7abe12be3f93d157816c9c9c952;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mergepatch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/davecgh/go-spew/spew"
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PreconditionFunc asserts that an incompatible change is not present within a patch.
0000000000000000000000000000000000000000;;	type PreconditionFunc func(interface{}) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequireKeyUnchanged returns a precondition function that fails if the provided key
0000000000000000000000000000000000000000;;	// is present in the patch (indicating that its value has changed).
0000000000000000000000000000000000000000;;	func RequireKeyUnchanged(key string) PreconditionFunc {
0000000000000000000000000000000000000000;;		return func(patch interface{}) bool {
0000000000000000000000000000000000000000;;			patchMap, ok := patch.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The presence of key means that its value has been changed, so the test fails.
0000000000000000000000000000000000000000;;			_, ok = patchMap[key]
0000000000000000000000000000000000000000;;			return !ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequireMetadataKeyUnchanged creates a precondition function that fails
0000000000000000000000000000000000000000;;	// if the metadata.key is present in the patch (indicating its value
0000000000000000000000000000000000000000;;	// has changed).
0000000000000000000000000000000000000000;;	func RequireMetadataKeyUnchanged(key string) PreconditionFunc {
0000000000000000000000000000000000000000;;		return func(patch interface{}) bool {
0000000000000000000000000000000000000000;;			patchMap, ok := patch.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			patchMap1, ok := patchMap["metadata"]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			patchMap2, ok := patchMap1.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, ok = patchMap2[key]
0000000000000000000000000000000000000000;;			return !ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ToYAMLOrError(v interface{}) string {
0000000000000000000000000000000000000000;;		y, err := toYAML(v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return y
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toYAML(v interface{}) (string, error) {
0000000000000000000000000000000000000000;;		y, err := yaml.Marshal(v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("yaml marshal failed:%v\n%v\n", err, spew.Sdump(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(y), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasConflicts returns true if the left and right JSON interface objects overlap with
0000000000000000000000000000000000000000;;	// different values in any key. All keys are required to be strings. Since patches of the
0000000000000000000000000000000000000000;;	// same Type have congruent keys, this is valid for multiple patch types. This method
0000000000000000000000000000000000000000;;	// supports JSON merge patch semantics.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: Numbers with different types (e.g. int(0) vs int64(0)) will be detected as conflicts.
0000000000000000000000000000000000000000;;	//       Make sure the unmarshaling of left and right are consistent (e.g. use the same library).
0000000000000000000000000000000000000000;;	func HasConflicts(left, right interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		switch typedLeft := left.(type) {
0000000000000000000000000000000000000000;;		case map[string]interface{}:
0000000000000000000000000000000000000000;;			switch typedRight := right.(type) {
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				for key, leftValue := range typedLeft {
0000000000000000000000000000000000000000;;					rightValue, ok := typedRight[key]
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if conflict, err := HasConflicts(leftValue, rightValue); err != nil || conflict {
0000000000000000000000000000000000000000;;						return conflict, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			switch typedRight := right.(type) {
0000000000000000000000000000000000000000;;			case []interface{}:
0000000000000000000000000000000000000000;;				if len(typedLeft) != len(typedRight) {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := range typedLeft {
0000000000000000000000000000000000000000;;					if conflict, err := HasConflicts(typedLeft[i], typedRight[i]); err != nil || conflict {
0000000000000000000000000000000000000000;;						return conflict, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case string, float64, bool, int, int64, nil:
0000000000000000000000000000000000000000;;			return !reflect.DeepEqual(left, right), nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return true, fmt.Errorf("unknown type: %v", reflect.TypeOf(left))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
