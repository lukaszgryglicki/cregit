0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package net
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortRange represents a range of TCP/UDP ports.  To represent a single port,
0000000000000000000000000000000000000000;;	// set Size to 1.
0000000000000000000000000000000000000000;;	type PortRange struct {
0000000000000000000000000000000000000000;;		Base int
0000000000000000000000000000000000000000;;		Size int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains tests whether a given port falls within the PortRange.
0000000000000000000000000000000000000000;;	func (pr *PortRange) Contains(p int) bool {
0000000000000000000000000000000000000000;;		return (p >= pr.Base) && ((p - pr.Base) < pr.Size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String converts the PortRange to a string representation, which can be
0000000000000000000000000000000000000000;;	// parsed by PortRange.Set or ParsePortRange.
0000000000000000000000000000000000000000;;	func (pr PortRange) String() string {
0000000000000000000000000000000000000000;;		if pr.Size == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%d-%d", pr.Base, pr.Base+pr.Size-1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set parses a string of the form "min-max", inclusive at both ends, and
0000000000000000000000000000000000000000;;	// sets the PortRange from it.  This is part of the flag.Value and pflag.Value
0000000000000000000000000000000000000000;;	// interfaces.
0000000000000000000000000000000000000000;;	func (pr *PortRange) Set(value string) error {
0000000000000000000000000000000000000000;;		value = strings.TrimSpace(value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Accept "80" syntax
0000000000000000000000000000000000000000;;		// TODO: Accept "80+8" syntax
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if value == "" {
0000000000000000000000000000000000000000;;			pr.Base = 0
0000000000000000000000000000000000000000;;			pr.Size = 0
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hyphenIndex := strings.Index(value, "-")
0000000000000000000000000000000000000000;;		if hyphenIndex == -1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected hyphen in port range")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var low int
0000000000000000000000000000000000000000;;		var high int
0000000000000000000000000000000000000000;;		low, err = strconv.Atoi(value[:hyphenIndex])
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			high, err = strconv.Atoi(value[hyphenIndex+1:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to parse port range: %s: %v", value, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if low > 65535 || high > 65535 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("the port range cannot be greater than 65535: %s", value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if high < low {
0000000000000000000000000000000000000000;;			return fmt.Errorf("end port cannot be less than start port: %s", value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pr.Base = low
0000000000000000000000000000000000000000;;		pr.Size = 1 + high - low
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type returns a descriptive string about this type.  This is part of the
0000000000000000000000000000000000000000;;	// pflag.Value interface.
0000000000000000000000000000000000000000;;	func (*PortRange) Type() string {
0000000000000000000000000000000000000000;;		return "portRange"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePortRange parses a string of the form "min-max", inclusive at both
0000000000000000000000000000000000000000;;	// ends, and initializs a new PortRange from it.
0000000000000000000000000000000000000000;;	func ParsePortRange(value string) (*PortRange, error) {
0000000000000000000000000000000000000000;;		pr := &PortRange{}
0000000000000000000000000000000000000000;;		err := pr.Set(value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParsePortRangeOrDie(value string) *PortRange {
0000000000000000000000000000000000000000;;		pr, err := ParsePortRange(value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("couldn't parse port range %q: %v", value, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pr
0000000000000000000000000000000000000000;;	}
