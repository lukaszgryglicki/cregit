0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
18ec529477569e3f71f0df63c1488953c11a0166;pkg/util/httpstream/spdy/connection_test.go[pkg/util/httpstream/spdy/connection_test.go][staging/src/k8s.io/apimachinery/pkg/util/httpstream/spdy/connection_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package spdy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runProxy(t *testing.T, backendUrl string, proxyUrl chan<- string, proxyDone chan<- struct{}) {
0000000000000000000000000000000000000000;;		listener, err := net.Listen("tcp4", "localhost:0")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("error listening: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer listener.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyUrl <- listener.Addr().String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConn, err := listener.Accept()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("proxy: error accepting client connection: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backendConn, err := net.Dial("tcp4", backendUrl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("proxy: error dialing backend: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer backendConn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer wg.Done()
0000000000000000000000000000000000000000;;			io.Copy(backendConn, clientConn)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer wg.Done()
0000000000000000000000000000000000000000;;			io.Copy(clientConn, backendConn)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyDone <- struct{}{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runServer(t *testing.T, backendUrl chan<- string, serverDone chan<- struct{}) {
0000000000000000000000000000000000000000;;		listener, err := net.Listen("tcp4", "localhost:0")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("server: error listening: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer listener.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		backendUrl <- listener.Addr().String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := listener.Accept()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("server: error accepting connection: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamChan := make(chan httpstream.Stream)
0000000000000000000000000000000000000000;;		replySentChan := make(chan (<-chan struct{}))
0000000000000000000000000000000000000000;;		spdyConn, err := NewServerConnection(conn, func(stream httpstream.Stream, replySent <-chan struct{}) error {
0000000000000000000000000000000000000000;;			streamChan <- stream
0000000000000000000000000000000000000000;;			replySentChan <- replySent
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("server: error creating spdy connection: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream := <-streamChan
0000000000000000000000000000000000000000;;		replySent := <-replySentChan
0000000000000000000000000000000000000000;;		<-replySent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := make([]byte, 1)
0000000000000000000000000000000000000000;;		_, err = stream.Read(buf)
0000000000000000000000000000000000000000;;		if err != io.EOF {
0000000000000000000000000000000000000000;;			t.Errorf("server: unexpected read error: %v", err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-spdyConn.CloseChan()
0000000000000000000000000000000000000000;;		raw := spdyConn.(*connection).conn
0000000000000000000000000000000000000000;;		if err := raw.Wait(15 * time.Second); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("server: timed out waiting for connection closure: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverDone <- struct{}{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConnectionCloseIsImmediateThroughAProxy(t *testing.T) {
0000000000000000000000000000000000000000;;		serverDone := make(chan struct{})
0000000000000000000000000000000000000000;;		backendUrlChan := make(chan string)
0000000000000000000000000000000000000000;;		go runServer(t, backendUrlChan, serverDone)
0000000000000000000000000000000000000000;;		backendUrl := <-backendUrlChan
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyDone := make(chan struct{})
0000000000000000000000000000000000000000;;		proxyUrlChan := make(chan string)
0000000000000000000000000000000000000000;;		go runProxy(t, backendUrl, proxyUrlChan, proxyDone)
0000000000000000000000000000000000000000;;		proxyUrl := <-proxyUrlChan
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := net.Dial("tcp4", proxyUrl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("client: error connecting to proxy: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spdyConn, err := NewClientConnection(conn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("client: error creating spdy connection: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := spdyConn.CreateStream(http.Header{}); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("client: error creating stream: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spdyConn.Close()
0000000000000000000000000000000000000000;;		raw := spdyConn.(*connection).conn
0000000000000000000000000000000000000000;;		if err := raw.Wait(15 * time.Second); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("client: timed out waiting for connection closure: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expired := time.NewTimer(15 * time.Second)
0000000000000000000000000000000000000000;;		defer expired.Stop()
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-expired.C:
0000000000000000000000000000000000000000;;				t.Fatalf("timed out waiting for proxy and/or server closure")
0000000000000000000000000000000000000000;;			case <-serverDone:
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			case <-proxyDone:
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i == 2 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
