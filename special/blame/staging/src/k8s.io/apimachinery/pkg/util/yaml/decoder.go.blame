0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package yaml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToJSON converts a single YAML document into a JSON document
0000000000000000000000000000000000000000;;	// or returns an error. If the document appears to be JSON the
0000000000000000000000000000000000000000;;	// YAML decoding path is not used (so that error messages are
0000000000000000000000000000000000000000;;	// JSON specific).
0000000000000000000000000000000000000000;;	func ToJSON(data []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		if hasJSONPrefix(data) {
0000000000000000000000000000000000000000;;			return data, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return yaml.YAMLToJSON(data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// YAMLToJSONDecoder decodes YAML documents from an io.Reader by
0000000000000000000000000000000000000000;;	// separating individual documents. It first converts the YAML
0000000000000000000000000000000000000000;;	// body to JSON, then unmarshals the JSON.
0000000000000000000000000000000000000000;;	type YAMLToJSONDecoder struct {
0000000000000000000000000000000000000000;;		reader Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewYAMLToJSONDecoder decodes YAML documents from the provided
0000000000000000000000000000000000000000;;	// stream in chunks by converting each document (as defined by
0000000000000000000000000000000000000000;;	// the YAML spec) into its own chunk, converting it to JSON via
0000000000000000000000000000000000000000;;	// yaml.YAMLToJSON, and then passing it to json.Decoder.
0000000000000000000000000000000000000000;;	func NewYAMLToJSONDecoder(r io.Reader) *YAMLToJSONDecoder {
0000000000000000000000000000000000000000;;		reader := bufio.NewReader(r)
0000000000000000000000000000000000000000;;		return &YAMLToJSONDecoder{
0000000000000000000000000000000000000000;;			reader: NewYAMLReader(reader),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode reads a YAML document as JSON from the stream or returns
0000000000000000000000000000000000000000;;	// an error. The decoding rules match json.Unmarshal, not
0000000000000000000000000000000000000000;;	// yaml.Unmarshal.
0000000000000000000000000000000000000000;;	func (d *YAMLToJSONDecoder) Decode(into interface{}) error {
0000000000000000000000000000000000000000;;		bytes, err := d.reader.Read()
0000000000000000000000000000000000000000;;		if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(bytes) != 0 {
0000000000000000000000000000000000000000;;			err := yaml.Unmarshal(bytes, into)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return YAMLSyntaxError{err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// YAMLDecoder reads chunks of objects and returns ErrShortBuffer if
0000000000000000000000000000000000000000;;	// the data is not sufficient.
0000000000000000000000000000000000000000;;	type YAMLDecoder struct {
0000000000000000000000000000000000000000;;		r         io.ReadCloser
0000000000000000000000000000000000000000;;		scanner   *bufio.Scanner
0000000000000000000000000000000000000000;;		remaining []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDocumentDecoder decodes YAML documents from the provided
0000000000000000000000000000000000000000;;	// stream in chunks by converting each document (as defined by
0000000000000000000000000000000000000000;;	// the YAML spec) into its own chunk. io.ErrShortBuffer will be
0000000000000000000000000000000000000000;;	// returned if the entire buffer could not be read to assist
0000000000000000000000000000000000000000;;	// the caller in framing the chunk.
0000000000000000000000000000000000000000;;	func NewDocumentDecoder(r io.ReadCloser) io.ReadCloser {
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(r)
0000000000000000000000000000000000000000;;		scanner.Split(splitYAMLDocument)
0000000000000000000000000000000000000000;;		return &YAMLDecoder{
0000000000000000000000000000000000000000;;			r:       r,
0000000000000000000000000000000000000000;;			scanner: scanner,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads the previous slice into the buffer, or attempts to read
0000000000000000000000000000000000000000;;	// the next chunk.
0000000000000000000000000000000000000000;;	// TODO: switch to readline approach.
0000000000000000000000000000000000000000;;	func (d *YAMLDecoder) Read(data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		left := len(d.remaining)
0000000000000000000000000000000000000000;;		if left == 0 {
0000000000000000000000000000000000000000;;			// return the next chunk from the stream
0000000000000000000000000000000000000000;;			if !d.scanner.Scan() {
0000000000000000000000000000000000000000;;				err := d.scanner.Err()
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					err = io.EOF
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out := d.scanner.Bytes()
0000000000000000000000000000000000000000;;			d.remaining = out
0000000000000000000000000000000000000000;;			left = len(out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fits within data
0000000000000000000000000000000000000000;;		if left <= len(data) {
0000000000000000000000000000000000000000;;			copy(data, d.remaining)
0000000000000000000000000000000000000000;;			d.remaining = nil
0000000000000000000000000000000000000000;;			return len(d.remaining), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// caller will need to reread
0000000000000000000000000000000000000000;;		copy(data, d.remaining[:left])
0000000000000000000000000000000000000000;;		d.remaining = d.remaining[left:]
0000000000000000000000000000000000000000;;		return len(data), io.ErrShortBuffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *YAMLDecoder) Close() error {
0000000000000000000000000000000000000000;;		return d.r.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const yamlSeparator = "\n---"
0000000000000000000000000000000000000000;;	const separator = "---"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitYAMLDocument is a bufio.SplitFunc for splitting YAML streams into individual documents.
0000000000000000000000000000000000000000;;	func splitYAMLDocument(data []byte, atEOF bool) (advance int, token []byte, err error) {
0000000000000000000000000000000000000000;;		if atEOF && len(data) == 0 {
0000000000000000000000000000000000000000;;			return 0, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sep := len([]byte(yamlSeparator))
0000000000000000000000000000000000000000;;		if i := bytes.Index(data, []byte(yamlSeparator)); i >= 0 {
0000000000000000000000000000000000000000;;			// We have a potential document terminator
0000000000000000000000000000000000000000;;			i += sep
0000000000000000000000000000000000000000;;			after := data[i:]
0000000000000000000000000000000000000000;;			if len(after) == 0 {
0000000000000000000000000000000000000000;;				// we can't read any more characters
0000000000000000000000000000000000000000;;				if atEOF {
0000000000000000000000000000000000000000;;					return len(data), data[:len(data)-sep], nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return 0, nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if j := bytes.IndexByte(after, '\n'); j >= 0 {
0000000000000000000000000000000000000000;;				return i + j + 1, data[0 : i-sep], nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return 0, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we're at EOF, we have a final, non-terminated line. Return it.
0000000000000000000000000000000000000000;;		if atEOF {
0000000000000000000000000000000000000000;;			return len(data), data, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Request more data.
0000000000000000000000000000000000000000;;		return 0, nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decoder is a convenience interface for Decode.
0000000000000000000000000000000000000000;;	type decoder interface {
0000000000000000000000000000000000000000;;		Decode(into interface{}) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// YAMLOrJSONDecoder attempts to decode a stream of JSON documents or
0000000000000000000000000000000000000000;;	// YAML documents by sniffing for a leading { character.
0000000000000000000000000000000000000000;;	type YAMLOrJSONDecoder struct {
0000000000000000000000000000000000000000;;		r          io.Reader
0000000000000000000000000000000000000000;;		bufferSize int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder decoder
0000000000000000000000000000000000000000;;		rawData []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JSONSyntaxError struct {
0000000000000000000000000000000000000000;;		Line int
0000000000000000000000000000000000000000;;		Err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e JSONSyntaxError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("json: line %d: %s", e.Line, e.Err.Error())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type YAMLSyntaxError struct {
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e YAMLSyntaxError) Error() string {
0000000000000000000000000000000000000000;;		return e.err.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewYAMLOrJSONDecoder returns a decoder that will process YAML documents
0000000000000000000000000000000000000000;;	// or JSON documents from the given reader as a stream. bufferSize determines
0000000000000000000000000000000000000000;;	// how far into the stream the decoder will look to figure out whether this
0000000000000000000000000000000000000000;;	// is a JSON stream (has whitespace followed by an open brace).
0000000000000000000000000000000000000000;;	func NewYAMLOrJSONDecoder(r io.Reader, bufferSize int) *YAMLOrJSONDecoder {
0000000000000000000000000000000000000000;;		return &YAMLOrJSONDecoder{
0000000000000000000000000000000000000000;;			r:          r,
0000000000000000000000000000000000000000;;			bufferSize: bufferSize,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode unmarshals the next object from the underlying stream into the
0000000000000000000000000000000000000000;;	// provide object, or returns an error.
0000000000000000000000000000000000000000;;	func (d *YAMLOrJSONDecoder) Decode(into interface{}) error {
0000000000000000000000000000000000000000;;		if d.decoder == nil {
0000000000000000000000000000000000000000;;			buffer, origData, isJSON := GuessJSONStream(d.r, d.bufferSize)
0000000000000000000000000000000000000000;;			if isJSON {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("decoding stream as JSON")
0000000000000000000000000000000000000000;;				d.decoder = json.NewDecoder(buffer)
0000000000000000000000000000000000000000;;				d.rawData = origData
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("decoding stream as YAML")
0000000000000000000000000000000000000000;;				d.decoder = NewYAMLToJSONDecoder(buffer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := d.decoder.Decode(into)
0000000000000000000000000000000000000000;;		if jsonDecoder, ok := d.decoder.(*json.Decoder); ok {
0000000000000000000000000000000000000000;;			if syntax, ok := err.(*json.SyntaxError); ok {
0000000000000000000000000000000000000000;;				data, readErr := ioutil.ReadAll(jsonDecoder.Buffered())
0000000000000000000000000000000000000000;;				if readErr != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("reading stream failed: %v", readErr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				js := string(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if contents from io.Reader are not complete,
0000000000000000000000000000000000000000;;				// use the original raw data to prevent panic
0000000000000000000000000000000000000000;;				if int64(len(js)) <= syntax.Offset {
0000000000000000000000000000000000000000;;					js = string(d.rawData)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				start := strings.LastIndex(js[:syntax.Offset], "\n") + 1
0000000000000000000000000000000000000000;;				line := strings.Count(js[:start], "\n")
0000000000000000000000000000000000000000;;				return JSONSyntaxError{
0000000000000000000000000000000000000000;;					Line: line,
0000000000000000000000000000000000000000;;					Err:  fmt.Errorf(syntax.Error()),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Reader interface {
0000000000000000000000000000000000000000;;		Read() ([]byte, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type YAMLReader struct {
0000000000000000000000000000000000000000;;		reader Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewYAMLReader(r *bufio.Reader) *YAMLReader {
0000000000000000000000000000000000000000;;		return &YAMLReader{
0000000000000000000000000000000000000000;;			reader: &LineReader{reader: r},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read returns a full YAML document.
0000000000000000000000000000000000000000;;	func (r *YAMLReader) Read() ([]byte, error) {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			line, err := r.reader.Read()
0000000000000000000000000000000000000000;;			if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sep := len([]byte(separator))
0000000000000000000000000000000000000000;;			if i := bytes.Index(line, []byte(separator)); i == 0 {
0000000000000000000000000000000000000000;;				// We have a potential document terminator
0000000000000000000000000000000000000000;;				i += sep
0000000000000000000000000000000000000000;;				after := line[i:]
0000000000000000000000000000000000000000;;				if len(strings.TrimRightFunc(string(after), unicode.IsSpace)) == 0 {
0000000000000000000000000000000000000000;;					if buffer.Len() != 0 {
0000000000000000000000000000000000000000;;						return buffer.Bytes(), nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err == io.EOF {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				if buffer.Len() != 0 {
0000000000000000000000000000000000000000;;					// If we're at EOF, we have a final, non-terminated line. Return it.
0000000000000000000000000000000000000000;;					return buffer.Bytes(), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buffer.Write(line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LineReader struct {
0000000000000000000000000000000000000000;;		reader *bufio.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read returns a single line (with '\n' ended) from the underlying reader.
0000000000000000000000000000000000000000;;	// An error is returned iff there is an error with the underlying reader.
0000000000000000000000000000000000000000;;	func (r *LineReader) Read() ([]byte, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			isPrefix bool  = true
0000000000000000000000000000000000000000;;			err      error = nil
0000000000000000000000000000000000000000;;			line     []byte
0000000000000000000000000000000000000000;;			buffer   bytes.Buffer
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for isPrefix && err == nil {
0000000000000000000000000000000000000000;;			line, isPrefix, err = r.reader.ReadLine()
0000000000000000000000000000000000000000;;			buffer.Write(line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buffer.WriteByte('\n')
0000000000000000000000000000000000000000;;		return buffer.Bytes(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GuessJSONStream scans the provided reader up to size, looking
0000000000000000000000000000000000000000;;	// for an open brace indicating this is JSON. It will return the
0000000000000000000000000000000000000000;;	// bufio.Reader it creates for the consumer.
0000000000000000000000000000000000000000;;	func GuessJSONStream(r io.Reader, size int) (io.Reader, []byte, bool) {
0000000000000000000000000000000000000000;;		buffer := bufio.NewReaderSize(r, size)
0000000000000000000000000000000000000000;;		b, _ := buffer.Peek(size)
0000000000000000000000000000000000000000;;		return buffer, b, hasJSONPrefix(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var jsonPrefix = []byte("{")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasJSONPrefix returns true if the provided buffer appears to start with
0000000000000000000000000000000000000000;;	// a JSON open brace.
0000000000000000000000000000000000000000;;	func hasJSONPrefix(buf []byte) bool {
0000000000000000000000000000000000000000;;		return hasPrefix(buf, jsonPrefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return true if the first non-whitespace bytes in buf is
0000000000000000000000000000000000000000;;	// prefix.
0000000000000000000000000000000000000000;;	func hasPrefix(buf []byte, prefix []byte) bool {
0000000000000000000000000000000000000000;;		trim := bytes.TrimLeftFunc(buf, unicode.IsSpace)
0000000000000000000000000000000000000000;;		return bytes.HasPrefix(trim, prefix)
0000000000000000000000000000000000000000;;	}
