0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
a4381495a8e8dfc088ef3de32d9f162c92ce78eb;pkg/registry/generic/rest/proxy.go[pkg/registry/generic/rest/proxy.go][staging/src/k8s.io/apimachinery/pkg/util/proxy/upgradeaware.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package proxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httputil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/mxk/go-flowrate/flowrate"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpgradeAwareHandler is a handler for proxy requests that may require an upgrade
0000000000000000000000000000000000000000;;	type UpgradeAwareHandler struct {
0000000000000000000000000000000000000000;;		UpgradeRequired bool
0000000000000000000000000000000000000000;;		Location        *url.URL
0000000000000000000000000000000000000000;;		// Transport provides an optional round tripper to use to proxy. If nil, the default proxy transport is used
0000000000000000000000000000000000000000;;		Transport http.RoundTripper
0000000000000000000000000000000000000000;;		// WrapTransport indicates whether the provided Transport should be wrapped with default proxy transport behavior (URL rewriting, X-Forwarded-* header setting)
0000000000000000000000000000000000000000;;		WrapTransport bool
0000000000000000000000000000000000000000;;		// InterceptRedirects determines whether the proxy should sniff backend responses for redirects,
0000000000000000000000000000000000000000;;		// following them as necessary.
0000000000000000000000000000000000000000;;		InterceptRedirects bool
0000000000000000000000000000000000000000;;		FlushInterval      time.Duration
0000000000000000000000000000000000000000;;		MaxBytesPerSec     int64
0000000000000000000000000000000000000000;;		Responder          ErrorResponder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultFlushInterval = 200 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorResponder abstracts error reporting to the proxy handler to remove the need to hardcode a particular
0000000000000000000000000000000000000000;;	// error format.
0000000000000000000000000000000000000000;;	type ErrorResponder interface {
0000000000000000000000000000000000000000;;		Error(err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUpgradeAwareHandler creates a new proxy handler with a default flush interval. Responder is required for returning
0000000000000000000000000000000000000000;;	// errors to the caller.
0000000000000000000000000000000000000000;;	func NewUpgradeAwareHandler(location *url.URL, transport http.RoundTripper, wrapTransport, upgradeRequired bool, responder ErrorResponder) *UpgradeAwareHandler {
0000000000000000000000000000000000000000;;		return &UpgradeAwareHandler{
0000000000000000000000000000000000000000;;			Location:        location,
0000000000000000000000000000000000000000;;			Transport:       transport,
0000000000000000000000000000000000000000;;			WrapTransport:   wrapTransport,
0000000000000000000000000000000000000000;;			UpgradeRequired: upgradeRequired,
0000000000000000000000000000000000000000;;			FlushInterval:   defaultFlushInterval,
0000000000000000000000000000000000000000;;			Responder:       responder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP handles the proxy request
0000000000000000000000000000000000000000;;	func (h *UpgradeAwareHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		if len(h.Location.Scheme) == 0 {
0000000000000000000000000000000000000000;;			h.Location.Scheme = "http"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.tryUpgrade(w, req) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.UpgradeRequired {
0000000000000000000000000000000000000000;;			h.Responder.Error(errors.NewBadRequest("Upgrade request required"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		loc := *h.Location
0000000000000000000000000000000000000000;;		loc.RawQuery = req.URL.RawQuery
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If original request URL ended in '/', append a '/' at the end of the
0000000000000000000000000000000000000000;;		// of the proxy URL
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(loc.Path, "/") && strings.HasSuffix(req.URL.Path, "/") {
0000000000000000000000000000000000000000;;			loc.Path += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// From pkg/genericapiserver/endpoints/handlers/proxy.go#ServeHTTP:
0000000000000000000000000000000000000000;;		// Redirect requests with an empty path to a location that ends with a '/'
0000000000000000000000000000000000000000;;		// This is essentially a hack for http://issue.k8s.io/4958.
0000000000000000000000000000000000000000;;		// Note: Keep this code after tryUpgrade to not break that flow.
0000000000000000000000000000000000000000;;		if len(loc.Path) == 0 {
0000000000000000000000000000000000000000;;			var queryPart string
0000000000000000000000000000000000000000;;			if len(req.URL.RawQuery) > 0 {
0000000000000000000000000000000000000000;;				queryPart = "?" + req.URL.RawQuery
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Header().Set("Location", req.URL.Path+"/"+queryPart)
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusMovedPermanently)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h.Transport == nil || h.WrapTransport {
0000000000000000000000000000000000000000;;			h.Transport = h.defaultProxyTransport(req.URL, h.Transport)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WithContext creates a shallow clone of the request with the new context.
0000000000000000000000000000000000000000;;		newReq := req.WithContext(context.Background())
0000000000000000000000000000000000000000;;		newReq.Header = utilnet.CloneHeader(req.Header)
0000000000000000000000000000000000000000;;		newReq.URL = &loc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxy := httputil.NewSingleHostReverseProxy(&url.URL{Scheme: h.Location.Scheme, Host: h.Location.Host})
0000000000000000000000000000000000000000;;		proxy.Transport = h.Transport
0000000000000000000000000000000000000000;;		proxy.FlushInterval = h.FlushInterval
0000000000000000000000000000000000000000;;		proxy.ServeHTTP(w, newReq)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tryUpgrade returns true if the request was handled.
0000000000000000000000000000000000000000;;	func (h *UpgradeAwareHandler) tryUpgrade(w http.ResponseWriter, req *http.Request) bool {
0000000000000000000000000000000000000000;;		if !httpstream.IsUpgradeRequest(req) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			backendConn net.Conn
0000000000000000000000000000000000000000;;			rawResponse []byte
0000000000000000000000000000000000000000;;			err         error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clone := utilnet.CloneRequest(req)
0000000000000000000000000000000000000000;;		// Only append X-Forwarded-For in the upgrade path, since httputil.NewSingleHostReverseProxy
0000000000000000000000000000000000000000;;		// handles this in the non-upgrade path.
0000000000000000000000000000000000000000;;		utilnet.AppendForwardedForHeader(clone)
0000000000000000000000000000000000000000;;		if h.InterceptRedirects {
0000000000000000000000000000000000000000;;			backendConn, rawResponse, err = utilnet.ConnectWithRedirects(req.Method, h.Location, clone.Header, req.Body, h)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			clone.URL = h.Location
0000000000000000000000000000000000000000;;			backendConn, err = h.Dial(clone)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			h.Responder.Error(err)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer backendConn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Once the connection is hijacked, the ErrorResponder will no longer work, so
0000000000000000000000000000000000000000;;		// hijacking should be the last step in the upgrade.
0000000000000000000000000000000000000000;;		requestHijacker, ok := w.(http.Hijacker)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			h.Responder.Error(fmt.Errorf("request connection cannot be hijacked: %T", w))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		requestHijackedConn, _, err := requestHijacker.Hijack()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			h.Responder.Error(fmt.Errorf("error hijacking request connection: %v", err))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer requestHijackedConn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Forward raw response bytes back to client.
0000000000000000000000000000000000000000;;		if len(rawResponse) > 0 {
0000000000000000000000000000000000000000;;			if _, err = requestHijackedConn.Write(rawResponse); err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("Error proxying response from backend to client: %v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Proxy the connection.
0000000000000000000000000000000000000000;;		wg := &sync.WaitGroup{}
0000000000000000000000000000000000000000;;		wg.Add(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			var writer io.WriteCloser
0000000000000000000000000000000000000000;;			if h.MaxBytesPerSec > 0 {
0000000000000000000000000000000000000000;;				writer = flowrate.NewWriter(backendConn, h.MaxBytesPerSec)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				writer = backendConn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := io.Copy(writer, requestHijackedConn)
0000000000000000000000000000000000000000;;			if err != nil && !strings.Contains(err.Error(), "use of closed network connection") {
0000000000000000000000000000000000000000;;				glog.Errorf("Error proxying data from client to backend: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			var reader io.ReadCloser
0000000000000000000000000000000000000000;;			if h.MaxBytesPerSec > 0 {
0000000000000000000000000000000000000000;;				reader = flowrate.NewReader(backendConn, h.MaxBytesPerSec)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				reader = backendConn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := io.Copy(requestHijackedConn, reader)
0000000000000000000000000000000000000000;;			if err != nil && !strings.Contains(err.Error(), "use of closed network connection") {
0000000000000000000000000000000000000000;;				glog.Errorf("Error proxying data from backend to client: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial dials the backend at req.URL and writes req to it.
0000000000000000000000000000000000000000;;	func (h *UpgradeAwareHandler) Dial(req *http.Request) (net.Conn, error) {
0000000000000000000000000000000000000000;;		conn, err := DialURL(req.URL, h.Transport)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error dialing backend: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = req.Write(conn); err != nil {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error sending request: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return conn, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ utilnet.Dialer = &UpgradeAwareHandler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *UpgradeAwareHandler) defaultProxyTransport(url *url.URL, internalTransport http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		scheme := url.Scheme
0000000000000000000000000000000000000000;;		host := url.Host
0000000000000000000000000000000000000000;;		suffix := h.Location.Path
0000000000000000000000000000000000000000;;		if strings.HasSuffix(url.Path, "/") && !strings.HasSuffix(suffix, "/") {
0000000000000000000000000000000000000000;;			suffix += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pathPrepend := strings.TrimSuffix(url.Path, suffix)
0000000000000000000000000000000000000000;;		rewritingTransport := &Transport{
0000000000000000000000000000000000000000;;			Scheme:       scheme,
0000000000000000000000000000000000000000;;			Host:         host,
0000000000000000000000000000000000000000;;			PathPrepend:  pathPrepend,
0000000000000000000000000000000000000000;;			RoundTripper: internalTransport,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &corsRemovingTransport{
0000000000000000000000000000000000000000;;			RoundTripper: rewritingTransport,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// corsRemovingTransport is a wrapper for an internal transport. It removes CORS headers
0000000000000000000000000000000000000000;;	// from the internal response.
0000000000000000000000000000000000000000;;	// Implements pkg/util/net.RoundTripperWrapper
0000000000000000000000000000000000000000;;	type corsRemovingTransport struct {
0000000000000000000000000000000000000000;;		http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = utilnet.RoundTripperWrapper(&corsRemovingTransport{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *corsRemovingTransport) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		resp, err := rt.RoundTripper.RoundTrip(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		removeCORSHeaders(resp)
0000000000000000000000000000000000000000;;		return resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *corsRemovingTransport) WrappedRoundTripper() http.RoundTripper {
0000000000000000000000000000000000000000;;		return rt.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeCORSHeaders strip CORS headers sent from the backend
0000000000000000000000000000000000000000;;	// This should be called on all responses before returning
0000000000000000000000000000000000000000;;	func removeCORSHeaders(resp *http.Response) {
0000000000000000000000000000000000000000;;		resp.Header.Del("Access-Control-Allow-Credentials")
0000000000000000000000000000000000000000;;		resp.Header.Del("Access-Control-Allow-Headers")
0000000000000000000000000000000000000000;;		resp.Header.Del("Access-Control-Allow-Methods")
0000000000000000000000000000000000000000;;		resp.Header.Del("Access-Control-Allow-Origin")
0000000000000000000000000000000000000000;;	}
