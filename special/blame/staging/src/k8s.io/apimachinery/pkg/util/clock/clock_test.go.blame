0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
47136f3945aff958c99509decdab350d4be7b2c7;staging/src/k8s.io/client-go/pkg/util/clock/clock_test.go[staging/src/k8s.io/client-go/pkg/util/clock/clock_test.go][staging/src/k8s.io/apimachinery/pkg/util/clock/clock_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFakeClock(t *testing.T) {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		tc := NewFakeClock(startTime)
0000000000000000000000000000000000000000;;		tc.Step(time.Second)
0000000000000000000000000000000000000000;;		now := tc.Now()
0000000000000000000000000000000000000000;;		if now.Sub(startTime) != time.Second {
0000000000000000000000000000000000000000;;			t.Errorf("input: %s now=%s gap=%s expected=%s", startTime, now, now.Sub(startTime), time.Second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tt := tc.Now()
0000000000000000000000000000000000000000;;		tc.SetTime(tt.Add(time.Hour))
0000000000000000000000000000000000000000;;		if tc.Now().Sub(tt) != time.Hour {
0000000000000000000000000000000000000000;;			t.Errorf("input: %s now=%s gap=%s expected=%s", tt, tc.Now(), tc.Now().Sub(tt), time.Hour)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFakeClockSleep(t *testing.T) {
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		tc := NewFakeClock(startTime)
0000000000000000000000000000000000000000;;		tc.Sleep(time.Duration(1) * time.Hour)
0000000000000000000000000000000000000000;;		now := tc.Now()
0000000000000000000000000000000000000000;;		if now.Sub(startTime) != time.Hour {
0000000000000000000000000000000000000000;;			t.Errorf("Fake sleep failed, expected time to advance by one hour, instead, its %v", now.Sub(startTime))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFakeAfter(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		if tc.HasWaiters() {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected waiter?")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oneSec := tc.After(time.Second)
0000000000000000000000000000000000000000;;		if !tc.HasWaiters() {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected lack of waiter?")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oneOhOneSec := tc.After(time.Second + time.Millisecond)
0000000000000000000000000000000000000000;;		twoSec := tc.After(2 * time.Second)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-oneSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-oneOhOneSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-twoSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.Step(999 * time.Millisecond)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-oneSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-oneOhOneSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-twoSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.Step(time.Millisecond)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-oneSec:
0000000000000000000000000000000000000000;;			// Expected!
0000000000000000000000000000000000000000;;		case <-oneOhOneSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-twoSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-channel read")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.Step(time.Millisecond)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-oneSec:
0000000000000000000000000000000000000000;;			// should not double-trigger!
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-oneOhOneSec:
0000000000000000000000000000000000000000;;			// Expected!
0000000000000000000000000000000000000000;;		case <-twoSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-channel read")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFakeTick(t *testing.T) {
0000000000000000000000000000000000000000;;		tc := NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		if tc.HasWaiters() {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected waiter?")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oneSec := tc.Tick(time.Second)
0000000000000000000000000000000000000000;;		if !tc.HasWaiters() {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected lack of waiter?")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oneOhOneSec := tc.Tick(time.Second + time.Millisecond)
0000000000000000000000000000000000000000;;		twoSec := tc.Tick(2 * time.Second)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-oneSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-oneOhOneSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-twoSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.Step(999 * time.Millisecond) // t=.999
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-oneSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-oneOhOneSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-twoSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.Step(time.Millisecond) // t=1.000
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-oneSec:
0000000000000000000000000000000000000000;;			// Expected!
0000000000000000000000000000000000000000;;		case <-oneOhOneSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-twoSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-channel read")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc.Step(time.Millisecond) // t=1.001
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-oneSec:
0000000000000000000000000000000000000000;;			// should not double-trigger!
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		case <-oneOhOneSec:
0000000000000000000000000000000000000000;;			// Expected!
0000000000000000000000000000000000000000;;		case <-twoSec:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected channel read")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-channel read")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc.Step(time.Second) // t=2.001
0000000000000000000000000000000000000000;;		tc.Step(time.Second) // t=3.001
0000000000000000000000000000000000000000;;		tc.Step(time.Second) // t=4.001
0000000000000000000000000000000000000000;;		tc.Step(time.Second) // t=5.001
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The one second ticker should not accumulate ticks
0000000000000000000000000000000000000000;;		accumulatedTicks := 0
0000000000000000000000000000000000000000;;		drained := false
0000000000000000000000000000000000000000;;		for !drained {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-oneSec:
0000000000000000000000000000000000000000;;				accumulatedTicks++
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				drained = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if accumulatedTicks != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected number of accumulated ticks: %d", accumulatedTicks)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
