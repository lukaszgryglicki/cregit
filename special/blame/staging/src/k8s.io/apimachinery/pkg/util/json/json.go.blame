0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncoder delegates to json.NewEncoder
0000000000000000000000000000000000000000;;	// It is only here so this package can be a drop-in for common encoding/json uses
0000000000000000000000000000000000000000;;	func NewEncoder(w io.Writer) *json.Encoder {
0000000000000000000000000000000000000000;;		return json.NewEncoder(w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal delegates to json.Marshal
0000000000000000000000000000000000000000;;	// It is only here so this package can be a drop-in for common encoding/json uses
0000000000000000000000000000000000000000;;	func Marshal(v interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		return json.Marshal(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal unmarshals the given data
0000000000000000000000000000000000000000;;	// If v is a *map[string]interface{}, numbers are converted to int64 or float64
0000000000000000000000000000000000000000;;	func Unmarshal(data []byte, v interface{}) error {
0000000000000000000000000000000000000000;;		switch v := v.(type) {
0000000000000000000000000000000000000000;;		case *map[string]interface{}:
0000000000000000000000000000000000000000;;			// Build a decoder from the given data
0000000000000000000000000000000000000000;;			decoder := json.NewDecoder(bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;			// Preserve numbers, rather than casting to float64 automatically
0000000000000000000000000000000000000000;;			decoder.UseNumber()
0000000000000000000000000000000000000000;;			// Run the decode
0000000000000000000000000000000000000000;;			if err := decoder.Decode(v); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If the decode succeeds, post-process the map to convert json.Number objects to int64 or float64
0000000000000000000000000000000000000000;;			return convertMapNumbers(*v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return json.Unmarshal(data, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertMapNumbers traverses the map, converting any json.Number values to int64 or float64.
0000000000000000000000000000000000000000;;	// values which are map[string]interface{} or []interface{} are recursively visited
0000000000000000000000000000000000000000;;	func convertMapNumbers(m map[string]interface{}) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			switch v := v.(type) {
0000000000000000000000000000000000000000;;			case json.Number:
0000000000000000000000000000000000000000;;				m[k], err = convertNumber(v)
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				err = convertMapNumbers(v)
0000000000000000000000000000000000000000;;			case []interface{}:
0000000000000000000000000000000000000000;;				err = convertSliceNumbers(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertSliceNumbers traverses the slice, converting any json.Number values to int64 or float64.
0000000000000000000000000000000000000000;;	// values which are map[string]interface{} or []interface{} are recursively visited
0000000000000000000000000000000000000000;;	func convertSliceNumbers(s []interface{}) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for i, v := range s {
0000000000000000000000000000000000000000;;			switch v := v.(type) {
0000000000000000000000000000000000000000;;			case json.Number:
0000000000000000000000000000000000000000;;				s[i], err = convertNumber(v)
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				err = convertMapNumbers(v)
0000000000000000000000000000000000000000;;			case []interface{}:
0000000000000000000000000000000000000000;;				err = convertSliceNumbers(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertNumber converts a json.Number to an int64 or float64, or returns an error
0000000000000000000000000000000000000000;;	func convertNumber(n json.Number) (interface{}, error) {
0000000000000000000000000000000000000000;;		// Attempt to convert to an int64 first
0000000000000000000000000000000000000000;;		if i, err := n.Int64(); err == nil {
0000000000000000000000000000000000000000;;			return i, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Return a float64 (default json.Decode() behavior)
0000000000000000000000000000000000000000;;		// An overflow will return an error
0000000000000000000000000000000000000000;;		return n.Float64()
0000000000000000000000000000000000000000;;	}
