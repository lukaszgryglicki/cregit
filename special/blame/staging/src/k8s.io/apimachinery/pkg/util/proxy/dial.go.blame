0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
e80c67ada9be48c9a4c3bbc9b9d067fc1caa2743;pkg/util/proxy/dial.go[pkg/util/proxy/dial.go][staging/src/k8s.io/apimachinery/pkg/util/proxy/dial.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package proxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/third_party/forked/golang/netutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DialURL(url *url.URL, transport http.RoundTripper) (net.Conn, error) {
0000000000000000000000000000000000000000;;		dialAddr := netutil.CanonicalAddr(url)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dialer, _ := utilnet.DialerFor(transport)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch url.Scheme {
0000000000000000000000000000000000000000;;		case "http":
0000000000000000000000000000000000000000;;			if dialer != nil {
0000000000000000000000000000000000000000;;				return dialer("tcp", dialAddr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return net.Dial("tcp", dialAddr)
0000000000000000000000000000000000000000;;		case "https":
0000000000000000000000000000000000000000;;			// Get the tls config from the transport if we recognize it
0000000000000000000000000000000000000000;;			var tlsConfig *tls.Config
0000000000000000000000000000000000000000;;			var tlsConn *tls.Conn
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			tlsConfig, _ = utilnet.TLSClientConfig(transport)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if dialer != nil {
0000000000000000000000000000000000000000;;				// We have a dialer; use it to open the connection, then
0000000000000000000000000000000000000000;;				// create a tls client using the connection.
0000000000000000000000000000000000000000;;				netConn, err := dialer("tcp", dialAddr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tlsConfig == nil {
0000000000000000000000000000000000000000;;					// tls.Client requires non-nil config
0000000000000000000000000000000000000000;;					glog.Warningf("using custom dialer with no TLSClientConfig. Defaulting to InsecureSkipVerify")
0000000000000000000000000000000000000000;;					// tls.Handshake() requires ServerName or InsecureSkipVerify
0000000000000000000000000000000000000000;;					tlsConfig = &tls.Config{
0000000000000000000000000000000000000000;;						InsecureSkipVerify: true,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if len(tlsConfig.ServerName) == 0 && !tlsConfig.InsecureSkipVerify {
0000000000000000000000000000000000000000;;					// tls.Handshake() requires ServerName or InsecureSkipVerify
0000000000000000000000000000000000000000;;					// infer the ServerName from the hostname we're connecting to.
0000000000000000000000000000000000000000;;					inferredHost := dialAddr
0000000000000000000000000000000000000000;;					if host, _, err := net.SplitHostPort(dialAddr); err == nil {
0000000000000000000000000000000000000000;;						inferredHost = host
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Make a copy to avoid polluting the provided config
0000000000000000000000000000000000000000;;					tlsConfigCopy := tlsConfig.Clone()
0000000000000000000000000000000000000000;;					tlsConfigCopy.ServerName = inferredHost
0000000000000000000000000000000000000000;;					tlsConfig = tlsConfigCopy
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tlsConn = tls.Client(netConn, tlsConfig)
0000000000000000000000000000000000000000;;				if err := tlsConn.Handshake(); err != nil {
0000000000000000000000000000000000000000;;					netConn.Close()
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Dial
0000000000000000000000000000000000000000;;				tlsConn, err = tls.Dial("tcp", dialAddr, tlsConfig)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Return if we were configured to skip validation
0000000000000000000000000000000000000000;;			if tlsConfig != nil && tlsConfig.InsecureSkipVerify {
0000000000000000000000000000000000000000;;				return tlsConn, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Verify
0000000000000000000000000000000000000000;;			host, _, _ := net.SplitHostPort(dialAddr)
0000000000000000000000000000000000000000;;			if err := tlsConn.VerifyHostname(host); err != nil {
0000000000000000000000000000000000000000;;				tlsConn.Close()
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return tlsConn, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unknown scheme: %s", url.Scheme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
