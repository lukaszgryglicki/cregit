0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7c46d6bc91cb50f1fdd21c23d36f48f70c322338;pkg/util/strategicpatch/patch.go[pkg/util/strategicpatch/patch.go][staging/src/k8s.io/apimachinery/pkg/util/strategicpatch/patch.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package strategicpatch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/mergepatch"
0000000000000000000000000000000000000000;;		forkedjson "k8s.io/apimachinery/third_party/forked/golang/json"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An alternate implementation of JSON Merge Patch
0000000000000000000000000000000000000000;;	// (https://tools.ietf.org/html/rfc7386) which supports the ability to annotate
0000000000000000000000000000000000000000;;	// certain fields with metadata that indicates whether the elements of JSON
0000000000000000000000000000000000000000;;	// lists should be merged or replaced.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more information, see the PATCH section of docs/devel/api-conventions.md.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some of the content of this package was borrowed with minor adaptations from
0000000000000000000000000000000000000000;;	// evanphx/json-patch and openshift/origin.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		directiveMarker  = "$patch"
0000000000000000000000000000000000000000;;		deleteDirective  = "delete"
0000000000000000000000000000000000000000;;		replaceDirective = "replace"
0000000000000000000000000000000000000000;;		mergeDirective   = "merge"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retainKeysStrategy = "retainKeys"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deleteFromPrimitiveListDirectivePrefix = "$deleteFromPrimitiveList"
0000000000000000000000000000000000000000;;		retainKeysDirective                    = "$" + retainKeysStrategy
0000000000000000000000000000000000000000;;		setElementOrderDirectivePrefix         = "$setElementOrder"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONMap is a representations of JSON object encoded as map[string]interface{}
0000000000000000000000000000000000000000;;	// where the children can be either map[string]interface{}, []interface{} or
0000000000000000000000000000000000000000;;	// primitive type).
0000000000000000000000000000000000000000;;	// Operating on JSONMap representation is much faster as it doesn't require any
0000000000000000000000000000000000000000;;	// json marshaling and/or unmarshaling operations.
0000000000000000000000000000000000000000;;	type JSONMap map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DiffOptions struct {
0000000000000000000000000000000000000000;;		// SetElementOrder determines whether we generate the $setElementOrder parallel list.
0000000000000000000000000000000000000000;;		SetElementOrder bool
0000000000000000000000000000000000000000;;		// IgnoreChangesAndAdditions indicates if we keep the changes and additions in the patch.
0000000000000000000000000000000000000000;;		IgnoreChangesAndAdditions bool
0000000000000000000000000000000000000000;;		// IgnoreDeletions indicates if we keep the deletions in the patch.
0000000000000000000000000000000000000000;;		IgnoreDeletions bool
0000000000000000000000000000000000000000;;		// We introduce a new value retainKeys for patchStrategy.
0000000000000000000000000000000000000000;;		// It indicates that all fields needing to be preserved must be
0000000000000000000000000000000000000000;;		// present in the `retainKeys` list.
0000000000000000000000000000000000000000;;		// And the fields that are present will be merged with live object.
0000000000000000000000000000000000000000;;		// All the missing fields will be cleared when patching.
0000000000000000000000000000000000000000;;		BuildRetainKeysDirective bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MergeOptions struct {
0000000000000000000000000000000000000000;;		// MergeParallelList indicates if we are merging the parallel list.
0000000000000000000000000000000000000000;;		// We don't merge parallel list when calling mergeMap() in CreateThreeWayMergePatch()
0000000000000000000000000000000000000000;;		// which is called client-side.
0000000000000000000000000000000000000000;;		// We merge parallel list iff when calling mergeMap() in StrategicMergeMapPatch()
0000000000000000000000000000000000000000;;		// which is called server-side
0000000000000000000000000000000000000000;;		MergeParallelList bool
0000000000000000000000000000000000000000;;		// IgnoreUnmatchedNulls indicates if we should process the unmatched nulls.
0000000000000000000000000000000000000000;;		IgnoreUnmatchedNulls bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following code is adapted from github.com/openshift/origin/pkg/util/jsonmerge.
0000000000000000000000000000000000000000;;	// Instead of defining a Delta that holds an original, a patch and a set of preconditions,
0000000000000000000000000000000000000000;;	// the reconcile method accepts a set of preconditions as an argument.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateTwoWayMergePatch creates a patch that can be passed to StrategicMergePatch from an original
0000000000000000000000000000000000000000;;	// document and a modified document, which are passed to the method as json encoded content. It will
0000000000000000000000000000000000000000;;	// return a patch that yields the modified document when applied to the original document, or an error
0000000000000000000000000000000000000000;;	// if either of the two documents is invalid.
0000000000000000000000000000000000000000;;	func CreateTwoWayMergePatch(original, modified []byte, dataStruct interface{}, fns ...mergepatch.PreconditionFunc) ([]byte, error) {
0000000000000000000000000000000000000000;;		originalMap := map[string]interface{}{}
0000000000000000000000000000000000000000;;		if len(original) > 0 {
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(original, &originalMap); err != nil {
0000000000000000000000000000000000000000;;				return nil, mergepatch.ErrBadJSONDoc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modifiedMap := map[string]interface{}{}
0000000000000000000000000000000000000000;;		if len(modified) > 0 {
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(modified, &modifiedMap); err != nil {
0000000000000000000000000000000000000000;;				return nil, mergepatch.ErrBadJSONDoc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchMap, err := CreateTwoWayMergeMapPatch(originalMap, modifiedMap, dataStruct, fns...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(patchMap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateTwoWayMergeMapPatch creates a patch from an original and modified JSON objects,
0000000000000000000000000000000000000000;;	// encoded JSONMap.
0000000000000000000000000000000000000000;;	// The serialized version of the map can then be passed to StrategicMergeMapPatch.
0000000000000000000000000000000000000000;;	func CreateTwoWayMergeMapPatch(original, modified JSONMap, dataStruct interface{}, fns ...mergepatch.PreconditionFunc) (JSONMap, error) {
0000000000000000000000000000000000000000;;		t, err := getTagStructType(dataStruct)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diffOptions := DiffOptions{
0000000000000000000000000000000000000000;;			SetElementOrder: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patchMap, err := diffMaps(original, modified, t, diffOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply the preconditions to the patch, and return an error if any of them fail.
0000000000000000000000000000000000000000;;		for _, fn := range fns {
0000000000000000000000000000000000000000;;			if !fn(patchMap) {
0000000000000000000000000000000000000000;;				return nil, mergepatch.NewErrPreconditionFailed(patchMap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return patchMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a (recursive) strategic merge patch that yields modified when applied to original.
0000000000000000000000000000000000000000;;	// Including:
0000000000000000000000000000000000000000;;	// - Adding fields to the patch present in modified, missing from original
0000000000000000000000000000000000000000;;	// - Setting fields to the patch present in modified and original with different values
0000000000000000000000000000000000000000;;	// - Delete fields present in original, missing from modified through
0000000000000000000000000000000000000000;;	// - IFF map field - set to nil in patch
0000000000000000000000000000000000000000;;	// - IFF list of maps && merge strategy - use deleteDirective for the elements
0000000000000000000000000000000000000000;;	// - IFF list of primitives && merge strategy - use parallel deletion list
0000000000000000000000000000000000000000;;	// - IFF list of maps or primitives with replace strategy (default) - set patch value to the value in modified
0000000000000000000000000000000000000000;;	// - Build $retainKeys directive for fields with retainKeys patch strategy
0000000000000000000000000000000000000000;;	func diffMaps(original, modified map[string]interface{}, t reflect.Type, diffOptions DiffOptions) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		patch := map[string]interface{}{}
0000000000000000000000000000000000000000;;		// Get the underlying type for pointers
0000000000000000000000000000000000000000;;		if t.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This will be used to build the $retainKeys directive sent in the patch
0000000000000000000000000000000000000000;;		retainKeysList := make([]interface{}, 0, len(modified))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compare each value in the modified map against the value in the original map
0000000000000000000000000000000000000000;;		for key, modifiedValue := range modified {
0000000000000000000000000000000000000000;;			// Get the underlying type for pointers
0000000000000000000000000000000000000000;;			if diffOptions.BuildRetainKeysDirective && modifiedValue != nil {
0000000000000000000000000000000000000000;;				retainKeysList = append(retainKeysList, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			originalValue, ok := original[key]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// Key was added, so add to patch
0000000000000000000000000000000000000000;;				if !diffOptions.IgnoreChangesAndAdditions {
0000000000000000000000000000000000000000;;					patch[key] = modifiedValue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// The patch may have a patch directive
0000000000000000000000000000000000000000;;			// TODO: figure out if we need this. This shouldn't be needed by apply. When would the original map have patch directives in it?
0000000000000000000000000000000000000000;;			foundDirectiveMarker, err := handleDirectiveMarker(key, originalValue, modifiedValue, patch)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if foundDirectiveMarker {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if reflect.TypeOf(originalValue) != reflect.TypeOf(modifiedValue) {
0000000000000000000000000000000000000000;;				// Types have changed, so add to patch
0000000000000000000000000000000000000000;;				if !diffOptions.IgnoreChangesAndAdditions {
0000000000000000000000000000000000000000;;					patch[key] = modifiedValue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Types are the same, so compare values
0000000000000000000000000000000000000000;;			switch originalValueTyped := originalValue.(type) {
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				modifiedValueTyped := modifiedValue.(map[string]interface{})
0000000000000000000000000000000000000000;;				err = handleMapDiff(key, originalValueTyped, modifiedValueTyped, patch, t, diffOptions)
0000000000000000000000000000000000000000;;			case []interface{}:
0000000000000000000000000000000000000000;;				modifiedValueTyped := modifiedValue.([]interface{})
0000000000000000000000000000000000000000;;				err = handleSliceDiff(key, originalValueTyped, modifiedValueTyped, patch, t, diffOptions)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				replacePatchFieldIfNotEqual(key, originalValue, modifiedValue, patch, diffOptions)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		updatePatchIfMissing(original, modified, patch, diffOptions)
0000000000000000000000000000000000000000;;		// Insert the retainKeysList iff there are values present in the retainKeysList and
0000000000000000000000000000000000000000;;		// either of the following is true:
0000000000000000000000000000000000000000;;		// - the patch is not empty
0000000000000000000000000000000000000000;;		// - there are additional field in original that need to be cleared
0000000000000000000000000000000000000000;;		if len(retainKeysList) > 0 &&
0000000000000000000000000000000000000000;;			(len(patch) > 0 || hasAdditionalNewField(original, modified)) {
0000000000000000000000000000000000000000;;			patch[retainKeysDirective] = sortScalars(retainKeysList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return patch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleDirectiveMarker handles how to diff directive marker between 2 objects
0000000000000000000000000000000000000000;;	func handleDirectiveMarker(key string, originalValue, modifiedValue interface{}, patch map[string]interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		if key == directiveMarker {
0000000000000000000000000000000000000000;;			originalString, ok := originalValue.(string)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("invalid value for special key: %s", directiveMarker)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			modifiedString, ok := modifiedValue.(string)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("invalid value for special key: %s", directiveMarker)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if modifiedString != originalString {
0000000000000000000000000000000000000000;;				patch[directiveMarker] = modifiedValue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleMapDiff diff between 2 maps `originalValueTyped` and `modifiedValue`,
0000000000000000000000000000000000000000;;	// puts the diff in the `patch` associated with `key`
0000000000000000000000000000000000000000;;	// key is the key associated with originalValue and modifiedValue.
0000000000000000000000000000000000000000;;	// originalValue, modifiedValue are the old and new value respectively.They are both maps
0000000000000000000000000000000000000000;;	// patch is the patch map that contains key and the updated value, and it is the parent of originalValue, modifiedValue
0000000000000000000000000000000000000000;;	// diffOptions contains multiple options to control how we do the diff.
0000000000000000000000000000000000000000;;	func handleMapDiff(key string, originalValue, modifiedValue, patch map[string]interface{},
0000000000000000000000000000000000000000;;		t reflect.Type, diffOptions DiffOptions) error {
0000000000000000000000000000000000000000;;		fieldType, fieldPatchStrategies, _, err := forkedjson.LookupPatchMetadata(t, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// We couldn't look up metadata for the field
0000000000000000000000000000000000000000;;			// If the values are identical, this doesn't matter, no patch is needed
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(originalValue, modifiedValue) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Otherwise, return the error
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		retainKeys, patchStrategy, err := extractRetainKeysPatchStrategy(fieldPatchStrategies)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		diffOptions.BuildRetainKeysDirective = retainKeys
0000000000000000000000000000000000000000;;		switch patchStrategy {
0000000000000000000000000000000000000000;;		// The patch strategic from metadata tells us to replace the entire object instead of diffing it
0000000000000000000000000000000000000000;;		case replaceDirective:
0000000000000000000000000000000000000000;;			if !diffOptions.IgnoreChangesAndAdditions {
0000000000000000000000000000000000000000;;				patch[key] = modifiedValue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			patchValue, err := diffMaps(originalValue, modifiedValue, fieldType, diffOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Maps were not identical, use provided patch value
0000000000000000000000000000000000000000;;			if len(patchValue) > 0 {
0000000000000000000000000000000000000000;;				patch[key] = patchValue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleSliceDiff diff between 2 slices `originalValueTyped` and `modifiedValue`,
0000000000000000000000000000000000000000;;	// puts the diff in the `patch` associated with `key`
0000000000000000000000000000000000000000;;	// key is the key associated with originalValue and modifiedValue.
0000000000000000000000000000000000000000;;	// originalValue, modifiedValue are the old and new value respectively.They are both slices
0000000000000000000000000000000000000000;;	// patch is the patch map that contains key and the updated value, and it is the parent of originalValue, modifiedValue
0000000000000000000000000000000000000000;;	// diffOptions contains multiple options to control how we do the diff.
0000000000000000000000000000000000000000;;	func handleSliceDiff(key string, originalValue, modifiedValue []interface{}, patch map[string]interface{},
0000000000000000000000000000000000000000;;		t reflect.Type, diffOptions DiffOptions) error {
0000000000000000000000000000000000000000;;		fieldType, fieldPatchStrategies, fieldPatchMergeKey, err := forkedjson.LookupPatchMetadata(t, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// We couldn't look up metadata for the field
0000000000000000000000000000000000000000;;			// If the values are identical, this doesn't matter, no patch is needed
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(originalValue, modifiedValue) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Otherwise, return the error
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		retainKeys, patchStrategy, err := extractRetainKeysPatchStrategy(fieldPatchStrategies)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch patchStrategy {
0000000000000000000000000000000000000000;;		// Merge the 2 slices using mergePatchKey
0000000000000000000000000000000000000000;;		case mergeDirective:
0000000000000000000000000000000000000000;;			diffOptions.BuildRetainKeysDirective = retainKeys
0000000000000000000000000000000000000000;;			addList, deletionList, setOrderList, err := diffLists(originalValue, modifiedValue, fieldType.Elem(), fieldPatchMergeKey, diffOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(addList) > 0 {
0000000000000000000000000000000000000000;;				patch[key] = addList
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// generate a parallel list for deletion
0000000000000000000000000000000000000000;;			if len(deletionList) > 0 {
0000000000000000000000000000000000000000;;				parallelDeletionListKey := fmt.Sprintf("%s/%s", deleteFromPrimitiveListDirectivePrefix, key)
0000000000000000000000000000000000000000;;				patch[parallelDeletionListKey] = deletionList
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(setOrderList) > 0 {
0000000000000000000000000000000000000000;;				parallelSetOrderListKey := fmt.Sprintf("%s/%s", setElementOrderDirectivePrefix, key)
0000000000000000000000000000000000000000;;				patch[parallelSetOrderListKey] = setOrderList
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			replacePatchFieldIfNotEqual(key, originalValue, modifiedValue, patch, diffOptions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// replacePatchFieldIfNotEqual updates the patch if original and modified are not deep equal
0000000000000000000000000000000000000000;;	// if diffOptions.IgnoreChangesAndAdditions is false.
0000000000000000000000000000000000000000;;	// original is the old value, maybe either the live cluster object or the last applied configuration
0000000000000000000000000000000000000000;;	// modified is the new value, is always the users new config
0000000000000000000000000000000000000000;;	func replacePatchFieldIfNotEqual(key string, original, modified interface{},
0000000000000000000000000000000000000000;;		patch map[string]interface{}, diffOptions DiffOptions) {
0000000000000000000000000000000000000000;;		if diffOptions.IgnoreChangesAndAdditions {
0000000000000000000000000000000000000000;;			// Ignoring changes - do nothing
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(original, modified) {
0000000000000000000000000000000000000000;;			// Contents are identical - do nothing
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Create a patch to replace the old value with the new one
0000000000000000000000000000000000000000;;		patch[key] = modified
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updatePatchIfMissing iterates over `original` when ignoreDeletions is false.
0000000000000000000000000000000000000000;;	// Clear the field whose key is not present in `modified`.
0000000000000000000000000000000000000000;;	// original is the old value, maybe either the live cluster object or the last applied configuration
0000000000000000000000000000000000000000;;	// modified is the new value, is always the users new config
0000000000000000000000000000000000000000;;	func updatePatchIfMissing(original, modified, patch map[string]interface{}, diffOptions DiffOptions) {
0000000000000000000000000000000000000000;;		if diffOptions.IgnoreDeletions {
0000000000000000000000000000000000000000;;			// Ignoring deletion - do nothing
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add nils for deleted values
0000000000000000000000000000000000000000;;		for key := range original {
0000000000000000000000000000000000000000;;			if _, found := modified[key]; !found {
0000000000000000000000000000000000000000;;				patch[key] = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateMergeKeyInLists checks if each map in the list has the mentryerge key.
0000000000000000000000000000000000000000;;	func validateMergeKeyInLists(mergeKey string, lists ...[]interface{}) error {
0000000000000000000000000000000000000000;;		for _, list := range lists {
0000000000000000000000000000000000000000;;			for _, item := range list {
0000000000000000000000000000000000000000;;				m, ok := item.(map[string]interface{})
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return mergepatch.ErrBadArgType(m, item)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok = m[mergeKey]; !ok {
0000000000000000000000000000000000000000;;					return mergepatch.ErrNoMergeKey(m, mergeKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// normalizeElementOrder sort `patch` list by `patchOrder` and sort `serverOnly` list by `serverOrder`.
0000000000000000000000000000000000000000;;	// Then it merges the 2 sorted lists.
0000000000000000000000000000000000000000;;	// It guarantee the relative order in the patch list and in the serverOnly list is kept.
0000000000000000000000000000000000000000;;	// `patch` is a list of items in the patch, and `serverOnly` is a list of items in the live object.
0000000000000000000000000000000000000000;;	// `patchOrder` is the order we want `patch` list to have and
0000000000000000000000000000000000000000;;	// `serverOrder` is the order we want `serverOnly` list to have.
0000000000000000000000000000000000000000;;	// kind is the kind of each item in the lists `patch` and `serverOnly`.
0000000000000000000000000000000000000000;;	func normalizeElementOrder(patch, serverOnly, patchOrder, serverOrder []interface{}, mergeKey string, kind reflect.Kind) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		patch, err := normalizeSliceOrder(patch, patchOrder, mergeKey, kind)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serverOnly, err = normalizeSliceOrder(serverOnly, serverOrder, mergeKey, kind)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		all := mergeSortedSlice(serverOnly, patch, serverOrder, mergeKey, kind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return all, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeSortedSlice merges the 2 sorted lists by serverOrder with best effort.
0000000000000000000000000000000000000000;;	// It will insert each item in `left` list to `right` list. In most cases, the 2 lists will be interleaved.
0000000000000000000000000000000000000000;;	// The relative order of left and right are guaranteed to be kept.
0000000000000000000000000000000000000000;;	// They have higher precedence than the order in the live list.
0000000000000000000000000000000000000000;;	// The place for a item in `left` is found by:
0000000000000000000000000000000000000000;;	// scan from the place of last insertion in `right` to the end of `right`,
0000000000000000000000000000000000000000;;	// the place is before the first item that is greater than the item we want to insert.
0000000000000000000000000000000000000000;;	// example usage: using server-only items as left and patch items as right. We insert server-only items
0000000000000000000000000000000000000000;;	// to patch list. We use the order of live object as record for comparision.
0000000000000000000000000000000000000000;;	func mergeSortedSlice(left, right, serverOrder []interface{}, mergeKey string, kind reflect.Kind) []interface{} {
0000000000000000000000000000000000000000;;		// Returns if l is less than r, and if both have been found.
0000000000000000000000000000000000000000;;		// If l and r both present and l is in front of r, l is less than r.
0000000000000000000000000000000000000000;;		less := func(l, r interface{}) (bool, bool) {
0000000000000000000000000000000000000000;;			li := index(serverOrder, l, mergeKey, kind)
0000000000000000000000000000000000000000;;			ri := index(serverOrder, r, mergeKey, kind)
0000000000000000000000000000000000000000;;			if li >= 0 && ri >= 0 {
0000000000000000000000000000000000000000;;				return li < ri, true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return false, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// left and right should be non-overlapping.
0000000000000000000000000000000000000000;;		size := len(left) + len(right)
0000000000000000000000000000000000000000;;		i, j := 0, 0
0000000000000000000000000000000000000000;;		s := make([]interface{}, size, size)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k := 0; k < size; k++ {
0000000000000000000000000000000000000000;;			if i >= len(left) && j < len(right) {
0000000000000000000000000000000000000000;;				// have items left in `right` list
0000000000000000000000000000000000000000;;				s[k] = right[j]
0000000000000000000000000000000000000000;;				j++
0000000000000000000000000000000000000000;;			} else if j >= len(right) && i < len(left) {
0000000000000000000000000000000000000000;;				// have items left in `left` list
0000000000000000000000000000000000000000;;				s[k] = left[i]
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// compare them if i and j are both in bound
0000000000000000000000000000000000000000;;				less, foundBoth := less(left[i], right[j])
0000000000000000000000000000000000000000;;				if foundBoth && less {
0000000000000000000000000000000000000000;;					s[k] = left[i]
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					s[k] = right[j]
0000000000000000000000000000000000000000;;					j++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// index returns the index of the item in the given items, or -1 if it doesn't exist
0000000000000000000000000000000000000000;;	// l must NOT be a slice of slices, this should be checked before calling.
0000000000000000000000000000000000000000;;	func index(l []interface{}, valToLookUp interface{}, mergeKey string, kind reflect.Kind) int {
0000000000000000000000000000000000000000;;		var getValFn func(interface{}) interface{}
0000000000000000000000000000000000000000;;		// Get the correct `getValFn` based on item `kind`.
0000000000000000000000000000000000000000;;		// It should return the value of merge key for maps and
0000000000000000000000000000000000000000;;		// return the item for other kinds.
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			getValFn = func(item interface{}) interface{} {
0000000000000000000000000000000000000000;;				typedItem, ok := item.(map[string]interface{})
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				val := typedItem[mergeKey]
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			getValFn = func(item interface{}) interface{} {
0000000000000000000000000000000000000000;;				return item
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, v := range l {
0000000000000000000000000000000000000000;;			if getValFn(valToLookUp) == getValFn(v) {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extractToDeleteItems takes a list and
0000000000000000000000000000000000000000;;	// returns 2 lists: one contains items that should be kept and the other contains items to be deleted.
0000000000000000000000000000000000000000;;	func extractToDeleteItems(l []interface{}) ([]interface{}, []interface{}, error) {
0000000000000000000000000000000000000000;;		var nonDelete, toDelete []interface{}
0000000000000000000000000000000000000000;;		for _, v := range l {
0000000000000000000000000000000000000000;;			m, ok := v.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, nil, mergepatch.ErrBadArgType(m, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			directive, foundDirective := m[directiveMarker]
0000000000000000000000000000000000000000;;			if foundDirective && directive == deleteDirective {
0000000000000000000000000000000000000000;;				toDelete = append(toDelete, v)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				nonDelete = append(nonDelete, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nonDelete, toDelete, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// normalizeSliceOrder sort `toSort` list by `order`
0000000000000000000000000000000000000000;;	func normalizeSliceOrder(toSort, order []interface{}, mergeKey string, kind reflect.Kind) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		var toDelete []interface{}
0000000000000000000000000000000000000000;;		if kind == reflect.Map {
0000000000000000000000000000000000000000;;			// make sure each item in toSort, order has merge key
0000000000000000000000000000000000000000;;			err := validateMergeKeyInLists(mergeKey, toSort, order)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			toSort, toDelete, err = extractToDeleteItems(toSort)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.SliceStable(toSort, func(i, j int) bool {
0000000000000000000000000000000000000000;;			if ii := index(order, toSort[i], mergeKey, kind); ii >= 0 {
0000000000000000000000000000000000000000;;				if ij := index(order, toSort[j], mergeKey, kind); ij >= 0 {
0000000000000000000000000000000000000000;;					return ii < ij
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		toSort = append(toSort, toDelete...)
0000000000000000000000000000000000000000;;		return toSort, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a (recursive) strategic merge patch, a parallel deletion list if necessary and
0000000000000000000000000000000000000000;;	// another list to set the order of the list
0000000000000000000000000000000000000000;;	// Only list of primitives with merge strategy will generate a parallel deletion list.
0000000000000000000000000000000000000000;;	// These two lists should yield modified when applied to original, for lists with merge semantics.
0000000000000000000000000000000000000000;;	func diffLists(original, modified []interface{}, t reflect.Type, mergeKey string, diffOptions DiffOptions) ([]interface{}, []interface{}, []interface{}, error) {
0000000000000000000000000000000000000000;;		if len(original) == 0 {
0000000000000000000000000000000000000000;;			// Both slices are empty - do nothing
0000000000000000000000000000000000000000;;			if len(modified) == 0 || diffOptions.IgnoreChangesAndAdditions {
0000000000000000000000000000000000000000;;				return nil, nil, nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Old slice was empty - add all elements from the new slice
0000000000000000000000000000000000000000;;			return modified, nil, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		elementType, err := sliceElementType(original, modified)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var patchList, deleteList, setOrderList []interface{}
0000000000000000000000000000000000000000;;		kind := elementType.Kind()
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			patchList, deleteList, err = diffListsOfMaps(original, modified, t, mergeKey, diffOptions)
0000000000000000000000000000000000000000;;			patchList, err = normalizeSliceOrder(patchList, modified, mergeKey, kind)
0000000000000000000000000000000000000000;;			orderSame, err := isOrderSame(original, modified, mergeKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// append the deletions to the end of the patch list.
0000000000000000000000000000000000000000;;			patchList = append(patchList, deleteList...)
0000000000000000000000000000000000000000;;			deleteList = nil
0000000000000000000000000000000000000000;;			// generate the setElementOrder list when there are content changes or order changes
0000000000000000000000000000000000000000;;			if diffOptions.SetElementOrder &&
0000000000000000000000000000000000000000;;				((!diffOptions.IgnoreChangesAndAdditions && (len(patchList) > 0 || !orderSame)) ||
0000000000000000000000000000000000000000;;					(!diffOptions.IgnoreDeletions && len(patchList) > 0)) {
0000000000000000000000000000000000000000;;				// Generate a list of maps that each item contains only the merge key.
0000000000000000000000000000000000000000;;				setOrderList = make([]interface{}, len(modified))
0000000000000000000000000000000000000000;;				for i, v := range modified {
0000000000000000000000000000000000000000;;					typedV := v.(map[string]interface{})
0000000000000000000000000000000000000000;;					setOrderList[i] = map[string]interface{}{
0000000000000000000000000000000000000000;;						mergeKey: typedV[mergeKey],
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			// Lists of Lists are not permitted by the api
0000000000000000000000000000000000000000;;			return nil, nil, nil, mergepatch.ErrNoListOfLists
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			patchList, deleteList, err = diffListsOfScalars(original, modified, diffOptions)
0000000000000000000000000000000000000000;;			patchList, err = normalizeSliceOrder(patchList, modified, mergeKey, kind)
0000000000000000000000000000000000000000;;			// generate the setElementOrder list when there are content changes or order changes
0000000000000000000000000000000000000000;;			if diffOptions.SetElementOrder && ((!diffOptions.IgnoreDeletions && len(deleteList) > 0) ||
0000000000000000000000000000000000000000;;				(!diffOptions.IgnoreChangesAndAdditions && !reflect.DeepEqual(original, modified))) {
0000000000000000000000000000000000000000;;				setOrderList = modified
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return patchList, deleteList, setOrderList, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isOrderSame checks if the order in a list has changed
0000000000000000000000000000000000000000;;	func isOrderSame(original, modified []interface{}, mergeKey string) (bool, error) {
0000000000000000000000000000000000000000;;		if len(original) != len(modified) {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, modifiedItem := range modified {
0000000000000000000000000000000000000000;;			equal, err := mergeKeyValueEqual(original[i], modifiedItem, mergeKey)
0000000000000000000000000000000000000000;;			if err != nil || !equal {
0000000000000000000000000000000000000000;;				return equal, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// diffListsOfScalars returns 2 lists, the first one is addList and the second one is deletionList.
0000000000000000000000000000000000000000;;	// Argument diffOptions.IgnoreChangesAndAdditions controls if calculate addList. true means not calculate.
0000000000000000000000000000000000000000;;	// Argument diffOptions.IgnoreDeletions controls if calculate deletionList. true means not calculate.
0000000000000000000000000000000000000000;;	// original may be changed, but modified is guaranteed to not be changed
0000000000000000000000000000000000000000;;	func diffListsOfScalars(original, modified []interface{}, diffOptions DiffOptions) ([]interface{}, []interface{}, error) {
0000000000000000000000000000000000000000;;		modifiedCopy := make([]interface{}, len(modified))
0000000000000000000000000000000000000000;;		copy(modifiedCopy, modified)
0000000000000000000000000000000000000000;;		// Sort the scalars for easier calculating the diff
0000000000000000000000000000000000000000;;		originalScalars := sortScalars(original)
0000000000000000000000000000000000000000;;		modifiedScalars := sortScalars(modifiedCopy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		originalIndex, modifiedIndex := 0, 0
0000000000000000000000000000000000000000;;		addList := []interface{}{}
0000000000000000000000000000000000000000;;		deletionList := []interface{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			originalInBounds := originalIndex < len(originalScalars)
0000000000000000000000000000000000000000;;			modifiedInBounds := modifiedIndex < len(modifiedScalars)
0000000000000000000000000000000000000000;;			if !originalInBounds && !modifiedInBounds {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// we need to compare the string representation of the scalar,
0000000000000000000000000000000000000000;;			// because the scalar is an interface which doesn't support either < or >
0000000000000000000000000000000000000000;;			// And that's how func sortScalars compare scalars.
0000000000000000000000000000000000000000;;			var originalString, modifiedString string
0000000000000000000000000000000000000000;;			var originalValue, modifiedValue interface{}
0000000000000000000000000000000000000000;;			if originalInBounds {
0000000000000000000000000000000000000000;;				originalValue = originalScalars[originalIndex]
0000000000000000000000000000000000000000;;				originalString = fmt.Sprintf("%v", originalValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if modifiedInBounds {
0000000000000000000000000000000000000000;;				modifiedValue = modifiedScalars[modifiedIndex]
0000000000000000000000000000000000000000;;				modifiedString = fmt.Sprintf("%v", modifiedValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			originalV, modifiedV := compareListValuesAtIndex(originalInBounds, modifiedInBounds, originalString, modifiedString)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case originalV == nil && modifiedV == nil:
0000000000000000000000000000000000000000;;				originalIndex++
0000000000000000000000000000000000000000;;				modifiedIndex++
0000000000000000000000000000000000000000;;			case originalV != nil && modifiedV == nil:
0000000000000000000000000000000000000000;;				if !diffOptions.IgnoreDeletions {
0000000000000000000000000000000000000000;;					deletionList = append(deletionList, originalValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				originalIndex++
0000000000000000000000000000000000000000;;			case originalV == nil && modifiedV != nil:
0000000000000000000000000000000000000000;;				if !diffOptions.IgnoreChangesAndAdditions {
0000000000000000000000000000000000000000;;					addList = append(addList, modifiedValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				modifiedIndex++
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("Unexpected returned value from compareListValuesAtIndex: %v and %v", originalV, modifiedV)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return addList, deduplicateScalars(deletionList), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If first return value is non-nil, list1 contains an element not present in list2
0000000000000000000000000000000000000000;;	// If second return value is non-nil, list2 contains an element not present in list1
0000000000000000000000000000000000000000;;	func compareListValuesAtIndex(list1Inbounds, list2Inbounds bool, list1Value, list2Value string) (interface{}, interface{}) {
0000000000000000000000000000000000000000;;		bothInBounds := list1Inbounds && list2Inbounds
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// scalars are identical
0000000000000000000000000000000000000000;;		case bothInBounds && list1Value == list2Value:
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		// only list2 is in bound
0000000000000000000000000000000000000000;;		case !list1Inbounds:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		// list2 has additional scalar
0000000000000000000000000000000000000000;;		case bothInBounds && list1Value > list2Value:
0000000000000000000000000000000000000000;;			return nil, list2Value
0000000000000000000000000000000000000000;;		// only original is in bound
0000000000000000000000000000000000000000;;		case !list2Inbounds:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		// original has additional scalar
0000000000000000000000000000000000000000;;		case bothInBounds && list1Value < list2Value:
0000000000000000000000000000000000000000;;			return list1Value, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// diffListsOfMaps takes a pair of lists and
0000000000000000000000000000000000000000;;	// returns a (recursive) strategic merge patch list contains additions and changes and
0000000000000000000000000000000000000000;;	// a deletion list contains deletions
0000000000000000000000000000000000000000;;	func diffListsOfMaps(original, modified []interface{}, t reflect.Type, mergeKey string, diffOptions DiffOptions) ([]interface{}, []interface{}, error) {
0000000000000000000000000000000000000000;;		patch := make([]interface{}, 0, len(modified))
0000000000000000000000000000000000000000;;		deletionList := make([]interface{}, 0, len(original))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		originalSorted, err := sortMergeListsByNameArray(original, t, mergeKey, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		modifiedSorted, err := sortMergeListsByNameArray(modified, t, mergeKey, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		originalIndex, modifiedIndex := 0, 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			originalInBounds := originalIndex < len(originalSorted)
0000000000000000000000000000000000000000;;			modifiedInBounds := modifiedIndex < len(modifiedSorted)
0000000000000000000000000000000000000000;;			bothInBounds := originalInBounds && modifiedInBounds
0000000000000000000000000000000000000000;;			if !originalInBounds && !modifiedInBounds {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var originalElementMergeKeyValueString, modifiedElementMergeKeyValueString string
0000000000000000000000000000000000000000;;			var originalElementMergeKeyValue, modifiedElementMergeKeyValue interface{}
0000000000000000000000000000000000000000;;			var originalElement, modifiedElement map[string]interface{}
0000000000000000000000000000000000000000;;			if originalInBounds {
0000000000000000000000000000000000000000;;				originalElement, originalElementMergeKeyValue, err = getMapAndMergeKeyValueByIndex(originalIndex, mergeKey, originalSorted)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				originalElementMergeKeyValueString = fmt.Sprintf("%v", originalElementMergeKeyValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if modifiedInBounds {
0000000000000000000000000000000000000000;;				modifiedElement, modifiedElementMergeKeyValue, err = getMapAndMergeKeyValueByIndex(modifiedIndex, mergeKey, modifiedSorted)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				modifiedElementMergeKeyValueString = fmt.Sprintf("%v", modifiedElementMergeKeyValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case bothInBounds && ItemMatchesOriginalAndModifiedSlice(originalElementMergeKeyValueString, modifiedElementMergeKeyValueString):
0000000000000000000000000000000000000000;;				// Merge key values are equal, so recurse
0000000000000000000000000000000000000000;;				patchValue, err := diffMaps(originalElement, modifiedElement, t, diffOptions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(patchValue) > 0 {
0000000000000000000000000000000000000000;;					patchValue[mergeKey] = modifiedElementMergeKeyValue
0000000000000000000000000000000000000000;;					patch = append(patch, patchValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				originalIndex++
0000000000000000000000000000000000000000;;				modifiedIndex++
0000000000000000000000000000000000000000;;			// only modified is in bound
0000000000000000000000000000000000000000;;			case !originalInBounds:
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			// modified has additional map
0000000000000000000000000000000000000000;;			case bothInBounds && ItemAddedToModifiedSlice(originalElementMergeKeyValueString, modifiedElementMergeKeyValueString):
0000000000000000000000000000000000000000;;				if !diffOptions.IgnoreChangesAndAdditions {
0000000000000000000000000000000000000000;;					patch = append(patch, modifiedElement)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				modifiedIndex++
0000000000000000000000000000000000000000;;			// only original is in bound
0000000000000000000000000000000000000000;;			case !modifiedInBounds:
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			// original has additional map
0000000000000000000000000000000000000000;;			case bothInBounds && ItemRemovedFromModifiedSlice(originalElementMergeKeyValueString, modifiedElementMergeKeyValueString):
0000000000000000000000000000000000000000;;				if !diffOptions.IgnoreDeletions {
0000000000000000000000000000000000000000;;					// Item was deleted, so add delete directive
0000000000000000000000000000000000000000;;					deletionList = append(deletionList, CreateDeleteDirective(mergeKey, originalElementMergeKeyValue))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				originalIndex++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return patch, deletionList, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getMapAndMergeKeyValueByIndex return a map in the list and its merge key value given the index of the map.
0000000000000000000000000000000000000000;;	func getMapAndMergeKeyValueByIndex(index int, mergeKey string, listOfMaps []interface{}) (map[string]interface{}, interface{}, error) {
0000000000000000000000000000000000000000;;		m, ok := listOfMaps[index].(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, mergepatch.ErrBadArgType(m, listOfMaps[index])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, ok := m[mergeKey]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, mergepatch.ErrNoMergeKey(m, mergeKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, val, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StrategicMergePatch applies a strategic merge patch. The patch and the original document
0000000000000000000000000000000000000000;;	// must be json encoded content. A patch can be created from an original and a modified document
0000000000000000000000000000000000000000;;	// by calling CreateStrategicMergePatch.
0000000000000000000000000000000000000000;;	func StrategicMergePatch(original, patch []byte, dataStruct interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		originalMap, err := handleUnmarshal(original)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patchMap, err := handleUnmarshal(patch)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, err := StrategicMergeMapPatch(originalMap, patchMap, dataStruct)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(result)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleUnmarshal(j []byte) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		if j == nil {
0000000000000000000000000000000000000000;;			j = []byte("{}")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := map[string]interface{}{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(j, &m)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, mergepatch.ErrBadJSONDoc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StrategicMergePatch applies a strategic merge patch. The original and patch documents
0000000000000000000000000000000000000000;;	// must be JSONMap. A patch can be created from an original and modified document by
0000000000000000000000000000000000000000;;	// calling CreateTwoWayMergeMapPatch.
0000000000000000000000000000000000000000;;	// Warning: the original and patch JSONMap objects are mutated by this function and should not be reused.
0000000000000000000000000000000000000000;;	func StrategicMergeMapPatch(original, patch JSONMap, dataStruct interface{}) (JSONMap, error) {
0000000000000000000000000000000000000000;;		t, err := getTagStructType(dataStruct)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mergeOptions := MergeOptions{
0000000000000000000000000000000000000000;;			MergeParallelList:    true,
0000000000000000000000000000000000000000;;			IgnoreUnmatchedNulls: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mergeMap(original, patch, t, mergeOptions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTagStructType(dataStruct interface{}) (reflect.Type, error) {
0000000000000000000000000000000000000000;;		if dataStruct == nil {
0000000000000000000000000000000000000000;;			return nil, mergepatch.ErrBadArgKind(struct{}{}, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(dataStruct)
0000000000000000000000000000000000000000;;		// Get the underlying type for pointers
0000000000000000000000000000000000000000;;		if t.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return nil, mergepatch.ErrBadArgKind(struct{}{}, dataStruct)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleDirectiveInMergeMap handles the patch directive when merging 2 maps.
0000000000000000000000000000000000000000;;	func handleDirectiveInMergeMap(directive interface{}, patch map[string]interface{}) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		if directive == replaceDirective {
0000000000000000000000000000000000000000;;			// If the patch contains "$patch: replace", don't merge it, just use the
0000000000000000000000000000000000000000;;			// patch directly. Later on, we can add a single level replace that only
0000000000000000000000000000000000000000;;			// affects the map that the $patch is in.
0000000000000000000000000000000000000000;;			delete(patch, directiveMarker)
0000000000000000000000000000000000000000;;			return patch, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if directive == deleteDirective {
0000000000000000000000000000000000000000;;			// If the patch contains "$patch: delete", don't merge it, just return
0000000000000000000000000000000000000000;;			//  an empty map.
0000000000000000000000000000000000000000;;			return map[string]interface{}{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, mergepatch.ErrBadPatchType(directive, patch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func containsDirectiveMarker(item interface{}) bool {
0000000000000000000000000000000000000000;;		m, ok := item.(map[string]interface{})
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if _, foundDirectiveMarker := m[directiveMarker]; foundDirectiveMarker {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mergeKeyValueEqual(left, right interface{}, mergeKey string) (bool, error) {
0000000000000000000000000000000000000000;;		if len(mergeKey) == 0 {
0000000000000000000000000000000000000000;;			return left == right, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typedLeft, ok := left.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false, mergepatch.ErrBadArgType(typedLeft, left)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typedRight, ok := right.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false, mergepatch.ErrBadArgType(typedRight, right)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mergeKeyLeft, ok := typedLeft[mergeKey]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false, mergepatch.ErrNoMergeKey(typedLeft, mergeKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mergeKeyRight, ok := typedRight[mergeKey]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false, mergepatch.ErrNoMergeKey(typedRight, mergeKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mergeKeyLeft == mergeKeyRight, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extractKey trims the prefix and return the original key
0000000000000000000000000000000000000000;;	func extractKey(s, prefix string) (string, error) {
0000000000000000000000000000000000000000;;		substrings := strings.SplitN(s, "/", 2)
0000000000000000000000000000000000000000;;		if len(substrings) <= 1 || substrings[0] != prefix {
0000000000000000000000000000000000000000;;			switch prefix {
0000000000000000000000000000000000000000;;			case deleteFromPrimitiveListDirectivePrefix:
0000000000000000000000000000000000000000;;				return "", mergepatch.ErrBadPatchFormatForPrimitiveList
0000000000000000000000000000000000000000;;			case setElementOrderDirectivePrefix:
0000000000000000000000000000000000000000;;				return "", mergepatch.ErrBadPatchFormatForSetElementOrderList
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("fail to find unknown prefix %q in %s\n", prefix, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return substrings[1], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validatePatchUsingSetOrderList verifies:
0000000000000000000000000000000000000000;;	// the relative order of any two items in the setOrderList list matches that in the patch list.
0000000000000000000000000000000000000000;;	// the items in the patch list must be a subset or the same as the $setElementOrder list (deletions are ignored).
0000000000000000000000000000000000000000;;	func validatePatchWithSetOrderList(patchList, setOrderList interface{}, mergeKey string) error {
0000000000000000000000000000000000000000;;		typedSetOrderList, ok := setOrderList.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return mergepatch.ErrBadPatchFormatForSetElementOrderList
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typedPatchList, ok := patchList.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return mergepatch.ErrBadPatchFormatForSetElementOrderList
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(typedSetOrderList) == 0 || len(typedPatchList) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var nonDeleteList, toDeleteList []interface{}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if len(mergeKey) > 0 {
0000000000000000000000000000000000000000;;			nonDeleteList, toDeleteList, err = extractToDeleteItems(typedPatchList)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			nonDeleteList = typedPatchList
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchIndex, setOrderIndex := 0, 0
0000000000000000000000000000000000000000;;		for patchIndex < len(nonDeleteList) && setOrderIndex < len(typedSetOrderList) {
0000000000000000000000000000000000000000;;			if containsDirectiveMarker(nonDeleteList[patchIndex]) {
0000000000000000000000000000000000000000;;				patchIndex++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mergeKeyEqual, err := mergeKeyValueEqual(nonDeleteList[patchIndex], typedSetOrderList[setOrderIndex], mergeKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if mergeKeyEqual {
0000000000000000000000000000000000000000;;				patchIndex++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			setOrderIndex++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If patchIndex is inbound but setOrderIndex if out of bound mean there are items mismatching between the patch list and setElementOrder list.
0000000000000000000000000000000000000000;;		// the second check is is a sanity check, and should always be true if the first is true.
0000000000000000000000000000000000000000;;		if patchIndex < len(nonDeleteList) && setOrderIndex >= len(typedSetOrderList) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("The order in patch list:\n%v\n doesn't match %s list:\n%v\n", typedPatchList, setElementOrderDirectivePrefix, setOrderList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typedPatchList = append(nonDeleteList, toDeleteList...)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// preprocessDeletionListForMerging preprocesses the deletion list.
0000000000000000000000000000000000000000;;	// it returns shouldContinue, isDeletionList, noPrefixKey
0000000000000000000000000000000000000000;;	func preprocessDeletionListForMerging(key string, original map[string]interface{},
0000000000000000000000000000000000000000;;		patchVal interface{}, mergeDeletionList bool) (bool, bool, string, error) {
0000000000000000000000000000000000000000;;		// If found a parallel list for deletion and we are going to merge the list,
0000000000000000000000000000000000000000;;		// overwrite the key to the original key and set flag isDeleteList
0000000000000000000000000000000000000000;;		foundParallelListPrefix := strings.HasPrefix(key, deleteFromPrimitiveListDirectivePrefix)
0000000000000000000000000000000000000000;;		if foundParallelListPrefix {
0000000000000000000000000000000000000000;;			if !mergeDeletionList {
0000000000000000000000000000000000000000;;				original[key] = patchVal
0000000000000000000000000000000000000000;;				return true, false, "", nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			originalKey, err := extractKey(key, deleteFromPrimitiveListDirectivePrefix)
0000000000000000000000000000000000000000;;			return false, true, originalKey, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, false, "", nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyRetainKeysDirective looks for a retainKeys directive and applies to original
0000000000000000000000000000000000000000;;	// - if no directive exists do nothing
0000000000000000000000000000000000000000;;	// - if directive is found, clear keys in original missing from the directive list
0000000000000000000000000000000000000000;;	// - validate that all keys present in the patch are present in the retainKeys directive
0000000000000000000000000000000000000000;;	// note: original may be another patch request, e.g. applying the add+modified patch to the deletions patch. In this case it may have directives
0000000000000000000000000000000000000000;;	func applyRetainKeysDirective(original, patch map[string]interface{}, options MergeOptions) error {
0000000000000000000000000000000000000000;;		retainKeysInPatch, foundInPatch := patch[retainKeysDirective]
0000000000000000000000000000000000000000;;		if !foundInPatch {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// cleanup the directive
0000000000000000000000000000000000000000;;		delete(patch, retainKeysDirective)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !options.MergeParallelList {
0000000000000000000000000000000000000000;;			// If original is actually a patch, make sure the retainKeys directives are the same in both patches if present in both.
0000000000000000000000000000000000000000;;			// If not present in the original patch, copy from the modified patch.
0000000000000000000000000000000000000000;;			retainKeysInOriginal, foundInOriginal := original[retainKeysDirective]
0000000000000000000000000000000000000000;;			if foundInOriginal {
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(retainKeysInOriginal, retainKeysInPatch) {
0000000000000000000000000000000000000000;;					// This error actually should never happen.
0000000000000000000000000000000000000000;;					return fmt.Errorf("%v and %v are not deep equal: this may happen when calculating the 3-way diff patch", retainKeysInOriginal, retainKeysInPatch)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				original[retainKeysDirective] = retainKeysInPatch
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		retainKeysList, ok := retainKeysInPatch.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return mergepatch.ErrBadPatchFormatForRetainKeys
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate patch to make sure all fields in the patch are present in the retainKeysList.
0000000000000000000000000000000000000000;;		// The map is used only as a set, the value is never referenced
0000000000000000000000000000000000000000;;		m := map[interface{}]struct{}{}
0000000000000000000000000000000000000000;;		for _, v := range retainKeysList {
0000000000000000000000000000000000000000;;			m[v] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range patch {
0000000000000000000000000000000000000000;;			if v == nil || strings.HasPrefix(k, deleteFromPrimitiveListDirectivePrefix) ||
0000000000000000000000000000000000000000;;				strings.HasPrefix(k, setElementOrderDirectivePrefix) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If there is an item present in the patch but not in the retainKeys list,
0000000000000000000000000000000000000000;;			// the patch is invalid.
0000000000000000000000000000000000000000;;			if _, found := m[k]; !found {
0000000000000000000000000000000000000000;;				return mergepatch.ErrBadPatchFormatForRetainKeys
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clear not present fields
0000000000000000000000000000000000000000;;		for k := range original {
0000000000000000000000000000000000000000;;			if _, found := m[k]; !found {
0000000000000000000000000000000000000000;;				delete(original, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergePatchIntoOriginal processes $setElementOrder list.
0000000000000000000000000000000000000000;;	// When not merging the directive, it will make sure $setElementOrder list exist only in original.
0000000000000000000000000000000000000000;;	// When merging the directive, it will try to find the $setElementOrder list and
0000000000000000000000000000000000000000;;	// its corresponding patch list, validate it and merge it.
0000000000000000000000000000000000000000;;	// Then, sort them by the relative order in setElementOrder, patch list and live list.
0000000000000000000000000000000000000000;;	// The precedence is $setElementOrder > order in patch list > order in live list.
0000000000000000000000000000000000000000;;	// This function will delete the item after merging it to prevent process it again in the future.
0000000000000000000000000000000000000000;;	// Ref: https://git.k8s.io/community/contributors/design-proposals/preserve-order-in-strategic-merge-patch.md
0000000000000000000000000000000000000000;;	func mergePatchIntoOriginal(original, patch map[string]interface{}, t reflect.Type, mergeOptions MergeOptions) error {
0000000000000000000000000000000000000000;;		for key, patchV := range patch {
0000000000000000000000000000000000000000;;			// Do nothing if there is no ordering directive
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(key, setElementOrderDirectivePrefix) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			setElementOrderInPatch := patchV
0000000000000000000000000000000000000000;;			// Copies directive from the second patch (`patch`) to the first patch (`original`)
0000000000000000000000000000000000000000;;			// and checks they are equal and delete the directive in the second patch
0000000000000000000000000000000000000000;;			if !mergeOptions.MergeParallelList {
0000000000000000000000000000000000000000;;				setElementOrderListInOriginal, ok := original[key]
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					// check if the setElementOrder list in original and the one in patch matches
0000000000000000000000000000000000000000;;					if !reflect.DeepEqual(setElementOrderListInOriginal, setElementOrderInPatch) {
0000000000000000000000000000000000000000;;						return mergepatch.ErrBadPatchFormatForSetElementOrderList
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// move the setElementOrder list from patch to original
0000000000000000000000000000000000000000;;					original[key] = setElementOrderInPatch
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(patch, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				ok                                          bool
0000000000000000000000000000000000000000;;				originalFieldValue, patchFieldValue, merged []interface{}
0000000000000000000000000000000000000000;;				patchStrategy, mergeKey                     string
0000000000000000000000000000000000000000;;				patchStrategies                             []string
0000000000000000000000000000000000000000;;				fieldType                                   reflect.Type
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;			typedSetElementOrderList, ok := setElementOrderInPatch.([]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return mergepatch.ErrBadArgType(typedSetElementOrderList, setElementOrderInPatch)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Trim the setElementOrderDirectivePrefix to get the key of the list field in original.
0000000000000000000000000000000000000000;;			originalKey, err := extractKey(key, setElementOrderDirectivePrefix)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// try to find the list with `originalKey` in `original` and `modified` and merge them.
0000000000000000000000000000000000000000;;			originalList, foundOriginal := original[originalKey]
0000000000000000000000000000000000000000;;			patchList, foundPatch := patch[originalKey]
0000000000000000000000000000000000000000;;			if foundOriginal {
0000000000000000000000000000000000000000;;				originalFieldValue, ok = originalList.([]interface{})
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return mergepatch.ErrBadArgType(originalFieldValue, originalList)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if foundPatch {
0000000000000000000000000000000000000000;;				patchFieldValue, ok = patchList.([]interface{})
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return mergepatch.ErrBadArgType(patchFieldValue, patchList)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fieldType, patchStrategies, mergeKey, err = forkedjson.LookupPatchMetadata(t, originalKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, patchStrategy, err = extractRetainKeysPatchStrategy(patchStrategies)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check for consistency between the element order list and the field it applies to
0000000000000000000000000000000000000000;;			err = validatePatchWithSetOrderList(patchFieldValue, typedSetElementOrderList, mergeKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case foundOriginal && !foundPatch:
0000000000000000000000000000000000000000;;				// no change to list contents
0000000000000000000000000000000000000000;;				merged = originalFieldValue
0000000000000000000000000000000000000000;;			case !foundOriginal && foundPatch:
0000000000000000000000000000000000000000;;				// list was added
0000000000000000000000000000000000000000;;				merged = patchFieldValue
0000000000000000000000000000000000000000;;			case foundOriginal && foundPatch:
0000000000000000000000000000000000000000;;				merged, err = mergeSliceHandler(originalList, patchList, fieldType,
0000000000000000000000000000000000000000;;					patchStrategy, mergeKey, false, mergeOptions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case !foundOriginal && !foundPatch:
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Split all items into patch items and server-only items and then enforce the order.
0000000000000000000000000000000000000000;;			var patchItems, serverOnlyItems []interface{}
0000000000000000000000000000000000000000;;			if len(mergeKey) == 0 {
0000000000000000000000000000000000000000;;				// Primitives doesn't need merge key to do partitioning.
0000000000000000000000000000000000000000;;				patchItems, serverOnlyItems = partitionPrimitivesByPresentInList(merged, typedSetElementOrderList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Maps need merge key to do partitioning.
0000000000000000000000000000000000000000;;				patchItems, serverOnlyItems, err = partitionMapsByPresentInList(merged, typedSetElementOrderList, mergeKey)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			elementType, err := sliceElementType(originalFieldValue, patchFieldValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kind := elementType.Kind()
0000000000000000000000000000000000000000;;			// normalize merged list
0000000000000000000000000000000000000000;;			// typedSetElementOrderList contains all the relative order in typedPatchList,
0000000000000000000000000000000000000000;;			// so don't need to use typedPatchList
0000000000000000000000000000000000000000;;			both, err := normalizeElementOrder(patchItems, serverOnlyItems, typedSetElementOrderList, originalFieldValue, mergeKey, kind)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			original[originalKey] = both
0000000000000000000000000000000000000000;;			// delete patch list from patch to prevent process again in the future
0000000000000000000000000000000000000000;;			delete(patch, originalKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// partitionPrimitivesByPresentInList partitions elements into 2 slices, the first containing items present in partitionBy, the other not.
0000000000000000000000000000000000000000;;	func partitionPrimitivesByPresentInList(original, partitionBy []interface{}) ([]interface{}, []interface{}) {
0000000000000000000000000000000000000000;;		patch := make([]interface{}, 0, len(original))
0000000000000000000000000000000000000000;;		serverOnly := make([]interface{}, 0, len(original))
0000000000000000000000000000000000000000;;		inPatch := map[interface{}]bool{}
0000000000000000000000000000000000000000;;		for _, v := range partitionBy {
0000000000000000000000000000000000000000;;			inPatch[v] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range original {
0000000000000000000000000000000000000000;;			if !inPatch[v] {
0000000000000000000000000000000000000000;;				serverOnly = append(serverOnly, v)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				patch = append(patch, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return patch, serverOnly
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// partitionMapsByPresentInList partitions elements into 2 slices, the first containing items present in partitionBy, the other not.
0000000000000000000000000000000000000000;;	func partitionMapsByPresentInList(original, partitionBy []interface{}, mergeKey string) ([]interface{}, []interface{}, error) {
0000000000000000000000000000000000000000;;		patch := make([]interface{}, 0, len(original))
0000000000000000000000000000000000000000;;		serverOnly := make([]interface{}, 0, len(original))
0000000000000000000000000000000000000000;;		for _, v := range original {
0000000000000000000000000000000000000000;;			typedV, ok := v.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, nil, mergepatch.ErrBadArgType(typedV, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mergeKeyValue, foundMergeKey := typedV[mergeKey]
0000000000000000000000000000000000000000;;			if !foundMergeKey {
0000000000000000000000000000000000000000;;				return nil, nil, mergepatch.ErrNoMergeKey(typedV, mergeKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, _, found, err := findMapInSliceBasedOnKeyValue(partitionBy, mergeKey, mergeKeyValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				serverOnly = append(serverOnly, v)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				patch = append(patch, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return patch, serverOnly, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge fields from a patch map into the original map. Note: This may modify
0000000000000000000000000000000000000000;;	// both the original map and the patch because getting a deep copy of a map in
0000000000000000000000000000000000000000;;	// golang is highly non-trivial.
0000000000000000000000000000000000000000;;	// flag mergeOptions.MergeParallelList controls if using the parallel list to delete or keeping the list.
0000000000000000000000000000000000000000;;	// If patch contains any null field (e.g. field_1: null) that is not
0000000000000000000000000000000000000000;;	// present in original, then to propagate it to the end result use
0000000000000000000000000000000000000000;;	// mergeOptions.IgnoreUnmatchedNulls == false.
0000000000000000000000000000000000000000;;	func mergeMap(original, patch map[string]interface{}, t reflect.Type, mergeOptions MergeOptions) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		if v, ok := patch[directiveMarker]; ok {
0000000000000000000000000000000000000000;;			return handleDirectiveInMergeMap(v, patch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nil is an accepted value for original to simplify logic in other places.
0000000000000000000000000000000000000000;;		// If original is nil, replace it with an empty map and then apply the patch.
0000000000000000000000000000000000000000;;		if original == nil {
0000000000000000000000000000000000000000;;			original = map[string]interface{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := applyRetainKeysDirective(original, patch, mergeOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Process $setElementOrder list and other lists sharing the same key.
0000000000000000000000000000000000000000;;		// When not merging the directive, it will make sure $setElementOrder list exist only in original.
0000000000000000000000000000000000000000;;		// When merging the directive, it will process $setElementOrder and its patch list together.
0000000000000000000000000000000000000000;;		// This function will delete the merged elements from patch so they will not be reprocessed
0000000000000000000000000000000000000000;;		err = mergePatchIntoOriginal(original, patch, t, mergeOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start merging the patch into the original.
0000000000000000000000000000000000000000;;		for k, patchV := range patch {
0000000000000000000000000000000000000000;;			skipProcessing, isDeleteList, noPrefixKey, err := preprocessDeletionListForMerging(k, original, patchV, mergeOptions.MergeParallelList)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if skipProcessing {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(noPrefixKey) > 0 {
0000000000000000000000000000000000000000;;				k = noPrefixKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the value of this key is null, delete the key if it exists in the
0000000000000000000000000000000000000000;;			// original. Otherwise, check if we want to preserve it or skip it.
0000000000000000000000000000000000000000;;			// Preserving the null value is useful when we want to send an explicit
0000000000000000000000000000000000000000;;			// delete to the API server.
0000000000000000000000000000000000000000;;			if patchV == nil {
0000000000000000000000000000000000000000;;				if _, ok := original[k]; ok {
0000000000000000000000000000000000000000;;					delete(original, k)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if mergeOptions.IgnoreUnmatchedNulls {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, ok := original[k]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// If it's not in the original document, just take the patch value.
0000000000000000000000000000000000000000;;				original[k] = patchV
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the data type is a pointer, resolve the element.
0000000000000000000000000000000000000000;;			if t.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				t = t.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			originalType := reflect.TypeOf(original[k])
0000000000000000000000000000000000000000;;			patchType := reflect.TypeOf(patchV)
0000000000000000000000000000000000000000;;			if originalType != patchType {
0000000000000000000000000000000000000000;;				original[k] = patchV
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If they're both maps or lists, recurse into the value.
0000000000000000000000000000000000000000;;			// First find the fieldPatchStrategy and fieldPatchMergeKey.
0000000000000000000000000000000000000000;;			fieldType, fieldPatchStrategies, fieldPatchMergeKey, err := forkedjson.LookupPatchMetadata(t, k)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, patchStrategy, err := extractRetainKeysPatchStrategy(fieldPatchStrategies)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch originalType.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				original[k], err = mergeMapHandler(original[k], patchV, fieldType, patchStrategy, mergeOptions)
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				original[k], err = mergeSliceHandler(original[k], patchV, fieldType, patchStrategy, fieldPatchMergeKey, isDeleteList, mergeOptions)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				original[k] = patchV
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return original, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeMapHandler handles how to merge `patchV` whose key is `key` with `original` respecting
0000000000000000000000000000000000000000;;	// fieldPatchStrategy and mergeOptions.
0000000000000000000000000000000000000000;;	func mergeMapHandler(original, patch interface{}, fieldType reflect.Type,
0000000000000000000000000000000000000000;;		fieldPatchStrategy string, mergeOptions MergeOptions) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		typedOriginal, typedPatch, err := mapTypeAssertion(original, patch)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fieldPatchStrategy != replaceDirective {
0000000000000000000000000000000000000000;;			return mergeMap(typedOriginal, typedPatch, fieldType, mergeOptions)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return typedPatch, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeSliceHandler handles how to merge `patchV` whose key is `key` with `original` respecting
0000000000000000000000000000000000000000;;	// fieldPatchStrategy, fieldPatchMergeKey, isDeleteList and mergeOptions.
0000000000000000000000000000000000000000;;	func mergeSliceHandler(original, patch interface{}, fieldType reflect.Type,
0000000000000000000000000000000000000000;;		fieldPatchStrategy, fieldPatchMergeKey string, isDeleteList bool, mergeOptions MergeOptions) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		typedOriginal, typedPatch, err := sliceTypeAssertion(original, patch)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fieldPatchStrategy == mergeDirective {
0000000000000000000000000000000000000000;;			elemType := fieldType.Elem()
0000000000000000000000000000000000000000;;			return mergeSlice(typedOriginal, typedPatch, elemType, fieldPatchMergeKey, mergeOptions, isDeleteList)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return typedPatch, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge two slices together. Note: This may modify both the original slice and
0000000000000000000000000000000000000000;;	// the patch because getting a deep copy of a slice in golang is highly
0000000000000000000000000000000000000000;;	// non-trivial.
0000000000000000000000000000000000000000;;	func mergeSlice(original, patch []interface{}, elemType reflect.Type, mergeKey string, mergeOptions MergeOptions, isDeleteList bool) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		if len(original) == 0 && len(patch) == 0 {
0000000000000000000000000000000000000000;;			return original, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All the values must be of the same type, but not a list.
0000000000000000000000000000000000000000;;		t, err := sliceElementType(original, patch)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var merged []interface{}
0000000000000000000000000000000000000000;;		kind := t.Kind()
0000000000000000000000000000000000000000;;		// If the elements are not maps, merge the slices of scalars.
0000000000000000000000000000000000000000;;		if kind != reflect.Map {
0000000000000000000000000000000000000000;;			if mergeOptions.MergeParallelList && isDeleteList {
0000000000000000000000000000000000000000;;				return deleteFromSlice(original, patch), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Maybe in the future add a "concat" mode that doesn't
0000000000000000000000000000000000000000;;			// deduplicate.
0000000000000000000000000000000000000000;;			both := append(original, patch...)
0000000000000000000000000000000000000000;;			merged = deduplicateScalars(both)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if mergeKey == "" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot merge lists without merge key for type %s", elemType.Kind().String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			original, patch, err = mergeSliceWithSpecialElements(original, patch, mergeKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			merged, err = mergeSliceWithoutSpecialElements(original, patch, mergeKey, elemType, mergeOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// enforce the order
0000000000000000000000000000000000000000;;		var patchItems, serverOnlyItems []interface{}
0000000000000000000000000000000000000000;;		if len(mergeKey) == 0 {
0000000000000000000000000000000000000000;;			patchItems, serverOnlyItems = partitionPrimitivesByPresentInList(merged, patch)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			patchItems, serverOnlyItems, err = partitionMapsByPresentInList(merged, patch, mergeKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return normalizeElementOrder(patchItems, serverOnlyItems, patch, original, mergeKey, kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeSliceWithSpecialElements handles special elements with directiveMarker
0000000000000000000000000000000000000000;;	// before merging the slices. It returns a updated `original` and a patch without special elements.
0000000000000000000000000000000000000000;;	// original and patch must be slices of maps, they should be checked before calling this function.
0000000000000000000000000000000000000000;;	func mergeSliceWithSpecialElements(original, patch []interface{}, mergeKey string) ([]interface{}, []interface{}, error) {
0000000000000000000000000000000000000000;;		patchWithoutSpecialElements := []interface{}{}
0000000000000000000000000000000000000000;;		replace := false
0000000000000000000000000000000000000000;;		for _, v := range patch {
0000000000000000000000000000000000000000;;			typedV := v.(map[string]interface{})
0000000000000000000000000000000000000000;;			patchType, ok := typedV[directiveMarker]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				patchWithoutSpecialElements = append(patchWithoutSpecialElements, v)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				switch patchType {
0000000000000000000000000000000000000000;;				case deleteDirective:
0000000000000000000000000000000000000000;;					mergeValue, ok := typedV[mergeKey]
0000000000000000000000000000000000000000;;					if ok {
0000000000000000000000000000000000000000;;						var err error
0000000000000000000000000000000000000000;;						original, err = deleteMatchingEntries(original, mergeKey, mergeValue)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return nil, nil, mergepatch.ErrNoMergeKey(typedV, mergeKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case replaceDirective:
0000000000000000000000000000000000000000;;					replace = true
0000000000000000000000000000000000000000;;					// Continue iterating through the array to prune any other $patch elements.
0000000000000000000000000000000000000000;;				case mergeDirective:
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("merging lists cannot yet be specified in the patch")
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, nil, mergepatch.ErrBadPatchType(patchType, typedV)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if replace {
0000000000000000000000000000000000000000;;			return patchWithoutSpecialElements, nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return original, patchWithoutSpecialElements, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delete all matching entries (based on merge key) from a merging list
0000000000000000000000000000000000000000;;	func deleteMatchingEntries(original []interface{}, mergeKey string, mergeValue interface{}) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			_, originalKey, found, err := findMapInSliceBasedOnKeyValue(original, mergeKey, mergeValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Delete the element at originalKey.
0000000000000000000000000000000000000000;;			original = append(original[:originalKey], original[originalKey+1:]...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return original, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mergeSliceWithoutSpecialElements merges slices with non-special elements.
0000000000000000000000000000000000000000;;	// original and patch must be slices of maps, they should be checked before calling this function.
0000000000000000000000000000000000000000;;	func mergeSliceWithoutSpecialElements(original, patch []interface{}, mergeKey string, elemType reflect.Type, mergeOptions MergeOptions) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		for _, v := range patch {
0000000000000000000000000000000000000000;;			typedV := v.(map[string]interface{})
0000000000000000000000000000000000000000;;			mergeValue, ok := typedV[mergeKey]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, mergepatch.ErrNoMergeKey(typedV, mergeKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we find a value with this merge key value in original, merge the
0000000000000000000000000000000000000000;;			// maps. Otherwise append onto original.
0000000000000000000000000000000000000000;;			originalMap, originalKey, found, err := findMapInSliceBasedOnKeyValue(original, mergeKey, mergeValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if found {
0000000000000000000000000000000000000000;;				var mergedMaps interface{}
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				// Merge into original.
0000000000000000000000000000000000000000;;				mergedMaps, err = mergeMap(originalMap, typedV, elemType, mergeOptions)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				original[originalKey] = mergedMaps
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				original = append(original, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return original, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteFromSlice uses the parallel list to delete the items in a list of scalars
0000000000000000000000000000000000000000;;	func deleteFromSlice(current, toDelete []interface{}) []interface{} {
0000000000000000000000000000000000000000;;		toDeleteMap := map[interface{}]interface{}{}
0000000000000000000000000000000000000000;;		processed := make([]interface{}, 0, len(current))
0000000000000000000000000000000000000000;;		for _, v := range toDelete {
0000000000000000000000000000000000000000;;			toDeleteMap[v] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range current {
0000000000000000000000000000000000000000;;			if _, found := toDeleteMap[v]; !found {
0000000000000000000000000000000000000000;;				processed = append(processed, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return processed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This method no longer panics if any element of the slice is not a map.
0000000000000000000000000000000000000000;;	func findMapInSliceBasedOnKeyValue(m []interface{}, key string, value interface{}) (map[string]interface{}, int, bool, error) {
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			typedV, ok := v.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, 0, false, fmt.Errorf("value for key %v is not a map.", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			valueToMatch, ok := typedV[key]
0000000000000000000000000000000000000000;;			if ok && valueToMatch == value {
0000000000000000000000000000000000000000;;				return typedV, k, true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, 0, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function takes a JSON map and sorts all the lists that should be merged
0000000000000000000000000000000000000000;;	// by key. This is needed by tests because in JSON, list order is significant,
0000000000000000000000000000000000000000;;	// but in Strategic Merge Patch, merge lists do not have significant order.
0000000000000000000000000000000000000000;;	// Sorting the lists allows for order-insensitive comparison of patched maps.
0000000000000000000000000000000000000000;;	func sortMergeListsByName(mapJSON []byte, dataStruct interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		var m map[string]interface{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(mapJSON, &m)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newM, err := sortMergeListsByNameMap(m, reflect.TypeOf(dataStruct))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(newM)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function sortMergeListsByNameMap recursively sorts the merge lists by its mergeKey in a map.
0000000000000000000000000000000000000000;;	func sortMergeListsByNameMap(s map[string]interface{}, t reflect.Type) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		newS := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for k, v := range s {
0000000000000000000000000000000000000000;;			if k == retainKeysDirective {
0000000000000000000000000000000000000000;;				typedV, ok := v.([]interface{})
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, mergepatch.ErrBadPatchFormatForRetainKeys
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v = sortScalars(typedV)
0000000000000000000000000000000000000000;;			} else if strings.HasPrefix(k, deleteFromPrimitiveListDirectivePrefix) {
0000000000000000000000000000000000000000;;				typedV, ok := v.([]interface{})
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, mergepatch.ErrBadPatchFormatForPrimitiveList
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v = sortScalars(typedV)
0000000000000000000000000000000000000000;;			} else if strings.HasPrefix(k, setElementOrderDirectivePrefix) {
0000000000000000000000000000000000000000;;				_, ok := v.([]interface{})
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, mergepatch.ErrBadPatchFormatForSetElementOrderList
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if k != directiveMarker {
0000000000000000000000000000000000000000;;				fieldType, fieldPatchStrategies, fieldPatchMergeKey, err := forkedjson.LookupPatchMetadata(t, k)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, patchStrategy, err := extractRetainKeysPatchStrategy(fieldPatchStrategies)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// If v is a map or a merge slice, recurse.
0000000000000000000000000000000000000000;;				if typedV, ok := v.(map[string]interface{}); ok {
0000000000000000000000000000000000000000;;					var err error
0000000000000000000000000000000000000000;;					v, err = sortMergeListsByNameMap(typedV, fieldType)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if typedV, ok := v.([]interface{}); ok {
0000000000000000000000000000000000000000;;					if patchStrategy == mergeDirective {
0000000000000000000000000000000000000000;;						var err error
0000000000000000000000000000000000000000;;						v, err = sortMergeListsByNameArray(typedV, fieldType.Elem(), fieldPatchMergeKey, true)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newS[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newS, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function sortMergeListsByNameMap recursively sorts the merge lists by its mergeKey in an array.
0000000000000000000000000000000000000000;;	func sortMergeListsByNameArray(s []interface{}, elemType reflect.Type, mergeKey string, recurse bool) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return s, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We don't support lists of lists yet.
0000000000000000000000000000000000000000;;		t, err := sliceElementType(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the elements are not maps...
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;			// Sort the elements, because they may have been merged out of order.
0000000000000000000000000000000000000000;;			return deduplicateAndSortScalars(s), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Elements are maps - if one of the keys of the map is a map or a
0000000000000000000000000000000000000000;;		// list, we may need to recurse into it.
0000000000000000000000000000000000000000;;		newS := []interface{}{}
0000000000000000000000000000000000000000;;		for _, elem := range s {
0000000000000000000000000000000000000000;;			if recurse {
0000000000000000000000000000000000000000;;				typedElem := elem.(map[string]interface{})
0000000000000000000000000000000000000000;;				newElem, err := sortMergeListsByNameMap(typedElem, elemType)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				newS = append(newS, newElem)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				newS = append(newS, elem)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort the maps.
0000000000000000000000000000000000000000;;		newS = sortMapsBasedOnField(newS, mergeKey)
0000000000000000000000000000000000000000;;		return newS, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sortMapsBasedOnField(m []interface{}, fieldName string) []interface{} {
0000000000000000000000000000000000000000;;		mapM := mapSliceFromSlice(m)
0000000000000000000000000000000000000000;;		ss := SortableSliceOfMaps{mapM, fieldName}
0000000000000000000000000000000000000000;;		sort.Sort(ss)
0000000000000000000000000000000000000000;;		newS := sliceFromMapSlice(ss.s)
0000000000000000000000000000000000000000;;		return newS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mapSliceFromSlice(m []interface{}) []map[string]interface{} {
0000000000000000000000000000000000000000;;		newM := []map[string]interface{}{}
0000000000000000000000000000000000000000;;		for _, v := range m {
0000000000000000000000000000000000000000;;			vt := v.(map[string]interface{})
0000000000000000000000000000000000000000;;			newM = append(newM, vt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newM
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sliceFromMapSlice(s []map[string]interface{}) []interface{} {
0000000000000000000000000000000000000000;;		newS := []interface{}{}
0000000000000000000000000000000000000000;;		for _, v := range s {
0000000000000000000000000000000000000000;;			newS = append(newS, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SortableSliceOfMaps struct {
0000000000000000000000000000000000000000;;		s []map[string]interface{}
0000000000000000000000000000000000000000;;		k string // key to sort on
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss SortableSliceOfMaps) Len() int {
0000000000000000000000000000000000000000;;		return len(ss.s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss SortableSliceOfMaps) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		iStr := fmt.Sprintf("%v", ss.s[i][ss.k])
0000000000000000000000000000000000000000;;		jStr := fmt.Sprintf("%v", ss.s[j][ss.k])
0000000000000000000000000000000000000000;;		return sort.StringsAreSorted([]string{iStr, jStr})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss SortableSliceOfMaps) Swap(i, j int) {
0000000000000000000000000000000000000000;;		tmp := ss.s[i]
0000000000000000000000000000000000000000;;		ss.s[i] = ss.s[j]
0000000000000000000000000000000000000000;;		ss.s[j] = tmp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deduplicateAndSortScalars(s []interface{}) []interface{} {
0000000000000000000000000000000000000000;;		s = deduplicateScalars(s)
0000000000000000000000000000000000000000;;		return sortScalars(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sortScalars(s []interface{}) []interface{} {
0000000000000000000000000000000000000000;;		ss := SortableSliceOfScalars{s}
0000000000000000000000000000000000000000;;		sort.Sort(ss)
0000000000000000000000000000000000000000;;		return ss.s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deduplicateScalars(s []interface{}) []interface{} {
0000000000000000000000000000000000000000;;		// Clever algorithm to deduplicate.
0000000000000000000000000000000000000000;;		length := len(s) - 1
0000000000000000000000000000000000000000;;		for i := 0; i < length; i++ {
0000000000000000000000000000000000000000;;			for j := i + 1; j <= length; j++ {
0000000000000000000000000000000000000000;;				if s[i] == s[j] {
0000000000000000000000000000000000000000;;					s[j] = s[length]
0000000000000000000000000000000000000000;;					s = s[0:length]
0000000000000000000000000000000000000000;;					length--
0000000000000000000000000000000000000000;;					j--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SortableSliceOfScalars struct {
0000000000000000000000000000000000000000;;		s []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss SortableSliceOfScalars) Len() int {
0000000000000000000000000000000000000000;;		return len(ss.s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss SortableSliceOfScalars) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		iStr := fmt.Sprintf("%v", ss.s[i])
0000000000000000000000000000000000000000;;		jStr := fmt.Sprintf("%v", ss.s[j])
0000000000000000000000000000000000000000;;		return sort.StringsAreSorted([]string{iStr, jStr})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ss SortableSliceOfScalars) Swap(i, j int) {
0000000000000000000000000000000000000000;;		tmp := ss.s[i]
0000000000000000000000000000000000000000;;		ss.s[i] = ss.s[j]
0000000000000000000000000000000000000000;;		ss.s[j] = tmp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the type of the elements of N slice(s). If the type is different,
0000000000000000000000000000000000000000;;	// another slice or undefined, returns an error.
0000000000000000000000000000000000000000;;	func sliceElementType(slices ...[]interface{}) (reflect.Type, error) {
0000000000000000000000000000000000000000;;		var prevType reflect.Type
0000000000000000000000000000000000000000;;		for _, s := range slices {
0000000000000000000000000000000000000000;;			// Go through elements of all given slices and make sure they are all the same type.
0000000000000000000000000000000000000000;;			for _, v := range s {
0000000000000000000000000000000000000000;;				currentType := reflect.TypeOf(v)
0000000000000000000000000000000000000000;;				if prevType == nil {
0000000000000000000000000000000000000000;;					prevType = currentType
0000000000000000000000000000000000000000;;					// We don't support lists of lists yet.
0000000000000000000000000000000000000000;;					if prevType.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;						return nil, mergepatch.ErrNoListOfLists
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if prevType != currentType {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("list element types are not identical: %v", fmt.Sprint(slices))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					prevType = currentType
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if prevType == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no elements in any of the given slices")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return prevType, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergingMapsHaveConflicts returns true if the left and right JSON interface
0000000000000000000000000000000000000000;;	// objects overlap with different values in any key. All keys are required to be
0000000000000000000000000000000000000000;;	// strings. Since patches of the same Type have congruent keys, this is valid
0000000000000000000000000000000000000000;;	// for multiple patch types. This method supports strategic merge patch semantics.
0000000000000000000000000000000000000000;;	func MergingMapsHaveConflicts(left, right map[string]interface{}, dataStruct interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		t, err := getTagStructType(dataStruct)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mergingMapFieldsHaveConflicts(left, right, t, "", "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mergingMapFieldsHaveConflicts(
0000000000000000000000000000000000000000;;		left, right interface{},
0000000000000000000000000000000000000000;;		fieldType reflect.Type,
0000000000000000000000000000000000000000;;		fieldPatchStrategy, fieldPatchMergeKey string,
0000000000000000000000000000000000000000;;	) (bool, error) {
0000000000000000000000000000000000000000;;		switch leftType := left.(type) {
0000000000000000000000000000000000000000;;		case map[string]interface{}:
0000000000000000000000000000000000000000;;			rightType, ok := right.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			leftMarker, okLeft := leftType[directiveMarker]
0000000000000000000000000000000000000000;;			rightMarker, okRight := rightType[directiveMarker]
0000000000000000000000000000000000000000;;			// if one or the other has a directive marker,
0000000000000000000000000000000000000000;;			// then we need to consider that before looking at the individual keys,
0000000000000000000000000000000000000000;;			// since a directive operates on the whole map.
0000000000000000000000000000000000000000;;			if okLeft || okRight {
0000000000000000000000000000000000000000;;				// if one has a directive marker and the other doesn't,
0000000000000000000000000000000000000000;;				// then we have a conflict, since one is deleting or replacing the whole map,
0000000000000000000000000000000000000000;;				// and the other is doing things to individual keys.
0000000000000000000000000000000000000000;;				if okLeft != okRight {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// if they both have markers, but they are not the same directive,
0000000000000000000000000000000000000000;;				// then we have a conflict because they're doing different things to the map.
0000000000000000000000000000000000000000;;				if leftMarker != rightMarker {
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fieldPatchStrategy == replaceDirective {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Check the individual keys.
0000000000000000000000000000000000000000;;			return mapsHaveConflicts(leftType, rightType, fieldType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			rightType, ok := right.([]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return slicesHaveConflicts(leftType, rightType, fieldType, fieldPatchStrategy, fieldPatchMergeKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case string, float64, bool, int, int64, nil:
0000000000000000000000000000000000000000;;			return !reflect.DeepEqual(left, right), nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return true, fmt.Errorf("unknown type: %v", reflect.TypeOf(left))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mapsHaveConflicts(typedLeft, typedRight map[string]interface{}, structType reflect.Type) (bool, error) {
0000000000000000000000000000000000000000;;		for key, leftValue := range typedLeft {
0000000000000000000000000000000000000000;;			if key != directiveMarker && key != retainKeysDirective {
0000000000000000000000000000000000000000;;				if rightValue, ok := typedRight[key]; ok {
0000000000000000000000000000000000000000;;					fieldType, fieldPatchStrategies, fieldPatchMergeKey, err := forkedjson.LookupPatchMetadata(structType, key)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return true, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					_, patchStrategy, err := extractRetainKeysPatchStrategy(fieldPatchStrategies)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return true, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if hasConflicts, err := mergingMapFieldsHaveConflicts(leftValue, rightValue,
0000000000000000000000000000000000000000;;						fieldType, patchStrategy, fieldPatchMergeKey); hasConflicts {
0000000000000000000000000000000000000000;;						return true, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func slicesHaveConflicts(
0000000000000000000000000000000000000000;;		typedLeft, typedRight []interface{},
0000000000000000000000000000000000000000;;		fieldType reflect.Type,
0000000000000000000000000000000000000000;;		fieldPatchStrategy, fieldPatchMergeKey string,
0000000000000000000000000000000000000000;;	) (bool, error) {
0000000000000000000000000000000000000000;;		elementType, err := sliceElementType(typedLeft, typedRight)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		valueType := fieldType.Elem()
0000000000000000000000000000000000000000;;		if fieldPatchStrategy == mergeDirective {
0000000000000000000000000000000000000000;;			// Merging lists of scalars have no conflicts by definition
0000000000000000000000000000000000000000;;			// So we only need to check further if the elements are maps
0000000000000000000000000000000000000000;;			if elementType.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Build a map for each slice and then compare the two maps
0000000000000000000000000000000000000000;;			leftMap, err := sliceOfMapsToMapOfMaps(typedLeft, fieldPatchMergeKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return true, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rightMap, err := sliceOfMapsToMapOfMaps(typedRight, fieldPatchMergeKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return true, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return mapsOfMapsHaveConflicts(leftMap, rightMap, valueType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Either we don't have type information, or these are non-merging lists
0000000000000000000000000000000000000000;;		if len(typedLeft) != len(typedRight) {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort scalar slices to prevent ordering issues
0000000000000000000000000000000000000000;;		// We have no way to sort non-merging lists of maps
0000000000000000000000000000000000000000;;		if elementType.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;			typedLeft = deduplicateAndSortScalars(typedLeft)
0000000000000000000000000000000000000000;;			typedRight = deduplicateAndSortScalars(typedRight)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compare the slices element by element in order
0000000000000000000000000000000000000000;;		// This test will fail if the slices are not sorted
0000000000000000000000000000000000000000;;		for i := range typedLeft {
0000000000000000000000000000000000000000;;			if hasConflicts, err := mergingMapFieldsHaveConflicts(typedLeft[i], typedRight[i], valueType, "", ""); hasConflicts {
0000000000000000000000000000000000000000;;				return true, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sliceOfMapsToMapOfMaps(slice []interface{}, mergeKey string) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		result := make(map[string]interface{}, len(slice))
0000000000000000000000000000000000000000;;		for _, value := range slice {
0000000000000000000000000000000000000000;;			typedValue, ok := value.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid element type in merging list:%v", slice)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			mergeValue, ok := typedValue[mergeKey]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot find merge key `%s` in merging list element:%v", mergeKey, typedValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result[fmt.Sprintf("%s", mergeValue)] = typedValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mapsOfMapsHaveConflicts(typedLeft, typedRight map[string]interface{}, structType reflect.Type) (bool, error) {
0000000000000000000000000000000000000000;;		for key, leftValue := range typedLeft {
0000000000000000000000000000000000000000;;			if rightValue, ok := typedRight[key]; ok {
0000000000000000000000000000000000000000;;				if hasConflicts, err := mergingMapFieldsHaveConflicts(leftValue, rightValue, structType, "", ""); hasConflicts {
0000000000000000000000000000000000000000;;					return true, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateThreeWayMergePatch reconciles a modified configuration with an original configuration,
0000000000000000000000000000000000000000;;	// while preserving any changes or deletions made to the original configuration in the interim,
0000000000000000000000000000000000000000;;	// and not overridden by the current configuration. All three documents must be passed to the
0000000000000000000000000000000000000000;;	// method as json encoded content. It will return a strategic merge patch, or an error if any
0000000000000000000000000000000000000000;;	// of the documents is invalid, or if there are any preconditions that fail against the modified
0000000000000000000000000000000000000000;;	// configuration, or, if overwrite is false and there are conflicts between the modified and current
0000000000000000000000000000000000000000;;	// configurations. Conflicts are defined as keys changed differently from original to modified
0000000000000000000000000000000000000000;;	// than from original to current. In other words, a conflict occurs if modified changes any key
0000000000000000000000000000000000000000;;	// in a way that is different from how it is changed in current (e.g., deleting it, changing its
0000000000000000000000000000000000000000;;	// value). We also propagate values fields that do not exist in original but are explicitly
0000000000000000000000000000000000000000;;	// defined in modified.
0000000000000000000000000000000000000000;;	func CreateThreeWayMergePatch(original, modified, current []byte, dataStruct interface{}, overwrite bool, fns ...mergepatch.PreconditionFunc) ([]byte, error) {
0000000000000000000000000000000000000000;;		originalMap := map[string]interface{}{}
0000000000000000000000000000000000000000;;		if len(original) > 0 {
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(original, &originalMap); err != nil {
0000000000000000000000000000000000000000;;				return nil, mergepatch.ErrBadJSONDoc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		modifiedMap := map[string]interface{}{}
0000000000000000000000000000000000000000;;		if len(modified) > 0 {
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(modified, &modifiedMap); err != nil {
0000000000000000000000000000000000000000;;				return nil, mergepatch.ErrBadJSONDoc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentMap := map[string]interface{}{}
0000000000000000000000000000000000000000;;		if len(current) > 0 {
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(current, &currentMap); err != nil {
0000000000000000000000000000000000000000;;				return nil, mergepatch.ErrBadJSONDoc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t, err := getTagStructType(dataStruct)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The patch is the difference from current to modified without deletions, plus deletions
0000000000000000000000000000000000000000;;		// from original to modified. To find it, we compute deletions, which are the deletions from
0000000000000000000000000000000000000000;;		// original to modified, and delta, which is the difference from current to modified without
0000000000000000000000000000000000000000;;		// deletions, and then apply delta to deletions as a patch, which should be strictly additive.
0000000000000000000000000000000000000000;;		deltaMapDiffOptions := DiffOptions{
0000000000000000000000000000000000000000;;			IgnoreDeletions: true,
0000000000000000000000000000000000000000;;			SetElementOrder: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deltaMap, err := diffMaps(currentMap, modifiedMap, t, deltaMapDiffOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deletionsMapDiffOptions := DiffOptions{
0000000000000000000000000000000000000000;;			SetElementOrder:           true,
0000000000000000000000000000000000000000;;			IgnoreChangesAndAdditions: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deletionsMap, err := diffMaps(originalMap, modifiedMap, t, deletionsMapDiffOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mergeOptions := MergeOptions{}
0000000000000000000000000000000000000000;;		patchMap, err := mergeMap(deletionsMap, deltaMap, t, mergeOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Apply the preconditions to the patch, and return an error if any of them fail.
0000000000000000000000000000000000000000;;		for _, fn := range fns {
0000000000000000000000000000000000000000;;			if !fn(patchMap) {
0000000000000000000000000000000000000000;;				return nil, mergepatch.NewErrPreconditionFailed(patchMap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If overwrite is false, and the patch contains any keys that were changed differently,
0000000000000000000000000000000000000000;;		// then return a conflict error.
0000000000000000000000000000000000000000;;		if !overwrite {
0000000000000000000000000000000000000000;;			changeMapDiffOptions := DiffOptions{}
0000000000000000000000000000000000000000;;			changedMap, err := diffMaps(originalMap, currentMap, t, changeMapDiffOptions)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hasConflicts, err := MergingMapsHaveConflicts(patchMap, changedMap, dataStruct)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if hasConflicts {
0000000000000000000000000000000000000000;;				return nil, mergepatch.NewErrConflict(mergepatch.ToYAMLOrError(patchMap), mergepatch.ToYAMLOrError(changedMap))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(patchMap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ItemAddedToModifiedSlice(original, modified string) bool { return original > modified }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ItemRemovedFromModifiedSlice(original, modified string) bool { return original < modified }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ItemMatchesOriginalAndModifiedSlice(original, modified string) bool { return original == modified }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateDeleteDirective(mergeKey string, mergeKeyValue interface{}) map[string]interface{} {
0000000000000000000000000000000000000000;;		return map[string]interface{}{mergeKey: mergeKeyValue, directiveMarker: deleteDirective}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mapTypeAssertion(original, patch interface{}) (map[string]interface{}, map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		typedOriginal, ok := original.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, mergepatch.ErrBadArgType(typedOriginal, original)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typedPatch, ok := patch.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, mergepatch.ErrBadArgType(typedPatch, patch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return typedOriginal, typedPatch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sliceTypeAssertion(original, patch interface{}) ([]interface{}, []interface{}, error) {
0000000000000000000000000000000000000000;;		typedOriginal, ok := original.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, mergepatch.ErrBadArgType(typedOriginal, original)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typedPatch, ok := patch.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, mergepatch.ErrBadArgType(typedPatch, patch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return typedOriginal, typedPatch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extractRetainKeysPatchStrategy process patch strategy, which is a string may contains multiple
0000000000000000000000000000000000000000;;	// patch strategies seperated by ",". It returns a boolean var indicating if it has
0000000000000000000000000000000000000000;;	// retainKeys strategies and a string for the other strategy.
0000000000000000000000000000000000000000;;	func extractRetainKeysPatchStrategy(strategies []string) (bool, string, error) {
0000000000000000000000000000000000000000;;		switch len(strategies) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return false, "", nil
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			singleStrategy := strategies[0]
0000000000000000000000000000000000000000;;			switch singleStrategy {
0000000000000000000000000000000000000000;;			case retainKeysStrategy:
0000000000000000000000000000000000000000;;				return true, "", nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, singleStrategy, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case strategies[0] == retainKeysStrategy:
0000000000000000000000000000000000000000;;				return true, strategies[1], nil
0000000000000000000000000000000000000000;;			case strategies[1] == retainKeysStrategy:
0000000000000000000000000000000000000000;;				return true, strategies[0], nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, "", fmt.Errorf("unexpected patch strategy: %v", strategies)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false, "", fmt.Errorf("unexpected patch strategy: %v", strategies)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasAdditionalNewField returns if original map has additional key with non-nil value than modified.
0000000000000000000000000000000000000000;;	func hasAdditionalNewField(original, modified map[string]interface{}) bool {
0000000000000000000000000000000000000000;;		for k, v := range original {
0000000000000000000000000000000000000000;;			if v == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, found := modified[k]; !found {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
