0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package net
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPortRange(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			input    string
0000000000000000000000000000000000000000;;			success  bool
0000000000000000000000000000000000000000;;			expected string
0000000000000000000000000000000000000000;;			included int
0000000000000000000000000000000000000000;;			excluded int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"100-200", true, "100-200", 200, 201},
0000000000000000000000000000000000000000;;			{" 100-200 ", true, "100-200", 200, 201},
0000000000000000000000000000000000000000;;			{"0-0", true, "0-0", 0, 1},
0000000000000000000000000000000000000000;;			{"", true, "", -1, 0},
0000000000000000000000000000000000000000;;			{"100", false, "", -1, -1},
0000000000000000000000000000000000000000;;			{"100 - 200", false, "", -1, -1},
0000000000000000000000000000000000000000;;			{"-100", false, "", -1, -1},
0000000000000000000000000000000000000000;;			{"100-", false, "", -1, -1},
0000000000000000000000000000000000000000;;			{"200-100", false, "", -1, -1},
0000000000000000000000000000000000000000;;			{"60000-70000", false, "", -1, -1},
0000000000000000000000000000000000000000;;			{"70000-80000", false, "", -1, -1},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range testCases {
0000000000000000000000000000000000000000;;			tc := &testCases[i]
0000000000000000000000000000000000000000;;			pr := &PortRange{}
0000000000000000000000000000000000000000;;			var f flag.Value = pr
0000000000000000000000000000000000000000;;			err := f.Set(tc.input)
0000000000000000000000000000000000000000;;			if err != nil && tc.success == true {
0000000000000000000000000000000000000000;;				t.Errorf("expected success, got %q", err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if err == nil && tc.success == false {
0000000000000000000000000000000000000000;;				t.Errorf("expected failure")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if tc.success {
0000000000000000000000000000000000000000;;				if f.String() != tc.expected {
0000000000000000000000000000000000000000;;					t.Errorf("expected %q, got %q", tc.expected, f.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tc.included >= 0 && !pr.Contains(tc.included) {
0000000000000000000000000000000000000000;;					t.Errorf("expected %q to include %d", f.String(), tc.included)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tc.excluded >= 0 && pr.Contains(tc.excluded) {
0000000000000000000000000000000000000000;;					t.Errorf("expected %q to exclude %d", f.String(), tc.excluded)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
