0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package runtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ReallyCrash controls the behavior of HandleCrash and now defaults
0000000000000000000000000000000000000000;;		// true. It's still exposed so components can optionally set to false
0000000000000000000000000000000000000000;;		// to restore prior behavior.
0000000000000000000000000000000000000000;;		ReallyCrash = true
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PanicHandlers is a list of functions which will be invoked when a panic happens.
0000000000000000000000000000000000000000;;	var PanicHandlers = []func(interface{}){logPanic}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleCrash simply catches a crash and logs an error. Meant to be called via
0000000000000000000000000000000000000000;;	// defer.  Additional context-specific handlers can be provided, and will be
0000000000000000000000000000000000000000;;	// called in case of panic.  HandleCrash actually crashes, after calling the
0000000000000000000000000000000000000000;;	// handlers and logging the panic message.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: remove this function. We are switching to a world where it's safe for
0000000000000000000000000000000000000000;;	// apiserver to panic, since it will be restarted by kubelet. At the beginning
0000000000000000000000000000000000000000;;	// of the Kubernetes project, nothing was going to restart apiserver and so
0000000000000000000000000000000000000000;;	// catching panics was important. But it's actually much simpler for montoring
0000000000000000000000000000000000000000;;	// software if we just exit when an unexpected panic happens.
0000000000000000000000000000000000000000;;	func HandleCrash(additionalHandlers ...func(interface{})) {
0000000000000000000000000000000000000000;;		if r := recover(); r != nil {
0000000000000000000000000000000000000000;;			for _, fn := range PanicHandlers {
0000000000000000000000000000000000000000;;				fn(r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, fn := range additionalHandlers {
0000000000000000000000000000000000000000;;				fn(r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ReallyCrash {
0000000000000000000000000000000000000000;;				// Actually proceed to panic.
0000000000000000000000000000000000000000;;				panic(r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logPanic logs the caller tree when a panic occurs.
0000000000000000000000000000000000000000;;	func logPanic(r interface{}) {
0000000000000000000000000000000000000000;;		callers := getCallers(r)
0000000000000000000000000000000000000000;;		glog.Errorf("Observed a panic: %#v (%v)\n%v", r, r, callers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCallers(r interface{}) string {
0000000000000000000000000000000000000000;;		callers := ""
0000000000000000000000000000000000000000;;		for i := 0; true; i++ {
0000000000000000000000000000000000000000;;			_, file, line, ok := runtime.Caller(i)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			callers = callers + fmt.Sprintf("%v:%v\n", file, line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return callers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorHandlers is a list of functions which will be invoked when an unreturnable
0000000000000000000000000000000000000000;;	// error occurs.
0000000000000000000000000000000000000000;;	// TODO(lavalamp): for testability, this and the below HandleError function
0000000000000000000000000000000000000000;;	// should be packaged up into a testable and reusable object.
0000000000000000000000000000000000000000;;	var ErrorHandlers = []func(error){
0000000000000000000000000000000000000000;;		logError,
0000000000000000000000000000000000000000;;		(&rudimentaryErrorBackoff{
0000000000000000000000000000000000000000;;			lastErrorTime: time.Now(),
0000000000000000000000000000000000000000;;			// 1ms was the number folks were able to stomach as a global rate limit.
0000000000000000000000000000000000000000;;			// If you need to log errors more than 1000 times a second you
0000000000000000000000000000000000000000;;			// should probably consider fixing your code instead. :)
0000000000000000000000000000000000000000;;			minPeriod: time.Millisecond,
0000000000000000000000000000000000000000;;		}).OnError,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandlerError is a method to invoke when a non-user facing piece of code cannot
0000000000000000000000000000000000000000;;	// return an error and needs to indicate it has been ignored. Invoking this method
0000000000000000000000000000000000000000;;	// is preferable to logging the error - the default behavior is to log but the
0000000000000000000000000000000000000000;;	// errors may be sent to a remote server for analysis.
0000000000000000000000000000000000000000;;	func HandleError(err error) {
0000000000000000000000000000000000000000;;		// this is sometimes called with a nil error.  We probably shouldn't fail and should do nothing instead
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, fn := range ErrorHandlers {
0000000000000000000000000000000000000000;;			fn(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logError prints an error with the call stack of the location it was reported
0000000000000000000000000000000000000000;;	func logError(err error) {
0000000000000000000000000000000000000000;;		glog.ErrorDepth(2, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rudimentaryErrorBackoff struct {
0000000000000000000000000000000000000000;;		minPeriod time.Duration // immutable
0000000000000000000000000000000000000000;;		// TODO(lavalamp): use the clock for testability. Need to move that
0000000000000000000000000000000000000000;;		// package for that to be accessible here.
0000000000000000000000000000000000000000;;		lastErrorTimeLock sync.Mutex
0000000000000000000000000000000000000000;;		lastErrorTime     time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OnError will block if it is called more often than the embedded period time.
0000000000000000000000000000000000000000;;	// This will prevent overly tight hot error loops.
0000000000000000000000000000000000000000;;	func (r *rudimentaryErrorBackoff) OnError(error) {
0000000000000000000000000000000000000000;;		r.lastErrorTimeLock.Lock()
0000000000000000000000000000000000000000;;		defer r.lastErrorTimeLock.Unlock()
0000000000000000000000000000000000000000;;		d := time.Since(r.lastErrorTime)
0000000000000000000000000000000000000000;;		if d < r.minPeriod {
0000000000000000000000000000000000000000;;			time.Sleep(r.minPeriod - d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.lastErrorTime = time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetCaller returns the caller of the function that calls it.
0000000000000000000000000000000000000000;;	func GetCaller() string {
0000000000000000000000000000000000000000;;		var pc [1]uintptr
0000000000000000000000000000000000000000;;		runtime.Callers(3, pc[:])
0000000000000000000000000000000000000000;;		f := runtime.FuncForPC(pc[0])
0000000000000000000000000000000000000000;;		if f == nil {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("Unable to find caller")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.Name()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecoverFromPanic replaces the specified error with an error containing the
0000000000000000000000000000000000000000;;	// original error, and  the call tree when a panic occurs. This enables error
0000000000000000000000000000000000000000;;	// handlers to handle errors and panics the same way.
0000000000000000000000000000000000000000;;	func RecoverFromPanic(err *error) {
0000000000000000000000000000000000000000;;		if r := recover(); r != nil {
0000000000000000000000000000000000000000;;			callers := getCallers(r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			*err = fmt.Errorf(
0000000000000000000000000000000000000000;;				"recovered from panic %q. (err=%v) Call stack:\n%v",
0000000000000000000000000000000000000000;;				r,
0000000000000000000000000000000000000000;;				*err,
0000000000000000000000000000000000000000;;				callers)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
