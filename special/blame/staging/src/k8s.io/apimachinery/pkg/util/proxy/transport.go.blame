0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
04a8564febca9ad8ecd0d1827f8724644b8528ad;pkg/util/proxy/transport.go[pkg/util/proxy/transport.go][staging/src/k8s.io/apimachinery/pkg/util/proxy/transport.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package proxy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/html"
0000000000000000000000000000000000000000;;		"golang.org/x/net/html/atom"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// atomsToAttrs states which attributes of which tags require URL substitution.
0000000000000000000000000000000000000000;;	// Sources: http://www.w3.org/TR/REC-html40/index/attributes.html
0000000000000000000000000000000000000000;;	//          http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1
0000000000000000000000000000000000000000;;	var atomsToAttrs = map[atom.Atom]sets.String{
0000000000000000000000000000000000000000;;		atom.A:          sets.NewString("href"),
0000000000000000000000000000000000000000;;		atom.Applet:     sets.NewString("codebase"),
0000000000000000000000000000000000000000;;		atom.Area:       sets.NewString("href"),
0000000000000000000000000000000000000000;;		atom.Audio:      sets.NewString("src"),
0000000000000000000000000000000000000000;;		atom.Base:       sets.NewString("href"),
0000000000000000000000000000000000000000;;		atom.Blockquote: sets.NewString("cite"),
0000000000000000000000000000000000000000;;		atom.Body:       sets.NewString("background"),
0000000000000000000000000000000000000000;;		atom.Button:     sets.NewString("formaction"),
0000000000000000000000000000000000000000;;		atom.Command:    sets.NewString("icon"),
0000000000000000000000000000000000000000;;		atom.Del:        sets.NewString("cite"),
0000000000000000000000000000000000000000;;		atom.Embed:      sets.NewString("src"),
0000000000000000000000000000000000000000;;		atom.Form:       sets.NewString("action"),
0000000000000000000000000000000000000000;;		atom.Frame:      sets.NewString("longdesc", "src"),
0000000000000000000000000000000000000000;;		atom.Head:       sets.NewString("profile"),
0000000000000000000000000000000000000000;;		atom.Html:       sets.NewString("manifest"),
0000000000000000000000000000000000000000;;		atom.Iframe:     sets.NewString("longdesc", "src"),
0000000000000000000000000000000000000000;;		atom.Img:        sets.NewString("longdesc", "src", "usemap"),
0000000000000000000000000000000000000000;;		atom.Input:      sets.NewString("src", "usemap", "formaction"),
0000000000000000000000000000000000000000;;		atom.Ins:        sets.NewString("cite"),
0000000000000000000000000000000000000000;;		atom.Link:       sets.NewString("href"),
0000000000000000000000000000000000000000;;		atom.Object:     sets.NewString("classid", "codebase", "data", "usemap"),
0000000000000000000000000000000000000000;;		atom.Q:          sets.NewString("cite"),
0000000000000000000000000000000000000000;;		atom.Script:     sets.NewString("src"),
0000000000000000000000000000000000000000;;		atom.Source:     sets.NewString("src"),
0000000000000000000000000000000000000000;;		atom.Video:      sets.NewString("poster", "src"),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: css URLs hidden in style elements.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transport is a transport for text/html content that replaces URLs in html
0000000000000000000000000000000000000000;;	// content with the prefix of the proxy server
0000000000000000000000000000000000000000;;	type Transport struct {
0000000000000000000000000000000000000000;;		Scheme      string
0000000000000000000000000000000000000000;;		Host        string
0000000000000000000000000000000000000000;;		PathPrepend string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTrip implements the http.RoundTripper interface
0000000000000000000000000000000000000000;;	func (t *Transport) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		// Add reverse proxy headers.
0000000000000000000000000000000000000000;;		forwardedURI := path.Join(t.PathPrepend, req.URL.Path)
0000000000000000000000000000000000000000;;		if strings.HasSuffix(req.URL.Path, "/") {
0000000000000000000000000000000000000000;;			forwardedURI = forwardedURI + "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("X-Forwarded-Uri", forwardedURI)
0000000000000000000000000000000000000000;;		if len(t.Host) > 0 {
0000000000000000000000000000000000000000;;			req.Header.Set("X-Forwarded-Host", t.Host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(t.Scheme) > 0 {
0000000000000000000000000000000000000000;;			req.Header.Set("X-Forwarded-Proto", t.Scheme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rt := t.RoundTripper
0000000000000000000000000000000000000000;;		if rt == nil {
0000000000000000000000000000000000000000;;			rt = http.DefaultTransport
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := rt.RoundTrip(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			message := fmt.Sprintf("Error: '%s'\nTrying to reach: '%v'", err.Error(), req.URL.String())
0000000000000000000000000000000000000000;;			resp = &http.Response{
0000000000000000000000000000000000000000;;				StatusCode: http.StatusServiceUnavailable,
0000000000000000000000000000000000000000;;				Body:       ioutil.NopCloser(strings.NewReader(message)),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if redirect := resp.Header.Get("Location"); redirect != "" {
0000000000000000000000000000000000000000;;			resp.Header.Set("Location", t.rewriteURL(redirect, req.URL))
0000000000000000000000000000000000000000;;			return resp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cType := resp.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;		cType = strings.TrimSpace(strings.SplitN(cType, ";", 2)[0])
0000000000000000000000000000000000000000;;		if cType != "text/html" {
0000000000000000000000000000000000000000;;			// Do nothing, simply pass through
0000000000000000000000000000000000000000;;			return resp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t.rewriteResponse(req, resp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ = net.RoundTripperWrapper(&Transport{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *Transport) WrappedRoundTripper() http.RoundTripper {
0000000000000000000000000000000000000000;;		return rt.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rewriteURL rewrites a single URL to go through the proxy, if the URL refers
0000000000000000000000000000000000000000;;	// to the same host as sourceURL, which is the page on which the target URL
0000000000000000000000000000000000000000;;	// occurred. If any error occurs (e.g. parsing), it returns targetURL.
0000000000000000000000000000000000000000;;	func (t *Transport) rewriteURL(targetURL string, sourceURL *url.URL) string {
0000000000000000000000000000000000000000;;		url, err := url.Parse(targetURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return targetURL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isDifferentHost := url.Host != "" && url.Host != sourceURL.Host
0000000000000000000000000000000000000000;;		isRelative := !strings.HasPrefix(url.Path, "/")
0000000000000000000000000000000000000000;;		if isDifferentHost || isRelative {
0000000000000000000000000000000000000000;;			return targetURL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url.Scheme = t.Scheme
0000000000000000000000000000000000000000;;		url.Host = t.Host
0000000000000000000000000000000000000000;;		origPath := url.Path
0000000000000000000000000000000000000000;;		// Do not rewrite URL if the sourceURL already contains the necessary prefix.
0000000000000000000000000000000000000000;;		if strings.HasPrefix(url.Path, t.PathPrepend) {
0000000000000000000000000000000000000000;;			return url.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		url.Path = path.Join(t.PathPrepend, url.Path)
0000000000000000000000000000000000000000;;		if strings.HasSuffix(origPath, "/") {
0000000000000000000000000000000000000000;;			// Add back the trailing slash, which was stripped by path.Join().
0000000000000000000000000000000000000000;;			url.Path += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return url.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rewriteHTML scans the HTML for tags with url-valued attributes, and updates
0000000000000000000000000000000000000000;;	// those values with the urlRewriter function. The updated HTML is output to the
0000000000000000000000000000000000000000;;	// writer.
0000000000000000000000000000000000000000;;	func rewriteHTML(reader io.Reader, writer io.Writer, urlRewriter func(string) string) error {
0000000000000000000000000000000000000000;;		// Note: This assumes the content is UTF-8.
0000000000000000000000000000000000000000;;		tokenizer := html.NewTokenizer(reader)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for err == nil {
0000000000000000000000000000000000000000;;			tokenType := tokenizer.Next()
0000000000000000000000000000000000000000;;			switch tokenType {
0000000000000000000000000000000000000000;;			case html.ErrorToken:
0000000000000000000000000000000000000000;;				err = tokenizer.Err()
0000000000000000000000000000000000000000;;			case html.StartTagToken, html.SelfClosingTagToken:
0000000000000000000000000000000000000000;;				token := tokenizer.Token()
0000000000000000000000000000000000000000;;				if urlAttrs, ok := atomsToAttrs[token.DataAtom]; ok {
0000000000000000000000000000000000000000;;					for i, attr := range token.Attr {
0000000000000000000000000000000000000000;;						if urlAttrs.Has(attr.Key) {
0000000000000000000000000000000000000000;;							token.Attr[i].Val = urlRewriter(attr.Val)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = writer.Write([]byte(token.String()))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				_, err = writer.Write(tokenizer.Raw())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != io.EOF {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rewriteResponse modifies an HTML response by updating absolute links referring
0000000000000000000000000000000000000000;;	// to the original host to instead refer to the proxy transport.
0000000000000000000000000000000000000000;;	func (t *Transport) rewriteResponse(req *http.Request, resp *http.Response) (*http.Response, error) {
0000000000000000000000000000000000000000;;		origBody := resp.Body
0000000000000000000000000000000000000000;;		defer origBody.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newContent := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		var reader io.Reader = origBody
0000000000000000000000000000000000000000;;		var writer io.Writer = newContent
0000000000000000000000000000000000000000;;		encoding := resp.Header.Get("Content-Encoding")
0000000000000000000000000000000000000000;;		switch encoding {
0000000000000000000000000000000000000000;;		case "gzip":
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			reader, err = gzip.NewReader(reader)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("errorf making gzip reader: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			gzw := gzip.NewWriter(writer)
0000000000000000000000000000000000000000;;			defer gzw.Close()
0000000000000000000000000000000000000000;;			writer = gzw
0000000000000000000000000000000000000000;;		// TODO: support flate, other encodings.
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			// This is fine
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Some encoding we don't understand-- don't try to parse this
0000000000000000000000000000000000000000;;			glog.Errorf("Proxy encountered encoding %v for text/html; can't understand this so not fixing links.", encoding)
0000000000000000000000000000000000000000;;			return resp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		urlRewriter := func(targetUrl string) string {
0000000000000000000000000000000000000000;;			return t.rewriteURL(targetUrl, req.URL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := rewriteHTML(reader, writer, urlRewriter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to rewrite URLs: %v", err)
0000000000000000000000000000000000000000;;			return resp, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp.Body = ioutil.NopCloser(newContent)
0000000000000000000000000000000000000000;;		// Update header node with new content-length
0000000000000000000000000000000000000000;;		// TODO: Remove any hash/signature headers here?
0000000000000000000000000000000000000000;;		resp.Header.Del("Content-Length")
0000000000000000000000000000000000000000;;		resp.ContentLength = int64(newContent.Len())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp, err
0000000000000000000000000000000000000000;;	}
