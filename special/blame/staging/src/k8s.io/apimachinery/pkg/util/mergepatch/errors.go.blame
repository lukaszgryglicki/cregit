0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
33c8eedc24a4d7abe12be3f93d157816c9c9c952;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mergepatch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrBadJSONDoc                           = errors.New("invalid JSON document")
0000000000000000000000000000000000000000;;		ErrNoListOfLists                        = errors.New("lists of lists are not supported")
0000000000000000000000000000000000000000;;		ErrBadPatchFormatForPrimitiveList       = errors.New("invalid patch format of primitive list")
0000000000000000000000000000000000000000;;		ErrBadPatchFormatForRetainKeys          = errors.New("invalid patch format of retainKeys")
0000000000000000000000000000000000000000;;		ErrBadPatchFormatForSetElementOrderList = errors.New("invalid patch format of setElementOrder list")
0000000000000000000000000000000000000000;;		ErrPatchContentNotMatchRetainKeys       = errors.New("patch content doesn't match retainKeys list")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ErrNoMergeKey(m map[string]interface{}, k string) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("map: %v does not contain declared merge key: %s", m, k)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ErrBadArgType(expected, actual interface{}) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("expected a %s, but received a %s",
0000000000000000000000000000000000000000;;			reflect.TypeOf(expected),
0000000000000000000000000000000000000000;;			reflect.TypeOf(actual))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ErrBadArgKind(expected, actual interface{}) error {
0000000000000000000000000000000000000000;;		var expectedKindString, actualKindString string
0000000000000000000000000000000000000000;;		if expected == nil {
0000000000000000000000000000000000000000;;			expectedKindString = "nil"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			expectedKindString = reflect.TypeOf(expected).Kind().String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if actual == nil {
0000000000000000000000000000000000000000;;			actualKindString = "nil"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			actualKindString = reflect.TypeOf(actual).Kind().String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("expected a %s, but received a %s", expectedKindString, actualKindString)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ErrBadPatchType(t interface{}, m map[string]interface{}) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("unknown patch type: %s in map: %v", t, m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPreconditionFailed returns true if the provided error indicates
0000000000000000000000000000000000000000;;	// a precondition failed.
0000000000000000000000000000000000000000;;	func IsPreconditionFailed(err error) bool {
0000000000000000000000000000000000000000;;		_, ok := err.(ErrPreconditionFailed)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ErrPreconditionFailed struct {
0000000000000000000000000000000000000000;;		message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewErrPreconditionFailed(target map[string]interface{}) ErrPreconditionFailed {
0000000000000000000000000000000000000000;;		s := fmt.Sprintf("precondition failed for: %v", target)
0000000000000000000000000000000000000000;;		return ErrPreconditionFailed{s}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err ErrPreconditionFailed) Error() string {
0000000000000000000000000000000000000000;;		return err.message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ErrConflict struct {
0000000000000000000000000000000000000000;;		message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewErrConflict(patch, current string) ErrConflict {
0000000000000000000000000000000000000000;;		s := fmt.Sprintf("patch:\n%s\nconflicts with changes made from original to current:\n%s\n", patch, current)
0000000000000000000000000000000000000000;;		return ErrConflict{s}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (err ErrConflict) Error() string {
0000000000000000000000000000000000000000;;		return err.message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsConflict returns true if the provided error indicates
0000000000000000000000000000000000000000;;	// a conflict between the patch and the current configuration.
0000000000000000000000000000000000000000;;	func IsConflict(err error) bool {
0000000000000000000000000000000000000000;;		_, ok := err.(ErrConflict)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
