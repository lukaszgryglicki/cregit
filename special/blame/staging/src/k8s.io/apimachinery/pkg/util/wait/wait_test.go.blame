0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package wait
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUntil(t *testing.T) {
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		close(ch)
0000000000000000000000000000000000000000;;		Until(func() {
0000000000000000000000000000000000000000;;			t.Fatal("should not have been invoked")
0000000000000000000000000000000000000000;;		}, 0, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch = make(chan struct{})
0000000000000000000000000000000000000000;;		called := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			Until(func() {
0000000000000000000000000000000000000000;;				called <- struct{}{}
0000000000000000000000000000000000000000;;			}, 0, ch)
0000000000000000000000000000000000000000;;			close(called)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		<-called
0000000000000000000000000000000000000000;;		close(ch)
0000000000000000000000000000000000000000;;		<-called
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNonSlidingUntil(t *testing.T) {
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		close(ch)
0000000000000000000000000000000000000000;;		NonSlidingUntil(func() {
0000000000000000000000000000000000000000;;			t.Fatal("should not have been invoked")
0000000000000000000000000000000000000000;;		}, 0, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch = make(chan struct{})
0000000000000000000000000000000000000000;;		called := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			NonSlidingUntil(func() {
0000000000000000000000000000000000000000;;				called <- struct{}{}
0000000000000000000000000000000000000000;;			}, 0, ch)
0000000000000000000000000000000000000000;;			close(called)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		<-called
0000000000000000000000000000000000000000;;		close(ch)
0000000000000000000000000000000000000000;;		<-called
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUntilReturnsImmediately(t *testing.T) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		Until(func() {
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;		}, 30*time.Second, ch)
0000000000000000000000000000000000000000;;		if now.Add(25 * time.Second).Before(time.Now()) {
0000000000000000000000000000000000000000;;			t.Errorf("Until did not return immediately when the stop chan was closed inside the func")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJitterUntil(t *testing.T) {
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		// if a channel is closed JitterUntil never calls function f
0000000000000000000000000000000000000000;;		// and returns immediately
0000000000000000000000000000000000000000;;		close(ch)
0000000000000000000000000000000000000000;;		JitterUntil(func() {
0000000000000000000000000000000000000000;;			t.Fatal("should not have been invoked")
0000000000000000000000000000000000000000;;		}, 0, 1.0, true, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch = make(chan struct{})
0000000000000000000000000000000000000000;;		called := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			JitterUntil(func() {
0000000000000000000000000000000000000000;;				called <- struct{}{}
0000000000000000000000000000000000000000;;			}, 0, 1.0, true, ch)
0000000000000000000000000000000000000000;;			close(called)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		<-called
0000000000000000000000000000000000000000;;		close(ch)
0000000000000000000000000000000000000000;;		<-called
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJitterUntilReturnsImmediately(t *testing.T) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		JitterUntil(func() {
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;		}, 30*time.Second, 1.0, true, ch)
0000000000000000000000000000000000000000;;		if now.Add(25 * time.Second).Before(time.Now()) {
0000000000000000000000000000000000000000;;			t.Errorf("JitterUntil did not return immediately when the stop chan was closed inside the func")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJitterUntilRecoversPanic(t *testing.T) {
0000000000000000000000000000000000000000;;		// Save and restore crash handlers
0000000000000000000000000000000000000000;;		originalReallyCrash := runtime.ReallyCrash
0000000000000000000000000000000000000000;;		originalHandlers := runtime.PanicHandlers
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			runtime.ReallyCrash = originalReallyCrash
0000000000000000000000000000000000000000;;			runtime.PanicHandlers = originalHandlers
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		called := 0
0000000000000000000000000000000000000000;;		handled := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Hook up a custom crash handler to ensure it is called when a jitter function panics
0000000000000000000000000000000000000000;;		runtime.ReallyCrash = false
0000000000000000000000000000000000000000;;		runtime.PanicHandlers = []func(interface{}){
0000000000000000000000000000000000000000;;			func(p interface{}) {
0000000000000000000000000000000000000000;;				handled++
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		JitterUntil(func() {
0000000000000000000000000000000000000000;;			called++
0000000000000000000000000000000000000000;;			if called > 2 {
0000000000000000000000000000000000000000;;				close(ch)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			panic("TestJitterUntilRecoversPanic")
0000000000000000000000000000000000000000;;		}, time.Millisecond, 1.0, true, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if called != 3 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected panic recovers")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJitterUntilNegativeFactor(t *testing.T) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		called := make(chan struct{})
0000000000000000000000000000000000000000;;		received := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			JitterUntil(func() {
0000000000000000000000000000000000000000;;				called <- struct{}{}
0000000000000000000000000000000000000000;;				<-received
0000000000000000000000000000000000000000;;			}, time.Second, -30.0, true, ch)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		// first loop
0000000000000000000000000000000000000000;;		<-called
0000000000000000000000000000000000000000;;		received <- struct{}{}
0000000000000000000000000000000000000000;;		// second loop
0000000000000000000000000000000000000000;;		<-called
0000000000000000000000000000000000000000;;		close(ch)
0000000000000000000000000000000000000000;;		received <- struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// it should take at most 2 seconds + some overhead, not 3
0000000000000000000000000000000000000000;;		if now.Add(3 * time.Second).Before(time.Now()) {
0000000000000000000000000000000000000000;;			t.Errorf("JitterUntil did not returned after predefined period with negative jitter factor when the stop chan was closed inside the func")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExponentialBackoff(t *testing.T) {
0000000000000000000000000000000000000000;;		opts := Backoff{Factor: 1.0, Steps: 3}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// waits up to steps
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		err := ExponentialBackoff(opts, func() (bool, error) {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != ErrWaitTimeout || i != opts.Steps {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// returns immediately
0000000000000000000000000000000000000000;;		i = 0
0000000000000000000000000000000000000000;;		err = ExponentialBackoff(opts, func() (bool, error) {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil || i != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// returns immediately on error
0000000000000000000000000000000000000000;;		testErr := fmt.Errorf("some other error")
0000000000000000000000000000000000000000;;		err = ExponentialBackoff(opts, func() (bool, error) {
0000000000000000000000000000000000000000;;			return false, testErr
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != testErr {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// invoked multiple times
0000000000000000000000000000000000000000;;		i = 1
0000000000000000000000000000000000000000;;		err = ExponentialBackoff(opts, func() (bool, error) {
0000000000000000000000000000000000000000;;			if i < opts.Steps {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil || i != opts.Steps {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPoller(t *testing.T) {
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(done)
0000000000000000000000000000000000000000;;		w := poller(time.Millisecond, 2*time.Millisecond)
0000000000000000000000000000000000000000;;		ch := w(done)
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;	DRAIN:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case _, open := <-ch:
0000000000000000000000000000000000000000;;				if !open {
0000000000000000000000000000000000000000;;					break DRAIN
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;			case <-time.After(ForeverTestTimeout):
0000000000000000000000000000000000000000;;				t.Errorf("unexpected timeout after poll")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count > 3 {
0000000000000000000000000000000000000000;;			t.Errorf("expected up to three values, got %d", count)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePoller struct {
0000000000000000000000000000000000000000;;		max  int
0000000000000000000000000000000000000000;;		used int32 // accessed with atomics
0000000000000000000000000000000000000000;;		wg   sync.WaitGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeTicker(max int, used *int32, doneFunc func()) WaitFunc {
0000000000000000000000000000000000000000;;		return func(done <-chan struct{}) <-chan struct{} {
0000000000000000000000000000000000000000;;			ch := make(chan struct{})
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer doneFunc()
0000000000000000000000000000000000000000;;				defer close(ch)
0000000000000000000000000000000000000000;;				for i := 0; i < max; i++ {
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case ch <- struct{}{}:
0000000000000000000000000000000000000000;;					case <-done:
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if used != nil {
0000000000000000000000000000000000000000;;						atomic.AddInt32(used, 1)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			return ch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fp *fakePoller) GetWaitFunc() WaitFunc {
0000000000000000000000000000000000000000;;		fp.wg.Add(1)
0000000000000000000000000000000000000000;;		return fakeTicker(fp.max, &fp.used, fp.wg.Done)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPoll(t *testing.T) {
0000000000000000000000000000000000000000;;		invocations := 0
0000000000000000000000000000000000000000;;		f := ConditionFunc(func() (bool, error) {
0000000000000000000000000000000000000000;;			invocations++
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fp := fakePoller{max: 1}
0000000000000000000000000000000000000000;;		if err := pollInternal(fp.GetWaitFunc(), f); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fp.wg.Wait()
0000000000000000000000000000000000000000;;		if invocations != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected exactly one invocation, got %d", invocations)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		used := atomic.LoadInt32(&fp.used)
0000000000000000000000000000000000000000;;		if used != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected exactly one tick, got %d", used)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPollError(t *testing.T) {
0000000000000000000000000000000000000000;;		expectedError := errors.New("Expected error")
0000000000000000000000000000000000000000;;		f := ConditionFunc(func() (bool, error) {
0000000000000000000000000000000000000000;;			return false, expectedError
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fp := fakePoller{max: 1}
0000000000000000000000000000000000000000;;		if err := pollInternal(fp.GetWaitFunc(), f); err == nil || err != expectedError {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected error %v, got none %v", expectedError, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fp.wg.Wait()
0000000000000000000000000000000000000000;;		used := atomic.LoadInt32(&fp.used)
0000000000000000000000000000000000000000;;		if used != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected exactly one tick, got %d", used)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPollImmediate(t *testing.T) {
0000000000000000000000000000000000000000;;		invocations := 0
0000000000000000000000000000000000000000;;		f := ConditionFunc(func() (bool, error) {
0000000000000000000000000000000000000000;;			invocations++
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fp := fakePoller{max: 0}
0000000000000000000000000000000000000000;;		if err := pollImmediateInternal(fp.GetWaitFunc(), f); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We don't need to wait for fp.wg, as pollImmediate shouldn't call WaitFunc at all.
0000000000000000000000000000000000000000;;		if invocations != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected exactly one invocation, got %d", invocations)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		used := atomic.LoadInt32(&fp.used)
0000000000000000000000000000000000000000;;		if used != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected exactly zero ticks, got %d", used)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPollImmediateError(t *testing.T) {
0000000000000000000000000000000000000000;;		expectedError := errors.New("Expected error")
0000000000000000000000000000000000000000;;		f := ConditionFunc(func() (bool, error) {
0000000000000000000000000000000000000000;;			return false, expectedError
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fp := fakePoller{max: 0}
0000000000000000000000000000000000000000;;		if err := pollImmediateInternal(fp.GetWaitFunc(), f); err == nil || err != expectedError {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected error %v, got none %v", expectedError, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We don't need to wait for fp.wg, as pollImmediate shouldn't call WaitFunc at all.
0000000000000000000000000000000000000000;;		used := atomic.LoadInt32(&fp.used)
0000000000000000000000000000000000000000;;		if used != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected exactly zero ticks, got %d", used)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPollForever(t *testing.T) {
0000000000000000000000000000000000000000;;		ch := make(chan struct{})
0000000000000000000000000000000000000000;;		done := make(chan struct{}, 1)
0000000000000000000000000000000000000000;;		complete := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			f := ConditionFunc(func() (bool, error) {
0000000000000000000000000000000000000000;;				ch <- struct{}{}
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-done:
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := PollInfinite(time.Microsecond, f); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected error %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;			complete <- struct{}{}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure the condition is opened
0000000000000000000000000000000000000000;;		<-ch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure channel sends events
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case _, open := <-ch:
0000000000000000000000000000000000000000;;				if !open {
0000000000000000000000000000000000000000;;					t.Fatalf("did not expect channel to be closed")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-time.After(ForeverTestTimeout):
0000000000000000000000000000000000000000;;				t.Fatalf("channel did not return at least once within the poll interval")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// at most one poll notification should be sent once we return from the condition
0000000000000000000000000000000000000000;;		done <- struct{}{}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;				_, open := <-ch
0000000000000000000000000000000000000000;;				if !open {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Fatalf("expected closed channel after two iterations")
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		<-complete
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWaitFor(t *testing.T) {
0000000000000000000000000000000000000000;;		var invocations int
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			F       ConditionFunc
0000000000000000000000000000000000000000;;			Ticks   int
0000000000000000000000000000000000000000;;			Invoked int
0000000000000000000000000000000000000000;;			Err     bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"invoked once": {
0000000000000000000000000000000000000000;;				ConditionFunc(func() (bool, error) {
0000000000000000000000000000000000000000;;					invocations++
0000000000000000000000000000000000000000;;					return true, nil
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				2,
0000000000000000000000000000000000000000;;				1,
0000000000000000000000000000000000000000;;				false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"invoked and returns a timeout": {
0000000000000000000000000000000000000000;;				ConditionFunc(func() (bool, error) {
0000000000000000000000000000000000000000;;					invocations++
0000000000000000000000000000000000000000;;					return false, nil
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				2,
0000000000000000000000000000000000000000;;				3, // the contract of WaitFor() says the func is called once more at the end of the wait
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"returns immediately on error": {
0000000000000000000000000000000000000000;;				ConditionFunc(func() (bool, error) {
0000000000000000000000000000000000000000;;					invocations++
0000000000000000000000000000000000000000;;					return false, errors.New("test")
0000000000000000000000000000000000000000;;				}),
0000000000000000000000000000000000000000;;				2,
0000000000000000000000000000000000000000;;				1,
0000000000000000000000000000000000000000;;				true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, c := range testCases {
0000000000000000000000000000000000000000;;			invocations = 0
0000000000000000000000000000000000000000;;			ticker := fakeTicker(c.Ticks, nil, func() {})
0000000000000000000000000000000000000000;;			err := func() error {
0000000000000000000000000000000000000000;;				done := make(chan struct{})
0000000000000000000000000000000000000000;;				defer close(done)
0000000000000000000000000000000000000000;;				return WaitFor(ticker, c.F, done)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case c.Err && err == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected error, got nil", k)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case !c.Err && err != nil:
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected no error, got: %#v", k, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if invocations != c.Invoked {
0000000000000000000000000000000000000000;;				t.Errorf("%s: Expected %d invocations, got %d", k, c.Invoked, invocations)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWaitForWithDelay(t *testing.T) {
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(done)
0000000000000000000000000000000000000000;;		WaitFor(poller(time.Millisecond, ForeverTestTimeout), func() (bool, error) {
0000000000000000000000000000000000000000;;			time.Sleep(10 * time.Millisecond)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}, done)
0000000000000000000000000000000000000000;;		// If polling goroutine doesn't see the done signal it will leak timers.
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case done <- struct{}{}:
0000000000000000000000000000000000000000;;		case <-time.After(ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("expected an ack of the done signal.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestPollUntil(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		called := make(chan bool)
0000000000000000000000000000000000000000;;		pollDone := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			PollUntil(time.Microsecond, ConditionFunc(func() (bool, error) {
0000000000000000000000000000000000000000;;				called <- true
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}), stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			close(pollDone)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure we're called once
0000000000000000000000000000000000000000;;		<-called
0000000000000000000000000000000000000000;;		// this should trigger a "done"
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// release the condition func  if needed
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				<-called
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure we finished the poll
0000000000000000000000000000000000000000;;		<-pollDone
0000000000000000000000000000000000000000;;	}
