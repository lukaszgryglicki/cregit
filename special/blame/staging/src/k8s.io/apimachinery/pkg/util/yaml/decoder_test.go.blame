0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package yaml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSplitYAMLDocument(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			input  string
0000000000000000000000000000000000000000;;			atEOF  bool
0000000000000000000000000000000000000000;;			expect string
0000000000000000000000000000000000000000;;			adv    int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"foo", true, "foo", 3},
0000000000000000000000000000000000000000;;			{"fo", false, "", 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"---", true, "---", 3},
0000000000000000000000000000000000000000;;			{"---\n", true, "---\n", 4},
0000000000000000000000000000000000000000;;			{"---\n", false, "", 0},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"\n---\n", false, "", 5},
0000000000000000000000000000000000000000;;			{"\n---\n", true, "", 5},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{"abc\n---\ndef", true, "abc", 8},
0000000000000000000000000000000000000000;;			{"def", true, "def", 3},
0000000000000000000000000000000000000000;;			{"", true, "", 0},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			adv, token, err := splitYAMLDocument([]byte(testCase.input), testCase.atEOF)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if adv != testCase.adv {
0000000000000000000000000000000000000000;;				t.Errorf("%d: advance did not match: %d %d", i, testCase.adv, adv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if testCase.expect != string(token) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: token did not match: %q %q", i, testCase.expect, string(token))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGuessJSON(t *testing.T) {
0000000000000000000000000000000000000000;;		if r, _, isJSON := GuessJSONStream(bytes.NewReader([]byte(" \n{}")), 100); !isJSON {
0000000000000000000000000000000000000000;;			t.Fatalf("expected stream to be JSON")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			b := make([]byte, 30)
0000000000000000000000000000000000000000;;			n, err := r.Read(b)
0000000000000000000000000000000000000000;;			if err != nil || n != 4 {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected body: %d / %v", n, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if string(b[:n]) != " \n{}" {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected body: %q", string(b[:n]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScanYAML(t *testing.T) {
0000000000000000000000000000000000000000;;		s := bufio.NewScanner(bytes.NewReader([]byte(`---
0000000000000000000000000000000000000000;;	stuff: 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	---
0000000000000000000000000000000000000000;;	  `)))
0000000000000000000000000000000000000000;;		s.Split(splitYAMLDocument)
0000000000000000000000000000000000000000;;		if !s.Scan() {
0000000000000000000000000000000000000000;;			t.Fatalf("should have been able to scan")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("scan: %s", s.Text())
0000000000000000000000000000000000000000;;		if !s.Scan() {
0000000000000000000000000000000000000000;;			t.Fatalf("should have been able to scan")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("scan: %s", s.Text())
0000000000000000000000000000000000000000;;		if s.Scan() {
0000000000000000000000000000000000000000;;			t.Fatalf("scan should have been done")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Err() != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("err should have been nil: %v", s.Err())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDecodeYAML(t *testing.T) {
0000000000000000000000000000000000000000;;		s := NewYAMLToJSONDecoder(bytes.NewReader([]byte(`---
0000000000000000000000000000000000000000;;	stuff: 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	---   
0000000000000000000000000000000000000000;;	  `)))
0000000000000000000000000000000000000000;;		obj := generic{}
0000000000000000000000000000000000000000;;		if err := s.Decode(&obj); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fmt.Sprintf("%#v", obj) != `yaml.generic{"stuff":1}` {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj = generic{}
0000000000000000000000000000000000000000;;		if err := s.Decode(&obj); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(obj) != 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj = generic{}
0000000000000000000000000000000000000000;;		if err := s.Decode(&obj); err != io.EOF {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDecodeBrokenYAML(t *testing.T) {
0000000000000000000000000000000000000000;;		s := NewYAMLOrJSONDecoder(bytes.NewReader([]byte(`---
0000000000000000000000000000000000000000;;	stuff: 1
0000000000000000000000000000000000000000;;			test-foo: 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	---
0000000000000000000000000000000000000000;;	  `)), 100)
0000000000000000000000000000000000000000;;		obj := generic{}
0000000000000000000000000000000000000000;;		err := s.Decode(&obj)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("expected error with yaml: violate, got no error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Printf("err: %s\n", err.Error())
0000000000000000000000000000000000000000;;		if !strings.Contains(err.Error(), "yaml: line 2:") {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %q to have 'yaml: line 2:' found a tab character", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDecodeBrokenJSON(t *testing.T) {
0000000000000000000000000000000000000000;;		s := NewYAMLOrJSONDecoder(bytes.NewReader([]byte(`{
0000000000000000000000000000000000000000;;		"foo": {
0000000000000000000000000000000000000000;;			"stuff": 1
0000000000000000000000000000000000000000;;			"otherStuff": 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	  `)), 100)
0000000000000000000000000000000000000000;;		obj := generic{}
0000000000000000000000000000000000000000;;		err := s.Decode(&obj)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("expected error with json: prefix, got no error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(err.Error(), "json: line 3:") {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %q to have 'json: line 3:' prefix", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type generic map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestYAMLOrJSONDecoder(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			input  string
0000000000000000000000000000000000000000;;			buffer int
0000000000000000000000000000000000000000;;			isJSON bool
0000000000000000000000000000000000000000;;			err    bool
0000000000000000000000000000000000000000;;			out    []generic
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{` {"1":2}{"3":4}`, 2, true, false, []generic{
0000000000000000000000000000000000000000;;				{"1": 2},
0000000000000000000000000000000000000000;;				{"3": 4},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{" \n{}", 3, true, false, []generic{
0000000000000000000000000000000000000000;;				{},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{" \na: b", 2, false, false, []generic{
0000000000000000000000000000000000000000;;				{"a": "b"},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{" \n{\"a\": \"b\"}", 2, false, true, []generic{
0000000000000000000000000000000000000000;;				{"a": "b"},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{" \n{\"a\": \"b\"}", 3, true, false, []generic{
0000000000000000000000000000000000000000;;				{"a": "b"},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{`   {"a":"b"}`, 100, true, false, []generic{
0000000000000000000000000000000000000000;;				{"a": "b"},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{"", 1, false, false, []generic{}},
0000000000000000000000000000000000000000;;			{"foo: bar\n---\nbaz: biz", 100, false, false, []generic{
0000000000000000000000000000000000000000;;				{"foo": "bar"},
0000000000000000000000000000000000000000;;				{"baz": "biz"},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{"foo: bar\n---\n", 100, false, false, []generic{
0000000000000000000000000000000000000000;;				{"foo": "bar"},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{"foo: bar\n---", 100, false, false, []generic{
0000000000000000000000000000000000000000;;				{"foo": "bar"},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{"foo: bar\n--", 100, false, true, []generic{
0000000000000000000000000000000000000000;;				{"foo": "bar"},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{"foo: bar\n-", 100, false, true, []generic{
0000000000000000000000000000000000000000;;				{"foo": "bar"},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;			{"foo: bar\n", 100, false, false, []generic{
0000000000000000000000000000000000000000;;				{"foo": "bar"},
0000000000000000000000000000000000000000;;			}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, testCase := range testCases {
0000000000000000000000000000000000000000;;			decoder := NewYAMLOrJSONDecoder(bytes.NewReader([]byte(testCase.input)), testCase.buffer)
0000000000000000000000000000000000000000;;			objs := []generic{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				out := make(generic)
0000000000000000000000000000000000000000;;				err = decoder.Decode(&out)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				objs = append(objs, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != io.EOF {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case testCase.err && err == nil:
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected non-error", i)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case !testCase.err && err != nil:
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case err != nil:
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch decoder.decoder.(type) {
0000000000000000000000000000000000000000;;			case *YAMLToJSONDecoder:
0000000000000000000000000000000000000000;;				if testCase.isJSON {
0000000000000000000000000000000000000000;;					t.Errorf("%d: expected JSON decoder, got YAML", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case *json.Decoder:
0000000000000000000000000000000000000000;;				if !testCase.isJSON {
0000000000000000000000000000000000000000;;					t.Errorf("%d: expected YAML decoder, got JSON", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fmt.Sprintf("%#v", testCase.out) != fmt.Sprintf("%#v", objs) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: objects were not equal: \n%#v\n%#v", i, testCase.out, objs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadSingleLongLine(t *testing.T) {
0000000000000000000000000000000000000000;;		testReadLines(t, []int{128 * 1024})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReadRandomLineLengths(t *testing.T) {
0000000000000000000000000000000000000000;;		minLength := 100
0000000000000000000000000000000000000000;;		maxLength := 96 * 1024
0000000000000000000000000000000000000000;;		maxLines := 100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lineLengths := make([]int, maxLines)
0000000000000000000000000000000000000000;;		for i := 0; i < maxLines; i++ {
0000000000000000000000000000000000000000;;			lineLengths[i] = rand.Intn(maxLength-minLength) + minLength
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testReadLines(t, lineLengths)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testReadLines(t *testing.T, lineLengths []int) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			lines       [][]byte
0000000000000000000000000000000000000000;;			inputStream []byte
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for _, lineLength := range lineLengths {
0000000000000000000000000000000000000000;;			inputLine := make([]byte, lineLength+1)
0000000000000000000000000000000000000000;;			for i := 0; i < lineLength; i++ {
0000000000000000000000000000000000000000;;				char := rand.Intn('z'-'A') + 'A'
0000000000000000000000000000000000000000;;				inputLine[i] = byte(char)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			inputLine[len(inputLine)-1] = '\n'
0000000000000000000000000000000000000000;;			lines = append(lines, inputLine)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, line := range lines {
0000000000000000000000000000000000000000;;			inputStream = append(inputStream, line...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// init Reader
0000000000000000000000000000000000000000;;		reader := bufio.NewReader(bytes.NewReader(inputStream))
0000000000000000000000000000000000000000;;		lineReader := &LineReader{reader: reader}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// read lines
0000000000000000000000000000000000000000;;		var readLines [][]byte
0000000000000000000000000000000000000000;;		for range lines {
0000000000000000000000000000000000000000;;			bytes, err := lineReader.Read()
0000000000000000000000000000000000000000;;			if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;				t.Fatalf("failed to read lines: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			readLines = append(readLines, bytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// validate
0000000000000000000000000000000000000000;;		for i := range lines {
0000000000000000000000000000000000000000;;			if len(lines[i]) != len(readLines[i]) {
0000000000000000000000000000000000000000;;				t.Fatalf("expected line length: %d, but got %d", len(lines[i]), len(readLines[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(lines[i], readLines[i]) {
0000000000000000000000000000000000000000;;				t.Fatalf("expected line: %v, but got %v", lines[i], readLines[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTypedJSONOrYamlErrors(t *testing.T) {
0000000000000000000000000000000000000000;;		s := NewYAMLOrJSONDecoder(bytes.NewReader([]byte(`{
0000000000000000000000000000000000000000;;		"foo": {
0000000000000000000000000000000000000000;;			"stuff": 1
0000000000000000000000000000000000000000;;			"otherStuff": 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	  `)), 100)
0000000000000000000000000000000000000000;;		obj := generic{}
0000000000000000000000000000000000000000;;		err := s.Decode(&obj)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("expected error with json: prefix, got no error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := err.(JSONSyntaxError); !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %q to be of type JSONSyntaxError", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s = NewYAMLOrJSONDecoder(bytes.NewReader([]byte(`---
0000000000000000000000000000000000000000;;	stuff: 1
0000000000000000000000000000000000000000;;			test-foo: 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	---
0000000000000000000000000000000000000000;;	  `)), 100)
0000000000000000000000000000000000000000;;		obj = generic{}
0000000000000000000000000000000000000000;;		err = s.Decode(&obj)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("expected error with yaml: prefix, got no error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := err.(YAMLSyntaxError); !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %q to be of type YAMLSyntaxError", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
