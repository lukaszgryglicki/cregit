0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
351764b6cae066588e87a3efee44135d8f7e8120;pkg/util/httpstream/httpstream.go[pkg/util/httpstream/httpstream.go][staging/src/k8s.io/apimachinery/pkg/util/httpstream/httpstream.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package httpstream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		HeaderConnection               = "Connection"
0000000000000000000000000000000000000000;;		HeaderUpgrade                  = "Upgrade"
0000000000000000000000000000000000000000;;		HeaderProtocolVersion          = "X-Stream-Protocol-Version"
0000000000000000000000000000000000000000;;		HeaderAcceptedProtocolVersions = "X-Accepted-Stream-Protocol-Versions"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStreamHandler defines a function that is called when a new Stream is
0000000000000000000000000000000000000000;;	// received. If no error is returned, the Stream is accepted; otherwise,
0000000000000000000000000000000000000000;;	// the stream is rejected. After the reply frame has been sent, replySent is closed.
0000000000000000000000000000000000000000;;	type NewStreamHandler func(stream Stream, replySent <-chan struct{}) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NoOpNewStreamHandler is a stream handler that accepts a new stream and
0000000000000000000000000000000000000000;;	// performs no other logic.
0000000000000000000000000000000000000000;;	func NoOpNewStreamHandler(stream Stream, replySent <-chan struct{}) error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dialer knows how to open a streaming connection to a server.
0000000000000000000000000000000000000000;;	type Dialer interface {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dial opens a streaming connection to a server using one of the protocols
0000000000000000000000000000000000000000;;		// specified (in order of most preferred to least preferred).
0000000000000000000000000000000000000000;;		Dial(protocols ...string) (Connection, string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpgradeRoundTripper is a type of http.RoundTripper that is able to upgrade
0000000000000000000000000000000000000000;;	// HTTP requests to support multiplexed bidirectional streams. After RoundTrip()
0000000000000000000000000000000000000000;;	// is invoked, if the upgrade is successful, clients may retrieve the upgraded
0000000000000000000000000000000000000000;;	// connection by calling UpgradeRoundTripper.Connection().
0000000000000000000000000000000000000000;;	type UpgradeRoundTripper interface {
0000000000000000000000000000000000000000;;		http.RoundTripper
0000000000000000000000000000000000000000;;		// NewConnection validates the response and creates a new Connection.
0000000000000000000000000000000000000000;;		NewConnection(resp *http.Response) (Connection, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResponseUpgrader knows how to upgrade HTTP requests and responses to
0000000000000000000000000000000000000000;;	// add streaming support to them.
0000000000000000000000000000000000000000;;	type ResponseUpgrader interface {
0000000000000000000000000000000000000000;;		// UpgradeResponse upgrades an HTTP response to one that supports multiplexed
0000000000000000000000000000000000000000;;		// streams. newStreamHandler will be called asynchronously whenever the
0000000000000000000000000000000000000000;;		// other end of the upgraded connection creates a new stream.
0000000000000000000000000000000000000000;;		UpgradeResponse(w http.ResponseWriter, req *http.Request, newStreamHandler NewStreamHandler) Connection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Connection represents an upgraded HTTP connection.
0000000000000000000000000000000000000000;;	type Connection interface {
0000000000000000000000000000000000000000;;		// CreateStream creates a new Stream with the supplied headers.
0000000000000000000000000000000000000000;;		CreateStream(headers http.Header) (Stream, error)
0000000000000000000000000000000000000000;;		// Close resets all streams and closes the connection.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;		// CloseChan returns a channel that is closed when the underlying connection is closed.
0000000000000000000000000000000000000000;;		CloseChan() <-chan bool
0000000000000000000000000000000000000000;;		// SetIdleTimeout sets the amount of time the connection may remain idle before
0000000000000000000000000000000000000000;;		// it is automatically closed.
0000000000000000000000000000000000000000;;		SetIdleTimeout(timeout time.Duration)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stream represents a bidirectional communications channel that is part of an
0000000000000000000000000000000000000000;;	// upgraded connection.
0000000000000000000000000000000000000000;;	type Stream interface {
0000000000000000000000000000000000000000;;		io.ReadWriteCloser
0000000000000000000000000000000000000000;;		// Reset closes both directions of the stream, indicating that neither client
0000000000000000000000000000000000000000;;		// or server can use it any more.
0000000000000000000000000000000000000000;;		Reset() error
0000000000000000000000000000000000000000;;		// Headers returns the headers used to create the stream.
0000000000000000000000000000000000000000;;		Headers() http.Header
0000000000000000000000000000000000000000;;		// Identifier returns the stream's ID.
0000000000000000000000000000000000000000;;		Identifier() uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUpgradeRequest returns true if the given request is a connection upgrade request
0000000000000000000000000000000000000000;;	func IsUpgradeRequest(req *http.Request) bool {
0000000000000000000000000000000000000000;;		for _, h := range req.Header[http.CanonicalHeaderKey(HeaderConnection)] {
0000000000000000000000000000000000000000;;			if strings.Contains(strings.ToLower(h), strings.ToLower(HeaderUpgrade)) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func negotiateProtocol(clientProtocols, serverProtocols []string) string {
0000000000000000000000000000000000000000;;		for i := range clientProtocols {
0000000000000000000000000000000000000000;;			for j := range serverProtocols {
0000000000000000000000000000000000000000;;				if clientProtocols[i] == serverProtocols[j] {
0000000000000000000000000000000000000000;;					return clientProtocols[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handshake performs a subprotocol negotiation. If the client did request a
0000000000000000000000000000000000000000;;	// subprotocol, Handshake will select the first common value found in
0000000000000000000000000000000000000000;;	// serverProtocols. If a match is found, Handshake adds a response header
0000000000000000000000000000000000000000;;	// indicating the chosen subprotocol. If no match is found, HTTP forbidden is
0000000000000000000000000000000000000000;;	// returned, along with a response header containing the list of protocols the
0000000000000000000000000000000000000000;;	// server can accept.
0000000000000000000000000000000000000000;;	func Handshake(req *http.Request, w http.ResponseWriter, serverProtocols []string) (string, error) {
0000000000000000000000000000000000000000;;		clientProtocols := req.Header[http.CanonicalHeaderKey(HeaderProtocolVersion)]
0000000000000000000000000000000000000000;;		if len(clientProtocols) == 0 {
0000000000000000000000000000000000000000;;			// Kube 1.0 clients didn't support subprotocol negotiation.
0000000000000000000000000000000000000000;;			// TODO require clientProtocols once Kube 1.0 is no longer supported
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(serverProtocols) == 0 {
0000000000000000000000000000000000000000;;			// Kube 1.0 servers didn't support subprotocol negotiation. This is mainly for testing.
0000000000000000000000000000000000000000;;			// TODO require serverProtocols once Kube 1.0 is no longer supported
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		negotiatedProtocol := negotiateProtocol(clientProtocols, serverProtocols)
0000000000000000000000000000000000000000;;		if len(negotiatedProtocol) == 0 {
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusForbidden)
0000000000000000000000000000000000000000;;			for i := range serverProtocols {
0000000000000000000000000000000000000000;;				w.Header().Add(HeaderAcceptedProtocolVersions, serverProtocols[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "unable to upgrade: unable to negotiate protocol: client supports %v, server accepts %v", clientProtocols, serverProtocols)
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("unable to upgrade: unable to negotiate protocol: client supports %v, server supports %v", clientProtocols, serverProtocols)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Add(HeaderProtocolVersion, negotiatedProtocol)
0000000000000000000000000000000000000000;;		return negotiatedProtocol, nil
0000000000000000000000000000000000000000;;	}
