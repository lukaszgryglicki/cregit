0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package errors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MessageCountMap contains occurance for each error message.
0000000000000000000000000000000000000000;;	type MessageCountMap map[string]int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Aggregate represents an object that contains multiple errors, but does not
0000000000000000000000000000000000000000;;	// necessarily have singular semantic meaning.
0000000000000000000000000000000000000000;;	type Aggregate interface {
0000000000000000000000000000000000000000;;		error
0000000000000000000000000000000000000000;;		Errors() []error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAggregate converts a slice of errors into an Aggregate interface, which
0000000000000000000000000000000000000000;;	// is itself an implementation of the error interface.  If the slice is empty,
0000000000000000000000000000000000000000;;	// this returns nil.
0000000000000000000000000000000000000000;;	// It will check if any of the element of input error list is nil, to avoid
0000000000000000000000000000000000000000;;	// nil pointer panic when call Error().
0000000000000000000000000000000000000000;;	func NewAggregate(errlist []error) Aggregate {
0000000000000000000000000000000000000000;;		if len(errlist) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// In case of input error list contains nil
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		for _, e := range errlist {
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return aggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This helper implements the error and Errors interfaces.  Keeping it private
0000000000000000000000000000000000000000;;	// prevents people from making an aggregate of 0 errors, which is not
0000000000000000000000000000000000000000;;	// an error, but does satisfy the error interface.
0000000000000000000000000000000000000000;;	type aggregate []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error is part of the error interface.
0000000000000000000000000000000000000000;;	func (agg aggregate) Error() string {
0000000000000000000000000000000000000000;;		if len(agg) == 0 {
0000000000000000000000000000000000000000;;			// This should never happen, really.
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(agg) == 1 {
0000000000000000000000000000000000000000;;			return agg[0].Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := fmt.Sprintf("[%s", agg[0].Error())
0000000000000000000000000000000000000000;;		for i := 1; i < len(agg); i++ {
0000000000000000000000000000000000000000;;			result += fmt.Sprintf(", %s", agg[i].Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result += "]"
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Errors is part of the Aggregate interface.
0000000000000000000000000000000000000000;;	func (agg aggregate) Errors() []error {
0000000000000000000000000000000000000000;;		return []error(agg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matcher is used to match errors.  Returns true if the error matches.
0000000000000000000000000000000000000000;;	type Matcher func(error) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterOut removes all errors that match any of the matchers from the input
0000000000000000000000000000000000000000;;	// error.  If the input is a singular error, only that error is tested.  If the
0000000000000000000000000000000000000000;;	// input implements the Aggregate interface, the list of errors will be
0000000000000000000000000000000000000000;;	// processed recursively.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This can be used, for example, to remove known-OK errors (such as io.EOF or
0000000000000000000000000000000000000000;;	// os.PathNotFound) from a list of errors.
0000000000000000000000000000000000000000;;	func FilterOut(err error, fns ...Matcher) error {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if agg, ok := err.(Aggregate); ok {
0000000000000000000000000000000000000000;;			return NewAggregate(filterErrors(agg.Errors(), fns...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !matchesError(err, fns...) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matchesError returns true if any Matcher returns true
0000000000000000000000000000000000000000;;	func matchesError(err error, fns ...Matcher) bool {
0000000000000000000000000000000000000000;;		for _, fn := range fns {
0000000000000000000000000000000000000000;;			if fn(err) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filterErrors returns any errors (or nested errors, if the list contains
0000000000000000000000000000000000000000;;	// nested Errors) for which all fns return false. If no errors
0000000000000000000000000000000000000000;;	// remain a nil list is returned. The resulting silec will have all
0000000000000000000000000000000000000000;;	// nested slices flattened as a side effect.
0000000000000000000000000000000000000000;;	func filterErrors(list []error, fns ...Matcher) []error {
0000000000000000000000000000000000000000;;		result := []error{}
0000000000000000000000000000000000000000;;		for _, err := range list {
0000000000000000000000000000000000000000;;			r := FilterOut(err, fns...)
0000000000000000000000000000000000000000;;			if r != nil {
0000000000000000000000000000000000000000;;				result = append(result, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flatten takes an Aggregate, which may hold other Aggregates in arbitrary
0000000000000000000000000000000000000000;;	// nesting, and flattens them all into a single Aggregate, recursively.
0000000000000000000000000000000000000000;;	func Flatten(agg Aggregate) Aggregate {
0000000000000000000000000000000000000000;;		result := []error{}
0000000000000000000000000000000000000000;;		if agg == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, err := range agg.Errors() {
0000000000000000000000000000000000000000;;			if a, ok := err.(Aggregate); ok {
0000000000000000000000000000000000000000;;				r := Flatten(a)
0000000000000000000000000000000000000000;;				if r != nil {
0000000000000000000000000000000000000000;;					result = append(result, r.Errors()...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					result = append(result, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewAggregate(result)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateAggregateFromMessageCountMap converts MessageCountMap Aggregate
0000000000000000000000000000000000000000;;	func CreateAggregateFromMessageCountMap(m MessageCountMap) Aggregate {
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := make([]error, 0, len(m))
0000000000000000000000000000000000000000;;		for errStr, count := range m {
0000000000000000000000000000000000000000;;			var countStr string
0000000000000000000000000000000000000000;;			if count > 1 {
0000000000000000000000000000000000000000;;				countStr = fmt.Sprintf(" (repeated %v times)", count)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, fmt.Errorf("%v%v", errStr, countStr))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewAggregate(result)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reduce will return err or, if err is an Aggregate and only has one item,
0000000000000000000000000000000000000000;;	// the first item in the aggregate.
0000000000000000000000000000000000000000;;	func Reduce(err error) error {
0000000000000000000000000000000000000000;;		if agg, ok := err.(Aggregate); ok && err != nil {
0000000000000000000000000000000000000000;;			switch len(agg.Errors()) {
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				return agg.Errors()[0]
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AggregateGoroutines runs the provided functions in parallel, stuffing all
0000000000000000000000000000000000000000;;	// non-nil errors into the returned Aggregate.
0000000000000000000000000000000000000000;;	// Returns nil if all the functions complete successfully.
0000000000000000000000000000000000000000;;	func AggregateGoroutines(funcs ...func() error) Aggregate {
0000000000000000000000000000000000000000;;		errChan := make(chan error, len(funcs))
0000000000000000000000000000000000000000;;		for _, f := range funcs {
0000000000000000000000000000000000000000;;			go func(f func() error) { errChan <- f() }(f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs := make([]error, 0)
0000000000000000000000000000000000000000;;		for i := 0; i < cap(errChan); i++ {
0000000000000000000000000000000000000000;;			if err := <-errChan; err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrPreconditionViolated is returned when the precondition is violated
0000000000000000000000000000000000000000;;	var ErrPreconditionViolated = errors.New("precondition is violated")
