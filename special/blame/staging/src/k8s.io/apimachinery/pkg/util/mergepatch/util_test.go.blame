0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
33c8eedc24a4d7abe12be3f93d157816c9c9c952;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mergepatch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHasConflicts(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			A   interface{}
0000000000000000000000000000000000000000;;			B   interface{}
0000000000000000000000000000000000000000;;			Ret bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{A: "hello", B: "hello", Ret: false},
0000000000000000000000000000000000000000;;			{A: "hello", B: "hell", Ret: true},
0000000000000000000000000000000000000000;;			{A: "hello", B: nil, Ret: true},
0000000000000000000000000000000000000000;;			{A: "hello", B: 1, Ret: true},
0000000000000000000000000000000000000000;;			{A: "hello", B: float64(1.0), Ret: true},
0000000000000000000000000000000000000000;;			{A: "hello", B: false, Ret: true},
0000000000000000000000000000000000000000;;			{A: 1, B: 1, Ret: false},
0000000000000000000000000000000000000000;;			{A: nil, B: nil, Ret: false},
0000000000000000000000000000000000000000;;			{A: false, B: false, Ret: false},
0000000000000000000000000000000000000000;;			{A: float64(3), B: float64(3), Ret: false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{A: "hello", B: []interface{}{}, Ret: true},
0000000000000000000000000000000000000000;;			{A: []interface{}{1}, B: []interface{}{}, Ret: true},
0000000000000000000000000000000000000000;;			{A: []interface{}{}, B: []interface{}{}, Ret: false},
0000000000000000000000000000000000000000;;			{A: []interface{}{1}, B: []interface{}{1}, Ret: false},
0000000000000000000000000000000000000000;;			{A: map[string]interface{}{}, B: []interface{}{1}, Ret: true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{A: map[string]interface{}{}, B: map[string]interface{}{"a": 1}, Ret: false},
0000000000000000000000000000000000000000;;			{A: map[string]interface{}{"a": 1}, B: map[string]interface{}{"a": 1}, Ret: false},
0000000000000000000000000000000000000000;;			{A: map[string]interface{}{"a": 1}, B: map[string]interface{}{"a": 2}, Ret: true},
0000000000000000000000000000000000000000;;			{A: map[string]interface{}{"a": 1}, B: map[string]interface{}{"b": 2}, Ret: false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				A:   map[string]interface{}{"a": []interface{}{1}},
0000000000000000000000000000000000000000;;				B:   map[string]interface{}{"a": []interface{}{1}},
0000000000000000000000000000000000000000;;				Ret: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				A:   map[string]interface{}{"a": []interface{}{1}},
0000000000000000000000000000000000000000;;				B:   map[string]interface{}{"a": []interface{}{}},
0000000000000000000000000000000000000000;;				Ret: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				A:   map[string]interface{}{"a": []interface{}{1}},
0000000000000000000000000000000000000000;;				B:   map[string]interface{}{"a": 1},
0000000000000000000000000000000000000000;;				Ret: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Maps and lists with multiple entries.
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				A:   map[string]interface{}{"a": 1, "b": 2},
0000000000000000000000000000000000000000;;				B:   map[string]interface{}{"a": 1, "b": 0},
0000000000000000000000000000000000000000;;				Ret: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				A:   map[string]interface{}{"a": 1, "b": 2},
0000000000000000000000000000000000000000;;				B:   map[string]interface{}{"a": 1, "b": 2},
0000000000000000000000000000000000000000;;				Ret: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				A:   map[string]interface{}{"a": 1, "b": 2},
0000000000000000000000000000000000000000;;				B:   map[string]interface{}{"a": 1, "b": 0, "c": 3},
0000000000000000000000000000000000000000;;				Ret: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				A:   map[string]interface{}{"a": 1, "b": 2},
0000000000000000000000000000000000000000;;				B:   map[string]interface{}{"a": 1, "b": 2, "c": 3},
0000000000000000000000000000000000000000;;				Ret: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				A:   map[string]interface{}{"a": []interface{}{1, 2}},
0000000000000000000000000000000000000000;;				B:   map[string]interface{}{"a": []interface{}{1, 0}},
0000000000000000000000000000000000000000;;				Ret: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				A:   map[string]interface{}{"a": []interface{}{1, 2}},
0000000000000000000000000000000000000000;;				B:   map[string]interface{}{"a": []interface{}{1, 2}},
0000000000000000000000000000000000000000;;				Ret: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Numeric types are not interchangeable.
0000000000000000000000000000000000000000;;			// Callers are expected to ensure numeric types are consistent in 'left' and 'right'.
0000000000000000000000000000000000000000;;			{A: int(0), B: int64(0), Ret: true},
0000000000000000000000000000000000000000;;			{A: int(0), B: float64(0), Ret: true},
0000000000000000000000000000000000000000;;			{A: int64(0), B: float64(0), Ret: true},
0000000000000000000000000000000000000000;;			// Other types are not interchangeable.
0000000000000000000000000000000000000000;;			{A: int(0), B: "0", Ret: true},
0000000000000000000000000000000000000000;;			{A: int(0), B: nil, Ret: true},
0000000000000000000000000000000000000000;;			{A: int(0), B: false, Ret: true},
0000000000000000000000000000000000000000;;			{A: "true", B: true, Ret: true},
0000000000000000000000000000000000000000;;			{A: "null", B: nil, Ret: true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, testCase := range testCases {
0000000000000000000000000000000000000000;;			testStr := fmt.Sprintf("A = %#v, B = %#v", testCase.A, testCase.B)
0000000000000000000000000000000000000000;;			// Run each test case multiple times if it passes because HasConflicts()
0000000000000000000000000000000000000000;;			// uses map iteration, which returns keys in nondeterministic order.
0000000000000000000000000000000000000000;;			for try := 0; try < 10; try++ {
0000000000000000000000000000000000000000;;				out, err := HasConflicts(testCase.A, testCase.B)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v: unexpected error: %v", testStr, err)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if out != testCase.Ret {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected %t got %t", testStr, testCase.Ret, out)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out, err = HasConflicts(testCase.B, testCase.A)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%v: unexpected error: %v", testStr, err)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if out != testCase.Ret {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected reversed %t got %t", testStr, testCase.Ret, out)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
