0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
351764b6cae066588e87a3efee44135d8f7e8120;pkg/util/httpstream/spdy/upgrade.go[pkg/util/httpstream/spdy/upgrade.go][staging/src/k8s.io/apimachinery/pkg/util/httpstream/spdy/upgrade.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package spdy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const HeaderSpdy31 = "SPDY/3.1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// responseUpgrader knows how to upgrade HTTP responses. It
0000000000000000000000000000000000000000;;	// implements the httpstream.ResponseUpgrader interface.
0000000000000000000000000000000000000000;;	type responseUpgrader struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// connWrapper is used to wrap a hijacked connection and its bufio.Reader. All
0000000000000000000000000000000000000000;;	// calls will be handled directly by the underlying net.Conn with the exception
0000000000000000000000000000000000000000;;	// of Read and Close calls, which will consider data in the bufio.Reader. This
0000000000000000000000000000000000000000;;	// ensures that data already inside the used bufio.Reader instance is also
0000000000000000000000000000000000000000;;	// read.
0000000000000000000000000000000000000000;;	type connWrapper struct {
0000000000000000000000000000000000000000;;		net.Conn
0000000000000000000000000000000000000000;;		closed    int32
0000000000000000000000000000000000000000;;		bufReader *bufio.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *connWrapper) Read(b []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if atomic.LoadInt32(&w.closed) == 1 {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.bufReader.Read(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *connWrapper) Close() error {
0000000000000000000000000000000000000000;;		err := w.Conn.Close()
0000000000000000000000000000000000000000;;		atomic.StoreInt32(&w.closed, 1)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewResponseUpgrader returns a new httpstream.ResponseUpgrader that is
0000000000000000000000000000000000000000;;	// capable of upgrading HTTP responses using SPDY/3.1 via the
0000000000000000000000000000000000000000;;	// spdystream package.
0000000000000000000000000000000000000000;;	func NewResponseUpgrader() httpstream.ResponseUpgrader {
0000000000000000000000000000000000000000;;		return responseUpgrader{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpgradeResponse upgrades an HTTP response to one that supports multiplexed
0000000000000000000000000000000000000000;;	// streams. newStreamHandler will be called synchronously whenever the
0000000000000000000000000000000000000000;;	// other end of the upgraded connection creates a new stream.
0000000000000000000000000000000000000000;;	func (u responseUpgrader) UpgradeResponse(w http.ResponseWriter, req *http.Request, newStreamHandler httpstream.NewStreamHandler) httpstream.Connection {
0000000000000000000000000000000000000000;;		connectionHeader := strings.ToLower(req.Header.Get(httpstream.HeaderConnection))
0000000000000000000000000000000000000000;;		upgradeHeader := strings.ToLower(req.Header.Get(httpstream.HeaderUpgrade))
0000000000000000000000000000000000000000;;		if !strings.Contains(connectionHeader, strings.ToLower(httpstream.HeaderUpgrade)) || !strings.Contains(upgradeHeader, strings.ToLower(HeaderSpdy31)) {
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusBadRequest)
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "unable to upgrade: missing upgrade headers in request: %#v", req.Header)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hijacker, ok := w.(http.Hijacker)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "unable to upgrade: unable to hijack response")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Add(httpstream.HeaderConnection, httpstream.HeaderUpgrade)
0000000000000000000000000000000000000000;;		w.Header().Add(httpstream.HeaderUpgrade, HeaderSpdy31)
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusSwitchingProtocols)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, bufrw, err := hijacker.Hijack()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("unable to upgrade: error hijacking response: %v", err))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		connWithBuf := &connWrapper{Conn: conn, bufReader: bufrw.Reader}
0000000000000000000000000000000000000000;;		spdyConn, err := NewServerConnection(connWithBuf, newStreamHandler)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("unable to upgrade: error creating SPDY server connection: %v", err))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return spdyConn
0000000000000000000000000000000000000000;;	}
