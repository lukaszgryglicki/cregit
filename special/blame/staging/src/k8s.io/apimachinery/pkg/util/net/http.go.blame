0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package net
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/http2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsProbableEOF returns true if the given error resembles a connection termination
0000000000000000000000000000000000000000;;	// scenario that would justify assuming that the watch is empty.
0000000000000000000000000000000000000000;;	// These errors are what the Go http stack returns back to us which are general
0000000000000000000000000000000000000000;;	// connection closure errors (strongly correlated) and callers that need to
0000000000000000000000000000000000000000;;	// differentiate probable errors in connection behavior between normal "this is
0000000000000000000000000000000000000000;;	// disconnected" should use the method.
0000000000000000000000000000000000000000;;	func IsProbableEOF(err error) bool {
0000000000000000000000000000000000000000;;		if uerr, ok := err.(*url.Error); ok {
0000000000000000000000000000000000000000;;			err = uerr.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case err == io.EOF:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case err.Error() == "http: can't write HTTP request on broken connection":
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case strings.Contains(err.Error(), "connection reset by peer"):
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case strings.Contains(strings.ToLower(err.Error()), "use of closed network connection"):
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultTransport = http.DefaultTransport.(*http.Transport)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetOldTransportDefaults applies the defaults from http.DefaultTransport
0000000000000000000000000000000000000000;;	// for the Proxy, Dial, and TLSHandshakeTimeout fields if unset
0000000000000000000000000000000000000000;;	func SetOldTransportDefaults(t *http.Transport) *http.Transport {
0000000000000000000000000000000000000000;;		if t.Proxy == nil || isDefault(t.Proxy) {
0000000000000000000000000000000000000000;;			// http.ProxyFromEnvironment doesn't respect CIDRs and that makes it impossible to exclude things like pod and service IPs from proxy settings
0000000000000000000000000000000000000000;;			// ProxierWithNoProxyCIDR allows CIDR rules in NO_PROXY
0000000000000000000000000000000000000000;;			t.Proxy = NewProxierWithNoProxyCIDR(http.ProxyFromEnvironment)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Dial == nil {
0000000000000000000000000000000000000000;;			t.Dial = defaultTransport.Dial
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.TLSHandshakeTimeout == 0 {
0000000000000000000000000000000000000000;;			t.TLSHandshakeTimeout = defaultTransport.TLSHandshakeTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTransportDefaults applies the defaults from http.DefaultTransport
0000000000000000000000000000000000000000;;	// for the Proxy, Dial, and TLSHandshakeTimeout fields if unset
0000000000000000000000000000000000000000;;	func SetTransportDefaults(t *http.Transport) *http.Transport {
0000000000000000000000000000000000000000;;		t = SetOldTransportDefaults(t)
0000000000000000000000000000000000000000;;		// Allow clients to disable http2 if needed.
0000000000000000000000000000000000000000;;		if s := os.Getenv("DISABLE_HTTP2"); len(s) > 0 {
0000000000000000000000000000000000000000;;			glog.Infof("HTTP2 has been explicitly disabled")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if err := http2.ConfigureTransport(t); err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Transport failed http2 configuration: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RoundTripperWrapper interface {
0000000000000000000000000000000000000000;;		http.RoundTripper
0000000000000000000000000000000000000000;;		WrappedRoundTripper() http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DialFunc func(net, addr string) (net.Conn, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DialerFor(transport http.RoundTripper) (DialFunc, error) {
0000000000000000000000000000000000000000;;		if transport == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch transport := transport.(type) {
0000000000000000000000000000000000000000;;		case *http.Transport:
0000000000000000000000000000000000000000;;			return transport.Dial, nil
0000000000000000000000000000000000000000;;		case RoundTripperWrapper:
0000000000000000000000000000000000000000;;			return DialerFor(transport.WrappedRoundTripper())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown transport type: %v", transport)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TLSClientConfigHolder interface {
0000000000000000000000000000000000000000;;		TLSClientConfig() *tls.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TLSClientConfig(transport http.RoundTripper) (*tls.Config, error) {
0000000000000000000000000000000000000000;;		if transport == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch transport := transport.(type) {
0000000000000000000000000000000000000000;;		case *http.Transport:
0000000000000000000000000000000000000000;;			return transport.TLSClientConfig, nil
0000000000000000000000000000000000000000;;		case TLSClientConfigHolder:
0000000000000000000000000000000000000000;;			return transport.TLSClientConfig(), nil
0000000000000000000000000000000000000000;;		case RoundTripperWrapper:
0000000000000000000000000000000000000000;;			return TLSClientConfig(transport.WrappedRoundTripper())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown transport type: %v", transport)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FormatURL(scheme string, host string, port int, path string) *url.URL {
0000000000000000000000000000000000000000;;		return &url.URL{
0000000000000000000000000000000000000000;;			Scheme: scheme,
0000000000000000000000000000000000000000;;			Host:   net.JoinHostPort(host, strconv.Itoa(port)),
0000000000000000000000000000000000000000;;			Path:   path,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetHTTPClient(req *http.Request) string {
0000000000000000000000000000000000000000;;		if userAgent, ok := req.Header["User-Agent"]; ok {
0000000000000000000000000000000000000000;;			if len(userAgent) > 0 {
0000000000000000000000000000000000000000;;				return userAgent[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "unknown"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SourceIPs splits the comma separated X-Forwarded-For header or returns the X-Real-Ip header or req.RemoteAddr,
0000000000000000000000000000000000000000;;	// in that order, ignoring invalid IPs. It returns nil if all of these are empty or invalid.
0000000000000000000000000000000000000000;;	func SourceIPs(req *http.Request) []net.IP {
0000000000000000000000000000000000000000;;		hdr := req.Header
0000000000000000000000000000000000000000;;		// First check the X-Forwarded-For header for requests via proxy.
0000000000000000000000000000000000000000;;		hdrForwardedFor := hdr.Get("X-Forwarded-For")
0000000000000000000000000000000000000000;;		forwardedForIPs := []net.IP{}
0000000000000000000000000000000000000000;;		if hdrForwardedFor != "" {
0000000000000000000000000000000000000000;;			// X-Forwarded-For can be a csv of IPs in case of multiple proxies.
0000000000000000000000000000000000000000;;			// Use the first valid one.
0000000000000000000000000000000000000000;;			parts := strings.Split(hdrForwardedFor, ",")
0000000000000000000000000000000000000000;;			for _, part := range parts {
0000000000000000000000000000000000000000;;				ip := net.ParseIP(strings.TrimSpace(part))
0000000000000000000000000000000000000000;;				if ip != nil {
0000000000000000000000000000000000000000;;					forwardedForIPs = append(forwardedForIPs, ip)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(forwardedForIPs) > 0 {
0000000000000000000000000000000000000000;;			return forwardedForIPs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try the X-Real-Ip header.
0000000000000000000000000000000000000000;;		hdrRealIp := hdr.Get("X-Real-Ip")
0000000000000000000000000000000000000000;;		if hdrRealIp != "" {
0000000000000000000000000000000000000000;;			ip := net.ParseIP(hdrRealIp)
0000000000000000000000000000000000000000;;			if ip != nil {
0000000000000000000000000000000000000000;;				return []net.IP{ip}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fallback to Remote Address in request, which will give the correct client IP when there is no proxy.
0000000000000000000000000000000000000000;;		// Remote Address in Go's HTTP server is in the form host:port so we need to split that first.
0000000000000000000000000000000000000000;;		host, _, err := net.SplitHostPort(req.RemoteAddr)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			if remoteIP := net.ParseIP(host); remoteIP != nil {
0000000000000000000000000000000000000000;;				return []net.IP{remoteIP}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fallback if Remote Address was just IP.
0000000000000000000000000000000000000000;;		if remoteIP := net.ParseIP(req.RemoteAddr); remoteIP != nil {
0000000000000000000000000000000000000000;;			return []net.IP{remoteIP}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extracts and returns the clients IP from the given request.
0000000000000000000000000000000000000000;;	// Looks at X-Forwarded-For header, X-Real-Ip header and request.RemoteAddr in that order.
0000000000000000000000000000000000000000;;	// Returns nil if none of them are set or is set to an invalid value.
0000000000000000000000000000000000000000;;	func GetClientIP(req *http.Request) net.IP {
0000000000000000000000000000000000000000;;		ips := SourceIPs(req)
0000000000000000000000000000000000000000;;		if len(ips) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ips[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prepares the X-Forwarded-For header for another forwarding hop by appending the previous sender's
0000000000000000000000000000000000000000;;	// IP address to the X-Forwarded-For chain.
0000000000000000000000000000000000000000;;	func AppendForwardedForHeader(req *http.Request) {
0000000000000000000000000000000000000000;;		// Copied from net/http/httputil/reverseproxy.go:
0000000000000000000000000000000000000000;;		if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {
0000000000000000000000000000000000000000;;			// If we aren't the first proxy retain prior
0000000000000000000000000000000000000000;;			// X-Forwarded-For information as a comma+space
0000000000000000000000000000000000000000;;			// separated list and fold multiple headers into one.
0000000000000000000000000000000000000000;;			if prior, ok := req.Header["X-Forwarded-For"]; ok {
0000000000000000000000000000000000000000;;				clientIP = strings.Join(prior, ", ") + ", " + clientIP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			req.Header.Set("X-Forwarded-For", clientIP)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultProxyFuncPointer = fmt.Sprintf("%p", http.ProxyFromEnvironment)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isDefault checks to see if the transportProxierFunc is pointing to the default one
0000000000000000000000000000000000000000;;	func isDefault(transportProxier func(*http.Request) (*url.URL, error)) bool {
0000000000000000000000000000000000000000;;		transportProxierPointer := fmt.Sprintf("%p", transportProxier)
0000000000000000000000000000000000000000;;		return transportProxierPointer == defaultProxyFuncPointer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProxierWithNoProxyCIDR constructs a Proxier function that respects CIDRs in NO_PROXY and delegates if
0000000000000000000000000000000000000000;;	// no matching CIDRs are found
0000000000000000000000000000000000000000;;	func NewProxierWithNoProxyCIDR(delegate func(req *http.Request) (*url.URL, error)) func(req *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;		// we wrap the default method, so we only need to perform our check if the NO_PROXY envvar has a CIDR in it
0000000000000000000000000000000000000000;;		noProxyEnv := os.Getenv("NO_PROXY")
0000000000000000000000000000000000000000;;		noProxyRules := strings.Split(noProxyEnv, ",")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cidrs := []*net.IPNet{}
0000000000000000000000000000000000000000;;		for _, noProxyRule := range noProxyRules {
0000000000000000000000000000000000000000;;			_, cidr, _ := net.ParseCIDR(noProxyRule)
0000000000000000000000000000000000000000;;			if cidr != nil {
0000000000000000000000000000000000000000;;				cidrs = append(cidrs, cidr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cidrs) == 0 {
0000000000000000000000000000000000000000;;			return delegate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func(req *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;			host := req.URL.Host
0000000000000000000000000000000000000000;;			// for some urls, the Host is already the host, not the host:port
0000000000000000000000000000000000000000;;			if net.ParseIP(host) == nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				host, _, err = net.SplitHostPort(req.URL.Host)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return delegate(req)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ip := net.ParseIP(host)
0000000000000000000000000000000000000000;;			if ip == nil {
0000000000000000000000000000000000000000;;				return delegate(req)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, cidr := range cidrs {
0000000000000000000000000000000000000000;;				if cidr.Contains(ip) {
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return delegate(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dialer dials a host and writes a request to it.
0000000000000000000000000000000000000000;;	type Dialer interface {
0000000000000000000000000000000000000000;;		// Dial connects to the host specified by req's URL, writes the request to the connection, and
0000000000000000000000000000000000000000;;		// returns the opened net.Conn.
0000000000000000000000000000000000000000;;		Dial(req *http.Request) (net.Conn, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectWithRedirects uses dialer to send req, following up to 10 redirects (relative to
0000000000000000000000000000000000000000;;	// originalLocation). It returns the opened net.Conn and the raw response bytes.
0000000000000000000000000000000000000000;;	func ConnectWithRedirects(originalMethod string, originalLocation *url.URL, header http.Header, originalBody io.Reader, dialer Dialer) (net.Conn, []byte, error) {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			maxRedirects    = 10
0000000000000000000000000000000000000000;;			maxResponseSize = 16384 // play it safe to allow the potential for lots of / large headers
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			location         = originalLocation
0000000000000000000000000000000000000000;;			method           = originalMethod
0000000000000000000000000000000000000000;;			intermediateConn net.Conn
0000000000000000000000000000000000000000;;			rawResponse      = bytes.NewBuffer(make([]byte, 0, 256))
0000000000000000000000000000000000000000;;			body             = originalBody
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if intermediateConn != nil {
0000000000000000000000000000000000000000;;				intermediateConn.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	redirectLoop:
0000000000000000000000000000000000000000;;		for redirects := 0; ; redirects++ {
0000000000000000000000000000000000000000;;			if redirects > maxRedirects {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("too many redirects (%d)", redirects)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			req, err := http.NewRequest(method, location.String(), body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			req.Header = header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			intermediateConn, err = dialer.Dial(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Peek at the backend response.
0000000000000000000000000000000000000000;;			rawResponse.Reset()
0000000000000000000000000000000000000000;;			respReader := bufio.NewReader(io.TeeReader(
0000000000000000000000000000000000000000;;				io.LimitReader(intermediateConn, maxResponseSize), // Don't read more than maxResponseSize bytes.
0000000000000000000000000000000000000000;;				rawResponse)) // Save the raw response.
0000000000000000000000000000000000000000;;			resp, err := http.ReadResponse(respReader, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Unable to read the backend response; let the client handle it.
0000000000000000000000000000000000000000;;				glog.Warningf("Error reading backend response: %v", err)
0000000000000000000000000000000000000000;;				break redirectLoop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch resp.StatusCode {
0000000000000000000000000000000000000000;;			case http.StatusFound:
0000000000000000000000000000000000000000;;				// Redirect, continue.
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// Don't redirect.
0000000000000000000000000000000000000000;;				break redirectLoop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Redirected requests switch to "GET" according to the HTTP spec:
0000000000000000000000000000000000000000;;			// https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3
0000000000000000000000000000000000000000;;			method = "GET"
0000000000000000000000000000000000000000;;			// don't send a body when following redirects
0000000000000000000000000000000000000000;;			body = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp.Body.Close() // not used
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Reset the connection.
0000000000000000000000000000000000000000;;			intermediateConn.Close()
0000000000000000000000000000000000000000;;			intermediateConn = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Prepare to follow the redirect.
0000000000000000000000000000000000000000;;			redirectStr := resp.Header.Get("Location")
0000000000000000000000000000000000000000;;			if redirectStr == "" {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("%d response missing Location header", resp.StatusCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We have to parse relative to the current location, NOT originalLocation. For example,
0000000000000000000000000000000000000000;;			// if we request http://foo.com/a and get back "http://bar.com/b", the result should be
0000000000000000000000000000000000000000;;			// http://bar.com/b. If we then make that request and get back a redirect to "/c", the result
0000000000000000000000000000000000000000;;			// should be http://bar.com/c, not http://foo.com/c.
0000000000000000000000000000000000000000;;			location, err = location.Parse(redirectStr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, fmt.Errorf("malformed Location header: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		connToReturn := intermediateConn
0000000000000000000000000000000000000000;;		intermediateConn = nil // Don't close the connection when we return it.
0000000000000000000000000000000000000000;;		return connToReturn, rawResponse.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloneRequest creates a shallow copy of the request along with a deep copy of the Headers.
0000000000000000000000000000000000000000;;	func CloneRequest(req *http.Request) *http.Request {
0000000000000000000000000000000000000000;;		r := new(http.Request)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// shallow clone
0000000000000000000000000000000000000000;;		*r = *req
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// deep copy headers
0000000000000000000000000000000000000000;;		r.Header = CloneHeader(req.Header)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloneHeader creates a deep copy of an http.Header.
0000000000000000000000000000000000000000;;	func CloneHeader(in http.Header) http.Header {
0000000000000000000000000000000000000000;;		out := make(http.Header, len(in))
0000000000000000000000000000000000000000;;		for key, values := range in {
0000000000000000000000000000000000000000;;			newValues := make([]string, len(values))
0000000000000000000000000000000000000000;;			copy(newValues, values)
0000000000000000000000000000000000000000;;			out[key] = newValues
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
