0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
351764b6cae066588e87a3efee44135d8f7e8120;pkg/util/httpstream/spdy/roundtripper_test.go[pkg/util/httpstream/spdy/roundtripper_test.go][staging/src/k8s.io/apimachinery/pkg/util/httpstream/spdy/roundtripper_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package spdy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/httptest"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/elazarl/goproxy"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// be sure to unset environment variable https_proxy (if exported) before testing, otherwise the testing will fail unexpectedly.
0000000000000000000000000000000000000000;;	func TestRoundTripAndNewConnection(t *testing.T) {
0000000000000000000000000000000000000000;;		for _, redirect := range []bool{false, true} {
0000000000000000000000000000000000000000;;			t.Run(fmt.Sprintf("redirect = %t", redirect), func(t *testing.T) {
0000000000000000000000000000000000000000;;				localhostPool := x509.NewCertPool()
0000000000000000000000000000000000000000;;				if !localhostPool.AppendCertsFromPEM(localhostCert) {
0000000000000000000000000000000000000000;;					t.Errorf("error setting up localhostCert pool")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				httpsServerInvalidHostname := func(h http.Handler) *httptest.Server {
0000000000000000000000000000000000000000;;					cert, err := tls.X509KeyPair(exampleCert, exampleKey)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("https (invalid hostname): proxy_test: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts := httptest.NewUnstartedServer(h)
0000000000000000000000000000000000000000;;					ts.TLS = &tls.Config{
0000000000000000000000000000000000000000;;						Certificates: []tls.Certificate{cert},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts.StartTLS()
0000000000000000000000000000000000000000;;					return ts
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				httpsServerValidHostname := func(h http.Handler) *httptest.Server {
0000000000000000000000000000000000000000;;					cert, err := tls.X509KeyPair(localhostCert, localhostKey)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Errorf("https (valid hostname): proxy_test: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts := httptest.NewUnstartedServer(h)
0000000000000000000000000000000000000000;;					ts.TLS = &tls.Config{
0000000000000000000000000000000000000000;;						Certificates: []tls.Certificate{cert},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ts.StartTLS()
0000000000000000000000000000000000000000;;					return ts
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				testCases := map[string]struct {
0000000000000000000000000000000000000000;;					serverFunc             func(http.Handler) *httptest.Server
0000000000000000000000000000000000000000;;					proxyServerFunc        func(http.Handler) *httptest.Server
0000000000000000000000000000000000000000;;					proxyAuth              *url.Userinfo
0000000000000000000000000000000000000000;;					clientTLS              *tls.Config
0000000000000000000000000000000000000000;;					serverConnectionHeader string
0000000000000000000000000000000000000000;;					serverUpgradeHeader    string
0000000000000000000000000000000000000000;;					serverStatusCode       int
0000000000000000000000000000000000000000;;					shouldError            bool
0000000000000000000000000000000000000000;;				}{
0000000000000000000000000000000000000000;;					"no headers": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						serverConnectionHeader: "",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"no upgrade header": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"no connection header": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						serverConnectionHeader: "",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"no switching protocol status code": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusForbidden,
0000000000000000000000000000000000000000;;						shouldError:            true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"http": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"https (invalid hostname + InsecureSkipVerify)": {
0000000000000000000000000000000000000000;;						serverFunc:             httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{InsecureSkipVerify: true},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"https (invalid hostname + hostname verification)": {
0000000000000000000000000000000000000000;;						serverFunc:             httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{InsecureSkipVerify: false},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"https (valid hostname + RootCAs)": {
0000000000000000000000000000000000000000;;						serverFunc:             httpsServerValidHostname,
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{RootCAs: localhostPool},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied http->http": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httptest.NewServer,
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied https (invalid hostname + InsecureSkipVerify) -> http": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{InsecureSkipVerify: true},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied https with auth (invalid hostname + InsecureSkipVerify) -> http": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						proxyAuth:              url.UserPassword("proxyuser", "proxypasswd"),
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{InsecureSkipVerify: true},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied https (invalid hostname + hostname verification) -> http": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{InsecureSkipVerify: false},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            true, // fails because the client doesn't trust the proxy
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied https (valid hostname + RootCAs) -> http": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httpsServerValidHostname,
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{RootCAs: localhostPool},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied https with auth (valid hostname + RootCAs) -> http": {
0000000000000000000000000000000000000000;;						serverFunc:             httptest.NewServer,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httpsServerValidHostname,
0000000000000000000000000000000000000000;;						proxyAuth:              url.UserPassword("proxyuser", "proxypasswd"),
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{RootCAs: localhostPool},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied https (invalid hostname + InsecureSkipVerify) -> https (invalid hostname)": {
0000000000000000000000000000000000000000;;						serverFunc:             httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{InsecureSkipVerify: true},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false, // works because the test proxy ignores TLS errors
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied https with auth (invalid hostname + InsecureSkipVerify) -> https (invalid hostname)": {
0000000000000000000000000000000000000000;;						serverFunc:             httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						proxyAuth:              url.UserPassword("proxyuser", "proxypasswd"),
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{InsecureSkipVerify: true},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false, // works because the test proxy ignores TLS errors
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied https (invalid hostname + hostname verification) -> https (invalid hostname)": {
0000000000000000000000000000000000000000;;						serverFunc:             httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httpsServerInvalidHostname,
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{InsecureSkipVerify: false},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            true, // fails because the client doesn't trust the proxy
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied https (valid hostname + RootCAs) -> https (valid hostname + RootCAs)": {
0000000000000000000000000000000000000000;;						serverFunc:             httpsServerValidHostname,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httpsServerValidHostname,
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{RootCAs: localhostPool},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					"proxied https with auth (valid hostname + RootCAs) -> https (valid hostname + RootCAs)": {
0000000000000000000000000000000000000000;;						serverFunc:             httpsServerValidHostname,
0000000000000000000000000000000000000000;;						proxyServerFunc:        httpsServerValidHostname,
0000000000000000000000000000000000000000;;						proxyAuth:              url.UserPassword("proxyuser", "proxypasswd"),
0000000000000000000000000000000000000000;;						clientTLS:              &tls.Config{RootCAs: localhostPool},
0000000000000000000000000000000000000000;;						serverConnectionHeader: "Upgrade",
0000000000000000000000000000000000000000;;						serverUpgradeHeader:    "SPDY/3.1",
0000000000000000000000000000000000000000;;						serverStatusCode:       http.StatusSwitchingProtocols,
0000000000000000000000000000000000000000;;						shouldError:            false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for k, testCase := range testCases {
0000000000000000000000000000000000000000;;					server := testCase.serverFunc(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;						if testCase.shouldError {
0000000000000000000000000000000000000000;;							if e, a := httpstream.HeaderUpgrade, req.Header.Get(httpstream.HeaderConnection); e != a {
0000000000000000000000000000000000000000;;								t.Fatalf("%s: Expected connection=upgrade header, got '%s", k, a)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							w.Header().Set(httpstream.HeaderConnection, testCase.serverConnectionHeader)
0000000000000000000000000000000000000000;;							w.Header().Set(httpstream.HeaderUpgrade, testCase.serverUpgradeHeader)
0000000000000000000000000000000000000000;;							w.WriteHeader(testCase.serverStatusCode)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						streamCh := make(chan httpstream.Stream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						responseUpgrader := NewResponseUpgrader()
0000000000000000000000000000000000000000;;						spdyConn := responseUpgrader.UpgradeResponse(w, req, func(s httpstream.Stream, replySent <-chan struct{}) error {
0000000000000000000000000000000000000000;;							streamCh <- s
0000000000000000000000000000000000000000;;							return nil
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;						if spdyConn == nil {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: unexpected nil spdyConn", k)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						defer spdyConn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						stream := <-streamCh
0000000000000000000000000000000000000000;;						io.Copy(stream, stream)
0000000000000000000000000000000000000000;;					}))
0000000000000000000000000000000000000000;;					defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					serverURL, err := url.Parse(server.URL)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: Error creating request: %s", k, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					req, err := http.NewRequest("GET", server.URL, nil)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: Error creating request: %s", k, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					spdyTransport := NewSpdyRoundTripper(testCase.clientTLS, redirect)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var proxierCalled bool
0000000000000000000000000000000000000000;;					var proxyCalledWithHost string
0000000000000000000000000000000000000000;;					var proxyCalledWithAuth bool
0000000000000000000000000000000000000000;;					var proxyCalledWithAuthHeader string
0000000000000000000000000000000000000000;;					if testCase.proxyServerFunc != nil {
0000000000000000000000000000000000000000;;						proxyHandler := goproxy.NewProxyHttpServer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						proxyHandler.OnRequest().HandleConnectFunc(func(host string, ctx *goproxy.ProxyCtx) (*goproxy.ConnectAction, string) {
0000000000000000000000000000000000000000;;							proxyCalledWithHost = host
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							proxyAuthHeaderName := "Proxy-Authorization"
0000000000000000000000000000000000000000;;							_, proxyCalledWithAuth = ctx.Req.Header[proxyAuthHeaderName]
0000000000000000000000000000000000000000;;							proxyCalledWithAuthHeader = ctx.Req.Header.Get(proxyAuthHeaderName)
0000000000000000000000000000000000000000;;							return goproxy.OkConnect, host
0000000000000000000000000000000000000000;;						})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						proxy := testCase.proxyServerFunc(proxyHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						spdyTransport.proxier = func(proxierReq *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;							proxierCalled = true
0000000000000000000000000000000000000000;;							proxyURL, err := url.Parse(proxy.URL)
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								return nil, err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							proxyURL.User = testCase.proxyAuth
0000000000000000000000000000000000000000;;							return proxyURL, nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						defer proxy.Close()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					client := &http.Client{Transport: spdyTransport}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					resp, err := client.Do(req)
0000000000000000000000000000000000000000;;					var conn httpstream.Connection
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						conn, err = spdyTransport.NewConnection(resp)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					haveErr := err != nil
0000000000000000000000000000000000000000;;					if e, a := testCase.shouldError, haveErr; e != a {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: shouldError=%t, got %t: %v", k, e, a, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if testCase.shouldError {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					defer conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if resp.StatusCode != http.StatusSwitchingProtocols {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: expected http 101 switching protocols, got %d", k, resp.StatusCode)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					stream, err := conn.CreateStream(http.Header{})
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: error creating client stream: %s", k, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					n, err := stream.Write([]byte("hello"))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: error writing to stream: %s", k, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if n != 5 {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: Expected to write 5 bytes, but actually wrote %d", k, n)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					b := make([]byte, 5)
0000000000000000000000000000000000000000;;					n, err = stream.Read(b)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: error reading from stream: %s", k, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if n != 5 {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: Expected to read 5 bytes, but actually read %d", k, n)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if e, a := "hello", string(b[0:n]); e != a {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: expected '%s', got '%s'", k, e, a)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if testCase.proxyServerFunc != nil {
0000000000000000000000000000000000000000;;						if !proxierCalled {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: Expected to use a proxy but proxier in SpdyRoundTripper wasn't called", k)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if proxyCalledWithHost != serverURL.Host {
0000000000000000000000000000000000000000;;							t.Fatalf("%s: Expected to see a call to the proxy for backend %q, got %q", k, serverURL.Host, proxyCalledWithHost)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var expectedProxyAuth string
0000000000000000000000000000000000000000;;					if testCase.proxyAuth != nil {
0000000000000000000000000000000000000000;;						encodedCredentials := base64.StdEncoding.EncodeToString([]byte(testCase.proxyAuth.String()))
0000000000000000000000000000000000000000;;						expectedProxyAuth = "Basic " + encodedCredentials
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(expectedProxyAuth) == 0 && proxyCalledWithAuth {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: Proxy authorization unexpected, got %q", k, proxyCalledWithAuthHeader)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if proxyCalledWithAuthHeader != expectedProxyAuth {
0000000000000000000000000000000000000000;;						t.Fatalf("%s: Expected to see a call to the proxy with credentials %q, got %q", k, testCase.proxyAuth, proxyCalledWithAuthHeader)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRoundTripRedirects(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			redirects     int32
0000000000000000000000000000000000000000;;			expectSuccess bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{0, true},
0000000000000000000000000000000000000000;;			{1, true},
0000000000000000000000000000000000000000;;			{10, true},
0000000000000000000000000000000000000000;;			{11, false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Run(fmt.Sprintf("with %d redirects", test.redirects), func(t *testing.T) {
0000000000000000000000000000000000000000;;				var redirects int32 = 0
0000000000000000000000000000000000000000;;				server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;					if redirects < test.redirects {
0000000000000000000000000000000000000000;;						redirects = atomic.AddInt32(&redirects, 1)
0000000000000000000000000000000000000000;;						http.Redirect(w, req, "redirect", http.StatusFound)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					streamCh := make(chan httpstream.Stream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					responseUpgrader := NewResponseUpgrader()
0000000000000000000000000000000000000000;;					spdyConn := responseUpgrader.UpgradeResponse(w, req, func(s httpstream.Stream, replySent <-chan struct{}) error {
0000000000000000000000000000000000000000;;						streamCh <- s
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					})
0000000000000000000000000000000000000000;;					if spdyConn == nil {
0000000000000000000000000000000000000000;;						t.Fatalf("unexpected nil spdyConn")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					defer spdyConn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					stream := <-streamCh
0000000000000000000000000000000000000000;;					io.Copy(stream, stream)
0000000000000000000000000000000000000000;;				}))
0000000000000000000000000000000000000000;;				defer server.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				req, err := http.NewRequest("GET", server.URL, nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("Error creating request: %s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				spdyTransport := NewSpdyRoundTripper(nil, true)
0000000000000000000000000000000000000000;;				client := &http.Client{Transport: spdyTransport}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				resp, err := client.Do(req)
0000000000000000000000000000000000000000;;				if test.expectSuccess {
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						t.Fatalf("error calling Do: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						t.Fatalf("expecting an error")
0000000000000000000000000000000000000000;;					} else if !strings.Contains(err.Error(), "too many redirects") {
0000000000000000000000000000000000000000;;						t.Fatalf("expecting too many redirects, got %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				conn, err := spdyTransport.NewConnection(resp)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("error calling NewConnection: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if resp.StatusCode != http.StatusSwitchingProtocols {
0000000000000000000000000000000000000000;;					t.Fatalf("expected http 101 switching protocols, got %d", resp.StatusCode)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				stream, err := conn.CreateStream(http.Header{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("error creating client stream: %s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				n, err := stream.Write([]byte("hello"))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("error writing to stream: %s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if n != 5 {
0000000000000000000000000000000000000000;;					t.Fatalf("Expected to write 5 bytes, but actually wrote %d", n)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				b := make([]byte, 5)
0000000000000000000000000000000000000000;;				n, err = stream.Read(b)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Fatalf("error reading from stream: %s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if n != 5 {
0000000000000000000000000000000000000000;;					t.Fatalf("Expected to read 5 bytes, but actually read %d", n)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := "hello", string(b[0:n]); e != a {
0000000000000000000000000000000000000000;;					t.Fatalf("expected '%s', got '%s'", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// exampleCert was generated from crypto/tls/generate_cert.go with the following command:
0000000000000000000000000000000000000000;;	//    go run generate_cert.go  --rsa-bits 512 --host example.com --ca --start-date "Jan 1 00:00:00 1970" --duration=1000000h
0000000000000000000000000000000000000000;;	var exampleCert = []byte(`-----BEGIN CERTIFICATE-----
0000000000000000000000000000000000000000;;	MIIBdzCCASGgAwIBAgIRAOVTAdPnfbS5V85mfS90TfIwDQYJKoZIhvcNAQELBQAw
0000000000000000000000000000000000000000;;	EjEQMA4GA1UEChMHQWNtZSBDbzAgFw03MDAxMDEwMDAwMDBaGA8yMDg0MDEyOTE2
0000000000000000000000000000000000000000;;	MDAwMFowEjEQMA4GA1UEChMHQWNtZSBDbzBcMA0GCSqGSIb3DQEBAQUAA0sAMEgC
0000000000000000000000000000000000000000;;	QQCoVSqeu8TBvF+70T7Jm4340YQNhds6IxjRoifenYodAO1dnKGrcbF266DJGunh
0000000000000000000000000000000000000000;;	nIjQH7B12tduhl0fLK4Ezf7/AgMBAAGjUDBOMA4GA1UdDwEB/wQEAwICpDATBgNV
0000000000000000000000000000000000000000;;	HSUEDDAKBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MBYGA1UdEQQPMA2CC2V4
0000000000000000000000000000000000000000;;	YW1wbGUuY29tMA0GCSqGSIb3DQEBCwUAA0EAk1kVa5uZ/AzwYDVcS9bpM/czwjjV
0000000000000000000000000000000000000000;;	xq3VeSCfmNa2uNjbFvodmCRwZOHUvipAMGCUCV6j5vMrJ8eMj8tCQ36W9A==
0000000000000000000000000000000000000000;;	-----END CERTIFICATE-----`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var exampleKey = []byte(`-----BEGIN RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIBOgIBAAJBAKhVKp67xMG8X7vRPsmbjfjRhA2F2zojGNGiJ96dih0A7V2coatx
0000000000000000000000000000000000000000;;	sXbroMka6eGciNAfsHXa126GXR8srgTN/v8CAwEAAQJASdzdD7vKsUwMIejGCUb1
0000000000000000000000000000000000000000;;	fAnLTPfAY3lFCa+CmR89nE22dAoRDv+5RbnBsZ58BazPNJHrsVPRlfXB3OQmSQr0
0000000000000000000000000000000000000000;;	SQIhANoJhs+xOJE/i8nJv0uAbzKyiD1YkvRkta0GpUOULyAVAiEAxaQus3E/SuqD
0000000000000000000000000000000000000000;;	P7y5NeJnE7X6XkyC35zrsJRkz7orE8MCIHdDjsI8pjyNDeGqwUCDWE/a6DrmIDwe
0000000000000000000000000000000000000000;;	emHSqMN2YvChAiEAnxLCM9NWaenOsaIoP+J1rDuvw+4499nJKVqGuVrSCRkCIEqK
0000000000000000000000000000000000000000;;	4KSchPMc3x8M/uhw9oWTtKFmjA/PPh0FsWCdKrEy
0000000000000000000000000000000000000000;;	-----END RSA PRIVATE KEY-----`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// localhostCert was generated from crypto/tls/generate_cert.go with the following command:
0000000000000000000000000000000000000000;;	//     go run generate_cert.go  --rsa-bits 512 --host 127.0.0.1,::1,example.com --ca --start-date "Jan 1 00:00:00 1970" --duration=1000000h
0000000000000000000000000000000000000000;;	var localhostCert = []byte(`-----BEGIN CERTIFICATE-----
0000000000000000000000000000000000000000;;	MIIBjzCCATmgAwIBAgIRAKpi2WmTcFrVjxrl5n5YDUEwDQYJKoZIhvcNAQELBQAw
0000000000000000000000000000000000000000;;	EjEQMA4GA1UEChMHQWNtZSBDbzAgFw03MDAxMDEwMDAwMDBaGA8yMDg0MDEyOTE2
0000000000000000000000000000000000000000;;	MDAwMFowEjEQMA4GA1UEChMHQWNtZSBDbzBcMA0GCSqGSIb3DQEBAQUAA0sAMEgC
0000000000000000000000000000000000000000;;	QQC9fEbRszP3t14Gr4oahV7zFObBI4TfA5i7YnlMXeLinb7MnvT4bkfOJzE6zktn
0000000000000000000000000000000000000000;;	59zP7UiHs3l4YOuqrjiwM413AgMBAAGjaDBmMA4GA1UdDwEB/wQEAwICpDATBgNV
0000000000000000000000000000000000000000;;	HSUEDDAKBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MC4GA1UdEQQnMCWCC2V4
0000000000000000000000000000000000000000;;	YW1wbGUuY29thwR/AAABhxAAAAAAAAAAAAAAAAAAAAABMA0GCSqGSIb3DQEBCwUA
0000000000000000000000000000000000000000;;	A0EAUsVE6KMnza/ZbodLlyeMzdo7EM/5nb5ywyOxgIOCf0OOLHsPS9ueGLQX9HEG
0000000000000000000000000000000000000000;;	//yjTXuhNcUugExIjM/AIwAZPQ==
0000000000000000000000000000000000000000;;	-----END CERTIFICATE-----`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// localhostKey is the private key for localhostCert.
0000000000000000000000000000000000000000;;	var localhostKey = []byte(`-----BEGIN RSA PRIVATE KEY-----
0000000000000000000000000000000000000000;;	MIIBOwIBAAJBAL18RtGzM/e3XgavihqFXvMU5sEjhN8DmLtieUxd4uKdvsye9Phu
0000000000000000000000000000000000000000;;	R84nMTrOS2fn3M/tSIezeXhg66quOLAzjXcCAwEAAQJBAKcRxH9wuglYLBdI/0OT
0000000000000000000000000000000000000000;;	BLzfWPZCEw1vZmMR2FF1Fm8nkNOVDPleeVGTWoOEcYYlQbpTmkGSxJ6ya+hqRi6x
0000000000000000000000000000000000000000;;	goECIQDx3+X49fwpL6B5qpJIJMyZBSCuMhH4B7JevhGGFENi3wIhAMiNJN5Q3UkL
0000000000000000000000000000000000000000;;	IuSvv03kaPR5XVQ99/UeEetUgGvBcABpAiBJSBzVITIVCGkGc7d+RCf49KTCIklv
0000000000000000000000000000000000000000;;	bGWObufAR8Ni4QIgWpILjW8dkGg8GOUZ0zaNA6Nvt6TIv2UWGJ4v5PoV98kCIQDx
0000000000000000000000000000000000000000;;	rIiZs5QbKdycsv9gQJzwQAogC8o04X3Zz3dsoX+h4A==
0000000000000000000000000000000000000000;;	-----END RSA PRIVATE KEY-----`)
