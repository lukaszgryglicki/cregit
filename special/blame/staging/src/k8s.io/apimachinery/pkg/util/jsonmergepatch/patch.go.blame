0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
f3f50958583d1c16dfaefa511b8ad3c6824d9a74;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package jsonmergepatch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/evanphx/json-patch"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/mergepatch"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a 3-way merge patch based-on JSON merge patch.
0000000000000000000000000000000000000000;;	// Calculate addition-and-change patch between current and modified.
0000000000000000000000000000000000000000;;	// Calculate deletion patch between original and modified.
0000000000000000000000000000000000000000;;	func CreateThreeWayJSONMergePatch(original, modified, current []byte, fns ...mergepatch.PreconditionFunc) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(original) == 0 {
0000000000000000000000000000000000000000;;			original = []byte(`{}`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(modified) == 0 {
0000000000000000000000000000000000000000;;			modified = []byte(`{}`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(current) == 0 {
0000000000000000000000000000000000000000;;			current = []byte(`{}`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addAndChangePatch, err := jsonpatch.CreateMergePatch(current, modified)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Only keep addition and changes
0000000000000000000000000000000000000000;;		addAndChangePatch, addAndChangePatchObj, err := keepOrDeleteNullInJsonPatch(addAndChangePatch, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deletePatch, err := jsonpatch.CreateMergePatch(original, modified)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Only keep deletion
0000000000000000000000000000000000000000;;		deletePatch, deletePatchObj, err := keepOrDeleteNullInJsonPatch(deletePatch, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasConflicts, err := mergepatch.HasConflicts(addAndChangePatchObj, deletePatchObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasConflicts {
0000000000000000000000000000000000000000;;			return nil, mergepatch.NewErrConflict(mergepatch.ToYAMLOrError(addAndChangePatchObj), mergepatch.ToYAMLOrError(deletePatchObj))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patch, err := jsonpatch.MergePatch(deletePatch, addAndChangePatch)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var patchMap map[string]interface{}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(patch, &patchMap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Failed to unmarshal patch for precondition check: %s", patch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		meetPreconditions, err := meetPreconditions(patchMap, fns...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !meetPreconditions {
0000000000000000000000000000000000000000;;			return nil, mergepatch.NewErrPreconditionFailed(patchMap)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return patch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keepOrDeleteNullInJsonPatch takes a json-encoded byte array and a boolean.
0000000000000000000000000000000000000000;;	// It returns a filtered object and its corresponding json-encoded byte array.
0000000000000000000000000000000000000000;;	// It is a wrapper of func keepOrDeleteNullInObj
0000000000000000000000000000000000000000;;	func keepOrDeleteNullInJsonPatch(patch []byte, keepNull bool) ([]byte, map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		var patchMap map[string]interface{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(patch, &patchMap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		filteredMap, err := keepOrDeleteNullInObj(patchMap, keepNull)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o, err := json.Marshal(filteredMap)
0000000000000000000000000000000000000000;;		return o, filteredMap, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keepOrDeleteNullInObj will keep only the null value and delete all the others,
0000000000000000000000000000000000000000;;	// if keepNull is true. Otherwise, it will delete all the null value and keep the others.
0000000000000000000000000000000000000000;;	func keepOrDeleteNullInObj(m map[string]interface{}, keepNull bool) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		filteredMap := make(map[string]interface{})
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for key, val := range m {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case keepNull && val == nil:
0000000000000000000000000000000000000000;;				filteredMap[key] = nil
0000000000000000000000000000000000000000;;			case val != nil:
0000000000000000000000000000000000000000;;				switch typedVal := val.(type) {
0000000000000000000000000000000000000000;;				case map[string]interface{}:
0000000000000000000000000000000000000000;;					filteredMap[key], err = keepOrDeleteNullInObj(typedVal, keepNull)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case []interface{}, string, float64, bool, int, int64, nil:
0000000000000000000000000000000000000000;;					// Lists are always replaced in Json, no need to check each entry in the list.
0000000000000000000000000000000000000000;;					if !keepNull {
0000000000000000000000000000000000000000;;						filteredMap[key] = val
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("unknown type: %v", reflect.TypeOf(typedVal))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filteredMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func meetPreconditions(patchObj map[string]interface{}, fns ...mergepatch.PreconditionFunc) (bool, error) {
0000000000000000000000000000000000000000;;		// Apply the preconditions to the patch, and return an error if any of them fail.
0000000000000000000000000000000000000000;;		for _, fn := range fns {
0000000000000000000000000000000000000000;;			if !fn(patchObj) {
0000000000000000000000000000000000000000;;				return false, fmt.Errorf("precondition failed for: %v", patchObj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
