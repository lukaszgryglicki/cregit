0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package runtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/ast"
0000000000000000000000000000000000000000;;		"go/doc"
0000000000000000000000000000000000000000;;		"go/parser"
0000000000000000000000000000000000000000;;		"go/token"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pair of strings. We keed the name of fields and the doc
0000000000000000000000000000000000000000;;	type Pair struct {
0000000000000000000000000000000000000000;;		Name, Doc string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KubeTypes is an array to represent all available types in a parsed file. [0] is for the type itself
0000000000000000000000000000000000000000;;	type KubeTypes []Pair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func astFrom(filePath string) *doc.Package {
0000000000000000000000000000000000000000;;		fset := token.NewFileSet()
0000000000000000000000000000000000000000;;		m := make(map[string]*ast.File)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Println(err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m[filePath] = f
0000000000000000000000000000000000000000;;		apkg, _ := ast.NewPackage(fset, m, nil, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return doc.New(apkg, "", 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fmtRawDoc(rawDoc string) string {
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		delPrevChar := func() {
0000000000000000000000000000000000000000;;			if buffer.Len() > 0 {
0000000000000000000000000000000000000000;;				buffer.Truncate(buffer.Len() - 1) // Delete the last " " or "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore all lines after ---
0000000000000000000000000000000000000000;;		rawDoc = strings.Split(rawDoc, "---")[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, line := range strings.Split(rawDoc, "\n") {
0000000000000000000000000000000000000000;;			line = strings.TrimRight(line, " ")
0000000000000000000000000000000000000000;;			leading := strings.TrimLeft(line, " ")
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case len(line) == 0: // Keep paragraphs
0000000000000000000000000000000000000000;;				delPrevChar()
0000000000000000000000000000000000000000;;				buffer.WriteString("\n\n")
0000000000000000000000000000000000000000;;			case strings.HasPrefix(leading, "TODO"): // Ignore one line TODOs
0000000000000000000000000000000000000000;;			case strings.HasPrefix(leading, "+"): // Ignore instructions to go2idl
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if strings.HasPrefix(line, " ") || strings.HasPrefix(line, "\t") {
0000000000000000000000000000000000000000;;					delPrevChar()
0000000000000000000000000000000000000000;;					line = "\n" + line + "\n" // Replace it with newline. This is useful when we have a line with: "Example:\n\tJSON-someting..."
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					line += " "
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buffer.WriteString(line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		postDoc := strings.TrimRight(buffer.String(), "\n")
0000000000000000000000000000000000000000;;		postDoc = strings.Replace(postDoc, "\\\"", "\"", -1) // replace user's \" to "
0000000000000000000000000000000000000000;;		postDoc = strings.Replace(postDoc, "\"", "\\\"", -1) // Escape "
0000000000000000000000000000000000000000;;		postDoc = strings.Replace(postDoc, "\n", "\\n", -1)
0000000000000000000000000000000000000000;;		postDoc = strings.Replace(postDoc, "\t", "\\t", -1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return postDoc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fieldName returns the name of the field as it should appear in JSON format
0000000000000000000000000000000000000000;;	// "-" indicates that this field is not part of the JSON representation
0000000000000000000000000000000000000000;;	func fieldName(field *ast.Field) string {
0000000000000000000000000000000000000000;;		jsonTag := ""
0000000000000000000000000000000000000000;;		if field.Tag != nil {
0000000000000000000000000000000000000000;;			jsonTag = reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1]).Get("json") // Delete first and last quotation
0000000000000000000000000000000000000000;;			if strings.Contains(jsonTag, "inline") {
0000000000000000000000000000000000000000;;				return "-"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonTag = strings.Split(jsonTag, ",")[0] // This can return "-"
0000000000000000000000000000000000000000;;		if jsonTag == "" {
0000000000000000000000000000000000000000;;			if field.Names != nil {
0000000000000000000000000000000000000000;;				return field.Names[0].Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return field.Type.(*ast.Ident).Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return jsonTag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A buffer of lines that will be written.
0000000000000000000000000000000000000000;;	type bufferedLine struct {
0000000000000000000000000000000000000000;;		line        string
0000000000000000000000000000000000000000;;		indentation int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type buffer struct {
0000000000000000000000000000000000000000;;		lines []bufferedLine
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newBuffer() *buffer {
0000000000000000000000000000000000000000;;		return &buffer{
0000000000000000000000000000000000000000;;			lines: make([]bufferedLine, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *buffer) addLine(line string, indent int) {
0000000000000000000000000000000000000000;;		b.lines = append(b.lines, bufferedLine{line, indent})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *buffer) flushLines(w io.Writer) error {
0000000000000000000000000000000000000000;;		for _, line := range b.lines {
0000000000000000000000000000000000000000;;			indentation := strings.Repeat("\t", line.indentation)
0000000000000000000000000000000000000000;;			fullLine := fmt.Sprintf("%s%s", indentation, line.line)
0000000000000000000000000000000000000000;;			if _, err := io.WriteString(w, fullLine); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeFuncHeader(b *buffer, structName string, indent int) {
0000000000000000000000000000000000000000;;		s := fmt.Sprintf("var map_%s = map[string]string {\n", structName)
0000000000000000000000000000000000000000;;		b.addLine(s, indent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeFuncFooter(b *buffer, structName string, indent int) {
0000000000000000000000000000000000000000;;		b.addLine("}\n", indent) // Closes the map definition
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := fmt.Sprintf("func (%s) SwaggerDoc() map[string]string {\n", structName)
0000000000000000000000000000000000000000;;		b.addLine(s, indent)
0000000000000000000000000000000000000000;;		s = fmt.Sprintf("return map_%s\n", structName)
0000000000000000000000000000000000000000;;		b.addLine(s, indent+1)
0000000000000000000000000000000000000000;;		b.addLine("}\n", indent) // Closes the function definition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeMapBody(b *buffer, kubeType []Pair, indent int) {
0000000000000000000000000000000000000000;;		format := "\"%s\": \"%s\",\n"
0000000000000000000000000000000000000000;;		for _, pair := range kubeType {
0000000000000000000000000000000000000000;;			s := fmt.Sprintf(format, pair.Name, pair.Doc)
0000000000000000000000000000000000000000;;			b.addLine(s, indent+2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseDocumentationFrom gets all types' documentation and returns them as an
0000000000000000000000000000000000000000;;	// array. Each type is again represented as an array (we have to use arrays as we
0000000000000000000000000000000000000000;;	// need to be sure for the order of the fields). This function returns fields and
0000000000000000000000000000000000000000;;	// struct definitions that have no documentation as {name, ""}.
0000000000000000000000000000000000000000;;	func ParseDocumentationFrom(src string) []KubeTypes {
0000000000000000000000000000000000000000;;		var docForTypes []KubeTypes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pkg := astFrom(src)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, kubType := range pkg.Types {
0000000000000000000000000000000000000000;;			if structType, ok := kubType.Decl.Specs[0].(*ast.TypeSpec).Type.(*ast.StructType); ok {
0000000000000000000000000000000000000000;;				var ks KubeTypes
0000000000000000000000000000000000000000;;				ks = append(ks, Pair{kubType.Name, fmtRawDoc(kubType.Doc)})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, field := range structType.Fields.List {
0000000000000000000000000000000000000000;;					if n := fieldName(field); n != "-" {
0000000000000000000000000000000000000000;;						fieldDoc := fmtRawDoc(field.Doc.Text())
0000000000000000000000000000000000000000;;						ks = append(ks, Pair{n, fieldDoc})
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				docForTypes = append(docForTypes, ks)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return docForTypes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteSwaggerDocFunc writes a declaration of a function as a string. This function is used in
0000000000000000000000000000000000000000;;	// Swagger as a documentation source for structs and theirs fields
0000000000000000000000000000000000000000;;	func WriteSwaggerDocFunc(kubeTypes []KubeTypes, w io.Writer) error {
0000000000000000000000000000000000000000;;		for _, kubeType := range kubeTypes {
0000000000000000000000000000000000000000;;			structName := kubeType[0].Name
0000000000000000000000000000000000000000;;			kubeType[0].Name = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ignore empty documentation
0000000000000000000000000000000000000000;;			docfulTypes := make(KubeTypes, 0, len(kubeType))
0000000000000000000000000000000000000000;;			for _, pair := range kubeType {
0000000000000000000000000000000000000000;;				if pair.Doc != "" {
0000000000000000000000000000000000000000;;					docfulTypes = append(docfulTypes, pair)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(docfulTypes) == 0 {
0000000000000000000000000000000000000000;;				continue // If no fields and the struct have documentation, skip the function definition
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			indent := 0
0000000000000000000000000000000000000000;;			buffer := newBuffer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			writeFuncHeader(buffer, structName, indent)
0000000000000000000000000000000000000000;;			writeMapBody(buffer, docfulTypes, indent)
0000000000000000000000000000000000000000;;			writeFuncFooter(buffer, structName, indent)
0000000000000000000000000000000000000000;;			buffer.addLine("\n", 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := buffer.flushLines(w); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifySwaggerDocsExist writes in a io.Writer a list of structs and fields that
0000000000000000000000000000000000000000;;	// are missing of documentation.
0000000000000000000000000000000000000000;;	func VerifySwaggerDocsExist(kubeTypes []KubeTypes, w io.Writer) (int, error) {
0000000000000000000000000000000000000000;;		missingDocs := 0
0000000000000000000000000000000000000000;;		buffer := newBuffer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, kubeType := range kubeTypes {
0000000000000000000000000000000000000000;;			structName := kubeType[0].Name
0000000000000000000000000000000000000000;;			if kubeType[0].Doc == "" {
0000000000000000000000000000000000000000;;				format := "Missing documentation for the struct itself: %s\n"
0000000000000000000000000000000000000000;;				s := fmt.Sprintf(format, structName)
0000000000000000000000000000000000000000;;				buffer.addLine(s, 0)
0000000000000000000000000000000000000000;;				missingDocs++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kubeType = kubeType[1:] // Skip struct definition
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, pair := range kubeType { // Iterate only the fields
0000000000000000000000000000000000000000;;				if pair.Doc == "" {
0000000000000000000000000000000000000000;;					format := "In struct: %s, field documentation is missing: %s\n"
0000000000000000000000000000000000000000;;					s := fmt.Sprintf(format, structName, pair.Name)
0000000000000000000000000000000000000000;;					buffer.addLine(s, 0)
0000000000000000000000000000000000000000;;					missingDocs++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := buffer.flushLines(w); err != nil {
0000000000000000000000000000000000000000;;			return -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return missingDocs, nil
0000000000000000000000000000000000000000;;	}
