0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package versioning
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testDecodable struct {
0000000000000000000000000000000000000000;;		Other string
0000000000000000000000000000000000000000;;		Value int `json:"value"`
0000000000000000000000000000000000000000;;		gvk   schema.GroupVersionKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *testDecodable) GetObjectKind() schema.ObjectKind                { return d }
0000000000000000000000000000000000000000;;	func (d *testDecodable) SetGroupVersionKind(gvk schema.GroupVersionKind) { d.gvk = gvk }
0000000000000000000000000000000000000000;;	func (d *testDecodable) GroupVersionKind() schema.GroupVersionKind       { return d.gvk }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testNestedDecodable struct {
0000000000000000000000000000000000000000;;		Other string
0000000000000000000000000000000000000000;;		Value int `json:"value"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gvk          schema.GroupVersionKind
0000000000000000000000000000000000000000;;		nestedCalled bool
0000000000000000000000000000000000000000;;		nestedErr    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *testNestedDecodable) GetObjectKind() schema.ObjectKind                { return d }
0000000000000000000000000000000000000000;;	func (d *testNestedDecodable) SetGroupVersionKind(gvk schema.GroupVersionKind) { d.gvk = gvk }
0000000000000000000000000000000000000000;;	func (d *testNestedDecodable) GroupVersionKind() schema.GroupVersionKind       { return d.gvk }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *testNestedDecodable) EncodeNestedObjects(e runtime.Encoder) error {
0000000000000000000000000000000000000000;;		d.nestedCalled = true
0000000000000000000000000000000000000000;;		return d.nestedErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *testNestedDecodable) DecodeNestedObjects(_ runtime.Decoder) error {
0000000000000000000000000000000000000000;;		d.nestedCalled = true
0000000000000000000000000000000000000000;;		return d.nestedErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNestedDecode(t *testing.T) {
0000000000000000000000000000000000000000;;		n := &testNestedDecodable{nestedErr: fmt.Errorf("unable to decode")}
0000000000000000000000000000000000000000;;		decoder := &mockSerializer{obj: n}
0000000000000000000000000000000000000000;;		codec := NewCodec(nil, decoder, nil, nil, nil, nil, nil, nil, nil)
0000000000000000000000000000000000000000;;		if _, _, err := codec.Decode([]byte(`{}`), nil, n); err != n.nestedErr {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !n.nestedCalled {
0000000000000000000000000000000000000000;;			t.Errorf("did not invoke nested decoder")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNestedEncode(t *testing.T) {
0000000000000000000000000000000000000000;;		n := &testNestedDecodable{nestedErr: fmt.Errorf("unable to decode")}
0000000000000000000000000000000000000000;;		n2 := &testNestedDecodable{nestedErr: fmt.Errorf("unable to decode 2")}
0000000000000000000000000000000000000000;;		encoder := &mockSerializer{obj: n}
0000000000000000000000000000000000000000;;		codec := NewCodec(
0000000000000000000000000000000000000000;;			encoder, nil,
0000000000000000000000000000000000000000;;			&checkConvertor{obj: n2, groupVersion: schema.GroupVersion{Group: "other"}},
0000000000000000000000000000000000000000;;			nil, nil,
0000000000000000000000000000000000000000;;			&mockTyper{gvks: []schema.GroupVersionKind{{Kind: "test"}}},
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			schema.GroupVersion{Group: "other"}, nil,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err := codec.Encode(n, ioutil.Discard); err != n2.nestedErr {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.nestedCalled || !n2.nestedCalled {
0000000000000000000000000000000000000000;;			t.Errorf("did not invoke correct nested decoder")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDecode(t *testing.T) {
0000000000000000000000000000000000000000;;		gvk1 := &schema.GroupVersionKind{Kind: "Test", Group: "other", Version: "blah"}
0000000000000000000000000000000000000000;;		decodable1 := &testDecodable{}
0000000000000000000000000000000000000000;;		decodable2 := &testDecodable{}
0000000000000000000000000000000000000000;;		decodable3 := &testDecodable{}
0000000000000000000000000000000000000000;;		versionedDecodable1 := &runtime.VersionedObjects{Objects: []runtime.Object{decodable1}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			serializer runtime.Serializer
0000000000000000000000000000000000000000;;			convertor  runtime.ObjectConvertor
0000000000000000000000000000000000000000;;			creater    runtime.ObjectCreater
0000000000000000000000000000000000000000;;			copier     runtime.ObjectCopier
0000000000000000000000000000000000000000;;			typer      runtime.ObjectTyper
0000000000000000000000000000000000000000;;			defaulter  runtime.ObjectDefaulter
0000000000000000000000000000000000000000;;			yaml       bool
0000000000000000000000000000000000000000;;			pretty     bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			encodes, decodes runtime.GroupVersioner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defaultGVK *schema.GroupVersionKind
0000000000000000000000000000000000000000;;			into       runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			errFn          func(error) bool
0000000000000000000000000000000000000000;;			expectedObject runtime.Object
0000000000000000000000000000000000000000;;			sameObject     runtime.Object
0000000000000000000000000000000000000000;;			expectedGVK    *schema.GroupVersionKind
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serializer:  &mockSerializer{actual: gvk1},
0000000000000000000000000000000000000000;;				convertor:   &checkConvertor{groupVersion: schema.GroupVersion{Group: "other", Version: "__internal"}},
0000000000000000000000000000000000000000;;				expectedGVK: gvk1,
0000000000000000000000000000000000000000;;				decodes:     schema.GroupVersion{Group: "other", Version: "__internal"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serializer:  &mockSerializer{actual: gvk1, obj: decodable1},
0000000000000000000000000000000000000000;;				convertor:   &checkConvertor{in: decodable1, obj: decodable2, groupVersion: schema.GroupVersion{Group: "other", Version: "__internal"}},
0000000000000000000000000000000000000000;;				expectedGVK: gvk1,
0000000000000000000000000000000000000000;;				sameObject:  decodable2,
0000000000000000000000000000000000000000;;				decodes:     schema.GroupVersion{Group: "other", Version: "__internal"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// defaultGVK.Group is allowed to force a conversion to the destination group
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				serializer:  &mockSerializer{actual: gvk1, obj: decodable1},
0000000000000000000000000000000000000000;;				defaultGVK:  &schema.GroupVersionKind{Group: "force"},
0000000000000000000000000000000000000000;;				convertor:   &checkConvertor{in: decodable1, obj: decodable2, groupVersion: schema.GroupVersion{Group: "force", Version: "__internal"}},
0000000000000000000000000000000000000000;;				expectedGVK: gvk1,
0000000000000000000000000000000000000000;;				sameObject:  decodable2,
0000000000000000000000000000000000000000;;				decodes:     schema.GroupVersion{Group: "force", Version: "__internal"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// uses direct conversion for into when objects differ
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				into:        decodable3,
0000000000000000000000000000000000000000;;				serializer:  &mockSerializer{actual: gvk1, obj: decodable1},
0000000000000000000000000000000000000000;;				convertor:   &checkConvertor{in: decodable1, obj: decodable3, directConvert: true},
0000000000000000000000000000000000000000;;				expectedGVK: gvk1,
0000000000000000000000000000000000000000;;				sameObject:  decodable3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				into:        versionedDecodable1,
0000000000000000000000000000000000000000;;				serializer:  &mockSerializer{actual: gvk1, obj: decodable3},
0000000000000000000000000000000000000000;;				convertor:   &checkConvertor{in: decodable3, obj: decodable1, directConvert: true},
0000000000000000000000000000000000000000;;				expectedGVK: gvk1,
0000000000000000000000000000000000000000;;				sameObject:  versionedDecodable1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// returns directly when serializer returns into
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				into:        decodable3,
0000000000000000000000000000000000000000;;				serializer:  &mockSerializer{actual: gvk1, obj: decodable3},
0000000000000000000000000000000000000000;;				expectedGVK: gvk1,
0000000000000000000000000000000000000000;;				sameObject:  decodable3,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// returns directly when serializer returns into
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				into:        versionedDecodable1,
0000000000000000000000000000000000000000;;				serializer:  &mockSerializer{actual: gvk1, obj: decodable1},
0000000000000000000000000000000000000000;;				expectedGVK: gvk1,
0000000000000000000000000000000000000000;;				sameObject:  versionedDecodable1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// runtime.VersionedObjects are decoded
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				into: &runtime.VersionedObjects{Objects: []runtime.Object{}},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				serializer:     &mockSerializer{actual: gvk1, obj: decodable1},
0000000000000000000000000000000000000000;;				copier:         &checkCopy{in: decodable1, obj: decodable1},
0000000000000000000000000000000000000000;;				convertor:      &checkConvertor{in: decodable1, obj: decodable2, groupVersion: schema.GroupVersion{Group: "other", Version: "__internal"}},
0000000000000000000000000000000000000000;;				expectedGVK:    gvk1,
0000000000000000000000000000000000000000;;				expectedObject: &runtime.VersionedObjects{Objects: []runtime.Object{decodable1, decodable2}},
0000000000000000000000000000000000000000;;				decodes:        schema.GroupVersion{Group: "other", Version: "__internal"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				into: &runtime.VersionedObjects{Objects: []runtime.Object{}},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				serializer:     &mockSerializer{actual: gvk1, obj: decodable1},
0000000000000000000000000000000000000000;;				copier:         &checkCopy{in: decodable1, obj: nil, err: fmt.Errorf("error on copy")},
0000000000000000000000000000000000000000;;				convertor:      &checkConvertor{in: decodable1, obj: decodable2, groupVersion: schema.GroupVersion{Group: "other", Version: "__internal"}},
0000000000000000000000000000000000000000;;				expectedGVK:    gvk1,
0000000000000000000000000000000000000000;;				expectedObject: &runtime.VersionedObjects{Objects: []runtime.Object{decodable1, decodable2}},
0000000000000000000000000000000000000000;;				decodes:        schema.GroupVersion{Group: "other", Version: "__internal"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// decode into the same version as the serialized object
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				decodes: schema.GroupVersions{gvk1.GroupVersion()},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				serializer:     &mockSerializer{actual: gvk1, obj: decodable1},
0000000000000000000000000000000000000000;;				convertor:      &checkConvertor{in: decodable1, obj: decodable1, groupVersion: schema.GroupVersions{{Group: "other", Version: "blah"}}},
0000000000000000000000000000000000000000;;				expectedGVK:    gvk1,
0000000000000000000000000000000000000000;;				expectedObject: decodable1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				into:    &runtime.VersionedObjects{Objects: []runtime.Object{}},
0000000000000000000000000000000000000000;;				decodes: schema.GroupVersions{gvk1.GroupVersion()},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				serializer:     &mockSerializer{actual: gvk1, obj: decodable1},
0000000000000000000000000000000000000000;;				convertor:      &checkConvertor{in: decodable1, obj: decodable1, groupVersion: schema.GroupVersions{{Group: "other", Version: "blah"}}},
0000000000000000000000000000000000000000;;				copier:         &checkCopy{in: decodable1, obj: decodable1, err: nil},
0000000000000000000000000000000000000000;;				expectedGVK:    gvk1,
0000000000000000000000000000000000000000;;				expectedObject: &runtime.VersionedObjects{Objects: []runtime.Object{decodable1}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// codec with non matching version skips conversion altogether
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				decodes: schema.GroupVersions{{Group: "something", Version: "else"}},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				serializer:     &mockSerializer{actual: gvk1, obj: decodable1},
0000000000000000000000000000000000000000;;				convertor:      &checkConvertor{in: decodable1, obj: decodable1, groupVersion: schema.GroupVersions{{Group: "something", Version: "else"}}},
0000000000000000000000000000000000000000;;				expectedGVK:    gvk1,
0000000000000000000000000000000000000000;;				expectedObject: decodable1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				into:    &runtime.VersionedObjects{Objects: []runtime.Object{}},
0000000000000000000000000000000000000000;;				decodes: schema.GroupVersions{{Group: "something", Version: "else"}},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				serializer:     &mockSerializer{actual: gvk1, obj: decodable1},
0000000000000000000000000000000000000000;;				convertor:      &checkConvertor{in: decodable1, obj: decodable1, groupVersion: schema.GroupVersions{{Group: "something", Version: "else"}}},
0000000000000000000000000000000000000000;;				copier:         &checkCopy{in: decodable1, obj: decodable1, err: nil},
0000000000000000000000000000000000000000;;				expectedGVK:    gvk1,
0000000000000000000000000000000000000000;;				expectedObject: &runtime.VersionedObjects{Objects: []runtime.Object{decodable1}},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			t.Logf("%d", i)
0000000000000000000000000000000000000000;;			s := NewCodec(test.serializer, test.serializer, test.convertor, test.creater, test.copier, test.typer, test.defaulter, test.encodes, test.decodes)
0000000000000000000000000000000000000000;;			obj, gvk, err := s.Decode([]byte(`{}`), test.defaultGVK, test.into)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(test.expectedGVK, gvk) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected GVK: %v", i, gvk)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == nil && test.errFn != nil:
0000000000000000000000000000000000000000;;				t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case err != nil && test.errFn == nil:
0000000000000000000000000000000000000000;;				t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				if !test.errFn(err) {
0000000000000000000000000000000000000000;;					t.Errorf("%d: failed: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if obj != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d: should have returned nil object", i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.into != nil && test.into != obj {
0000000000000000000000000000000000000000;;				t.Errorf("%d: expected into to be returned: %v", i, obj)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case test.expectedObject != nil:
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(test.expectedObject, obj) {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected object:\n%s", i, diff.ObjectGoPrintSideBySide(test.expectedObject, obj))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case test.sameObject != nil:
0000000000000000000000000000000000000000;;				if test.sameObject != obj {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected object:\n%s", i, diff.ObjectGoPrintSideBySide(test.sameObject, obj))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case obj != nil:
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected object: %#v", i, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type checkCopy struct {
0000000000000000000000000000000000000000;;		in, obj runtime.Object
0000000000000000000000000000000000000000;;		err     error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *checkCopy) Copy(obj runtime.Object) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if c.in != nil && c.in != obj {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected input to copy: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.obj, c.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type checkConvertor struct {
0000000000000000000000000000000000000000;;		err           error
0000000000000000000000000000000000000000;;		in, obj       runtime.Object
0000000000000000000000000000000000000000;;		groupVersion  runtime.GroupVersioner
0000000000000000000000000000000000000000;;		directConvert bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *checkConvertor) Convert(in, out, context interface{}) error {
0000000000000000000000000000000000000000;;		if !c.directConvert {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected call to Convert")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.in != nil && c.in != in {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected in: %s", in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.obj != nil && c.obj != out {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected out: %s", out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *checkConvertor) ConvertToVersion(in runtime.Object, outVersion runtime.GroupVersioner) (out runtime.Object, err error) {
0000000000000000000000000000000000000000;;		if c.directConvert {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected call to ConvertToVersion")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.in != nil && c.in != in {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected in: %s", in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(c.groupVersion, outVersion) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unexpected outversion: %s (%s)", outVersion, c.groupVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.obj, c.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *checkConvertor) ConvertFieldLabel(version, kind, label, value string) (string, string, error) {
0000000000000000000000000000000000000000;;		return "", "", fmt.Errorf("unexpected call to ConvertFieldLabel")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockSerializer struct {
0000000000000000000000000000000000000000;;		err            error
0000000000000000000000000000000000000000;;		obj            runtime.Object
0000000000000000000000000000000000000000;;		encodingObjGVK schema.GroupVersionKind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaults, actual *schema.GroupVersionKind
0000000000000000000000000000000000000000;;		into             runtime.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *mockSerializer) Decode(data []byte, defaults *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		s.defaults = defaults
0000000000000000000000000000000000000000;;		s.into = into
0000000000000000000000000000000000000000;;		return s.obj, s.actual, s.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *mockSerializer) Encode(obj runtime.Object, w io.Writer) error {
0000000000000000000000000000000000000000;;		s.obj = obj
0000000000000000000000000000000000000000;;		s.encodingObjGVK = obj.GetObjectKind().GroupVersionKind()
0000000000000000000000000000000000000000;;		return s.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockCreater struct {
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;		obj runtime.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *mockCreater) New(kind schema.GroupVersionKind) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return c.obj, c.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mockTyper struct {
0000000000000000000000000000000000000000;;		gvks        []schema.GroupVersionKind
0000000000000000000000000000000000000000;;		unversioned bool
0000000000000000000000000000000000000000;;		err         error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *mockTyper) ObjectKinds(obj runtime.Object) ([]schema.GroupVersionKind, bool, error) {
0000000000000000000000000000000000000000;;		return t.gvks, t.unversioned, t.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *mockTyper) Recognizes(_ schema.GroupVersionKind) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDirectCodecEncode(t *testing.T) {
0000000000000000000000000000000000000000;;		serializer := mockSerializer{}
0000000000000000000000000000000000000000;;		typer := mockTyper{
0000000000000000000000000000000000000000;;			gvks: []schema.GroupVersionKind{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Group: "wrong_group",
0000000000000000000000000000000000000000;;					Kind:  "some_kind",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Group: "expected_group",
0000000000000000000000000000000000000000;;					Kind:  "some_kind",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := DirectEncoder{
0000000000000000000000000000000000000000;;			Version:     schema.GroupVersion{Group: "expected_group"},
0000000000000000000000000000000000000000;;			Encoder:     &serializer,
0000000000000000000000000000000000000000;;			ObjectTyper: &typer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Encode(&testDecodable{}, ioutil.Discard)
0000000000000000000000000000000000000000;;		if e, a := "expected_group", serializer.encodingObjGVK.Group; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected group to be %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
