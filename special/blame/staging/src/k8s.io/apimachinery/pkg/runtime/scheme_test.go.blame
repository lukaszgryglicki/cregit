0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package runtime_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		runtimetesting "k8s.io/apimachinery/pkg/runtime/testing"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var fuzzIters = flag.Int("fuzz-iters", 50, "How many fuzzing iterations to do.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestScheme(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Group: "test.group", Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Group: "test.group", Version: "testExternal"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(internalGV.WithKind("Simple"), &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(externalGV.WithKind("Simple"), &runtimetesting.ExternalSimple{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If set, would clear TypeMeta during conversion.
0000000000000000000000000000000000000000;;		//scheme.AddIgnoredConversionType(&TypeMeta{}, &TypeMeta{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test that scheme is an ObjectTyper
0000000000000000000000000000000000000000;;		var _ runtime.ObjectTyper = scheme
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		internalToExternalCalls := 0
0000000000000000000000000000000000000000;;		externalToInternalCalls := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register functions to verify that scope.Meta() gets set correctly.
0000000000000000000000000000000000000000;;		err := scheme.AddConversionFuncs(
0000000000000000000000000000000000000000;;			func(in *runtimetesting.InternalSimple, out *runtimetesting.ExternalSimple, scope conversion.Scope) error {
0000000000000000000000000000000000000000;;				scope.Convert(&in.TypeMeta, &out.TypeMeta, 0)
0000000000000000000000000000000000000000;;				scope.Convert(&in.TestString, &out.TestString, 0)
0000000000000000000000000000000000000000;;				internalToExternalCalls++
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(in *runtimetesting.ExternalSimple, out *runtimetesting.InternalSimple, scope conversion.Scope) error {
0000000000000000000000000000000000000000;;				scope.Convert(&in.TypeMeta, &out.TypeMeta, 0)
0000000000000000000000000000000000000000;;				scope.Convert(&in.TestString, &out.TestString, 0)
0000000000000000000000000000000000000000;;				externalToInternalCalls++
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codecs := serializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;		codec := codecs.LegacyCodec(externalGV)
0000000000000000000000000000000000000000;;		info, _ := runtime.SerializerInfoForMediaType(codecs.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		jsonserializer := info.Serializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &runtimetesting.InternalSimple{
0000000000000000000000000000000000000000;;			TestString: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test Encode, Decode, DecodeInto, and DecodeToVersion
0000000000000000000000000000000000000000;;		obj := runtime.Object(simple)
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(codec, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj2, err := runtime.Decode(codec, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := obj2.(*runtimetesting.InternalSimple); !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Got wrong type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := simple, obj2; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected:\n %#v,\n Got:\n %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj3 := &runtimetesting.InternalSimple{}
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(codec, data, obj3); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// clearing TypeMeta is a function of the scheme, which we do not test here (ConvertToVersion
0000000000000000000000000000000000000000;;		// does not automatically clear TypeMeta anymore).
0000000000000000000000000000000000000000;;		simple.TypeMeta = runtime.TypeMeta{Kind: "Simple", APIVersion: externalGV.String()}
0000000000000000000000000000000000000000;;		if e, a := simple, obj3; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected:\n %#v,\n Got:\n %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj4, err := runtime.Decode(jsonserializer, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := obj4.(*runtimetesting.ExternalSimple); !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Got wrong type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test Convert
0000000000000000000000000000000000000000;;		external := &runtimetesting.ExternalSimple{}
0000000000000000000000000000000000000000;;		err = scheme.Convert(simple, external, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := simple.TestString, external.TestString; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Encode and Convert should each have caused an increment.
0000000000000000000000000000000000000000;;		if e, a := 2, internalToExternalCalls; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// DecodeInto and Decode should each have caused an increment because of a conversion
0000000000000000000000000000000000000000;;		if e, a := 2, externalToInternalCalls; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBadJSONRejection(t *testing.T) {
0000000000000000000000000000000000000000;;		scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		codecs := serializer.NewCodecFactory(scheme)
0000000000000000000000000000000000000000;;		info, _ := runtime.SerializerInfoForMediaType(codecs.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		jsonserializer := info.Serializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		badJSONMissingKind := []byte(`{ }`)
0000000000000000000000000000000000000000;;		if _, err := runtime.Decode(jsonserializer, badJSONMissingKind); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Did not reject despite lack of kind field: %s", badJSONMissingKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		badJSONUnknownType := []byte(`{"kind": "bar"}`)
0000000000000000000000000000000000000000;;		if _, err1 := runtime.Decode(jsonserializer, badJSONUnknownType); err1 == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Did not reject despite use of unknown type: %s", badJSONUnknownType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		/*badJSONKindMismatch := []byte(`{"kind": "Pod"}`)
0000000000000000000000000000000000000000;;		if err2 := DecodeInto(badJSONKindMismatch, &Node{}); err2 == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Kind is set but doesn't match the object type: %s", badJSONKindMismatch)
0000000000000000000000000000000000000000;;		}*/
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExternalToInternalMapping(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Group: "test.group", Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Group: "test.group", Version: "testExternal"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(internalGV.WithKind("OptionalExtensionType"), &runtimetesting.InternalOptionalExtensionType{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(externalGV.WithKind("OptionalExtensionType"), &runtimetesting.ExternalOptionalExtensionType{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := serializer.NewCodecFactory(scheme).LegacyCodec(externalGV)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			obj     runtime.Object
0000000000000000000000000000000000000000;;			encoded string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&runtimetesting.InternalOptionalExtensionType{Extension: nil},
0000000000000000000000000000000000000000;;				`{"kind":"OptionalExtensionType","apiVersion":"` + externalGV.String() + `"}`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, item := range table {
0000000000000000000000000000000000000000;;			gotDecoded, err := runtime.Decode(codec, []byte(item.encoded))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error '%v' (%v)", err, item.encoded)
0000000000000000000000000000000000000000;;			} else if e, a := item.obj, gotDecoded; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected objects:\n%s", i, diff.ObjectGoPrintSideBySide(e, a))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExtensionMapping(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Group: "test.group", Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Group: "test.group", Version: "testExternal"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(internalGV.WithKind("ExtensionType"), &runtimetesting.InternalExtensionType{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(internalGV.WithKind("OptionalExtensionType"), &runtimetesting.InternalOptionalExtensionType{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(externalGV.WithKind("ExtensionType"), &runtimetesting.ExternalExtensionType{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(externalGV.WithKind("OptionalExtensionType"), &runtimetesting.ExternalOptionalExtensionType{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// register external first when the object is the same in both schemes, so ObjectVersionAndKind reports the
0000000000000000000000000000000000000000;;		// external version.
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(externalGV.WithKind("A"), &runtimetesting.ExtensionA{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(externalGV.WithKind("B"), &runtimetesting.ExtensionB{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(internalGV.WithKind("A"), &runtimetesting.ExtensionA{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(internalGV.WithKind("B"), &runtimetesting.ExtensionB{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := serializer.NewCodecFactory(scheme).LegacyCodec(externalGV)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			obj      runtime.Object
0000000000000000000000000000000000000000;;			expected runtime.Object
0000000000000000000000000000000000000000;;			encoded  string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				&runtimetesting.InternalExtensionType{
0000000000000000000000000000000000000000;;					Extension: runtime.NewEncodable(codec, &runtimetesting.ExtensionA{TestString: "foo"}),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&runtimetesting.InternalExtensionType{
0000000000000000000000000000000000000000;;					Extension: &runtime.Unknown{
0000000000000000000000000000000000000000;;						Raw:         []byte(`{"apiVersion":"test.group/testExternal","kind":"A","testString":"foo"}`),
0000000000000000000000000000000000000000;;						ContentType: runtime.ContentTypeJSON,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// apiVersion is set in the serialized object for easier consumption by clients
0000000000000000000000000000000000000000;;				`{"apiVersion":"` + externalGV.String() + `","kind":"ExtensionType","extension":{"apiVersion":"test.group/testExternal","kind":"A","testString":"foo"}}
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				&runtimetesting.InternalExtensionType{Extension: runtime.NewEncodable(codec, &runtimetesting.ExtensionB{TestString: "bar"})},
0000000000000000000000000000000000000000;;				&runtimetesting.InternalExtensionType{
0000000000000000000000000000000000000000;;					Extension: &runtime.Unknown{
0000000000000000000000000000000000000000;;						Raw:         []byte(`{"apiVersion":"test.group/testExternal","kind":"B","testString":"bar"}`),
0000000000000000000000000000000000000000;;						ContentType: runtime.ContentTypeJSON,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				// apiVersion is set in the serialized object for easier consumption by clients
0000000000000000000000000000000000000000;;				`{"apiVersion":"` + externalGV.String() + `","kind":"ExtensionType","extension":{"apiVersion":"test.group/testExternal","kind":"B","testString":"bar"}}
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				&runtimetesting.InternalExtensionType{Extension: nil},
0000000000000000000000000000000000000000;;				&runtimetesting.InternalExtensionType{
0000000000000000000000000000000000000000;;					Extension: nil,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				`{"apiVersion":"` + externalGV.String() + `","kind":"ExtensionType","extension":null}
0000000000000000000000000000000000000000;;	`,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, item := range table {
0000000000000000000000000000000000000000;;			gotEncoded, err := runtime.Encode(codec, item.obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error '%v' (%#v)", err, item.obj)
0000000000000000000000000000000000000000;;			} else if e, a := item.encoded, string(gotEncoded); e != a {
0000000000000000000000000000000000000000;;				t.Errorf("expected\n%#v\ngot\n%#v\n", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			gotDecoded, err := runtime.Decode(codec, []byte(item.encoded))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("unexpected error '%v' (%v)", err, item.encoded)
0000000000000000000000000000000000000000;;			} else if e, a := item.expected, gotDecoded; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected objects:\n%s", i, diff.ObjectGoPrintSideBySide(e, a))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEncode(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Group: "test.group", Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Group: "test.group", Version: "testExternal"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(internalGV.WithKind("Simple"), &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(externalGV.WithKind("Simple"), &runtimetesting.ExternalSimple{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := serializer.NewCodecFactory(scheme).LegacyCodec(externalGV)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		test := &runtimetesting.InternalSimple{
0000000000000000000000000000000000000000;;			TestString: "I'm the same",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj := runtime.Object(test)
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(codec, obj)
0000000000000000000000000000000000000000;;		obj2, gvk, err2 := codec.Decode(data, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil || err2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failure: '%v' '%v'", err, err2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := obj2.(*runtimetesting.InternalSimple); !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Got wrong type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(obj2, test) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected:\n %#v,\n Got:\n %#v", test, obj2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(gvk, &schema.GroupVersionKind{Group: "test.group", Version: "testExternal", Kind: "Simple"}) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected gvk returned by decode: %#v", gvk)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUnversionedTypes(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Group: "test.group", Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Group: "test.group", Version: "testExternal"}
0000000000000000000000000000000000000000;;		otherGV := schema.GroupVersion{Group: "group", Version: "other"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scheme := runtime.NewScheme()
0000000000000000000000000000000000000000;;		scheme.AddUnversionedTypes(externalGV, &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(internalGV.WithKind("Simple"), &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(externalGV.WithKind("Simple"), &runtimetesting.ExternalSimple{})
0000000000000000000000000000000000000000;;		scheme.AddKnownTypeWithName(otherGV.WithKind("Simple"), &runtimetesting.ExternalSimple{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := serializer.NewCodecFactory(scheme).LegacyCodec(externalGV)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if unv, ok := scheme.IsUnversioned(&runtimetesting.InternalSimple{}); !unv || !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("type not unversioned and in scheme: %t %t", unv, ok)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kinds, _, err := scheme.ObjectKinds(&runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kind := kinds[0]
0000000000000000000000000000000000000000;;		if kind != externalGV.WithKind("InternalSimple") {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected: %#v", kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		test := &runtimetesting.InternalSimple{
0000000000000000000000000000000000000000;;			TestString: "I'm the same",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj := runtime.Object(test)
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(codec, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj2, gvk, err := codec.Decode(data, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := obj2.(*runtimetesting.InternalSimple); !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Got wrong type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(obj2, test) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected:\n %#v,\n Got:\n %#v", test, obj2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// object is serialized as an unversioned object (in the group and version it was defined in)
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(gvk, &schema.GroupVersionKind{Group: "test.group", Version: "testExternal", Kind: "InternalSimple"}) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected gvk returned by decode: %#v", gvk)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// when serialized to a different group, the object is kept in its preferred name
0000000000000000000000000000000000000000;;		codec = serializer.NewCodecFactory(scheme).LegacyCodec(otherGV)
0000000000000000000000000000000000000000;;		data, err = runtime.Encode(codec, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if string(data) != `{"apiVersion":"test.group/testExternal","kind":"InternalSimple","testString":"I'm the same"}`+"\n" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected data: %s", data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestObjectFuzzer can randomly populate all the above objects.
0000000000000000000000000000000000000000;;	var TestObjectFuzzer = fuzz.New().NilChance(.5).NumElements(1, 100).Funcs(
0000000000000000000000000000000000000000;;		func(j *runtimetesting.MyWeirdCustomEmbeddedVersionKindField, c fuzz.Continue) {
0000000000000000000000000000000000000000;;			// We have to customize the randomization of MyWeirdCustomEmbeddedVersionKindFields because their
0000000000000000000000000000000000000000;;			// APIVersion and Kind must remain blank in memory.
0000000000000000000000000000000000000000;;			j.APIVersion = ""
0000000000000000000000000000000000000000;;			j.ObjectKind = ""
0000000000000000000000000000000000000000;;			j.ID = c.RandString()
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a new Scheme set up with the test objects.
0000000000000000000000000000000000000000;;	func GetTestScheme() *runtime.Scheme {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Version: "__internal"}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Version: "v1"}
0000000000000000000000000000000000000000;;		alternateExternalGV := schema.GroupVersion{Group: "custom", Version: "v1"}
0000000000000000000000000000000000000000;;		differentExternalGV := schema.GroupVersion{Group: "other", Version: "v2"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		// Ordinarily, we wouldn't add TestType2, but because this is a test and
0000000000000000000000000000000000000000;;		// both types are from the same package, we need to get it into the system
0000000000000000000000000000000000000000;;		// so that converter will match it with ExternalType2.
0000000000000000000000000000000000000000;;		s.AddKnownTypes(internalGV, &runtimetesting.TestType1{}, &runtimetesting.TestType2{}, &runtimetesting.ExternalInternalSame{})
0000000000000000000000000000000000000000;;		s.AddKnownTypes(externalGV, &runtimetesting.ExternalInternalSame{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("TestType1"), &runtimetesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("TestType2"), &runtimetesting.ExternalTestType2{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(internalGV.WithKind("TestType3"), &runtimetesting.TestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("TestType3"), &runtimetesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("TestType4"), &runtimetesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(alternateExternalGV.WithKind("TestType3"), &runtimetesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(alternateExternalGV.WithKind("TestType5"), &runtimetesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(differentExternalGV.WithKind("TestType1"), &runtimetesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;		s.AddUnversionedTypes(externalGV, &runtimetesting.UnversionedType{})
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestKnownTypes(t *testing.T) {
0000000000000000000000000000000000000000;;		s := GetTestScheme()
0000000000000000000000000000000000000000;;		if len(s.KnownTypes(schema.GroupVersion{Group: "group", Version: "v2"})) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("should have no known types for v2")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		types := s.KnownTypes(schema.GroupVersion{Version: "v1"})
0000000000000000000000000000000000000000;;		for _, s := range []string{"TestType1", "TestType2", "TestType3", "ExternalInternalSame"} {
0000000000000000000000000000000000000000;;			if _, ok := types[s]; !ok {
0000000000000000000000000000000000000000;;				t.Errorf("missing type %q", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAddKnownTypesIdemPotent(t *testing.T) {
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gv := schema.GroupVersion{Group: "foo", Version: "v1"}
0000000000000000000000000000000000000000;;		s.AddKnownTypes(gv, &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		s.AddKnownTypes(gv, &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		if len(s.KnownTypes(gv)) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected only one %v type after double registration", gv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.AllKnownTypes()) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected only one type after double registration")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(gv.WithKind("InternalSimple"), &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(gv.WithKind("InternalSimple"), &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		if len(s.KnownTypes(gv)) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected only one %v type after double registration with custom name", gv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.AllKnownTypes()) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected only one type after double registration with custom name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.AddUnversionedTypes(gv, &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		s.AddUnversionedTypes(gv, &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		if len(s.KnownTypes(gv)) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected only one %v type after double registration with custom name", gv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s.AllKnownTypes()) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected only one type after double registration with custom name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kinds, _, err := s.ObjectKinds(&runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(kinds) != 1 {
0000000000000000000000000000000000000000;;			t.Errorf("expected only one kind for InternalSimple after double registration")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// redefine InternalSimple with the same name, but obviously as a different type than in runtimetesting
0000000000000000000000000000000000000000;;	type InternalSimple struct {
0000000000000000000000000000000000000000;;		runtime.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		TestString       string `json:"testString"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *InternalSimple) DeepCopyObject() runtime.Object { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConflictingAddKnownTypes(t *testing.T) {
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		gv := schema.GroupVersion{Group: "foo", Version: "v1"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		panicked := make(chan bool)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if recover() != nil {
0000000000000000000000000000000000000000;;					panicked <- true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			s.AddKnownTypeWithName(gv.WithKind("InternalSimple"), &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;			s.AddKnownTypeWithName(gv.WithKind("InternalSimple"), &runtimetesting.ExternalSimple{})
0000000000000000000000000000000000000000;;			panicked <- false
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if !<-panicked {
0000000000000000000000000000000000000000;;			t.Errorf("Expected AddKnownTypesWithName to panic with conflicting type registrations")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				if recover() != nil {
0000000000000000000000000000000000000000;;					panicked <- true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.AddUnversionedTypes(gv, &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;			s.AddUnversionedTypes(gv, &InternalSimple{})
0000000000000000000000000000000000000000;;			panicked <- false
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if !<-panicked {
0000000000000000000000000000000000000000;;			t.Errorf("Expected AddUnversionedTypes to panic with conflicting type registrations")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConvertToVersionBasic(t *testing.T) {
0000000000000000000000000000000000000000;;		s := GetTestScheme()
0000000000000000000000000000000000000000;;		tt := &runtimetesting.TestType1{A: "I'm not a pointer object"}
0000000000000000000000000000000000000000;;		other, err := s.ConvertToVersion(tt, schema.GroupVersion{Version: "v1"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failure: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		converted, ok := other.(*runtimetesting.ExternalTestType1)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Got wrong type: %T", other)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tt.A != converted.A {
0000000000000000000000000000000000000000;;			t.Fatalf("Failed to convert object correctly: %#v", converted)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testGroupVersioner struct {
0000000000000000000000000000000000000000;;		target schema.GroupVersionKind
0000000000000000000000000000000000000000;;		ok     bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m testGroupVersioner) KindForGroupVersionKinds(kinds []schema.GroupVersionKind) (schema.GroupVersionKind, bool) {
0000000000000000000000000000000000000000;;		return m.target, m.ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConvertToVersion(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			scheme *runtime.Scheme
0000000000000000000000000000000000000000;;			in     runtime.Object
0000000000000000000000000000000000000000;;			gv     runtime.GroupVersioner
0000000000000000000000000000000000000000;;			same   bool
0000000000000000000000000000000000000000;;			out    runtime.Object
0000000000000000000000000000000000000000;;			errFn  func(error) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// errors if the type is not registered in the scheme
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.UnknownType{},
0000000000000000000000000000000000000000;;				errFn:  func(err error) bool { return err != nil && runtime.IsNotRegisteredError(err) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// errors if the group versioner returns no target
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     testGroupVersioner{},
0000000000000000000000000000000000000000;;				errFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return err != nil && strings.Contains(err.Error(), "is not suitable for converting")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// converts to internal
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     schema.GroupVersion{Version: "__internal"},
0000000000000000000000000000000000000000;;				out:    &runtimetesting.TestType1{A: "test"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// prefers the best match
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     schema.GroupVersions{{Version: "__internal"}, {Version: "v1"}},
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "v1", ObjectKind: "TestType1"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// unversioned type returned as-is
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.UnversionedType{A: "test"},
0000000000000000000000000000000000000000;;				gv:     schema.GroupVersions{{Version: "v1"}},
0000000000000000000000000000000000000000;;				same:   true,
0000000000000000000000000000000000000000;;				out: &runtimetesting.UnversionedType{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "v1", ObjectKind: "UnversionedType"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// unversioned type returned when not included in the target types
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.UnversionedType{A: "test"},
0000000000000000000000000000000000000000;;				gv:     schema.GroupVersions{{Group: "other", Version: "v2"}},
0000000000000000000000000000000000000000;;				same:   true,
0000000000000000000000000000000000000000;;				out: &runtimetesting.UnversionedType{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "v1", ObjectKind: "UnversionedType"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// detected as already being in the target version
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     schema.GroupVersions{{Version: "v1"}},
0000000000000000000000000000000000000000;;				same:   true,
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "v1", ObjectKind: "TestType1"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// detected as already being in the first target version
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     schema.GroupVersions{{Version: "v1"}, {Version: "__internal"}},
0000000000000000000000000000000000000000;;				same:   true,
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "v1", ObjectKind: "TestType1"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// detected as already being in the first target version
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     schema.GroupVersions{{Version: "v1"}, {Version: "__internal"}},
0000000000000000000000000000000000000000;;				same:   true,
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "v1", ObjectKind: "TestType1"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// the external type is registered in multiple groups, versions, and kinds, and can be targeted to all of them (1/3): different kind
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     testGroupVersioner{ok: true, target: schema.GroupVersionKind{Kind: "TestType3", Version: "v1"}},
0000000000000000000000000000000000000000;;				same:   true,
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "v1", ObjectKind: "TestType3"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// the external type is registered in multiple groups, versions, and kinds, and can be targeted to all of them (2/3): different gv
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     testGroupVersioner{ok: true, target: schema.GroupVersionKind{Kind: "TestType3", Group: "custom", Version: "v1"}},
0000000000000000000000000000000000000000;;				same:   true,
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "custom/v1", ObjectKind: "TestType3"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// the external type is registered in multiple groups, versions, and kinds, and can be targeted to all of them (3/3): different gvk
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     testGroupVersioner{ok: true, target: schema.GroupVersionKind{Group: "custom", Version: "v1", Kind: "TestType5"}},
0000000000000000000000000000000000000000;;				same:   true,
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "custom/v1", ObjectKind: "TestType5"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// multi group versioner recognizes multiple groups and forces the output to a particular version, copies because version differs
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     runtime.NewMultiGroupVersioner(schema.GroupVersion{Group: "other", Version: "v2"}, schema.GroupKind{Group: "custom", Kind: "TestType3"}, schema.GroupKind{Kind: "TestType1"}),
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "other/v2", ObjectKind: "TestType1"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// multi group versioner recognizes multiple groups and forces the output to a particular version, copies because version differs
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     runtime.NewMultiGroupVersioner(schema.GroupVersion{Group: "other", Version: "v2"}, schema.GroupKind{Kind: "TestType1"}, schema.GroupKind{Group: "custom", Kind: "TestType3"}),
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "other/v2", ObjectKind: "TestType1"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// multi group versioner is unable to find a match when kind AND group don't match (there is no TestType1 kind in group "other", and no kind "TestType5" in the default group)
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.TestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     runtime.NewMultiGroupVersioner(schema.GroupVersion{Group: "custom", Version: "v1"}, schema.GroupKind{Group: "other"}, schema.GroupKind{Kind: "TestType5"}),
0000000000000000000000000000000000000000;;				errFn: func(err error) bool {
0000000000000000000000000000000000000000;;					return err != nil && strings.Contains(err.Error(), "is not suitable for converting")
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// multi group versioner recognizes multiple groups and forces the output to a particular version, performs no copy
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     runtime.NewMultiGroupVersioner(schema.GroupVersion{Group: "", Version: "v1"}, schema.GroupKind{Group: "custom", Kind: "TestType3"}, schema.GroupKind{Kind: "TestType1"}),
0000000000000000000000000000000000000000;;				same:   true,
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "v1", ObjectKind: "TestType1"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// multi group versioner recognizes multiple groups and forces the output to a particular version, performs no copy
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.ExternalTestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     runtime.NewMultiGroupVersioner(schema.GroupVersion{Group: "", Version: "v1"}, schema.GroupKind{Kind: "TestType1"}, schema.GroupKind{Group: "custom", Kind: "TestType3"}),
0000000000000000000000000000000000000000;;				same:   true,
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "v1", ObjectKind: "TestType1"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// group versioner can choose a particular target kind for a given input when kind is the same across group versions
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.TestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     testGroupVersioner{ok: true, target: schema.GroupVersionKind{Version: "v1", Kind: "TestType3"}},
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "v1", ObjectKind: "TestType3"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// group versioner can choose a different kind
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				scheme: GetTestScheme(),
0000000000000000000000000000000000000000;;				in:     &runtimetesting.TestType1{A: "test"},
0000000000000000000000000000000000000000;;				gv:     testGroupVersioner{ok: true, target: schema.GroupVersionKind{Kind: "TestType5", Group: "custom", Version: "v1"}},
0000000000000000000000000000000000000000;;				out: &runtimetesting.ExternalTestType1{
0000000000000000000000000000000000000000;;					MyWeirdCustomEmbeddedVersionKindField: runtimetesting.MyWeirdCustomEmbeddedVersionKindField{APIVersion: "custom/v1", ObjectKind: "TestType5"},
0000000000000000000000000000000000000000;;					A: "test",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range testCases {
0000000000000000000000000000000000000000;;			original, _ := test.scheme.DeepCopy(test.in)
0000000000000000000000000000000000000000;;			out, err := test.scheme.ConvertToVersion(test.in, test.gv)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case test.errFn != nil:
0000000000000000000000000000000000000000;;				if !test.errFn(err) {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out == test.in {
0000000000000000000000000000000000000000;;				t.Errorf("%d: ConvertToVersion should always copy out: %#v", i, out)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.same {
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(original, test.in) {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected mutation of input: %s", i, diff.ObjectReflectDiff(original, test.in))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(out, test.out) {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected out: %s", i, diff.ObjectReflectDiff(out, test.out))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				unsafe, err := test.scheme.UnsafeConvertToVersion(test.in, test.gv)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(unsafe, test.out) {
0000000000000000000000000000000000000000;;					t.Errorf("%d: unexpected unsafe: %s", i, diff.ObjectReflectDiff(unsafe, test.out))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if unsafe != test.in {
0000000000000000000000000000000000000000;;					t.Errorf("%d: UnsafeConvertToVersion should return same object: %#v", i, unsafe)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(out, test.out) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected out: %s", i, diff.ObjectReflectDiff(out, test.out))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMetaValues(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Group: "test.group", Version: "__internal"}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Group: "test.group", Version: "externalVersion"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(internalGV.WithKind("Simple"), &runtimetesting.InternalSimple{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("Simple"), &runtimetesting.ExternalSimple{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		internalToExternalCalls := 0
0000000000000000000000000000000000000000;;		externalToInternalCalls := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register functions to verify that scope.Meta() gets set correctly.
0000000000000000000000000000000000000000;;		err := s.AddConversionFuncs(
0000000000000000000000000000000000000000;;			func(in *runtimetesting.InternalSimple, out *runtimetesting.ExternalSimple, scope conversion.Scope) error {
0000000000000000000000000000000000000000;;				t.Logf("internal -> external")
0000000000000000000000000000000000000000;;				scope.Convert(&in.TestString, &out.TestString, 0)
0000000000000000000000000000000000000000;;				internalToExternalCalls++
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			func(in *runtimetesting.ExternalSimple, out *runtimetesting.InternalSimple, scope conversion.Scope) error {
0000000000000000000000000000000000000000;;				t.Logf("external -> internal")
0000000000000000000000000000000000000000;;				scope.Convert(&in.TestString, &out.TestString, 0)
0000000000000000000000000000000000000000;;				externalToInternalCalls++
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		simple := &runtimetesting.InternalSimple{
0000000000000000000000000000000000000000;;			TestString: "foo",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.Log(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := s.ConvertToVersion(simple, externalGV)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		internal, err := s.ConvertToVersion(out, internalGV)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := simple, internal; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected:\n %#v,\n Got:\n %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 1, internalToExternalCalls; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 1, externalToInternalCalls; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMetaValuesUnregisteredConvert(t *testing.T) {
0000000000000000000000000000000000000000;;		type InternalSimple struct {
0000000000000000000000000000000000000000;;			Version    string `json:"apiVersion,omitempty"`
0000000000000000000000000000000000000000;;			Kind       string `json:"kind,omitempty"`
0000000000000000000000000000000000000000;;			TestString string `json:"testString"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type ExternalSimple struct {
0000000000000000000000000000000000000000;;			Version    string `json:"apiVersion,omitempty"`
0000000000000000000000000000000000000000;;			Kind       string `json:"kind,omitempty"`
0000000000000000000000000000000000000000;;			TestString string `json:"testString"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		// We deliberately don't register the types.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		internalToExternalCalls := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register functions to verify that scope.Meta() gets set correctly.
0000000000000000000000000000000000000000;;		err := s.AddConversionFuncs(
0000000000000000000000000000000000000000;;			func(in *InternalSimple, out *ExternalSimple, scope conversion.Scope) error {
0000000000000000000000000000000000000000;;				scope.Convert(&in.TestString, &out.TestString, 0)
0000000000000000000000000000000000000000;;				internalToExternalCalls++
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simple := &InternalSimple{TestString: "foo"}
0000000000000000000000000000000000000000;;		external := &ExternalSimple{}
0000000000000000000000000000000000000000;;		err = s.Convert(simple, external, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := simple.TestString, external.TestString; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that our conversion handler got called.
0000000000000000000000000000000000000000;;		if e, a := 1, internalToExternalCalls; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
