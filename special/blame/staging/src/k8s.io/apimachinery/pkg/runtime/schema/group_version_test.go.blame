0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package schema
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGroupVersionParse(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input string
0000000000000000000000000000000000000000;;			out   GroupVersion
0000000000000000000000000000000000000000;;			err   func(error) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{input: "v1", out: GroupVersion{Version: "v1"}},
0000000000000000000000000000000000000000;;			{input: "v2", out: GroupVersion{Version: "v2"}},
0000000000000000000000000000000000000000;;			{input: "/v1", out: GroupVersion{Version: "v1"}},
0000000000000000000000000000000000000000;;			{input: "v1/", out: GroupVersion{Group: "v1"}},
0000000000000000000000000000000000000000;;			{input: "/v1/", err: func(err error) bool { return err.Error() == "unexpected GroupVersion string: /v1/" }},
0000000000000000000000000000000000000000;;			{input: "v1/a", out: GroupVersion{Group: "v1", Version: "a"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			out, err := ParseGroupVersion(test.input)
0000000000000000000000000000000000000000;;			if test.err == nil && err != nil || err == nil && test.err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.err != nil && !test.err(err) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected error: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if out != test.out {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected output: %#v", i, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestGroupResourceParse(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input string
0000000000000000000000000000000000000000;;			out   GroupResource
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{input: "v1", out: GroupResource{Resource: "v1"}},
0000000000000000000000000000000000000000;;			{input: ".v1", out: GroupResource{Group: "v1"}},
0000000000000000000000000000000000000000;;			{input: "v1.", out: GroupResource{Resource: "v1"}},
0000000000000000000000000000000000000000;;			{input: "v1.a", out: GroupResource{Group: "a", Resource: "v1"}},
0000000000000000000000000000000000000000;;			{input: "b.v1.a", out: GroupResource{Group: "v1.a", Resource: "b"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			out := ParseGroupResource(test.input)
0000000000000000000000000000000000000000;;			if out != test.out {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected output: %#v", i, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestParseResourceArg(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			input string
0000000000000000000000000000000000000000;;			gvr   *GroupVersionResource
0000000000000000000000000000000000000000;;			gr    GroupResource
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{input: "v1", gr: GroupResource{Resource: "v1"}},
0000000000000000000000000000000000000000;;			{input: ".v1", gr: GroupResource{Group: "v1"}},
0000000000000000000000000000000000000000;;			{input: "v1.", gr: GroupResource{Resource: "v1"}},
0000000000000000000000000000000000000000;;			{input: "v1.a", gr: GroupResource{Group: "a", Resource: "v1"}},
0000000000000000000000000000000000000000;;			{input: "b.v1.a", gvr: &GroupVersionResource{Group: "a", Version: "v1", Resource: "b"}, gr: GroupResource{Group: "v1.a", Resource: "b"}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			gvr, gr := ParseResourceArg(test.input)
0000000000000000000000000000000000000000;;			if (gvr != nil && test.gvr == nil) || (gvr == nil && test.gvr != nil) || (test.gvr != nil && *gvr != *test.gvr) {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected output: %#v", i, gvr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if gr != test.gr {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected output: %#v", i, gr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestKindForGroupVersionKinds(t *testing.T) {
0000000000000000000000000000000000000000;;		gvks := GroupVersions{
0000000000000000000000000000000000000000;;			GroupVersion{Group: "batch", Version: "v1"},
0000000000000000000000000000000000000000;;			GroupVersion{Group: "batch", Version: "v2alpha1"},
0000000000000000000000000000000000000000;;			GroupVersion{Group: "policy", Version: "v1beta1"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cases := []struct {
0000000000000000000000000000000000000000;;			input  []GroupVersionKind
0000000000000000000000000000000000000000;;			target GroupVersionKind
0000000000000000000000000000000000000000;;			ok     bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  []GroupVersionKind{{Group: "batch", Version: "v2alpha1", Kind: "ScheduledJob"}},
0000000000000000000000000000000000000000;;				target: GroupVersionKind{Group: "batch", Version: "v2alpha1", Kind: "ScheduledJob"},
0000000000000000000000000000000000000000;;				ok:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  []GroupVersionKind{{Group: "batch", Version: "v3alpha1", Kind: "CronJob"}},
0000000000000000000000000000000000000000;;				target: GroupVersionKind{Group: "batch", Version: "v1", Kind: "CronJob"},
0000000000000000000000000000000000000000;;				ok:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  []GroupVersionKind{{Group: "policy", Version: "v1beta1", Kind: "PodDisruptionBudget"}},
0000000000000000000000000000000000000000;;				target: GroupVersionKind{Group: "policy", Version: "v1beta1", Kind: "PodDisruptionBudget"},
0000000000000000000000000000000000000000;;				ok:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				input:  []GroupVersionKind{{Group: "apps", Version: "v1alpha1", Kind: "StatefulSet"}},
0000000000000000000000000000000000000000;;				target: GroupVersionKind{},
0000000000000000000000000000000000000000;;				ok:     false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, c := range cases {
0000000000000000000000000000000000000000;;			target, ok := gvks.KindForGroupVersionKinds(c.input)
0000000000000000000000000000000000000000;;			if c.target != target {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected target: %v, expected %v", i, target, c.target)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.ok != ok {
0000000000000000000000000000000000000000;;				t.Errorf("%d: unexpected ok: %v, expected %v", i, ok, c.ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
