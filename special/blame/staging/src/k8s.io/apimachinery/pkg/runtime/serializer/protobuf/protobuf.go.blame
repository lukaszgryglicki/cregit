0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package protobuf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/proto"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/recognizer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/framer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// protoEncodingPrefix serves as a magic number for an encoded protobuf message on this serializer. All
0000000000000000000000000000000000000000;;		// proto messages serialized by this schema will be preceded by the bytes 0x6b 0x38 0x73, with the fourth
0000000000000000000000000000000000000000;;		// byte being reserved for the encoding style. The only encoding style defined is 0x00, which means that
0000000000000000000000000000000000000000;;		// the rest of the byte stream is a message of type k8s.io.kubernetes.pkg.runtime.Unknown (proto2).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// See k8s.io/apimachinery/pkg/runtime/generated.proto for details of the runtime.Unknown message.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This encoding scheme is experimental, and is subject to change at any time.
0000000000000000000000000000000000000000;;		protoEncodingPrefix = []byte{0x6b, 0x38, 0x73, 0x00}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errNotMarshalable struct {
0000000000000000000000000000000000000000;;		t reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e errNotMarshalable) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("object %v does not implement the protobuf marshalling interface and cannot be encoded to a protobuf message", e.t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func IsNotMarshalable(err error) bool {
0000000000000000000000000000000000000000;;		_, ok := err.(errNotMarshalable)
0000000000000000000000000000000000000000;;		return err != nil && ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSerializer creates a Protobuf serializer that handles encoding versioned objects into the proper wire form. If a typer
0000000000000000000000000000000000000000;;	// is passed, the encoded object will have group, version, and kind fields set. If typer is nil, the objects will be written
0000000000000000000000000000000000000000;;	// as-is (any type info passed with the object will be used).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This encoding scheme is experimental, and is subject to change at any time.
0000000000000000000000000000000000000000;;	func NewSerializer(creater runtime.ObjectCreater, typer runtime.ObjectTyper, defaultContentType string) *Serializer {
0000000000000000000000000000000000000000;;		return &Serializer{
0000000000000000000000000000000000000000;;			prefix:      protoEncodingPrefix,
0000000000000000000000000000000000000000;;			creater:     creater,
0000000000000000000000000000000000000000;;			typer:       typer,
0000000000000000000000000000000000000000;;			contentType: defaultContentType,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Serializer struct {
0000000000000000000000000000000000000000;;		prefix      []byte
0000000000000000000000000000000000000000;;		creater     runtime.ObjectCreater
0000000000000000000000000000000000000000;;		typer       runtime.ObjectTyper
0000000000000000000000000000000000000000;;		contentType string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ runtime.Serializer = &Serializer{}
0000000000000000000000000000000000000000;;	var _ recognizer.RecognizingDecoder = &Serializer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode attempts to convert the provided data into a protobuf message, extract the stored schema kind, apply the provided default
0000000000000000000000000000000000000000;;	// gvk, and then load that data into an object matching the desired schema kind or the provided into. If into is *runtime.Unknown,
0000000000000000000000000000000000000000;;	// the raw data will be extracted and no decoding will be performed. If into is not registered with the typer, then the object will
0000000000000000000000000000000000000000;;	// be straight decoded using normal protobuf unmarshalling (the MarshalTo interface). If into is provided and the original data is
0000000000000000000000000000000000000000;;	// not fully qualified with kind/version/group, the type of the into will be used to alter the returned gvk. On success or most
0000000000000000000000000000000000000000;;	// errors, the method will return the calculated schema kind.
0000000000000000000000000000000000000000;;	func (s *Serializer) Decode(originalData []byte, gvk *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		if versioned, ok := into.(*runtime.VersionedObjects); ok {
0000000000000000000000000000000000000000;;			into = versioned.Last()
0000000000000000000000000000000000000000;;			obj, actual, err := s.Decode(originalData, gvk, into)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, actual, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// the last item in versioned becomes into, so if versioned was not originally empty we reset the object
0000000000000000000000000000000000000000;;			// array so the first position is the decoded object and the second position is the outermost object.
0000000000000000000000000000000000000000;;			// if there were no objects in the versioned list passed to us, only add ourselves.
0000000000000000000000000000000000000000;;			if into != nil && into != obj {
0000000000000000000000000000000000000000;;				versioned.Objects = []runtime.Object{obj, into}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				versioned.Objects = []runtime.Object{obj}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return versioned, actual, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prefixLen := len(s.prefix)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case len(originalData) == 0:
0000000000000000000000000000000000000000;;			// TODO: treat like decoding {} from JSON with defaulting
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("empty data")
0000000000000000000000000000000000000000;;		case len(originalData) < prefixLen || !bytes.Equal(s.prefix, originalData[:prefixLen]):
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("provided data does not appear to be a protobuf message, expected prefix %v", s.prefix)
0000000000000000000000000000000000000000;;		case len(originalData) == prefixLen:
0000000000000000000000000000000000000000;;			// TODO: treat like decoding {} from JSON with defaulting
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("empty body")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := originalData[prefixLen:]
0000000000000000000000000000000000000000;;		unk := runtime.Unknown{}
0000000000000000000000000000000000000000;;		if err := unk.Unmarshal(data); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actual := unk.GroupVersionKind()
0000000000000000000000000000000000000000;;		copyKindDefaults(&actual, gvk)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if intoUnknown, ok := into.(*runtime.Unknown); ok && intoUnknown != nil {
0000000000000000000000000000000000000000;;			*intoUnknown = unk
0000000000000000000000000000000000000000;;			if ok, _, _ := s.RecognizesData(bytes.NewBuffer(unk.Raw)); ok {
0000000000000000000000000000000000000000;;				intoUnknown.ContentType = s.contentType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return intoUnknown, &actual, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if into != nil {
0000000000000000000000000000000000000000;;			types, _, err := s.typer.ObjectKinds(into)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case runtime.IsNotRegisteredError(err):
0000000000000000000000000000000000000000;;				pb, ok := into.(proto.Message)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, &actual, errNotMarshalable{reflect.TypeOf(into)}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := proto.Unmarshal(unk.Raw, pb); err != nil {
0000000000000000000000000000000000000000;;					return nil, &actual, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return into, &actual, nil
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				return nil, &actual, err
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				copyKindDefaults(&actual, &types[0])
0000000000000000000000000000000000000000;;				// if the result of defaulting did not set a version or group, ensure that at least group is set
0000000000000000000000000000000000000000;;				// (copyKindDefaults will not assign Group if version is already set). This guarantees that the group
0000000000000000000000000000000000000000;;				// of into is set if there is no better information from the caller or object.
0000000000000000000000000000000000000000;;				if len(actual.Version) == 0 && len(actual.Group) == 0 {
0000000000000000000000000000000000000000;;					actual.Group = types[0].Group
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(actual.Kind) == 0 {
0000000000000000000000000000000000000000;;			return nil, &actual, runtime.NewMissingKindErr(fmt.Sprintf("%#v", unk.TypeMeta))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(actual.Version) == 0 {
0000000000000000000000000000000000000000;;			return nil, &actual, runtime.NewMissingVersionErr(fmt.Sprintf("%#v", unk.TypeMeta))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unmarshalToObject(s.typer, s.creater, &actual, into, unk.Raw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode serializes the provided object to the given writer.
0000000000000000000000000000000000000000;;	func (s *Serializer) Encode(obj runtime.Object, w io.Writer) error {
0000000000000000000000000000000000000000;;		prefixSize := uint64(len(s.prefix))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var unk runtime.Unknown
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case *runtime.Unknown:
0000000000000000000000000000000000000000;;			estimatedSize := prefixSize + uint64(t.Size())
0000000000000000000000000000000000000000;;			data := make([]byte, estimatedSize)
0000000000000000000000000000000000000000;;			i, err := t.MarshalTo(data[prefixSize:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy(data, s.prefix)
0000000000000000000000000000000000000000;;			_, err = w.Write(data[:prefixSize+uint64(i)])
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			kind := obj.GetObjectKind().GroupVersionKind()
0000000000000000000000000000000000000000;;			unk = runtime.Unknown{
0000000000000000000000000000000000000000;;				TypeMeta: runtime.TypeMeta{
0000000000000000000000000000000000000000;;					Kind:       kind.Kind,
0000000000000000000000000000000000000000;;					APIVersion: kind.GroupVersion().String(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case bufferedMarshaller:
0000000000000000000000000000000000000000;;			// this path performs a single allocation during write but requires the caller to implement
0000000000000000000000000000000000000000;;			// the more efficient Size and MarshalTo methods
0000000000000000000000000000000000000000;;			encodedSize := uint64(t.Size())
0000000000000000000000000000000000000000;;			estimatedSize := prefixSize + estimateUnknownSize(&unk, encodedSize)
0000000000000000000000000000000000000000;;			data := make([]byte, estimatedSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i, err := unk.NestedMarshalTo(data[prefixSize:], t, encodedSize)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			copy(data, s.prefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = w.Write(data[:prefixSize+uint64(i)])
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case proto.Marshaler:
0000000000000000000000000000000000000000;;			// this path performs extra allocations
0000000000000000000000000000000000000000;;			data, err := t.Marshal()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unk.Raw = data
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			estimatedSize := prefixSize + uint64(unk.Size())
0000000000000000000000000000000000000000;;			data = make([]byte, estimatedSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i, err := unk.MarshalTo(data[prefixSize:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			copy(data, s.prefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = w.Write(data[:prefixSize+uint64(i)])
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// TODO: marshal with a different content type and serializer (JSON for third party objects)
0000000000000000000000000000000000000000;;			return errNotMarshalable{reflect.TypeOf(obj)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecognizesData implements the RecognizingDecoder interface.
0000000000000000000000000000000000000000;;	func (s *Serializer) RecognizesData(peek io.Reader) (bool, bool, error) {
0000000000000000000000000000000000000000;;		prefix := make([]byte, 4)
0000000000000000000000000000000000000000;;		n, err := peek.Read(prefix)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				return false, false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != 4 {
0000000000000000000000000000000000000000;;			return false, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bytes.Equal(s.prefix, prefix), false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyKindDefaults defaults dst to the value in src if dst does not have a value set.
0000000000000000000000000000000000000000;;	func copyKindDefaults(dst, src *schema.GroupVersionKind) {
0000000000000000000000000000000000000000;;		if src == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// apply kind and version defaulting from provided default
0000000000000000000000000000000000000000;;		if len(dst.Kind) == 0 {
0000000000000000000000000000000000000000;;			dst.Kind = src.Kind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(dst.Version) == 0 && len(src.Version) > 0 {
0000000000000000000000000000000000000000;;			dst.Group = src.Group
0000000000000000000000000000000000000000;;			dst.Version = src.Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bufferedMarshaller describes a more efficient marshalling interface that can avoid allocating multiple
0000000000000000000000000000000000000000;;	// byte buffers by pre-calculating the size of the final buffer needed.
0000000000000000000000000000000000000000;;	type bufferedMarshaller interface {
0000000000000000000000000000000000000000;;		proto.Sizer
0000000000000000000000000000000000000000;;		runtime.ProtobufMarshaller
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// estimateUnknownSize returns the expected bytes consumed by a given runtime.Unknown
0000000000000000000000000000000000000000;;	// object with a nil RawJSON struct and the expected size of the provided buffer. The
0000000000000000000000000000000000000000;;	// returned size will not be correct if RawJSOn is set on unk.
0000000000000000000000000000000000000000;;	func estimateUnknownSize(unk *runtime.Unknown, byteSize uint64) uint64 {
0000000000000000000000000000000000000000;;		size := uint64(unk.Size())
0000000000000000000000000000000000000000;;		// protobuf uses 1 byte for the tag, a varint for the length of the array (at most 8 bytes - uint64 - here),
0000000000000000000000000000000000000000;;		// and the size of the array.
0000000000000000000000000000000000000000;;		size += 1 + 8 + byteSize
0000000000000000000000000000000000000000;;		return size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRawSerializer creates a Protobuf serializer that handles encoding versioned objects into the proper wire form. If typer
0000000000000000000000000000000000000000;;	// is not nil, the object has the group, version, and kind fields set. This serializer does not provide type information for the
0000000000000000000000000000000000000000;;	// encoded object, and thus is not self describing (callers must know what type is being described in order to decode).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This encoding scheme is experimental, and is subject to change at any time.
0000000000000000000000000000000000000000;;	func NewRawSerializer(creater runtime.ObjectCreater, typer runtime.ObjectTyper, defaultContentType string) *RawSerializer {
0000000000000000000000000000000000000000;;		return &RawSerializer{
0000000000000000000000000000000000000000;;			creater:     creater,
0000000000000000000000000000000000000000;;			typer:       typer,
0000000000000000000000000000000000000000;;			contentType: defaultContentType,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RawSerializer encodes and decodes objects without adding a runtime.Unknown wrapper (objects are encoded without identifying
0000000000000000000000000000000000000000;;	// type).
0000000000000000000000000000000000000000;;	type RawSerializer struct {
0000000000000000000000000000000000000000;;		creater     runtime.ObjectCreater
0000000000000000000000000000000000000000;;		typer       runtime.ObjectTyper
0000000000000000000000000000000000000000;;		contentType string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ runtime.Serializer = &RawSerializer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode attempts to convert the provided data into a protobuf message, extract the stored schema kind, apply the provided default
0000000000000000000000000000000000000000;;	// gvk, and then load that data into an object matching the desired schema kind or the provided into. If into is *runtime.Unknown,
0000000000000000000000000000000000000000;;	// the raw data will be extracted and no decoding will be performed. If into is not registered with the typer, then the object will
0000000000000000000000000000000000000000;;	// be straight decoded using normal protobuf unmarshalling (the MarshalTo interface). If into is provided and the original data is
0000000000000000000000000000000000000000;;	// not fully qualified with kind/version/group, the type of the into will be used to alter the returned gvk. On success or most
0000000000000000000000000000000000000000;;	// errors, the method will return the calculated schema kind.
0000000000000000000000000000000000000000;;	func (s *RawSerializer) Decode(originalData []byte, gvk *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		if into == nil {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("this serializer requires an object to decode into: %#v", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if versioned, ok := into.(*runtime.VersionedObjects); ok {
0000000000000000000000000000000000000000;;			into = versioned.Last()
0000000000000000000000000000000000000000;;			obj, actual, err := s.Decode(originalData, gvk, into)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, actual, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if into != nil && into != obj {
0000000000000000000000000000000000000000;;				versioned.Objects = []runtime.Object{obj, into}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				versioned.Objects = []runtime.Object{obj}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return versioned, actual, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(originalData) == 0 {
0000000000000000000000000000000000000000;;			// TODO: treat like decoding {} from JSON with defaulting
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("empty data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data := originalData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actual := &schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;		copyKindDefaults(actual, gvk)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if intoUnknown, ok := into.(*runtime.Unknown); ok && intoUnknown != nil {
0000000000000000000000000000000000000000;;			intoUnknown.Raw = data
0000000000000000000000000000000000000000;;			intoUnknown.ContentEncoding = ""
0000000000000000000000000000000000000000;;			intoUnknown.ContentType = s.contentType
0000000000000000000000000000000000000000;;			intoUnknown.SetGroupVersionKind(*actual)
0000000000000000000000000000000000000000;;			return intoUnknown, actual, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		types, _, err := s.typer.ObjectKinds(into)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case runtime.IsNotRegisteredError(err):
0000000000000000000000000000000000000000;;			pb, ok := into.(proto.Message)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, actual, errNotMarshalable{reflect.TypeOf(into)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := proto.Unmarshal(data, pb); err != nil {
0000000000000000000000000000000000000000;;				return nil, actual, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return into, actual, nil
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			return nil, actual, err
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			copyKindDefaults(actual, &types[0])
0000000000000000000000000000000000000000;;			// if the result of defaulting did not set a version or group, ensure that at least group is set
0000000000000000000000000000000000000000;;			// (copyKindDefaults will not assign Group if version is already set). This guarantees that the group
0000000000000000000000000000000000000000;;			// of into is set if there is no better information from the caller or object.
0000000000000000000000000000000000000000;;			if len(actual.Version) == 0 && len(actual.Group) == 0 {
0000000000000000000000000000000000000000;;				actual.Group = types[0].Group
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(actual.Kind) == 0 {
0000000000000000000000000000000000000000;;			return nil, actual, runtime.NewMissingKindErr("<protobuf encoded body - must provide default type>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(actual.Version) == 0 {
0000000000000000000000000000000000000000;;			return nil, actual, runtime.NewMissingVersionErr("<protobuf encoded body - must provide default type>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unmarshalToObject(s.typer, s.creater, actual, into, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unmarshalToObject is the common code between decode in the raw and normal serializer.
0000000000000000000000000000000000000000;;	func unmarshalToObject(typer runtime.ObjectTyper, creater runtime.ObjectCreater, actual *schema.GroupVersionKind, into runtime.Object, data []byte) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		// use the target if necessary
0000000000000000000000000000000000000000;;		obj, err := runtime.UseOrCreateObject(typer, creater, *actual, into)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, actual, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb, ok := obj.(proto.Message)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, actual, errNotMarshalable{reflect.TypeOf(obj)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := proto.Unmarshal(data, pb); err != nil {
0000000000000000000000000000000000000000;;			return nil, actual, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, actual, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode serializes the provided object to the given writer. Overrides is ignored.
0000000000000000000000000000000000000000;;	func (s *RawSerializer) Encode(obj runtime.Object, w io.Writer) error {
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case bufferedMarshaller:
0000000000000000000000000000000000000000;;			// this path performs a single allocation during write but requires the caller to implement
0000000000000000000000000000000000000000;;			// the more efficient Size and MarshalTo methods
0000000000000000000000000000000000000000;;			encodedSize := uint64(t.Size())
0000000000000000000000000000000000000000;;			data := make([]byte, encodedSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n, err := t.MarshalTo(data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = w.Write(data[:n])
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case proto.Marshaler:
0000000000000000000000000000000000000000;;			// this path performs extra allocations
0000000000000000000000000000000000000000;;			data, err := t.Marshal()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = w.Write(data)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errNotMarshalable{reflect.TypeOf(obj)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var LengthDelimitedFramer = lengthDelimitedFramer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lengthDelimitedFramer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFrameWriter implements stream framing for this serializer
0000000000000000000000000000000000000000;;	func (lengthDelimitedFramer) NewFrameWriter(w io.Writer) io.Writer {
0000000000000000000000000000000000000000;;		return framer.NewLengthDelimitedFrameWriter(w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFrameReader implements stream framing for this serializer
0000000000000000000000000000000000000000;;	func (lengthDelimitedFramer) NewFrameReader(r io.ReadCloser) io.ReadCloser {
0000000000000000000000000000000000000000;;		return framer.NewLengthDelimitedFrameReader(r)
0000000000000000000000000000000000000000;;	}
