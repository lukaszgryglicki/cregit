0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package versioning
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCodecForScheme is a convenience method for callers that are using a scheme.
0000000000000000000000000000000000000000;;	func NewCodecForScheme(
0000000000000000000000000000000000000000;;		// TODO: I should be a scheme interface?
0000000000000000000000000000000000000000;;		scheme *runtime.Scheme,
0000000000000000000000000000000000000000;;		encoder runtime.Encoder,
0000000000000000000000000000000000000000;;		decoder runtime.Decoder,
0000000000000000000000000000000000000000;;		encodeVersion runtime.GroupVersioner,
0000000000000000000000000000000000000000;;		decodeVersion runtime.GroupVersioner,
0000000000000000000000000000000000000000;;	) runtime.Codec {
0000000000000000000000000000000000000000;;		return NewCodec(encoder, decoder, runtime.UnsafeObjectConvertor(scheme), scheme, scheme, scheme, nil, encodeVersion, decodeVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultingCodecForScheme is a convenience method for callers that are using a scheme.
0000000000000000000000000000000000000000;;	func NewDefaultingCodecForScheme(
0000000000000000000000000000000000000000;;		// TODO: I should be a scheme interface?
0000000000000000000000000000000000000000;;		scheme *runtime.Scheme,
0000000000000000000000000000000000000000;;		encoder runtime.Encoder,
0000000000000000000000000000000000000000;;		decoder runtime.Decoder,
0000000000000000000000000000000000000000;;		encodeVersion runtime.GroupVersioner,
0000000000000000000000000000000000000000;;		decodeVersion runtime.GroupVersioner,
0000000000000000000000000000000000000000;;	) runtime.Codec {
0000000000000000000000000000000000000000;;		return NewCodec(encoder, decoder, runtime.UnsafeObjectConvertor(scheme), scheme, scheme, scheme, scheme, encodeVersion, decodeVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCodec takes objects in their internal versions and converts them to external versions before
0000000000000000000000000000000000000000;;	// serializing them. It assumes the serializer provided to it only deals with external versions.
0000000000000000000000000000000000000000;;	// This class is also a serializer, but is generally used with a specific version.
0000000000000000000000000000000000000000;;	func NewCodec(
0000000000000000000000000000000000000000;;		encoder runtime.Encoder,
0000000000000000000000000000000000000000;;		decoder runtime.Decoder,
0000000000000000000000000000000000000000;;		convertor runtime.ObjectConvertor,
0000000000000000000000000000000000000000;;		creater runtime.ObjectCreater,
0000000000000000000000000000000000000000;;		copier runtime.ObjectCopier,
0000000000000000000000000000000000000000;;		typer runtime.ObjectTyper,
0000000000000000000000000000000000000000;;		defaulter runtime.ObjectDefaulter,
0000000000000000000000000000000000000000;;		encodeVersion runtime.GroupVersioner,
0000000000000000000000000000000000000000;;		decodeVersion runtime.GroupVersioner,
0000000000000000000000000000000000000000;;	) runtime.Codec {
0000000000000000000000000000000000000000;;		internal := &codec{
0000000000000000000000000000000000000000;;			encoder:   encoder,
0000000000000000000000000000000000000000;;			decoder:   decoder,
0000000000000000000000000000000000000000;;			convertor: convertor,
0000000000000000000000000000000000000000;;			creater:   creater,
0000000000000000000000000000000000000000;;			copier:    copier,
0000000000000000000000000000000000000000;;			typer:     typer,
0000000000000000000000000000000000000000;;			defaulter: defaulter,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			encodeVersion: encodeVersion,
0000000000000000000000000000000000000000;;			decodeVersion: decodeVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return internal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type codec struct {
0000000000000000000000000000000000000000;;		encoder   runtime.Encoder
0000000000000000000000000000000000000000;;		decoder   runtime.Decoder
0000000000000000000000000000000000000000;;		convertor runtime.ObjectConvertor
0000000000000000000000000000000000000000;;		creater   runtime.ObjectCreater
0000000000000000000000000000000000000000;;		copier    runtime.ObjectCopier
0000000000000000000000000000000000000000;;		typer     runtime.ObjectTyper
0000000000000000000000000000000000000000;;		defaulter runtime.ObjectDefaulter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encodeVersion runtime.GroupVersioner
0000000000000000000000000000000000000000;;		decodeVersion runtime.GroupVersioner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode attempts a decode of the object, then tries to convert it to the internal version. If into is provided and the decoding is
0000000000000000000000000000000000000000;;	// successful, the returned runtime.Object will be the value passed as into. Note that this may bypass conversion if you pass an
0000000000000000000000000000000000000000;;	// into that matches the serialized version.
0000000000000000000000000000000000000000;;	func (c *codec) Decode(data []byte, defaultGVK *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		versioned, isVersioned := into.(*runtime.VersionedObjects)
0000000000000000000000000000000000000000;;		if isVersioned {
0000000000000000000000000000000000000000;;			into = versioned.Last()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, gvk, err := c.decoder.Decode(data, defaultGVK, into)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, gvk, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d, ok := obj.(runtime.NestedObjectDecoder); ok {
0000000000000000000000000000000000000000;;			if err := d.DecodeNestedObjects(DirectDecoder{c.decoder}); err != nil {
0000000000000000000000000000000000000000;;				return nil, gvk, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we specify a target, use generic conversion.
0000000000000000000000000000000000000000;;		if into != nil {
0000000000000000000000000000000000000000;;			if into == obj {
0000000000000000000000000000000000000000;;				if isVersioned {
0000000000000000000000000000000000000000;;					return versioned, gvk, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return into, gvk, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// perform defaulting if requested
0000000000000000000000000000000000000000;;			if c.defaulter != nil {
0000000000000000000000000000000000000000;;				// create a copy to ensure defaulting is not applied to the original versioned objects
0000000000000000000000000000000000000000;;				if isVersioned {
0000000000000000000000000000000000000000;;					copied, err := c.copier.Copy(obj)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;						copied = obj
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					versioned.Objects = []runtime.Object{copied}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c.defaulter.Default(obj)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if isVersioned {
0000000000000000000000000000000000000000;;					versioned.Objects = []runtime.Object{obj}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := c.convertor.Convert(obj, into, c.decodeVersion); err != nil {
0000000000000000000000000000000000000000;;				return nil, gvk, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isVersioned {
0000000000000000000000000000000000000000;;				versioned.Objects = append(versioned.Objects, into)
0000000000000000000000000000000000000000;;				return versioned, gvk, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return into, gvk, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert if needed.
0000000000000000000000000000000000000000;;		if isVersioned {
0000000000000000000000000000000000000000;;			// create a copy, because ConvertToVersion does not guarantee non-mutation of objects
0000000000000000000000000000000000000000;;			copied, err := c.copier.Copy(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;				copied = obj
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			versioned.Objects = []runtime.Object{copied}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// perform defaulting if requested
0000000000000000000000000000000000000000;;		if c.defaulter != nil {
0000000000000000000000000000000000000000;;			c.defaulter.Default(obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := c.convertor.ConvertToVersion(obj, c.decodeVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, gvk, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isVersioned {
0000000000000000000000000000000000000000;;			if versioned.Last() != out {
0000000000000000000000000000000000000000;;				versioned.Objects = append(versioned.Objects, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return versioned, gvk, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, gvk, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode ensures the provided object is output in the appropriate group and version, invoking
0000000000000000000000000000000000000000;;	// conversion if necessary. Unversioned objects (according to the ObjectTyper) are output as is.
0000000000000000000000000000000000000000;;	func (c *codec) Encode(obj runtime.Object, w io.Writer) error {
0000000000000000000000000000000000000000;;		switch obj.(type) {
0000000000000000000000000000000000000000;;		case *runtime.Unknown, runtime.Unstructured:
0000000000000000000000000000000000000000;;			return c.encoder.Encode(obj, w)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gvks, isUnversioned, err := c.typer.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.encodeVersion == nil || isUnversioned {
0000000000000000000000000000000000000000;;			if e, ok := obj.(runtime.NestedObjectEncoder); ok {
0000000000000000000000000000000000000000;;				if err := e.EncodeNestedObjects(DirectEncoder{Encoder: c.encoder, ObjectTyper: c.typer}); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			objectKind := obj.GetObjectKind()
0000000000000000000000000000000000000000;;			old := objectKind.GroupVersionKind()
0000000000000000000000000000000000000000;;			objectKind.SetGroupVersionKind(gvks[0])
0000000000000000000000000000000000000000;;			err = c.encoder.Encode(obj, w)
0000000000000000000000000000000000000000;;			objectKind.SetGroupVersionKind(old)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform a conversion if necessary
0000000000000000000000000000000000000000;;		objectKind := obj.GetObjectKind()
0000000000000000000000000000000000000000;;		old := objectKind.GroupVersionKind()
0000000000000000000000000000000000000000;;		out, err := c.convertor.ConvertToVersion(obj, c.encodeVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, ok := out.(runtime.NestedObjectEncoder); ok {
0000000000000000000000000000000000000000;;			if err := e.EncodeNestedObjects(DirectEncoder{Version: c.encodeVersion, Encoder: c.encoder, ObjectTyper: c.typer}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Conversion is responsible for setting the proper group, version, and kind onto the outgoing object
0000000000000000000000000000000000000000;;		err = c.encoder.Encode(out, w)
0000000000000000000000000000000000000000;;		// restore the old GVK, in case conversion returned the same object
0000000000000000000000000000000000000000;;		objectKind.SetGroupVersionKind(old)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirectEncoder serializes an object and ensures the GVK is set.
0000000000000000000000000000000000000000;;	type DirectEncoder struct {
0000000000000000000000000000000000000000;;		Version runtime.GroupVersioner
0000000000000000000000000000000000000000;;		runtime.Encoder
0000000000000000000000000000000000000000;;		runtime.ObjectTyper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode does not do conversion. It sets the gvk during serialization.
0000000000000000000000000000000000000000;;	func (e DirectEncoder) Encode(obj runtime.Object, stream io.Writer) error {
0000000000000000000000000000000000000000;;		gvks, _, err := e.ObjectTyper.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if runtime.IsNotRegisteredError(err) {
0000000000000000000000000000000000000000;;				return e.Encoder.Encode(obj, stream)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kind := obj.GetObjectKind()
0000000000000000000000000000000000000000;;		oldGVK := kind.GroupVersionKind()
0000000000000000000000000000000000000000;;		gvk := gvks[0]
0000000000000000000000000000000000000000;;		if e.Version != nil {
0000000000000000000000000000000000000000;;			preferredGVK, ok := e.Version.KindForGroupVersionKinds(gvks)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				gvk = preferredGVK
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kind.SetGroupVersionKind(gvk)
0000000000000000000000000000000000000000;;		err = e.Encoder.Encode(obj, stream)
0000000000000000000000000000000000000000;;		kind.SetGroupVersionKind(oldGVK)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirectDecoder clears the group version kind of a deserialized object.
0000000000000000000000000000000000000000;;	type DirectDecoder struct {
0000000000000000000000000000000000000000;;		runtime.Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode does not do conversion. It removes the gvk during deserialization.
0000000000000000000000000000000000000000;;	func (d DirectDecoder) Decode(data []byte, defaults *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		obj, gvk, err := d.Decoder.Decode(data, defaults, into)
0000000000000000000000000000000000000000;;		if obj != nil {
0000000000000000000000000000000000000000;;			kind := obj.GetObjectKind()
0000000000000000000000000000000000000000;;			// clearing the gvk is just a convention of a codec
0000000000000000000000000000000000000000;;			kind.SetGroupVersionKind(schema.GroupVersionKind{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, gvk, err
0000000000000000000000000000000000000000;;	}
