0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package runtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion/queryparams"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// codec binds an encoder and decoder.
0000000000000000000000000000000000000000;;	type codec struct {
0000000000000000000000000000000000000000;;		Encoder
0000000000000000000000000000000000000000;;		Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCodec creates a Codec from an Encoder and Decoder.
0000000000000000000000000000000000000000;;	func NewCodec(e Encoder, d Decoder) Codec {
0000000000000000000000000000000000000000;;		return codec{e, d}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode is a convenience wrapper for encoding to a []byte from an Encoder
0000000000000000000000000000000000000000;;	func Encode(e Encoder, obj Object) ([]byte, error) {
0000000000000000000000000000000000000000;;		// TODO: reuse buffer
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		if err := e.Encode(obj, buf); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode is a convenience wrapper for decoding data into an Object.
0000000000000000000000000000000000000000;;	func Decode(d Decoder, data []byte) (Object, error) {
0000000000000000000000000000000000000000;;		obj, _, err := d.Decode(data, nil, nil)
0000000000000000000000000000000000000000;;		return obj, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeInto performs a Decode into the provided object.
0000000000000000000000000000000000000000;;	func DecodeInto(d Decoder, data []byte, into Object) error {
0000000000000000000000000000000000000000;;		out, gvk, err := d.Decode(data, nil, into)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out != into {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to decode %s into %v", gvk, reflect.TypeOf(into))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeOrDie is a version of Encode which will panic instead of returning an error. For tests.
0000000000000000000000000000000000000000;;	func EncodeOrDie(e Encoder, obj Object) string {
0000000000000000000000000000000000000000;;		bytes, err := Encode(e, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(bytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultingSerializer invokes defaulting after decoding.
0000000000000000000000000000000000000000;;	type DefaultingSerializer struct {
0000000000000000000000000000000000000000;;		Defaulter ObjectDefaulter
0000000000000000000000000000000000000000;;		Decoder   Decoder
0000000000000000000000000000000000000000;;		// Encoder is optional to allow this type to be used as both a Decoder and an Encoder
0000000000000000000000000000000000000000;;		Encoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode performs a decode and then allows the defaulter to act on the provided object.
0000000000000000000000000000000000000000;;	func (d DefaultingSerializer) Decode(data []byte, defaultGVK *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		obj, gvk, err := d.Decoder.Decode(data, defaultGVK, into)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return obj, gvk, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.Defaulter.Default(obj)
0000000000000000000000000000000000000000;;		return obj, gvk, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UseOrCreateObject returns obj if the canonical ObjectKind returned by the provided typer matches gvk, or
0000000000000000000000000000000000000000;;	// invokes the ObjectCreator to instantiate a new gvk. Returns an error if the typer cannot find the object.
0000000000000000000000000000000000000000;;	func UseOrCreateObject(t ObjectTyper, c ObjectCreater, gvk schema.GroupVersionKind, obj Object) (Object, error) {
0000000000000000000000000000000000000000;;		if obj != nil {
0000000000000000000000000000000000000000;;			kinds, _, err := t.ObjectKinds(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, kind := range kinds {
0000000000000000000000000000000000000000;;				if gvk == kind {
0000000000000000000000000000000000000000;;					return obj, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.New(gvk)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NoopEncoder converts an Decoder to a Serializer or Codec for code that expects them but only uses decoding.
0000000000000000000000000000000000000000;;	type NoopEncoder struct {
0000000000000000000000000000000000000000;;		Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Serializer = NoopEncoder{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n NoopEncoder) Encode(obj Object, w io.Writer) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("encoding is not allowed for this codec: %v", reflect.TypeOf(n.Decoder))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NoopDecoder converts an Encoder to a Serializer or Codec for code that expects them but only uses encoding.
0000000000000000000000000000000000000000;;	type NoopDecoder struct {
0000000000000000000000000000000000000000;;		Encoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Serializer = NoopDecoder{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n NoopDecoder) Decode(data []byte, gvk *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		return nil, nil, fmt.Errorf("decoding is not allowed for this codec: %v", reflect.TypeOf(n.Encoder))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewParameterCodec creates a ParameterCodec capable of transforming url values into versioned objects and back.
0000000000000000000000000000000000000000;;	func NewParameterCodec(scheme *Scheme) ParameterCodec {
0000000000000000000000000000000000000000;;		return &parameterCodec{
0000000000000000000000000000000000000000;;			typer:     scheme,
0000000000000000000000000000000000000000;;			convertor: scheme,
0000000000000000000000000000000000000000;;			creator:   scheme,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parameterCodec implements conversion to and from query parameters and objects.
0000000000000000000000000000000000000000;;	type parameterCodec struct {
0000000000000000000000000000000000000000;;		typer     ObjectTyper
0000000000000000000000000000000000000000;;		convertor ObjectConvertor
0000000000000000000000000000000000000000;;		creator   ObjectCreater
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ParameterCodec = &parameterCodec{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeParameters converts the provided url.Values into an object of type From with the kind of into, and then
0000000000000000000000000000000000000000;;	// converts that object to into (if necessary). Returns an error if the operation cannot be completed.
0000000000000000000000000000000000000000;;	func (c *parameterCodec) DecodeParameters(parameters url.Values, from schema.GroupVersion, into Object) error {
0000000000000000000000000000000000000000;;		if len(parameters) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		targetGVKs, _, err := c.typer.ObjectKinds(into)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range targetGVKs {
0000000000000000000000000000000000000000;;			if targetGVKs[i].GroupVersion() == from {
0000000000000000000000000000000000000000;;				return c.convertor.Convert(&parameters, into, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		input, err := c.creator.New(from.WithKind(targetGVKs[0].Kind))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.convertor.Convert(&parameters, input, nil); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.convertor.Convert(input, into, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeParameters converts the provided object into the to version, then converts that object to url.Values.
0000000000000000000000000000000000000000;;	// Returns an error if conversion is not possible.
0000000000000000000000000000000000000000;;	func (c *parameterCodec) EncodeParameters(obj Object, to schema.GroupVersion) (url.Values, error) {
0000000000000000000000000000000000000000;;		gvks, _, err := c.typer.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvk := gvks[0]
0000000000000000000000000000000000000000;;		if to != gvk.GroupVersion() {
0000000000000000000000000000000000000000;;			out, err := c.convertor.ConvertToVersion(obj, to)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj = out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return queryparams.Convert(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type base64Serializer struct {
0000000000000000000000000000000000000000;;		Encoder
0000000000000000000000000000000000000000;;		Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBase64Serializer(e Encoder, d Decoder) Serializer {
0000000000000000000000000000000000000000;;		return &base64Serializer{e, d}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s base64Serializer) Encode(obj Object, stream io.Writer) error {
0000000000000000000000000000000000000000;;		e := base64.NewEncoder(base64.StdEncoding, stream)
0000000000000000000000000000000000000000;;		err := s.Encoder.Encode(obj, e)
0000000000000000000000000000000000000000;;		e.Close()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s base64Serializer) Decode(data []byte, defaults *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		out := make([]byte, base64.StdEncoding.DecodedLen(len(data)))
0000000000000000000000000000000000000000;;		n, err := base64.StdEncoding.Decode(out, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.Decoder.Decode(out[:n], defaults, into)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SerializerInfoForMediaType returns the first info in types that has a matching media type (which cannot
0000000000000000000000000000000000000000;;	// include media-type parameters), or the first info with an empty media type, or false if no type matches.
0000000000000000000000000000000000000000;;	func SerializerInfoForMediaType(types []SerializerInfo, mediaType string) (SerializerInfo, bool) {
0000000000000000000000000000000000000000;;		for _, info := range types {
0000000000000000000000000000000000000000;;			if info.MediaType == mediaType {
0000000000000000000000000000000000000000;;				return info, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, info := range types {
0000000000000000000000000000000000000000;;			if len(info.MediaType) == 0 {
0000000000000000000000000000000000000000;;				return info, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return SerializerInfo{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// InternalGroupVersioner will always prefer the internal version for a given group version kind.
0000000000000000000000000000000000000000;;		InternalGroupVersioner GroupVersioner = internalGroupVersioner{}
0000000000000000000000000000000000000000;;		// DisabledGroupVersioner will reject all kinds passed to it.
0000000000000000000000000000000000000000;;		DisabledGroupVersioner GroupVersioner = disabledGroupVersioner{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type internalGroupVersioner struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KindForGroupVersionKinds returns an internal Kind if one is found, or converts the first provided kind to the internal version.
0000000000000000000000000000000000000000;;	func (internalGroupVersioner) KindForGroupVersionKinds(kinds []schema.GroupVersionKind) (schema.GroupVersionKind, bool) {
0000000000000000000000000000000000000000;;		for _, kind := range kinds {
0000000000000000000000000000000000000000;;			if kind.Version == APIVersionInternal {
0000000000000000000000000000000000000000;;				return kind, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, kind := range kinds {
0000000000000000000000000000000000000000;;			return schema.GroupVersionKind{Group: kind.Group, Version: APIVersionInternal, Kind: kind.Kind}, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return schema.GroupVersionKind{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type disabledGroupVersioner struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KindForGroupVersionKinds returns false for any input.
0000000000000000000000000000000000000000;;	func (disabledGroupVersioner) KindForGroupVersionKinds(kinds []schema.GroupVersionKind) (schema.GroupVersionKind, bool) {
0000000000000000000000000000000000000000;;		return schema.GroupVersionKind{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersioners implements GroupVersioner and resolves to the first exact match for any kind.
0000000000000000000000000000000000000000;;	type GroupVersioners []GroupVersioner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KindForGroupVersionKinds returns the first match of any of the group versioners, or false if no match occured.
0000000000000000000000000000000000000000;;	func (gvs GroupVersioners) KindForGroupVersionKinds(kinds []schema.GroupVersionKind) (schema.GroupVersionKind, bool) {
0000000000000000000000000000000000000000;;		for _, gv := range gvs {
0000000000000000000000000000000000000000;;			target, ok := gv.KindForGroupVersionKinds(kinds)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return target, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return schema.GroupVersionKind{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assert that schema.GroupVersion and GroupVersions implement GroupVersioner
0000000000000000000000000000000000000000;;	var _ GroupVersioner = schema.GroupVersion{}
0000000000000000000000000000000000000000;;	var _ GroupVersioner = schema.GroupVersions{}
0000000000000000000000000000000000000000;;	var _ GroupVersioner = multiGroupVersioner{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type multiGroupVersioner struct {
0000000000000000000000000000000000000000;;		target             schema.GroupVersion
0000000000000000000000000000000000000000;;		acceptedGroupKinds []schema.GroupKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMultiGroupVersioner returns the provided group version for any kind that matches one of the provided group kinds.
0000000000000000000000000000000000000000;;	// Kind may be empty in the provided group kind, in which case any kind will match.
0000000000000000000000000000000000000000;;	func NewMultiGroupVersioner(gv schema.GroupVersion, groupKinds ...schema.GroupKind) GroupVersioner {
0000000000000000000000000000000000000000;;		if len(groupKinds) == 0 || (len(groupKinds) == 1 && groupKinds[0].Group == gv.Group) {
0000000000000000000000000000000000000000;;			return gv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return multiGroupVersioner{target: gv, acceptedGroupKinds: groupKinds}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KindForGroupVersionKinds returns the target group version if any kind matches any of the original group kinds. It will
0000000000000000000000000000000000000000;;	// use the originating kind where possible.
0000000000000000000000000000000000000000;;	func (v multiGroupVersioner) KindForGroupVersionKinds(kinds []schema.GroupVersionKind) (schema.GroupVersionKind, bool) {
0000000000000000000000000000000000000000;;		for _, src := range kinds {
0000000000000000000000000000000000000000;;			for _, kind := range v.acceptedGroupKinds {
0000000000000000000000000000000000000000;;				if kind.Group != src.Group {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(kind.Kind) > 0 && kind.Kind != src.Kind {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return v.target.WithKind(src.Kind), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return schema.GroupVersionKind{}, false
0000000000000000000000000000000000000000;;	}
