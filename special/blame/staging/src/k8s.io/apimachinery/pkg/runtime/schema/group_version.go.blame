0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package schema
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseResourceArg takes the common style of string which may be either `resource.group.com` or `resource.version.group.com`
0000000000000000000000000000000000000000;;	// and parses it out into both possibilities.  This code takes no responsibility for knowing which representation was intended
0000000000000000000000000000000000000000;;	// but with a knowledge of all GroupVersions, calling code can take a very good guess.  If there are only two segments, then
0000000000000000000000000000000000000000;;	// `*GroupVersionResource` is nil.
0000000000000000000000000000000000000000;;	// `resource.group.com` -> `group=com, version=group, resource=resource` and `group=group.com, resource=resource`
0000000000000000000000000000000000000000;;	func ParseResourceArg(arg string) (*GroupVersionResource, GroupResource) {
0000000000000000000000000000000000000000;;		var gvr *GroupVersionResource
0000000000000000000000000000000000000000;;		if strings.Count(arg, ".") >= 2 {
0000000000000000000000000000000000000000;;			s := strings.SplitN(arg, ".", 3)
0000000000000000000000000000000000000000;;			gvr = &GroupVersionResource{Group: s[2], Version: s[1], Resource: s[0]}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gvr, ParseGroupResource(arg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupResource specifies a Group and a Resource, but does not force a version.  This is useful for identifying
0000000000000000000000000000000000000000;;	// concepts during lookup stages without having partially valid types
0000000000000000000000000000000000000000;;	type GroupResource struct {
0000000000000000000000000000000000000000;;		Group    string
0000000000000000000000000000000000000000;;		Resource string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gr GroupResource) WithVersion(version string) GroupVersionResource {
0000000000000000000000000000000000000000;;		return GroupVersionResource{Group: gr.Group, Version: version, Resource: gr.Resource}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gr GroupResource) Empty() bool {
0000000000000000000000000000000000000000;;		return len(gr.Group) == 0 && len(gr.Resource) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gr *GroupResource) String() string {
0000000000000000000000000000000000000000;;		if len(gr.Group) == 0 {
0000000000000000000000000000000000000000;;			return gr.Resource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gr.Resource + "." + gr.Group
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseGroupResource turns "resource.group" string into a GroupResource struct.  Empty strings are allowed
0000000000000000000000000000000000000000;;	// for each field.
0000000000000000000000000000000000000000;;	func ParseGroupResource(gr string) GroupResource {
0000000000000000000000000000000000000000;;		if i := strings.Index(gr, "."); i == -1 {
0000000000000000000000000000000000000000;;			return GroupResource{Resource: gr}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return GroupResource{Group: gr[i+1:], Resource: gr[:i]}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersionResource unambiguously identifies a resource.  It doesn't anonymously include GroupVersion
0000000000000000000000000000000000000000;;	// to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling
0000000000000000000000000000000000000000;;	type GroupVersionResource struct {
0000000000000000000000000000000000000000;;		Group    string
0000000000000000000000000000000000000000;;		Version  string
0000000000000000000000000000000000000000;;		Resource string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gvr GroupVersionResource) Empty() bool {
0000000000000000000000000000000000000000;;		return len(gvr.Group) == 0 && len(gvr.Version) == 0 && len(gvr.Resource) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gvr GroupVersionResource) GroupResource() GroupResource {
0000000000000000000000000000000000000000;;		return GroupResource{Group: gvr.Group, Resource: gvr.Resource}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gvr GroupVersionResource) GroupVersion() GroupVersion {
0000000000000000000000000000000000000000;;		return GroupVersion{Group: gvr.Group, Version: gvr.Version}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gvr *GroupVersionResource) String() string {
0000000000000000000000000000000000000000;;		return strings.Join([]string{gvr.Group, "/", gvr.Version, ", Resource=", gvr.Resource}, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying
0000000000000000000000000000000000000000;;	// concepts during lookup stages without having partially valid types
0000000000000000000000000000000000000000;;	type GroupKind struct {
0000000000000000000000000000000000000000;;		Group string
0000000000000000000000000000000000000000;;		Kind  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gk GroupKind) Empty() bool {
0000000000000000000000000000000000000000;;		return len(gk.Group) == 0 && len(gk.Kind) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gk GroupKind) WithVersion(version string) GroupVersionKind {
0000000000000000000000000000000000000000;;		return GroupVersionKind{Group: gk.Group, Version: version, Kind: gk.Kind}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gk *GroupKind) String() string {
0000000000000000000000000000000000000000;;		if len(gk.Group) == 0 {
0000000000000000000000000000000000000000;;			return gk.Kind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gk.Kind + "." + gk.Group
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersionKind unambiguously identifies a kind.  It doesn't anonymously include GroupVersion
0000000000000000000000000000000000000000;;	// to avoid automatic coercion.  It doesn't use a GroupVersion to avoid custom marshalling
0000000000000000000000000000000000000000;;	type GroupVersionKind struct {
0000000000000000000000000000000000000000;;		Group   string
0000000000000000000000000000000000000000;;		Version string
0000000000000000000000000000000000000000;;		Kind    string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty returns true if group, version, and kind are empty
0000000000000000000000000000000000000000;;	func (gvk GroupVersionKind) Empty() bool {
0000000000000000000000000000000000000000;;		return len(gvk.Group) == 0 && len(gvk.Version) == 0 && len(gvk.Kind) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gvk GroupVersionKind) GroupKind() GroupKind {
0000000000000000000000000000000000000000;;		return GroupKind{Group: gvk.Group, Kind: gvk.Kind}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gvk GroupVersionKind) GroupVersion() GroupVersion {
0000000000000000000000000000000000000000;;		return GroupVersion{Group: gvk.Group, Version: gvk.Version}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gvk GroupVersionKind) String() string {
0000000000000000000000000000000000000000;;		return gvk.Group + "/" + gvk.Version + ", Kind=" + gvk.Kind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersion contains the "group" and the "version", which uniquely identifies the API.
0000000000000000000000000000000000000000;;	type GroupVersion struct {
0000000000000000000000000000000000000000;;		Group   string
0000000000000000000000000000000000000000;;		Version string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty returns true if group and version are empty
0000000000000000000000000000000000000000;;	func (gv GroupVersion) Empty() bool {
0000000000000000000000000000000000000000;;		return len(gv.Group) == 0 && len(gv.Version) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String puts "group" and "version" into a single "group/version" string. For the legacy v1
0000000000000000000000000000000000000000;;	// it returns "v1".
0000000000000000000000000000000000000000;;	func (gv GroupVersion) String() string {
0000000000000000000000000000000000000000;;		// special case the internal apiVersion for the legacy kube types
0000000000000000000000000000000000000000;;		if gv.Empty() {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// special case of "v1" for backward compatibility
0000000000000000000000000000000000000000;;		if len(gv.Group) == 0 && gv.Version == "v1" {
0000000000000000000000000000000000000000;;			return gv.Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(gv.Group) > 0 {
0000000000000000000000000000000000000000;;			return gv.Group + "/" + gv.Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gv.Version
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KindForGroupVersionKinds identifies the preferred GroupVersionKind out of a list. It returns ok false
0000000000000000000000000000000000000000;;	// if none of the options match the group. It prefers a match to group and version over just group.
0000000000000000000000000000000000000000;;	// TODO: Move GroupVersion to a package under pkg/runtime, since it's used by scheme.
0000000000000000000000000000000000000000;;	// TODO: Introduce an adapter type between GroupVersion and runtime.GroupVersioner, and use LegacyCodec(GroupVersion)
0000000000000000000000000000000000000000;;	//   in fewer places.
0000000000000000000000000000000000000000;;	func (gv GroupVersion) KindForGroupVersionKinds(kinds []GroupVersionKind) (target GroupVersionKind, ok bool) {
0000000000000000000000000000000000000000;;		for _, gvk := range kinds {
0000000000000000000000000000000000000000;;			if gvk.Group == gv.Group && gvk.Version == gv.Version {
0000000000000000000000000000000000000000;;				return gvk, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, gvk := range kinds {
0000000000000000000000000000000000000000;;			if gvk.Group == gv.Group {
0000000000000000000000000000000000000000;;				return gv.WithKind(gvk.Kind), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GroupVersionKind{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseGroupVersion turns "group/version" string into a GroupVersion struct. It reports error
0000000000000000000000000000000000000000;;	// if it cannot parse the string.
0000000000000000000000000000000000000000;;	func ParseGroupVersion(gv string) (GroupVersion, error) {
0000000000000000000000000000000000000000;;		// this can be the internal version for the legacy kube types
0000000000000000000000000000000000000000;;		// TODO once we've cleared the last uses as strings, this special case should be removed.
0000000000000000000000000000000000000000;;		if (len(gv) == 0) || (gv == "/") {
0000000000000000000000000000000000000000;;			return GroupVersion{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch strings.Count(gv, "/") {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return GroupVersion{"", gv}, nil
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			i := strings.Index(gv, "/")
0000000000000000000000000000000000000000;;			return GroupVersion{gv[:i], gv[i+1:]}, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return GroupVersion{}, fmt.Errorf("unexpected GroupVersion string: %v", gv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithKind creates a GroupVersionKind based on the method receiver's GroupVersion and the passed Kind.
0000000000000000000000000000000000000000;;	func (gv GroupVersion) WithKind(kind string) GroupVersionKind {
0000000000000000000000000000000000000000;;		return GroupVersionKind{Group: gv.Group, Version: gv.Version, Kind: kind}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithResource creates a GroupVersionResource based on the method receiver's GroupVersion and the passed Resource.
0000000000000000000000000000000000000000;;	func (gv GroupVersion) WithResource(resource string) GroupVersionResource {
0000000000000000000000000000000000000000;;		return GroupVersionResource{Group: gv.Group, Version: gv.Version, Resource: resource}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersions can be used to represent a set of desired group versions.
0000000000000000000000000000000000000000;;	// TODO: Move GroupVersions to a package under pkg/runtime, since it's used by scheme.
0000000000000000000000000000000000000000;;	// TODO: Introduce an adapter type between GroupVersions and runtime.GroupVersioner, and use LegacyCodec(GroupVersion)
0000000000000000000000000000000000000000;;	//   in fewer places.
0000000000000000000000000000000000000000;;	type GroupVersions []GroupVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KindForGroupVersionKinds identifies the preferred GroupVersionKind out of a list. It returns ok false
0000000000000000000000000000000000000000;;	// if none of the options match the group.
0000000000000000000000000000000000000000;;	func (gvs GroupVersions) KindForGroupVersionKinds(kinds []GroupVersionKind) (GroupVersionKind, bool) {
0000000000000000000000000000000000000000;;		var targets []GroupVersionKind
0000000000000000000000000000000000000000;;		for _, gv := range gvs {
0000000000000000000000000000000000000000;;			target, ok := gv.KindForGroupVersionKinds(kinds)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			targets = append(targets, target)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(targets) == 1 {
0000000000000000000000000000000000000000;;			return targets[0], true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(targets) > 1 {
0000000000000000000000000000000000000000;;			return bestMatch(kinds, targets), true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GroupVersionKind{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bestMatch tries to pick best matching GroupVersionKind and falls back to the first
0000000000000000000000000000000000000000;;	// found if no exact match exists.
0000000000000000000000000000000000000000;;	func bestMatch(kinds []GroupVersionKind, targets []GroupVersionKind) GroupVersionKind {
0000000000000000000000000000000000000000;;		for _, gvk := range targets {
0000000000000000000000000000000000000000;;			for _, k := range kinds {
0000000000000000000000000000000000000000;;				if k == gvk {
0000000000000000000000000000000000000000;;					return k
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return targets[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToAPIVersionAndKind is a convenience method for satisfying runtime.Object on types that
0000000000000000000000000000000000000000;;	// do not use TypeMeta.
0000000000000000000000000000000000000000;;	func (gvk *GroupVersionKind) ToAPIVersionAndKind() (string, string) {
0000000000000000000000000000000000000000;;		if gvk == nil {
0000000000000000000000000000000000000000;;			return "", ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gvk.GroupVersion().String(), gvk.Kind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromAPIVersionAndKind returns a GVK representing the provided fields for types that
0000000000000000000000000000000000000000;;	// do not use TypeMeta. This method exists to support test types and legacy serializations
0000000000000000000000000000000000000000;;	// that have a distinct group and kind.
0000000000000000000000000000000000000000;;	// TODO: further reduce usage of this method.
0000000000000000000000000000000000000000;;	func FromAPIVersionAndKind(apiVersion, kind string) GroupVersionKind {
0000000000000000000000000000000000000000;;		if gv, err := ParseGroupVersion(apiVersion); err == nil {
0000000000000000000000000000000000000000;;			return GroupVersionKind{Group: gv.Group, Version: gv.Version, Kind: kind}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GroupVersionKind{Kind: kind}
0000000000000000000000000000000000000000;;	}
