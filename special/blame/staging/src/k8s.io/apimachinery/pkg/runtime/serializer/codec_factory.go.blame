0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/json"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/recognizer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/versioning"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serializerExtensions are for serializers that are conditionally compiled in
0000000000000000000000000000000000000000;;	var serializerExtensions = []func(*runtime.Scheme) (serializerType, bool){}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serializerType struct {
0000000000000000000000000000000000000000;;		AcceptContentTypes []string
0000000000000000000000000000000000000000;;		ContentType        string
0000000000000000000000000000000000000000;;		FileExtensions     []string
0000000000000000000000000000000000000000;;		// EncodesAsText should be true if this content type can be represented safely in UTF-8
0000000000000000000000000000000000000000;;		EncodesAsText bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Serializer       runtime.Serializer
0000000000000000000000000000000000000000;;		PrettySerializer runtime.Serializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AcceptStreamContentTypes []string
0000000000000000000000000000000000000000;;		StreamContentType        string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Framer           runtime.Framer
0000000000000000000000000000000000000000;;		StreamSerializer runtime.Serializer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSerializersForScheme(scheme *runtime.Scheme, mf json.MetaFactory) []serializerType {
0000000000000000000000000000000000000000;;		jsonSerializer := json.NewSerializer(mf, scheme, scheme, false)
0000000000000000000000000000000000000000;;		jsonPrettySerializer := json.NewSerializer(mf, scheme, scheme, true)
0000000000000000000000000000000000000000;;		yamlSerializer := json.NewYAMLSerializer(mf, scheme, scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serializers := []serializerType{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				AcceptContentTypes: []string{"application/json"},
0000000000000000000000000000000000000000;;				ContentType:        "application/json",
0000000000000000000000000000000000000000;;				FileExtensions:     []string{"json"},
0000000000000000000000000000000000000000;;				EncodesAsText:      true,
0000000000000000000000000000000000000000;;				Serializer:         jsonSerializer,
0000000000000000000000000000000000000000;;				PrettySerializer:   jsonPrettySerializer,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				Framer:           json.Framer,
0000000000000000000000000000000000000000;;				StreamSerializer: jsonSerializer,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				AcceptContentTypes: []string{"application/yaml"},
0000000000000000000000000000000000000000;;				ContentType:        "application/yaml",
0000000000000000000000000000000000000000;;				FileExtensions:     []string{"yaml"},
0000000000000000000000000000000000000000;;				EncodesAsText:      true,
0000000000000000000000000000000000000000;;				Serializer:         yamlSerializer,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, fn := range serializerExtensions {
0000000000000000000000000000000000000000;;			if serializer, ok := fn(scheme); ok {
0000000000000000000000000000000000000000;;				serializers = append(serializers, serializer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return serializers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CodecFactory provides methods for retrieving codecs and serializers for specific
0000000000000000000000000000000000000000;;	// versions and content types.
0000000000000000000000000000000000000000;;	type CodecFactory struct {
0000000000000000000000000000000000000000;;		scheme      *runtime.Scheme
0000000000000000000000000000000000000000;;		serializers []serializerType
0000000000000000000000000000000000000000;;		universal   runtime.Decoder
0000000000000000000000000000000000000000;;		accepts     []runtime.SerializerInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		legacySerializer runtime.Serializer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCodecFactory provides methods for retrieving serializers for the supported wire formats
0000000000000000000000000000000000000000;;	// and conversion wrappers to define preferred internal and external versions. In the future,
0000000000000000000000000000000000000000;;	// as the internal version is used less, callers may instead use a defaulting serializer and
0000000000000000000000000000000000000000;;	// only convert objects which are shared internally (Status, common API machinery).
0000000000000000000000000000000000000000;;	// TODO: allow other codecs to be compiled in?
0000000000000000000000000000000000000000;;	// TODO: accept a scheme interface
0000000000000000000000000000000000000000;;	func NewCodecFactory(scheme *runtime.Scheme) CodecFactory {
0000000000000000000000000000000000000000;;		serializers := newSerializersForScheme(scheme, json.DefaultMetaFactory)
0000000000000000000000000000000000000000;;		return newCodecFactory(scheme, serializers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newCodecFactory is a helper for testing that allows a different metafactory to be specified.
0000000000000000000000000000000000000000;;	func newCodecFactory(scheme *runtime.Scheme, serializers []serializerType) CodecFactory {
0000000000000000000000000000000000000000;;		decoders := make([]runtime.Decoder, 0, len(serializers))
0000000000000000000000000000000000000000;;		var accepts []runtime.SerializerInfo
0000000000000000000000000000000000000000;;		alreadyAccepted := make(map[string]struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var legacySerializer runtime.Serializer
0000000000000000000000000000000000000000;;		for _, d := range serializers {
0000000000000000000000000000000000000000;;			decoders = append(decoders, d.Serializer)
0000000000000000000000000000000000000000;;			for _, mediaType := range d.AcceptContentTypes {
0000000000000000000000000000000000000000;;				if _, ok := alreadyAccepted[mediaType]; ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				alreadyAccepted[mediaType] = struct{}{}
0000000000000000000000000000000000000000;;				info := runtime.SerializerInfo{
0000000000000000000000000000000000000000;;					MediaType:        d.ContentType,
0000000000000000000000000000000000000000;;					EncodesAsText:    d.EncodesAsText,
0000000000000000000000000000000000000000;;					Serializer:       d.Serializer,
0000000000000000000000000000000000000000;;					PrettySerializer: d.PrettySerializer,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if d.StreamSerializer != nil {
0000000000000000000000000000000000000000;;					info.StreamSerializer = &runtime.StreamSerializerInfo{
0000000000000000000000000000000000000000;;						Serializer:    d.StreamSerializer,
0000000000000000000000000000000000000000;;						EncodesAsText: d.EncodesAsText,
0000000000000000000000000000000000000000;;						Framer:        d.Framer,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				accepts = append(accepts, info)
0000000000000000000000000000000000000000;;				if mediaType == runtime.ContentTypeJSON {
0000000000000000000000000000000000000000;;					legacySerializer = d.Serializer
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if legacySerializer == nil {
0000000000000000000000000000000000000000;;			legacySerializer = serializers[0].Serializer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return CodecFactory{
0000000000000000000000000000000000000000;;			scheme:      scheme,
0000000000000000000000000000000000000000;;			serializers: serializers,
0000000000000000000000000000000000000000;;			universal:   recognizer.NewDecoder(decoders...),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			accepts: accepts,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			legacySerializer: legacySerializer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SupportedMediaTypes returns the RFC2046 media types that this factory has serializers for.
0000000000000000000000000000000000000000;;	func (f CodecFactory) SupportedMediaTypes() []runtime.SerializerInfo {
0000000000000000000000000000000000000000;;		return f.accepts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LegacyCodec encodes output to a given API versions, and decodes output into the internal form from
0000000000000000000000000000000000000000;;	// any recognized source. The returned codec will always encode output to JSON. If a type is not
0000000000000000000000000000000000000000;;	// found in the list of versions an error will be returned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This method is deprecated - clients and servers should negotiate a serializer by mime-type and
0000000000000000000000000000000000000000;;	// invoke CodecForVersions. Callers that need only to read data should use UniversalDecoder().
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: make this call exist only in pkg/api, and initialize it with the set of default versions.
0000000000000000000000000000000000000000;;	//   All other callers will be forced to request a Codec directly.
0000000000000000000000000000000000000000;;	func (f CodecFactory) LegacyCodec(version ...schema.GroupVersion) runtime.Codec {
0000000000000000000000000000000000000000;;		return versioning.NewDefaultingCodecForScheme(f.scheme, f.legacySerializer, f.universal, schema.GroupVersions(version), runtime.InternalGroupVersioner)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UniversalDeserializer can convert any stored data recognized by this factory into a Go object that satisfies
0000000000000000000000000000000000000000;;	// runtime.Object. It does not perform conversion. It does not perform defaulting.
0000000000000000000000000000000000000000;;	func (f CodecFactory) UniversalDeserializer() runtime.Decoder {
0000000000000000000000000000000000000000;;		return f.universal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UniversalDecoder returns a runtime.Decoder capable of decoding all known API objects in all known formats. Used
0000000000000000000000000000000000000000;;	// by clients that do not need to encode objects but want to deserialize API objects stored on disk. Only decodes
0000000000000000000000000000000000000000;;	// objects in groups registered with the scheme. The GroupVersions passed may be used to select alternate
0000000000000000000000000000000000000000;;	// versions of objects to return - by default, runtime.APIVersionInternal is used. If any versions are specified,
0000000000000000000000000000000000000000;;	// unrecognized groups will be returned in the version they are encoded as (no conversion). This decoder performs
0000000000000000000000000000000000000000;;	// defaulting.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: the decoder will eventually be removed in favor of dealing with objects in their versioned form
0000000000000000000000000000000000000000;;	// TODO: only accept a group versioner
0000000000000000000000000000000000000000;;	func (f CodecFactory) UniversalDecoder(versions ...schema.GroupVersion) runtime.Decoder {
0000000000000000000000000000000000000000;;		var versioner runtime.GroupVersioner
0000000000000000000000000000000000000000;;		if len(versions) == 0 {
0000000000000000000000000000000000000000;;			versioner = runtime.InternalGroupVersioner
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			versioner = schema.GroupVersions(versions)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.CodecForVersions(nil, f.universal, nil, versioner)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CodecForVersions creates a codec with the provided serializer. If an object is decoded and its group is not in the list,
0000000000000000000000000000000000000000;;	// it will default to runtime.APIVersionInternal. If encode is not specified for an object's group, the object is not
0000000000000000000000000000000000000000;;	// converted. If encode or decode are nil, no conversion is performed.
0000000000000000000000000000000000000000;;	func (f CodecFactory) CodecForVersions(encoder runtime.Encoder, decoder runtime.Decoder, encode runtime.GroupVersioner, decode runtime.GroupVersioner) runtime.Codec {
0000000000000000000000000000000000000000;;		// TODO: these are for backcompat, remove them in the future
0000000000000000000000000000000000000000;;		if encode == nil {
0000000000000000000000000000000000000000;;			encode = runtime.DisabledGroupVersioner
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if decode == nil {
0000000000000000000000000000000000000000;;			decode = runtime.InternalGroupVersioner
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return versioning.NewDefaultingCodecForScheme(f.scheme, encoder, decoder, encode, decode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecoderToVersion returns a decoder that targets the provided group version.
0000000000000000000000000000000000000000;;	func (f CodecFactory) DecoderToVersion(decoder runtime.Decoder, gv runtime.GroupVersioner) runtime.Decoder {
0000000000000000000000000000000000000000;;		return f.CodecForVersions(nil, decoder, nil, gv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncoderForVersion returns an encoder that targets the provided group version.
0000000000000000000000000000000000000000;;	func (f CodecFactory) EncoderForVersion(encoder runtime.Encoder, gv runtime.GroupVersioner) runtime.Encoder {
0000000000000000000000000000000000000000;;		return f.CodecForVersions(encoder, nil, gv, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirectCodecFactory provides methods for retrieving "DirectCodec"s, which do not do conversion.
0000000000000000000000000000000000000000;;	type DirectCodecFactory struct {
0000000000000000000000000000000000000000;;		CodecFactory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncoderForVersion returns an encoder that does not do conversion.
0000000000000000000000000000000000000000;;	func (f DirectCodecFactory) EncoderForVersion(serializer runtime.Encoder, version runtime.GroupVersioner) runtime.Encoder {
0000000000000000000000000000000000000000;;		return versioning.DirectEncoder{
0000000000000000000000000000000000000000;;			Version:     version,
0000000000000000000000000000000000000000;;			Encoder:     serializer,
0000000000000000000000000000000000000000;;			ObjectTyper: f.CodecFactory.scheme,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecoderToVersion returns an decoder that does not do conversion. gv is ignored.
0000000000000000000000000000000000000000;;	func (f DirectCodecFactory) DecoderToVersion(serializer runtime.Decoder, _ runtime.GroupVersioner) runtime.Decoder {
0000000000000000000000000000000000000000;;		return versioning.DirectDecoder{
0000000000000000000000000000000000000000;;			Decoder: serializer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
