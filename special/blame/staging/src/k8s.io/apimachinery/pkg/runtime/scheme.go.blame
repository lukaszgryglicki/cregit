0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package runtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scheme defines methods for serializing and deserializing API objects, a type
0000000000000000000000000000000000000000;;	// registry for converting group, version, and kind information to and from Go
0000000000000000000000000000000000000000;;	// schemas, and mappings between Go schemas of different versions. A scheme is the
0000000000000000000000000000000000000000;;	// foundation for a versioned API and versioned configuration over time.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In a Scheme, a Type is a particular Go struct, a Version is a point-in-time
0000000000000000000000000000000000000000;;	// identifier for a particular representation of that Type (typically backwards
0000000000000000000000000000000000000000;;	// compatible), a Kind is the unique name for that Type within the Version, and a
0000000000000000000000000000000000000000;;	// Group identifies a set of Versions, Kinds, and Types that evolve over time. An
0000000000000000000000000000000000000000;;	// Unversioned Type is one that is not yet formally bound to a type and is promised
0000000000000000000000000000000000000000;;	// to be backwards compatible (effectively a "v1" of a Type that does not expect
0000000000000000000000000000000000000000;;	// to break in the future).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Schemes are not expected to change at runtime and are only threadsafe after
0000000000000000000000000000000000000000;;	// registration is complete.
0000000000000000000000000000000000000000;;	type Scheme struct {
0000000000000000000000000000000000000000;;		// versionMap allows one to figure out the go type of an object with
0000000000000000000000000000000000000000;;		// the given version and name.
0000000000000000000000000000000000000000;;		gvkToType map[schema.GroupVersionKind]reflect.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// typeToGroupVersion allows one to find metadata for a given go object.
0000000000000000000000000000000000000000;;		// The reflect.Type we index by should *not* be a pointer.
0000000000000000000000000000000000000000;;		typeToGVK map[reflect.Type][]schema.GroupVersionKind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unversionedTypes are transformed without conversion in ConvertToVersion.
0000000000000000000000000000000000000000;;		unversionedTypes map[reflect.Type]schema.GroupVersionKind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unversionedKinds are the names of kinds that can be created in the context of any group
0000000000000000000000000000000000000000;;		// or version
0000000000000000000000000000000000000000;;		// TODO: resolve the status of unversioned types.
0000000000000000000000000000000000000000;;		unversionedKinds map[string]reflect.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map from version and resource to the corresponding func to convert
0000000000000000000000000000000000000000;;		// resource field labels in that version to internal version.
0000000000000000000000000000000000000000;;		fieldLabelConversionFuncs map[string]map[string]FieldLabelConversionFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// defaulterFuncs is an array of interfaces to be called with an object to provide defaulting
0000000000000000000000000000000000000000;;		// the provided object must be a pointer.
0000000000000000000000000000000000000000;;		defaulterFuncs map[reflect.Type]func(interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// converter stores all registered conversion functions. It also has
0000000000000000000000000000000000000000;;		// default coverting behavior.
0000000000000000000000000000000000000000;;		converter *conversion.Converter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cloner stores all registered copy functions. It also has default
0000000000000000000000000000000000000000;;		// deep copy behavior.
0000000000000000000000000000000000000000;;		cloner *conversion.Cloner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function to convert a field selector to internal representation.
0000000000000000000000000000000000000000;;	type FieldLabelConversionFunc func(label, value string) (internalLabel, internalValue string, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewScheme creates a new Scheme. This scheme is pluggable by default.
0000000000000000000000000000000000000000;;	func NewScheme() *Scheme {
0000000000000000000000000000000000000000;;		s := &Scheme{
0000000000000000000000000000000000000000;;			gvkToType:        map[schema.GroupVersionKind]reflect.Type{},
0000000000000000000000000000000000000000;;			typeToGVK:        map[reflect.Type][]schema.GroupVersionKind{},
0000000000000000000000000000000000000000;;			unversionedTypes: map[reflect.Type]schema.GroupVersionKind{},
0000000000000000000000000000000000000000;;			unversionedKinds: map[string]reflect.Type{},
0000000000000000000000000000000000000000;;			cloner:           conversion.NewCloner(),
0000000000000000000000000000000000000000;;			fieldLabelConversionFuncs: map[string]map[string]FieldLabelConversionFunc{},
0000000000000000000000000000000000000000;;			defaulterFuncs:            map[reflect.Type]func(interface{}){},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.converter = conversion.NewConverter(s.nameFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.AddConversionFuncs(DefaultEmbeddedConversions()...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Enable map[string][]string conversions by default
0000000000000000000000000000000000000000;;		if err := s.AddConversionFuncs(DefaultStringConversions...); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.RegisterInputDefaults(&map[string][]string{}, JSONKeyMapper, conversion.AllowDifferentFieldTypeNames|conversion.IgnoreMissingFields); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.RegisterInputDefaults(&url.Values{}, JSONKeyMapper, conversion.AllowDifferentFieldTypeNames|conversion.IgnoreMissingFields); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nameFunc returns the name of the type that we wish to use to determine when two types attempt
0000000000000000000000000000000000000000;;	// a conversion. Defaults to the go name of the type if the type is not registered.
0000000000000000000000000000000000000000;;	func (s *Scheme) nameFunc(t reflect.Type) string {
0000000000000000000000000000000000000000;;		// find the preferred names for this type
0000000000000000000000000000000000000000;;		gvks, ok := s.typeToGVK[t]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return t.Name()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, gvk := range gvks {
0000000000000000000000000000000000000000;;			internalGV := gvk.GroupVersion()
0000000000000000000000000000000000000000;;			internalGV.Version = "__internal" // this is hacky and maybe should be passed in
0000000000000000000000000000000000000000;;			internalGVK := internalGV.WithKind(gvk.Kind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if internalType, exists := s.gvkToType[internalGVK]; exists {
0000000000000000000000000000000000000000;;				return s.typeToGVK[internalType][0].Kind
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gvks[0].Kind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fromScope gets the input version, desired output version, and desired Scheme
0000000000000000000000000000000000000000;;	// from a conversion.Scope.
0000000000000000000000000000000000000000;;	func (s *Scheme) fromScope(scope conversion.Scope) *Scheme {
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converter allows access to the converter for the scheme
0000000000000000000000000000000000000000;;	func (s *Scheme) Converter() *conversion.Converter {
0000000000000000000000000000000000000000;;		return s.converter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddUnversionedTypes registers the provided types as "unversioned", which means that they follow special rules.
0000000000000000000000000000000000000000;;	// Whenever an object of this type is serialized, it is serialized with the provided group version and is not
0000000000000000000000000000000000000000;;	// converted. Thus unversioned objects are expected to remain backwards compatible forever, as if they were in an
0000000000000000000000000000000000000000;;	// API group and version that would never be updated.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: there is discussion about removing unversioned and replacing it with objects that are manifest into
0000000000000000000000000000000000000000;;	//   every version with particular schemas. Resolve this method at that point.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddUnversionedTypes(version schema.GroupVersion, types ...Object) {
0000000000000000000000000000000000000000;;		s.AddKnownTypes(version, types...)
0000000000000000000000000000000000000000;;		for _, obj := range types {
0000000000000000000000000000000000000000;;			t := reflect.TypeOf(obj).Elem()
0000000000000000000000000000000000000000;;			gvk := version.WithKind(t.Name())
0000000000000000000000000000000000000000;;			s.unversionedTypes[t] = gvk
0000000000000000000000000000000000000000;;			if old, ok := s.unversionedKinds[gvk.Kind]; ok && t != old {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("%v.%v has already been registered as unversioned kind %q - kind name must be unique", old.PkgPath(), old.Name(), gvk))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.unversionedKinds[gvk.Kind] = t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddKnownTypes registers all types passed in 'types' as being members of version 'version'.
0000000000000000000000000000000000000000;;	// All objects passed to types should be pointers to structs. The name that go reports for
0000000000000000000000000000000000000000;;	// the struct becomes the "kind" field when encoding. Version may not be empty - use the
0000000000000000000000000000000000000000;;	// APIVersionInternal constant if you have a type that does not have a formal version.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddKnownTypes(gv schema.GroupVersion, types ...Object) {
0000000000000000000000000000000000000000;;		for _, obj := range types {
0000000000000000000000000000000000000000;;			t := reflect.TypeOf(obj)
0000000000000000000000000000000000000000;;			if t.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;				panic("All types must be pointers to structs.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;			s.AddKnownTypeWithName(gv.WithKind(t.Name()), obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddKnownTypeWithName is like AddKnownTypes, but it lets you specify what this type should
0000000000000000000000000000000000000000;;	// be encoded as. Useful for testing when you don't want to make multiple packages to define
0000000000000000000000000000000000000000;;	// your structs. Version may not be empty - use the APIVersionInternal constant if you have a
0000000000000000000000000000000000000000;;	// type that does not have a formal version.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddKnownTypeWithName(gvk schema.GroupVersionKind, obj Object) {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(obj)
0000000000000000000000000000000000000000;;		if len(gvk.Version) == 0 {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("version is required on all types: %s %v", gvk, t))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			panic("All types must be pointers to structs.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t = t.Elem()
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			panic("All types must be pointers to structs.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldT, found := s.gvkToType[gvk]; found && oldT != t {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("Double registration of different types for %v: old=%v.%v, new=%v.%v", gvk, oldT.PkgPath(), oldT.Name(), t.PkgPath(), t.Name()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.gvkToType[gvk] = t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, existingGvk := range s.typeToGVK[t] {
0000000000000000000000000000000000000000;;			if existingGvk == gvk {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.typeToGVK[t] = append(s.typeToGVK[t], gvk)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KnownTypes returns the types known for the given version.
0000000000000000000000000000000000000000;;	func (s *Scheme) KnownTypes(gv schema.GroupVersion) map[string]reflect.Type {
0000000000000000000000000000000000000000;;		types := make(map[string]reflect.Type)
0000000000000000000000000000000000000000;;		for gvk, t := range s.gvkToType {
0000000000000000000000000000000000000000;;			if gv != gvk.GroupVersion() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			types[gvk.Kind] = t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return types
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllKnownTypes returns the all known types.
0000000000000000000000000000000000000000;;	func (s *Scheme) AllKnownTypes() map[schema.GroupVersionKind]reflect.Type {
0000000000000000000000000000000000000000;;		return s.gvkToType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectKind returns the group,version,kind of the go object and true if this object
0000000000000000000000000000000000000000;;	// is considered unversioned, or an error if it's not a pointer or is unregistered.
0000000000000000000000000000000000000000;;	func (s *Scheme) ObjectKind(obj Object) (schema.GroupVersionKind, bool, error) {
0000000000000000000000000000000000000000;;		gvks, unversionedType, err := s.ObjectKinds(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionKind{}, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gvks[0], unversionedType, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectKinds returns all possible group,version,kind of the go object, true if the
0000000000000000000000000000000000000000;;	// object is considered unversioned, or an error if it's not a pointer or is unregistered.
0000000000000000000000000000000000000000;;	func (s *Scheme) ObjectKinds(obj Object) ([]schema.GroupVersionKind, bool, error) {
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := v.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gvks, ok := s.typeToGVK[t]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, false, NewNotRegisteredErrForType(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, unversionedType := s.unversionedTypes[t]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gvks, unversionedType, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recognizes returns true if the scheme is able to handle the provided group,version,kind
0000000000000000000000000000000000000000;;	// of an object.
0000000000000000000000000000000000000000;;	func (s *Scheme) Recognizes(gvk schema.GroupVersionKind) bool {
0000000000000000000000000000000000000000;;		_, exists := s.gvkToType[gvk]
0000000000000000000000000000000000000000;;		return exists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Scheme) IsUnversioned(obj Object) (bool, bool) {
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := v.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := s.typeToGVK[t]; !ok {
0000000000000000000000000000000000000000;;			return false, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := s.unversionedTypes[t]
0000000000000000000000000000000000000000;;		return ok, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new API object of the given version and name, or an error if it hasn't
0000000000000000000000000000000000000000;;	// been registered. The version and kind fields must be specified.
0000000000000000000000000000000000000000;;	func (s *Scheme) New(kind schema.GroupVersionKind) (Object, error) {
0000000000000000000000000000000000000000;;		if t, exists := s.gvkToType[kind]; exists {
0000000000000000000000000000000000000000;;			return reflect.New(t).Interface().(Object), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t, exists := s.unversionedKinds[kind.Kind]; exists {
0000000000000000000000000000000000000000;;			return reflect.New(t).Interface().(Object), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, NewNotRegisteredErrForKind(kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddGenericConversionFunc adds a function that accepts the ConversionFunc call pattern
0000000000000000000000000000000000000000;;	// (for two conversion types) to the converter. These functions are checked first during
0000000000000000000000000000000000000000;;	// a normal conversion, but are otherwise not called. Use AddConversionFuncs when registering
0000000000000000000000000000000000000000;;	// typed conversions.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddGenericConversionFunc(fn conversion.GenericConversionFunc) {
0000000000000000000000000000000000000000;;		s.converter.AddGenericConversionFunc(fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Log sets a logger on the scheme. For test purposes only
0000000000000000000000000000000000000000;;	func (s *Scheme) Log(l conversion.DebugLogger) {
0000000000000000000000000000000000000000;;		s.converter.Debug = l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddIgnoredConversionType identifies a pair of types that should be skipped by
0000000000000000000000000000000000000000;;	// conversion (because the data inside them is explicitly dropped during
0000000000000000000000000000000000000000;;	// conversion).
0000000000000000000000000000000000000000;;	func (s *Scheme) AddIgnoredConversionType(from, to interface{}) error {
0000000000000000000000000000000000000000;;		return s.converter.RegisterIgnoredConversion(from, to)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddConversionFuncs adds functions to the list of conversion functions. The given
0000000000000000000000000000000000000000;;	// functions should know how to convert between two of your API objects, or their
0000000000000000000000000000000000000000;;	// sub-objects. We deduce how to call these functions from the types of their two
0000000000000000000000000000000000000000;;	// parameters; see the comment for Converter.Register.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that, if you need to copy sub-objects that didn't change, you can use the
0000000000000000000000000000000000000000;;	// conversion.Scope object that will be passed to your conversion function.
0000000000000000000000000000000000000000;;	// Additionally, all conversions started by Scheme will set the SrcVersion and
0000000000000000000000000000000000000000;;	// DestVersion fields on the Meta object. Example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// s.AddConversionFuncs(
0000000000000000000000000000000000000000;;	//	func(in *InternalObject, out *ExternalObject, scope conversion.Scope) error {
0000000000000000000000000000000000000000;;	//		// You can depend on Meta() being non-nil, and this being set to
0000000000000000000000000000000000000000;;	//		// the source version, e.g., ""
0000000000000000000000000000000000000000;;	//		s.Meta().SrcVersion
0000000000000000000000000000000000000000;;	//		// You can depend on this being set to the destination version,
0000000000000000000000000000000000000000;;	//		// e.g., "v1".
0000000000000000000000000000000000000000;;	//		s.Meta().DestVersion
0000000000000000000000000000000000000000;;	//		// Call scope.Convert to copy sub-fields.
0000000000000000000000000000000000000000;;	//		s.Convert(&in.SubFieldThatMoved, &out.NewLocation.NewName, 0)
0000000000000000000000000000000000000000;;	//		return nil
0000000000000000000000000000000000000000;;	//	},
0000000000000000000000000000000000000000;;	// )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// (For more detail about conversion functions, see Converter.Register's comment.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Also note that the default behavior, if you don't add a conversion function, is to
0000000000000000000000000000000000000000;;	// sanely copy fields that have the same names and same type names. It's OK if the
0000000000000000000000000000000000000000;;	// destination type has extra fields, but it must not remove any. So you only need to
0000000000000000000000000000000000000000;;	// add conversion functions for things with changed/removed fields.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddConversionFuncs(conversionFuncs ...interface{}) error {
0000000000000000000000000000000000000000;;		for _, f := range conversionFuncs {
0000000000000000000000000000000000000000;;			if err := s.converter.RegisterConversionFunc(f); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Similar to AddConversionFuncs, but registers conversion functions that were
0000000000000000000000000000000000000000;;	// automatically generated.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddGeneratedConversionFuncs(conversionFuncs ...interface{}) error {
0000000000000000000000000000000000000000;;		for _, f := range conversionFuncs {
0000000000000000000000000000000000000000;;			if err := s.converter.RegisterGeneratedConversionFunc(f); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddDeepCopyFuncs adds a function to the list of deep-copy functions.
0000000000000000000000000000000000000000;;	// For the expected format of deep-copy function, see the comment for
0000000000000000000000000000000000000000;;	// Copier.RegisterDeepCopyFunction.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddDeepCopyFuncs(deepCopyFuncs ...interface{}) error {
0000000000000000000000000000000000000000;;		for _, f := range deepCopyFuncs {
0000000000000000000000000000000000000000;;			if err := s.cloner.RegisterDeepCopyFunc(f); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Similar to AddDeepCopyFuncs, but registers deep-copy functions that were
0000000000000000000000000000000000000000;;	// automatically generated.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddGeneratedDeepCopyFuncs(deepCopyFuncs ...conversion.GeneratedDeepCopyFunc) error {
0000000000000000000000000000000000000000;;		for _, fn := range deepCopyFuncs {
0000000000000000000000000000000000000000;;			if err := s.cloner.RegisterGeneratedDeepCopyFunc(fn); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFieldLabelConversionFunc adds a conversion function to convert field selectors
0000000000000000000000000000000000000000;;	// of the given kind from the given version to internal version representation.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddFieldLabelConversionFunc(version, kind string, conversionFunc FieldLabelConversionFunc) error {
0000000000000000000000000000000000000000;;		if s.fieldLabelConversionFuncs[version] == nil {
0000000000000000000000000000000000000000;;			s.fieldLabelConversionFuncs[version] = map[string]FieldLabelConversionFunc{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.fieldLabelConversionFuncs[version][kind] = conversionFunc
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddStructFieldConversion allows you to specify a mechanical copy for a moved
0000000000000000000000000000000000000000;;	// or renamed struct field without writing an entire conversion function. See
0000000000000000000000000000000000000000;;	// the comment in conversion.Converter.SetStructFieldCopy for parameter details.
0000000000000000000000000000000000000000;;	// Call as many times as needed, even on the same fields.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddStructFieldConversion(srcFieldType interface{}, srcFieldName string, destFieldType interface{}, destFieldName string) error {
0000000000000000000000000000000000000000;;		return s.converter.SetStructFieldCopy(srcFieldType, srcFieldName, destFieldType, destFieldName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterInputDefaults sets the provided field mapping function and field matching
0000000000000000000000000000000000000000;;	// as the defaults for the provided input type.  The fn may be nil, in which case no
0000000000000000000000000000000000000000;;	// mapping will happen by default. Use this method to register a mechanism for handling
0000000000000000000000000000000000000000;;	// a specific input type in conversion, such as a map[string]string to structs.
0000000000000000000000000000000000000000;;	func (s *Scheme) RegisterInputDefaults(in interface{}, fn conversion.FieldMappingFunc, defaultFlags conversion.FieldMatchingFlags) error {
0000000000000000000000000000000000000000;;		return s.converter.RegisterInputDefaults(in, fn, defaultFlags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddTypeDefaultingFuncs registers a function that is passed a pointer to an
0000000000000000000000000000000000000000;;	// object and can default fields on the object. These functions will be invoked
0000000000000000000000000000000000000000;;	// when Default() is called. The function will never be called unless the
0000000000000000000000000000000000000000;;	// defaulted object matches srcType. If this function is invoked twice with the
0000000000000000000000000000000000000000;;	// same srcType, the fn passed to the later call will be used instead.
0000000000000000000000000000000000000000;;	func (s *Scheme) AddTypeDefaultingFunc(srcType Object, fn func(interface{})) {
0000000000000000000000000000000000000000;;		s.defaulterFuncs[reflect.TypeOf(srcType)] = fn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Default sets defaults on the provided Object.
0000000000000000000000000000000000000000;;	func (s *Scheme) Default(src Object) {
0000000000000000000000000000000000000000;;		if fn, ok := s.defaulterFuncs[reflect.TypeOf(src)]; ok {
0000000000000000000000000000000000000000;;			fn(src)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy does a deep copy of an API object.
0000000000000000000000000000000000000000;;	func (s *Scheme) Copy(src Object) (Object, error) {
0000000000000000000000000000000000000000;;		dst, err := s.DeepCopy(src)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dst.(Object), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Performs a deep copy of the given object.
0000000000000000000000000000000000000000;;	func (s *Scheme) DeepCopy(src interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		return s.cloner.DeepCopy(src)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert will attempt to convert in into out. Both must be pointers. For easy
0000000000000000000000000000000000000000;;	// testing of conversion functions. Returns an error if the conversion isn't
0000000000000000000000000000000000000000;;	// possible. You can call this with types that haven't been registered (for example,
0000000000000000000000000000000000000000;;	// a to test conversion of types that are nested within registered types). The
0000000000000000000000000000000000000000;;	// context interface is passed to the convertor.
0000000000000000000000000000000000000000;;	// TODO: identify whether context should be hidden, or behind a formal context/scope
0000000000000000000000000000000000000000;;	//   interface
0000000000000000000000000000000000000000;;	func (s *Scheme) Convert(in, out interface{}, context interface{}) error {
0000000000000000000000000000000000000000;;		flags, meta := s.generateConvertMeta(in)
0000000000000000000000000000000000000000;;		meta.Context = context
0000000000000000000000000000000000000000;;		if flags == 0 {
0000000000000000000000000000000000000000;;			flags = conversion.AllowDifferentFieldTypeNames
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.converter.Convert(in, out, flags, meta)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converts the given field label and value for an kind field selector from
0000000000000000000000000000000000000000;;	// versioned representation to an unversioned one.
0000000000000000000000000000000000000000;;	func (s *Scheme) ConvertFieldLabel(version, kind, label, value string) (string, string, error) {
0000000000000000000000000000000000000000;;		if s.fieldLabelConversionFuncs[version] == nil {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("No field label conversion function found for version: %s", version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conversionFunc, ok := s.fieldLabelConversionFuncs[version][kind]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("No field label conversion function found for version %s and kind %s", version, kind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conversionFunc(label, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertToVersion attempts to convert an input object to its matching Kind in another
0000000000000000000000000000000000000000;;	// version within this scheme. Will return an error if the provided version does not
0000000000000000000000000000000000000000;;	// contain the inKind (or a mapping by name defined with AddKnownTypeWithName). Will also
0000000000000000000000000000000000000000;;	// return an error if the conversion does not result in a valid Object being
0000000000000000000000000000000000000000;;	// returned. Passes target down to the conversion methods as the Context on the scope.
0000000000000000000000000000000000000000;;	func (s *Scheme) ConvertToVersion(in Object, target GroupVersioner) (Object, error) {
0000000000000000000000000000000000000000;;		return s.convertToVersion(true, in, target)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsafeConvertToVersion will convert in to the provided target if such a conversion is possible,
0000000000000000000000000000000000000000;;	// but does not guarantee the output object does not share fields with the input object. It attempts to be as
0000000000000000000000000000000000000000;;	// efficient as possible when doing conversion.
0000000000000000000000000000000000000000;;	func (s *Scheme) UnsafeConvertToVersion(in Object, target GroupVersioner) (Object, error) {
0000000000000000000000000000000000000000;;		return s.convertToVersion(false, in, target)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertToVersion handles conversion with an optional copy.
0000000000000000000000000000000000000000;;	func (s *Scheme) convertToVersion(copy bool, in Object, target GroupVersioner) (Object, error) {
0000000000000000000000000000000000000000;;		// determine the incoming kinds with as few allocations as possible.
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(in)
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("only pointer types may be converted: %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t = t.Elem()
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("only pointers to struct types may be converted: %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kinds, ok := s.typeToGVK[t]
0000000000000000000000000000000000000000;;		if !ok || len(kinds) == 0 {
0000000000000000000000000000000000000000;;			return nil, NewNotRegisteredErrForType(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gvk, ok := target.KindForGroupVersionKinds(kinds)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// try to see if this type is listed as unversioned (for legacy support)
0000000000000000000000000000000000000000;;			// TODO: when we move to server API versions, we should completely remove the unversioned concept
0000000000000000000000000000000000000000;;			if unversionedKind, ok := s.unversionedTypes[t]; ok {
0000000000000000000000000000000000000000;;				if gvk, ok := target.KindForGroupVersionKinds([]schema.GroupVersionKind{unversionedKind}); ok {
0000000000000000000000000000000000000000;;					return copyAndSetTargetKind(copy, s, in, gvk)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return copyAndSetTargetKind(copy, s, in, unversionedKind)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, NewNotRegisteredErrForTarget(t, target)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// target wants to use the existing type, set kind and return (no conversion necessary)
0000000000000000000000000000000000000000;;		for _, kind := range kinds {
0000000000000000000000000000000000000000;;			if gvk == kind {
0000000000000000000000000000000000000000;;				return copyAndSetTargetKind(copy, s, in, gvk)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// type is unversioned, no conversion necessary
0000000000000000000000000000000000000000;;		if unversionedKind, ok := s.unversionedTypes[t]; ok {
0000000000000000000000000000000000000000;;			if gvk, ok := target.KindForGroupVersionKinds([]schema.GroupVersionKind{unversionedKind}); ok {
0000000000000000000000000000000000000000;;				return copyAndSetTargetKind(copy, s, in, gvk)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return copyAndSetTargetKind(copy, s, in, unversionedKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := s.New(gvk)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if copy {
0000000000000000000000000000000000000000;;			copied, err := s.Copy(in)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			in = copied
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flags, meta := s.generateConvertMeta(in)
0000000000000000000000000000000000000000;;		meta.Context = target
0000000000000000000000000000000000000000;;		if err := s.converter.Convert(in, out, flags, meta); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setTargetKind(out, gvk)
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generateConvertMeta constructs the meta value we pass to Convert.
0000000000000000000000000000000000000000;;	func (s *Scheme) generateConvertMeta(in interface{}) (conversion.FieldMatchingFlags, *conversion.Meta) {
0000000000000000000000000000000000000000;;		return s.converter.DefaultMeta(reflect.TypeOf(in))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyAndSetTargetKind performs a conditional copy before returning the object, or an error if copy was not successful.
0000000000000000000000000000000000000000;;	func copyAndSetTargetKind(copy bool, copier ObjectCopier, obj Object, kind schema.GroupVersionKind) (Object, error) {
0000000000000000000000000000000000000000;;		if copy {
0000000000000000000000000000000000000000;;			copied, err := copier.Copy(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj = copied
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setTargetKind(obj, kind)
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setTargetKind sets the kind on an object, taking into account whether the target kind is the internal version.
0000000000000000000000000000000000000000;;	func setTargetKind(obj Object, kind schema.GroupVersionKind) {
0000000000000000000000000000000000000000;;		if kind.Version == APIVersionInternal {
0000000000000000000000000000000000000000;;			// internal is a special case
0000000000000000000000000000000000000000;;			// TODO: look at removing the need to special case this
0000000000000000000000000000000000000000;;			obj.GetObjectKind().SetGroupVersionKind(schema.GroupVersionKind{})
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj.GetObjectKind().SetGroupVersionKind(kind)
0000000000000000000000000000000000000000;;	}
