0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;		"github.com/ugorji/go/codec"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer/recognizer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/framer"
0000000000000000000000000000000000000000;;		utilyaml "k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSerializer creates a JSON serializer that handles encoding versioned objects into the proper JSON form. If typer
0000000000000000000000000000000000000000;;	// is not nil, the object has the group, version, and kind fields set.
0000000000000000000000000000000000000000;;	func NewSerializer(meta MetaFactory, creater runtime.ObjectCreater, typer runtime.ObjectTyper, pretty bool) *Serializer {
0000000000000000000000000000000000000000;;		return &Serializer{
0000000000000000000000000000000000000000;;			meta:    meta,
0000000000000000000000000000000000000000;;			creater: creater,
0000000000000000000000000000000000000000;;			typer:   typer,
0000000000000000000000000000000000000000;;			yaml:    false,
0000000000000000000000000000000000000000;;			pretty:  pretty,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewYAMLSerializer creates a YAML serializer that handles encoding versioned objects into the proper YAML form. If typer
0000000000000000000000000000000000000000;;	// is not nil, the object has the group, version, and kind fields set. This serializer supports only the subset of YAML that
0000000000000000000000000000000000000000;;	// matches JSON, and will error if constructs are used that do not serialize to JSON.
0000000000000000000000000000000000000000;;	func NewYAMLSerializer(meta MetaFactory, creater runtime.ObjectCreater, typer runtime.ObjectTyper) *Serializer {
0000000000000000000000000000000000000000;;		return &Serializer{
0000000000000000000000000000000000000000;;			meta:    meta,
0000000000000000000000000000000000000000;;			creater: creater,
0000000000000000000000000000000000000000;;			typer:   typer,
0000000000000000000000000000000000000000;;			yaml:    true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Serializer struct {
0000000000000000000000000000000000000000;;		meta    MetaFactory
0000000000000000000000000000000000000000;;		creater runtime.ObjectCreater
0000000000000000000000000000000000000000;;		typer   runtime.ObjectTyper
0000000000000000000000000000000000000000;;		yaml    bool
0000000000000000000000000000000000000000;;		pretty  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serializer implements Serializer
0000000000000000000000000000000000000000;;	var _ runtime.Serializer = &Serializer{}
0000000000000000000000000000000000000000;;	var _ recognizer.RecognizingDecoder = &Serializer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode attempts to convert the provided data into YAML or JSON, extract the stored schema kind, apply the provided default gvk, and then
0000000000000000000000000000000000000000;;	// load that data into an object matching the desired schema kind or the provided into. If into is *runtime.Unknown, the raw data will be
0000000000000000000000000000000000000000;;	// extracted and no decoding will be performed. If into is not registered with the typer, then the object will be straight decoded using
0000000000000000000000000000000000000000;;	// normal JSON/YAML unmarshalling. If into is provided and the original data is not fully qualified with kind/version/group, the type of
0000000000000000000000000000000000000000;;	// the into will be used to alter the returned gvk. On success or most errors, the method will return the calculated schema kind.
0000000000000000000000000000000000000000;;	func (s *Serializer) Decode(originalData []byte, gvk *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		if versioned, ok := into.(*runtime.VersionedObjects); ok {
0000000000000000000000000000000000000000;;			into = versioned.Last()
0000000000000000000000000000000000000000;;			obj, actual, err := s.Decode(originalData, gvk, into)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, actual, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			versioned.Objects = []runtime.Object{obj}
0000000000000000000000000000000000000000;;			return versioned, actual, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := originalData
0000000000000000000000000000000000000000;;		if s.yaml {
0000000000000000000000000000000000000000;;			altered, err := yaml.YAMLToJSON(data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data = altered
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		actual, err := s.meta.Interpret(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if gvk != nil {
0000000000000000000000000000000000000000;;			// apply kind and version defaulting from provided default
0000000000000000000000000000000000000000;;			if len(actual.Kind) == 0 {
0000000000000000000000000000000000000000;;				actual.Kind = gvk.Kind
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(actual.Version) == 0 && len(actual.Group) == 0 {
0000000000000000000000000000000000000000;;				actual.Group = gvk.Group
0000000000000000000000000000000000000000;;				actual.Version = gvk.Version
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(actual.Version) == 0 && actual.Group == gvk.Group {
0000000000000000000000000000000000000000;;				actual.Version = gvk.Version
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if unk, ok := into.(*runtime.Unknown); ok && unk != nil {
0000000000000000000000000000000000000000;;			unk.Raw = originalData
0000000000000000000000000000000000000000;;			unk.ContentType = runtime.ContentTypeJSON
0000000000000000000000000000000000000000;;			unk.GetObjectKind().SetGroupVersionKind(*actual)
0000000000000000000000000000000000000000;;			return unk, actual, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if into != nil {
0000000000000000000000000000000000000000;;			types, _, err := s.typer.ObjectKinds(into)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case runtime.IsNotRegisteredError(err):
0000000000000000000000000000000000000000;;				if err := codec.NewDecoderBytes(data, new(codec.JsonHandle)).Decode(into); err != nil {
0000000000000000000000000000000000000000;;					return nil, actual, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return into, actual, nil
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				return nil, actual, err
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				typed := types[0]
0000000000000000000000000000000000000000;;				if len(actual.Kind) == 0 {
0000000000000000000000000000000000000000;;					actual.Kind = typed.Kind
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(actual.Version) == 0 && len(actual.Group) == 0 {
0000000000000000000000000000000000000000;;					actual.Group = typed.Group
0000000000000000000000000000000000000000;;					actual.Version = typed.Version
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(actual.Version) == 0 && actual.Group == typed.Group {
0000000000000000000000000000000000000000;;					actual.Version = typed.Version
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(actual.Kind) == 0 {
0000000000000000000000000000000000000000;;			return nil, actual, runtime.NewMissingKindErr(string(originalData))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(actual.Version) == 0 {
0000000000000000000000000000000000000000;;			return nil, actual, runtime.NewMissingVersionErr(string(originalData))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// use the target if necessary
0000000000000000000000000000000000000000;;		obj, err := runtime.UseOrCreateObject(s.typer, s.creater, *actual, into)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, actual, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := codec.NewDecoderBytes(data, new(codec.JsonHandle)).Decode(obj); err != nil {
0000000000000000000000000000000000000000;;			return nil, actual, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, actual, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode serializes the provided object to the given writer.
0000000000000000000000000000000000000000;;	func (s *Serializer) Encode(obj runtime.Object, w io.Writer) error {
0000000000000000000000000000000000000000;;		if s.yaml {
0000000000000000000000000000000000000000;;			json, err := json.Marshal(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data, err := yaml.JSONToYAML(json)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = w.Write(data)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.pretty {
0000000000000000000000000000000000000000;;			data, err := json.MarshalIndent(obj, "", "  ")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err = w.Write(data)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		encoder := json.NewEncoder(w)
0000000000000000000000000000000000000000;;		return encoder.Encode(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RecognizesData implements the RecognizingDecoder interface.
0000000000000000000000000000000000000000;;	func (s *Serializer) RecognizesData(peek io.Reader) (ok, unknown bool, err error) {
0000000000000000000000000000000000000000;;		if s.yaml {
0000000000000000000000000000000000000000;;			// we could potentially look for '---'
0000000000000000000000000000000000000000;;			return false, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, ok = utilyaml.GuessJSONStream(peek, 2048)
0000000000000000000000000000000000000000;;		return ok, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Framer is the default JSON framing behavior, with newlines delimiting individual objects.
0000000000000000000000000000000000000000;;	var Framer = jsonFramer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jsonFramer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFrameWriter implements stream framing for this serializer
0000000000000000000000000000000000000000;;	func (jsonFramer) NewFrameWriter(w io.Writer) io.Writer {
0000000000000000000000000000000000000000;;		// we can write JSON objects directly to the writer, because they are self-framing
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFrameReader implements stream framing for this serializer
0000000000000000000000000000000000000000;;	func (jsonFramer) NewFrameReader(r io.ReadCloser) io.ReadCloser {
0000000000000000000000000000000000000000;;		// we need to extract the JSON chunks of data to pass to Decode()
0000000000000000000000000000000000000000;;		return framer.NewJSONFramedReader(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Framer is the default JSON framing behavior, with newlines delimiting individual objects.
0000000000000000000000000000000000000000;;	var YAMLFramer = yamlFramer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yamlFramer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFrameWriter implements stream framing for this serializer
0000000000000000000000000000000000000000;;	func (yamlFramer) NewFrameWriter(w io.Writer) io.Writer {
0000000000000000000000000000000000000000;;		return yamlFrameWriter{w}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFrameReader implements stream framing for this serializer
0000000000000000000000000000000000000000;;	func (yamlFramer) NewFrameReader(r io.ReadCloser) io.ReadCloser {
0000000000000000000000000000000000000000;;		// extract the YAML document chunks directly
0000000000000000000000000000000000000000;;		return utilyaml.NewDocumentDecoder(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type yamlFrameWriter struct {
0000000000000000000000000000000000000000;;		w io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write separates each document with the YAML document separator (`---` followed by line
0000000000000000000000000000000000000000;;	// break). Writers must write well formed YAML documents (include a final line break).
0000000000000000000000000000000000000000;;	func (w yamlFrameWriter) Write(data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if _, err := w.w.Write([]byte("---\n")); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.w.Write(data)
0000000000000000000000000000000000000000;;	}
