0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package runtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unsafeObjectConvertor implements ObjectConvertor using the unsafe conversion path.
0000000000000000000000000000000000000000;;	type unsafeObjectConvertor struct {
0000000000000000000000000000000000000000;;		*Scheme
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ObjectConvertor = unsafeObjectConvertor{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConvertToVersion converts in to the provided outVersion without copying the input first, which
0000000000000000000000000000000000000000;;	// is only safe if the output object is not mutated or reused.
0000000000000000000000000000000000000000;;	func (c unsafeObjectConvertor) ConvertToVersion(in Object, outVersion GroupVersioner) (Object, error) {
0000000000000000000000000000000000000000;;		return c.Scheme.UnsafeConvertToVersion(in, outVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsafeObjectConvertor performs object conversion without copying the object structure,
0000000000000000000000000000000000000000;;	// for use when the converted object will not be reused or mutated. Primarily for use within
0000000000000000000000000000000000000000;;	// versioned codecs, which use the external object for serialization but do not return it.
0000000000000000000000000000000000000000;;	func UnsafeObjectConvertor(scheme *Scheme) ObjectConvertor {
0000000000000000000000000000000000000000;;		return unsafeObjectConvertor{scheme}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetField puts the value of src, into fieldName, which must be a member of v.
0000000000000000000000000000000000000000;;	// The value of src must be assignable to the field.
0000000000000000000000000000000000000000;;	func SetField(src interface{}, v reflect.Value, fieldName string) error {
0000000000000000000000000000000000000000;;		field := v.FieldByName(fieldName)
0000000000000000000000000000000000000000;;		if !field.IsValid() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't find %v field in %#v", fieldName, v.Interface())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srcValue := reflect.ValueOf(src)
0000000000000000000000000000000000000000;;		if srcValue.Type().AssignableTo(field.Type()) {
0000000000000000000000000000000000000000;;			field.Set(srcValue)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if srcValue.Type().ConvertibleTo(field.Type()) {
0000000000000000000000000000000000000000;;			field.Set(srcValue.Convert(field.Type()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("couldn't assign/convert %v to %v", srcValue.Type(), field.Type())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Field puts the value of fieldName, which must be a member of v, into dest,
0000000000000000000000000000000000000000;;	// which must be a variable to which this field's value can be assigned.
0000000000000000000000000000000000000000;;	func Field(v reflect.Value, fieldName string, dest interface{}) error {
0000000000000000000000000000000000000000;;		field := v.FieldByName(fieldName)
0000000000000000000000000000000000000000;;		if !field.IsValid() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't find %v field in %#v", fieldName, v.Interface())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		destValue, err := conversion.EnforcePtr(dest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if field.Type().AssignableTo(destValue.Type()) {
0000000000000000000000000000000000000000;;			destValue.Set(field)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if field.Type().ConvertibleTo(destValue.Type()) {
0000000000000000000000000000000000000000;;			destValue.Set(field.Convert(destValue.Type()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("couldn't assign/convert %v to %v", field.Type(), destValue.Type())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fieldPtr puts the address of fieldName, which must be a member of v,
0000000000000000000000000000000000000000;;	// into dest, which must be an address of a variable to which this field's
0000000000000000000000000000000000000000;;	// address can be assigned.
0000000000000000000000000000000000000000;;	func FieldPtr(v reflect.Value, fieldName string, dest interface{}) error {
0000000000000000000000000000000000000000;;		field := v.FieldByName(fieldName)
0000000000000000000000000000000000000000;;		if !field.IsValid() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't find %v field in %#v", fieldName, v.Interface())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(dest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		field = field.Addr()
0000000000000000000000000000000000000000;;		if field.Type().AssignableTo(v.Type()) {
0000000000000000000000000000000000000000;;			v.Set(field)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if field.Type().ConvertibleTo(v.Type()) {
0000000000000000000000000000000000000000;;			v.Set(field.Convert(v.Type()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Errorf("couldn't assign/convert %v to %v", field.Type(), v.Type())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeList ensures that each object in an array is converted to a Unknown{} in serialized form.
0000000000000000000000000000000000000000;;	// TODO: accept a content type.
0000000000000000000000000000000000000000;;	func EncodeList(e Encoder, objects []Object) error {
0000000000000000000000000000000000000000;;		var errs []error
0000000000000000000000000000000000000000;;		for i := range objects {
0000000000000000000000000000000000000000;;			data, err := Encode(e, objects[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: Set ContentEncoding and ContentType.
0000000000000000000000000000000000000000;;			objects[i] = &Unknown{Raw: data}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors.NewAggregate(errs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeListItem(obj *Unknown, decoders []Decoder) (Object, error) {
0000000000000000000000000000000000000000;;		for _, decoder := range decoders {
0000000000000000000000000000000000000000;;			// TODO: Decode based on ContentType.
0000000000000000000000000000000000000000;;			obj, err := Decode(decoder, obj.Raw)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if IsNotRegisteredError(err) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return obj, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// could not decode, so leave the object as Unknown, but give the decoders the
0000000000000000000000000000000000000000;;		// chance to set Unknown.TypeMeta if it is available.
0000000000000000000000000000000000000000;;		for _, decoder := range decoders {
0000000000000000000000000000000000000000;;			if err := DecodeInto(decoder, obj.Raw, obj); err == nil {
0000000000000000000000000000000000000000;;				return obj, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeList alters the list in place, attempting to decode any objects found in
0000000000000000000000000000000000000000;;	// the list that have the Unknown type. Any errors that occur are returned
0000000000000000000000000000000000000000;;	// after the entire list is processed. Decoders are tried in order.
0000000000000000000000000000000000000000;;	func DecodeList(objects []Object, decoders ...Decoder) []error {
0000000000000000000000000000000000000000;;		errs := []error(nil)
0000000000000000000000000000000000000000;;		for i, obj := range objects {
0000000000000000000000000000000000000000;;			switch t := obj.(type) {
0000000000000000000000000000000000000000;;			case *Unknown:
0000000000000000000000000000000000000000;;				decoded, err := decodeListItem(t, decoders)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					errs = append(errs, err)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				objects[i] = decoded
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MultiObjectTyper returns the types of objects across multiple schemes in order.
0000000000000000000000000000000000000000;;	type MultiObjectTyper []ObjectTyper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ObjectTyper = MultiObjectTyper{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m MultiObjectTyper) ObjectKinds(obj Object) (gvks []schema.GroupVersionKind, unversionedType bool, err error) {
0000000000000000000000000000000000000000;;		for _, t := range m {
0000000000000000000000000000000000000000;;			gvks, unversionedType, err = t.ObjectKinds(obj)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m MultiObjectTyper) Recognizes(gvk schema.GroupVersionKind) bool {
0000000000000000000000000000000000000000;;		for _, t := range m {
0000000000000000000000000000000000000000;;			if t.Recognizes(gvk) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetZeroValue would set the object of objPtr to zero value of its type.
0000000000000000000000000000000000000000;;	func SetZeroValue(objPtr Object) error {
0000000000000000000000000000000000000000;;		v, err := conversion.EnforcePtr(objPtr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultFramer is valid for any stream that can read objects serially without
0000000000000000000000000000000000000000;;	// any separation in the stream.
0000000000000000000000000000000000000000;;	var DefaultFramer = defaultFramer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type defaultFramer struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (defaultFramer) NewFrameReader(r io.ReadCloser) io.ReadCloser { return r }
0000000000000000000000000000000000000000;;	func (defaultFramer) NewFrameWriter(w io.Writer) io.Writer         { return w }
