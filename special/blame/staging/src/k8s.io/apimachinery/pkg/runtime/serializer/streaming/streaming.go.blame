0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package streaming implements encoder and decoder for streams
0000000000000000000000000000000000000000;;	// of runtime.Objects over io.Writer/Readers.
0000000000000000000000000000000000000000;;	package streaming
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encoder is a runtime.Encoder on a stream.
0000000000000000000000000000000000000000;;	type Encoder interface {
0000000000000000000000000000000000000000;;		// Encode will write the provided object to the stream or return an error. It obeys the same
0000000000000000000000000000000000000000;;		// contract as runtime.VersionedEncoder.
0000000000000000000000000000000000000000;;		Encode(obj runtime.Object) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decoder is a runtime.Decoder from a stream.
0000000000000000000000000000000000000000;;	type Decoder interface {
0000000000000000000000000000000000000000;;		// Decode will return io.EOF when no more objects are available.
0000000000000000000000000000000000000000;;		Decode(defaults *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error)
0000000000000000000000000000000000000000;;		// Close closes the underlying stream.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serializer is a factory for creating encoders and decoders that work over streams.
0000000000000000000000000000000000000000;;	type Serializer interface {
0000000000000000000000000000000000000000;;		NewEncoder(w io.Writer) Encoder
0000000000000000000000000000000000000000;;		NewDecoder(r io.ReadCloser) Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decoder struct {
0000000000000000000000000000000000000000;;		reader    io.ReadCloser
0000000000000000000000000000000000000000;;		decoder   runtime.Decoder
0000000000000000000000000000000000000000;;		buf       []byte
0000000000000000000000000000000000000000;;		maxBytes  int
0000000000000000000000000000000000000000;;		resetRead bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoder creates a streaming decoder that reads object chunks from r and decodes them with d.
0000000000000000000000000000000000000000;;	// The reader is expected to return ErrShortRead if the provided buffer is not large enough to read
0000000000000000000000000000000000000000;;	// an entire object.
0000000000000000000000000000000000000000;;	func NewDecoder(r io.ReadCloser, d runtime.Decoder) Decoder {
0000000000000000000000000000000000000000;;		return &decoder{
0000000000000000000000000000000000000000;;			reader:   r,
0000000000000000000000000000000000000000;;			decoder:  d,
0000000000000000000000000000000000000000;;			buf:      make([]byte, 1024),
0000000000000000000000000000000000000000;;			maxBytes: 1024 * 1024,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrObjectTooLarge = fmt.Errorf("object to decode was longer than maximum allowed size")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode reads the next object from the stream and decodes it.
0000000000000000000000000000000000000000;;	func (d *decoder) Decode(defaults *schema.GroupVersionKind, into runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		base := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n, err := d.reader.Read(d.buf[base:])
0000000000000000000000000000000000000000;;			if err == io.ErrShortBuffer {
0000000000000000000000000000000000000000;;				if n == 0 {
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("got short buffer with n=0, base=%d, cap=%d", base, cap(d.buf))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if d.resetRead {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// double the buffer size up to maxBytes
0000000000000000000000000000000000000000;;				if len(d.buf) < d.maxBytes {
0000000000000000000000000000000000000000;;					base += n
0000000000000000000000000000000000000000;;					d.buf = append(d.buf, make([]byte, len(d.buf))...)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// must read the rest of the frame (until we stop getting ErrShortBuffer)
0000000000000000000000000000000000000000;;				d.resetRead = true
0000000000000000000000000000000000000000;;				base = 0
0000000000000000000000000000000000000000;;				return nil, nil, ErrObjectTooLarge
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if d.resetRead {
0000000000000000000000000000000000000000;;				// now that we have drained the large read, continue
0000000000000000000000000000000000000000;;				d.resetRead = false
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			base += n
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.decoder.Decode(d.buf[:base], defaults, into)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) Close() error {
0000000000000000000000000000000000000000;;		return d.reader.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encoder struct {
0000000000000000000000000000000000000000;;		writer  io.Writer
0000000000000000000000000000000000000000;;		encoder runtime.Encoder
0000000000000000000000000000000000000000;;		buf     *bytes.Buffer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncoder returns a new streaming encoder.
0000000000000000000000000000000000000000;;	func NewEncoder(w io.Writer, e runtime.Encoder) Encoder {
0000000000000000000000000000000000000000;;		return &encoder{
0000000000000000000000000000000000000000;;			writer:  w,
0000000000000000000000000000000000000000;;			encoder: e,
0000000000000000000000000000000000000000;;			buf:     &bytes.Buffer{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode writes the provided object to the nested writer.
0000000000000000000000000000000000000000;;	func (e *encoder) Encode(obj runtime.Object) error {
0000000000000000000000000000000000000000;;		if err := e.encoder.Encode(obj, e.buf); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := e.writer.Write(e.buf.Bytes())
0000000000000000000000000000000000000000;;		e.buf.Reset()
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
