0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package runtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note that the types provided in this file are not versioned and are intended to be
0000000000000000000000000000000000000000;;	// safe to use from within all versions of every API object.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeMeta is shared by all top level objects. The proper way to use it is to inline it in your type,
0000000000000000000000000000000000000000;;	// like this:
0000000000000000000000000000000000000000;;	// type MyAwesomeAPIObject struct {
0000000000000000000000000000000000000000;;	//      runtime.TypeMeta    `json:",inline"`
0000000000000000000000000000000000000000;;	//      ... // other fields
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	// func (obj *MyAwesomeAPIObject) SetGroupVersionKind(gvk *metav1.GroupVersionKind) { metav1.UpdateTypeMeta(obj,gvk) }; GroupVersionKind() *GroupVersionKind
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TypeMeta is provided here for convenience. You may use it directly from this package or define
0000000000000000000000000000000000000000;;	// your own with the same fields.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +k8s:deepcopy-gen=true
0000000000000000000000000000000000000000;;	// +protobuf=true
0000000000000000000000000000000000000000;;	// +k8s:openapi-gen=true
0000000000000000000000000000000000000000;;	type TypeMeta struct {
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		APIVersion string `json:"apiVersion,omitempty" yaml:"apiVersion,omitempty" protobuf:"bytes,1,opt,name=apiVersion"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Kind string `json:"kind,omitempty" yaml:"kind,omitempty" protobuf:"bytes,2,opt,name=kind"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ContentTypeJSON string = "application/json"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RawExtension is used to hold extensions in external versions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To use this, make a field which has RawExtension as its type in your external, versioned
0000000000000000000000000000000000000000;;	// struct, and Object in your internal struct. You also need to register your
0000000000000000000000000000000000000000;;	// various plugin types.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// // Internal package:
0000000000000000000000000000000000000000;;	// type MyAPIObject struct {
0000000000000000000000000000000000000000;;	// 	runtime.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	//	MyPlugin runtime.Object `json:"myPlugin"`
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	// type PluginA struct {
0000000000000000000000000000000000000000;;	//	AOption string `json:"aOption"`
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// // External package:
0000000000000000000000000000000000000000;;	// type MyAPIObject struct {
0000000000000000000000000000000000000000;;	// 	runtime.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	//	MyPlugin runtime.RawExtension `json:"myPlugin"`
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	// type PluginA struct {
0000000000000000000000000000000000000000;;	//	AOption string `json:"aOption"`
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// // On the wire, the JSON will look something like this:
0000000000000000000000000000000000000000;;	// {
0000000000000000000000000000000000000000;;	//	"kind":"MyAPIObject",
0000000000000000000000000000000000000000;;	//	"apiVersion":"v1",
0000000000000000000000000000000000000000;;	//	"myPlugin": {
0000000000000000000000000000000000000000;;	//		"kind":"PluginA",
0000000000000000000000000000000000000000;;	//		"aOption":"foo",
0000000000000000000000000000000000000000;;	//	},
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// So what happens? Decode first uses json or yaml to unmarshal the serialized data into
0000000000000000000000000000000000000000;;	// your external MyAPIObject. That causes the raw JSON to be stored, but not unpacked.
0000000000000000000000000000000000000000;;	// The next step is to copy (using pkg/conversion) into the internal struct. The runtime
0000000000000000000000000000000000000000;;	// package's DefaultScheme has conversion functions installed which will unpack the
0000000000000000000000000000000000000000;;	// JSON stored in RawExtension, turning it into the correct object type, and storing it
0000000000000000000000000000000000000000;;	// in the Object. (TODO: In the case where the object is of an unknown type, a
0000000000000000000000000000000000000000;;	// runtime.Unknown object will be created and stored.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +k8s:deepcopy-gen=true
0000000000000000000000000000000000000000;;	// +protobuf=true
0000000000000000000000000000000000000000;;	// +k8s:openapi-gen=true
0000000000000000000000000000000000000000;;	type RawExtension struct {
0000000000000000000000000000000000000000;;		// Raw is the underlying serialization of this object.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// TODO: Determine how to detect ContentType and ContentEncoding of 'Raw' data.
0000000000000000000000000000000000000000;;		Raw []byte `protobuf:"bytes,1,opt,name=raw"`
0000000000000000000000000000000000000000;;		// Object can hold a representation of this extension - useful for working with versioned
0000000000000000000000000000000000000000;;		// structs.
0000000000000000000000000000000000000000;;		Object Object `json:"-"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unknown allows api objects with unknown types to be passed-through. This can be used
0000000000000000000000000000000000000000;;	// to deal with the API objects from a plug-in. Unknown objects still have functioning
0000000000000000000000000000000000000000;;	// TypeMeta features-- kind, version, etc.
0000000000000000000000000000000000000000;;	// TODO: Make this object have easy access to field based accessors and settors for
0000000000000000000000000000000000000000;;	// metadata and field mutatation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +k8s:deepcopy-gen=true
0000000000000000000000000000000000000000;;	// +protobuf=true
0000000000000000000000000000000000000000;;	// +k8s:openapi-gen=true
0000000000000000000000000000000000000000;;	type Unknown struct {
0000000000000000000000000000000000000000;;		TypeMeta `json:",inline" protobuf:"bytes,1,opt,name=typeMeta"`
0000000000000000000000000000000000000000;;		// Raw will hold the complete serialized object which couldn't be matched
0000000000000000000000000000000000000000;;		// with a registered type. Most likely, nothing should be done with this
0000000000000000000000000000000000000000;;		// except for passing it through the system.
0000000000000000000000000000000000000000;;		Raw []byte `protobuf:"bytes,2,opt,name=raw"`
0000000000000000000000000000000000000000;;		// ContentEncoding is encoding used to encode 'Raw' data.
0000000000000000000000000000000000000000;;		// Unspecified means no encoding.
0000000000000000000000000000000000000000;;		ContentEncoding string `protobuf:"bytes,3,opt,name=contentEncoding"`
0000000000000000000000000000000000000000;;		// ContentType  is serialization method used to serialize 'Raw'.
0000000000000000000000000000000000000000;;		// Unspecified means ContentTypeJSON.
0000000000000000000000000000000000000000;;		ContentType string `protobuf:"bytes,4,opt,name=contentType"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VersionedObjects is used by Decoders to give callers a way to access all versions
0000000000000000000000000000000000000000;;	// of an object during the decoding process.
0000000000000000000000000000000000000000;;	type VersionedObjects struct {
0000000000000000000000000000000000000000;;		// Objects is the set of objects retrieved during decoding, in order of conversion.
0000000000000000000000000000000000000000;;		// The 0 index is the object as serialized on the wire. If conversion has occurred,
0000000000000000000000000000000000000000;;		// other objects may be present. The right most object is the same as would be returned
0000000000000000000000000000000000000000;;		// by a normal Decode call.
0000000000000000000000000000000000000000;;		Objects []Object
0000000000000000000000000000000000000000;;	}
