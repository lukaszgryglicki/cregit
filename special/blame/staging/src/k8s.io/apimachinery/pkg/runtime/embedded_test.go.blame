0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package runtime_test
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		runtimetesting "k8s.io/apimachinery/pkg/runtime/testing"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDecodeEmptyRawExtensionAsObject(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Group: "test.group", Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Group: "test.group", Version: "v1test"}
0000000000000000000000000000000000000000;;		externalGVK := externalGV.WithKind("ObjectTest")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		s.AddKnownTypes(internalGV, &runtimetesting.ObjectTest{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGVK, &runtimetesting.ObjectTestExternal{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := serializer.NewCodecFactory(s).LegacyCodec(externalGV)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, gvk, err := codec.Decode([]byte(`{"kind":"`+externalGVK.Kind+`","apiVersion":"`+externalGV.String()+`","items":[{}]}`), nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		test := obj.(*runtimetesting.ObjectTest)
0000000000000000000000000000000000000000;;		if unk, ok := test.Items[0].(*runtime.Unknown); !ok || unk.Kind != "" || unk.APIVersion != "" || string(unk.Raw) != "{}" || unk.ContentType != runtime.ContentTypeJSON {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected object: %#v", test.Items[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *gvk != externalGVK {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected kind: %#v", gvk)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, gvk, err = codec.Decode([]byte(`{"kind":"`+externalGVK.Kind+`","apiVersion":"`+externalGV.String()+`","items":[{"kind":"Other","apiVersion":"v1"}]}`), nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		test = obj.(*runtimetesting.ObjectTest)
0000000000000000000000000000000000000000;;		if unk, ok := test.Items[0].(*runtime.Unknown); !ok || unk.Kind != "" || unk.APIVersion != "" || string(unk.Raw) != `{"kind":"Other","apiVersion":"v1"}` || unk.ContentType != runtime.ContentTypeJSON {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected object: %#v", test.Items[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *gvk != externalGVK {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected kind: %#v", gvk)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestArrayOfRuntimeObject(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Group: "test.group", Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Group: "test.group", Version: "v1test"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		s.AddKnownTypes(internalGV, &runtimetesting.EmbeddedTest{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("EmbeddedTest"), &runtimetesting.EmbeddedTestExternal{})
0000000000000000000000000000000000000000;;		s.AddKnownTypes(internalGV, &runtimetesting.ObjectTest{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("ObjectTest"), &runtimetesting.ObjectTestExternal{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := serializer.NewCodecFactory(s).LegacyCodec(externalGV)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		innerItems := []runtime.Object{
0000000000000000000000000000000000000000;;			&runtimetesting.EmbeddedTest{ID: "baz"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items := []runtime.Object{
0000000000000000000000000000000000000000;;			&runtimetesting.EmbeddedTest{ID: "foo"},
0000000000000000000000000000000000000000;;			&runtimetesting.EmbeddedTest{ID: "bar"},
0000000000000000000000000000000000000000;;			// TODO: until YAML is removed, this JSON must be in ascending key order to ensure consistent roundtrip serialization
0000000000000000000000000000000000000000;;			&runtime.Unknown{
0000000000000000000000000000000000000000;;				Raw:         []byte(`{"apiVersion":"unknown.group/unknown","foo":"bar","kind":"OtherTest"}`),
0000000000000000000000000000000000000000;;				ContentType: runtime.ContentTypeJSON,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&runtimetesting.ObjectTest{
0000000000000000000000000000000000000000;;				Items: runtime.NewEncodableList(codec, innerItems),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		internal := &runtimetesting.ObjectTest{
0000000000000000000000000000000000000000;;			Items: runtime.NewEncodableList(codec, items),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wire, err := runtime.Encode(codec, internal)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("Wire format is:\n%s\n", string(wire))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := &runtimetesting.ObjectTestExternal{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(wire, obj); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("exact wire is: %s", string(obj.Items[0].Raw))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items[3] = &runtimetesting.ObjectTest{Items: innerItems}
0000000000000000000000000000000000000000;;		internal.Items = items
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoded, err := runtime.Decode(codec, wire)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list, err := meta.ExtractList(decoded)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errs := runtime.DecodeList(list, codec); len(errs) > 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list2, err := meta.ExtractList(list[3])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if errs := runtime.DecodeList(list2, codec); len(errs) > 0 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := meta.SetList(list[3], list2); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we want DecodeList to set type meta if possible, even on runtime.Unknown objects
0000000000000000000000000000000000000000;;		internal.Items[2].(*runtime.Unknown).TypeMeta = runtime.TypeMeta{Kind: "OtherTest", APIVersion: "unknown.group/unknown"}
0000000000000000000000000000000000000000;;		if e, a := internal.Items, list; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("mismatched decoded: %s", diff.ObjectGoPrintSideBySide(e, a))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNestedObject(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Group: "test.group", Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Group: "test.group", Version: "v1test"}
0000000000000000000000000000000000000000;;		embeddedTestExternalGVK := externalGV.WithKind("EmbeddedTest")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		s.AddKnownTypes(internalGV, &runtimetesting.EmbeddedTest{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(embeddedTestExternalGVK, &runtimetesting.EmbeddedTestExternal{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := serializer.NewCodecFactory(s).LegacyCodec(externalGV)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inner := &runtimetesting.EmbeddedTest{
0000000000000000000000000000000000000000;;			ID: "inner",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		outer := &runtimetesting.EmbeddedTest{
0000000000000000000000000000000000000000;;			ID:     "outer",
0000000000000000000000000000000000000000;;			Object: runtime.NewEncodable(codec, inner),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wire, err := runtime.Encode(codec, outer)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected encode error '%v'", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Logf("Wire format is:\n%v\n", string(wire))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoded, err := runtime.Decode(codec, wire)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected decode error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for later tests
0000000000000000000000000000000000000000;;		outer.Object = inner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := outer, decoded; reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected unequal %#v %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := runtime.Decode(codec, decoded.(*runtimetesting.EmbeddedTest).Object.(*runtime.Unknown).Raw)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decoded.(*runtimetesting.EmbeddedTest).Object = obj
0000000000000000000000000000000000000000;;		if e, a := outer, decoded; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected equal %#v %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test JSON decoding of the external object, which should preserve
0000000000000000000000000000000000000000;;		// raw bytes
0000000000000000000000000000000000000000;;		var externalViaJSON runtimetesting.EmbeddedTestExternal
0000000000000000000000000000000000000000;;		err = json.Unmarshal(wire, &externalViaJSON)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected decode error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if externalViaJSON.Kind == "" || externalViaJSON.APIVersion == "" || externalViaJSON.ID != "outer" {
0000000000000000000000000000000000000000;;			t.Errorf("Expected objects to have type info set, got %#v", externalViaJSON)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(externalViaJSON.EmptyObject.Raw, []byte("null")) || len(externalViaJSON.Object.Raw) == 0 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected deserialization of nested objects into bytes, got %#v", externalViaJSON)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test JSON decoding, too, since Decode uses yaml unmarshalling.
0000000000000000000000000000000000000000;;		// Generic Unmarshalling of JSON cannot load the nested objects because there is
0000000000000000000000000000000000000000;;		// no default schema set.  Consumers wishing to get direct JSON decoding must use
0000000000000000000000000000000000000000;;		// the external representation
0000000000000000000000000000000000000000;;		var decodedViaJSON runtimetesting.EmbeddedTest
0000000000000000000000000000000000000000;;		err = json.Unmarshal(wire, &decodedViaJSON)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatal("Expeceted decode error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := err.(*json.UnmarshalTypeError); !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Unexpected decode error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a := decodedViaJSON; a.Object != nil || a.EmptyObject != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Expected embedded objects to be nil: %#v", a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestDeepCopyOfRuntimeObject checks to make sure that runtime.Objects's can be passed through DeepCopy with fidelity
0000000000000000000000000000000000000000;;	func TestDeepCopyOfRuntimeObject(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Group: "test.group", Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Group: "test.group", Version: "v1test"}
0000000000000000000000000000000000000000;;		embeddedTestExternalGVK := externalGV.WithKind("EmbeddedTest")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		s.AddKnownTypes(internalGV, &runtimetesting.EmbeddedTest{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(embeddedTestExternalGVK, &runtimetesting.EmbeddedTestExternal{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		original := &runtimetesting.EmbeddedTest{
0000000000000000000000000000000000000000;;			ID: "outer",
0000000000000000000000000000000000000000;;			Object: &runtimetesting.EmbeddedTest{
0000000000000000000000000000000000000000;;				ID: "inner",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := serializer.NewCodecFactory(s).LegacyCodec(externalGV)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		originalData, err := runtime.Encode(codec, original)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("originalRole = %v\n", string(originalData))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copyOfOriginal, err := s.DeepCopy(original)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copiedData, err := runtime.Encode(codec, copyOfOriginal.(runtime.Object))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Logf("copyOfRole   = %v\n", string(copiedData))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(original, copyOfOriginal) {
0000000000000000000000000000000000000000;;			t.Errorf("expected \n%v\n, got \n%v", string(originalData), string(copiedData))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
