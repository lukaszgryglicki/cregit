0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package runtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// APIVersionInternal may be used if you are registering a type that should not
0000000000000000000000000000000000000000;;		// be considered stable or serialized - it is a convention only and has no
0000000000000000000000000000000000000000;;		// special behavior in this package.
0000000000000000000000000000000000000000;;		APIVersionInternal = "__internal"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersioner refines a set of possible conversion targets into a single option.
0000000000000000000000000000000000000000;;	type GroupVersioner interface {
0000000000000000000000000000000000000000;;		// KindForGroupVersionKinds returns a desired target group version kind for the given input, or returns ok false if no
0000000000000000000000000000000000000000;;		// target is known. In general, if the return target is not in the input list, the caller is expected to invoke
0000000000000000000000000000000000000000;;		// Scheme.New(target) and then perform a conversion between the current Go type and the destination Go type.
0000000000000000000000000000000000000000;;		// Sophisticated implementations may use additional information about the input kinds to pick a destination kind.
0000000000000000000000000000000000000000;;		KindForGroupVersionKinds(kinds []schema.GroupVersionKind) (target schema.GroupVersionKind, ok bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encoders write objects to a serialized form
0000000000000000000000000000000000000000;;	type Encoder interface {
0000000000000000000000000000000000000000;;		// Encode writes an object to a stream. Implementations may return errors if the versions are
0000000000000000000000000000000000000000;;		// incompatible, or if no conversion is defined.
0000000000000000000000000000000000000000;;		Encode(obj Object, w io.Writer) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decoders attempt to load an object from data.
0000000000000000000000000000000000000000;;	type Decoder interface {
0000000000000000000000000000000000000000;;		// Decode attempts to deserialize the provided data using either the innate typing of the scheme or the
0000000000000000000000000000000000000000;;		// default kind, group, and version provided. It returns a decoded object as well as the kind, group, and
0000000000000000000000000000000000000000;;		// version from the serialized data, or an error. If into is non-nil, it will be used as the target type
0000000000000000000000000000000000000000;;		// and implementations may choose to use it rather than reallocating an object. However, the object is not
0000000000000000000000000000000000000000;;		// guaranteed to be populated. The returned object is not guaranteed to match into. If defaults are
0000000000000000000000000000000000000000;;		// provided, they are applied to the data by default. If no defaults or partial defaults are provided, the
0000000000000000000000000000000000000000;;		// type of the into may be used to guide conversion decisions.
0000000000000000000000000000000000000000;;		Decode(data []byte, defaults *schema.GroupVersionKind, into Object) (Object, *schema.GroupVersionKind, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serializer is the core interface for transforming objects into a serialized format and back.
0000000000000000000000000000000000000000;;	// Implementations may choose to perform conversion of the object, but no assumptions should be made.
0000000000000000000000000000000000000000;;	type Serializer interface {
0000000000000000000000000000000000000000;;		Encoder
0000000000000000000000000000000000000000;;		Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Codec is a Serializer that deals with the details of versioning objects. It offers the same
0000000000000000000000000000000000000000;;	// interface as Serializer, so this is a marker to consumers that care about the version of the objects
0000000000000000000000000000000000000000;;	// they receive.
0000000000000000000000000000000000000000;;	type Codec Serializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParameterCodec defines methods for serializing and deserializing API objects to url.Values and
0000000000000000000000000000000000000000;;	// performing any necessary conversion. Unlike the normal Codec, query parameters are not self describing
0000000000000000000000000000000000000000;;	// and the desired version must be specified.
0000000000000000000000000000000000000000;;	type ParameterCodec interface {
0000000000000000000000000000000000000000;;		// DecodeParameters takes the given url.Values in the specified group version and decodes them
0000000000000000000000000000000000000000;;		// into the provided object, or returns an error.
0000000000000000000000000000000000000000;;		DecodeParameters(parameters url.Values, from schema.GroupVersion, into Object) error
0000000000000000000000000000000000000000;;		// EncodeParameters encodes the provided object as query parameters or returns an error.
0000000000000000000000000000000000000000;;		EncodeParameters(obj Object, to schema.GroupVersion) (url.Values, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Framer is a factory for creating readers and writers that obey a particular framing pattern.
0000000000000000000000000000000000000000;;	type Framer interface {
0000000000000000000000000000000000000000;;		NewFrameReader(r io.ReadCloser) io.ReadCloser
0000000000000000000000000000000000000000;;		NewFrameWriter(w io.Writer) io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SerializerInfo contains information about a specific serialization format
0000000000000000000000000000000000000000;;	type SerializerInfo struct {
0000000000000000000000000000000000000000;;		// MediaType is the value that represents this serializer over the wire.
0000000000000000000000000000000000000000;;		MediaType string
0000000000000000000000000000000000000000;;		// EncodesAsText indicates this serializer can be encoded to UTF-8 safely.
0000000000000000000000000000000000000000;;		EncodesAsText bool
0000000000000000000000000000000000000000;;		// Serializer is the individual object serializer for this media type.
0000000000000000000000000000000000000000;;		Serializer Serializer
0000000000000000000000000000000000000000;;		// PrettySerializer, if set, can serialize this object in a form biased towards
0000000000000000000000000000000000000000;;		// readability.
0000000000000000000000000000000000000000;;		PrettySerializer Serializer
0000000000000000000000000000000000000000;;		// StreamSerializer, if set, describes the streaming serialization format
0000000000000000000000000000000000000000;;		// for this media type.
0000000000000000000000000000000000000000;;		StreamSerializer *StreamSerializerInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StreamSerializerInfo contains information about a specific stream serialization format
0000000000000000000000000000000000000000;;	type StreamSerializerInfo struct {
0000000000000000000000000000000000000000;;		// EncodesAsText indicates this serializer can be encoded to UTF-8 safely.
0000000000000000000000000000000000000000;;		EncodesAsText bool
0000000000000000000000000000000000000000;;		// Serializer is the top level object serializer for this type when streaming
0000000000000000000000000000000000000000;;		Serializer
0000000000000000000000000000000000000000;;		// Framer is the factory for retrieving streams that separate objects on the wire
0000000000000000000000000000000000000000;;		Framer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NegotiatedSerializer is an interface used for obtaining encoders, decoders, and serializers
0000000000000000000000000000000000000000;;	// for multiple supported media types. This would commonly be accepted by a server component
0000000000000000000000000000000000000000;;	// that performs HTTP content negotiation to accept multiple formats.
0000000000000000000000000000000000000000;;	type NegotiatedSerializer interface {
0000000000000000000000000000000000000000;;		// SupportedMediaTypes is the media types supported for reading and writing single objects.
0000000000000000000000000000000000000000;;		SupportedMediaTypes() []SerializerInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EncoderForVersion returns an encoder that ensures objects being written to the provided
0000000000000000000000000000000000000000;;		// serializer are in the provided group version.
0000000000000000000000000000000000000000;;		EncoderForVersion(serializer Encoder, gv GroupVersioner) Encoder
0000000000000000000000000000000000000000;;		// DecoderForVersion returns a decoder that ensures objects being read by the provided
0000000000000000000000000000000000000000;;		// serializer are in the provided group version by default.
0000000000000000000000000000000000000000;;		DecoderToVersion(serializer Decoder, gv GroupVersioner) Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StorageSerializer is an interface used for obtaining encoders, decoders, and serializers
0000000000000000000000000000000000000000;;	// that can read and write data at rest. This would commonly be used by client tools that must
0000000000000000000000000000000000000000;;	// read files, or server side storage interfaces that persist restful objects.
0000000000000000000000000000000000000000;;	type StorageSerializer interface {
0000000000000000000000000000000000000000;;		// SupportedMediaTypes are the media types supported for reading and writing objects.
0000000000000000000000000000000000000000;;		SupportedMediaTypes() []SerializerInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UniversalDeserializer returns a Serializer that can read objects in multiple supported formats
0000000000000000000000000000000000000000;;		// by introspecting the data at rest.
0000000000000000000000000000000000000000;;		UniversalDeserializer() Decoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// EncoderForVersion returns an encoder that ensures objects being written to the provided
0000000000000000000000000000000000000000;;		// serializer are in the provided group version.
0000000000000000000000000000000000000000;;		EncoderForVersion(serializer Encoder, gv GroupVersioner) Encoder
0000000000000000000000000000000000000000;;		// DecoderForVersion returns a decoder that ensures objects being read by the provided
0000000000000000000000000000000000000000;;		// serializer are in the provided group version by default.
0000000000000000000000000000000000000000;;		DecoderToVersion(serializer Decoder, gv GroupVersioner) Decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NestedObjectEncoder is an optional interface that objects may implement to be given
0000000000000000000000000000000000000000;;	// an opportunity to encode any nested Objects / RawExtensions during serialization.
0000000000000000000000000000000000000000;;	type NestedObjectEncoder interface {
0000000000000000000000000000000000000000;;		EncodeNestedObjects(e Encoder) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NestedObjectDecoder is an optional interface that objects may implement to be given
0000000000000000000000000000000000000000;;	// an opportunity to decode any nested Objects / RawExtensions during serialization.
0000000000000000000000000000000000000000;;	type NestedObjectDecoder interface {
0000000000000000000000000000000000000000;;		DecodeNestedObjects(d Decoder) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	///////////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	// Non-codec interfaces
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ObjectDefaulter interface {
0000000000000000000000000000000000000000;;		// Default takes an object (must be a pointer) and applies any default values.
0000000000000000000000000000000000000000;;		// Defaulters may not error.
0000000000000000000000000000000000000000;;		Default(in Object)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ObjectVersioner interface {
0000000000000000000000000000000000000000;;		ConvertToVersion(in Object, gv GroupVersioner) (out Object, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectConvertor converts an object to a different version.
0000000000000000000000000000000000000000;;	type ObjectConvertor interface {
0000000000000000000000000000000000000000;;		// Convert attempts to convert one object into another, or returns an error. This method does
0000000000000000000000000000000000000000;;		// not guarantee the in object is not mutated. The context argument will be passed to
0000000000000000000000000000000000000000;;		// all nested conversions.
0000000000000000000000000000000000000000;;		Convert(in, out, context interface{}) error
0000000000000000000000000000000000000000;;		// ConvertToVersion takes the provided object and converts it the provided version. This
0000000000000000000000000000000000000000;;		// method does not guarantee that the in object is not mutated. This method is similar to
0000000000000000000000000000000000000000;;		// Convert() but handles specific details of choosing the correct output version.
0000000000000000000000000000000000000000;;		ConvertToVersion(in Object, gv GroupVersioner) (out Object, err error)
0000000000000000000000000000000000000000;;		ConvertFieldLabel(version, kind, label, value string) (string, string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectTyper contains methods for extracting the APIVersion and Kind
0000000000000000000000000000000000000000;;	// of objects.
0000000000000000000000000000000000000000;;	type ObjectTyper interface {
0000000000000000000000000000000000000000;;		// ObjectKinds returns the all possible group,version,kind of the provided object, true if
0000000000000000000000000000000000000000;;		// the object is unversioned, or an error if the object is not recognized
0000000000000000000000000000000000000000;;		// (IsNotRegisteredError will return true).
0000000000000000000000000000000000000000;;		ObjectKinds(Object) ([]schema.GroupVersionKind, bool, error)
0000000000000000000000000000000000000000;;		// Recognizes returns true if the scheme is able to handle the provided version and kind,
0000000000000000000000000000000000000000;;		// or more precisely that the provided version is a possible conversion or decoding
0000000000000000000000000000000000000000;;		// target.
0000000000000000000000000000000000000000;;		Recognizes(gvk schema.GroupVersionKind) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectCreater contains methods for instantiating an object by kind and version.
0000000000000000000000000000000000000000;;	type ObjectCreater interface {
0000000000000000000000000000000000000000;;		New(kind schema.GroupVersionKind) (out Object, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectCopier duplicates an object.
0000000000000000000000000000000000000000;;	type ObjectCopier interface {
0000000000000000000000000000000000000000;;		// Copy returns an exact copy of the provided Object, or an error if the
0000000000000000000000000000000000000000;;		// copy could not be completed.
0000000000000000000000000000000000000000;;		Copy(Object) (Object, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceVersioner provides methods for setting and retrieving
0000000000000000000000000000000000000000;;	// the resource version from an API object.
0000000000000000000000000000000000000000;;	type ResourceVersioner interface {
0000000000000000000000000000000000000000;;		SetResourceVersion(obj Object, version string) error
0000000000000000000000000000000000000000;;		ResourceVersion(obj Object) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelfLinker provides methods for setting and retrieving the SelfLink field of an API object.
0000000000000000000000000000000000000000;;	type SelfLinker interface {
0000000000000000000000000000000000000000;;		SetSelfLink(obj Object, selfLink string) error
0000000000000000000000000000000000000000;;		SelfLink(obj Object) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Knowing Name is sometimes necessary to use a SelfLinker.
0000000000000000000000000000000000000000;;		Name(obj Object) (string, error)
0000000000000000000000000000000000000000;;		// Knowing Namespace is sometimes necessary to use a SelfLinker
0000000000000000000000000000000000000000;;		Namespace(obj Object) (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All API types registered with Scheme must support the Object interface. Since objects in a scheme are
0000000000000000000000000000000000000000;;	// expected to be serialized to the wire, the interface an Object must provide to the Scheme allows
0000000000000000000000000000000000000000;;	// serializers to set the kind, version, and group the object is represented as. An Object may choose
0000000000000000000000000000000000000000;;	// to return a no-op ObjectKindAccessor in cases where it is not expected to be serialized.
0000000000000000000000000000000000000000;;	type Object interface {
0000000000000000000000000000000000000000;;		GetObjectKind() schema.ObjectKind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unstructured objects store values as map[string]interface{}, with only values that can be serialized
0000000000000000000000000000000000000000;;	// to JSON allowed.
0000000000000000000000000000000000000000;;	type Unstructured interface {
0000000000000000000000000000000000000000;;		// IsUnstructuredObject is a marker interface to allow objects that can be serialized but not introspected
0000000000000000000000000000000000000000;;		// to bypass conversion.
0000000000000000000000000000000000000000;;		IsUnstructuredObject()
0000000000000000000000000000000000000000;;		// UnstructuredContent returns a non-nil, mutable map of the contents of this object. Values may be
0000000000000000000000000000000000000000;;		// []interface{}, map[string]interface{}, or any primitive type. Contents are typically serialized to
0000000000000000000000000000000000000000;;		// and from JSON.
0000000000000000000000000000000000000000;;		UnstructuredContent() map[string]interface{}
0000000000000000000000000000000000000000;;		// IsList returns true if this type is a list or matches the list convention - has an array called "items".
0000000000000000000000000000000000000000;;		IsList() bool
0000000000000000000000000000000000000000;;		// EachListItem should pass a single item out of the list as an Object to the provided function. Any
0000000000000000000000000000000000000000;;		// error should terminate the iteration. If IsList() returns false, this method should return an error
0000000000000000000000000000000000000000;;		// instead of calling the provided function.
0000000000000000000000000000000000000000;;		EachListItem(func(Object) error) error
0000000000000000000000000000000000000000;;	}
