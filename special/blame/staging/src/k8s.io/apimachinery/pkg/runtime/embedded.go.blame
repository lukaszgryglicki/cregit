0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package runtime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encodable struct {
0000000000000000000000000000000000000000;;		E        Encoder `json:"-"`
0000000000000000000000000000000000000000;;		obj      Object
0000000000000000000000000000000000000000;;		versions []schema.GroupVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e encodable) GetObjectKind() schema.ObjectKind { return e.obj.GetObjectKind() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncodable creates an object that will be encoded with the provided codec on demand.
0000000000000000000000000000000000000000;;	// Provided as a convenience for test cases dealing with internal objects.
0000000000000000000000000000000000000000;;	func NewEncodable(e Encoder, obj Object, versions ...schema.GroupVersion) Object {
0000000000000000000000000000000000000000;;		if _, ok := obj.(*Unknown); ok {
0000000000000000000000000000000000000000;;			return obj
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return encodable{e, obj, versions}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (re encodable) UnmarshalJSON(in []byte) error {
0000000000000000000000000000000000000000;;		return errors.New("runtime.encodable cannot be unmarshalled from JSON")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal may get called on pointers or values, so implement MarshalJSON on value.
0000000000000000000000000000000000000000;;	// http://stackoverflow.com/questions/21390979/custom-marshaljson-never-gets-called-in-go
0000000000000000000000000000000000000000;;	func (re encodable) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return Encode(re.E, re.obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncodableList creates an object that will be encoded with the provided codec on demand.
0000000000000000000000000000000000000000;;	// Provided as a convenience for test cases dealing with internal objects.
0000000000000000000000000000000000000000;;	func NewEncodableList(e Encoder, objects []Object, versions ...schema.GroupVersion) []Object {
0000000000000000000000000000000000000000;;		out := make([]Object, len(objects))
0000000000000000000000000000000000000000;;		for i := range objects {
0000000000000000000000000000000000000000;;			if _, ok := objects[i].(*Unknown); ok {
0000000000000000000000000000000000000000;;				out[i] = objects[i]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out[i] = NewEncodable(e, objects[i], versions...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (re *Unknown) UnmarshalJSON(in []byte) error {
0000000000000000000000000000000000000000;;		if re == nil {
0000000000000000000000000000000000000000;;			return errors.New("runtime.Unknown: UnmarshalJSON on nil pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		re.TypeMeta = TypeMeta{}
0000000000000000000000000000000000000000;;		re.Raw = append(re.Raw[0:0], in...)
0000000000000000000000000000000000000000;;		re.ContentEncoding = ""
0000000000000000000000000000000000000000;;		re.ContentType = ContentTypeJSON
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal may get called on pointers or values, so implement MarshalJSON on value.
0000000000000000000000000000000000000000;;	// http://stackoverflow.com/questions/21390979/custom-marshaljson-never-gets-called-in-go
0000000000000000000000000000000000000000;;	func (re Unknown) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		// If ContentType is unset, we assume this is JSON.
0000000000000000000000000000000000000000;;		if re.ContentType != "" && re.ContentType != ContentTypeJSON {
0000000000000000000000000000000000000000;;			return nil, errors.New("runtime.Unknown: MarshalJSON on non-json data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if re.Raw == nil {
0000000000000000000000000000000000000000;;			return []byte("null"), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return re.Raw, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_runtime_Object_To_runtime_RawExtension(in *Object, out *RawExtension, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		if in == nil {
0000000000000000000000000000000000000000;;			out.Raw = []byte("null")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj := *in
0000000000000000000000000000000000000000;;		if unk, ok := obj.(*Unknown); ok {
0000000000000000000000000000000000000000;;			if unk.Raw != nil {
0000000000000000000000000000000000000000;;				out.Raw = unk.Raw
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj = out.Object
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			out.Raw = nil
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Object = obj
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_runtime_RawExtension_To_runtime_Object(in *RawExtension, out *Object, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		if in.Object != nil {
0000000000000000000000000000000000000000;;			*out = in.Object
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data := in.Raw
0000000000000000000000000000000000000000;;		if len(data) == 0 || (len(data) == 4 && string(data) == "null") {
0000000000000000000000000000000000000000;;			*out = nil
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*out = &Unknown{
0000000000000000000000000000000000000000;;			Raw: data,
0000000000000000000000000000000000000000;;			// TODO: Set ContentEncoding and ContentType appropriately.
0000000000000000000000000000000000000000;;			// Currently we set ContentTypeJSON to make tests passing.
0000000000000000000000000000000000000000;;			ContentType: ContentTypeJSON,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultEmbeddedConversions() []interface{} {
0000000000000000000000000000000000000000;;		return []interface{}{
0000000000000000000000000000000000000000;;			Convert_runtime_Object_To_runtime_RawExtension,
0000000000000000000000000000000000000000;;			Convert_runtime_RawExtension_To_runtime_Object,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
