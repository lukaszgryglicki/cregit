0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package serializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		serializertesting "k8s.io/apimachinery/pkg/runtime/serializer/testing"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/ghodss/yaml"
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;		flag "github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var fuzzIters = flag.Int("fuzz-iters", 50, "How many fuzzing iterations to do.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testMetaFactory struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (testMetaFactory) Interpret(data []byte) (*schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		findKind := struct {
0000000000000000000000000000000000000000;;			APIVersion string `json:"myVersionKey,omitempty"`
0000000000000000000000000000000000000000;;			ObjectKind string `json:"myKindKey,omitempty"`
0000000000000000000000000000000000000000;;		}{}
0000000000000000000000000000000000000000;;		// yaml is a superset of json, so we use it to decode here. That way,
0000000000000000000000000000000000000000;;		// we understand both.
0000000000000000000000000000000000000000;;		if err := yaml.Unmarshal(data, &findKind); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't get version/kind: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gv, err := schema.ParseGroupVersion(findKind.APIVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &schema.GroupVersionKind{Group: gv.Group, Version: gv.Version, Kind: findKind.ObjectKind}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestObjectFuzzer can randomly populate all the above objects.
0000000000000000000000000000000000000000;;	var TestObjectFuzzer = fuzz.New().NilChance(.5).NumElements(1, 100).Funcs(
0000000000000000000000000000000000000000;;		func(j *serializertesting.MyWeirdCustomEmbeddedVersionKindField, c fuzz.Continue) {
0000000000000000000000000000000000000000;;			c.FuzzNoCustom(j)
0000000000000000000000000000000000000000;;			j.APIVersion = ""
0000000000000000000000000000000000000000;;			j.ObjectKind = ""
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a new Scheme set up with the test objects.
0000000000000000000000000000000000000000;;	func GetTestScheme() (*runtime.Scheme, runtime.Codec) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Version: "v1"}
0000000000000000000000000000000000000000;;		externalGV2 := schema.GroupVersion{Version: "v2"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		// Ordinarily, we wouldn't add TestType2, but because this is a test and
0000000000000000000000000000000000000000;;		// both types are from the same package, we need to get it into the system
0000000000000000000000000000000000000000;;		// so that converter will match it with ExternalType2.
0000000000000000000000000000000000000000;;		s.AddKnownTypes(internalGV, &serializertesting.TestType1{}, &serializertesting.TestType2{}, &serializertesting.ExternalInternalSame{})
0000000000000000000000000000000000000000;;		s.AddKnownTypes(externalGV, &serializertesting.ExternalInternalSame{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("TestType1"), &serializertesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("TestType2"), &serializertesting.ExternalTestType2{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(internalGV.WithKind("TestType3"), &serializertesting.TestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("TestType3"), &serializertesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV2.WithKind("TestType1"), &serializertesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.AddUnversionedTypes(externalGV, &metav1.Status{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cf := newCodecFactory(s, newSerializersForScheme(s, testMetaFactory{}))
0000000000000000000000000000000000000000;;		codec := cf.LegacyCodec(schema.GroupVersion{Version: "v1"})
0000000000000000000000000000000000000000;;		return s, codec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var semantic = conversion.EqualitiesOrDie(
0000000000000000000000000000000000000000;;		func(a, b serializertesting.MyWeirdCustomEmbeddedVersionKindField) bool {
0000000000000000000000000000000000000000;;			a.APIVersion, a.ObjectKind = "", ""
0000000000000000000000000000000000000000;;			b.APIVersion, b.ObjectKind = "", ""
0000000000000000000000000000000000000000;;			return a == b
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func runTest(t *testing.T, source interface{}) {
0000000000000000000000000000000000000000;;		name := reflect.TypeOf(source).Elem().Name()
0000000000000000000000000000000000000000;;		TestObjectFuzzer.Fuzz(source)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, codec := GetTestScheme()
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(codec, source.(runtime.Object))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%v: %v (%#v)", name, err, source)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj2, err := runtime.Decode(codec, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("%v: %v (%v)", name, err, string(data))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !semantic.DeepEqual(source, obj2) {
0000000000000000000000000000000000000000;;			t.Errorf("1: %v: diff: %v", name, diff.ObjectGoPrintSideBySide(source, obj2))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj3 := reflect.New(reflect.TypeOf(source).Elem()).Interface()
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(codec, data, obj3.(runtime.Object)); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("2: %v: %v", name, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !semantic.DeepEqual(source, obj3) {
0000000000000000000000000000000000000000;;			t.Errorf("3: %v: diff: %v", name, diff.ObjectDiff(source, obj3))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTypes(t *testing.T) {
0000000000000000000000000000000000000000;;		table := []interface{}{
0000000000000000000000000000000000000000;;			&serializertesting.TestType1{},
0000000000000000000000000000000000000000;;			&serializertesting.ExternalInternalSame{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			// Try a few times, since runTest uses random values.
0000000000000000000000000000000000000000;;			for i := 0; i < *fuzzIters; i++ {
0000000000000000000000000000000000000000;;				runTest(t, item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestVersionedEncoding(t *testing.T) {
0000000000000000000000000000000000000000;;		s, _ := GetTestScheme()
0000000000000000000000000000000000000000;;		cf := newCodecFactory(s, newSerializersForScheme(s, testMetaFactory{}))
0000000000000000000000000000000000000000;;		info, _ := runtime.SerializerInfoForMediaType(cf.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		encoder := info.Serializer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := cf.CodecForVersions(encoder, nil, schema.GroupVersion{Version: "v2"}, nil)
0000000000000000000000000000000000000000;;		out, err := runtime.Encode(codec, &serializertesting.TestType1{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if string(out) != `{"myVersionKey":"v2","myKindKey":"TestType1"}`+"\n" {
0000000000000000000000000000000000000000;;			t.Fatal(string(out))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec = cf.CodecForVersions(encoder, nil, schema.GroupVersion{Version: "v3"}, nil)
0000000000000000000000000000000000000000;;		_, err = runtime.Encode(codec, &serializertesting.TestType1{})
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unversioned encode with no versions is written directly to wire
0000000000000000000000000000000000000000;;		codec = cf.CodecForVersions(encoder, nil, runtime.InternalGroupVersioner, nil)
0000000000000000000000000000000000000000;;		out, err = runtime.Encode(codec, &serializertesting.TestType1{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if string(out) != `{}`+"\n" {
0000000000000000000000000000000000000000;;			t.Fatal(string(out))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultipleNames(t *testing.T) {
0000000000000000000000000000000000000000;;		_, codec := GetTestScheme()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, _, err := codec.Decode([]byte(`{"myKindKey":"TestType3","myVersionKey":"v1","A":"value"}`), nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		internal := obj.(*serializertesting.TestType1)
0000000000000000000000000000000000000000;;		if internal.A != "value" {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected decoded object: %#v", internal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := runtime.Encode(codec, internal)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !strings.Contains(string(out), `"myKindKey":"TestType1"`) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected encoded output: %s", string(out))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestConvertTypesWhenDefaultNamesMatch(t *testing.T) {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Version: "v1"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		// create two names internally, with TestType1 being preferred
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(internalGV.WithKind("TestType1"), &serializertesting.TestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(internalGV.WithKind("OtherType1"), &serializertesting.TestType1{})
0000000000000000000000000000000000000000;;		// create two names externally, with TestType1 being preferred
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("TestType1"), &serializertesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypeWithName(externalGV.WithKind("OtherType1"), &serializertesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ext := &serializertesting.ExternalTestType1{}
0000000000000000000000000000000000000000;;		ext.APIVersion = "v1"
0000000000000000000000000000000000000000;;		ext.ObjectKind = "OtherType1"
0000000000000000000000000000000000000000;;		ext.A = "test"
0000000000000000000000000000000000000000;;		data, err := json.Marshal(ext)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expect := &serializertesting.TestType1{A: "test"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		codec := newCodecFactory(s, newSerializersForScheme(s, testMetaFactory{})).LegacyCodec(schema.GroupVersion{Version: "v1"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, err := runtime.Decode(codec, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !semantic.DeepEqual(expect, obj) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		into := &serializertesting.TestType1{}
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(codec, data, into); err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !semantic.DeepEqual(expect, into) {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEncode_Ptr(t *testing.T) {
0000000000000000000000000000000000000000;;		_, codec := GetTestScheme()
0000000000000000000000000000000000000000;;		tt := &serializertesting.TestType1{A: "I am a pointer object"}
0000000000000000000000000000000000000000;;		data, err := runtime.Encode(codec, tt)
0000000000000000000000000000000000000000;;		obj2, err2 := runtime.Decode(codec, data)
0000000000000000000000000000000000000000;;		if err != nil || err2 != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("Failure: '%v' '%v'\n%s", err, err2, data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := obj2.(*serializertesting.TestType1); !ok {
0000000000000000000000000000000000000000;;			t.Fatalf("Got wrong type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !semantic.DeepEqual(obj2, tt) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected:\n %#v,\n Got:\n %#v", tt, obj2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBadJSONRejection(t *testing.T) {
0000000000000000000000000000000000000000;;		log.SetOutput(os.Stderr)
0000000000000000000000000000000000000000;;		_, codec := GetTestScheme()
0000000000000000000000000000000000000000;;		badJSONs := [][]byte{
0000000000000000000000000000000000000000;;			[]byte(`{"myVersionKey":"v1"}`),                          // Missing kind
0000000000000000000000000000000000000000;;			[]byte(`{"myVersionKey":"v1","myKindKey":"bar"}`),        // Unknown kind
0000000000000000000000000000000000000000;;			[]byte(`{"myVersionKey":"bar","myKindKey":"TestType1"}`), // Unknown version
0000000000000000000000000000000000000000;;			[]byte(`{"myKindKey":"TestType1"}`),                      // Missing version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, b := range badJSONs {
0000000000000000000000000000000000000000;;			if _, err := runtime.Decode(codec, b); err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("Did not reject bad json: %s", string(b))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		badJSONKindMismatch := []byte(`{"myVersionKey":"v1","myKindKey":"ExternalInternalSame"}`)
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(codec, badJSONKindMismatch, &serializertesting.TestType1{}); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Kind is set but doesn't match the object type: %s", badJSONKindMismatch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := runtime.DecodeInto(codec, []byte(``), &serializertesting.TestType1{}); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Should allow empty decode: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, _, err := codec.Decode([]byte(``), &schema.GroupVersionKind{Kind: "ExternalInternalSame"}, nil); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Did not give error for empty data with only kind default")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, _, err := codec.Decode([]byte(`{"myVersionKey":"v1"}`), &schema.GroupVersionKind{Kind: "ExternalInternalSame"}, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Gave error for version and kind default")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, _, err := codec.Decode([]byte(`{"myKindKey":"ExternalInternalSame"}`), &schema.GroupVersionKind{Version: "v1"}, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Gave error for version and kind default")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, _, err := codec.Decode([]byte(``), &schema.GroupVersionKind{Kind: "ExternalInternalSame", Version: "v1"}, nil); err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Gave error for version and kind defaulted: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := runtime.Decode(codec, []byte(``)); err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Did not give error for empty data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a new Scheme set up with the test objects needed by TestDirectCodec.
0000000000000000000000000000000000000000;;	func GetDirectCodecTestScheme() *runtime.Scheme {
0000000000000000000000000000000000000000;;		internalGV := schema.GroupVersion{Version: runtime.APIVersionInternal}
0000000000000000000000000000000000000000;;		externalGV := schema.GroupVersion{Version: "v1"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := runtime.NewScheme()
0000000000000000000000000000000000000000;;		// Ordinarily, we wouldn't add TestType2, but because this is a test and
0000000000000000000000000000000000000000;;		// both types are from the same package, we need to get it into the system
0000000000000000000000000000000000000000;;		// so that converter will match it with ExternalType2.
0000000000000000000000000000000000000000;;		s.AddKnownTypes(internalGV, &serializertesting.TestType1{})
0000000000000000000000000000000000000000;;		s.AddKnownTypes(externalGV, &serializertesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.AddUnversionedTypes(externalGV, &metav1.Status{})
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDirectCodec(t *testing.T) {
0000000000000000000000000000000000000000;;		s := GetDirectCodecTestScheme()
0000000000000000000000000000000000000000;;		cf := newCodecFactory(s, newSerializersForScheme(s, testMetaFactory{}))
0000000000000000000000000000000000000000;;		info, _ := runtime.SerializerInfoForMediaType(cf.SupportedMediaTypes(), runtime.ContentTypeJSON)
0000000000000000000000000000000000000000;;		serializer := info.Serializer
0000000000000000000000000000000000000000;;		df := DirectCodecFactory{cf}
0000000000000000000000000000000000000000;;		ignoredGV, err := schema.ParseGroupVersion("ignored group/ignored version")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		directEncoder := df.EncoderForVersion(serializer, ignoredGV)
0000000000000000000000000000000000000000;;		directDecoder := df.DecoderToVersion(serializer, ignoredGV)
0000000000000000000000000000000000000000;;		out, err := runtime.Encode(directEncoder, &serializertesting.ExternalTestType1{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if string(out) != `{"myVersionKey":"v1","myKindKey":"ExternalTestType1"}`+"\n" {
0000000000000000000000000000000000000000;;			t.Fatal(string(out))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a, _, err := directDecoder.Decode(out, nil, nil)
0000000000000000000000000000000000000000;;		e := &serializertesting.ExternalTestType1{
0000000000000000000000000000000000000000;;			MyWeirdCustomEmbeddedVersionKindField: serializertesting.MyWeirdCustomEmbeddedVersionKindField{
0000000000000000000000000000000000000000;;				APIVersion: "v1",
0000000000000000000000000000000000000000;;				ObjectKind: "ExternalTestType1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !semantic.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Fatalf("expect %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
