0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
e3dc20715c634d0ee264047be4592cf2099eaf8f;pkg/fields/selector_test.go[pkg/fields/selector_test.go][staging/src/k8s.io/apimachinery/pkg/fields/selector_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fields
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSplitTerms(t *testing.T) {
0000000000000000000000000000000000000000;;		testcases := map[string][]string{
0000000000000000000000000000000000000000;;			// Simple selectors
0000000000000000000000000000000000000000;;			`a`:                            {`a`},
0000000000000000000000000000000000000000;;			`a=avalue`:                     {`a=avalue`},
0000000000000000000000000000000000000000;;			`a=avalue,b=bvalue`:            {`a=avalue`, `b=bvalue`},
0000000000000000000000000000000000000000;;			`a=avalue,b==bvalue,c!=cvalue`: {`a=avalue`, `b==bvalue`, `c!=cvalue`},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Empty terms
0000000000000000000000000000000000000000;;			``:     nil,
0000000000000000000000000000000000000000;;			`a=a,`: {`a=a`, ``},
0000000000000000000000000000000000000000;;			`,a=a`: {``, `a=a`},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Escaped values
0000000000000000000000000000000000000000;;			`k=\,,k2=v2`:   {`k=\,`, `k2=v2`},   // escaped comma in value
0000000000000000000000000000000000000000;;			`k=\\,k2=v2`:   {`k=\\`, `k2=v2`},   // escaped backslash, unescaped comma
0000000000000000000000000000000000000000;;			`k=\\\,,k2=v2`: {`k=\\\,`, `k2=v2`}, // escaped backslash and comma
0000000000000000000000000000000000000000;;			`k=\a\b\`:      {`k=\a\b\`},         // non-escape sequences
0000000000000000000000000000000000000000;;			`k=\`:          {`k=\`},             // orphan backslash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Multi-byte
0000000000000000000000000000000000000000;;			`함=수,목=록`: {`함=수`, `목=록`},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for selector, expectedTerms := range testcases {
0000000000000000000000000000000000000000;;			if terms := splitTerms(selector); !reflect.DeepEqual(terms, expectedTerms) {
0000000000000000000000000000000000000000;;				t.Errorf("splitSelectors(`%s`): Expected\n%#v\ngot\n%#v", selector, expectedTerms, terms)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSplitTerm(t *testing.T) {
0000000000000000000000000000000000000000;;		testcases := map[string]struct {
0000000000000000000000000000000000000000;;			lhs string
0000000000000000000000000000000000000000;;			op  string
0000000000000000000000000000000000000000;;			rhs string
0000000000000000000000000000000000000000;;			ok  bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// Simple terms
0000000000000000000000000000000000000000;;			`a=value`:  {lhs: `a`, op: `=`, rhs: `value`, ok: true},
0000000000000000000000000000000000000000;;			`b==value`: {lhs: `b`, op: `==`, rhs: `value`, ok: true},
0000000000000000000000000000000000000000;;			`c!=value`: {lhs: `c`, op: `!=`, rhs: `value`, ok: true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Empty or invalid terms
0000000000000000000000000000000000000000;;			``:  {lhs: ``, op: ``, rhs: ``, ok: false},
0000000000000000000000000000000000000000;;			`a`: {lhs: ``, op: ``, rhs: ``, ok: false},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Escaped values
0000000000000000000000000000000000000000;;			`k=\,`:          {lhs: `k`, op: `=`, rhs: `\,`, ok: true},
0000000000000000000000000000000000000000;;			`k=\=`:          {lhs: `k`, op: `=`, rhs: `\=`, ok: true},
0000000000000000000000000000000000000000;;			`k=\\\a\b\=\,\`: {lhs: `k`, op: `=`, rhs: `\\\a\b\=\,\`, ok: true},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Multi-byte
0000000000000000000000000000000000000000;;			`함=수`: {lhs: `함`, op: `=`, rhs: `수`, ok: true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for term, expected := range testcases {
0000000000000000000000000000000000000000;;			lhs, op, rhs, ok := splitTerm(term)
0000000000000000000000000000000000000000;;			if lhs != expected.lhs || op != expected.op || rhs != expected.rhs || ok != expected.ok {
0000000000000000000000000000000000000000;;				t.Errorf(
0000000000000000000000000000000000000000;;					"splitTerm(`%s`): Expected\n%s,%s,%s,%v\nGot\n%s,%s,%s,%v",
0000000000000000000000000000000000000000;;					term,
0000000000000000000000000000000000000000;;					expected.lhs, expected.op, expected.rhs, expected.ok,
0000000000000000000000000000000000000000;;					lhs, op, rhs, ok,
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEscapeValue(t *testing.T) {
0000000000000000000000000000000000000000;;		// map values to their normalized escaped values
0000000000000000000000000000000000000000;;		testcases := map[string]string{
0000000000000000000000000000000000000000;;			``:      ``,
0000000000000000000000000000000000000000;;			`a`:     `a`,
0000000000000000000000000000000000000000;;			`=`:     `\=`,
0000000000000000000000000000000000000000;;			`,`:     `\,`,
0000000000000000000000000000000000000000;;			`\`:     `\\`,
0000000000000000000000000000000000000000;;			`\=\,\`: `\\\=\\\,\\`,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for unescapedValue, escapedValue := range testcases {
0000000000000000000000000000000000000000;;			actualEscaped := EscapeValue(unescapedValue)
0000000000000000000000000000000000000000;;			if actualEscaped != escapedValue {
0000000000000000000000000000000000000000;;				t.Errorf("EscapeValue(%s): expected %s, got %s", unescapedValue, escapedValue, actualEscaped)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actualUnescaped, err := UnescapeValue(escapedValue)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("UnescapeValue(%s): unexpected error %v", escapedValue, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if actualUnescaped != unescapedValue {
0000000000000000000000000000000000000000;;				t.Errorf("UnescapeValue(%s): expected %s, got %s", escapedValue, unescapedValue, actualUnescaped)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test invalid escape sequences
0000000000000000000000000000000000000000;;		invalidTestcases := []string{
0000000000000000000000000000000000000000;;			`\`,   // orphan slash is invalid
0000000000000000000000000000000000000000;;			`\\\`, // orphan slash is invalid
0000000000000000000000000000000000000000;;			`\a`,  // unrecognized escape sequence is invalid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, invalidValue := range invalidTestcases {
0000000000000000000000000000000000000000;;			_, err := UnescapeValue(invalidValue)
0000000000000000000000000000000000000000;;			if _, ok := err.(InvalidEscapeSequence); !ok || err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("UnescapeValue(%s): expected invalid escape sequence error, got %#v", invalidValue, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelectorParse(t *testing.T) {
0000000000000000000000000000000000000000;;		testGoodStrings := []string{
0000000000000000000000000000000000000000;;			"x=a,y=b,z=c",
0000000000000000000000000000000000000000;;			"",
0000000000000000000000000000000000000000;;			"x!=a,y=b",
0000000000000000000000000000000000000000;;			`x=a||y\=b`,
0000000000000000000000000000000000000000;;			`x=a\=\=b`,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testBadStrings := []string{
0000000000000000000000000000000000000000;;			"x=a||y=b",
0000000000000000000000000000000000000000;;			"x==a==b",
0000000000000000000000000000000000000000;;			"x=a,b",
0000000000000000000000000000000000000000;;			"x in (a)",
0000000000000000000000000000000000000000;;			"x in (a,b,c)",
0000000000000000000000000000000000000000;;			"x",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range testGoodStrings {
0000000000000000000000000000000000000000;;			lq, err := ParseSelector(test)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: error %v (%#v)\n", test, err, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test != lq.String() {
0000000000000000000000000000000000000000;;				t.Errorf("%v restring gave: %v\n", test, lq.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range testBadStrings {
0000000000000000000000000000000000000000;;			_, err := ParseSelector(test)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%v: did not get expected error\n", test)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeterministicParse(t *testing.T) {
0000000000000000000000000000000000000000;;		s1, err := ParseSelector("x=a,a=x")
0000000000000000000000000000000000000000;;		s2, err2 := ParseSelector("a=x,x=a")
0000000000000000000000000000000000000000;;		if err != nil || err2 != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unexpected parse error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s1.String() != s2.String() {
0000000000000000000000000000000000000000;;			t.Errorf("Non-deterministic parse")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectMatch(t *testing.T, selector string, ls Set) {
0000000000000000000000000000000000000000;;		lq, err := ParseSelector(selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to parse %v as a selector\n", selector)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !lq.Matches(ls) {
0000000000000000000000000000000000000000;;			t.Errorf("Wanted %s to match '%s', but it did not.\n", selector, ls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectNoMatch(t *testing.T, selector string, ls Set) {
0000000000000000000000000000000000000000;;		lq, err := ParseSelector(selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to parse %v as a selector\n", selector)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lq.Matches(ls) {
0000000000000000000000000000000000000000;;			t.Errorf("Wanted '%s' to not match '%s', but it did.", selector, ls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEverything(t *testing.T) {
0000000000000000000000000000000000000000;;		if !Everything().Matches(Set{"x": "y"}) {
0000000000000000000000000000000000000000;;			t.Errorf("Nil selector didn't match")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !Everything().Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("Everything was not empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSelectorMatches(t *testing.T) {
0000000000000000000000000000000000000000;;		expectMatch(t, "", Set{"x": "y"})
0000000000000000000000000000000000000000;;		expectMatch(t, "x=y", Set{"x": "y"})
0000000000000000000000000000000000000000;;		expectMatch(t, "x=y,z=w", Set{"x": "y", "z": "w"})
0000000000000000000000000000000000000000;;		expectMatch(t, "x!=y,z!=w", Set{"x": "z", "z": "a"})
0000000000000000000000000000000000000000;;		expectMatch(t, "notin=in", Set{"notin": "in"}) // in and notin in exactMatch
0000000000000000000000000000000000000000;;		expectNoMatch(t, "x=y", Set{"x": "z"})
0000000000000000000000000000000000000000;;		expectNoMatch(t, "x=y,z=w", Set{"x": "w", "z": "w"})
0000000000000000000000000000000000000000;;		expectNoMatch(t, "x!=y,z!=w", Set{"x": "z", "z": "w"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fieldset := Set{
0000000000000000000000000000000000000000;;			"foo":     "bar",
0000000000000000000000000000000000000000;;			"baz":     "blah",
0000000000000000000000000000000000000000;;			"complex": `=value\,\`,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectMatch(t, "foo=bar", fieldset)
0000000000000000000000000000000000000000;;		expectMatch(t, "baz=blah", fieldset)
0000000000000000000000000000000000000000;;		expectMatch(t, "foo=bar,baz=blah", fieldset)
0000000000000000000000000000000000000000;;		expectMatch(t, `foo=bar,baz=blah,complex=\=value\\\,\\`, fieldset)
0000000000000000000000000000000000000000;;		expectNoMatch(t, "foo=blah", fieldset)
0000000000000000000000000000000000000000;;		expectNoMatch(t, "baz=bar", fieldset)
0000000000000000000000000000000000000000;;		expectNoMatch(t, "foo=bar,foobar=bar,baz=blah", fieldset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestOneTermEqualSelector(t *testing.T) {
0000000000000000000000000000000000000000;;		if !OneTermEqualSelector("x", "y").Matches(Set{"x": "y"}) {
0000000000000000000000000000000000000000;;			t.Errorf("No match when match expected.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if OneTermEqualSelector("x", "y").Matches(Set{"x": "z"}) {
0000000000000000000000000000000000000000;;			t.Errorf("Match when none expected.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectMatchDirect(t *testing.T, selector, ls Set) {
0000000000000000000000000000000000000000;;		if !SelectorFromSet(selector).Matches(ls) {
0000000000000000000000000000000000000000;;			t.Errorf("Wanted %s to match '%s', but it did not.\n", selector, ls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expectNoMatchDirect(t *testing.T, selector, ls Set) {
0000000000000000000000000000000000000000;;		if SelectorFromSet(selector).Matches(ls) {
0000000000000000000000000000000000000000;;			t.Errorf("Wanted '%s' to not match '%s', but it did.", selector, ls)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetMatches(t *testing.T) {
0000000000000000000000000000000000000000;;		labelset := Set{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "blah",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectMatchDirect(t, Set{}, labelset)
0000000000000000000000000000000000000000;;		expectMatchDirect(t, Set{"foo": "bar"}, labelset)
0000000000000000000000000000000000000000;;		expectMatchDirect(t, Set{"baz": "blah"}, labelset)
0000000000000000000000000000000000000000;;		expectMatchDirect(t, Set{"foo": "bar", "baz": "blah"}, labelset)
0000000000000000000000000000000000000000;;		expectNoMatchDirect(t, Set{"foo": "=blah"}, labelset)
0000000000000000000000000000000000000000;;		expectNoMatchDirect(t, Set{"baz": "=bar"}, labelset)
0000000000000000000000000000000000000000;;		expectNoMatchDirect(t, Set{"foo": "=bar", "foobar": "bar", "baz": "blah"}, labelset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestNilMapIsValid(t *testing.T) {
0000000000000000000000000000000000000000;;		selector := Set(nil).AsSelector()
0000000000000000000000000000000000000000;;		if selector == nil {
0000000000000000000000000000000000000000;;			t.Errorf("Selector for nil set should be Everything")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !selector.Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("Selector for nil set should be Empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestSetIsEmpty(t *testing.T) {
0000000000000000000000000000000000000000;;		if !(Set{}).AsSelector().Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("Empty set should be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !(andTerm(nil)).Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("Nil andTerm should be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (&hasTerm{}).Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("hasTerm should not be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (&notHasTerm{}).Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("notHasTerm should not be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !(andTerm{andTerm{}}).Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("Nested andTerm should be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (andTerm{&hasTerm{"a", "b"}}).Empty() {
0000000000000000000000000000000000000000;;			t.Errorf("Nested andTerm should not be empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRequiresExactMatch(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			S     Selector
0000000000000000000000000000000000000000;;			Label string
0000000000000000000000000000000000000000;;			Value string
0000000000000000000000000000000000000000;;			Found bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"empty set":                 {Set{}.AsSelector(), "test", "", false},
0000000000000000000000000000000000000000;;			"empty hasTerm":             {&hasTerm{}, "test", "", false},
0000000000000000000000000000000000000000;;			"skipped hasTerm":           {&hasTerm{"a", "b"}, "test", "", false},
0000000000000000000000000000000000000000;;			"valid hasTerm":             {&hasTerm{"test", "b"}, "test", "b", true},
0000000000000000000000000000000000000000;;			"valid hasTerm no value":    {&hasTerm{"test", ""}, "test", "", true},
0000000000000000000000000000000000000000;;			"valid notHasTerm":          {&notHasTerm{"test", "b"}, "test", "", false},
0000000000000000000000000000000000000000;;			"valid notHasTerm no value": {&notHasTerm{"test", ""}, "test", "", false},
0000000000000000000000000000000000000000;;			"nil andTerm":               {andTerm(nil), "test", "", false},
0000000000000000000000000000000000000000;;			"empty andTerm":             {andTerm{}, "test", "", false},
0000000000000000000000000000000000000000;;			"nested andTerm":            {andTerm{andTerm{}}, "test", "", false},
0000000000000000000000000000000000000000;;			"nested andTerm matches":    {andTerm{&hasTerm{"test", "b"}}, "test", "b", true},
0000000000000000000000000000000000000000;;			"andTerm with non-match":    {andTerm{&hasTerm{}, &hasTerm{"test", "b"}}, "test", "b", true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range testCases {
0000000000000000000000000000000000000000;;			value, found := v.S.RequiresExactMatch(v.Label)
0000000000000000000000000000000000000000;;			if value != v.Value {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected value %s, got %s", k, v.Value, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if found != v.Found {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected found %t, got %t", k, v.Found, found)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestTransform(t *testing.T) {
0000000000000000000000000000000000000000;;		testCases := []struct {
0000000000000000000000000000000000000000;;			name      string
0000000000000000000000000000000000000000;;			selector  string
0000000000000000000000000000000000000000;;			transform func(field, value string) (string, string, error)
0000000000000000000000000000000000000000;;			result    string
0000000000000000000000000000000000000000;;			isEmpty   bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:      "empty selector",
0000000000000000000000000000000000000000;;				selector:  "",
0000000000000000000000000000000000000000;;				transform: func(field, value string) (string, string, error) { return field, value, nil },
0000000000000000000000000000000000000000;;				result:    "",
0000000000000000000000000000000000000000;;				isEmpty:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:      "no-op transform",
0000000000000000000000000000000000000000;;				selector:  "a=b,c=d",
0000000000000000000000000000000000000000;;				transform: func(field, value string) (string, string, error) { return field, value, nil },
0000000000000000000000000000000000000000;;				result:    "a=b,c=d",
0000000000000000000000000000000000000000;;				isEmpty:   false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "transform one field",
0000000000000000000000000000000000000000;;				selector: "a=b,c=d",
0000000000000000000000000000000000000000;;				transform: func(field, value string) (string, string, error) {
0000000000000000000000000000000000000000;;					if field == "a" {
0000000000000000000000000000000000000000;;						return "e", "f", nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return field, value, nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result:  "e=f,c=d",
0000000000000000000000000000000000000000;;				isEmpty: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:      "remove field to make empty",
0000000000000000000000000000000000000000;;				selector:  "a=b",
0000000000000000000000000000000000000000;;				transform: func(field, value string) (string, string, error) { return "", "", nil },
0000000000000000000000000000000000000000;;				result:    "",
0000000000000000000000000000000000000000;;				isEmpty:   true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:     "remove only one field",
0000000000000000000000000000000000000000;;				selector: "a=b,c=d,e=f",
0000000000000000000000000000000000000000;;				transform: func(field, value string) (string, string, error) {
0000000000000000000000000000000000000000;;					if field == "c" {
0000000000000000000000000000000000000000;;						return "", "", nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return field, value, nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				result:  "a=b,e=f",
0000000000000000000000000000000000000000;;				isEmpty: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range testCases {
0000000000000000000000000000000000000000;;			result, err := ParseAndTransformSelector(tc.selector, tc.transform)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected error during Transform: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result.Empty() != tc.isEmpty {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] expected empty: %t, got: %t", i, tc.isEmpty, result.Empty)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result.String() != tc.result {
0000000000000000000000000000000000000000;;				t.Errorf("[%d] unexpected result: %s", i, result.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
