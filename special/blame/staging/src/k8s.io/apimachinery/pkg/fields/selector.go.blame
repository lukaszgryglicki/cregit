0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
e3dc20715c634d0ee264047be4592cf2099eaf8f;pkg/fields/selector.go[pkg/fields/selector.go][staging/src/k8s.io/apimachinery/pkg/fields/selector.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fields
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/selection"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Selector represents a field selector.
0000000000000000000000000000000000000000;;	type Selector interface {
0000000000000000000000000000000000000000;;		// Matches returns true if this selector matches the given set of fields.
0000000000000000000000000000000000000000;;		Matches(Fields) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Empty returns true if this selector does not restrict the selection space.
0000000000000000000000000000000000000000;;		Empty() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RequiresExactMatch allows a caller to introspect whether a given selector
0000000000000000000000000000000000000000;;		// requires a single specific field to be set, and if so returns the value it
0000000000000000000000000000000000000000;;		// requires.
0000000000000000000000000000000000000000;;		RequiresExactMatch(field string) (value string, found bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Transform returns a new copy of the selector after TransformFunc has been
0000000000000000000000000000000000000000;;		// applied to the entire selector, or an error if fn returns an error.
0000000000000000000000000000000000000000;;		// If for a given requirement both field and value are transformed to empty
0000000000000000000000000000000000000000;;		// string, the requirement is skipped.
0000000000000000000000000000000000000000;;		Transform(fn TransformFunc) (Selector, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Requirements converts this interface to Requirements to expose
0000000000000000000000000000000000000000;;		// more detailed selection information.
0000000000000000000000000000000000000000;;		Requirements() Requirements
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// String returns a human readable string that represents this selector.
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Everything returns a selector that matches all fields.
0000000000000000000000000000000000000000;;	func Everything() Selector {
0000000000000000000000000000000000000000;;		return andTerm{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type hasTerm struct {
0000000000000000000000000000000000000000;;		field, value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *hasTerm) Matches(ls Fields) bool {
0000000000000000000000000000000000000000;;		return ls.Get(t.field) == t.value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *hasTerm) Empty() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *hasTerm) RequiresExactMatch(field string) (value string, found bool) {
0000000000000000000000000000000000000000;;		if t.field == field {
0000000000000000000000000000000000000000;;			return t.value, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *hasTerm) Transform(fn TransformFunc) (Selector, error) {
0000000000000000000000000000000000000000;;		field, value, err := fn(t.field, t.value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(field) == 0 && len(value) == 0 {
0000000000000000000000000000000000000000;;			return Everything(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &hasTerm{field, value}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *hasTerm) Requirements() Requirements {
0000000000000000000000000000000000000000;;		return []Requirement{{
0000000000000000000000000000000000000000;;			Field:    t.field,
0000000000000000000000000000000000000000;;			Operator: selection.Equals,
0000000000000000000000000000000000000000;;			Value:    t.value,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *hasTerm) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v=%v", t.field, EscapeValue(t.value))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type notHasTerm struct {
0000000000000000000000000000000000000000;;		field, value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *notHasTerm) Matches(ls Fields) bool {
0000000000000000000000000000000000000000;;		return ls.Get(t.field) != t.value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *notHasTerm) Empty() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *notHasTerm) RequiresExactMatch(field string) (value string, found bool) {
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *notHasTerm) Transform(fn TransformFunc) (Selector, error) {
0000000000000000000000000000000000000000;;		field, value, err := fn(t.field, t.value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(field) == 0 && len(value) == 0 {
0000000000000000000000000000000000000000;;			return Everything(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &notHasTerm{field, value}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *notHasTerm) Requirements() Requirements {
0000000000000000000000000000000000000000;;		return []Requirement{{
0000000000000000000000000000000000000000;;			Field:    t.field,
0000000000000000000000000000000000000000;;			Operator: selection.NotEquals,
0000000000000000000000000000000000000000;;			Value:    t.value,
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *notHasTerm) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v!=%v", t.field, EscapeValue(t.value))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type andTerm []Selector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t andTerm) Matches(ls Fields) bool {
0000000000000000000000000000000000000000;;		for _, q := range t {
0000000000000000000000000000000000000000;;			if !q.Matches(ls) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t andTerm) Empty() bool {
0000000000000000000000000000000000000000;;		if t == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len([]Selector(t)) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range t {
0000000000000000000000000000000000000000;;			if !t[i].Empty() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t andTerm) RequiresExactMatch(field string) (string, bool) {
0000000000000000000000000000000000000000;;		if t == nil || len([]Selector(t)) == 0 {
0000000000000000000000000000000000000000;;			return "", false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range t {
0000000000000000000000000000000000000000;;			if value, found := t[i].RequiresExactMatch(field); found {
0000000000000000000000000000000000000000;;				return value, found
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t andTerm) Transform(fn TransformFunc) (Selector, error) {
0000000000000000000000000000000000000000;;		next := make([]Selector, 0, len([]Selector(t)))
0000000000000000000000000000000000000000;;		for _, s := range []Selector(t) {
0000000000000000000000000000000000000000;;			n, err := s.Transform(fn)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !n.Empty() {
0000000000000000000000000000000000000000;;				next = append(next, n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return andTerm(next), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t andTerm) Requirements() Requirements {
0000000000000000000000000000000000000000;;		reqs := make([]Requirement, 0, len(t))
0000000000000000000000000000000000000000;;		for _, s := range []Selector(t) {
0000000000000000000000000000000000000000;;			rs := s.Requirements()
0000000000000000000000000000000000000000;;			reqs = append(reqs, rs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reqs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t andTerm) String() string {
0000000000000000000000000000000000000000;;		var terms []string
0000000000000000000000000000000000000000;;		for _, q := range t {
0000000000000000000000000000000000000000;;			terms = append(terms, q.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(terms, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectorFromSet returns a Selector which will match exactly the given Set. A
0000000000000000000000000000000000000000;;	// nil Set is considered equivalent to Everything().
0000000000000000000000000000000000000000;;	func SelectorFromSet(ls Set) Selector {
0000000000000000000000000000000000000000;;		if ls == nil {
0000000000000000000000000000000000000000;;			return Everything()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items := make([]Selector, 0, len(ls))
0000000000000000000000000000000000000000;;		for field, value := range ls {
0000000000000000000000000000000000000000;;			items = append(items, &hasTerm{field: field, value: value})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(items) == 1 {
0000000000000000000000000000000000000000;;			return items[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return andTerm(items)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// valueEscaper prefixes \,= characters with a backslash
0000000000000000000000000000000000000000;;	var valueEscaper = strings.NewReplacer(
0000000000000000000000000000000000000000;;		// escape \ characters
0000000000000000000000000000000000000000;;		`\`, `\\`,
0000000000000000000000000000000000000000;;		// then escape , and = characters to allow unambiguous parsing of the value in a fieldSelector
0000000000000000000000000000000000000000;;		`,`, `\,`,
0000000000000000000000000000000000000000;;		`=`, `\=`,
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EscapeValue escapes an arbitrary literal string for use as a fieldSelector value
0000000000000000000000000000000000000000;;	func EscapeValue(s string) string {
0000000000000000000000000000000000000000;;		return valueEscaper.Replace(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvalidEscapeSequence indicates an error occurred unescaping a field selector
0000000000000000000000000000000000000000;;	type InvalidEscapeSequence struct {
0000000000000000000000000000000000000000;;		sequence string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i InvalidEscapeSequence) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("invalid field selector: invalid escape sequence: %s", i.sequence)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnescapedRune indicates an error occurred unescaping a field selector
0000000000000000000000000000000000000000;;	type UnescapedRune struct {
0000000000000000000000000000000000000000;;		r rune
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i UnescapedRune) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("invalid field selector: unescaped character in value: %v", i.r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnescapeValue unescapes a fieldSelector value and returns the original literal value.
0000000000000000000000000000000000000000;;	// May return the original string if it contains no escaped or special characters.
0000000000000000000000000000000000000000;;	func UnescapeValue(s string) (string, error) {
0000000000000000000000000000000000000000;;		// if there's no escaping or special characters, just return to avoid allocation
0000000000000000000000000000000000000000;;		if !strings.ContainsAny(s, `\,=`) {
0000000000000000000000000000000000000000;;			return s, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := bytes.NewBuffer(make([]byte, 0, len(s)))
0000000000000000000000000000000000000000;;		inSlash := false
0000000000000000000000000000000000000000;;		for _, c := range s {
0000000000000000000000000000000000000000;;			if inSlash {
0000000000000000000000000000000000000000;;				switch c {
0000000000000000000000000000000000000000;;				case '\\', ',', '=':
0000000000000000000000000000000000000000;;					// omit the \ for recognized escape sequences
0000000000000000000000000000000000000000;;					v.WriteRune(c)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// error on unrecognized escape sequences
0000000000000000000000000000000000000000;;					return "", InvalidEscapeSequence{sequence: string([]rune{'\\', c})}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				inSlash = false
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				inSlash = true
0000000000000000000000000000000000000000;;			case ',', '=':
0000000000000000000000000000000000000000;;				// unescaped , and = characters are not allowed in field selector values
0000000000000000000000000000000000000000;;				return "", UnescapedRune{r: c}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				v.WriteRune(c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ending with a single backslash is an invalid sequence
0000000000000000000000000000000000000000;;		if inSlash {
0000000000000000000000000000000000000000;;			return "", InvalidEscapeSequence{sequence: "\\"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseSelectorOrDie takes a string representing a selector and returns an
0000000000000000000000000000000000000000;;	// object suitable for matching, or panic when an error occur.
0000000000000000000000000000000000000000;;	func ParseSelectorOrDie(s string) Selector {
0000000000000000000000000000000000000000;;		selector, err := ParseSelector(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseSelector takes a string representing a selector and returns an
0000000000000000000000000000000000000000;;	// object suitable for matching, or an error.
0000000000000000000000000000000000000000;;	func ParseSelector(selector string) (Selector, error) {
0000000000000000000000000000000000000000;;		return parseSelector(selector,
0000000000000000000000000000000000000000;;			func(lhs, rhs string) (newLhs, newRhs string, err error) {
0000000000000000000000000000000000000000;;				return lhs, rhs, nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseAndTransformSelector parses the selector and runs them through the given TransformFunc.
0000000000000000000000000000000000000000;;	func ParseAndTransformSelector(selector string, fn TransformFunc) (Selector, error) {
0000000000000000000000000000000000000000;;		return parseSelector(selector, fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TransformFunc transforms selectors.
0000000000000000000000000000000000000000;;	type TransformFunc func(field, value string) (newField, newValue string, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitTerms returns the comma-separated terms contained in the given fieldSelector.
0000000000000000000000000000000000000000;;	// Backslash-escaped commas are treated as data instead of delimiters, and are included in the returned terms, with the leading backslash preserved.
0000000000000000000000000000000000000000;;	func splitTerms(fieldSelector string) []string {
0000000000000000000000000000000000000000;;		if len(fieldSelector) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		terms := make([]string, 0, 1)
0000000000000000000000000000000000000000;;		startIndex := 0
0000000000000000000000000000000000000000;;		inSlash := false
0000000000000000000000000000000000000000;;		for i, c := range fieldSelector {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case inSlash:
0000000000000000000000000000000000000000;;				inSlash = false
0000000000000000000000000000000000000000;;			case c == '\\':
0000000000000000000000000000000000000000;;				inSlash = true
0000000000000000000000000000000000000000;;			case c == ',':
0000000000000000000000000000000000000000;;				terms = append(terms, fieldSelector[startIndex:i])
0000000000000000000000000000000000000000;;				startIndex = i + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		terms = append(terms, fieldSelector[startIndex:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return terms
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		notEqualOperator    = "!="
0000000000000000000000000000000000000000;;		doubleEqualOperator = "=="
0000000000000000000000000000000000000000;;		equalOperator       = "="
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// termOperators holds the recognized operators supported in fieldSelectors.
0000000000000000000000000000000000000000;;	// doubleEqualOperator and equal are equivalent, but doubleEqualOperator is checked first
0000000000000000000000000000000000000000;;	// to avoid leaving a leading = character on the rhs value.
0000000000000000000000000000000000000000;;	var termOperators = []string{notEqualOperator, doubleEqualOperator, equalOperator}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitTerm returns the lhs, operator, and rhs parsed from the given term, along with an indicator of whether the parse was successful.
0000000000000000000000000000000000000000;;	// no escaping of special characters is supported in the lhs value, so the first occurance of a recognized operator is used as the split point.
0000000000000000000000000000000000000000;;	// the literal rhs is returned, and the caller is responsible for applying any desired unescaping.
0000000000000000000000000000000000000000;;	func splitTerm(term string) (lhs, op, rhs string, ok bool) {
0000000000000000000000000000000000000000;;		for i := range term {
0000000000000000000000000000000000000000;;			remaining := term[i:]
0000000000000000000000000000000000000000;;			for _, op := range termOperators {
0000000000000000000000000000000000000000;;				if strings.HasPrefix(remaining, op) {
0000000000000000000000000000000000000000;;					return term[0:i], op, term[i+len(op):], true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseSelector(selector string, fn TransformFunc) (Selector, error) {
0000000000000000000000000000000000000000;;		parts := splitTerms(selector)
0000000000000000000000000000000000000000;;		sort.StringSlice(parts).Sort()
0000000000000000000000000000000000000000;;		var items []Selector
0000000000000000000000000000000000000000;;		for _, part := range parts {
0000000000000000000000000000000000000000;;			if part == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lhs, op, rhs, ok := splitTerm(part)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid selector: '%s'; can't understand '%s'", selector, part)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unescapedRHS, err := UnescapeValue(rhs)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch op {
0000000000000000000000000000000000000000;;			case notEqualOperator:
0000000000000000000000000000000000000000;;				items = append(items, &notHasTerm{field: lhs, value: unescapedRHS})
0000000000000000000000000000000000000000;;			case doubleEqualOperator:
0000000000000000000000000000000000000000;;				items = append(items, &hasTerm{field: lhs, value: unescapedRHS})
0000000000000000000000000000000000000000;;			case equalOperator:
0000000000000000000000000000000000000000;;				items = append(items, &hasTerm{field: lhs, value: unescapedRHS})
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid selector: '%s'; can't understand '%s'", selector, part)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(items) == 1 {
0000000000000000000000000000000000000000;;			return items[0].Transform(fn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return andTerm(items).Transform(fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OneTermEqualSelector returns an object that matches objects where one field/field equals one value.
0000000000000000000000000000000000000000;;	// Cannot return an error.
0000000000000000000000000000000000000000;;	func OneTermEqualSelector(k, v string) Selector {
0000000000000000000000000000000000000000;;		return &hasTerm{field: k, value: v}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AndSelectors creates a selector that is the logical AND of all the given selectors
0000000000000000000000000000000000000000;;	func AndSelectors(selectors ...Selector) Selector {
0000000000000000000000000000000000000000;;		return andTerm(selectors)
0000000000000000000000000000000000000000;;	}
