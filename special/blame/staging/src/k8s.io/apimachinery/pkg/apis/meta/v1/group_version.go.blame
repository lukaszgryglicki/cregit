0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupResource specifies a Group and a Resource, but does not force a version.  This is useful for identifying
0000000000000000000000000000000000000000;;	// concepts during lookup stages without having partially valid types
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +protobuf.options.(gogoproto.goproto_stringer)=false
0000000000000000000000000000000000000000;;	type GroupResource struct {
0000000000000000000000000000000000000000;;		Group    string `json:"group" protobuf:"bytes,1,opt,name=group"`
0000000000000000000000000000000000000000;;		Resource string `json:"resource" protobuf:"bytes,2,opt,name=resource"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gr *GroupResource) String() string {
0000000000000000000000000000000000000000;;		if len(gr.Group) == 0 {
0000000000000000000000000000000000000000;;			return gr.Resource
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gr.Resource + "." + gr.Group
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersionResource unambiguously identifies a resource.  It doesn't anonymously include GroupVersion
0000000000000000000000000000000000000000;;	// to avoid automatic coersion.  It doesn't use a GroupVersion to avoid custom marshalling
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +protobuf.options.(gogoproto.goproto_stringer)=false
0000000000000000000000000000000000000000;;	type GroupVersionResource struct {
0000000000000000000000000000000000000000;;		Group    string `json:"group" protobuf:"bytes,1,opt,name=group"`
0000000000000000000000000000000000000000;;		Version  string `json:"version" protobuf:"bytes,2,opt,name=version"`
0000000000000000000000000000000000000000;;		Resource string `json:"resource" protobuf:"bytes,3,opt,name=resource"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gvr *GroupVersionResource) String() string {
0000000000000000000000000000000000000000;;		return strings.Join([]string{gvr.Group, "/", gvr.Version, ", Resource=", gvr.Resource}, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupKind specifies a Group and a Kind, but does not force a version.  This is useful for identifying
0000000000000000000000000000000000000000;;	// concepts during lookup stages without having partially valid types
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +protobuf.options.(gogoproto.goproto_stringer)=false
0000000000000000000000000000000000000000;;	type GroupKind struct {
0000000000000000000000000000000000000000;;		Group string `json:"group" protobuf:"bytes,1,opt,name=group"`
0000000000000000000000000000000000000000;;		Kind  string `json:"kind" protobuf:"bytes,2,opt,name=kind"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gk *GroupKind) String() string {
0000000000000000000000000000000000000000;;		if len(gk.Group) == 0 {
0000000000000000000000000000000000000000;;			return gk.Kind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gk.Kind + "." + gk.Group
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersionKind unambiguously identifies a kind.  It doesn't anonymously include GroupVersion
0000000000000000000000000000000000000000;;	// to avoid automatic coersion.  It doesn't use a GroupVersion to avoid custom marshalling
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +protobuf.options.(gogoproto.goproto_stringer)=false
0000000000000000000000000000000000000000;;	type GroupVersionKind struct {
0000000000000000000000000000000000000000;;		Group   string `json:"group" protobuf:"bytes,1,opt,name=group"`
0000000000000000000000000000000000000000;;		Version string `json:"version" protobuf:"bytes,2,opt,name=version"`
0000000000000000000000000000000000000000;;		Kind    string `json:"kind" protobuf:"bytes,3,opt,name=kind"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gvk GroupVersionKind) String() string {
0000000000000000000000000000000000000000;;		return gvk.Group + "/" + gvk.Version + ", Kind=" + gvk.Kind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersion contains the "group" and the "version", which uniquely identifies the API.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +protobuf.options.(gogoproto.goproto_stringer)=false
0000000000000000000000000000000000000000;;	type GroupVersion struct {
0000000000000000000000000000000000000000;;		Group   string `json:"group" protobuf:"bytes,1,opt,name=group"`
0000000000000000000000000000000000000000;;		Version string `json:"version" protobuf:"bytes,2,opt,name=version"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty returns true if group and version are empty
0000000000000000000000000000000000000000;;	func (gv GroupVersion) Empty() bool {
0000000000000000000000000000000000000000;;		return len(gv.Group) == 0 && len(gv.Version) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String puts "group" and "version" into a single "group/version" string. For the legacy v1
0000000000000000000000000000000000000000;;	// it returns "v1".
0000000000000000000000000000000000000000;;	func (gv GroupVersion) String() string {
0000000000000000000000000000000000000000;;		// special case the internal apiVersion for the legacy kube types
0000000000000000000000000000000000000000;;		if gv.Empty() {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// special case of "v1" for backward compatibility
0000000000000000000000000000000000000000;;		if len(gv.Group) == 0 && gv.Version == "v1" {
0000000000000000000000000000000000000000;;			return gv.Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(gv.Group) > 0 {
0000000000000000000000000000000000000000;;			return gv.Group + "/" + gv.Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gv.Version
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements the json.Marshaller interface.
0000000000000000000000000000000000000000;;	func (gv GroupVersion) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		s := gv.String()
0000000000000000000000000000000000000000;;		if strings.Count(s, "/") > 1 {
0000000000000000000000000000000000000000;;			return []byte{}, fmt.Errorf("illegal GroupVersion %v: contains more than one /", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (gv *GroupVersion) unmarshal(value []byte) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(value, &s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parsed, err := schema.ParseGroupVersion(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gv.Group, gv.Version = parsed.Group, parsed.Version
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements the json.Unmarshaller interface.
0000000000000000000000000000000000000000;;	func (gv *GroupVersion) UnmarshalJSON(value []byte) error {
0000000000000000000000000000000000000000;;		return gv.unmarshal(value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalTEXT implements the Ugorji's encoding.TextUnmarshaler interface.
0000000000000000000000000000000000000000;;	func (gv *GroupVersion) UnmarshalText(value []byte) error {
0000000000000000000000000000000000000000;;		return gv.unmarshal(value)
0000000000000000000000000000000000000000;;	}
