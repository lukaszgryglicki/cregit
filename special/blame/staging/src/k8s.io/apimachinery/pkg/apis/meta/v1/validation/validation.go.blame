0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
df2ee2fab8dfd7abb4d69a01789453822e33098f;pkg/api/unversioned/validation/validation.go[pkg/api/unversioned/validation/validation.go][staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/validation/validation.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateLabelSelector(ps *metav1.LabelSelector, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if ps == nil {
0000000000000000000000000000000000000000;;			return allErrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateLabels(ps.MatchLabels, fldPath.Child("matchLabels"))...)
0000000000000000000000000000000000000000;;		for i, expr := range ps.MatchExpressions {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateLabelSelectorRequirement(expr, fldPath.Child("matchExpressions").Index(i))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateLabelSelectorRequirement(sr metav1.LabelSelectorRequirement, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		switch sr.Operator {
0000000000000000000000000000000000000000;;		case metav1.LabelSelectorOpIn, metav1.LabelSelectorOpNotIn:
0000000000000000000000000000000000000000;;			if len(sr.Values) == 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Required(fldPath.Child("values"), "must be specified when `operator` is 'In' or 'NotIn'"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case metav1.LabelSelectorOpExists, metav1.LabelSelectorOpDoesNotExist:
0000000000000000000000000000000000000000;;			if len(sr.Values) > 0 {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Forbidden(fldPath.Child("values"), "may not be specified when `operator` is 'Exists' or 'DoesNotExist'"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath.Child("operator"), sr.Operator, "not a valid selector operator"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allErrs = append(allErrs, ValidateLabelName(sr.Key, fldPath.Child("key"))...)
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateLabelName validates that the label name is correctly defined.
0000000000000000000000000000000000000000;;	func ValidateLabelName(labelName string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for _, msg := range validation.IsQualifiedName(labelName) {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(fldPath, labelName, msg))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateLabels validates that a set of labels are correctly defined.
0000000000000000000000000000000000000000;;	func ValidateLabels(labels map[string]string, fldPath *field.Path) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		for k, v := range labels {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, ValidateLabelName(k, fldPath)...)
0000000000000000000000000000000000000000;;			for _, msg := range validation.IsValidLabelValue(v) {
0000000000000000000000000000000000000000;;				allErrs = append(allErrs, field.Invalid(fldPath, v, msg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ValidateDeleteOptions(options *metav1.DeleteOptions) field.ErrorList {
0000000000000000000000000000000000000000;;		allErrs := field.ErrorList{}
0000000000000000000000000000000000000000;;		if options.OrphanDependents != nil && options.PropagationPolicy != nil {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath(""), options, "OrphanDependents and DeletionPropagation cannot be both set"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.PropagationPolicy != nil &&
0000000000000000000000000000000000000000;;			*options.PropagationPolicy != metav1.DeletePropagationForeground &&
0000000000000000000000000000000000000000;;			*options.PropagationPolicy != metav1.DeletePropagationBackground &&
0000000000000000000000000000000000000000;;			*options.PropagationPolicy != metav1.DeletePropagationOrphan {
0000000000000000000000000000000000000000;;			allErrs = append(allErrs, field.Invalid(field.NewPath(""), options, fmt.Sprintf("DeletionPropagation need to be one of %q, %q, %q or nil", metav1.DeletePropagationForeground, metav1.DeletePropagationBackground, metav1.DeletePropagationOrphan)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return allErrs
0000000000000000000000000000000000000000;;	}
