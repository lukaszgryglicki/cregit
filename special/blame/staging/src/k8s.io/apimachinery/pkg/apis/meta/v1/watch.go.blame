0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Event represents a single event to a watched resource.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +protobuf=true
0000000000000000000000000000000000000000;;	type WatchEvent struct {
0000000000000000000000000000000000000000;;		Type string `json:"type" protobuf:"bytes,1,opt,name=type"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Object is:
0000000000000000000000000000000000000000;;		//  * If Type is Added or Modified: the new state of the object.
0000000000000000000000000000000000000000;;		//  * If Type is Deleted: the state of the object immediately before deletion.
0000000000000000000000000000000000000000;;		//  * If Type is Error: *Status is recommended; other types may make sense
0000000000000000000000000000000000000000;;		//    depending on context.
0000000000000000000000000000000000000000;;		Object runtime.RawExtension `json:"object" protobuf:"bytes,2,opt,name=object"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_watch_Event_to_versioned_Event(in *watch.Event, out *WatchEvent, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		out.Type = string(in.Type)
0000000000000000000000000000000000000000;;		switch t := in.Object.(type) {
0000000000000000000000000000000000000000;;		case *runtime.Unknown:
0000000000000000000000000000000000000000;;			// TODO: handle other fields on Unknown and detect type
0000000000000000000000000000000000000000;;			out.Object.Raw = t.Raw
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			out.Object.Object = in.Object
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_versioned_InternalEvent_to_versioned_Event(in *InternalEvent, out *WatchEvent, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		return Convert_watch_Event_to_versioned_Event((*watch.Event)(in), out, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_versioned_Event_to_watch_Event(in *WatchEvent, out *watch.Event, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		out.Type = watch.EventType(in.Type)
0000000000000000000000000000000000000000;;		if in.Object.Object != nil {
0000000000000000000000000000000000000000;;			out.Object = in.Object.Object
0000000000000000000000000000000000000000;;		} else if in.Object.Raw != nil {
0000000000000000000000000000000000000000;;			// TODO: handle other fields on Unknown and detect type
0000000000000000000000000000000000000000;;			out.Object = &runtime.Unknown{
0000000000000000000000000000000000000000;;				Raw:         in.Object.Raw,
0000000000000000000000000000000000000000;;				ContentType: runtime.ContentTypeJSON,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Convert_versioned_Event_to_versioned_InternalEvent(in *WatchEvent, out *InternalEvent, s conversion.Scope) error {
0000000000000000000000000000000000000000;;		return Convert_versioned_Event_to_watch_Event(in, (*watch.Event)(out), s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InternalEvent makes watch.Event versioned
0000000000000000000000000000000000000000;;	// +protobuf=false
0000000000000000000000000000000000000000;;	type InternalEvent watch.Event
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *InternalEvent) GetObjectKind() schema.ObjectKind { return schema.EmptyObjectKind }
0000000000000000000000000000000000000000;;	func (e *WatchEvent) GetObjectKind() schema.ObjectKind    { return schema.EmptyObjectKind }
