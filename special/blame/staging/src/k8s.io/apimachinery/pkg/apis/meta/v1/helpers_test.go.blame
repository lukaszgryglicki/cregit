0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelSelectorAsSelector(t *testing.T) {
0000000000000000000000000000000000000000;;		matchLabels := map[string]string{"foo": "bar"}
0000000000000000000000000000000000000000;;		matchExpressions := []LabelSelectorRequirement{{
0000000000000000000000000000000000000000;;			Key:      "baz",
0000000000000000000000000000000000000000;;			Operator: LabelSelectorOpIn,
0000000000000000000000000000000000000000;;			Values:   []string{"qux", "norf"},
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;		mustParse := func(s string) labels.Selector {
0000000000000000000000000000000000000000;;			out, e := labels.Parse(s)
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				panic(e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tc := []struct {
0000000000000000000000000000000000000000;;			in        *LabelSelector
0000000000000000000000000000000000000000;;			out       labels.Selector
0000000000000000000000000000000000000000;;			expectErr bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{in: nil, out: labels.Nothing()},
0000000000000000000000000000000000000000;;			{in: &LabelSelector{}, out: labels.Everything()},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &LabelSelector{MatchLabels: matchLabels},
0000000000000000000000000000000000000000;;				out: mustParse("foo=bar"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &LabelSelector{MatchExpressions: matchExpressions},
0000000000000000000000000000000000000000;;				out: mustParse("baz in (norf,qux)"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &LabelSelector{MatchLabels: matchLabels, MatchExpressions: matchExpressions},
0000000000000000000000000000000000000000;;				out: mustParse("baz in (norf,qux),foo=bar"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in: &LabelSelector{
0000000000000000000000000000000000000000;;					MatchExpressions: []LabelSelectorRequirement{{
0000000000000000000000000000000000000000;;						Key:      "baz",
0000000000000000000000000000000000000000;;						Operator: LabelSelectorOpExists,
0000000000000000000000000000000000000000;;						Values:   []string{"qux", "norf"},
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range tc {
0000000000000000000000000000000000000000;;			out, err := LabelSelectorAsSelector(tc.in)
0000000000000000000000000000000000000000;;			if err == nil && tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected error but got none.", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && !tc.expectErr {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]did not expect error but got: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(out, tc.out) {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected:\n\t%+v\nbut got:\n\t%+v", i, tc.out, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLabelSelectorAsMap(t *testing.T) {
0000000000000000000000000000000000000000;;		matchLabels := map[string]string{"foo": "bar"}
0000000000000000000000000000000000000000;;		matchExpressions := func(operator LabelSelectorOperator, values []string) []LabelSelectorRequirement {
0000000000000000000000000000000000000000;;			return []LabelSelectorRequirement{{
0000000000000000000000000000000000000000;;				Key:      "baz",
0000000000000000000000000000000000000000;;				Operator: operator,
0000000000000000000000000000000000000000;;				Values:   values,
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			in        *LabelSelector
0000000000000000000000000000000000000000;;			out       map[string]string
0000000000000000000000000000000000000000;;			errString string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{in: nil, out: nil},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &LabelSelector{MatchLabels: matchLabels},
0000000000000000000000000000000000000000;;				out: map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &LabelSelector{MatchLabels: matchLabels, MatchExpressions: matchExpressions(LabelSelectorOpIn, []string{"norf"})},
0000000000000000000000000000000000000000;;				out: map[string]string{"foo": "bar", "baz": "norf"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:  &LabelSelector{MatchExpressions: matchExpressions(LabelSelectorOpIn, []string{"norf"})},
0000000000000000000000000000000000000000;;				out: map[string]string{"baz": "norf"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:        &LabelSelector{MatchLabels: matchLabels, MatchExpressions: matchExpressions(LabelSelectorOpIn, []string{"norf", "qux"})},
0000000000000000000000000000000000000000;;				out:       map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				errString: "without a single value cannot be converted",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:        &LabelSelector{MatchExpressions: matchExpressions(LabelSelectorOpNotIn, []string{"norf", "qux"})},
0000000000000000000000000000000000000000;;				out:       map[string]string{},
0000000000000000000000000000000000000000;;				errString: "cannot be converted",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:        &LabelSelector{MatchLabels: matchLabels, MatchExpressions: matchExpressions(LabelSelectorOpExists, []string{})},
0000000000000000000000000000000000000000;;				out:       map[string]string{"foo": "bar"},
0000000000000000000000000000000000000000;;				errString: "cannot be converted",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				in:        &LabelSelector{MatchExpressions: matchExpressions(LabelSelectorOpDoesNotExist, []string{})},
0000000000000000000000000000000000000000;;				out:       map[string]string{},
0000000000000000000000000000000000000000;;				errString: "cannot be converted",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, tc := range tests {
0000000000000000000000000000000000000000;;			out, err := LabelSelectorAsMap(tc.in)
0000000000000000000000000000000000000000;;			if err == nil && len(tc.errString) > 0 {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected error but got none.", i)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && len(tc.errString) == 0 {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]did not expect error but got: %v", i, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil && len(tc.errString) > 0 && !strings.Contains(err.Error(), tc.errString) {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected error with %q but got: %v", i, tc.errString, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(out, tc.out) {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected:\n\t%+v\nbut got:\n\t%+v", i, tc.out, out)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
