0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
ba8aeff1a1372da5e0f8b543e133f79e92d45011;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/openapi"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const RFC3339Micro = "2006-01-02T15:04:05.000000Z07:00"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MicroTime is version of Time with microsecond level precision.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +protobuf.options.marshal=false
0000000000000000000000000000000000000000;;	// +protobuf.as=Timestamp
0000000000000000000000000000000000000000;;	// +protobuf.options.(gogoproto.goproto_stringer)=false
0000000000000000000000000000000000000000;;	type MicroTime struct {
0000000000000000000000000000000000000000;;		time.Time `protobuf:"-"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeepCopy returns a deep-copy of the MicroTime value.  The underlying time.Time
0000000000000000000000000000000000000000;;	// type is effectively immutable in the time API, so it is safe to
0000000000000000000000000000000000000000;;	// copy-by-assign, despite the presence of (unexported) Pointer fields.
0000000000000000000000000000000000000000;;	func (t MicroTime) DeepCopy() MicroTime {
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the representation of the time.
0000000000000000000000000000000000000000;;	func (t MicroTime) String() string {
0000000000000000000000000000000000000000;;		return t.Time.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMicroTime returns a wrapped instance of the provided time
0000000000000000000000000000000000000000;;	func NewMicroTime(time time.Time) MicroTime {
0000000000000000000000000000000000000000;;		return MicroTime{time}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DateMicro returns the MicroTime corresponding to the supplied parameters
0000000000000000000000000000000000000000;;	// by wrapping time.Date.
0000000000000000000000000000000000000000;;	func DateMicro(year int, month time.Month, day, hour, min, sec, nsec int, loc *time.Location) MicroTime {
0000000000000000000000000000000000000000;;		return MicroTime{time.Date(year, month, day, hour, min, sec, nsec, loc)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NowMicro returns the current local time.
0000000000000000000000000000000000000000;;	func NowMicro() MicroTime {
0000000000000000000000000000000000000000;;		return MicroTime{time.Now()}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsZero returns true if the value is nil or time is zero.
0000000000000000000000000000000000000000;;	func (t *MicroTime) IsZero() bool {
0000000000000000000000000000000000000000;;		if t == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.Time.IsZero()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Before reports whether the time instant t is before u.
0000000000000000000000000000000000000000;;	func (t MicroTime) Before(u MicroTime) bool {
0000000000000000000000000000000000000000;;		return t.Time.Before(u.Time)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal reports whether the time instant t is equal to u.
0000000000000000000000000000000000000000;;	func (t MicroTime) Equal(u MicroTime) bool {
0000000000000000000000000000000000000000;;		return t.Time.Equal(u.Time)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BeforeTime reports whether the time instant t is before second-lever precision u.
0000000000000000000000000000000000000000;;	func (t MicroTime) BeforeTime(u Time) bool {
0000000000000000000000000000000000000000;;		return t.Time.Before(u.Time)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EqualTime reports whether the time instant t is equal to second-lever precision u.
0000000000000000000000000000000000000000;;	func (t MicroTime) EqualTime(u Time) bool {
0000000000000000000000000000000000000000;;		return t.Time.Equal(u.Time)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnixMicro returns the local time corresponding to the given Unix time
0000000000000000000000000000000000000000;;	// by wrapping time.Unix.
0000000000000000000000000000000000000000;;	func UnixMicro(sec int64, nsec int64) MicroTime {
0000000000000000000000000000000000000000;;		return MicroTime{time.Unix(sec, nsec)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements the json.Unmarshaller interface.
0000000000000000000000000000000000000000;;	func (t *MicroTime) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		if len(b) == 4 && string(b) == "null" {
0000000000000000000000000000000000000000;;			t.Time = time.Time{}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var str string
0000000000000000000000000000000000000000;;		json.Unmarshal(b, &str)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pt, err := time.Parse(RFC3339Micro, str)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Time = pt.Local()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalQueryParameter converts from a URL query parameter value to an object
0000000000000000000000000000000000000000;;	func (t *MicroTime) UnmarshalQueryParameter(str string) error {
0000000000000000000000000000000000000000;;		if len(str) == 0 {
0000000000000000000000000000000000000000;;			t.Time = time.Time{}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Tolerate requests from older clients that used JSON serialization to build query params
0000000000000000000000000000000000000000;;		if len(str) == 4 && str == "null" {
0000000000000000000000000000000000000000;;			t.Time = time.Time{}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pt, err := time.Parse(RFC3339Micro, str)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Time = pt.Local()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements the json.Marshaler interface.
0000000000000000000000000000000000000000;;	func (t MicroTime) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if t.IsZero() {
0000000000000000000000000000000000000000;;			// Encode unset/nil objects as JSON's "null".
0000000000000000000000000000000000000000;;			return []byte("null"), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(t.UTC().Format(RFC3339Micro))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ MicroTime) OpenAPIDefinition() openapi.OpenAPIDefinition {
0000000000000000000000000000000000000000;;		return openapi.OpenAPIDefinition{
0000000000000000000000000000000000000000;;			Schema: spec.Schema{
0000000000000000000000000000000000000000;;				SchemaProps: spec.SchemaProps{
0000000000000000000000000000000000000000;;					Type:   []string{"string"},
0000000000000000000000000000000000000000;;					Format: "date-time",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalQueryParameter converts to a URL query parameter value
0000000000000000000000000000000000000000;;	func (t MicroTime) MarshalQueryParameter() (string, error) {
0000000000000000000000000000000000000000;;		if t.IsZero() {
0000000000000000000000000000000000000000;;			// Encode unset/nil objects as an empty string
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t.UTC().Format(RFC3339Micro), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fuzz satisfies fuzz.Interface.
0000000000000000000000000000000000000000;;	func (t *MicroTime) Fuzz(c fuzz.Continue) {
0000000000000000000000000000000000000000;;		if t == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Allow for about 1000 years of randomness.  Leave off nanoseconds
0000000000000000000000000000000000000000;;		// because JSON doesn't represent them so they can't round-trip
0000000000000000000000000000000000000000;;		// properly.
0000000000000000000000000000000000000000;;		t.Time = time.Unix(c.Rand.Int63n(1000*365*24*60*60*1000*1000), 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ fuzz.Interface = &MicroTime{}
