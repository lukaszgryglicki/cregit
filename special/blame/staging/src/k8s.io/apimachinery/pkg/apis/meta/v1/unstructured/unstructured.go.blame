0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package unstructured
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		gojson "encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/json"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unstructured allows objects that do not have Golang structs registered to be manipulated
0000000000000000000000000000000000000000;;	// generically. This can be used to deal with the API objects from a plug-in. Unstructured
0000000000000000000000000000000000000000;;	// objects still have functioning TypeMeta features-- kind, version, etc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// WARNING: This object has accessors for the v1 standard metadata. You *MUST NOT* use this
0000000000000000000000000000000000000000;;	// type if you are dealing with objects that are not in the server meta v1 schema.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: make the serialization part of this type distinct from the field accessors.
0000000000000000000000000000000000000000;;	type Unstructured struct {
0000000000000000000000000000000000000000;;		// Object is a JSON compatible map with string, float, int, bool, []interface{}, or
0000000000000000000000000000000000000000;;		// map[string]interface{}
0000000000000000000000000000000000000000;;		// children.
0000000000000000000000000000000000000000;;		Object map[string]interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ metav1.Object = &Unstructured{}
0000000000000000000000000000000000000000;;	var _ runtime.Unstructured = &Unstructured{}
0000000000000000000000000000000000000000;;	var _ runtime.Unstructured = &UnstructuredList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *Unstructured) GetObjectKind() schema.ObjectKind     { return obj }
0000000000000000000000000000000000000000;;	func (obj *UnstructuredList) GetObjectKind() schema.ObjectKind { return obj }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *Unstructured) IsUnstructuredObject()     {}
0000000000000000000000000000000000000000;;	func (obj *UnstructuredList) IsUnstructuredObject() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *Unstructured) IsList() bool {
0000000000000000000000000000000000000000;;		if obj.Object != nil {
0000000000000000000000000000000000000000;;			_, ok := obj.Object["items"]
0000000000000000000000000000000000000000;;			return ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (obj *UnstructuredList) IsList() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *Unstructured) EachListItem(fn func(runtime.Object) error) error {
0000000000000000000000000000000000000000;;		if obj.Object == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("content is not a list")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		field, ok := obj.Object["items"]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("content is not a list")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items, ok := field.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			child, ok := item.(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("items member is not an object")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := fn(&Unstructured{Object: child}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *UnstructuredList) EachListItem(fn func(runtime.Object) error) error {
0000000000000000000000000000000000000000;;		for i := range obj.Items {
0000000000000000000000000000000000000000;;			if err := fn(&obj.Items[i]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (obj *Unstructured) UnstructuredContent() map[string]interface{} {
0000000000000000000000000000000000000000;;		if obj.Object == nil {
0000000000000000000000000000000000000000;;			obj.Object = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj.Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnstructuredContent returns a map contain an overlay of the Items field onto
0000000000000000000000000000000000000000;;	// the Object field. Items always overwrites overlay. Changing "items" in the
0000000000000000000000000000000000000000;;	// returned object will affect items in the underlying Items field, but changing
0000000000000000000000000000000000000000;;	// the "items" slice itself will have no effect.
0000000000000000000000000000000000000000;;	// TODO: expose SetUnstructuredContent on runtime.Unstructured that allows
0000000000000000000000000000000000000000;;	// items to be changed.
0000000000000000000000000000000000000000;;	func (obj *UnstructuredList) UnstructuredContent() map[string]interface{} {
0000000000000000000000000000000000000000;;		out := obj.Object
0000000000000000000000000000000000000000;;		if out == nil {
0000000000000000000000000000000000000000;;			out = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		items := make([]interface{}, len(obj.Items))
0000000000000000000000000000000000000000;;		for i, item := range obj.Items {
0000000000000000000000000000000000000000;;			items[i] = item.Object
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out["items"] = items
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON ensures that the unstructured object produces proper
0000000000000000000000000000000000000000;;	// JSON when passed to Go's standard JSON library.
0000000000000000000000000000000000000000;;	func (u *Unstructured) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		err := UnstructuredJSONScheme.Encode(u, &buf)
0000000000000000000000000000000000000000;;		return buf.Bytes(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON ensures that the unstructured object properly decodes
0000000000000000000000000000000000000000;;	// JSON when passed to Go's standard JSON library.
0000000000000000000000000000000000000000;;	func (u *Unstructured) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		_, _, err := UnstructuredJSONScheme.Decode(b, nil, u)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNestedField(obj map[string]interface{}, fields ...string) interface{} {
0000000000000000000000000000000000000000;;		var val interface{} = obj
0000000000000000000000000000000000000000;;		for _, field := range fields {
0000000000000000000000000000000000000000;;			if _, ok := val.(map[string]interface{}); !ok {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val = val.(map[string]interface{})[field]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNestedString(obj map[string]interface{}, fields ...string) string {
0000000000000000000000000000000000000000;;		if str, ok := getNestedField(obj, fields...).(string); ok {
0000000000000000000000000000000000000000;;			return str
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNestedInt64(obj map[string]interface{}, fields ...string) int64 {
0000000000000000000000000000000000000000;;		if str, ok := getNestedField(obj, fields...).(int64); ok {
0000000000000000000000000000000000000000;;			return str
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNestedInt64Pointer(obj map[string]interface{}, fields ...string) *int64 {
0000000000000000000000000000000000000000;;		nested := getNestedField(obj, fields...)
0000000000000000000000000000000000000000;;		switch n := nested.(type) {
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			return &n
0000000000000000000000000000000000000000;;		case *int64:
0000000000000000000000000000000000000000;;			return n
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNestedSlice(obj map[string]interface{}, fields ...string) []string {
0000000000000000000000000000000000000000;;		if m, ok := getNestedField(obj, fields...).([]interface{}); ok {
0000000000000000000000000000000000000000;;			strSlice := make([]string, 0, len(m))
0000000000000000000000000000000000000000;;			for _, v := range m {
0000000000000000000000000000000000000000;;				if str, ok := v.(string); ok {
0000000000000000000000000000000000000000;;					strSlice = append(strSlice, str)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return strSlice
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNestedMap(obj map[string]interface{}, fields ...string) map[string]string {
0000000000000000000000000000000000000000;;		if m, ok := getNestedField(obj, fields...).(map[string]interface{}); ok {
0000000000000000000000000000000000000000;;			strMap := make(map[string]string, len(m))
0000000000000000000000000000000000000000;;			for k, v := range m {
0000000000000000000000000000000000000000;;				if str, ok := v.(string); ok {
0000000000000000000000000000000000000000;;					strMap[k] = str
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return strMap
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNestedField(obj map[string]interface{}, value interface{}, fields ...string) {
0000000000000000000000000000000000000000;;		m := obj
0000000000000000000000000000000000000000;;		if len(fields) > 1 {
0000000000000000000000000000000000000000;;			for _, field := range fields[0 : len(fields)-1] {
0000000000000000000000000000000000000000;;				if _, ok := m[field].(map[string]interface{}); !ok {
0000000000000000000000000000000000000000;;					m[field] = make(map[string]interface{})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m = m[field].(map[string]interface{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m[fields[len(fields)-1]] = value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNestedSlice(obj map[string]interface{}, value []string, fields ...string) {
0000000000000000000000000000000000000000;;		m := make([]interface{}, 0, len(value))
0000000000000000000000000000000000000000;;		for _, v := range value {
0000000000000000000000000000000000000000;;			m = append(m, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setNestedField(obj, m, fields...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNestedMap(obj map[string]interface{}, value map[string]string, fields ...string) {
0000000000000000000000000000000000000000;;		m := make(map[string]interface{}, len(value))
0000000000000000000000000000000000000000;;		for k, v := range value {
0000000000000000000000000000000000000000;;			m[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setNestedField(obj, m, fields...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) setNestedField(value interface{}, fields ...string) {
0000000000000000000000000000000000000000;;		if u.Object == nil {
0000000000000000000000000000000000000000;;			u.Object = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setNestedField(u.Object, value, fields...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) setNestedSlice(value []string, fields ...string) {
0000000000000000000000000000000000000000;;		if u.Object == nil {
0000000000000000000000000000000000000000;;			u.Object = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setNestedSlice(u.Object, value, fields...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) setNestedMap(value map[string]string, fields ...string) {
0000000000000000000000000000000000000000;;		if u.Object == nil {
0000000000000000000000000000000000000000;;			u.Object = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setNestedMap(u.Object, value, fields...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractOwnerReference(src interface{}) metav1.OwnerReference {
0000000000000000000000000000000000000000;;		v := src.(map[string]interface{})
0000000000000000000000000000000000000000;;		// though this field is a *bool, but when decoded from JSON, it's
0000000000000000000000000000000000000000;;		// unmarshalled as bool.
0000000000000000000000000000000000000000;;		var controllerPtr *bool
0000000000000000000000000000000000000000;;		controller, ok := (getNestedField(v, "controller")).(bool)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			controllerPtr = nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			controllerCopy := controller
0000000000000000000000000000000000000000;;			controllerPtr = &controllerCopy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var blockOwnerDeletionPtr *bool
0000000000000000000000000000000000000000;;		blockOwnerDeletion, ok := (getNestedField(v, "blockOwnerDeletion")).(bool)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			blockOwnerDeletionPtr = nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			blockOwnerDeletionCopy := blockOwnerDeletion
0000000000000000000000000000000000000000;;			blockOwnerDeletionPtr = &blockOwnerDeletionCopy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metav1.OwnerReference{
0000000000000000000000000000000000000000;;			Kind:               getNestedString(v, "kind"),
0000000000000000000000000000000000000000;;			Name:               getNestedString(v, "name"),
0000000000000000000000000000000000000000;;			APIVersion:         getNestedString(v, "apiVersion"),
0000000000000000000000000000000000000000;;			UID:                (types.UID)(getNestedString(v, "uid")),
0000000000000000000000000000000000000000;;			Controller:         controllerPtr,
0000000000000000000000000000000000000000;;			BlockOwnerDeletion: blockOwnerDeletionPtr,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setOwnerReference(src metav1.OwnerReference) map[string]interface{} {
0000000000000000000000000000000000000000;;		ret := make(map[string]interface{})
0000000000000000000000000000000000000000;;		setNestedField(ret, src.Kind, "kind")
0000000000000000000000000000000000000000;;		setNestedField(ret, src.Name, "name")
0000000000000000000000000000000000000000;;		setNestedField(ret, src.APIVersion, "apiVersion")
0000000000000000000000000000000000000000;;		setNestedField(ret, string(src.UID), "uid")
0000000000000000000000000000000000000000;;		// json.Unmarshal() extracts boolean json fields as bool, not as *bool and hence extractOwnerReference()
0000000000000000000000000000000000000000;;		// expects bool or a missing field, not *bool. So if pointer is nil, fields are omitted from the ret object.
0000000000000000000000000000000000000000;;		// If pointer is non-nil, they are set to the referenced value.
0000000000000000000000000000000000000000;;		if src.Controller != nil {
0000000000000000000000000000000000000000;;			setNestedField(ret, *src.Controller, "controller")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if src.BlockOwnerDeletion != nil {
0000000000000000000000000000000000000000;;			setNestedField(ret, *src.BlockOwnerDeletion, "blockOwnerDeletion")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getOwnerReferences(object map[string]interface{}) ([]map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		field := getNestedField(object, "metadata", "ownerReferences")
0000000000000000000000000000000000000000;;		if field == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot find field metadata.ownerReferences in %v", object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ownerReferences, ok := field.([]map[string]interface{})
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return ownerReferences, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: This is hacky...
0000000000000000000000000000000000000000;;		interfaces, ok := field.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("expect metadata.ownerReferences to be a slice in %#v", object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ownerReferences = make([]map[string]interface{}, 0, len(interfaces))
0000000000000000000000000000000000000000;;		for i := 0; i < len(interfaces); i++ {
0000000000000000000000000000000000000000;;			r, ok := interfaces[i].(map[string]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("expect element metadata.ownerReferences to be a map[string]interface{} in %#v", object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ownerReferences = append(ownerReferences, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ownerReferences, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetOwnerReferences() []metav1.OwnerReference {
0000000000000000000000000000000000000000;;		original, err := getOwnerReferences(u.Object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(6).Info(err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := make([]metav1.OwnerReference, 0, len(original))
0000000000000000000000000000000000000000;;		for i := 0; i < len(original); i++ {
0000000000000000000000000000000000000000;;			ret = append(ret, extractOwnerReference(original[i]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetOwnerReferences(references []metav1.OwnerReference) {
0000000000000000000000000000000000000000;;		var newReferences = make([]map[string]interface{}, 0, len(references))
0000000000000000000000000000000000000000;;		for i := 0; i < len(references); i++ {
0000000000000000000000000000000000000000;;			newReferences = append(newReferences, setOwnerReference(references[i]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.setNestedField(newReferences, "metadata", "ownerReferences")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetAPIVersion() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "apiVersion")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetAPIVersion(version string) {
0000000000000000000000000000000000000000;;		u.setNestedField(version, "apiVersion")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetKind() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "kind")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetKind(kind string) {
0000000000000000000000000000000000000000;;		u.setNestedField(kind, "kind")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetNamespace() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "metadata", "namespace")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetNamespace(namespace string) {
0000000000000000000000000000000000000000;;		u.setNestedField(namespace, "metadata", "namespace")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetName() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "metadata", "name")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetName(name string) {
0000000000000000000000000000000000000000;;		u.setNestedField(name, "metadata", "name")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetGenerateName() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "metadata", "generateName")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetGenerateName(name string) {
0000000000000000000000000000000000000000;;		u.setNestedField(name, "metadata", "generateName")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetUID() types.UID {
0000000000000000000000000000000000000000;;		return types.UID(getNestedString(u.Object, "metadata", "uid"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetUID(uid types.UID) {
0000000000000000000000000000000000000000;;		u.setNestedField(string(uid), "metadata", "uid")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetResourceVersion() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "metadata", "resourceVersion")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetResourceVersion(version string) {
0000000000000000000000000000000000000000;;		u.setNestedField(version, "metadata", "resourceVersion")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetGeneration() int64 {
0000000000000000000000000000000000000000;;		return getNestedInt64(u.Object, "metadata", "generation")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetGeneration(generation int64) {
0000000000000000000000000000000000000000;;		u.setNestedField(generation, "metadata", "generation")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetSelfLink() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "metadata", "selfLink")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetSelfLink(selfLink string) {
0000000000000000000000000000000000000000;;		u.setNestedField(selfLink, "metadata", "selfLink")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetCreationTimestamp() metav1.Time {
0000000000000000000000000000000000000000;;		var timestamp metav1.Time
0000000000000000000000000000000000000000;;		timestamp.UnmarshalQueryParameter(getNestedString(u.Object, "metadata", "creationTimestamp"))
0000000000000000000000000000000000000000;;		return timestamp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetCreationTimestamp(timestamp metav1.Time) {
0000000000000000000000000000000000000000;;		ts, _ := timestamp.MarshalQueryParameter()
0000000000000000000000000000000000000000;;		u.setNestedField(ts, "metadata", "creationTimestamp")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetDeletionTimestamp() *metav1.Time {
0000000000000000000000000000000000000000;;		var timestamp metav1.Time
0000000000000000000000000000000000000000;;		timestamp.UnmarshalQueryParameter(getNestedString(u.Object, "metadata", "deletionTimestamp"))
0000000000000000000000000000000000000000;;		if timestamp.IsZero() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &timestamp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetDeletionTimestamp(timestamp *metav1.Time) {
0000000000000000000000000000000000000000;;		if timestamp == nil {
0000000000000000000000000000000000000000;;			u.setNestedField(nil, "metadata", "deletionTimestamp")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ts, _ := timestamp.MarshalQueryParameter()
0000000000000000000000000000000000000000;;		u.setNestedField(ts, "metadata", "deletionTimestamp")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetDeletionGracePeriodSeconds() *int64 {
0000000000000000000000000000000000000000;;		return getNestedInt64Pointer(u.Object, "metadata", "deletionGracePeriodSeconds")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetDeletionGracePeriodSeconds(deletionGracePeriodSeconds *int64) {
0000000000000000000000000000000000000000;;		u.setNestedField(deletionGracePeriodSeconds, "metadata", "deletionGracePeriodSeconds")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetLabels() map[string]string {
0000000000000000000000000000000000000000;;		return getNestedMap(u.Object, "metadata", "labels")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetLabels(labels map[string]string) {
0000000000000000000000000000000000000000;;		u.setNestedMap(labels, "metadata", "labels")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetAnnotations() map[string]string {
0000000000000000000000000000000000000000;;		return getNestedMap(u.Object, "metadata", "annotations")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetAnnotations(annotations map[string]string) {
0000000000000000000000000000000000000000;;		u.setNestedMap(annotations, "metadata", "annotations")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetGroupVersionKind(gvk schema.GroupVersionKind) {
0000000000000000000000000000000000000000;;		u.SetAPIVersion(gvk.GroupVersion().String())
0000000000000000000000000000000000000000;;		u.SetKind(gvk.Kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GroupVersionKind() schema.GroupVersionKind {
0000000000000000000000000000000000000000;;		gv, err := schema.ParseGroupVersion(u.GetAPIVersion())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvk := gv.WithKind(u.GetKind())
0000000000000000000000000000000000000000;;		return gvk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var converter = unstructured.NewConverter(false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetInitializers() *metav1.Initializers {
0000000000000000000000000000000000000000;;		field := getNestedField(u.Object, "metadata", "initializers")
0000000000000000000000000000000000000000;;		if field == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, ok := field.(map[string]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := &metav1.Initializers{}
0000000000000000000000000000000000000000;;		if err := converter.FromUnstructured(obj, out); err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unable to retrieve initializers for object: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetInitializers(initializers *metav1.Initializers) {
0000000000000000000000000000000000000000;;		if u.Object == nil {
0000000000000000000000000000000000000000;;			u.Object = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if initializers == nil {
0000000000000000000000000000000000000000;;			setNestedField(u.Object, nil, "metadata", "initializers")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out, err := converter.ToUnstructured(initializers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(fmt.Errorf("unable to retrieve initializers for object: %v", err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setNestedField(u.Object, out, "metadata", "initializers")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetFinalizers() []string {
0000000000000000000000000000000000000000;;		return getNestedSlice(u.Object, "metadata", "finalizers")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetFinalizers(finalizers []string) {
0000000000000000000000000000000000000000;;		u.setNestedSlice(finalizers, "metadata", "finalizers")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) GetClusterName() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "metadata", "clusterName")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Unstructured) SetClusterName(clusterName string) {
0000000000000000000000000000000000000000;;		u.setNestedField(clusterName, "metadata", "clusterName")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnstructuredList allows lists that do not have Golang structs
0000000000000000000000000000000000000000;;	// registered to be manipulated generically. This can be used to deal
0000000000000000000000000000000000000000;;	// with the API lists from a plug-in.
0000000000000000000000000000000000000000;;	type UnstructuredList struct {
0000000000000000000000000000000000000000;;		Object map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is a list of unstructured objects.
0000000000000000000000000000000000000000;;		Items []Unstructured `json:"items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON ensures that the unstructured list object produces proper
0000000000000000000000000000000000000000;;	// JSON when passed to Go's standard JSON library.
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		err := UnstructuredJSONScheme.Encode(u, &buf)
0000000000000000000000000000000000000000;;		return buf.Bytes(), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON ensures that the unstructured list object properly
0000000000000000000000000000000000000000;;	// decodes JSON when passed to Go's standard JSON library.
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		_, _, err := UnstructuredJSONScheme.Decode(b, nil, u)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) setNestedField(value interface{}, fields ...string) {
0000000000000000000000000000000000000000;;		if u.Object == nil {
0000000000000000000000000000000000000000;;			u.Object = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setNestedField(u.Object, value, fields...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) GetAPIVersion() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "apiVersion")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) SetAPIVersion(version string) {
0000000000000000000000000000000000000000;;		u.setNestedField(version, "apiVersion")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) GetKind() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "kind")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) SetKind(kind string) {
0000000000000000000000000000000000000000;;		u.setNestedField(kind, "kind")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) GetResourceVersion() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "metadata", "resourceVersion")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) SetResourceVersion(version string) {
0000000000000000000000000000000000000000;;		u.setNestedField(version, "metadata", "resourceVersion")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) GetSelfLink() string {
0000000000000000000000000000000000000000;;		return getNestedString(u.Object, "metadata", "selfLink")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) SetSelfLink(selfLink string) {
0000000000000000000000000000000000000000;;		u.setNestedField(selfLink, "metadata", "selfLink")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) SetGroupVersionKind(gvk schema.GroupVersionKind) {
0000000000000000000000000000000000000000;;		u.SetAPIVersion(gvk.GroupVersion().String())
0000000000000000000000000000000000000000;;		u.SetKind(gvk.Kind)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UnstructuredList) GroupVersionKind() schema.GroupVersionKind {
0000000000000000000000000000000000000000;;		gv, err := schema.ParseGroupVersion(u.GetAPIVersion())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return schema.GroupVersionKind{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gvk := gv.WithKind(u.GetKind())
0000000000000000000000000000000000000000;;		return gvk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnstructuredJSONScheme is capable of converting JSON data into the Unstructured
0000000000000000000000000000000000000000;;	// type, which can be used for generic access to objects without a predefined scheme.
0000000000000000000000000000000000000000;;	// TODO: move into serializer/json.
0000000000000000000000000000000000000000;;	var UnstructuredJSONScheme runtime.Codec = unstructuredJSONScheme{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unstructuredJSONScheme struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s unstructuredJSONScheme) Decode(data []byte, _ *schema.GroupVersionKind, obj runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if obj != nil {
0000000000000000000000000000000000000000;;			err = s.decodeInto(data, obj)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			obj, err = s.decode(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gvk := obj.GetObjectKind().GroupVersionKind()
0000000000000000000000000000000000000000;;		if len(gvk.Kind) == 0 {
0000000000000000000000000000000000000000;;			return nil, &gvk, runtime.NewMissingKindErr(string(data))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return obj, &gvk, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (unstructuredJSONScheme) Encode(obj runtime.Object, w io.Writer) error {
0000000000000000000000000000000000000000;;		switch t := obj.(type) {
0000000000000000000000000000000000000000;;		case *Unstructured:
0000000000000000000000000000000000000000;;			return json.NewEncoder(w).Encode(t.Object)
0000000000000000000000000000000000000000;;		case *UnstructuredList:
0000000000000000000000000000000000000000;;			items := make([]map[string]interface{}, 0, len(t.Items))
0000000000000000000000000000000000000000;;			for _, i := range t.Items {
0000000000000000000000000000000000000000;;				items = append(items, i.Object)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t.Object["items"] = items
0000000000000000000000000000000000000000;;			defer func() { delete(t.Object, "items") }()
0000000000000000000000000000000000000000;;			return json.NewEncoder(w).Encode(t.Object)
0000000000000000000000000000000000000000;;		case *runtime.Unknown:
0000000000000000000000000000000000000000;;			// TODO: Unstructured needs to deal with ContentType.
0000000000000000000000000000000000000000;;			_, err := w.Write(t.Raw)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return json.NewEncoder(w).Encode(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s unstructuredJSONScheme) decode(data []byte) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		type detector struct {
0000000000000000000000000000000000000000;;			Items gojson.RawMessage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var det detector
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &det); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if det.Items != nil {
0000000000000000000000000000000000000000;;			list := &UnstructuredList{}
0000000000000000000000000000000000000000;;			err := s.decodeToList(data, list)
0000000000000000000000000000000000000000;;			return list, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No Items field, so it wasn't a list.
0000000000000000000000000000000000000000;;		unstruct := &Unstructured{}
0000000000000000000000000000000000000000;;		err := s.decodeToUnstructured(data, unstruct)
0000000000000000000000000000000000000000;;		return unstruct, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s unstructuredJSONScheme) decodeInto(data []byte, obj runtime.Object) error {
0000000000000000000000000000000000000000;;		switch x := obj.(type) {
0000000000000000000000000000000000000000;;		case *Unstructured:
0000000000000000000000000000000000000000;;			return s.decodeToUnstructured(data, x)
0000000000000000000000000000000000000000;;		case *UnstructuredList:
0000000000000000000000000000000000000000;;			return s.decodeToList(data, x)
0000000000000000000000000000000000000000;;		case *runtime.VersionedObjects:
0000000000000000000000000000000000000000;;			o, err := s.decode(data)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				x.Objects = []runtime.Object{o}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return json.Unmarshal(data, x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (unstructuredJSONScheme) decodeToUnstructured(data []byte, unstruct *Unstructured) error {
0000000000000000000000000000000000000000;;		m := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &m); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unstruct.Object = m
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s unstructuredJSONScheme) decodeToList(data []byte, list *UnstructuredList) error {
0000000000000000000000000000000000000000;;		type decodeList struct {
0000000000000000000000000000000000000000;;			Items []gojson.RawMessage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dList decodeList
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &dList); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &list.Object); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For typed lists, e.g., a PodList, API server doesn't set each item's
0000000000000000000000000000000000000000;;		// APIVersion and Kind. We need to set it.
0000000000000000000000000000000000000000;;		listAPIVersion := list.GetAPIVersion()
0000000000000000000000000000000000000000;;		listKind := list.GetKind()
0000000000000000000000000000000000000000;;		itemKind := strings.TrimSuffix(listKind, "List")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(list.Object, "items")
0000000000000000000000000000000000000000;;		list.Items = nil
0000000000000000000000000000000000000000;;		for _, i := range dList.Items {
0000000000000000000000000000000000000000;;			unstruct := &Unstructured{}
0000000000000000000000000000000000000000;;			if err := s.decodeToUnstructured([]byte(i), unstruct); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// This is hacky. Set the item's Kind and APIVersion to those inferred
0000000000000000000000000000000000000000;;			// from the List.
0000000000000000000000000000000000000000;;			if len(unstruct.GetKind()) == 0 && len(unstruct.GetAPIVersion()) == 0 {
0000000000000000000000000000000000000000;;				unstruct.SetKind(itemKind)
0000000000000000000000000000000000000000;;				unstruct.SetAPIVersion(listAPIVersion)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			list.Items = append(list.Items, *unstruct)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnstructuredObjectConverter is an ObjectConverter for use with
0000000000000000000000000000000000000000;;	// Unstructured objects. Since it has no schema or type information,
0000000000000000000000000000000000000000;;	// it will only succeed for no-op conversions. This is provided as a
0000000000000000000000000000000000000000;;	// sane implementation for APIs that require an object converter.
0000000000000000000000000000000000000000;;	type UnstructuredObjectConverter struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (UnstructuredObjectConverter) Convert(in, out, context interface{}) error {
0000000000000000000000000000000000000000;;		unstructIn, ok := in.(*Unstructured)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("input type %T in not valid for unstructured conversion", in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unstructOut, ok := out.(*Unstructured)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("output type %T in not valid for unstructured conversion", out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// maybe deep copy the map? It is documented in the
0000000000000000000000000000000000000000;;		// ObjectConverter interface that this function is not
0000000000000000000000000000000000000000;;		// guaranteeed to not mutate the input. Or maybe set the input
0000000000000000000000000000000000000000;;		// object to nil.
0000000000000000000000000000000000000000;;		unstructOut.Object = unstructIn.Object
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (UnstructuredObjectConverter) ConvertToVersion(in runtime.Object, target runtime.GroupVersioner) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		if kind := in.GetObjectKind().GroupVersionKind(); !kind.Empty() {
0000000000000000000000000000000000000000;;			gvk, ok := target.KindForGroupVersionKinds([]schema.GroupVersionKind{kind})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// TODO: should this be a typed error?
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("%v is unstructured and is not suitable for converting to %q", kind, target)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			in.GetObjectKind().SetGroupVersionKind(gvk)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return in, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (UnstructuredObjectConverter) ConvertFieldLabel(version, kind, label, value string) (string, string, error) {
0000000000000000000000000000000000000000;;		return "", "", errors.New("unstructured cannot convert field labels")
0000000000000000000000000000000000000000;;	}
