0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package unversioned contains API types that are common to all versions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The package contains two categories of types:
0000000000000000000000000000000000000000;;	// - external (serialized) types that lack their own version (e.g TypeMeta)
0000000000000000000000000000000000000000;;	// - internal (never-serialized) types that are needed by several different
0000000000000000000000000000000000000000;;	//   api groups, and so live here, to avoid duplication and/or import loops
0000000000000000000000000000000000000000;;	//   (e.g. LabelSelector).
0000000000000000000000000000000000000000;;	// In the future, we will probably move these categories of objects into
0000000000000000000000000000000000000000;;	// separate packages.
0000000000000000000000000000000000000000;;	package v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeMeta describes an individual object in an API response or request
0000000000000000000000000000000000000000;;	// with strings representing the type of the object and its API schema version.
0000000000000000000000000000000000000000;;	// Structures that are versioned or persisted should inline TypeMeta.
0000000000000000000000000000000000000000;;	type TypeMeta struct {
0000000000000000000000000000000000000000;;		// Kind is a string value representing the REST resource this object represents.
0000000000000000000000000000000000000000;;		// Servers may infer this from the endpoint the client submits requests to.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// In CamelCase.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Kind string `json:"kind,omitempty" protobuf:"bytes,1,opt,name=kind"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// APIVersion defines the versioned schema of this representation of an object.
0000000000000000000000000000000000000000;;		// Servers should convert recognized schemas to the latest internal value, and
0000000000000000000000000000000000000000;;		// may reject unrecognized values.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		APIVersion string `json:"apiVersion,omitempty" protobuf:"bytes,2,opt,name=apiVersion"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListMeta describes metadata that synthetic resources must have, including lists and
0000000000000000000000000000000000000000;;	// various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
0000000000000000000000000000000000000000;;	type ListMeta struct {
0000000000000000000000000000000000000000;;		// SelfLink is a URL representing this object.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SelfLink string `json:"selfLink,omitempty" protobuf:"bytes,1,opt,name=selfLink"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// String that identifies the server's internal version of this object that
0000000000000000000000000000000000000000;;		// can be used by clients to determine when objects have changed.
0000000000000000000000000000000000000000;;		// Value must be treated as opaque by clients and passed unmodified back to the server.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,2,opt,name=resourceVersion"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are internal finalizer values for Kubernetes-like APIs, must be qualified name unless defined here
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FinalizerOrphanDependents string = "orphan"
0000000000000000000000000000000000000000;;		FinalizerDeleteDependents string = "foregroundDeletion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
0000000000000000000000000000000000000000;;	// users must create.
0000000000000000000000000000000000000000;;	type ObjectMeta struct {
0000000000000000000000000000000000000000;;		// Name must be unique within a namespace. Is required when creating resources, although
0000000000000000000000000000000000000000;;		// some resources may allow a client to request the generation of an appropriate name
0000000000000000000000000000000000000000;;		// automatically. Name is primarily intended for creation idempotence and configuration
0000000000000000000000000000000000000000;;		// definition.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: http://kubernetes.io/docs/user-guide/identifiers#names
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GenerateName is an optional prefix, used by the server, to generate a unique
0000000000000000000000000000000000000000;;		// name ONLY IF the Name field has not been provided.
0000000000000000000000000000000000000000;;		// If this field is used, the name returned to the client will be different
0000000000000000000000000000000000000000;;		// than the name passed. This value will also be combined with a unique suffix.
0000000000000000000000000000000000000000;;		// The provided value has the same validation rules as the Name field,
0000000000000000000000000000000000000000;;		// and may be truncated by the length of the suffix required to make the value
0000000000000000000000000000000000000000;;		// unique on the server.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If this field is specified and the generated name exists, the server will
0000000000000000000000000000000000000000;;		// NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
0000000000000000000000000000000000000000;;		// ServerTimeout indicating a unique name could not be found in the time allotted, and the client
0000000000000000000000000000000000000000;;		// should retry (optionally after the time indicated in the Retry-After header).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Applied only if Name is not specified.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GenerateName string `json:"generateName,omitempty" protobuf:"bytes,2,opt,name=generateName"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Namespace defines the space within each name must be unique. An empty namespace is
0000000000000000000000000000000000000000;;		// equivalent to the "default" namespace, but "default" is the canonical representation.
0000000000000000000000000000000000000000;;		// Not all objects are required to be scoped to a namespace - the value of this field for
0000000000000000000000000000000000000000;;		// those objects will be empty.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Must be a DNS_LABEL.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: http://kubernetes.io/docs/user-guide/namespaces
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Namespace string `json:"namespace,omitempty" protobuf:"bytes,3,opt,name=namespace"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SelfLink is a URL representing this object.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SelfLink string `json:"selfLink,omitempty" protobuf:"bytes,4,opt,name=selfLink"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UID is the unique in time and space value for this object. It is typically generated by
0000000000000000000000000000000000000000;;		// the server on successful creation of a resource and is not allowed to change on PUT
0000000000000000000000000000000000000000;;		// operations.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UID types.UID `json:"uid,omitempty" protobuf:"bytes,5,opt,name=uid,casttype=k8s.io/kubernetes/pkg/types.UID"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An opaque value that represents the internal version of this object that can
0000000000000000000000000000000000000000;;		// be used by clients to determine when objects have changed. May be used for optimistic
0000000000000000000000000000000000000000;;		// concurrency, change detection, and the watch operation on a resource or set of resources.
0000000000000000000000000000000000000000;;		// Clients must treat these values as opaque and passed unmodified back to the server.
0000000000000000000000000000000000000000;;		// They may only be valid for a particular resource or set of resources.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// Value must be treated as opaque by clients and .
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,6,opt,name=resourceVersion"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A sequence number representing a specific generation of the desired state.
0000000000000000000000000000000000000000;;		// Populated by the system. Read-only.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Generation int64 `json:"generation,omitempty" protobuf:"varint,7,opt,name=generation"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CreationTimestamp is a timestamp representing the server time when this object was
0000000000000000000000000000000000000000;;		// created. It is not guaranteed to be set in happens-before order across separate operations.
0000000000000000000000000000000000000000;;		// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// Null for lists.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CreationTimestamp Time `json:"creationTimestamp,omitempty" protobuf:"bytes,8,opt,name=creationTimestamp"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
0000000000000000000000000000000000000000;;		// field is set by the server when a graceful deletion is requested by the user, and is not
0000000000000000000000000000000000000000;;		// directly settable by a client. The resource is expected to be deleted (no longer visible
0000000000000000000000000000000000000000;;		// from resource lists, and not reachable by name) after the time in this field. Once set,
0000000000000000000000000000000000000000;;		// this value may not be unset or be set further into the future, although it may be shortened
0000000000000000000000000000000000000000;;		// or the resource may be deleted prior to this time. For example, a user may request that
0000000000000000000000000000000000000000;;		// a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination
0000000000000000000000000000000000000000;;		// signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard
0000000000000000000000000000000000000000;;		// termination signal (SIGKILL) to the container and after cleanup, remove the pod from the
0000000000000000000000000000000000000000;;		// API. In the presence of network partitions, this object may still exist after this
0000000000000000000000000000000000000000;;		// timestamp, until an administrator or automated process can determine the resource is
0000000000000000000000000000000000000000;;		// fully terminated.
0000000000000000000000000000000000000000;;		// If not set, graceful deletion of the object has not been requested.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Populated by the system when a graceful deletion is requested.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DeletionTimestamp *Time `json:"deletionTimestamp,omitempty" protobuf:"bytes,9,opt,name=deletionTimestamp"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of seconds allowed for this object to gracefully terminate before
0000000000000000000000000000000000000000;;		// it will be removed from the system. Only set when deletionTimestamp is also set.
0000000000000000000000000000000000000000;;		// May only be shortened.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DeletionGracePeriodSeconds *int64 `json:"deletionGracePeriodSeconds,omitempty" protobuf:"varint,10,opt,name=deletionGracePeriodSeconds"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map of string keys and values that can be used to organize and categorize
0000000000000000000000000000000000000000;;		// (scope and select) objects. May match selectors of replication controllers
0000000000000000000000000000000000000000;;		// and services.
0000000000000000000000000000000000000000;;		// More info: http://kubernetes.io/docs/user-guide/labels
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Labels map[string]string `json:"labels,omitempty" protobuf:"bytes,11,rep,name=labels"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Annotations is an unstructured key value map stored with a resource that may be
0000000000000000000000000000000000000000;;		// set by external tools to store and retrieve arbitrary metadata. They are not
0000000000000000000000000000000000000000;;		// queryable and should be preserved when modifying objects.
0000000000000000000000000000000000000000;;		// More info: http://kubernetes.io/docs/user-guide/annotations
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Annotations map[string]string `json:"annotations,omitempty" protobuf:"bytes,12,rep,name=annotations"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of objects depended by this object. If ALL objects in the list have
0000000000000000000000000000000000000000;;		// been deleted, this object will be garbage collected. If this object is managed by a controller,
0000000000000000000000000000000000000000;;		// then an entry in this list will point to this controller, with the controller field set to true.
0000000000000000000000000000000000000000;;		// There cannot be more than one managing controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=uid
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		OwnerReferences []OwnerReference `json:"ownerReferences,omitempty" patchStrategy:"merge" patchMergeKey:"uid" protobuf:"bytes,13,rep,name=ownerReferences"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An initializer is a controller which enforces some system invariant at object creation time.
0000000000000000000000000000000000000000;;		// This field is a list of initializers that have not yet acted on this object. If nil or empty,
0000000000000000000000000000000000000000;;		// this object has been completely initialized. Otherwise, the object is considered uninitialized
0000000000000000000000000000000000000000;;		// and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to
0000000000000000000000000000000000000000;;		// observe uninitialized objects.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// When an object is created, the system will populate this list with the current set of initializers.
0000000000000000000000000000000000000000;;		// Only privileged users may set or modify this list. Once it is empty, it may not be modified further
0000000000000000000000000000000000000000;;		// by any user.
0000000000000000000000000000000000000000;;		Initializers *Initializers `json:"initializers,omitempty" protobuf:"bytes,16,opt,name=initializers"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Must be empty before the object is deleted from the registry. Each entry
0000000000000000000000000000000000000000;;		// is an identifier for the responsible component that will remove the entry
0000000000000000000000000000000000000000;;		// from the list. If the deletionTimestamp of the object is non-nil, entries
0000000000000000000000000000000000000000;;		// in this list can only be removed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Finalizers []string `json:"finalizers,omitempty" patchStrategy:"merge" protobuf:"bytes,14,rep,name=finalizers"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The name of the cluster which the object belongs to.
0000000000000000000000000000000000000000;;		// This is used to distinguish resources with same name and namespace in different clusters.
0000000000000000000000000000000000000000;;		// This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ClusterName string `json:"clusterName,omitempty" protobuf:"bytes,15,opt,name=clusterName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initializers tracks the progress of initialization.
0000000000000000000000000000000000000000;;	type Initializers struct {
0000000000000000000000000000000000000000;;		// Pending is a list of initializers that must execute in order before this object is visible.
0000000000000000000000000000000000000000;;		// When the last pending initializer is removed, and no failing result is set, the initializers
0000000000000000000000000000000000000000;;		// struct will be set to nil and the object is considered as initialized and visible to all
0000000000000000000000000000000000000000;;		// clients.
0000000000000000000000000000000000000000;;		Pending []Initializer `json:"pending" protobuf:"bytes,1,rep,name=pending"`
0000000000000000000000000000000000000000;;		// If result is set with the Failure field, the object will be persisted to storage and then deleted,
0000000000000000000000000000000000000000;;		// ensuring that other clients can observe the deletion.
0000000000000000000000000000000000000000;;		Result *Status `json:"result,omitempty" protobuf:"bytes,2,opt,name=result"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initializer is information about an initializer that has not yet completed.
0000000000000000000000000000000000000000;;	type Initializer struct {
0000000000000000000000000000000000000000;;		// name of the process that is responsible for initializing this object.
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NamespaceDefault means the object is in the default namespace which is applied when not specified by clients
0000000000000000000000000000000000000000;;		NamespaceDefault string = "default"
0000000000000000000000000000000000000000;;		// NamespaceAll is the default argument to specify on a context when you want to list or filter resources across all namespaces
0000000000000000000000000000000000000000;;		NamespaceAll string = ""
0000000000000000000000000000000000000000;;		// NamespaceNone is the argument for a context when there is no namespace.
0000000000000000000000000000000000000000;;		NamespaceNone string = ""
0000000000000000000000000000000000000000;;		// NamespaceSystem is the system namespace where we place system components.
0000000000000000000000000000000000000000;;		NamespaceSystem string = "kube-system"
0000000000000000000000000000000000000000;;		// NamespacePublic is the namespace where we place public info (ConfigMaps)
0000000000000000000000000000000000000000;;		NamespacePublic string = "kube-public"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OwnerReference contains enough information to let you identify an owning
0000000000000000000000000000000000000000;;	// object. Currently, an owning object must be in the same namespace, so there
0000000000000000000000000000000000000000;;	// is no namespace field.
0000000000000000000000000000000000000000;;	type OwnerReference struct {
0000000000000000000000000000000000000000;;		// API version of the referent.
0000000000000000000000000000000000000000;;		APIVersion string `json:"apiVersion" protobuf:"bytes,5,opt,name=apiVersion"`
0000000000000000000000000000000000000000;;		// Kind of the referent.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		Kind string `json:"kind" protobuf:"bytes,1,opt,name=kind"`
0000000000000000000000000000000000000000;;		// Name of the referent.
0000000000000000000000000000000000000000;;		// More info: http://kubernetes.io/docs/user-guide/identifiers#names
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,3,opt,name=name"`
0000000000000000000000000000000000000000;;		// UID of the referent.
0000000000000000000000000000000000000000;;		// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
0000000000000000000000000000000000000000;;		UID types.UID `json:"uid" protobuf:"bytes,4,opt,name=uid,casttype=k8s.io/apimachinery/pkg/types.UID"`
0000000000000000000000000000000000000000;;		// If true, this reference points to the managing controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Controller *bool `json:"controller,omitempty" protobuf:"varint,6,opt,name=controller"`
0000000000000000000000000000000000000000;;		// If true, AND if the owner has the "foregroundDeletion" finalizer, then
0000000000000000000000000000000000000000;;		// the owner cannot be deleted from the key-value store until this
0000000000000000000000000000000000000000;;		// reference is removed.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// To set this field, a user needs "delete" permission of the owner,
0000000000000000000000000000000000000000;;		// otherwise 422 (Unprocessable Entity) will be returned.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		BlockOwnerDeletion *bool `json:"blockOwnerDeletion,omitempty" protobuf:"varint,7,opt,name=blockOwnerDeletion"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListOptions is the query options to a standard REST list call.
0000000000000000000000000000000000000000;;	type ListOptions struct {
0000000000000000000000000000000000000000;;		TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A selector to restrict the list of returned objects by their labels.
0000000000000000000000000000000000000000;;		// Defaults to everything.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LabelSelector string `json:"labelSelector,omitempty" protobuf:"bytes,1,opt,name=labelSelector"`
0000000000000000000000000000000000000000;;		// A selector to restrict the list of returned objects by their fields.
0000000000000000000000000000000000000000;;		// Defaults to everything.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FieldSelector string `json:"fieldSelector,omitempty" protobuf:"bytes,2,opt,name=fieldSelector"`
0000000000000000000000000000000000000000;;		// If true, partially initialized resources are included in the response.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		IncludeUninitialized bool `json:"includeUninitialized,omitempty" protobuf:"varint,6,opt,name=includeUninitialized"`
0000000000000000000000000000000000000000;;		// Watch for changes to the described resources and return them as a stream of
0000000000000000000000000000000000000000;;		// add, update, and remove notifications. Specify resourceVersion.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Watch bool `json:"watch,omitempty" protobuf:"varint,3,opt,name=watch"`
0000000000000000000000000000000000000000;;		// When specified with a watch call, shows changes that occur after that particular version of a resource.
0000000000000000000000000000000000000000;;		// Defaults to changes from the beginning of history.
0000000000000000000000000000000000000000;;		// When specified for list:
0000000000000000000000000000000000000000;;		// - if unset, then the result is returned from remote storage based on quorum-read flag;
0000000000000000000000000000000000000000;;		// - if it's 0, then we simply return what we currently have in cache, no guarantee;
0000000000000000000000000000000000000000;;		// - if set to non zero, then the result is at least as fresh as given rv.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,4,opt,name=resourceVersion"`
0000000000000000000000000000000000000000;;		// Timeout for the list/watch call.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TimeoutSeconds *int64 `json:"timeoutSeconds,omitempty" protobuf:"varint,5,opt,name=timeoutSeconds"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExportOptions is the query options to the standard REST get call.
0000000000000000000000000000000000000000;;	type ExportOptions struct {
0000000000000000000000000000000000000000;;		TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Should this value be exported.  Export strips fields that a user can not specify.
0000000000000000000000000000000000000000;;		Export bool `json:"export" protobuf:"varint,1,opt,name=export"`
0000000000000000000000000000000000000000;;		// Should the export be exact.  Exact export maintains cluster-specific fields like 'Namespace'.
0000000000000000000000000000000000000000;;		Exact bool `json:"exact" protobuf:"varint,2,opt,name=exact"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetOptions is the standard query options to the standard REST get call.
0000000000000000000000000000000000000000;;	type GetOptions struct {
0000000000000000000000000000000000000000;;		TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// When specified:
0000000000000000000000000000000000000000;;		// - if unset, then the result is returned from remote storage based on quorum-read flag;
0000000000000000000000000000000000000000;;		// - if it's 0, then we simply return what we currently have in cache, no guarantee;
0000000000000000000000000000000000000000;;		// - if set to non zero, then the result is at least as fresh as given rv.
0000000000000000000000000000000000000000;;		ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,1,opt,name=resourceVersion"`
0000000000000000000000000000000000000000;;		// If true, partially initialized resources are included in the response.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		IncludeUninitialized bool `json:"includeUninitialized,omitempty" protobuf:"varint,2,opt,name=includeUninitialized"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeletionPropagation decides if a deletion will propagate to the dependents of
0000000000000000000000000000000000000000;;	// the object, and how the garbage collector will handle the propagation.
0000000000000000000000000000000000000000;;	type DeletionPropagation string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Orphans the dependents.
0000000000000000000000000000000000000000;;		DeletePropagationOrphan DeletionPropagation = "Orphan"
0000000000000000000000000000000000000000;;		// Deletes the object from the key-value store, the garbage collector will
0000000000000000000000000000000000000000;;		// delete the dependents in the background.
0000000000000000000000000000000000000000;;		DeletePropagationBackground DeletionPropagation = "Background"
0000000000000000000000000000000000000000;;		// The object exists in the key-value store until the garbage collector
0000000000000000000000000000000000000000;;		// deletes all the dependents whose ownerReference.blockOwnerDeletion=true
0000000000000000000000000000000000000000;;		// from the key-value store.  API sever will put the "foregroundDeletion"
0000000000000000000000000000000000000000;;		// finalizer on the object, and sets its deletionTimestamp.  This policy is
0000000000000000000000000000000000000000;;		// cascading, i.e., the dependents will be deleted with Foreground.
0000000000000000000000000000000000000000;;		DeletePropagationForeground DeletionPropagation = "Foreground"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteOptions may be provided when deleting an API object.
0000000000000000000000000000000000000000;;	type DeleteOptions struct {
0000000000000000000000000000000000000000;;		TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The duration in seconds before the object should be deleted. Value must be non-negative integer.
0000000000000000000000000000000000000000;;		// The value zero indicates delete immediately. If this value is nil, the default grace period for the
0000000000000000000000000000000000000000;;		// specified type will be used.
0000000000000000000000000000000000000000;;		// Defaults to a per object value if not specified. zero means delete immediately.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GracePeriodSeconds *int64 `json:"gracePeriodSeconds,omitempty" protobuf:"varint,1,opt,name=gracePeriodSeconds"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
0000000000000000000000000000000000000000;;		// returned.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Preconditions *Preconditions `json:"preconditions,omitempty" protobuf:"bytes,2,opt,name=preconditions"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
0000000000000000000000000000000000000000;;		// Should the dependent objects be orphaned. If true/false, the "orphan"
0000000000000000000000000000000000000000;;		// finalizer will be added to/removed from the object's finalizers list.
0000000000000000000000000000000000000000;;		// Either this field or PropagationPolicy may be set, but not both.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		OrphanDependents *bool `json:"orphanDependents,omitempty" protobuf:"varint,3,opt,name=orphanDependents"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether and how garbage collection will be performed.
0000000000000000000000000000000000000000;;		// Either this field or OrphanDependents may be set, but not both.
0000000000000000000000000000000000000000;;		// The default policy is decided by the existing finalizer set in the
0000000000000000000000000000000000000000;;		// metadata.finalizers and the resource-specific default policy.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PropagationPolicy *DeletionPropagation `json:"propagationPolicy,omitempty" protobuf:"varint,4,opt,name=propagationPolicy"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
0000000000000000000000000000000000000000;;	type Preconditions struct {
0000000000000000000000000000000000000000;;		// Specifies the target UID.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UID *types.UID `json:"uid,omitempty" protobuf:"bytes,1,opt,name=uid,casttype=k8s.io/apimachinery/pkg/types.UID"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status is a return value for calls that don't return other objects.
0000000000000000000000000000000000000000;;	type Status struct {
0000000000000000000000000000000000000000;;		TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status of the operation.
0000000000000000000000000000000000000000;;		// One of: "Success" or "Failure".
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status string `json:"status,omitempty" protobuf:"bytes,2,opt,name=status"`
0000000000000000000000000000000000000000;;		// A human-readable description of the status of this operation.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,3,opt,name=message"`
0000000000000000000000000000000000000000;;		// A machine-readable description of why this operation is in the
0000000000000000000000000000000000000000;;		// "Failure" status. If this value is empty there
0000000000000000000000000000000000000000;;		// is no information available. A Reason clarifies an HTTP status
0000000000000000000000000000000000000000;;		// code but does not override it.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason StatusReason `json:"reason,omitempty" protobuf:"bytes,4,opt,name=reason,casttype=StatusReason"`
0000000000000000000000000000000000000000;;		// Extended data associated with the reason.  Each reason may define its
0000000000000000000000000000000000000000;;		// own extended details. This field is optional and the data returned
0000000000000000000000000000000000000000;;		// is not guaranteed to conform to any schema except that defined by
0000000000000000000000000000000000000000;;		// the reason type.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Details *StatusDetails `json:"details,omitempty" protobuf:"bytes,5,opt,name=details"`
0000000000000000000000000000000000000000;;		// Suggested HTTP return code for this status, 0 if not set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Code int32 `json:"code,omitempty" protobuf:"varint,6,opt,name=code"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusDetails is a set of additional properties that MAY be set by the
0000000000000000000000000000000000000000;;	// server to provide additional information about a response. The Reason
0000000000000000000000000000000000000000;;	// field of a Status object defines what attributes will be set. Clients
0000000000000000000000000000000000000000;;	// must ignore fields that do not match the defined type of each attribute,
0000000000000000000000000000000000000000;;	// and should assume that any attribute may be empty, invalid, or under
0000000000000000000000000000000000000000;;	// defined.
0000000000000000000000000000000000000000;;	type StatusDetails struct {
0000000000000000000000000000000000000000;;		// The name attribute of the resource associated with the status StatusReason
0000000000000000000000000000000000000000;;		// (when there is a single name which can be described).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// The group attribute of the resource associated with the status StatusReason.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Group string `json:"group,omitempty" protobuf:"bytes,2,opt,name=group"`
0000000000000000000000000000000000000000;;		// The kind attribute of the resource associated with the status StatusReason.
0000000000000000000000000000000000000000;;		// On some operations may differ from the requested resource Kind.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Kind string `json:"kind,omitempty" protobuf:"bytes,3,opt,name=kind"`
0000000000000000000000000000000000000000;;		// UID of the resource.
0000000000000000000000000000000000000000;;		// (when there is a single resource which can be described).
0000000000000000000000000000000000000000;;		// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UID types.UID `json:"uid,omitempty" protobuf:"bytes,6,opt,name=uid,casttype=k8s.io/apimachinery/pkg/types.UID"`
0000000000000000000000000000000000000000;;		// The Causes array includes more details associated with the StatusReason
0000000000000000000000000000000000000000;;		// failure. Not all StatusReasons may provide detailed causes.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Causes []StatusCause `json:"causes,omitempty" protobuf:"bytes,4,rep,name=causes"`
0000000000000000000000000000000000000000;;		// If specified, the time in seconds before the operation should be retried.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RetryAfterSeconds int32 `json:"retryAfterSeconds,omitempty" protobuf:"varint,5,opt,name=retryAfterSeconds"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Values of Status.Status
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		StatusSuccess = "Success"
0000000000000000000000000000000000000000;;		StatusFailure = "Failure"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusReason is an enumeration of possible failure causes.  Each StatusReason
0000000000000000000000000000000000000000;;	// must map to a single HTTP status code, but multiple reasons may map
0000000000000000000000000000000000000000;;	// to the same HTTP status code.
0000000000000000000000000000000000000000;;	// TODO: move to apiserver
0000000000000000000000000000000000000000;;	type StatusReason string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// StatusReasonUnknown means the server has declined to indicate a specific reason.
0000000000000000000000000000000000000000;;		// The details field may contain other information about this error.
0000000000000000000000000000000000000000;;		// Status code 500.
0000000000000000000000000000000000000000;;		StatusReasonUnknown StatusReason = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonUnauthorized means the server can be reached and understood the request, but requires
0000000000000000000000000000000000000000;;		// the user to present appropriate authorization credentials (identified by the WWW-Authenticate header)
0000000000000000000000000000000000000000;;		// in order for the action to be completed. If the user has specified credentials on the request, the
0000000000000000000000000000000000000000;;		// server considers them insufficient.
0000000000000000000000000000000000000000;;		// Status code 401
0000000000000000000000000000000000000000;;		StatusReasonUnauthorized StatusReason = "Unauthorized"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonForbidden means the server can be reached and understood the request, but refuses
0000000000000000000000000000000000000000;;		// to take any further action.  It is the result of the server being configured to deny access for some reason
0000000000000000000000000000000000000000;;		// to the requested resource by the client.
0000000000000000000000000000000000000000;;		// Details (optional):
0000000000000000000000000000000000000000;;		//   "kind" string - the kind attribute of the forbidden resource
0000000000000000000000000000000000000000;;		//                   on some operations may differ from the requested
0000000000000000000000000000000000000000;;		//                   resource.
0000000000000000000000000000000000000000;;		//   "id"   string - the identifier of the forbidden resource
0000000000000000000000000000000000000000;;		// Status code 403
0000000000000000000000000000000000000000;;		StatusReasonForbidden StatusReason = "Forbidden"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonNotFound means one or more resources required for this operation
0000000000000000000000000000000000000000;;		// could not be found.
0000000000000000000000000000000000000000;;		// Details (optional):
0000000000000000000000000000000000000000;;		//   "kind" string - the kind attribute of the missing resource
0000000000000000000000000000000000000000;;		//                   on some operations may differ from the requested
0000000000000000000000000000000000000000;;		//                   resource.
0000000000000000000000000000000000000000;;		//   "id"   string - the identifier of the missing resource
0000000000000000000000000000000000000000;;		// Status code 404
0000000000000000000000000000000000000000;;		StatusReasonNotFound StatusReason = "NotFound"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonAlreadyExists means the resource you are creating already exists.
0000000000000000000000000000000000000000;;		// Details (optional):
0000000000000000000000000000000000000000;;		//   "kind" string - the kind attribute of the conflicting resource
0000000000000000000000000000000000000000;;		//   "id"   string - the identifier of the conflicting resource
0000000000000000000000000000000000000000;;		// Status code 409
0000000000000000000000000000000000000000;;		StatusReasonAlreadyExists StatusReason = "AlreadyExists"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonConflict means the requested operation cannot be completed
0000000000000000000000000000000000000000;;		// due to a conflict in the operation. The client may need to alter the
0000000000000000000000000000000000000000;;		// request. Each resource may define custom details that indicate the
0000000000000000000000000000000000000000;;		// nature of the conflict.
0000000000000000000000000000000000000000;;		// Status code 409
0000000000000000000000000000000000000000;;		StatusReasonConflict StatusReason = "Conflict"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonGone means the item is no longer available at the server and no
0000000000000000000000000000000000000000;;		// forwarding address is known.
0000000000000000000000000000000000000000;;		// Status code 410
0000000000000000000000000000000000000000;;		StatusReasonGone StatusReason = "Gone"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonInvalid means the requested create or update operation cannot be
0000000000000000000000000000000000000000;;		// completed due to invalid data provided as part of the request. The client may
0000000000000000000000000000000000000000;;		// need to alter the request. When set, the client may use the StatusDetails
0000000000000000000000000000000000000000;;		// message field as a summary of the issues encountered.
0000000000000000000000000000000000000000;;		// Details (optional):
0000000000000000000000000000000000000000;;		//   "kind" string - the kind attribute of the invalid resource
0000000000000000000000000000000000000000;;		//   "id"   string - the identifier of the invalid resource
0000000000000000000000000000000000000000;;		//   "causes"      - one or more StatusCause entries indicating the data in the
0000000000000000000000000000000000000000;;		//                   provided resource that was invalid.  The code, message, and
0000000000000000000000000000000000000000;;		//                   field attributes will be set.
0000000000000000000000000000000000000000;;		// Status code 422
0000000000000000000000000000000000000000;;		StatusReasonInvalid StatusReason = "Invalid"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonServerTimeout means the server can be reached and understood the request,
0000000000000000000000000000000000000000;;		// but cannot complete the action in a reasonable time. The client should retry the request.
0000000000000000000000000000000000000000;;		// This is may be due to temporary server load or a transient communication issue with
0000000000000000000000000000000000000000;;		// another server. Status code 500 is used because the HTTP spec provides no suitable
0000000000000000000000000000000000000000;;		// server-requested client retry and the 5xx class represents actionable errors.
0000000000000000000000000000000000000000;;		// Details (optional):
0000000000000000000000000000000000000000;;		//   "kind" string - the kind attribute of the resource being acted on.
0000000000000000000000000000000000000000;;		//   "id"   string - the operation that is being attempted.
0000000000000000000000000000000000000000;;		//   "retryAfterSeconds" int32 - the number of seconds before the operation should be retried
0000000000000000000000000000000000000000;;		// Status code 500
0000000000000000000000000000000000000000;;		StatusReasonServerTimeout StatusReason = "ServerTimeout"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonTimeout means that the request could not be completed within the given time.
0000000000000000000000000000000000000000;;		// Clients can get this response only when they specified a timeout param in the request,
0000000000000000000000000000000000000000;;		// or if the server cannot complete the operation within a reasonable amount of time.
0000000000000000000000000000000000000000;;		// The request might succeed with an increased value of timeout param. The client *should*
0000000000000000000000000000000000000000;;		// wait at least the number of seconds specified by the retryAfterSeconds field.
0000000000000000000000000000000000000000;;		// Details (optional):
0000000000000000000000000000000000000000;;		//   "retryAfterSeconds" int32 - the number of seconds before the operation should be retried
0000000000000000000000000000000000000000;;		// Status code 504
0000000000000000000000000000000000000000;;		StatusReasonTimeout StatusReason = "Timeout"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonBadRequest means that the request itself was invalid, because the request
0000000000000000000000000000000000000000;;		// doesn't make any sense, for example deleting a read-only object.  This is different than
0000000000000000000000000000000000000000;;		// StatusReasonInvalid above which indicates that the API call could possibly succeed, but the
0000000000000000000000000000000000000000;;		// data was invalid.  API calls that return BadRequest can never succeed.
0000000000000000000000000000000000000000;;		StatusReasonBadRequest StatusReason = "BadRequest"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonMethodNotAllowed means that the action the client attempted to perform on the
0000000000000000000000000000000000000000;;		// resource was not supported by the code - for instance, attempting to delete a resource that
0000000000000000000000000000000000000000;;		// can only be created. API calls that return MethodNotAllowed can never succeed.
0000000000000000000000000000000000000000;;		StatusReasonMethodNotAllowed StatusReason = "MethodNotAllowed"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonInternalError indicates that an internal error occurred, it is unexpected
0000000000000000000000000000000000000000;;		// and the outcome of the call is unknown.
0000000000000000000000000000000000000000;;		// Details (optional):
0000000000000000000000000000000000000000;;		//   "causes" - The original error
0000000000000000000000000000000000000000;;		// Status code 500
0000000000000000000000000000000000000000;;		StatusReasonInternalError StatusReason = "InternalError"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonExpired indicates that the request is invalid because the content you are requesting
0000000000000000000000000000000000000000;;		// has expired and is no longer available. It is typically associated with watches that can't be
0000000000000000000000000000000000000000;;		// serviced.
0000000000000000000000000000000000000000;;		// Status code 410 (gone)
0000000000000000000000000000000000000000;;		StatusReasonExpired StatusReason = "Expired"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StatusReasonServiceUnavailable means that the request itself was valid,
0000000000000000000000000000000000000000;;		// but the requested service is unavailable at this time.
0000000000000000000000000000000000000000;;		// Retrying the request after some time might succeed.
0000000000000000000000000000000000000000;;		// Status code 503
0000000000000000000000000000000000000000;;		StatusReasonServiceUnavailable StatusReason = "ServiceUnavailable"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatusCause provides more information about an api.Status failure, including
0000000000000000000000000000000000000000;;	// cases when multiple errors are encountered.
0000000000000000000000000000000000000000;;	type StatusCause struct {
0000000000000000000000000000000000000000;;		// A machine-readable description of the cause of the error. If this value is
0000000000000000000000000000000000000000;;		// empty there is no information available.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type CauseType `json:"reason,omitempty" protobuf:"bytes,1,opt,name=reason,casttype=CauseType"`
0000000000000000000000000000000000000000;;		// A human-readable description of the cause of the error.  This field may be
0000000000000000000000000000000000000000;;		// presented as-is to a reader.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,2,opt,name=message"`
0000000000000000000000000000000000000000;;		// The field of the resource that has caused this error, as named by its JSON
0000000000000000000000000000000000000000;;		// serialization. May include dot and postfix notation for nested attributes.
0000000000000000000000000000000000000000;;		// Arrays are zero-indexed.  Fields may appear more than once in an array of
0000000000000000000000000000000000000000;;		// causes due to fields having multiple errors.
0000000000000000000000000000000000000000;;		// Optional.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Examples:
0000000000000000000000000000000000000000;;		//   "name" - the field "name" on the current resource
0000000000000000000000000000000000000000;;		//   "items[0].name" - the field "name" on the first array entry in "items"
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Field string `json:"field,omitempty" protobuf:"bytes,3,opt,name=field"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CauseType is a machine readable value providing more detail about what
0000000000000000000000000000000000000000;;	// occurred in a status response. An operation may have multiple causes for a
0000000000000000000000000000000000000000;;	// status (whether Failure or Success).
0000000000000000000000000000000000000000;;	type CauseType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// CauseTypeFieldValueNotFound is used to report failure to find a requested value
0000000000000000000000000000000000000000;;		// (e.g. looking up an ID).
0000000000000000000000000000000000000000;;		CauseTypeFieldValueNotFound CauseType = "FieldValueNotFound"
0000000000000000000000000000000000000000;;		// CauseTypeFieldValueRequired is used to report required values that are not
0000000000000000000000000000000000000000;;		// provided (e.g. empty strings, null values, or empty arrays).
0000000000000000000000000000000000000000;;		CauseTypeFieldValueRequired CauseType = "FieldValueRequired"
0000000000000000000000000000000000000000;;		// CauseTypeFieldValueDuplicate is used to report collisions of values that must be
0000000000000000000000000000000000000000;;		// unique (e.g. unique IDs).
0000000000000000000000000000000000000000;;		CauseTypeFieldValueDuplicate CauseType = "FieldValueDuplicate"
0000000000000000000000000000000000000000;;		// CauseTypeFieldValueInvalid is used to report malformed values (e.g. failed regex
0000000000000000000000000000000000000000;;		// match).
0000000000000000000000000000000000000000;;		CauseTypeFieldValueInvalid CauseType = "FieldValueInvalid"
0000000000000000000000000000000000000000;;		// CauseTypeFieldValueNotSupported is used to report valid (as per formatting rules)
0000000000000000000000000000000000000000;;		// values that can not be handled (e.g. an enumerated string).
0000000000000000000000000000000000000000;;		CauseTypeFieldValueNotSupported CauseType = "FieldValueNotSupported"
0000000000000000000000000000000000000000;;		// CauseTypeUnexpectedServerResponse is used to report when the server responded to the client
0000000000000000000000000000000000000000;;		// without the expected return type. The presence of this cause indicates the error may be
0000000000000000000000000000000000000000;;		// due to an intervening proxy or the server software malfunctioning.
0000000000000000000000000000000000000000;;		CauseTypeUnexpectedServerResponse CauseType = "UnexpectedServerResponse"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIVersions lists the versions that are available, to allow clients to
0000000000000000000000000000000000000000;;	// discover the API at /api, which is the root path of the legacy v1 API.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +protobuf.options.(gogoproto.goproto_stringer)=false
0000000000000000000000000000000000000000;;	type APIVersions struct {
0000000000000000000000000000000000000000;;		TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// versions are the api versions that are available.
0000000000000000000000000000000000000000;;		Versions []string `json:"versions" protobuf:"bytes,1,rep,name=versions"`
0000000000000000000000000000000000000000;;		// a map of client CIDR to server address that is serving this group.
0000000000000000000000000000000000000000;;		// This is to help clients reach servers in the most network-efficient way possible.
0000000000000000000000000000000000000000;;		// Clients can use the appropriate server address as per the CIDR that they match.
0000000000000000000000000000000000000000;;		// In case of multiple matches, clients should use the longest matching CIDR.
0000000000000000000000000000000000000000;;		// The server returns only those CIDRs that it thinks that the client can match.
0000000000000000000000000000000000000000;;		// For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
0000000000000000000000000000000000000000;;		// Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
0000000000000000000000000000000000000000;;		ServerAddressByClientCIDRs []ServerAddressByClientCIDR `json:"serverAddressByClientCIDRs" protobuf:"bytes,2,rep,name=serverAddressByClientCIDRs"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIGroupList is a list of APIGroup, to allow clients to discover the API at
0000000000000000000000000000000000000000;;	// /apis.
0000000000000000000000000000000000000000;;	type APIGroupList struct {
0000000000000000000000000000000000000000;;		TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// groups is a list of APIGroup.
0000000000000000000000000000000000000000;;		Groups []APIGroup `json:"groups" protobuf:"bytes,1,rep,name=groups"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIGroup contains the name, the supported versions, and the preferred version
0000000000000000000000000000000000000000;;	// of a group.
0000000000000000000000000000000000000000;;	type APIGroup struct {
0000000000000000000000000000000000000000;;		TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// name is the name of the group.
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// versions are the versions supported in this group.
0000000000000000000000000000000000000000;;		Versions []GroupVersionForDiscovery `json:"versions" protobuf:"bytes,2,rep,name=versions"`
0000000000000000000000000000000000000000;;		// preferredVersion is the version preferred by the API server, which
0000000000000000000000000000000000000000;;		// probably is the storage version.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreferredVersion GroupVersionForDiscovery `json:"preferredVersion,omitempty" protobuf:"bytes,3,opt,name=preferredVersion"`
0000000000000000000000000000000000000000;;		// a map of client CIDR to server address that is serving this group.
0000000000000000000000000000000000000000;;		// This is to help clients reach servers in the most network-efficient way possible.
0000000000000000000000000000000000000000;;		// Clients can use the appropriate server address as per the CIDR that they match.
0000000000000000000000000000000000000000;;		// In case of multiple matches, clients should use the longest matching CIDR.
0000000000000000000000000000000000000000;;		// The server returns only those CIDRs that it thinks that the client can match.
0000000000000000000000000000000000000000;;		// For example: the master will return an internal IP CIDR only, if the client reaches the server using an internal IP.
0000000000000000000000000000000000000000;;		// Server looks at X-Forwarded-For header or X-Real-Ip header or request.RemoteAddr (in that order) to get the client IP.
0000000000000000000000000000000000000000;;		ServerAddressByClientCIDRs []ServerAddressByClientCIDR `json:"serverAddressByClientCIDRs" protobuf:"bytes,4,rep,name=serverAddressByClientCIDRs"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerAddressByClientCIDR helps the client to determine the server address that they should use, depending on the clientCIDR that they match.
0000000000000000000000000000000000000000;;	type ServerAddressByClientCIDR struct {
0000000000000000000000000000000000000000;;		// The CIDR with which clients can match their IP to figure out the server address that they should use.
0000000000000000000000000000000000000000;;		ClientCIDR string `json:"clientCIDR" protobuf:"bytes,1,opt,name=clientCIDR"`
0000000000000000000000000000000000000000;;		// Address of this server, suitable for a client that matches the above CIDR.
0000000000000000000000000000000000000000;;		// This can be a hostname, hostname:port, IP or IP:port.
0000000000000000000000000000000000000000;;		ServerAddress string `json:"serverAddress" protobuf:"bytes,2,opt,name=serverAddress"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GroupVersion contains the "group/version" and "version" string of a version.
0000000000000000000000000000000000000000;;	// It is made a struct to keep extensibility.
0000000000000000000000000000000000000000;;	type GroupVersionForDiscovery struct {
0000000000000000000000000000000000000000;;		// groupVersion specifies the API group and version in the form "group/version"
0000000000000000000000000000000000000000;;		GroupVersion string `json:"groupVersion" protobuf:"bytes,1,opt,name=groupVersion"`
0000000000000000000000000000000000000000;;		// version specifies the version in the form of "version". This is to save
0000000000000000000000000000000000000000;;		// the clients the trouble of splitting the GroupVersion.
0000000000000000000000000000000000000000;;		Version string `json:"version" protobuf:"bytes,2,opt,name=version"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIResource specifies the name of a resource and whether it is namespaced.
0000000000000000000000000000000000000000;;	type APIResource struct {
0000000000000000000000000000000000000000;;		// name is the plural name of the resource.
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// singularName is the singular name of the resource.  This allows clients to handle plural and singular opaquely.
0000000000000000000000000000000000000000;;		// The singularName is more correct for reporting status on a single item and both singular and plural are allowed
0000000000000000000000000000000000000000;;		// from the kubectl CLI interface.
0000000000000000000000000000000000000000;;		SingularName string `json:"singularName" protobuf:"bytes,6,opt,name=singularName"`
0000000000000000000000000000000000000000;;		// namespaced indicates if a resource is namespaced or not.
0000000000000000000000000000000000000000;;		Namespaced bool `json:"namespaced" protobuf:"varint,2,opt,name=namespaced"`
0000000000000000000000000000000000000000;;		// kind is the kind for the resource (e.g. 'Foo' is the kind for a resource 'foo')
0000000000000000000000000000000000000000;;		Kind string `json:"kind" protobuf:"bytes,3,opt,name=kind"`
0000000000000000000000000000000000000000;;		// verbs is a list of supported kube verbs (this includes get, list, watch, create,
0000000000000000000000000000000000000000;;		// update, patch, delete, deletecollection, and proxy)
0000000000000000000000000000000000000000;;		Verbs Verbs `json:"verbs" protobuf:"bytes,4,opt,name=verbs"`
0000000000000000000000000000000000000000;;		// shortNames is a list of suggested short names of the resource.
0000000000000000000000000000000000000000;;		ShortNames []string `json:"shortNames,omitempty" protobuf:"bytes,5,rep,name=shortNames"`
0000000000000000000000000000000000000000;;		// categories is a list of the grouped resources this resource belongs to (e.g. 'all')
0000000000000000000000000000000000000000;;		Categories []string `json:"categories,omitempty" protobuf:"bytes,7,rep,name=categories"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verbs masks the value so protobuf can generate
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// +protobuf.nullable=true
0000000000000000000000000000000000000000;;	// +protobuf.options.(gogoproto.goproto_stringer)=false
0000000000000000000000000000000000000000;;	type Verbs []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vs Verbs) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v", []string(vs))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIResourceList is a list of APIResource, it is used to expose the name of the
0000000000000000000000000000000000000000;;	// resources supported in a specific group and version, and if the resource
0000000000000000000000000000000000000000;;	// is namespaced.
0000000000000000000000000000000000000000;;	type APIResourceList struct {
0000000000000000000000000000000000000000;;		TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// groupVersion is the group and version this APIResourceList is for.
0000000000000000000000000000000000000000;;		GroupVersion string `json:"groupVersion" protobuf:"bytes,1,opt,name=groupVersion"`
0000000000000000000000000000000000000000;;		// resources contains the name of the resources and if they are namespaced.
0000000000000000000000000000000000000000;;		APIResources []APIResource `json:"resources" protobuf:"bytes,2,rep,name=resources"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RootPaths lists the paths available at root.
0000000000000000000000000000000000000000;;	// For example: "/healthz", "/apis".
0000000000000000000000000000000000000000;;	type RootPaths struct {
0000000000000000000000000000000000000000;;		// paths are the paths available at root.
0000000000000000000000000000000000000000;;		Paths []string `json:"paths" protobuf:"bytes,1,rep,name=paths"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove me when watch is refactored
0000000000000000000000000000000000000000;;	func LabelSelectorQueryParam(version string) string {
0000000000000000000000000000000000000000;;		return "labelSelector"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: remove me when watch is refactored
0000000000000000000000000000000000000000;;	func FieldSelectorQueryParam(version string) string {
0000000000000000000000000000000000000000;;		return "fieldSelector"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns available api versions as a human-friendly version string.
0000000000000000000000000000000000000000;;	func (apiVersions APIVersions) String() string {
0000000000000000000000000000000000000000;;		return strings.Join(apiVersions.Versions, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (apiVersions APIVersions) GoString() string {
0000000000000000000000000000000000000000;;		return apiVersions.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Patch is provided to give a concrete name and type to the Kubernetes PATCH request body.
0000000000000000000000000000000000000000;;	type Patch struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note:
0000000000000000000000000000000000000000;;	// There are two different styles of label selectors used in versioned types:
0000000000000000000000000000000000000000;;	// an older style which is represented as just a string in versioned types, and a
0000000000000000000000000000000000000000;;	// newer style that is structured.  LabelSelector is an internal representation for the
0000000000000000000000000000000000000000;;	// latter style.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A label selector is a label query over a set of resources. The result of matchLabels and
0000000000000000000000000000000000000000;;	// matchExpressions are ANDed. An empty label selector matches all objects. A null
0000000000000000000000000000000000000000;;	// label selector matches no objects.
0000000000000000000000000000000000000000;;	type LabelSelector struct {
0000000000000000000000000000000000000000;;		// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
0000000000000000000000000000000000000000;;		// map is equivalent to an element of matchExpressions, whose key field is "key", the
0000000000000000000000000000000000000000;;		// operator is "In", and the values array contains only "value". The requirements are ANDed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MatchLabels map[string]string `json:"matchLabels,omitempty" protobuf:"bytes,1,rep,name=matchLabels"`
0000000000000000000000000000000000000000;;		// matchExpressions is a list of label selector requirements. The requirements are ANDed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MatchExpressions []LabelSelectorRequirement `json:"matchExpressions,omitempty" protobuf:"bytes,2,rep,name=matchExpressions"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A label selector requirement is a selector that contains values, a key, and an operator that
0000000000000000000000000000000000000000;;	// relates the key and values.
0000000000000000000000000000000000000000;;	type LabelSelectorRequirement struct {
0000000000000000000000000000000000000000;;		// key is the label key that the selector applies to.
0000000000000000000000000000000000000000;;		// +patchMergeKey=key
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Key string `json:"key" patchStrategy:"merge" patchMergeKey:"key" protobuf:"bytes,1,opt,name=key"`
0000000000000000000000000000000000000000;;		// operator represents a key's relationship to a set of values.
0000000000000000000000000000000000000000;;		// Valid operators ard In, NotIn, Exists and DoesNotExist.
0000000000000000000000000000000000000000;;		Operator LabelSelectorOperator `json:"operator" protobuf:"bytes,2,opt,name=operator,casttype=LabelSelectorOperator"`
0000000000000000000000000000000000000000;;		// values is an array of string values. If the operator is In or NotIn,
0000000000000000000000000000000000000000;;		// the values array must be non-empty. If the operator is Exists or DoesNotExist,
0000000000000000000000000000000000000000;;		// the values array must be empty. This array is replaced during a strategic
0000000000000000000000000000000000000000;;		// merge patch.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Values []string `json:"values,omitempty" protobuf:"bytes,3,rep,name=values"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A label selector operator is the set of operators that can be used in a selector requirement.
0000000000000000000000000000000000000000;;	type LabelSelectorOperator string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		LabelSelectorOpIn           LabelSelectorOperator = "In"
0000000000000000000000000000000000000000;;		LabelSelectorOpNotIn        LabelSelectorOperator = "NotIn"
0000000000000000000000000000000000000000;;		LabelSelectorOpExists       LabelSelectorOperator = "Exists"
0000000000000000000000000000000000000000;;		LabelSelectorOpDoesNotExist LabelSelectorOperator = "DoesNotExist"
0000000000000000000000000000000000000000;;	)
