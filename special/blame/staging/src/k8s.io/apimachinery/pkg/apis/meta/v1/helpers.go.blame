0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/selection"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelSelectorAsSelector converts the LabelSelector api type into a struct that implements
0000000000000000000000000000000000000000;;	// labels.Selector
0000000000000000000000000000000000000000;;	// Note: This function should be kept in sync with the selector methods in pkg/labels/selector.go
0000000000000000000000000000000000000000;;	func LabelSelectorAsSelector(ps *LabelSelector) (labels.Selector, error) {
0000000000000000000000000000000000000000;;		if ps == nil {
0000000000000000000000000000000000000000;;			return labels.Nothing(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(ps.MatchLabels)+len(ps.MatchExpressions) == 0 {
0000000000000000000000000000000000000000;;			return labels.Everything(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selector := labels.NewSelector()
0000000000000000000000000000000000000000;;		for k, v := range ps.MatchLabels {
0000000000000000000000000000000000000000;;			r, err := labels.NewRequirement(k, selection.Equals, []string{v})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selector = selector.Add(*r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, expr := range ps.MatchExpressions {
0000000000000000000000000000000000000000;;			var op selection.Operator
0000000000000000000000000000000000000000;;			switch expr.Operator {
0000000000000000000000000000000000000000;;			case LabelSelectorOpIn:
0000000000000000000000000000000000000000;;				op = selection.In
0000000000000000000000000000000000000000;;			case LabelSelectorOpNotIn:
0000000000000000000000000000000000000000;;				op = selection.NotIn
0000000000000000000000000000000000000000;;			case LabelSelectorOpExists:
0000000000000000000000000000000000000000;;				op = selection.Exists
0000000000000000000000000000000000000000;;			case LabelSelectorOpDoesNotExist:
0000000000000000000000000000000000000000;;				op = selection.DoesNotExist
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("%q is not a valid pod selector operator", expr.Operator)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r, err := labels.NewRequirement(expr.Key, op, append([]string(nil), expr.Values...))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			selector = selector.Add(*r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selector, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LabelSelectorAsMap converts the LabelSelector api type into a map of strings, ie. the
0000000000000000000000000000000000000000;;	// original structure of a label selector. Operators that cannot be converted into plain
0000000000000000000000000000000000000000;;	// labels (Exists, DoesNotExist, NotIn, and In with more than one value) will result in
0000000000000000000000000000000000000000;;	// an error.
0000000000000000000000000000000000000000;;	func LabelSelectorAsMap(ps *LabelSelector) (map[string]string, error) {
0000000000000000000000000000000000000000;;		if ps == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		selector := map[string]string{}
0000000000000000000000000000000000000000;;		for k, v := range ps.MatchLabels {
0000000000000000000000000000000000000000;;			selector[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, expr := range ps.MatchExpressions {
0000000000000000000000000000000000000000;;			switch expr.Operator {
0000000000000000000000000000000000000000;;			case LabelSelectorOpIn:
0000000000000000000000000000000000000000;;				if len(expr.Values) != 1 {
0000000000000000000000000000000000000000;;					return selector, fmt.Errorf("operator %q without a single value cannot be converted into the old label selector format", expr.Operator)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Should we do anything in case this will override a previous key-value pair?
0000000000000000000000000000000000000000;;				selector[expr.Key] = expr.Values[0]
0000000000000000000000000000000000000000;;			case LabelSelectorOpNotIn, LabelSelectorOpExists, LabelSelectorOpDoesNotExist:
0000000000000000000000000000000000000000;;				return selector, fmt.Errorf("operator %q cannot be converted into the old label selector format", expr.Operator)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return selector, fmt.Errorf("%q is not a valid selector operator", expr.Operator)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return selector, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseToLabelSelector parses a string representing a selector into a LabelSelector object.
0000000000000000000000000000000000000000;;	// Note: This function should be kept in sync with the parser in pkg/labels/selector.go
0000000000000000000000000000000000000000;;	func ParseToLabelSelector(selector string) (*LabelSelector, error) {
0000000000000000000000000000000000000000;;		reqs, err := labels.ParseToRequirements(selector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("couldn't parse the selector string \"%s\": %v", selector, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelSelector := &LabelSelector{
0000000000000000000000000000000000000000;;			MatchLabels:      map[string]string{},
0000000000000000000000000000000000000000;;			MatchExpressions: []LabelSelectorRequirement{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, req := range reqs {
0000000000000000000000000000000000000000;;			var op LabelSelectorOperator
0000000000000000000000000000000000000000;;			switch req.Operator() {
0000000000000000000000000000000000000000;;			case selection.Equals, selection.DoubleEquals:
0000000000000000000000000000000000000000;;				vals := req.Values()
0000000000000000000000000000000000000000;;				if vals.Len() != 1 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("equals operator must have exactly one value")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				val, ok := vals.PopAny()
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("equals operator has exactly one value but it cannot be retrieved")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				labelSelector.MatchLabels[req.Key()] = val
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case selection.In:
0000000000000000000000000000000000000000;;				op = LabelSelectorOpIn
0000000000000000000000000000000000000000;;			case selection.NotIn:
0000000000000000000000000000000000000000;;				op = LabelSelectorOpNotIn
0000000000000000000000000000000000000000;;			case selection.Exists:
0000000000000000000000000000000000000000;;				op = LabelSelectorOpExists
0000000000000000000000000000000000000000;;			case selection.DoesNotExist:
0000000000000000000000000000000000000000;;				op = LabelSelectorOpDoesNotExist
0000000000000000000000000000000000000000;;			case selection.GreaterThan, selection.LessThan:
0000000000000000000000000000000000000000;;				// Adding a separate case for these operators to indicate that this is deliberate
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("%q isn't supported in label selectors", req.Operator())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("%q is not a valid label selector operator", req.Operator())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			labelSelector.MatchExpressions = append(labelSelector.MatchExpressions, LabelSelectorRequirement{
0000000000000000000000000000000000000000;;				Key:      req.Key(),
0000000000000000000000000000000000000000;;				Operator: op,
0000000000000000000000000000000000000000;;				Values:   req.Values().List(),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labelSelector, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetAsLabelSelector converts the labels.Set object into a LabelSelector api object.
0000000000000000000000000000000000000000;;	func SetAsLabelSelector(ls labels.Set) *LabelSelector {
0000000000000000000000000000000000000000;;		if ls == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selector := &LabelSelector{
0000000000000000000000000000000000000000;;			MatchLabels: make(map[string]string),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for label, value := range ls {
0000000000000000000000000000000000000000;;			selector.MatchLabels[label] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return selector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FormatLabelSelector convert labelSelector into plain string
0000000000000000000000000000000000000000;;	func FormatLabelSelector(labelSelector *LabelSelector) string {
0000000000000000000000000000000000000000;;		selector, err := LabelSelectorAsSelector(labelSelector)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "<error>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := selector.String()
0000000000000000000000000000000000000000;;		if len(l) == 0 {
0000000000000000000000000000000000000000;;			l = "<none>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ExtractGroupVersions(l *APIGroupList) []string {
0000000000000000000000000000000000000000;;		var groupVersions []string
0000000000000000000000000000000000000000;;		for _, g := range l.Groups {
0000000000000000000000000000000000000000;;			for _, gv := range g.Versions {
0000000000000000000000000000000000000000;;				groupVersions = append(groupVersions, gv.GroupVersion)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return groupVersions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasAnnotation returns a bool if passed in annotation exists
0000000000000000000000000000000000000000;;	func HasAnnotation(obj ObjectMeta, ann string) bool {
0000000000000000000000000000000000000000;;		_, found := obj.Annotations[ann]
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetMetaDataAnnotation sets the annotation and value
0000000000000000000000000000000000000000;;	func SetMetaDataAnnotation(obj *ObjectMeta, ann string, value string) {
0000000000000000000000000000000000000000;;		if obj.Annotations == nil {
0000000000000000000000000000000000000000;;			obj.Annotations = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj.Annotations[ann] = value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SingleObject returns a ListOptions for watching a single object.
0000000000000000000000000000000000000000;;	func SingleObject(meta ObjectMeta) ListOptions {
0000000000000000000000000000000000000000;;		return ListOptions{
0000000000000000000000000000000000000000;;			FieldSelector:   fields.OneTermEqualSelector("metadata.name", meta.Name).String(),
0000000000000000000000000000000000000000;;			ResourceVersion: meta.ResourceVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDeleteOptions returns a DeleteOptions indicating the resource should
0000000000000000000000000000000000000000;;	// be deleted within the specified grace period. Use zero to indicate
0000000000000000000000000000000000000000;;	// immediate deletion. If you would prefer to use the default grace period,
0000000000000000000000000000000000000000;;	// use &metav1.DeleteOptions{} directly.
0000000000000000000000000000000000000000;;	func NewDeleteOptions(grace int64) *DeleteOptions {
0000000000000000000000000000000000000000;;		return &DeleteOptions{GracePeriodSeconds: &grace}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPreconditionDeleteOptions returns a DeleteOptions with a UID precondition set.
0000000000000000000000000000000000000000;;	func NewPreconditionDeleteOptions(uid string) *DeleteOptions {
0000000000000000000000000000000000000000;;		u := types.UID(uid)
0000000000000000000000000000000000000000;;		p := Preconditions{UID: &u}
0000000000000000000000000000000000000000;;		return &DeleteOptions{Preconditions: &p}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUIDPreconditions returns a Preconditions with UID set.
0000000000000000000000000000000000000000;;	func NewUIDPreconditions(uid string) *Preconditions {
0000000000000000000000000000000000000000;;		u := types.UID(uid)
0000000000000000000000000000000000000000;;		return &Preconditions{UID: &u}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasObjectMetaSystemFieldValues returns true if fields that are managed by the system on ObjectMeta have values.
0000000000000000000000000000000000000000;;	func HasObjectMetaSystemFieldValues(meta Object) bool {
0000000000000000000000000000000000000000;;		return !meta.GetCreationTimestamp().Time.IsZero() ||
0000000000000000000000000000000000000000;;			len(meta.GetUID()) != 0
0000000000000000000000000000000000000000;;	}
