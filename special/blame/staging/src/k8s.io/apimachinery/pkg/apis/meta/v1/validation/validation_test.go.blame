0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
79cb5f148f9fbb125b5ed9b40f2a31f6f99e3405;pkg/api/unversioned/validation/validation_test.go[pkg/api/unversioned/validation/validation_test.go][staging/src/k8s.io/apimachinery/pkg/apis/meta/v1/validation/validation_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation/field"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestValidateLabels(t *testing.T) {
0000000000000000000000000000000000000000;;		successCases := []map[string]string{
0000000000000000000000000000000000000000;;			{"simple": "bar"},
0000000000000000000000000000000000000000;;			{"now-with-dashes": "bar"},
0000000000000000000000000000000000000000;;			{"1-starts-with-num": "bar"},
0000000000000000000000000000000000000000;;			{"1234": "bar"},
0000000000000000000000000000000000000000;;			{"simple/simple": "bar"},
0000000000000000000000000000000000000000;;			{"now-with-dashes/simple": "bar"},
0000000000000000000000000000000000000000;;			{"now-with-dashes/now-with-dashes": "bar"},
0000000000000000000000000000000000000000;;			{"now.with.dots/simple": "bar"},
0000000000000000000000000000000000000000;;			{"now-with.dashes-and.dots/simple": "bar"},
0000000000000000000000000000000000000000;;			{"1-num.2-num/3-num": "bar"},
0000000000000000000000000000000000000000;;			{"1234/5678": "bar"},
0000000000000000000000000000000000000000;;			{"1.2.3.4/5678": "bar"},
0000000000000000000000000000000000000000;;			{"UpperCaseAreOK123": "bar"},
0000000000000000000000000000000000000000;;			{"goodvalue": "123_-.BaR"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range successCases {
0000000000000000000000000000000000000000;;			errs := ValidateLabels(successCases[i], field.NewPath("field"))
0000000000000000000000000000000000000000;;			if len(errs) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d] expected success, got %#v", i, errs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namePartErrMsg := "name part must consist of"
0000000000000000000000000000000000000000;;		nameErrMsg := "a qualified name must consist of"
0000000000000000000000000000000000000000;;		labelErrMsg := "a valid label must be an empty string or consist of"
0000000000000000000000000000000000000000;;		maxLengthErrMsg := "must be no more than"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelNameErrorCases := []struct {
0000000000000000000000000000000000000000;;			labels map[string]string
0000000000000000000000000000000000000000;;			expect string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{map[string]string{"nospecialchars^=@": "bar"}, namePartErrMsg},
0000000000000000000000000000000000000000;;			{map[string]string{"cantendwithadash-": "bar"}, namePartErrMsg},
0000000000000000000000000000000000000000;;			{map[string]string{"only/one/slash": "bar"}, nameErrMsg},
0000000000000000000000000000000000000000;;			{map[string]string{strings.Repeat("a", 254): "bar"}, maxLengthErrMsg},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range labelNameErrorCases {
0000000000000000000000000000000000000000;;			errs := ValidateLabels(labelNameErrorCases[i].labels, field.NewPath("field"))
0000000000000000000000000000000000000000;;			if len(errs) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d]: expected failure", i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !strings.Contains(errs[0].Detail, labelNameErrorCases[i].expect) {
0000000000000000000000000000000000000000;;					t.Errorf("case[%d]: error details do not include %q: %q", i, labelNameErrorCases[i].expect, errs[0].Detail)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labelValueErrorCases := []struct {
0000000000000000000000000000000000000000;;			labels map[string]string
0000000000000000000000000000000000000000;;			expect string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{map[string]string{"toolongvalue": strings.Repeat("a", 64)}, maxLengthErrMsg},
0000000000000000000000000000000000000000;;			{map[string]string{"backslashesinvalue": "some\\bad\\value"}, labelErrMsg},
0000000000000000000000000000000000000000;;			{map[string]string{"nocommasallowed": "bad,value"}, labelErrMsg},
0000000000000000000000000000000000000000;;			{map[string]string{"strangecharsinvalue": "?#$notsogood"}, labelErrMsg},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range labelValueErrorCases {
0000000000000000000000000000000000000000;;			errs := ValidateLabels(labelValueErrorCases[i].labels, field.NewPath("field"))
0000000000000000000000000000000000000000;;			if len(errs) != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("case[%d]: expected failure", i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !strings.Contains(errs[0].Detail, labelValueErrorCases[i].expect) {
0000000000000000000000000000000000000000;;					t.Errorf("case[%d]: error details do not include %q: %q", i, labelValueErrorCases[i].expect, errs[0].Detail)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
