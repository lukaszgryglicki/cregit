0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
f05006577d95d7a7ecee895b6662439043a61f9d;;	
0000000000000000000000000000000000000000;;	// Package reflect is a fork of go's standard library reflection package, which
0000000000000000000000000000000000000000;;	// allows for deep equal with equality functions defined.
0000000000000000000000000000000000000000;;	package reflect
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equalities is a map from type to a function comparing two values of
0000000000000000000000000000000000000000;;	// that type.
0000000000000000000000000000000000000000;;	type Equalities map[reflect.Type]reflect.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For convenience, panics on errrors
0000000000000000000000000000000000000000;;	func EqualitiesOrDie(funcs ...interface{}) Equalities {
0000000000000000000000000000000000000000;;		e := Equalities{}
0000000000000000000000000000000000000000;;		if err := e.AddFuncs(funcs...); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFuncs is a shortcut for multiple calls to AddFunc.
0000000000000000000000000000000000000000;;	func (e Equalities) AddFuncs(funcs ...interface{}) error {
0000000000000000000000000000000000000000;;		for _, f := range funcs {
0000000000000000000000000000000000000000;;			if err := e.AddFunc(f); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFunc uses func as an equality function: it must take
0000000000000000000000000000000000000000;;	// two parameters of the same type, and return a boolean.
0000000000000000000000000000000000000000;;	func (e Equalities) AddFunc(eqFunc interface{}) error {
0000000000000000000000000000000000000000;;		fv := reflect.ValueOf(eqFunc)
0000000000000000000000000000000000000000;;		ft := fv.Type()
0000000000000000000000000000000000000000;;		if ft.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected func, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.NumIn() != 2 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected three 'in' params, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.NumOut() != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected one 'out' param, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ft.In(0) != ft.In(1) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected arg 1 and 2 to have same type, but got %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var forReturnType bool
0000000000000000000000000000000000000000;;		boolType := reflect.TypeOf(forReturnType)
0000000000000000000000000000000000000000;;		if ft.Out(0) != boolType {
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected bool return, got: %v", ft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e[ft.In(0)] = fv
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Below here is forked from go's reflect/deepequal.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// During deepValueEqual, must keep track of checks that are
0000000000000000000000000000000000000000;;	// in progress.  The comparison algorithm assumes that all
0000000000000000000000000000000000000000;;	// checks in progress are true when it reencounters them.
0000000000000000000000000000000000000000;;	// Visited comparisons are stored in a map indexed by visit.
0000000000000000000000000000000000000000;;	type visit struct {
0000000000000000000000000000000000000000;;		a1  uintptr
0000000000000000000000000000000000000000;;		a2  uintptr
0000000000000000000000000000000000000000;;		typ reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unexportedTypePanic is thrown when you use this DeepEqual on something that has an
0000000000000000000000000000000000000000;;	// unexported type. It indicates a programmer error, so should not occur at runtime,
0000000000000000000000000000000000000000;;	// which is why it's not public and thus impossible to catch.
0000000000000000000000000000000000000000;;	type unexportedTypePanic []reflect.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u unexportedTypePanic) Error() string { return u.String() }
0000000000000000000000000000000000000000;;	func (u unexportedTypePanic) String() string {
0000000000000000000000000000000000000000;;		strs := make([]string, len(u))
0000000000000000000000000000000000000000;;		for i, t := range u {
0000000000000000000000000000000000000000;;			strs[i] = fmt.Sprintf("%v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "an unexported field was encountered, nested like this: " + strings.Join(strs, " -> ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeUsefulPanic(v reflect.Value) {
0000000000000000000000000000000000000000;;		if x := recover(); x != nil {
0000000000000000000000000000000000000000;;			if u, ok := x.(unexportedTypePanic); ok {
0000000000000000000000000000000000000000;;				u = append(unexportedTypePanic{v.Type()}, u...)
0000000000000000000000000000000000000000;;				x = u
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			panic(x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests for deep equality using reflected types. The map argument tracks
0000000000000000000000000000000000000000;;	// comparisons that have already been seen, which allows short circuiting on
0000000000000000000000000000000000000000;;	// recursive types.
0000000000000000000000000000000000000000;;	func (e Equalities) deepValueEqual(v1, v2 reflect.Value, visited map[visit]bool, depth int) bool {
0000000000000000000000000000000000000000;;		defer makeUsefulPanic(v1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !v1.IsValid() || !v2.IsValid() {
0000000000000000000000000000000000000000;;			return v1.IsValid() == v2.IsValid()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v1.Type() != v2.Type() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fv, ok := e[v1.Type()]; ok {
0000000000000000000000000000000000000000;;			return fv.Call([]reflect.Value{v1, v2})[0].Bool()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hard := func(k reflect.Kind) bool {
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case reflect.Array, reflect.Map, reflect.Slice, reflect.Struct:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v1.CanAddr() && v2.CanAddr() && hard(v1.Kind()) {
0000000000000000000000000000000000000000;;			addr1 := v1.UnsafeAddr()
0000000000000000000000000000000000000000;;			addr2 := v2.UnsafeAddr()
0000000000000000000000000000000000000000;;			if addr1 > addr2 {
0000000000000000000000000000000000000000;;				// Canonicalize order to reduce number of entries in visited.
0000000000000000000000000000000000000000;;				addr1, addr2 = addr2, addr1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Short circuit if references are identical ...
0000000000000000000000000000000000000000;;			if addr1 == addr2 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ... or already seen
0000000000000000000000000000000000000000;;			typ := v1.Type()
0000000000000000000000000000000000000000;;			v := visit{addr1, addr2, typ}
0000000000000000000000000000000000000000;;			if visited[v] {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remember for later.
0000000000000000000000000000000000000000;;			visited[v] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch v1.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			// We don't need to check length here because length is part of
0000000000000000000000000000000000000000;;			// an array's type, which has already been filtered for.
0000000000000000000000000000000000000000;;			for i := 0; i < v1.Len(); i++ {
0000000000000000000000000000000000000000;;				if !e.deepValueEqual(v1.Index(i), v2.Index(i), visited, depth+1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if (v1.IsNil() || v1.Len() == 0) != (v2.IsNil() || v2.Len() == 0) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.IsNil() || v1.Len() == 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.Len() != v2.Len() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.Pointer() == v2.Pointer() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < v1.Len(); i++ {
0000000000000000000000000000000000000000;;				if !e.deepValueEqual(v1.Index(i), v2.Index(i), visited, depth+1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if v1.IsNil() || v2.IsNil() {
0000000000000000000000000000000000000000;;				return v1.IsNil() == v2.IsNil()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return e.deepValueEqual(v1.Elem(), v2.Elem(), visited, depth+1)
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			return e.deepValueEqual(v1.Elem(), v2.Elem(), visited, depth+1)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i, n := 0, v1.NumField(); i < n; i++ {
0000000000000000000000000000000000000000;;				if !e.deepValueEqual(v1.Field(i), v2.Field(i), visited, depth+1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if (v1.IsNil() || v1.Len() == 0) != (v2.IsNil() || v2.Len() == 0) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.IsNil() || v1.Len() == 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.Len() != v2.Len() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.Pointer() == v2.Pointer() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, k := range v1.MapKeys() {
0000000000000000000000000000000000000000;;				if !e.deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited, depth+1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Func:
0000000000000000000000000000000000000000;;			if v1.IsNil() && v2.IsNil() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Can't do better than this:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Normal equality suffices
0000000000000000000000000000000000000000;;			if !v1.CanInterface() || !v2.CanInterface() {
0000000000000000000000000000000000000000;;				panic(unexportedTypePanic{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return v1.Interface() == v2.Interface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeepEqual is like reflect.DeepEqual, but focused on semantic equality
0000000000000000000000000000000000000000;;	// instead of memory equality.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will use e's equality functions if it finds types that match.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An empty slice *is* equal to a nil slice for our purposes; same for maps.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unexported field members cannot be compared and will cause an imformative panic; you must add an Equality
0000000000000000000000000000000000000000;;	// function for these types.
0000000000000000000000000000000000000000;;	func (e Equalities) DeepEqual(a1, a2 interface{}) bool {
0000000000000000000000000000000000000000;;		if a1 == nil || a2 == nil {
0000000000000000000000000000000000000000;;			return a1 == a2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v1 := reflect.ValueOf(a1)
0000000000000000000000000000000000000000;;		v2 := reflect.ValueOf(a2)
0000000000000000000000000000000000000000;;		if v1.Type() != v2.Type() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.deepValueEqual(v1, v2, make(map[visit]bool), 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e Equalities) deepValueDerive(v1, v2 reflect.Value, visited map[visit]bool, depth int) bool {
0000000000000000000000000000000000000000;;		defer makeUsefulPanic(v1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !v1.IsValid() || !v2.IsValid() {
0000000000000000000000000000000000000000;;			return v1.IsValid() == v2.IsValid()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v1.Type() != v2.Type() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fv, ok := e[v1.Type()]; ok {
0000000000000000000000000000000000000000;;			return fv.Call([]reflect.Value{v1, v2})[0].Bool()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hard := func(k reflect.Kind) bool {
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case reflect.Array, reflect.Map, reflect.Slice, reflect.Struct:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v1.CanAddr() && v2.CanAddr() && hard(v1.Kind()) {
0000000000000000000000000000000000000000;;			addr1 := v1.UnsafeAddr()
0000000000000000000000000000000000000000;;			addr2 := v2.UnsafeAddr()
0000000000000000000000000000000000000000;;			if addr1 > addr2 {
0000000000000000000000000000000000000000;;				// Canonicalize order to reduce number of entries in visited.
0000000000000000000000000000000000000000;;				addr1, addr2 = addr2, addr1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Short circuit if references are identical ...
0000000000000000000000000000000000000000;;			if addr1 == addr2 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ... or already seen
0000000000000000000000000000000000000000;;			typ := v1.Type()
0000000000000000000000000000000000000000;;			v := visit{addr1, addr2, typ}
0000000000000000000000000000000000000000;;			if visited[v] {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remember for later.
0000000000000000000000000000000000000000;;			visited[v] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch v1.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			// We don't need to check length here because length is part of
0000000000000000000000000000000000000000;;			// an array's type, which has already been filtered for.
0000000000000000000000000000000000000000;;			for i := 0; i < v1.Len(); i++ {
0000000000000000000000000000000000000000;;				if !e.deepValueDerive(v1.Index(i), v2.Index(i), visited, depth+1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if v1.IsNil() || v1.Len() == 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.Len() > v2.Len() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.Pointer() == v2.Pointer() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < v1.Len(); i++ {
0000000000000000000000000000000000000000;;				if !e.deepValueDerive(v1.Index(i), v2.Index(i), visited, depth+1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			if v1.Len() == 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.Len() > v2.Len() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return v1.String() == v2.String()
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if v1.IsNil() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return e.deepValueDerive(v1.Elem(), v2.Elem(), visited, depth+1)
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if v1.IsNil() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return e.deepValueDerive(v1.Elem(), v2.Elem(), visited, depth+1)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i, n := 0, v1.NumField(); i < n; i++ {
0000000000000000000000000000000000000000;;				if !e.deepValueDerive(v1.Field(i), v2.Field(i), visited, depth+1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if v1.IsNil() || v1.Len() == 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.Len() > v2.Len() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v1.Pointer() == v2.Pointer() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, k := range v1.MapKeys() {
0000000000000000000000000000000000000000;;				if !e.deepValueDerive(v1.MapIndex(k), v2.MapIndex(k), visited, depth+1) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Func:
0000000000000000000000000000000000000000;;			if v1.IsNil() && v2.IsNil() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Can't do better than this:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Normal equality suffices
0000000000000000000000000000000000000000;;			if !v1.CanInterface() || !v2.CanInterface() {
0000000000000000000000000000000000000000;;				panic(unexportedTypePanic{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return v1.Interface() == v2.Interface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeepDerivative is similar to DeepEqual except that unset fields in a1 are
0000000000000000000000000000000000000000;;	// ignored (not compared). This allows us to focus on the fields that matter to
0000000000000000000000000000000000000000;;	// the semantic comparison.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The unset fields include a nil pointer and an empty string.
0000000000000000000000000000000000000000;;	func (e Equalities) DeepDerivative(a1, a2 interface{}) bool {
0000000000000000000000000000000000000000;;		if a1 == nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v1 := reflect.ValueOf(a1)
0000000000000000000000000000000000000000;;		v2 := reflect.ValueOf(a2)
0000000000000000000000000000000000000000;;		if v1.Type() != v2.Type() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.deepValueDerive(v1, v2, make(map[visit]bool), 0)
0000000000000000000000000000000000000000;;	}
