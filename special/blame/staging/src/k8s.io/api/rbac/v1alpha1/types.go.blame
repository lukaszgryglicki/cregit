0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
41d09af91494e0fe417fbc529b3fbc5cae0ac70f;pkg/apis/rbac/v1alpha1/types.go[pkg/apis/rbac/v1alpha1/types.go][staging/src/k8s.io/api/rbac/v1alpha1/types.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1alpha1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Authorization is calculated against
0000000000000000000000000000000000000000;;	// 1. evaluation of ClusterRoleBindings - short circuit on match
0000000000000000000000000000000000000000;;	// 2. evaluation of RoleBindings in the namespace requested - short circuit on match
0000000000000000000000000000000000000000;;	// 3. deny by default
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		APIGroupAll    = "*"
0000000000000000000000000000000000000000;;		ResourceAll    = "*"
0000000000000000000000000000000000000000;;		VerbAll        = "*"
0000000000000000000000000000000000000000;;		NonResourceAll = "*"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GroupKind          = "Group"
0000000000000000000000000000000000000000;;		ServiceAccountKind = "ServiceAccount"
0000000000000000000000000000000000000000;;		UserKind           = "User"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AutoUpdateAnnotationKey is the name of an annotation which prevents reconciliation if set to "false"
0000000000000000000000000000000000000000;;		AutoUpdateAnnotationKey = "rbac.authorization.kubernetes.io/autoupdate"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Authorization is calculated against
0000000000000000000000000000000000000000;;	// 1. evaluation of ClusterRoleBindings - short circuit on match
0000000000000000000000000000000000000000;;	// 2. evaluation of RoleBindings in the namespace requested - short circuit on match
0000000000000000000000000000000000000000;;	// 3. deny by default
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PolicyRule holds information that describes a policy rule, but does not contain information
0000000000000000000000000000000000000000;;	// about who the rule applies to or which namespace the rule applies to.
0000000000000000000000000000000000000000;;	type PolicyRule struct {
0000000000000000000000000000000000000000;;		// Verbs is a list of Verbs that apply to ALL the ResourceKinds and AttributeRestrictions contained in this rule.  VerbAll represents all kinds.
0000000000000000000000000000000000000000;;		Verbs []string `json:"verbs" protobuf:"bytes,1,rep,name=verbs"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// APIGroups is the name of the APIGroup that contains the resources.  If multiple API groups are specified, any action requested against one of
0000000000000000000000000000000000000000;;		// the enumerated resources in any API group will be allowed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		APIGroups []string `json:"apiGroups,omitempty" protobuf:"bytes,3,rep,name=apiGroups"`
0000000000000000000000000000000000000000;;		// Resources is a list of resources this rule applies to.  ResourceAll represents all resources.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Resources []string `json:"resources,omitempty" protobuf:"bytes,4,rep,name=resources"`
0000000000000000000000000000000000000000;;		// ResourceNames is an optional white list of names that the rule applies to.  An empty set means that everything is allowed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceNames []string `json:"resourceNames,omitempty" protobuf:"bytes,5,rep,name=resourceNames"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NonResourceURLs is a set of partial urls that a user should have access to.  *s are allowed, but only as the full, final step in the path
0000000000000000000000000000000000000000;;		// This name is intentionally different than the internal type so that the DefaultConvert works nicely and because the ordering may be different.
0000000000000000000000000000000000000000;;		// Since non-resource URLs are not namespaced, this field is only applicable for ClusterRoles referenced from a ClusterRoleBinding.
0000000000000000000000000000000000000000;;		// Rules can either apply to API resources (such as "pods" or "secrets") or non-resource URL paths (such as "/api"),  but not both.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NonResourceURLs []string `json:"nonResourceURLs,omitempty" protobuf:"bytes,6,rep,name=nonResourceURLs"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference,
0000000000000000000000000000000000000000;;	// or a value for non-objects such as user and group names.
0000000000000000000000000000000000000000;;	type Subject struct {
0000000000000000000000000000000000000000;;		// Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount".
0000000000000000000000000000000000000000;;		// If the Authorizer does not recognized the kind value, the Authorizer should report an error.
0000000000000000000000000000000000000000;;		Kind string `json:"kind" protobuf:"bytes,1,opt,name=kind"`
0000000000000000000000000000000000000000;;		// APIVersion holds the API group and version of the referenced subject.
0000000000000000000000000000000000000000;;		// Defaults to "v1" for ServiceAccount subjects.
0000000000000000000000000000000000000000;;		// Defaults to "rbac.authorization.k8s.io/v1alpha1" for User and Group subjects.
0000000000000000000000000000000000000000;;		// +k8s:conversion-gen=false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		APIVersion string `json:"apiVersion,omitempty" protobuf:"bytes,2,opt.name=apiVersion"`
0000000000000000000000000000000000000000;;		// Name of the object being referenced.
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,3,opt,name=name"`
0000000000000000000000000000000000000000;;		// Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty
0000000000000000000000000000000000000000;;		// the Authorizer should report an error.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Namespace string `json:"namespace,omitempty" protobuf:"bytes,4,opt,name=namespace"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoleRef contains information that points to the role being used
0000000000000000000000000000000000000000;;	type RoleRef struct {
0000000000000000000000000000000000000000;;		// APIGroup is the group for the resource being referenced
0000000000000000000000000000000000000000;;		APIGroup string `json:"apiGroup" protobuf:"bytes,1,opt,name=apiGroup"`
0000000000000000000000000000000000000000;;		// Kind is the type of resource being referenced
0000000000000000000000000000000000000000;;		Kind string `json:"kind" protobuf:"bytes,2,opt,name=kind"`
0000000000000000000000000000000000000000;;		// Name is the name of resource being referenced
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,3,opt,name=name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
0000000000000000000000000000000000000000;;	type Role struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rules holds all the PolicyRules for this Role
0000000000000000000000000000000000000000;;		Rules []PolicyRule `json:"rules" protobuf:"bytes,2,rep,name=rules"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace.
0000000000000000000000000000000000000000;;	// It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given
0000000000000000000000000000000000000000;;	// namespace only have effect in that namespace.
0000000000000000000000000000000000000000;;	type RoleBinding struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Subjects holds references to the objects the role applies to.
0000000000000000000000000000000000000000;;		Subjects []Subject `json:"subjects" protobuf:"bytes,2,rep,name=subjects"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace.
0000000000000000000000000000000000000000;;		// If the RoleRef cannot be resolved, the Authorizer must return an error.
0000000000000000000000000000000000000000;;		RoleRef RoleRef `json:"roleRef" protobuf:"bytes,3,opt,name=roleRef"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoleBindingList is a collection of RoleBindings
0000000000000000000000000000000000000000;;	type RoleBindingList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is a list of RoleBindings
0000000000000000000000000000000000000000;;		Items []RoleBinding `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoleList is a collection of Roles
0000000000000000000000000000000000000000;;	type RoleList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is a list of Roles
0000000000000000000000000000000000000000;;		Items []Role `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
0000000000000000000000000000000000000000;;	type ClusterRole struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rules holds all the PolicyRules for this ClusterRole
0000000000000000000000000000000000000000;;		Rules []PolicyRule `json:"rules" protobuf:"bytes,2,rep,name=rules"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace,
0000000000000000000000000000000000000000;;	// and adds who information via Subject.
0000000000000000000000000000000000000000;;	type ClusterRoleBinding struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Subjects holds references to the objects the role applies to.
0000000000000000000000000000000000000000;;		Subjects []Subject `json:"subjects" protobuf:"bytes,2,rep,name=subjects"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RoleRef can only reference a ClusterRole in the global namespace.
0000000000000000000000000000000000000000;;		// If the RoleRef cannot be resolved, the Authorizer must return an error.
0000000000000000000000000000000000000000;;		RoleRef RoleRef `json:"roleRef" protobuf:"bytes,3,opt,name=roleRef"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRoleBindingList is a collection of ClusterRoleBindings
0000000000000000000000000000000000000000;;	type ClusterRoleBindingList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is a list of ClusterRoleBindings
0000000000000000000000000000000000000000;;		Items []ClusterRoleBinding `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClusterRoleList is a collection of ClusterRoles
0000000000000000000000000000000000000000;;	type ClusterRoleList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is a list of ClusterRoles
0000000000000000000000000000000000000000;;		Items []ClusterRole `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
