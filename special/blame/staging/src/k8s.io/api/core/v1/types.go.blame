0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
a0a6ff3e50600118609309ad715f48c98e5c6c73;pkg/api/v1/types.go[pkg/api/v1/types.go][staging/src/k8s.io/api/core/v1/types.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/resource"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The comments for the structs and fields can be used from go-restful to
0000000000000000000000000000000000000000;;	// generate Swagger API documentation for its models. Please read this PR for more
0000000000000000000000000000000000000000;;	// information on the implementation: https://github.com/emicklei/go-restful/pull/215
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODOs are ignored from the parser (e.g. TODO(andronat):... || TODO:...) if and only if
0000000000000000000000000000000000000000;;	// they are on one line! For multiple line or blocks that you want to ignore use ---.
0000000000000000000000000000000000000000;;	// Any context after a --- is ignored and not exported to the SwaggerAPI.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The aforementioned methods can be generated by hack/update-generated-swagger-docs.sh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Common string formats
0000000000000000000000000000000000000000;;	// ---------------------
0000000000000000000000000000000000000000;;	// Many fields in this API have formatting requirements. The commonly used
0000000000000000000000000000000000000000;;	// formats are defined here.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// C_IDENTIFIER:  This is a string that conforms to the definition of an "identifier"
0000000000000000000000000000000000000000;;	//     in the C language. This is captured by the following regex:
0000000000000000000000000000000000000000;;	//         [A-Za-z_][A-Za-z0-9_]*
0000000000000000000000000000000000000000;;	//     This defines the format, but not the length restriction, which should be
0000000000000000000000000000000000000000;;	//     specified at the definition of any field of this type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// DNS_LABEL:  This is a string, no more than 63 characters long, that conforms
0000000000000000000000000000000000000000;;	//     to the definition of a "label" in RFCs 1035 and 1123. This is captured
0000000000000000000000000000000000000000;;	//     by the following regex:
0000000000000000000000000000000000000000;;	//         [a-z0-9]([-a-z0-9]*[a-z0-9])?
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// DNS_SUBDOMAIN:  This is a string, no more than 253 characters long, that conforms
0000000000000000000000000000000000000000;;	//      to the definition of a "subdomain" in RFCs 1035 and 1123. This is captured
0000000000000000000000000000000000000000;;	//      by the following regex:
0000000000000000000000000000000000000000;;	//         [a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*
0000000000000000000000000000000000000000;;	//     or more simply:
0000000000000000000000000000000000000000;;	//         DNS_LABEL(\.DNS_LABEL)*
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// IANA_SVC_NAME: This is a string, no more than 15 characters long, that
0000000000000000000000000000000000000000;;	//      conforms to the definition of IANA service name in RFC 6335.
0000000000000000000000000000000000000000;;	//      It must contains at least one letter [a-z] and it must contains only [a-z0-9-].
0000000000000000000000000000000000000000;;	//      Hypens ('-') cannot be leading or trailing character of the string
0000000000000000000000000000000000000000;;	//      and cannot be adjacent to other hyphens.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectMeta is metadata that all persisted resources must have, which includes all objects
0000000000000000000000000000000000000000;;	// users must create.
0000000000000000000000000000000000000000;;	// DEPRECATED: Use k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta instead - this type will be removed soon.
0000000000000000000000000000000000000000;;	// +k8s:openapi-gen=false
0000000000000000000000000000000000000000;;	type ObjectMeta struct {
0000000000000000000000000000000000000000;;		// Name must be unique within a namespace. Is required when creating resources, although
0000000000000000000000000000000000000000;;		// some resources may allow a client to request the generation of an appropriate name
0000000000000000000000000000000000000000;;		// automatically. Name is primarily intended for creation idempotence and configuration
0000000000000000000000000000000000000000;;		// definition.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GenerateName is an optional prefix, used by the server, to generate a unique
0000000000000000000000000000000000000000;;		// name ONLY IF the Name field has not been provided.
0000000000000000000000000000000000000000;;		// If this field is used, the name returned to the client will be different
0000000000000000000000000000000000000000;;		// than the name passed. This value will also be combined with a unique suffix.
0000000000000000000000000000000000000000;;		// The provided value has the same validation rules as the Name field,
0000000000000000000000000000000000000000;;		// and may be truncated by the length of the suffix required to make the value
0000000000000000000000000000000000000000;;		// unique on the server.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If this field is specified and the generated name exists, the server will
0000000000000000000000000000000000000000;;		// NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
0000000000000000000000000000000000000000;;		// ServerTimeout indicating a unique name could not be found in the time allotted, and the client
0000000000000000000000000000000000000000;;		// should retry (optionally after the time indicated in the Retry-After header).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Applied only if Name is not specified.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GenerateName string `json:"generateName,omitempty" protobuf:"bytes,2,opt,name=generateName"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Namespace defines the space within each name must be unique. An empty namespace is
0000000000000000000000000000000000000000;;		// equivalent to the "default" namespace, but "default" is the canonical representation.
0000000000000000000000000000000000000000;;		// Not all objects are required to be scoped to a namespace - the value of this field for
0000000000000000000000000000000000000000;;		// those objects will be empty.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Must be a DNS_LABEL.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Namespace string `json:"namespace,omitempty" protobuf:"bytes,3,opt,name=namespace"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SelfLink is a URL representing this object.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SelfLink string `json:"selfLink,omitempty" protobuf:"bytes,4,opt,name=selfLink"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UID is the unique in time and space value for this object. It is typically generated by
0000000000000000000000000000000000000000;;		// the server on successful creation of a resource and is not allowed to change on PUT
0000000000000000000000000000000000000000;;		// operations.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UID types.UID `json:"uid,omitempty" protobuf:"bytes,5,opt,name=uid,casttype=k8s.io/apimachinery/pkg/types.UID"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An opaque value that represents the internal version of this object that can
0000000000000000000000000000000000000000;;		// be used by clients to determine when objects have changed. May be used for optimistic
0000000000000000000000000000000000000000;;		// concurrency, change detection, and the watch operation on a resource or set of resources.
0000000000000000000000000000000000000000;;		// Clients must treat these values as opaque and passed unmodified back to the server.
0000000000000000000000000000000000000000;;		// They may only be valid for a particular resource or set of resources.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// Value must be treated as opaque by clients and .
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,6,opt,name=resourceVersion"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A sequence number representing a specific generation of the desired state.
0000000000000000000000000000000000000000;;		// Populated by the system. Read-only.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Generation int64 `json:"generation,omitempty" protobuf:"varint,7,opt,name=generation"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CreationTimestamp is a timestamp representing the server time when this object was
0000000000000000000000000000000000000000;;		// created. It is not guaranteed to be set in happens-before order across separate operations.
0000000000000000000000000000000000000000;;		// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// Null for lists.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CreationTimestamp metav1.Time `json:"creationTimestamp,omitempty" protobuf:"bytes,8,opt,name=creationTimestamp"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
0000000000000000000000000000000000000000;;		// field is set by the server when a graceful deletion is requested by the user, and is not
0000000000000000000000000000000000000000;;		// directly settable by a client. The resource is expected to be deleted (no longer visible
0000000000000000000000000000000000000000;;		// from resource lists, and not reachable by name) after the time in this field. Once set,
0000000000000000000000000000000000000000;;		// this value may not be unset or be set further into the future, although it may be shortened
0000000000000000000000000000000000000000;;		// or the resource may be deleted prior to this time. For example, a user may request that
0000000000000000000000000000000000000000;;		// a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination
0000000000000000000000000000000000000000;;		// signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard
0000000000000000000000000000000000000000;;		// termination signal (SIGKILL) to the container and after cleanup, remove the pod from the
0000000000000000000000000000000000000000;;		// API. In the presence of network partitions, this object may still exist after this
0000000000000000000000000000000000000000;;		// timestamp, until an administrator or automated process can determine the resource is
0000000000000000000000000000000000000000;;		// fully terminated.
0000000000000000000000000000000000000000;;		// If not set, graceful deletion of the object has not been requested.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Populated by the system when a graceful deletion is requested.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DeletionTimestamp *metav1.Time `json:"deletionTimestamp,omitempty" protobuf:"bytes,9,opt,name=deletionTimestamp"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of seconds allowed for this object to gracefully terminate before
0000000000000000000000000000000000000000;;		// it will be removed from the system. Only set when deletionTimestamp is also set.
0000000000000000000000000000000000000000;;		// May only be shortened.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DeletionGracePeriodSeconds *int64 `json:"deletionGracePeriodSeconds,omitempty" protobuf:"varint,10,opt,name=deletionGracePeriodSeconds"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map of string keys and values that can be used to organize and categorize
0000000000000000000000000000000000000000;;		// (scope and select) objects. May match selectors of replication controllers
0000000000000000000000000000000000000000;;		// and services.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Labels map[string]string `json:"labels,omitempty" protobuf:"bytes,11,rep,name=labels"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Annotations is an unstructured key value map stored with a resource that may be
0000000000000000000000000000000000000000;;		// set by external tools to store and retrieve arbitrary metadata. They are not
0000000000000000000000000000000000000000;;		// queryable and should be preserved when modifying objects.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Annotations map[string]string `json:"annotations,omitempty" protobuf:"bytes,12,rep,name=annotations"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of objects depended by this object. If ALL objects in the list have
0000000000000000000000000000000000000000;;		// been deleted, this object will be garbage collected. If this object is managed by a controller,
0000000000000000000000000000000000000000;;		// then an entry in this list will point to this controller, with the controller field set to true.
0000000000000000000000000000000000000000;;		// There cannot be more than one managing controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=uid
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		OwnerReferences []metav1.OwnerReference `json:"ownerReferences,omitempty" patchStrategy:"merge" patchMergeKey:"uid" protobuf:"bytes,13,rep,name=ownerReferences"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An initializer is a controller which enforces some system invariant at object creation time.
0000000000000000000000000000000000000000;;		// This field is a list of initializers that have not yet acted on this object. If nil or empty,
0000000000000000000000000000000000000000;;		// this object has been completely initialized. Otherwise, the object is considered uninitialized
0000000000000000000000000000000000000000;;		// and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to
0000000000000000000000000000000000000000;;		// observe uninitialized objects.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// When an object is created, the system will populate this list with the current set of initializers.
0000000000000000000000000000000000000000;;		// Only privileged users may set or modify this list. Once it is empty, it may not be modified further
0000000000000000000000000000000000000000;;		// by any user.
0000000000000000000000000000000000000000;;		Initializers *metav1.Initializers `json:"initializers,omitempty" patchStrategy:"merge" protobuf:"bytes,16,rep,name=initializers"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Must be empty before the object is deleted from the registry. Each entry
0000000000000000000000000000000000000000;;		// is an identifier for the responsible component that will remove the entry
0000000000000000000000000000000000000000;;		// from the list. If the deletionTimestamp of the object is non-nil, entries
0000000000000000000000000000000000000000;;		// in this list can only be removed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Finalizers []string `json:"finalizers,omitempty" patchStrategy:"merge" protobuf:"bytes,14,rep,name=finalizers"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The name of the cluster which the object belongs to.
0000000000000000000000000000000000000000;;		// This is used to distinguish resources with same name and namespace in different clusters.
0000000000000000000000000000000000000000;;		// This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ClusterName string `json:"clusterName,omitempty" protobuf:"bytes,15,opt,name=clusterName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NamespaceDefault means the object is in the default namespace which is applied when not specified by clients
0000000000000000000000000000000000000000;;		NamespaceDefault string = "default"
0000000000000000000000000000000000000000;;		// NamespaceAll is the default argument to specify on a context when you want to list or filter resources across all namespaces
0000000000000000000000000000000000000000;;		NamespaceAll string = ""
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Volume represents a named volume in a pod that may be accessed by any container in the pod.
0000000000000000000000000000000000000000;;	type Volume struct {
0000000000000000000000000000000000000000;;		// Volume's name.
0000000000000000000000000000000000000000;;		// Must be a DNS_LABEL and unique within the pod.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// VolumeSource represents the location and type of the mounted volume.
0000000000000000000000000000000000000000;;		// If not specified, the Volume is implied to be an EmptyDir.
0000000000000000000000000000000000000000;;		// This implied behavior is deprecated and will be removed in a future version.
0000000000000000000000000000000000000000;;		VolumeSource `json:",inline" protobuf:"bytes,2,opt,name=volumeSource"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents the source of a volume to mount.
0000000000000000000000000000000000000000;;	// Only one of its members may be specified.
0000000000000000000000000000000000000000;;	type VolumeSource struct {
0000000000000000000000000000000000000000;;		// HostPath represents a pre-existing file or directory on the host
0000000000000000000000000000000000000000;;		// machine that is directly exposed to the container. This is generally
0000000000000000000000000000000000000000;;		// used for system agents or other privileged things that are allowed
0000000000000000000000000000000000000000;;		// to see the host machine. Most containers will NOT need this.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
0000000000000000000000000000000000000000;;		// ---
0000000000000000000000000000000000000000;;		// TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
0000000000000000000000000000000000000000;;		// mount host directories as read/write.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostPath *HostPathVolumeSource `json:"hostPath,omitempty" protobuf:"bytes,1,opt,name=hostPath"`
0000000000000000000000000000000000000000;;		// EmptyDir represents a temporary directory that shares a pod's lifetime.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		EmptyDir *EmptyDirVolumeSource `json:"emptyDir,omitempty" protobuf:"bytes,2,opt,name=emptyDir"`
0000000000000000000000000000000000000000;;		// GCEPersistentDisk represents a GCE Disk resource that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GCEPersistentDisk *GCEPersistentDiskVolumeSource `json:"gcePersistentDisk,omitempty" protobuf:"bytes,3,opt,name=gcePersistentDisk"`
0000000000000000000000000000000000000000;;		// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AWSElasticBlockStore *AWSElasticBlockStoreVolumeSource `json:"awsElasticBlockStore,omitempty" protobuf:"bytes,4,opt,name=awsElasticBlockStore"`
0000000000000000000000000000000000000000;;		// GitRepo represents a git repository at a particular revision.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GitRepo *GitRepoVolumeSource `json:"gitRepo,omitempty" protobuf:"bytes,5,opt,name=gitRepo"`
0000000000000000000000000000000000000000;;		// Secret represents a secret that should populate this volume.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Secret *SecretVolumeSource `json:"secret,omitempty" protobuf:"bytes,6,opt,name=secret"`
0000000000000000000000000000000000000000;;		// NFS represents an NFS mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NFS *NFSVolumeSource `json:"nfs,omitempty" protobuf:"bytes,7,opt,name=nfs"`
0000000000000000000000000000000000000000;;		// ISCSI represents an ISCSI Disk resource that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/iscsi/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ISCSI *ISCSIVolumeSource `json:"iscsi,omitempty" protobuf:"bytes,8,opt,name=iscsi"`
0000000000000000000000000000000000000000;;		// Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Glusterfs *GlusterfsVolumeSource `json:"glusterfs,omitempty" protobuf:"bytes,9,opt,name=glusterfs"`
0000000000000000000000000000000000000000;;		// PersistentVolumeClaimVolumeSource represents a reference to a
0000000000000000000000000000000000000000;;		// PersistentVolumeClaim in the same namespace.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PersistentVolumeClaim *PersistentVolumeClaimVolumeSource `json:"persistentVolumeClaim,omitempty" protobuf:"bytes,10,opt,name=persistentVolumeClaim"`
0000000000000000000000000000000000000000;;		// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RBD *RBDVolumeSource `json:"rbd,omitempty" protobuf:"bytes,11,opt,name=rbd"`
0000000000000000000000000000000000000000;;		// FlexVolume represents a generic volume resource that is
0000000000000000000000000000000000000000;;		// provisioned/attached using an exec based plugin. This is an
0000000000000000000000000000000000000000;;		// alpha feature and may change in future.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FlexVolume *FlexVolumeSource `json:"flexVolume,omitempty" protobuf:"bytes,12,opt,name=flexVolume"`
0000000000000000000000000000000000000000;;		// Cinder represents a cinder volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Cinder *CinderVolumeSource `json:"cinder,omitempty" protobuf:"bytes,13,opt,name=cinder"`
0000000000000000000000000000000000000000;;		// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CephFS *CephFSVolumeSource `json:"cephfs,omitempty" protobuf:"bytes,14,opt,name=cephfs"`
0000000000000000000000000000000000000000;;		// Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Flocker *FlockerVolumeSource `json:"flocker,omitempty" protobuf:"bytes,15,opt,name=flocker"`
0000000000000000000000000000000000000000;;		// DownwardAPI represents downward API about the pod that should populate this volume
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DownwardAPI *DownwardAPIVolumeSource `json:"downwardAPI,omitempty" protobuf:"bytes,16,opt,name=downwardAPI"`
0000000000000000000000000000000000000000;;		// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FC *FCVolumeSource `json:"fc,omitempty" protobuf:"bytes,17,opt,name=fc"`
0000000000000000000000000000000000000000;;		// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AzureFile *AzureFileVolumeSource `json:"azureFile,omitempty" protobuf:"bytes,18,opt,name=azureFile"`
0000000000000000000000000000000000000000;;		// ConfigMap represents a configMap that should populate this volume
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ConfigMap *ConfigMapVolumeSource `json:"configMap,omitempty" protobuf:"bytes,19,opt,name=configMap"`
0000000000000000000000000000000000000000;;		// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VsphereVolume *VsphereVirtualDiskVolumeSource `json:"vsphereVolume,omitempty" protobuf:"bytes,20,opt,name=vsphereVolume"`
0000000000000000000000000000000000000000;;		// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Quobyte *QuobyteVolumeSource `json:"quobyte,omitempty" protobuf:"bytes,21,opt,name=quobyte"`
0000000000000000000000000000000000000000;;		// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AzureDisk *AzureDiskVolumeSource `json:"azureDisk,omitempty" protobuf:"bytes,22,opt,name=azureDisk"`
0000000000000000000000000000000000000000;;		// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		PhotonPersistentDisk *PhotonPersistentDiskVolumeSource `json:"photonPersistentDisk,omitempty" protobuf:"bytes,23,opt,name=photonPersistentDisk"`
0000000000000000000000000000000000000000;;		// Items for all in one resources secrets, configmaps, and downward API
0000000000000000000000000000000000000000;;		Projected *ProjectedVolumeSource `json:"projected,omitempty" protobuf:"bytes,26,opt,name=projected"`
0000000000000000000000000000000000000000;;		// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PortworxVolume *PortworxVolumeSource `json:"portworxVolume,omitempty" protobuf:"bytes,24,opt,name=portworxVolume"`
0000000000000000000000000000000000000000;;		// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ScaleIO *ScaleIOVolumeSource `json:"scaleIO,omitempty" protobuf:"bytes,25,opt,name=scaleIO"`
0000000000000000000000000000000000000000;;		// StorageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StorageOS *StorageOSVolumeSource `json:"storageos,omitempty" protobuf:"bytes,27,opt,name=storageos"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
0000000000000000000000000000000000000000;;	// This volume finds the bound PV and mounts that volume for the pod. A
0000000000000000000000000000000000000000;;	// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
0000000000000000000000000000000000000000;;	// type of volume that is owned by someone else (the system).
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimVolumeSource struct {
0000000000000000000000000000000000000000;;		// ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
0000000000000000000000000000000000000000;;		ClaimName string `json:"claimName" protobuf:"bytes,1,opt,name=claimName"`
0000000000000000000000000000000000000000;;		// Will force the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// Default false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,2,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeSource is similar to VolumeSource but meant for the
0000000000000000000000000000000000000000;;	// administrator who creates PVs. Exactly one of its members must be set.
0000000000000000000000000000000000000000;;	type PersistentVolumeSource struct {
0000000000000000000000000000000000000000;;		// GCEPersistentDisk represents a GCE Disk resource that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GCEPersistentDisk *GCEPersistentDiskVolumeSource `json:"gcePersistentDisk,omitempty" protobuf:"bytes,1,opt,name=gcePersistentDisk"`
0000000000000000000000000000000000000000;;		// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AWSElasticBlockStore *AWSElasticBlockStoreVolumeSource `json:"awsElasticBlockStore,omitempty" protobuf:"bytes,2,opt,name=awsElasticBlockStore"`
0000000000000000000000000000000000000000;;		// HostPath represents a directory on the host.
0000000000000000000000000000000000000000;;		// Provisioned by a developer or tester.
0000000000000000000000000000000000000000;;		// This is useful for single-node development and testing only!
0000000000000000000000000000000000000000;;		// On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostPath *HostPathVolumeSource `json:"hostPath,omitempty" protobuf:"bytes,3,opt,name=hostPath"`
0000000000000000000000000000000000000000;;		// Glusterfs represents a Glusterfs volume that is attached to a host and
0000000000000000000000000000000000000000;;		// exposed to the pod. Provisioned by an admin.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Glusterfs *GlusterfsVolumeSource `json:"glusterfs,omitempty" protobuf:"bytes,4,opt,name=glusterfs"`
0000000000000000000000000000000000000000;;		// NFS represents an NFS mount on the host. Provisioned by an admin.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NFS *NFSVolumeSource `json:"nfs,omitempty" protobuf:"bytes,5,opt,name=nfs"`
0000000000000000000000000000000000000000;;		// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RBD *RBDVolumeSource `json:"rbd,omitempty" protobuf:"bytes,6,opt,name=rbd"`
0000000000000000000000000000000000000000;;		// ISCSI represents an ISCSI Disk resource that is attached to a
0000000000000000000000000000000000000000;;		// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ISCSI *ISCSIVolumeSource `json:"iscsi,omitempty" protobuf:"bytes,7,opt,name=iscsi"`
0000000000000000000000000000000000000000;;		// Cinder represents a cinder volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Cinder *CinderVolumeSource `json:"cinder,omitempty" protobuf:"bytes,8,opt,name=cinder"`
0000000000000000000000000000000000000000;;		// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CephFS *CephFSVolumeSource `json:"cephfs,omitempty" protobuf:"bytes,9,opt,name=cephfs"`
0000000000000000000000000000000000000000;;		// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FC *FCVolumeSource `json:"fc,omitempty" protobuf:"bytes,10,opt,name=fc"`
0000000000000000000000000000000000000000;;		// Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Flocker *FlockerVolumeSource `json:"flocker,omitempty" protobuf:"bytes,11,opt,name=flocker"`
0000000000000000000000000000000000000000;;		// FlexVolume represents a generic volume resource that is
0000000000000000000000000000000000000000;;		// provisioned/attached using an exec based plugin. This is an
0000000000000000000000000000000000000000;;		// alpha feature and may change in future.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FlexVolume *FlexVolumeSource `json:"flexVolume,omitempty" protobuf:"bytes,12,opt,name=flexVolume"`
0000000000000000000000000000000000000000;;		// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AzureFile *AzureFileVolumeSource `json:"azureFile,omitempty" protobuf:"bytes,13,opt,name=azureFile"`
0000000000000000000000000000000000000000;;		// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VsphereVolume *VsphereVirtualDiskVolumeSource `json:"vsphereVolume,omitempty" protobuf:"bytes,14,opt,name=vsphereVolume"`
0000000000000000000000000000000000000000;;		// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Quobyte *QuobyteVolumeSource `json:"quobyte,omitempty" protobuf:"bytes,15,opt,name=quobyte"`
0000000000000000000000000000000000000000;;		// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AzureDisk *AzureDiskVolumeSource `json:"azureDisk,omitempty" protobuf:"bytes,16,opt,name=azureDisk"`
0000000000000000000000000000000000000000;;		// PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		PhotonPersistentDisk *PhotonPersistentDiskVolumeSource `json:"photonPersistentDisk,omitempty" protobuf:"bytes,17,opt,name=photonPersistentDisk"`
0000000000000000000000000000000000000000;;		// PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PortworxVolume *PortworxVolumeSource `json:"portworxVolume,omitempty" protobuf:"bytes,18,opt,name=portworxVolume"`
0000000000000000000000000000000000000000;;		// ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ScaleIO *ScaleIOVolumeSource `json:"scaleIO,omitempty" protobuf:"bytes,19,opt,name=scaleIO"`
0000000000000000000000000000000000000000;;		// Local represents directly-attached storage with node affinity
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Local *LocalVolumeSource `json:"local,omitempty" protobuf:"bytes,20,opt,name=local"`
0000000000000000000000000000000000000000;;		// StorageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/storageos/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StorageOS *StorageOSPersistentVolumeSource `json:"storageos,omitempty" protobuf:"bytes,21,opt,name=storageos"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// BetaStorageClassAnnotation represents the beta/previous StorageClass annotation.
0000000000000000000000000000000000000000;;		// It's currently still used and will be held for backwards compatibility
0000000000000000000000000000000000000000;;		BetaStorageClassAnnotation = "volume.beta.kubernetes.io/storage-class"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MountOptionAnnotation defines mount option annotation used in PVs
0000000000000000000000000000000000000000;;		MountOptionAnnotation = "volume.beta.kubernetes.io/mount-options"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AlphaStorageNodeAffinityAnnotation defines node affinity policies for a PersistentVolume.
0000000000000000000000000000000000000000;;		// Value is a string of the json representation of type NodeAffinity
0000000000000000000000000000000000000000;;		AlphaStorageNodeAffinityAnnotation = "volume.alpha.kubernetes.io/node-affinity"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolume (PV) is a storage resource provisioned by an administrator.
0000000000000000000000000000000000000000;;	// It is analogous to a node.
0000000000000000000000000000000000000000;;	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
0000000000000000000000000000000000000000;;	type PersistentVolume struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines a specification of a persistent volume owned by the cluster.
0000000000000000000000000000000000000000;;		// Provisioned by an administrator.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec PersistentVolumeSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status represents the current information/status for the persistent volume.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status PersistentVolumeStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeSpec is the specification of a persistent volume.
0000000000000000000000000000000000000000;;	type PersistentVolumeSpec struct {
0000000000000000000000000000000000000000;;		// A description of the persistent volume's resources and capacity.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Capacity ResourceList `json:"capacity,omitempty" protobuf:"bytes,1,rep,name=capacity,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;		// The actual volume backing the persistent volume.
0000000000000000000000000000000000000000;;		PersistentVolumeSource `json:",inline" protobuf:"bytes,2,opt,name=persistentVolumeSource"`
0000000000000000000000000000000000000000;;		// AccessModes contains all ways the volume can be mounted.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AccessModes []PersistentVolumeAccessMode `json:"accessModes,omitempty" protobuf:"bytes,3,rep,name=accessModes,casttype=PersistentVolumeAccessMode"`
0000000000000000000000000000000000000000;;		// ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
0000000000000000000000000000000000000000;;		// Expected to be non-nil when bound.
0000000000000000000000000000000000000000;;		// claim.VolumeName is the authoritative bind between PV and PVC.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ClaimRef *ObjectReference `json:"claimRef,omitempty" protobuf:"bytes,4,opt,name=claimRef"`
0000000000000000000000000000000000000000;;		// What happens to a persistent volume when released from its claim.
0000000000000000000000000000000000000000;;		// Valid options are Retain (default) and Recycle.
0000000000000000000000000000000000000000;;		// Recycling must be supported by the volume plugin underlying this persistent volume.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PersistentVolumeReclaimPolicy PersistentVolumeReclaimPolicy `json:"persistentVolumeReclaimPolicy,omitempty" protobuf:"bytes,5,opt,name=persistentVolumeReclaimPolicy,casttype=PersistentVolumeReclaimPolicy"`
0000000000000000000000000000000000000000;;		// Name of StorageClass to which this persistent volume belongs. Empty value
0000000000000000000000000000000000000000;;		// means that this volume does not belong to any StorageClass.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StorageClassName string `json:"storageClassName,omitempty" protobuf:"bytes,6,opt,name=storageClassName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeReclaimPolicy describes a policy for end-of-life maintenance of persistent volumes.
0000000000000000000000000000000000000000;;	type PersistentVolumeReclaimPolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PersistentVolumeReclaimRecycle means the volume will be recycled back into the pool of unbound persistent volumes on release from its claim.
0000000000000000000000000000000000000000;;		// The volume plugin must support Recycling.
0000000000000000000000000000000000000000;;		PersistentVolumeReclaimRecycle PersistentVolumeReclaimPolicy = "Recycle"
0000000000000000000000000000000000000000;;		// PersistentVolumeReclaimDelete means the volume will be deleted from Kubernetes on release from its claim.
0000000000000000000000000000000000000000;;		// The volume plugin must support Deletion.
0000000000000000000000000000000000000000;;		PersistentVolumeReclaimDelete PersistentVolumeReclaimPolicy = "Delete"
0000000000000000000000000000000000000000;;		// PersistentVolumeReclaimRetain means the volume will be left in its current phase (Released) for manual reclamation by the administrator.
0000000000000000000000000000000000000000;;		// The default policy is Retain.
0000000000000000000000000000000000000000;;		PersistentVolumeReclaimRetain PersistentVolumeReclaimPolicy = "Retain"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeStatus is the current status of a persistent volume.
0000000000000000000000000000000000000000;;	type PersistentVolumeStatus struct {
0000000000000000000000000000000000000000;;		// Phase indicates if a volume is available, bound to a claim, or released by a claim.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Phase PersistentVolumePhase `json:"phase,omitempty" protobuf:"bytes,1,opt,name=phase,casttype=PersistentVolumePhase"`
0000000000000000000000000000000000000000;;		// A human-readable message indicating details about why the volume is in this state.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,2,opt,name=message"`
0000000000000000000000000000000000000000;;		// Reason is a brief CamelCase string that describes any failure and is meant
0000000000000000000000000000000000000000;;		// for machine parsing and tidy display in the CLI.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string `json:"reason,omitempty" protobuf:"bytes,3,opt,name=reason"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeList is a list of PersistentVolume items.
0000000000000000000000000000000000000000;;	type PersistentVolumeList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;		// List of persistent volumes.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
0000000000000000000000000000000000000000;;		Items []PersistentVolume `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaim is a user's request for and claim to a persistent volume
0000000000000000000000000000000000000000;;	type PersistentVolumeClaim struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the desired characteristics of a volume requested by a pod author.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec PersistentVolumeClaimSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status represents the current information/status of a persistent volume claim.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status PersistentVolumeClaimStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;		// A list of persistent volume claims.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
0000000000000000000000000000000000000000;;		Items []PersistentVolumeClaim `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaimSpec describes the common attributes of storage devices
0000000000000000000000000000000000000000;;	// and allows a Source for provider-specific attributes
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimSpec struct {
0000000000000000000000000000000000000000;;		// AccessModes contains the desired access modes the volume should have.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AccessModes []PersistentVolumeAccessMode `json:"accessModes,omitempty" protobuf:"bytes,1,rep,name=accessModes,casttype=PersistentVolumeAccessMode"`
0000000000000000000000000000000000000000;;		// A label query over volumes to consider for binding.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector *metav1.LabelSelector `json:"selector,omitempty" protobuf:"bytes,4,opt,name=selector"`
0000000000000000000000000000000000000000;;		// Resources represents the minimum resources the volume should have.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Resources ResourceRequirements `json:"resources,omitempty" protobuf:"bytes,2,opt,name=resources"`
0000000000000000000000000000000000000000;;		// VolumeName is the binding reference to the PersistentVolume backing this claim.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumeName string `json:"volumeName,omitempty" protobuf:"bytes,3,opt,name=volumeName"`
0000000000000000000000000000000000000000;;		// Name of the StorageClass required by the claim.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StorageClassName *string `json:"storageClassName,omitempty" protobuf:"bytes,5,opt,name=storageClassName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PersistentVolumeClaimStatus is the current status of a persistent volume claim.
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimStatus struct {
0000000000000000000000000000000000000000;;		// Phase represents the current phase of PersistentVolumeClaim.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Phase PersistentVolumeClaimPhase `json:"phase,omitempty" protobuf:"bytes,1,opt,name=phase,casttype=PersistentVolumeClaimPhase"`
0000000000000000000000000000000000000000;;		// AccessModes contains the actual access modes the volume backing the PVC has.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AccessModes []PersistentVolumeAccessMode `json:"accessModes,omitempty" protobuf:"bytes,2,rep,name=accessModes,casttype=PersistentVolumeAccessMode"`
0000000000000000000000000000000000000000;;		// Represents the actual resources of the underlying volume.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Capacity ResourceList `json:"capacity,omitempty" protobuf:"bytes,3,rep,name=capacity,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeAccessMode string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// can be mounted read/write mode to exactly 1 host
0000000000000000000000000000000000000000;;		ReadWriteOnce PersistentVolumeAccessMode = "ReadWriteOnce"
0000000000000000000000000000000000000000;;		// can be mounted in read-only mode to many hosts
0000000000000000000000000000000000000000;;		ReadOnlyMany PersistentVolumeAccessMode = "ReadOnlyMany"
0000000000000000000000000000000000000000;;		// can be mounted in read/write mode to many hosts
0000000000000000000000000000000000000000;;		ReadWriteMany PersistentVolumeAccessMode = "ReadWriteMany"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumePhase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// used for PersistentVolumes that are not available
0000000000000000000000000000000000000000;;		VolumePending PersistentVolumePhase = "Pending"
0000000000000000000000000000000000000000;;		// used for PersistentVolumes that are not yet bound
0000000000000000000000000000000000000000;;		// Available volumes are held by the binder and matched to PersistentVolumeClaims
0000000000000000000000000000000000000000;;		VolumeAvailable PersistentVolumePhase = "Available"
0000000000000000000000000000000000000000;;		// used for PersistentVolumes that are bound
0000000000000000000000000000000000000000;;		VolumeBound PersistentVolumePhase = "Bound"
0000000000000000000000000000000000000000;;		// used for PersistentVolumes where the bound PersistentVolumeClaim was deleted
0000000000000000000000000000000000000000;;		// released volumes must be recycled before becoming available again
0000000000000000000000000000000000000000;;		// this phase is used by the persistent volume claim binder to signal to another process to reclaim the resource
0000000000000000000000000000000000000000;;		VolumeReleased PersistentVolumePhase = "Released"
0000000000000000000000000000000000000000;;		// used for PersistentVolumes that failed to be correctly recycled or deleted after being released from a claim
0000000000000000000000000000000000000000;;		VolumeFailed PersistentVolumePhase = "Failed"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistentVolumeClaimPhase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// used for PersistentVolumeClaims that are not yet bound
0000000000000000000000000000000000000000;;		ClaimPending PersistentVolumeClaimPhase = "Pending"
0000000000000000000000000000000000000000;;		// used for PersistentVolumeClaims that are bound
0000000000000000000000000000000000000000;;		ClaimBound PersistentVolumeClaimPhase = "Bound"
0000000000000000000000000000000000000000;;		// used for PersistentVolumeClaims that lost their underlying
0000000000000000000000000000000000000000;;		// PersistentVolume. The claim was bound to a PersistentVolume and this
0000000000000000000000000000000000000000;;		// volume does not exist any longer and all data on it was lost.
0000000000000000000000000000000000000000;;		ClaimLost PersistentVolumeClaimPhase = "Lost"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a host path mapped into a pod.
0000000000000000000000000000000000000000;;	// Host path volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type HostPathVolumeSource struct {
0000000000000000000000000000000000000000;;		// Path of the directory on the host.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
0000000000000000000000000000000000000000;;		Path string `json:"path" protobuf:"bytes,1,opt,name=path"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents an empty directory for a pod.
0000000000000000000000000000000000000000;;	// Empty directory volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type EmptyDirVolumeSource struct {
0000000000000000000000000000000000000000;;		// What type of storage medium should back this directory.
0000000000000000000000000000000000000000;;		// The default is "" which means to use the node's default medium.
0000000000000000000000000000000000000000;;		// Must be an empty string (default) or Memory.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Medium StorageMedium `json:"medium,omitempty" protobuf:"bytes,1,opt,name=medium,casttype=StorageMedium"`
0000000000000000000000000000000000000000;;		// Total amount of local storage required for this EmptyDir volume.
0000000000000000000000000000000000000000;;		// The size limit is also applicable for memory medium.
0000000000000000000000000000000000000000;;		// The maximum usage on memory medium EmptyDir would be the minimum value between
0000000000000000000000000000000000000000;;		// the SizeLimit specified here and the sum of memory limits of all containers in a pod.
0000000000000000000000000000000000000000;;		// The default is nil which means that the limit is undefined.
0000000000000000000000000000000000000000;;		// More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SizeLimit resource.Quantity `json:"sizeLimit,omitempty" protobuf:"bytes,2,opt,name=sizeLimit"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Glusterfs mount that lasts the lifetime of a pod.
0000000000000000000000000000000000000000;;	// Glusterfs volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type GlusterfsVolumeSource struct {
0000000000000000000000000000000000000000;;		// EndpointsName is the endpoint name that details Glusterfs topology.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
0000000000000000000000000000000000000000;;		EndpointsName string `json:"endpoints" protobuf:"bytes,1,opt,name=endpoints"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path is the Glusterfs volume path.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
0000000000000000000000000000000000000000;;		Path string `json:"path" protobuf:"bytes,2,opt,name=path"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,3,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Rados Block Device mount that lasts the lifetime of a pod.
0000000000000000000000000000000000000000;;	// RBD volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type RBDVolumeSource struct {
0000000000000000000000000000000000000000;;		// A collection of Ceph monitors.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		CephMonitors []string `json:"monitors" protobuf:"bytes,1,rep,name=monitors"`
0000000000000000000000000000000000000000;;		// The rados image name.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		RBDImage string `json:"image" protobuf:"bytes,2,opt,name=image"`
0000000000000000000000000000000000000000;;		// Filesystem type of the volume that you want to mount.
0000000000000000000000000000000000000000;;		// Tip: Ensure that the filesystem type is supported by the host operating system.
0000000000000000000000000000000000000000;;		// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
0000000000000000000000000000000000000000;;		// TODO: how do we prevent errors in the filesystem from compromising the machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,3,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// The rados pool name.
0000000000000000000000000000000000000000;;		// Default is rbd.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RBDPool string `json:"pool,omitempty" protobuf:"bytes,4,opt,name=pool"`
0000000000000000000000000000000000000000;;		// The rados user name.
0000000000000000000000000000000000000000;;		// Default is admin.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RadosUser string `json:"user,omitempty" protobuf:"bytes,5,opt,name=user"`
0000000000000000000000000000000000000000;;		// Keyring is the path to key ring for RBDUser.
0000000000000000000000000000000000000000;;		// Default is /etc/ceph/keyring.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Keyring string `json:"keyring,omitempty" protobuf:"bytes,6,opt,name=keyring"`
0000000000000000000000000000000000000000;;		// SecretRef is name of the authentication secret for RBDUser. If provided
0000000000000000000000000000000000000000;;		// overrides keyring.
0000000000000000000000000000000000000000;;		// Default is nil.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference `json:"secretRef,omitempty" protobuf:"bytes,7,opt,name=secretRef"`
0000000000000000000000000000000000000000;;		// ReadOnly here will force the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,8,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a cinder volume resource in Openstack.
0000000000000000000000000000000000000000;;	// A Cinder volume must exist before mounting to a container.
0000000000000000000000000000000000000000;;	// The volume must also be in the same region as the kubelet.
0000000000000000000000000000000000000000;;	// Cinder volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type CinderVolumeSource struct {
0000000000000000000000000000000000000000;;		// volume id used to identify the volume in cinder
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
0000000000000000000000000000000000000000;;		VolumeID string `json:"volumeID" protobuf:"bytes,1,opt,name=volumeID"`
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,2,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,3,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
0000000000000000000000000000000000000000;;	// Cephfs volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type CephFSVolumeSource struct {
0000000000000000000000000000000000000000;;		// Required: Monitors is a collection of Ceph monitors
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		Monitors []string `json:"monitors" protobuf:"bytes,1,rep,name=monitors"`
0000000000000000000000000000000000000000;;		// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Path string `json:"path,omitempty" protobuf:"bytes,2,opt,name=path"`
0000000000000000000000000000000000000000;;		// Optional: User is the rados user name, default is admin
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		User string `json:"user,omitempty" protobuf:"bytes,3,opt,name=user"`
0000000000000000000000000000000000000000;;		// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretFile string `json:"secretFile,omitempty" protobuf:"bytes,4,opt,name=secretFile"`
0000000000000000000000000000000000000000;;		// Optional: SecretRef is reference to the authentication secret for User, default is empty.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference `json:"secretRef,omitempty" protobuf:"bytes,5,opt,name=secretRef"`
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,6,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Flocker volume mounted by the Flocker agent.
0000000000000000000000000000000000000000;;	// One and only one of datasetName and datasetUUID should be set.
0000000000000000000000000000000000000000;;	// Flocker volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type FlockerVolumeSource struct {
0000000000000000000000000000000000000000;;		// Name of the dataset stored as metadata -> name on the dataset for Flocker
0000000000000000000000000000000000000000;;		// should be considered as deprecated
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DatasetName string `json:"datasetName,omitempty" protobuf:"bytes,1,opt,name=datasetName"`
0000000000000000000000000000000000000000;;		// UUID of the dataset. This is unique identifier of a Flocker dataset
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DatasetUUID string `json:"datasetUUID,omitempty" protobuf:"bytes,2,opt,name=datasetUUID"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StorageMedium defines ways that storage can be allocated to a volume.
0000000000000000000000000000000000000000;;	type StorageMedium string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		StorageMediumDefault StorageMedium = ""       // use whatever the default is for the node
0000000000000000000000000000000000000000;;		StorageMediumMemory  StorageMedium = "Memory" // use memory (tmpfs)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Protocol defines network protocols supported for things like container ports.
0000000000000000000000000000000000000000;;	type Protocol string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ProtocolTCP is the TCP protocol.
0000000000000000000000000000000000000000;;		ProtocolTCP Protocol = "TCP"
0000000000000000000000000000000000000000;;		// ProtocolUDP is the UDP protocol.
0000000000000000000000000000000000000000;;		ProtocolUDP Protocol = "UDP"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Persistent Disk resource in Google Compute Engine.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A GCE PD must exist before mounting to a container. The disk must
0000000000000000000000000000000000000000;;	// also be in the same GCE project and zone as the kubelet. A GCE PD
0000000000000000000000000000000000000000;;	// can only be mounted as read/write once or read-only many times. GCE
0000000000000000000000000000000000000000;;	// PDs support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type GCEPersistentDiskVolumeSource struct {
0000000000000000000000000000000000000000;;		// Unique name of the PD resource in GCE. Used to identify the disk in GCE.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
0000000000000000000000000000000000000000;;		PDName string `json:"pdName" protobuf:"bytes,1,opt,name=pdName"`
0000000000000000000000000000000000000000;;		// Filesystem type of the volume that you want to mount.
0000000000000000000000000000000000000000;;		// Tip: Ensure that the filesystem type is supported by the host operating system.
0000000000000000000000000000000000000000;;		// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
0000000000000000000000000000000000000000;;		// TODO: how do we prevent errors in the filesystem from compromising the machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,2,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// The partition in the volume that you want to mount.
0000000000000000000000000000000000000000;;		// If omitted, the default is to mount by volume name.
0000000000000000000000000000000000000000;;		// Examples: For volume /dev/sda1, you specify the partition as "1".
0000000000000000000000000000000000000000;;		// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Partition int32 `json:"partition,omitempty" protobuf:"varint,3,opt,name=partition"`
0000000000000000000000000000000000000000;;		// ReadOnly here will force the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,4,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Quobyte mount that lasts the lifetime of a pod.
0000000000000000000000000000000000000000;;	// Quobyte volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type QuobyteVolumeSource struct {
0000000000000000000000000000000000000000;;		// Registry represents a single or multiple Quobyte Registry services
0000000000000000000000000000000000000000;;		// specified as a string as host:port pair (multiple entries are separated with commas)
0000000000000000000000000000000000000000;;		// which acts as the central registry for volumes
0000000000000000000000000000000000000000;;		Registry string `json:"registry" protobuf:"bytes,1,opt,name=registry"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Volume is a string that references an already created Quobyte volume by name.
0000000000000000000000000000000000000000;;		Volume string `json:"volume" protobuf:"bytes,2,opt,name=volume"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,3,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// User to map volume access to
0000000000000000000000000000000000000000;;		// Defaults to serivceaccount user
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		User string `json:"user,omitempty" protobuf:"bytes,4,opt,name=user"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Group to map volume access to
0000000000000000000000000000000000000000;;		// Default is no group
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Group string `json:"group,omitempty" protobuf:"bytes,5,opt,name=group"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FlexVolume represents a generic volume resource that is
0000000000000000000000000000000000000000;;	// provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
0000000000000000000000000000000000000000;;	type FlexVolumeSource struct {
0000000000000000000000000000000000000000;;		// Driver is the name of the driver to use for this volume.
0000000000000000000000000000000000000000;;		Driver string `json:"driver" protobuf:"bytes,1,opt,name=driver"`
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,2,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// Optional: SecretRef is reference to the secret object containing
0000000000000000000000000000000000000000;;		// sensitive information to pass to the plugin scripts. This may be
0000000000000000000000000000000000000000;;		// empty if no secret object is specified. If the secret object
0000000000000000000000000000000000000000;;		// contains more than one secret, all secrets are passed to the plugin
0000000000000000000000000000000000000000;;		// scripts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference `json:"secretRef,omitempty" protobuf:"bytes,3,opt,name=secretRef"`
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,4,opt,name=readOnly"`
0000000000000000000000000000000000000000;;		// Optional: Extra command options if any.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Options map[string]string `json:"options,omitempty" protobuf:"bytes,5,rep,name=options"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Persistent Disk resource in AWS.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An AWS EBS disk must exist before mounting to a container. The disk
0000000000000000000000000000000000000000;;	// must also be in the same AWS zone as the kubelet. An AWS EBS disk
0000000000000000000000000000000000000000;;	// can only be mounted as read/write once. AWS EBS volumes support
0000000000000000000000000000000000000000;;	// ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type AWSElasticBlockStoreVolumeSource struct {
0000000000000000000000000000000000000000;;		// Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
0000000000000000000000000000000000000000;;		VolumeID string `json:"volumeID" protobuf:"bytes,1,opt,name=volumeID"`
0000000000000000000000000000000000000000;;		// Filesystem type of the volume that you want to mount.
0000000000000000000000000000000000000000;;		// Tip: Ensure that the filesystem type is supported by the host operating system.
0000000000000000000000000000000000000000;;		// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
0000000000000000000000000000000000000000;;		// TODO: how do we prevent errors in the filesystem from compromising the machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,2,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// The partition in the volume that you want to mount.
0000000000000000000000000000000000000000;;		// If omitted, the default is to mount by volume name.
0000000000000000000000000000000000000000;;		// Examples: For volume /dev/sda1, you specify the partition as "1".
0000000000000000000000000000000000000000;;		// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Partition int32 `json:"partition,omitempty" protobuf:"varint,3,opt,name=partition"`
0000000000000000000000000000000000000000;;		// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
0000000000000000000000000000000000000000;;		// If omitted, the default is "false".
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,4,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a volume that is populated with the contents of a git repository.
0000000000000000000000000000000000000000;;	// Git repo volumes do not support ownership management.
0000000000000000000000000000000000000000;;	// Git repo volumes support SELinux relabeling.
0000000000000000000000000000000000000000;;	type GitRepoVolumeSource struct {
0000000000000000000000000000000000000000;;		// Repository URL
0000000000000000000000000000000000000000;;		Repository string `json:"repository" protobuf:"bytes,1,opt,name=repository"`
0000000000000000000000000000000000000000;;		// Commit hash for the specified revision.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Revision string `json:"revision,omitempty" protobuf:"bytes,2,opt,name=revision"`
0000000000000000000000000000000000000000;;		// Target directory name.
0000000000000000000000000000000000000000;;		// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
0000000000000000000000000000000000000000;;		// git repository.  Otherwise, if specified, the volume will contain the git repository in
0000000000000000000000000000000000000000;;		// the subdirectory with the given name.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Directory string `json:"directory,omitempty" protobuf:"bytes,3,opt,name=directory"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adapts a Secret into a volume.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target Secret's Data field will be presented in a volume
0000000000000000000000000000000000000000;;	// as files using the keys in the Data field as the file names.
0000000000000000000000000000000000000000;;	// Secret volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type SecretVolumeSource struct {
0000000000000000000000000000000000000000;;		// Name of the secret in the pod's namespace to use.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretName string `json:"secretName,omitempty" protobuf:"bytes,1,opt,name=secretName"`
0000000000000000000000000000000000000000;;		// If unspecified, each key-value pair in the Data field of the referenced
0000000000000000000000000000000000000000;;		// Secret will be projected into the volume as a file whose name is the
0000000000000000000000000000000000000000;;		// key and content is the value. If specified, the listed keys will be
0000000000000000000000000000000000000000;;		// projected into the specified paths, and unlisted keys will not be
0000000000000000000000000000000000000000;;		// present. If a key is specified which is not present in the Secret,
0000000000000000000000000000000000000000;;		// the volume setup will error unless it is marked optional. Paths must be
0000000000000000000000000000000000000000;;		// relative and may not contain the '..' path or start with '..'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []KeyToPath `json:"items,omitempty" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;		// Optional: mode bits to use on created files by default. Must be a
0000000000000000000000000000000000000000;;		// value between 0 and 0777. Defaults to 0644.
0000000000000000000000000000000000000000;;		// Directories within the path are not affected by this setting.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultMode *int32 `json:"defaultMode,omitempty" protobuf:"bytes,3,opt,name=defaultMode"`
0000000000000000000000000000000000000000;;		// Specify whether the Secret or it's keys must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool `json:"optional,omitempty" protobuf:"varint,4,opt,name=optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SecretVolumeSourceDefaultMode int32 = 0644
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adapts a secret into a projected volume.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target Secret's Data field will be presented in a
0000000000000000000000000000000000000000;;	// projected volume as files using the keys in the Data field as the file names.
0000000000000000000000000000000000000000;;	// Note that this is identical to a secret volume source without the default
0000000000000000000000000000000000000000;;	// mode.
0000000000000000000000000000000000000000;;	type SecretProjection struct {
0000000000000000000000000000000000000000;;		LocalObjectReference `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
0000000000000000000000000000000000000000;;		// If unspecified, each key-value pair in the Data field of the referenced
0000000000000000000000000000000000000000;;		// Secret will be projected into the volume as a file whose name is the
0000000000000000000000000000000000000000;;		// key and content is the value. If specified, the listed keys will be
0000000000000000000000000000000000000000;;		// projected into the specified paths, and unlisted keys will not be
0000000000000000000000000000000000000000;;		// present. If a key is specified which is not present in the Secret,
0000000000000000000000000000000000000000;;		// the volume setup will error unless it is marked optional. Paths must be
0000000000000000000000000000000000000000;;		// relative and may not contain the '..' path or start with '..'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []KeyToPath `json:"items,omitempty" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;		// Specify whether the Secret or its key must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool `json:"optional,omitempty" protobuf:"varint,4,opt,name=optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents an NFS mount that lasts the lifetime of a pod.
0000000000000000000000000000000000000000;;	// NFS volumes do not support ownership management or SELinux relabeling.
0000000000000000000000000000000000000000;;	type NFSVolumeSource struct {
0000000000000000000000000000000000000000;;		// Server is the hostname or IP address of the NFS server.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
0000000000000000000000000000000000000000;;		Server string `json:"server" protobuf:"bytes,1,opt,name=server"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path that is exported by the NFS server.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
0000000000000000000000000000000000000000;;		Path string `json:"path" protobuf:"bytes,2,opt,name=path"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadOnly here will force
0000000000000000000000000000000000000000;;		// the NFS export to be mounted with read-only permissions.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,3,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents an ISCSI disk.
0000000000000000000000000000000000000000;;	// ISCSI volumes can only be mounted as read/write once.
0000000000000000000000000000000000000000;;	// ISCSI volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type ISCSIVolumeSource struct {
0000000000000000000000000000000000000000;;		// iSCSI target portal. The portal is either an IP or ip_addr:port if the port
0000000000000000000000000000000000000000;;		// is other than default (typically TCP ports 860 and 3260).
0000000000000000000000000000000000000000;;		TargetPortal string `json:"targetPortal" protobuf:"bytes,1,opt,name=targetPortal"`
0000000000000000000000000000000000000000;;		// Target iSCSI Qualified Name.
0000000000000000000000000000000000000000;;		IQN string `json:"iqn" protobuf:"bytes,2,opt,name=iqn"`
0000000000000000000000000000000000000000;;		// iSCSI target lun number.
0000000000000000000000000000000000000000;;		Lun int32 `json:"lun" protobuf:"varint,3,opt,name=lun"`
0000000000000000000000000000000000000000;;		// Optional: Defaults to 'default' (tcp). iSCSI interface name that uses an iSCSI transport.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ISCSIInterface string `json:"iscsiInterface,omitempty" protobuf:"bytes,4,opt,name=iscsiInterface"`
0000000000000000000000000000000000000000;;		// Filesystem type of the volume that you want to mount.
0000000000000000000000000000000000000000;;		// Tip: Ensure that the filesystem type is supported by the host operating system.
0000000000000000000000000000000000000000;;		// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
0000000000000000000000000000000000000000;;		// TODO: how do we prevent errors in the filesystem from compromising the machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,5,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// ReadOnly here will force the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,6,opt,name=readOnly"`
0000000000000000000000000000000000000000;;		// iSCSI target portal List. The portal is either an IP or ip_addr:port if the port
0000000000000000000000000000000000000000;;		// is other than default (typically TCP ports 860 and 3260).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Portals []string `json:"portals,omitempty" protobuf:"bytes,7,opt,name=portals"`
0000000000000000000000000000000000000000;;		// whether support iSCSI Discovery CHAP authentication
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DiscoveryCHAPAuth bool `json:"chapAuthDiscovery,omitempty" protobuf:"varint,8,opt,name=chapAuthDiscovery"`
0000000000000000000000000000000000000000;;		// whether support iSCSI Session CHAP authentication
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SessionCHAPAuth bool `json:"chapAuthSession,omitempty" protobuf:"varint,11,opt,name=chapAuthSession"`
0000000000000000000000000000000000000000;;		// CHAP secret for iSCSI target and initiator authentication
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference `json:"secretRef,omitempty" protobuf:"bytes,10,opt,name=secretRef"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Fibre Channel volume.
0000000000000000000000000000000000000000;;	// Fibre Channel volumes can only be mounted as read/write once.
0000000000000000000000000000000000000000;;	// Fibre Channel volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type FCVolumeSource struct {
0000000000000000000000000000000000000000;;		// Required: FC target worldwide names (WWNs)
0000000000000000000000000000000000000000;;		TargetWWNs []string `json:"targetWWNs" protobuf:"bytes,1,rep,name=targetWWNs"`
0000000000000000000000000000000000000000;;		// Required: FC target lun number
0000000000000000000000000000000000000000;;		Lun *int32 `json:"lun" protobuf:"varint,2,opt,name=lun"`
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// TODO: how do we prevent errors in the filesystem from compromising the machine
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,3,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// Optional: Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,4,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;	type AzureFileVolumeSource struct {
0000000000000000000000000000000000000000;;		// the name of secret that contains Azure Storage Account Name and Key
0000000000000000000000000000000000000000;;		SecretName string `json:"secretName" protobuf:"bytes,1,opt,name=secretName"`
0000000000000000000000000000000000000000;;		// Share Name
0000000000000000000000000000000000000000;;		ShareName string `json:"shareName" protobuf:"bytes,2,opt,name=shareName"`
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,3,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a vSphere volume resource.
0000000000000000000000000000000000000000;;	type VsphereVirtualDiskVolumeSource struct {
0000000000000000000000000000000000000000;;		// Path that identifies vSphere volume vmdk
0000000000000000000000000000000000000000;;		VolumePath string `json:"volumePath" protobuf:"bytes,1,opt,name=volumePath"`
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,2,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// Storage Policy Based Management (SPBM) profile name.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StoragePolicyName string `json:"storagePolicyName,omitempty" protobuf:"bytes,3,opt,name=storagePolicyName"`
0000000000000000000000000000000000000000;;		// Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StoragePolicyID string `json:"storagePolicyID,omitempty" protobuf:"bytes,4,opt,name=storagePolicyID"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a Photon Controller persistent disk resource.
0000000000000000000000000000000000000000;;	type PhotonPersistentDiskVolumeSource struct {
0000000000000000000000000000000000000000;;		// ID that identifies Photon Controller persistent disk
0000000000000000000000000000000000000000;;		PdID string `json:"pdID" protobuf:"bytes,1,opt,name=pdID"`
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,2,opt,name=fsType"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AzureDataDiskCachingMode string
0000000000000000000000000000000000000000;;	type AzureDataDiskKind string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		AzureDataDiskCachingNone      AzureDataDiskCachingMode = "None"
0000000000000000000000000000000000000000;;		AzureDataDiskCachingReadOnly  AzureDataDiskCachingMode = "ReadOnly"
0000000000000000000000000000000000000000;;		AzureDataDiskCachingReadWrite AzureDataDiskCachingMode = "ReadWrite"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AzureSharedBlobDisk    AzureDataDiskKind = "Shared"
0000000000000000000000000000000000000000;;		AzureDedicatedBlobDisk AzureDataDiskKind = "Dedicated"
0000000000000000000000000000000000000000;;		AzureManagedDisk       AzureDataDiskKind = "Managed"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
0000000000000000000000000000000000000000;;	type AzureDiskVolumeSource struct {
0000000000000000000000000000000000000000;;		// The Name of the data disk in the blob storage
0000000000000000000000000000000000000000;;		DiskName string `json:"diskName" protobuf:"bytes,1,opt,name=diskName"`
0000000000000000000000000000000000000000;;		// The URI the data disk in the blob storage
0000000000000000000000000000000000000000;;		DataDiskURI string `json:"diskURI" protobuf:"bytes,2,opt,name=diskURI"`
0000000000000000000000000000000000000000;;		// Host Caching mode: None, Read Only, Read Write.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CachingMode *AzureDataDiskCachingMode `json:"cachingMode,omitempty" protobuf:"bytes,3,opt,name=cachingMode,casttype=AzureDataDiskCachingMode"`
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType *string `json:"fsType,omitempty" protobuf:"bytes,4,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly *bool `json:"readOnly,omitempty" protobuf:"varint,5,opt,name=readOnly"`
0000000000000000000000000000000000000000;;		// Expected values Shared: mulitple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
0000000000000000000000000000000000000000;;		Kind *AzureDataDiskKind `json:"kind,omitempty" protobuf:"bytes,6,opt,name=kind,casttype=AzureDataDiskKind"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortworxVolumeSource represents a Portworx volume resource.
0000000000000000000000000000000000000000;;	type PortworxVolumeSource struct {
0000000000000000000000000000000000000000;;		// VolumeID uniquely identifies a Portworx volume
0000000000000000000000000000000000000000;;		VolumeID string `json:"volumeID" protobuf:"bytes,1,opt,name=volumeID"`
0000000000000000000000000000000000000000;;		// FSType represents the filesystem type to mount
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,2,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,3,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleIOVolumeSource represents a persistent ScaleIO volume
0000000000000000000000000000000000000000;;	type ScaleIOVolumeSource struct {
0000000000000000000000000000000000000000;;		// The host address of the ScaleIO API Gateway.
0000000000000000000000000000000000000000;;		Gateway string `json:"gateway" protobuf:"bytes,1,opt,name=gateway"`
0000000000000000000000000000000000000000;;		// The name of the storage system as configured in ScaleIO.
0000000000000000000000000000000000000000;;		System string `json:"system" protobuf:"bytes,2,opt,name=system"`
0000000000000000000000000000000000000000;;		// SecretRef references to the secret for ScaleIO user and other
0000000000000000000000000000000000000000;;		// sensitive information. If this is not provided, Login operation will fail.
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference `json:"secretRef" protobuf:"bytes,3,opt,name=secretRef"`
0000000000000000000000000000000000000000;;		// Flag to enable/disable SSL communication with Gateway, default false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SSLEnabled bool `json:"sslEnabled,omitempty" protobuf:"varint,4,opt,name=sslEnabled"`
0000000000000000000000000000000000000000;;		// The name of the Protection Domain for the configured storage (defaults to "default").
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ProtectionDomain string `json:"protectionDomain,omitempty" protobuf:"bytes,5,opt,name=protectionDomain"`
0000000000000000000000000000000000000000;;		// The Storage Pool associated with the protection domain (defaults to "default").
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StoragePool string `json:"storagePool,omitempty" protobuf:"bytes,6,opt,name=storagePool"`
0000000000000000000000000000000000000000;;		// Indicates whether the storage for a volume should be thick or thin (defaults to "thin").
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StorageMode string `json:"storageMode,omitempty" protobuf:"bytes,7,opt,name=storageMode"`
0000000000000000000000000000000000000000;;		// The name of a volume already created in the ScaleIO system
0000000000000000000000000000000000000000;;		// that is associated with this volume source.
0000000000000000000000000000000000000000;;		VolumeName string `json:"volumeName,omitempty" protobuf:"bytes,8,opt,name=volumeName"`
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,9,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,10,opt,name=readOnly"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a StorageOS persistent volume resource.
0000000000000000000000000000000000000000;;	type StorageOSVolumeSource struct {
0000000000000000000000000000000000000000;;		// VolumeName is the human-readable name of the StorageOS volume.  Volume
0000000000000000000000000000000000000000;;		// names are only unique within a namespace.
0000000000000000000000000000000000000000;;		VolumeName string `json:"volumeName,omitempty" protobuf:"bytes,1,opt,name=volumeName"`
0000000000000000000000000000000000000000;;		// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
0000000000000000000000000000000000000000;;		// namespace is specified then the Pod's namespace will be used.  This allows the
0000000000000000000000000000000000000000;;		// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
0000000000000000000000000000000000000000;;		// Set VolumeName to any name to override the default behaviour.
0000000000000000000000000000000000000000;;		// Set to "default" if you are not using namespaces within StorageOS.
0000000000000000000000000000000000000000;;		// Namespaces that do not pre-exist within StorageOS will be created.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumeNamespace string `json:"volumeNamespace,omitempty" protobuf:"bytes,2,opt,name=volumeNamespace"`
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,3,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,4,opt,name=readOnly"`
0000000000000000000000000000000000000000;;		// SecretRef specifies the secret to use for obtaining the StorageOS API
0000000000000000000000000000000000000000;;		// credentials.  If not specified, default values will be attempted.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *LocalObjectReference `json:"secretRef,omitempty" protobuf:"bytes,5,opt,name=secretRef"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a StorageOS persistent volume resource.
0000000000000000000000000000000000000000;;	type StorageOSPersistentVolumeSource struct {
0000000000000000000000000000000000000000;;		// VolumeName is the human-readable name of the StorageOS volume.  Volume
0000000000000000000000000000000000000000;;		// names are only unique within a namespace.
0000000000000000000000000000000000000000;;		VolumeName string `json:"volumeName,omitempty" protobuf:"bytes,1,opt,name=volumeName"`
0000000000000000000000000000000000000000;;		// VolumeNamespace specifies the scope of the volume within StorageOS.  If no
0000000000000000000000000000000000000000;;		// namespace is specified then the Pod's namespace will be used.  This allows the
0000000000000000000000000000000000000000;;		// Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
0000000000000000000000000000000000000000;;		// Set VolumeName to any name to override the default behaviour.
0000000000000000000000000000000000000000;;		// Set to "default" if you are not using namespaces within StorageOS.
0000000000000000000000000000000000000000;;		// Namespaces that do not pre-exist within StorageOS will be created.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumeNamespace string `json:"volumeNamespace,omitempty" protobuf:"bytes,2,opt,name=volumeNamespace"`
0000000000000000000000000000000000000000;;		// Filesystem type to mount.
0000000000000000000000000000000000000000;;		// Must be a filesystem type supported by the host operating system.
0000000000000000000000000000000000000000;;		// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSType string `json:"fsType,omitempty" protobuf:"bytes,3,opt,name=fsType"`
0000000000000000000000000000000000000000;;		// Defaults to false (read/write). ReadOnly here will force
0000000000000000000000000000000000000000;;		// the ReadOnly setting in VolumeMounts.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,4,opt,name=readOnly"`
0000000000000000000000000000000000000000;;		// SecretRef specifies the secret to use for obtaining the StorageOS API
0000000000000000000000000000000000000000;;		// credentials.  If not specified, default values will be attempted.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *ObjectReference `json:"secretRef,omitempty" protobuf:"bytes,5,opt,name=secretRef"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adapts a ConfigMap into a volume.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target ConfigMap's Data field will be presented in a
0000000000000000000000000000000000000000;;	// volume as files using the keys in the Data field as the file names, unless
0000000000000000000000000000000000000000;;	// the items element is populated with specific mappings of keys to paths.
0000000000000000000000000000000000000000;;	// ConfigMap volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type ConfigMapVolumeSource struct {
0000000000000000000000000000000000000000;;		LocalObjectReference `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
0000000000000000000000000000000000000000;;		// If unspecified, each key-value pair in the Data field of the referenced
0000000000000000000000000000000000000000;;		// ConfigMap will be projected into the volume as a file whose name is the
0000000000000000000000000000000000000000;;		// key and content is the value. If specified, the listed keys will be
0000000000000000000000000000000000000000;;		// projected into the specified paths, and unlisted keys will not be
0000000000000000000000000000000000000000;;		// present. If a key is specified which is not present in the ConfigMap,
0000000000000000000000000000000000000000;;		// the volume setup will error unless it is marked optional. Paths must be
0000000000000000000000000000000000000000;;		// relative and may not contain the '..' path or start with '..'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []KeyToPath `json:"items,omitempty" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;		// Optional: mode bits to use on created files by default. Must be a
0000000000000000000000000000000000000000;;		// value between 0 and 0777. Defaults to 0644.
0000000000000000000000000000000000000000;;		// Directories within the path are not affected by this setting.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultMode *int32 `json:"defaultMode,omitempty" protobuf:"varint,3,opt,name=defaultMode"`
0000000000000000000000000000000000000000;;		// Specify whether the ConfigMap or it's keys must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool `json:"optional,omitempty" protobuf:"varint,4,opt,name=optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ConfigMapVolumeSourceDefaultMode int32 = 0644
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adapts a ConfigMap into a projected volume.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target ConfigMap's Data field will be presented in a
0000000000000000000000000000000000000000;;	// projected volume as files using the keys in the Data field as the file names,
0000000000000000000000000000000000000000;;	// unless the items element is populated with specific mappings of keys to paths.
0000000000000000000000000000000000000000;;	// Note that this is identical to a configmap volume source without the default
0000000000000000000000000000000000000000;;	// mode.
0000000000000000000000000000000000000000;;	type ConfigMapProjection struct {
0000000000000000000000000000000000000000;;		LocalObjectReference `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
0000000000000000000000000000000000000000;;		// If unspecified, each key-value pair in the Data field of the referenced
0000000000000000000000000000000000000000;;		// ConfigMap will be projected into the volume as a file whose name is the
0000000000000000000000000000000000000000;;		// key and content is the value. If specified, the listed keys will be
0000000000000000000000000000000000000000;;		// projected into the specified paths, and unlisted keys will not be
0000000000000000000000000000000000000000;;		// present. If a key is specified which is not present in the ConfigMap,
0000000000000000000000000000000000000000;;		// the volume setup will error unless it is marked optional. Paths must be
0000000000000000000000000000000000000000;;		// relative and may not contain the '..' path or start with '..'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []KeyToPath `json:"items,omitempty" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;		// Specify whether the ConfigMap or it's keys must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool `json:"optional,omitempty" protobuf:"varint,4,opt,name=optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a projected volume source
0000000000000000000000000000000000000000;;	type ProjectedVolumeSource struct {
0000000000000000000000000000000000000000;;		// list of volume projections
0000000000000000000000000000000000000000;;		Sources []VolumeProjection `json:"sources" protobuf:"bytes,1,rep,name=sources"`
0000000000000000000000000000000000000000;;		// Mode bits to use on created files by default. Must be a value between
0000000000000000000000000000000000000000;;		// 0 and 0777.
0000000000000000000000000000000000000000;;		// Directories within the path are not affected by this setting.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultMode *int32 `json:"defaultMode,omitempty" protobuf:"varint,2,opt,name=defaultMode"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Projection that may be projected along with other supported volume types
0000000000000000000000000000000000000000;;	type VolumeProjection struct {
0000000000000000000000000000000000000000;;		// all types below are the supported types for projection into the same volume
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// information about the secret data to project
0000000000000000000000000000000000000000;;		Secret *SecretProjection `json:"secret,omitempty" protobuf:"bytes,1,opt,name=secret"`
0000000000000000000000000000000000000000;;		// information about the downwardAPI data to project
0000000000000000000000000000000000000000;;		DownwardAPI *DownwardAPIProjection `json:"downwardAPI,omitempty" protobuf:"bytes,2,opt,name=downwardAPI"`
0000000000000000000000000000000000000000;;		// information about the configMap data to project
0000000000000000000000000000000000000000;;		ConfigMap *ConfigMapProjection `json:"configMap,omitempty" protobuf:"bytes,3,opt,name=configMap"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ProjectedVolumeSourceDefaultMode int32 = 0644
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Maps a string key to a path within a volume.
0000000000000000000000000000000000000000;;	type KeyToPath struct {
0000000000000000000000000000000000000000;;		// The key to project.
0000000000000000000000000000000000000000;;		Key string `json:"key" protobuf:"bytes,1,opt,name=key"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The relative path of the file to map the key to.
0000000000000000000000000000000000000000;;		// May not be an absolute path.
0000000000000000000000000000000000000000;;		// May not contain the path element '..'.
0000000000000000000000000000000000000000;;		// May not start with the string '..'.
0000000000000000000000000000000000000000;;		Path string `json:"path" protobuf:"bytes,2,opt,name=path"`
0000000000000000000000000000000000000000;;		// Optional: mode bits to use on this file, must be a value between 0
0000000000000000000000000000000000000000;;		// and 0777. If not specified, the volume defaultMode will be used.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Mode *int32 `json:"mode,omitempty" protobuf:"varint,3,opt,name=mode"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Local represents directly-attached storage with node affinity
0000000000000000000000000000000000000000;;	type LocalVolumeSource struct {
0000000000000000000000000000000000000000;;		// The full path to the volume on the node
0000000000000000000000000000000000000000;;		// For alpha, this path must be a directory
0000000000000000000000000000000000000000;;		// Once block as a source is supported, then this path can point to a block device
0000000000000000000000000000000000000000;;		Path string `json:"path" protobuf:"bytes,1,opt,name=path"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerPort represents a network port in a single container.
0000000000000000000000000000000000000000;;	type ContainerPort struct {
0000000000000000000000000000000000000000;;		// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
0000000000000000000000000000000000000000;;		// named port in a pod must have a unique name. Name for the port that can be
0000000000000000000000000000000000000000;;		// referred to by services.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// Number of port to expose on the host.
0000000000000000000000000000000000000000;;		// If specified, this must be a valid port number, 0 < x < 65536.
0000000000000000000000000000000000000000;;		// If HostNetwork is specified, this must match ContainerPort.
0000000000000000000000000000000000000000;;		// Most containers do not need this.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostPort int32 `json:"hostPort,omitempty" protobuf:"varint,2,opt,name=hostPort"`
0000000000000000000000000000000000000000;;		// Number of port to expose on the pod's IP address.
0000000000000000000000000000000000000000;;		// This must be a valid port number, 0 < x < 65536.
0000000000000000000000000000000000000000;;		ContainerPort int32 `json:"containerPort" protobuf:"varint,3,opt,name=containerPort"`
0000000000000000000000000000000000000000;;		// Protocol for port. Must be UDP or TCP.
0000000000000000000000000000000000000000;;		// Defaults to "TCP".
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Protocol Protocol `json:"protocol,omitempty" protobuf:"bytes,4,opt,name=protocol,casttype=Protocol"`
0000000000000000000000000000000000000000;;		// What host IP to bind the external port to.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostIP string `json:"hostIP,omitempty" protobuf:"bytes,5,opt,name=hostIP"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VolumeMount describes a mounting of a Volume within a container.
0000000000000000000000000000000000000000;;	type VolumeMount struct {
0000000000000000000000000000000000000000;;		// This must match the Name of a Volume.
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// Mounted read-only if true, read-write otherwise (false or unspecified).
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnly bool `json:"readOnly,omitempty" protobuf:"varint,2,opt,name=readOnly"`
0000000000000000000000000000000000000000;;		// Path within the container at which the volume should be mounted.  Must
0000000000000000000000000000000000000000;;		// not contain ':'.
0000000000000000000000000000000000000000;;		MountPath string `json:"mountPath" protobuf:"bytes,3,opt,name=mountPath"`
0000000000000000000000000000000000000000;;		// Path within the volume from which the container's volume should be mounted.
0000000000000000000000000000000000000000;;		// Defaults to "" (volume's root).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SubPath string `json:"subPath,omitempty" protobuf:"bytes,4,opt,name=subPath"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnvVar represents an environment variable present in a Container.
0000000000000000000000000000000000000000;;	type EnvVar struct {
0000000000000000000000000000000000000000;;		// Name of the environment variable. Must be a C_IDENTIFIER.
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional: no more than one of the following may be specified.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Variable references $(VAR_NAME) are expanded
0000000000000000000000000000000000000000;;		// using the previous defined environment variables in the container and
0000000000000000000000000000000000000000;;		// any service environment variables. If a variable cannot be resolved,
0000000000000000000000000000000000000000;;		// the reference in the input string will be unchanged. The $(VAR_NAME)
0000000000000000000000000000000000000000;;		// syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
0000000000000000000000000000000000000000;;		// references will never be expanded, regardless of whether the variable
0000000000000000000000000000000000000000;;		// exists or not.
0000000000000000000000000000000000000000;;		// Defaults to "".
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Value string `json:"value,omitempty" protobuf:"bytes,2,opt,name=value"`
0000000000000000000000000000000000000000;;		// Source for the environment variable's value. Cannot be used if value is not empty.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ValueFrom *EnvVarSource `json:"valueFrom,omitempty" protobuf:"bytes,3,opt,name=valueFrom"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnvVarSource represents a source for the value of an EnvVar.
0000000000000000000000000000000000000000;;	type EnvVarSource struct {
0000000000000000000000000000000000000000;;		// Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations,
0000000000000000000000000000000000000000;;		// spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FieldRef *ObjectFieldSelector `json:"fieldRef,omitempty" protobuf:"bytes,1,opt,name=fieldRef"`
0000000000000000000000000000000000000000;;		// Selects a resource of the container: only resources limits and requests
0000000000000000000000000000000000000000;;		// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceFieldRef *ResourceFieldSelector `json:"resourceFieldRef,omitempty" protobuf:"bytes,2,opt,name=resourceFieldRef"`
0000000000000000000000000000000000000000;;		// Selects a key of a ConfigMap.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ConfigMapKeyRef *ConfigMapKeySelector `json:"configMapKeyRef,omitempty" protobuf:"bytes,3,opt,name=configMapKeyRef"`
0000000000000000000000000000000000000000;;		// Selects a key of a secret in the pod's namespace
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretKeyRef *SecretKeySelector `json:"secretKeyRef,omitempty" protobuf:"bytes,4,opt,name=secretKeyRef"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectFieldSelector selects an APIVersioned field of an object.
0000000000000000000000000000000000000000;;	type ObjectFieldSelector struct {
0000000000000000000000000000000000000000;;		// Version of the schema the FieldPath is written in terms of, defaults to "v1".
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		APIVersion string `json:"apiVersion,omitempty" protobuf:"bytes,1,opt,name=apiVersion"`
0000000000000000000000000000000000000000;;		// Path of the field to select in the specified API version.
0000000000000000000000000000000000000000;;		FieldPath string `json:"fieldPath" protobuf:"bytes,2,opt,name=fieldPath"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceFieldSelector represents container resources (cpu, memory) and their output format
0000000000000000000000000000000000000000;;	type ResourceFieldSelector struct {
0000000000000000000000000000000000000000;;		// Container name: required for volumes, optional for env vars
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ContainerName string `json:"containerName,omitempty" protobuf:"bytes,1,opt,name=containerName"`
0000000000000000000000000000000000000000;;		// Required: resource to select
0000000000000000000000000000000000000000;;		Resource string `json:"resource" protobuf:"bytes,2,opt,name=resource"`
0000000000000000000000000000000000000000;;		// Specifies the output format of the exposed resources, defaults to "1"
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Divisor resource.Quantity `json:"divisor,omitempty" protobuf:"bytes,3,opt,name=divisor"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Selects a key from a ConfigMap.
0000000000000000000000000000000000000000;;	type ConfigMapKeySelector struct {
0000000000000000000000000000000000000000;;		// The ConfigMap to select from.
0000000000000000000000000000000000000000;;		LocalObjectReference `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
0000000000000000000000000000000000000000;;		// The key to select.
0000000000000000000000000000000000000000;;		Key string `json:"key" protobuf:"bytes,2,opt,name=key"`
0000000000000000000000000000000000000000;;		// Specify whether the ConfigMap or it's key must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool `json:"optional,omitempty" protobuf:"varint,3,opt,name=optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecretKeySelector selects a key of a Secret.
0000000000000000000000000000000000000000;;	type SecretKeySelector struct {
0000000000000000000000000000000000000000;;		// The name of the secret in the pod's namespace to select from.
0000000000000000000000000000000000000000;;		LocalObjectReference `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
0000000000000000000000000000000000000000;;		// The key of the secret to select from.  Must be a valid secret key.
0000000000000000000000000000000000000000;;		Key string `json:"key" protobuf:"bytes,2,opt,name=key"`
0000000000000000000000000000000000000000;;		// Specify whether the Secret or it's key must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool `json:"optional,omitempty" protobuf:"varint,3,opt,name=optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnvFromSource represents the source of a set of ConfigMaps
0000000000000000000000000000000000000000;;	type EnvFromSource struct {
0000000000000000000000000000000000000000;;		// An optional identifer to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Prefix string `json:"prefix,omitempty" protobuf:"bytes,1,opt,name=prefix"`
0000000000000000000000000000000000000000;;		// The ConfigMap to select from
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ConfigMapRef *ConfigMapEnvSource `json:"configMapRef,omitempty" protobuf:"bytes,2,opt,name=configMapRef"`
0000000000000000000000000000000000000000;;		// The Secret to select from
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecretRef *SecretEnvSource `json:"secretRef,omitempty" protobuf:"bytes,3,opt,name=secretRef"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigMapEnvSource selects a ConfigMap to populate the environment
0000000000000000000000000000000000000000;;	// variables with.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target ConfigMap's Data field will represent the
0000000000000000000000000000000000000000;;	// key-value pairs as environment variables.
0000000000000000000000000000000000000000;;	type ConfigMapEnvSource struct {
0000000000000000000000000000000000000000;;		// The ConfigMap to select from.
0000000000000000000000000000000000000000;;		LocalObjectReference `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
0000000000000000000000000000000000000000;;		// Specify whether the ConfigMap must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool `json:"optional,omitempty" protobuf:"varint,2,opt,name=optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecretEnvSource selects a Secret to populate the environment
0000000000000000000000000000000000000000;;	// variables with.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The contents of the target Secret's Data field will represent the
0000000000000000000000000000000000000000;;	// key-value pairs as environment variables.
0000000000000000000000000000000000000000;;	type SecretEnvSource struct {
0000000000000000000000000000000000000000;;		// The Secret to select from.
0000000000000000000000000000000000000000;;		LocalObjectReference `json:",inline" protobuf:"bytes,1,opt,name=localObjectReference"`
0000000000000000000000000000000000000000;;		// Specify whether the Secret must be defined
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Optional *bool `json:"optional,omitempty" protobuf:"varint,2,opt,name=optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPHeader describes a custom header to be used in HTTP probes
0000000000000000000000000000000000000000;;	type HTTPHeader struct {
0000000000000000000000000000000000000000;;		// The header field name
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// The header field value
0000000000000000000000000000000000000000;;		Value string `json:"value" protobuf:"bytes,2,opt,name=value"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPGetAction describes an action based on HTTP Get requests.
0000000000000000000000000000000000000000;;	type HTTPGetAction struct {
0000000000000000000000000000000000000000;;		// Path to access on the HTTP server.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Path string `json:"path,omitempty" protobuf:"bytes,1,opt,name=path"`
0000000000000000000000000000000000000000;;		// Name or number of the port to access on the container.
0000000000000000000000000000000000000000;;		// Number must be in the range 1 to 65535.
0000000000000000000000000000000000000000;;		// Name must be an IANA_SVC_NAME.
0000000000000000000000000000000000000000;;		Port intstr.IntOrString `json:"port" protobuf:"bytes,2,opt,name=port"`
0000000000000000000000000000000000000000;;		// Host name to connect to, defaults to the pod IP. You probably want to set
0000000000000000000000000000000000000000;;		// "Host" in httpHeaders instead.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Host string `json:"host,omitempty" protobuf:"bytes,3,opt,name=host"`
0000000000000000000000000000000000000000;;		// Scheme to use for connecting to the host.
0000000000000000000000000000000000000000;;		// Defaults to HTTP.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Scheme URIScheme `json:"scheme,omitempty" protobuf:"bytes,4,opt,name=scheme,casttype=URIScheme"`
0000000000000000000000000000000000000000;;		// Custom headers to set in the request. HTTP allows repeated headers.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HTTPHeaders []HTTPHeader `json:"httpHeaders,omitempty" protobuf:"bytes,5,rep,name=httpHeaders"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URIScheme identifies the scheme used for connection to a host for Get actions
0000000000000000000000000000000000000000;;	type URIScheme string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// URISchemeHTTP means that the scheme used will be http://
0000000000000000000000000000000000000000;;		URISchemeHTTP URIScheme = "HTTP"
0000000000000000000000000000000000000000;;		// URISchemeHTTPS means that the scheme used will be https://
0000000000000000000000000000000000000000;;		URISchemeHTTPS URIScheme = "HTTPS"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TCPSocketAction describes an action based on opening a socket
0000000000000000000000000000000000000000;;	type TCPSocketAction struct {
0000000000000000000000000000000000000000;;		// Number or name of the port to access on the container.
0000000000000000000000000000000000000000;;		// Number must be in the range 1 to 65535.
0000000000000000000000000000000000000000;;		// Name must be an IANA_SVC_NAME.
0000000000000000000000000000000000000000;;		Port intstr.IntOrString `json:"port" protobuf:"bytes,1,opt,name=port"`
0000000000000000000000000000000000000000;;		// Optional: Host name to connect to, defaults to the pod IP.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Host string `json:"host,omitempty" protobuf:"bytes,2,opt,name=host"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExecAction describes a "run in container" action.
0000000000000000000000000000000000000000;;	type ExecAction struct {
0000000000000000000000000000000000000000;;		// Command is the command line to execute inside the container, the working directory for the
0000000000000000000000000000000000000000;;		// command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
0000000000000000000000000000000000000000;;		// not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
0000000000000000000000000000000000000000;;		// a shell, you need to explicitly call out to that shell.
0000000000000000000000000000000000000000;;		// Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Command []string `json:"command,omitempty" protobuf:"bytes,1,rep,name=command"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Probe describes a health check to be performed against a container to determine whether it is
0000000000000000000000000000000000000000;;	// alive or ready to receive traffic.
0000000000000000000000000000000000000000;;	type Probe struct {
0000000000000000000000000000000000000000;;		// The action taken to determine the health of a container
0000000000000000000000000000000000000000;;		Handler `json:",inline" protobuf:"bytes,1,opt,name=handler"`
0000000000000000000000000000000000000000;;		// Number of seconds after the container has started before liveness probes are initiated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		InitialDelaySeconds int32 `json:"initialDelaySeconds,omitempty" protobuf:"varint,2,opt,name=initialDelaySeconds"`
0000000000000000000000000000000000000000;;		// Number of seconds after which the probe times out.
0000000000000000000000000000000000000000;;		// Defaults to 1 second. Minimum value is 1.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TimeoutSeconds int32 `json:"timeoutSeconds,omitempty" protobuf:"varint,3,opt,name=timeoutSeconds"`
0000000000000000000000000000000000000000;;		// How often (in seconds) to perform the probe.
0000000000000000000000000000000000000000;;		// Default to 10 seconds. Minimum value is 1.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PeriodSeconds int32 `json:"periodSeconds,omitempty" protobuf:"varint,4,opt,name=periodSeconds"`
0000000000000000000000000000000000000000;;		// Minimum consecutive successes for the probe to be considered successful after having failed.
0000000000000000000000000000000000000000;;		// Defaults to 1. Must be 1 for liveness. Minimum value is 1.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SuccessThreshold int32 `json:"successThreshold,omitempty" protobuf:"varint,5,opt,name=successThreshold"`
0000000000000000000000000000000000000000;;		// Minimum consecutive failures for the probe to be considered failed after having succeeded.
0000000000000000000000000000000000000000;;		// Defaults to 3. Minimum value is 1.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FailureThreshold int32 `json:"failureThreshold,omitempty" protobuf:"varint,6,opt,name=failureThreshold"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PullPolicy describes a policy for if/when to pull a container image
0000000000000000000000000000000000000000;;	type PullPolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PullAlways means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
0000000000000000000000000000000000000000;;		PullAlways PullPolicy = "Always"
0000000000000000000000000000000000000000;;		// PullNever means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present
0000000000000000000000000000000000000000;;		PullNever PullPolicy = "Never"
0000000000000000000000000000000000000000;;		// PullIfNotPresent means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
0000000000000000000000000000000000000000;;		PullIfNotPresent PullPolicy = "IfNotPresent"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TerminationMessagePolicy describes how termination messages are retrieved from a container.
0000000000000000000000000000000000000000;;	type TerminationMessagePolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// TerminationMessageReadFile is the default behavior and will set the container status message to
0000000000000000000000000000000000000000;;		// the contents of the container's terminationMessagePath when the container exits.
0000000000000000000000000000000000000000;;		TerminationMessageReadFile TerminationMessagePolicy = "File"
0000000000000000000000000000000000000000;;		// TerminationMessageFallbackToLogsOnError will read the most recent contents of the container logs
0000000000000000000000000000000000000000;;		// for the container status message when the container exits with an error and the
0000000000000000000000000000000000000000;;		// terminationMessagePath has no contents.
0000000000000000000000000000000000000000;;		TerminationMessageFallbackToLogsOnError TerminationMessagePolicy = "FallbackToLogsOnError"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Capability represent POSIX capabilities type
0000000000000000000000000000000000000000;;	type Capability string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds and removes POSIX capabilities from running containers.
0000000000000000000000000000000000000000;;	type Capabilities struct {
0000000000000000000000000000000000000000;;		// Added capabilities
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Add []Capability `json:"add,omitempty" protobuf:"bytes,1,rep,name=add,casttype=Capability"`
0000000000000000000000000000000000000000;;		// Removed capabilities
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Drop []Capability `json:"drop,omitempty" protobuf:"bytes,2,rep,name=drop,casttype=Capability"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceRequirements describes the compute resource requirements.
0000000000000000000000000000000000000000;;	type ResourceRequirements struct {
0000000000000000000000000000000000000000;;		// Limits describes the maximum amount of compute resources allowed.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Limits ResourceList `json:"limits,omitempty" protobuf:"bytes,1,rep,name=limits,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;		// Requests describes the minimum amount of compute resources required.
0000000000000000000000000000000000000000;;		// If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
0000000000000000000000000000000000000000;;		// otherwise to an implementation-defined value.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Requests ResourceList `json:"requests,omitempty" protobuf:"bytes,2,rep,name=requests,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// TerminationMessagePathDefault means the default path to capture the application termination message running in a container
0000000000000000000000000000000000000000;;		TerminationMessagePathDefault string = "/dev/termination-log"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A single application container that you want to run within a pod.
0000000000000000000000000000000000000000;;	type Container struct {
0000000000000000000000000000000000000000;;		// Name of the container specified as a DNS_LABEL.
0000000000000000000000000000000000000000;;		// Each container in a pod must have a unique name (DNS_LABEL).
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// Docker image name.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/containers/images
0000000000000000000000000000000000000000;;		Image string `json:"image" protobuf:"bytes,2,opt,name=image"`
0000000000000000000000000000000000000000;;		// Entrypoint array. Not executed within a shell.
0000000000000000000000000000000000000000;;		// The docker image's ENTRYPOINT is used if this is not provided.
0000000000000000000000000000000000000000;;		// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
0000000000000000000000000000000000000000;;		// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
0000000000000000000000000000000000000000;;		// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
0000000000000000000000000000000000000000;;		// regardless of whether the variable exists or not.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Command []string `json:"command,omitempty" protobuf:"bytes,3,rep,name=command"`
0000000000000000000000000000000000000000;;		// Arguments to the entrypoint.
0000000000000000000000000000000000000000;;		// The docker image's CMD is used if this is not provided.
0000000000000000000000000000000000000000;;		// Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
0000000000000000000000000000000000000000;;		// cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax
0000000000000000000000000000000000000000;;		// can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,
0000000000000000000000000000000000000000;;		// regardless of whether the variable exists or not.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Args []string `json:"args,omitempty" protobuf:"bytes,4,rep,name=args"`
0000000000000000000000000000000000000000;;		// Container's working directory.
0000000000000000000000000000000000000000;;		// If not specified, the container runtime's default will be used, which
0000000000000000000000000000000000000000;;		// might be configured in the container image.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		WorkingDir string `json:"workingDir,omitempty" protobuf:"bytes,5,opt,name=workingDir"`
0000000000000000000000000000000000000000;;		// List of ports to expose from the container. Exposing a port here gives
0000000000000000000000000000000000000000;;		// the system additional information about the network connections a
0000000000000000000000000000000000000000;;		// container uses, but is primarily informational. Not specifying a port here
0000000000000000000000000000000000000000;;		// DOES NOT prevent that port from being exposed. Any port which is
0000000000000000000000000000000000000000;;		// listening on the default "0.0.0.0" address inside a container will be
0000000000000000000000000000000000000000;;		// accessible from the network.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=containerPort
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Ports []ContainerPort `json:"ports,omitempty" patchStrategy:"merge" patchMergeKey:"containerPort" protobuf:"bytes,6,rep,name=ports"`
0000000000000000000000000000000000000000;;		// List of sources to populate environment variables in the container.
0000000000000000000000000000000000000000;;		// The keys defined within a source must be a C_IDENTIFIER. All invalid keys
0000000000000000000000000000000000000000;;		// will be reported as an event when the container is starting. When a key exists in multiple
0000000000000000000000000000000000000000;;		// sources, the value associated with the last source will take precedence.
0000000000000000000000000000000000000000;;		// Values defined by an Env with a duplicate key will take precedence.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		EnvFrom []EnvFromSource `json:"envFrom,omitempty" protobuf:"bytes,19,rep,name=envFrom"`
0000000000000000000000000000000000000000;;		// List of environment variables to set in the container.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=name
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Env []EnvVar `json:"env,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,7,rep,name=env"`
0000000000000000000000000000000000000000;;		// Compute Resources required by this container.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Resources ResourceRequirements `json:"resources,omitempty" protobuf:"bytes,8,opt,name=resources"`
0000000000000000000000000000000000000000;;		// Pod volumes to mount into the container's filesystem.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=mountPath
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		VolumeMounts []VolumeMount `json:"volumeMounts,omitempty" patchStrategy:"merge" patchMergeKey:"mountPath" protobuf:"bytes,9,rep,name=volumeMounts"`
0000000000000000000000000000000000000000;;		// Periodic probe of container liveness.
0000000000000000000000000000000000000000;;		// Container will be restarted if the probe fails.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LivenessProbe *Probe `json:"livenessProbe,omitempty" protobuf:"bytes,10,opt,name=livenessProbe"`
0000000000000000000000000000000000000000;;		// Periodic probe of container service readiness.
0000000000000000000000000000000000000000;;		// Container will be removed from service endpoints if the probe fails.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadinessProbe *Probe `json:"readinessProbe,omitempty" protobuf:"bytes,11,opt,name=readinessProbe"`
0000000000000000000000000000000000000000;;		// Actions that the management system should take in response to container lifecycle events.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Lifecycle *Lifecycle `json:"lifecycle,omitempty" protobuf:"bytes,12,opt,name=lifecycle"`
0000000000000000000000000000000000000000;;		// Optional: Path at which the file to which the container's termination message
0000000000000000000000000000000000000000;;		// will be written is mounted into the container's filesystem.
0000000000000000000000000000000000000000;;		// Message written is intended to be brief final status, such as an assertion failure message.
0000000000000000000000000000000000000000;;		// Will be truncated by the node if greater than 4096 bytes. The total message length across
0000000000000000000000000000000000000000;;		// all containers will be limited to 12kb.
0000000000000000000000000000000000000000;;		// Defaults to /dev/termination-log.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TerminationMessagePath string `json:"terminationMessagePath,omitempty" protobuf:"bytes,13,opt,name=terminationMessagePath"`
0000000000000000000000000000000000000000;;		// Indicate how the termination message should be populated. File will use the contents of
0000000000000000000000000000000000000000;;		// terminationMessagePath to populate the container status message on both success and failure.
0000000000000000000000000000000000000000;;		// FallbackToLogsOnError will use the last chunk of container log output if the termination
0000000000000000000000000000000000000000;;		// message file is empty and the container exited with an error.
0000000000000000000000000000000000000000;;		// The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
0000000000000000000000000000000000000000;;		// Defaults to File.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TerminationMessagePolicy TerminationMessagePolicy `json:"terminationMessagePolicy,omitempty" protobuf:"bytes,20,opt,name=terminationMessagePolicy,casttype=TerminationMessagePolicy"`
0000000000000000000000000000000000000000;;		// Image pull policy.
0000000000000000000000000000000000000000;;		// One of Always, Never, IfNotPresent.
0000000000000000000000000000000000000000;;		// Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ImagePullPolicy PullPolicy `json:"imagePullPolicy,omitempty" protobuf:"bytes,14,opt,name=imagePullPolicy,casttype=PullPolicy"`
0000000000000000000000000000000000000000;;		// Security options the pod should run with.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/policy/security-context/
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/design-proposals/security_context.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecurityContext *SecurityContext `json:"securityContext,omitempty" protobuf:"bytes,15,opt,name=securityContext"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Variables for interactive containers, these have very specialized use-cases (e.g. debugging)
0000000000000000000000000000000000000000;;		// and shouldn't be used for general purpose containers.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether this container should allocate a buffer for stdin in the container runtime. If this
0000000000000000000000000000000000000000;;		// is not set, reads from stdin in the container will always result in EOF.
0000000000000000000000000000000000000000;;		// Default is false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stdin bool `json:"stdin,omitempty" protobuf:"varint,16,opt,name=stdin"`
0000000000000000000000000000000000000000;;		// Whether the container runtime should close the stdin channel after it has been opened by
0000000000000000000000000000000000000000;;		// a single attach. When stdin is true the stdin stream will remain open across multiple attach
0000000000000000000000000000000000000000;;		// sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
0000000000000000000000000000000000000000;;		// first client attaches to stdin, and then remains open and accepts data until the client disconnects,
0000000000000000000000000000000000000000;;		// at which time stdin is closed and remains closed until the container is restarted. If this
0000000000000000000000000000000000000000;;		// flag is false, a container processes that reads from stdin will never receive an EOF.
0000000000000000000000000000000000000000;;		// Default is false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StdinOnce bool `json:"stdinOnce,omitempty" protobuf:"varint,17,opt,name=stdinOnce"`
0000000000000000000000000000000000000000;;		// Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
0000000000000000000000000000000000000000;;		// Default is false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TTY bool `json:"tty,omitempty" protobuf:"varint,18,opt,name=tty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler defines a specific action that should be taken
0000000000000000000000000000000000000000;;	// TODO: pass structured data to these actions, and document that data here.
0000000000000000000000000000000000000000;;	type Handler struct {
0000000000000000000000000000000000000000;;		// One and only one of the following should be specified.
0000000000000000000000000000000000000000;;		// Exec specifies the action to take.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Exec *ExecAction `json:"exec,omitempty" protobuf:"bytes,1,opt,name=exec"`
0000000000000000000000000000000000000000;;		// HTTPGet specifies the http request to perform.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HTTPGet *HTTPGetAction `json:"httpGet,omitempty" protobuf:"bytes,2,opt,name=httpGet"`
0000000000000000000000000000000000000000;;		// TCPSocket specifies an action involving a TCP port.
0000000000000000000000000000000000000000;;		// TCP hooks not yet supported
0000000000000000000000000000000000000000;;		// TODO: implement a realistic TCP lifecycle hook
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TCPSocket *TCPSocketAction `json:"tcpSocket,omitempty" protobuf:"bytes,3,opt,name=tcpSocket"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lifecycle describes actions that the management system should take in response to container lifecycle
0000000000000000000000000000000000000000;;	// events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
0000000000000000000000000000000000000000;;	// until the action is complete, unless the container process fails, in which case the handler is aborted.
0000000000000000000000000000000000000000;;	type Lifecycle struct {
0000000000000000000000000000000000000000;;		// PostStart is called immediately after a container is created. If the handler fails,
0000000000000000000000000000000000000000;;		// the container is terminated and restarted according to its restart policy.
0000000000000000000000000000000000000000;;		// Other management of the container blocks until the hook completes.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PostStart *Handler `json:"postStart,omitempty" protobuf:"bytes,1,opt,name=postStart"`
0000000000000000000000000000000000000000;;		// PreStop is called immediately before a container is terminated.
0000000000000000000000000000000000000000;;		// The container is terminated after the handler completes.
0000000000000000000000000000000000000000;;		// The reason for termination is passed to the handler.
0000000000000000000000000000000000000000;;		// Regardless of the outcome of the handler, the container is eventually terminated.
0000000000000000000000000000000000000000;;		// Other management of the container blocks until the hook completes.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreStop *Handler `json:"preStop,omitempty" protobuf:"bytes,2,opt,name=preStop"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ConditionStatus string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid condition statuses. "ConditionTrue" means a resource is in the condition.
0000000000000000000000000000000000000000;;	// "ConditionFalse" means a resource is not in the condition. "ConditionUnknown" means kubernetes
0000000000000000000000000000000000000000;;	// can't decide if a resource is in the condition or not. In the future, we could add other
0000000000000000000000000000000000000000;;	// intermediate conditions, e.g. ConditionDegraded.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ConditionTrue    ConditionStatus = "True"
0000000000000000000000000000000000000000;;		ConditionFalse   ConditionStatus = "False"
0000000000000000000000000000000000000000;;		ConditionUnknown ConditionStatus = "Unknown"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerStateWaiting is a waiting state of a container.
0000000000000000000000000000000000000000;;	type ContainerStateWaiting struct {
0000000000000000000000000000000000000000;;		// (brief) reason the container is not yet running.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string `json:"reason,omitempty" protobuf:"bytes,1,opt,name=reason"`
0000000000000000000000000000000000000000;;		// Message regarding why the container is not yet running.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,2,opt,name=message"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerStateRunning is a running state of a container.
0000000000000000000000000000000000000000;;	type ContainerStateRunning struct {
0000000000000000000000000000000000000000;;		// Time at which the container was last (re-)started
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StartedAt metav1.Time `json:"startedAt,omitempty" protobuf:"bytes,1,opt,name=startedAt"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerStateTerminated is a terminated state of a container.
0000000000000000000000000000000000000000;;	type ContainerStateTerminated struct {
0000000000000000000000000000000000000000;;		// Exit status from the last termination of the container
0000000000000000000000000000000000000000;;		ExitCode int32 `json:"exitCode" protobuf:"varint,1,opt,name=exitCode"`
0000000000000000000000000000000000000000;;		// Signal from the last termination of the container
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Signal int32 `json:"signal,omitempty" protobuf:"varint,2,opt,name=signal"`
0000000000000000000000000000000000000000;;		// (brief) reason from the last termination of the container
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string `json:"reason,omitempty" protobuf:"bytes,3,opt,name=reason"`
0000000000000000000000000000000000000000;;		// Message regarding the last termination of the container
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,4,opt,name=message"`
0000000000000000000000000000000000000000;;		// Time at which previous execution of the container started
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StartedAt metav1.Time `json:"startedAt,omitempty" protobuf:"bytes,5,opt,name=startedAt"`
0000000000000000000000000000000000000000;;		// Time at which the container last terminated
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FinishedAt metav1.Time `json:"finishedAt,omitempty" protobuf:"bytes,6,opt,name=finishedAt"`
0000000000000000000000000000000000000000;;		// Container's ID in the format 'docker://<container_id>'
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ContainerID string `json:"containerID,omitempty" protobuf:"bytes,7,opt,name=containerID"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerState holds a possible state of container.
0000000000000000000000000000000000000000;;	// Only one of its members may be specified.
0000000000000000000000000000000000000000;;	// If none of them is specified, the default one is ContainerStateWaiting.
0000000000000000000000000000000000000000;;	type ContainerState struct {
0000000000000000000000000000000000000000;;		// Details about a waiting container
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Waiting *ContainerStateWaiting `json:"waiting,omitempty" protobuf:"bytes,1,opt,name=waiting"`
0000000000000000000000000000000000000000;;		// Details about a running container
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Running *ContainerStateRunning `json:"running,omitempty" protobuf:"bytes,2,opt,name=running"`
0000000000000000000000000000000000000000;;		// Details about a terminated container
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Terminated *ContainerStateTerminated `json:"terminated,omitempty" protobuf:"bytes,3,opt,name=terminated"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerStatus contains details for the current status of this container.
0000000000000000000000000000000000000000;;	type ContainerStatus struct {
0000000000000000000000000000000000000000;;		// This must be a DNS_LABEL. Each container in a pod must have a unique name.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// Details about the container's current condition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		State ContainerState `json:"state,omitempty" protobuf:"bytes,2,opt,name=state"`
0000000000000000000000000000000000000000;;		// Details about the container's last termination condition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTerminationState ContainerState `json:"lastState,omitempty" protobuf:"bytes,3,opt,name=lastState"`
0000000000000000000000000000000000000000;;		// Specifies whether the container has passed its readiness probe.
0000000000000000000000000000000000000000;;		Ready bool `json:"ready" protobuf:"varint,4,opt,name=ready"`
0000000000000000000000000000000000000000;;		// The number of times the container has been restarted, currently based on
0000000000000000000000000000000000000000;;		// the number of dead containers that have not yet been removed.
0000000000000000000000000000000000000000;;		// Note that this is calculated from dead containers. But those containers are subject to
0000000000000000000000000000000000000000;;		// garbage collection. This value will get capped at 5 by GC.
0000000000000000000000000000000000000000;;		RestartCount int32 `json:"restartCount" protobuf:"varint,5,opt,name=restartCount"`
0000000000000000000000000000000000000000;;		// The image the container is running.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/containers/images
0000000000000000000000000000000000000000;;		// TODO(dchen1107): Which image the container is running with?
0000000000000000000000000000000000000000;;		Image string `json:"image" protobuf:"bytes,6,opt,name=image"`
0000000000000000000000000000000000000000;;		// ImageID of the container's image.
0000000000000000000000000000000000000000;;		ImageID string `json:"imageID" protobuf:"bytes,7,opt,name=imageID"`
0000000000000000000000000000000000000000;;		// Container's ID in the format 'docker://<container_id>'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ContainerID string `json:"containerID,omitempty" protobuf:"bytes,8,opt,name=containerID"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodPhase is a label for the condition of a pod at the current time.
0000000000000000000000000000000000000000;;	type PodPhase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the valid statuses of pods.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PodPending means the pod has been accepted by the system, but one or more of the containers
0000000000000000000000000000000000000000;;		// has not been started. This includes time before being bound to a node, as well as time spent
0000000000000000000000000000000000000000;;		// pulling images onto the host.
0000000000000000000000000000000000000000;;		PodPending PodPhase = "Pending"
0000000000000000000000000000000000000000;;		// PodRunning means the pod has been bound to a node and all of the containers have been started.
0000000000000000000000000000000000000000;;		// At least one container is still running or is in the process of being restarted.
0000000000000000000000000000000000000000;;		PodRunning PodPhase = "Running"
0000000000000000000000000000000000000000;;		// PodSucceeded means that all containers in the pod have voluntarily terminated
0000000000000000000000000000000000000000;;		// with a container exit code of 0, and the system is not going to restart any of these containers.
0000000000000000000000000000000000000000;;		PodSucceeded PodPhase = "Succeeded"
0000000000000000000000000000000000000000;;		// PodFailed means that all containers in the pod have terminated, and at least one container has
0000000000000000000000000000000000000000;;		// terminated in a failure (exited with a non-zero exit code or was stopped by the system).
0000000000000000000000000000000000000000;;		PodFailed PodPhase = "Failed"
0000000000000000000000000000000000000000;;		// PodUnknown means that for some reason the state of the pod could not be obtained, typically due
0000000000000000000000000000000000000000;;		// to an error in communicating with the host of the pod.
0000000000000000000000000000000000000000;;		PodUnknown PodPhase = "Unknown"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodConditionType is a valid value for PodCondition.Type
0000000000000000000000000000000000000000;;	type PodConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid conditions of pod.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PodScheduled represents status of the scheduling process for this pod.
0000000000000000000000000000000000000000;;		PodScheduled PodConditionType = "PodScheduled"
0000000000000000000000000000000000000000;;		// PodReady means the pod is able to service requests and should be added to the
0000000000000000000000000000000000000000;;		// load balancing pools of all matching services.
0000000000000000000000000000000000000000;;		PodReady PodConditionType = "Ready"
0000000000000000000000000000000000000000;;		// PodInitialized means that all init containers in the pod have started successfully.
0000000000000000000000000000000000000000;;		PodInitialized PodConditionType = "Initialized"
0000000000000000000000000000000000000000;;		// PodReasonUnschedulable reason in PodScheduled PodCondition means that the scheduler
0000000000000000000000000000000000000000;;		// can't schedule the pod right now, for example due to insufficient resources in the cluster.
0000000000000000000000000000000000000000;;		PodReasonUnschedulable = "Unschedulable"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodCondition contains details for the current condition of this pod.
0000000000000000000000000000000000000000;;	type PodCondition struct {
0000000000000000000000000000000000000000;;		// Type is the type of the condition.
0000000000000000000000000000000000000000;;		// Currently only Ready.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
0000000000000000000000000000000000000000;;		Type PodConditionType `json:"type" protobuf:"bytes,1,opt,name=type,casttype=PodConditionType"`
0000000000000000000000000000000000000000;;		// Status is the status of the condition.
0000000000000000000000000000000000000000;;		// Can be True, False, Unknown.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
0000000000000000000000000000000000000000;;		Status ConditionStatus `json:"status" protobuf:"bytes,2,opt,name=status,casttype=ConditionStatus"`
0000000000000000000000000000000000000000;;		// Last time we probed the condition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastProbeTime metav1.Time `json:"lastProbeTime,omitempty" protobuf:"bytes,3,opt,name=lastProbeTime"`
0000000000000000000000000000000000000000;;		// Last time the condition transitioned from one status to another.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTransitionTime metav1.Time `json:"lastTransitionTime,omitempty" protobuf:"bytes,4,opt,name=lastTransitionTime"`
0000000000000000000000000000000000000000;;		// Unique, one-word, CamelCase reason for the condition's last transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string `json:"reason,omitempty" protobuf:"bytes,5,opt,name=reason"`
0000000000000000000000000000000000000000;;		// Human-readable message indicating details about last transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,6,opt,name=message"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RestartPolicy describes how the container should be restarted.
0000000000000000000000000000000000000000;;	// Only one of the following restart policies may be specified.
0000000000000000000000000000000000000000;;	// If none of the following policies is specified, the default one
0000000000000000000000000000000000000000;;	// is RestartPolicyAlways.
0000000000000000000000000000000000000000;;	type RestartPolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		RestartPolicyAlways    RestartPolicy = "Always"
0000000000000000000000000000000000000000;;		RestartPolicyOnFailure RestartPolicy = "OnFailure"
0000000000000000000000000000000000000000;;		RestartPolicyNever     RestartPolicy = "Never"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DNSPolicy defines how a pod's DNS will be configured.
0000000000000000000000000000000000000000;;	type DNSPolicy string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DNSClusterFirstWithHostNet indicates that the pod should use cluster DNS
0000000000000000000000000000000000000000;;		// first, if it is available, then fall back on the default
0000000000000000000000000000000000000000;;		// (as determined by kubelet) DNS settings.
0000000000000000000000000000000000000000;;		DNSClusterFirstWithHostNet DNSPolicy = "ClusterFirstWithHostNet"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DNSClusterFirst indicates that the pod should use cluster DNS
0000000000000000000000000000000000000000;;		// first unless hostNetwork is true, if it is available, then
0000000000000000000000000000000000000000;;		// fall back on the default (as determined by kubelet) DNS settings.
0000000000000000000000000000000000000000;;		DNSClusterFirst DNSPolicy = "ClusterFirst"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DNSDefault indicates that the pod should use the default (as
0000000000000000000000000000000000000000;;		// determined by kubelet) DNS settings.
0000000000000000000000000000000000000000;;		DNSDefault DNSPolicy = "Default"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DefaultTerminationGracePeriodSeconds = 30
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A node selector represents the union of the results of one or more label queries
0000000000000000000000000000000000000000;;	// over a set of nodes; that is, it represents the OR of the selectors represented
0000000000000000000000000000000000000000;;	// by the node selector terms.
0000000000000000000000000000000000000000;;	type NodeSelector struct {
0000000000000000000000000000000000000000;;		//Required. A list of node selector terms. The terms are ORed.
0000000000000000000000000000000000000000;;		NodeSelectorTerms []NodeSelectorTerm `json:"nodeSelectorTerms" protobuf:"bytes,1,rep,name=nodeSelectorTerms"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A null or empty node selector term matches no objects.
0000000000000000000000000000000000000000;;	type NodeSelectorTerm struct {
0000000000000000000000000000000000000000;;		//Required. A list of node selector requirements. The requirements are ANDed.
0000000000000000000000000000000000000000;;		MatchExpressions []NodeSelectorRequirement `json:"matchExpressions" protobuf:"bytes,1,rep,name=matchExpressions"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A node selector requirement is a selector that contains values, a key, and an operator
0000000000000000000000000000000000000000;;	// that relates the key and values.
0000000000000000000000000000000000000000;;	type NodeSelectorRequirement struct {
0000000000000000000000000000000000000000;;		// The label key that the selector applies to.
0000000000000000000000000000000000000000;;		// +patchMergeKey=key
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Key string `json:"key" patchStrategy:"merge" patchMergeKey:"key" protobuf:"bytes,1,opt,name=key"`
0000000000000000000000000000000000000000;;		// Represents a key's relationship to a set of values.
0000000000000000000000000000000000000000;;		// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
0000000000000000000000000000000000000000;;		Operator NodeSelectorOperator `json:"operator" protobuf:"bytes,2,opt,name=operator,casttype=NodeSelectorOperator"`
0000000000000000000000000000000000000000;;		// An array of string values. If the operator is In or NotIn,
0000000000000000000000000000000000000000;;		// the values array must be non-empty. If the operator is Exists or DoesNotExist,
0000000000000000000000000000000000000000;;		// the values array must be empty. If the operator is Gt or Lt, the values
0000000000000000000000000000000000000000;;		// array must have a single element, which will be interpreted as an integer.
0000000000000000000000000000000000000000;;		// This array is replaced during a strategic merge patch.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Values []string `json:"values,omitempty" protobuf:"bytes,3,rep,name=values"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A node selector operator is the set of operators that can be used in
0000000000000000000000000000000000000000;;	// a node selector requirement.
0000000000000000000000000000000000000000;;	type NodeSelectorOperator string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NodeSelectorOpIn           NodeSelectorOperator = "In"
0000000000000000000000000000000000000000;;		NodeSelectorOpNotIn        NodeSelectorOperator = "NotIn"
0000000000000000000000000000000000000000;;		NodeSelectorOpExists       NodeSelectorOperator = "Exists"
0000000000000000000000000000000000000000;;		NodeSelectorOpDoesNotExist NodeSelectorOperator = "DoesNotExist"
0000000000000000000000000000000000000000;;		NodeSelectorOpGt           NodeSelectorOperator = "Gt"
0000000000000000000000000000000000000000;;		NodeSelectorOpLt           NodeSelectorOperator = "Lt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Affinity is a group of affinity scheduling rules.
0000000000000000000000000000000000000000;;	type Affinity struct {
0000000000000000000000000000000000000000;;		// Describes node affinity scheduling rules for the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodeAffinity *NodeAffinity `json:"nodeAffinity,omitempty" protobuf:"bytes,1,opt,name=nodeAffinity"`
0000000000000000000000000000000000000000;;		// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodAffinity *PodAffinity `json:"podAffinity,omitempty" protobuf:"bytes,2,opt,name=podAffinity"`
0000000000000000000000000000000000000000;;		// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodAntiAffinity *PodAntiAffinity `json:"podAntiAffinity,omitempty" protobuf:"bytes,3,opt,name=podAntiAffinity"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pod affinity is a group of inter pod affinity scheduling rules.
0000000000000000000000000000000000000000;;	type PodAffinity struct {
0000000000000000000000000000000000000000;;		// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to a pod label update), the
0000000000000000000000000000000000000000;;		// system will try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// When there are multiple elements, the lists of nodes corresponding to each
0000000000000000000000000000000000000000;;		// podAffinityTerm are intersected, i.e. all terms must be satisfied.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to a pod label update), the
0000000000000000000000000000000000000000;;		// system may or may not try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// When there are multiple elements, the lists of nodes corresponding to each
0000000000000000000000000000000000000000;;		// podAffinityTerm are intersected, i.e. all terms must be satisfied.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,1,rep,name=requiredDuringSchedulingIgnoredDuringExecution"`
0000000000000000000000000000000000000000;;		// The scheduler will prefer to schedule pods to nodes that satisfy
0000000000000000000000000000000000000000;;		// the affinity expressions specified by this field, but it may choose
0000000000000000000000000000000000000000;;		// a node that violates one or more of the expressions. The node that is
0000000000000000000000000000000000000000;;		// most preferred is the one with the greatest sum of weights, i.e.
0000000000000000000000000000000000000000;;		// for each node that meets all of the scheduling requirements (resource
0000000000000000000000000000000000000000;;		// request, requiredDuringScheduling affinity expressions, etc.),
0000000000000000000000000000000000000000;;		// compute a sum by iterating through the elements of this field and adding
0000000000000000000000000000000000000000;;		// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
0000000000000000000000000000000000000000;;		// node(s) with the highest sum are the most preferred.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,2,rep,name=preferredDuringSchedulingIgnoredDuringExecution"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pod anti affinity is a group of inter pod anti affinity scheduling rules.
0000000000000000000000000000000000000000;;	type PodAntiAffinity struct {
0000000000000000000000000000000000000000;;		// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
0000000000000000000000000000000000000000;;		// If the anti-affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the anti-affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to a pod label update), the
0000000000000000000000000000000000000000;;		// system will try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// When there are multiple elements, the lists of nodes corresponding to each
0000000000000000000000000000000000000000;;		// podAffinityTerm are intersected, i.e. all terms must be satisfied.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`
0000000000000000000000000000000000000000;;		// If the anti-affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the anti-affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to a pod label update), the
0000000000000000000000000000000000000000;;		// system may or may not try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// When there are multiple elements, the lists of nodes corresponding to each
0000000000000000000000000000000000000000;;		// podAffinityTerm are intersected, i.e. all terms must be satisfied.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RequiredDuringSchedulingIgnoredDuringExecution []PodAffinityTerm `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,1,rep,name=requiredDuringSchedulingIgnoredDuringExecution"`
0000000000000000000000000000000000000000;;		// The scheduler will prefer to schedule pods to nodes that satisfy
0000000000000000000000000000000000000000;;		// the anti-affinity expressions specified by this field, but it may choose
0000000000000000000000000000000000000000;;		// a node that violates one or more of the expressions. The node that is
0000000000000000000000000000000000000000;;		// most preferred is the one with the greatest sum of weights, i.e.
0000000000000000000000000000000000000000;;		// for each node that meets all of the scheduling requirements (resource
0000000000000000000000000000000000000000;;		// request, requiredDuringScheduling anti-affinity expressions, etc.),
0000000000000000000000000000000000000000;;		// compute a sum by iterating through the elements of this field and adding
0000000000000000000000000000000000000000;;		// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
0000000000000000000000000000000000000000;;		// node(s) with the highest sum are the most preferred.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreferredDuringSchedulingIgnoredDuringExecution []WeightedPodAffinityTerm `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,2,rep,name=preferredDuringSchedulingIgnoredDuringExecution"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
0000000000000000000000000000000000000000;;	type WeightedPodAffinityTerm struct {
0000000000000000000000000000000000000000;;		// weight associated with matching the corresponding podAffinityTerm,
0000000000000000000000000000000000000000;;		// in the range 1-100.
0000000000000000000000000000000000000000;;		Weight int32 `json:"weight" protobuf:"varint,1,opt,name=weight"`
0000000000000000000000000000000000000000;;		// Required. A pod affinity term, associated with the corresponding weight.
0000000000000000000000000000000000000000;;		PodAffinityTerm PodAffinityTerm `json:"podAffinityTerm" protobuf:"bytes,2,opt,name=podAffinityTerm"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Defines a set of pods (namely those matching the labelSelector
0000000000000000000000000000000000000000;;	// relative to the given namespace(s)) that this pod should be
0000000000000000000000000000000000000000;;	// co-located (affinity) or not co-located (anti-affinity) with,
0000000000000000000000000000000000000000;;	// where co-located is defined as running on a node whose value of
0000000000000000000000000000000000000000;;	// the label with key <topologyKey> tches that of any node on which
0000000000000000000000000000000000000000;;	// a pod of the set of pods is running
0000000000000000000000000000000000000000;;	type PodAffinityTerm struct {
0000000000000000000000000000000000000000;;		// A label query over a set of resources, in this case pods.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LabelSelector *metav1.LabelSelector `json:"labelSelector,omitempty" protobuf:"bytes,1,opt,name=labelSelector"`
0000000000000000000000000000000000000000;;		// namespaces specifies which namespaces the labelSelector applies to (matches against);
0000000000000000000000000000000000000000;;		// null or empty list means "this pod's namespace"
0000000000000000000000000000000000000000;;		Namespaces []string `json:"namespaces,omitempty" protobuf:"bytes,2,rep,name=namespaces"`
0000000000000000000000000000000000000000;;		// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
0000000000000000000000000000000000000000;;		// the labelSelector in the specified namespaces, where co-located is defined as running on a node
0000000000000000000000000000000000000000;;		// whose value of the label with key topologyKey matches that of any node on which any of the
0000000000000000000000000000000000000000;;		// selected pods is running.
0000000000000000000000000000000000000000;;		// For PreferredDuringScheduling pod anti-affinity, empty topologyKey is interpreted as "all topologies"
0000000000000000000000000000000000000000;;		// ("all topologies" here means all the topologyKeys indicated by scheduler command-line argument --failure-domains);
0000000000000000000000000000000000000000;;		// for affinity and for RequiredDuringScheduling pod anti-affinity, empty topologyKey is not allowed.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TopologyKey string `json:"topologyKey,omitempty" protobuf:"bytes,3,opt,name=topologyKey"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Node affinity is a group of node affinity scheduling rules.
0000000000000000000000000000000000000000;;	type NodeAffinity struct {
0000000000000000000000000000000000000000;;		// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to an update), the system
0000000000000000000000000000000000000000;;		// will try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// RequiredDuringSchedulingRequiredDuringExecution *NodeSelector `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field are not met at
0000000000000000000000000000000000000000;;		// scheduling time, the pod will not be scheduled onto the node.
0000000000000000000000000000000000000000;;		// If the affinity requirements specified by this field cease to be met
0000000000000000000000000000000000000000;;		// at some point during pod execution (e.g. due to an update), the system
0000000000000000000000000000000000000000;;		// may or may not try to eventually evict the pod from its node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RequiredDuringSchedulingIgnoredDuringExecution *NodeSelector `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,1,opt,name=requiredDuringSchedulingIgnoredDuringExecution"`
0000000000000000000000000000000000000000;;		// The scheduler will prefer to schedule pods to nodes that satisfy
0000000000000000000000000000000000000000;;		// the affinity expressions specified by this field, but it may choose
0000000000000000000000000000000000000000;;		// a node that violates one or more of the expressions. The node that is
0000000000000000000000000000000000000000;;		// most preferred is the one with the greatest sum of weights, i.e.
0000000000000000000000000000000000000000;;		// for each node that meets all of the scheduling requirements (resource
0000000000000000000000000000000000000000;;		// request, requiredDuringScheduling affinity expressions, etc.),
0000000000000000000000000000000000000000;;		// compute a sum by iterating through the elements of this field and adding
0000000000000000000000000000000000000000;;		// "weight" to the sum if the node matches the corresponding matchExpressions; the
0000000000000000000000000000000000000000;;		// node(s) with the highest sum are the most preferred.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreferredDuringSchedulingIgnoredDuringExecution []PreferredSchedulingTerm `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" protobuf:"bytes,2,rep,name=preferredDuringSchedulingIgnoredDuringExecution"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An empty preferred scheduling term matches all objects with implicit weight 0
0000000000000000000000000000000000000000;;	// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
0000000000000000000000000000000000000000;;	type PreferredSchedulingTerm struct {
0000000000000000000000000000000000000000;;		// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
0000000000000000000000000000000000000000;;		Weight int32 `json:"weight" protobuf:"varint,1,opt,name=weight"`
0000000000000000000000000000000000000000;;		// A node selector term, associated with the corresponding weight.
0000000000000000000000000000000000000000;;		Preference NodeSelectorTerm `json:"preference" protobuf:"bytes,2,opt,name=preference"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The node this Taint is attached to has the effect "effect" on
0000000000000000000000000000000000000000;;	// any pod that that does not tolerate the Taint.
0000000000000000000000000000000000000000;;	type Taint struct {
0000000000000000000000000000000000000000;;		// Required. The taint key to be applied to a node.
0000000000000000000000000000000000000000;;		// +patchMergeKey=key
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Key string `json:"key" patchStrategy:"merge" patchMergeKey:"key" protobuf:"bytes,1,opt,name=key"`
0000000000000000000000000000000000000000;;		// Required. The taint value corresponding to the taint key.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Value string `json:"value,omitempty" protobuf:"bytes,2,opt,name=value"`
0000000000000000000000000000000000000000;;		// Required. The effect of the taint on pods
0000000000000000000000000000000000000000;;		// that do not tolerate the taint.
0000000000000000000000000000000000000000;;		// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
0000000000000000000000000000000000000000;;		Effect TaintEffect `json:"effect" protobuf:"bytes,3,opt,name=effect,casttype=TaintEffect"`
0000000000000000000000000000000000000000;;		// TimeAdded represents the time at which the taint was added.
0000000000000000000000000000000000000000;;		// It is only written for NoExecute taints.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TimeAdded metav1.Time `json:"timeAdded,omitempty" protobuf:"bytes,4,opt,name=timeAdded"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TaintEffect string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Do not allow new pods to schedule onto the node unless they tolerate the taint,
0000000000000000000000000000000000000000;;		// but allow all pods submitted to Kubelet without going through the scheduler
0000000000000000000000000000000000000000;;		// to start, and allow all already-running pods to continue running.
0000000000000000000000000000000000000000;;		// Enforced by the scheduler.
0000000000000000000000000000000000000000;;		TaintEffectNoSchedule TaintEffect = "NoSchedule"
0000000000000000000000000000000000000000;;		// Like TaintEffectNoSchedule, but the scheduler tries not to schedule
0000000000000000000000000000000000000000;;		// new pods onto the node, rather than prohibiting new pods from scheduling
0000000000000000000000000000000000000000;;		// onto the node entirely. Enforced by the scheduler.
0000000000000000000000000000000000000000;;		TaintEffectPreferNoSchedule TaintEffect = "PreferNoSchedule"
0000000000000000000000000000000000000000;;		// NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented.
0000000000000000000000000000000000000000;;		// Like TaintEffectNoSchedule, but additionally do not allow pods submitted to
0000000000000000000000000000000000000000;;		// Kubelet without going through the scheduler to start.
0000000000000000000000000000000000000000;;		// Enforced by Kubelet and the scheduler.
0000000000000000000000000000000000000000;;		// TaintEffectNoScheduleNoAdmit TaintEffect = "NoScheduleNoAdmit"
0000000000000000000000000000000000000000;;		// Evict any already-running pods that do not tolerate the taint.
0000000000000000000000000000000000000000;;		// Currently enforced by NodeController.
0000000000000000000000000000000000000000;;		TaintEffectNoExecute TaintEffect = "NoExecute"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The pod this Toleration is attached to tolerates any taint that matches
0000000000000000000000000000000000000000;;	// the triple <key,value,effect> using the matching operator <operator>.
0000000000000000000000000000000000000000;;	type Toleration struct {
0000000000000000000000000000000000000000;;		// Key is the taint key that the toleration applies to. Empty means match all taint keys.
0000000000000000000000000000000000000000;;		// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=key
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Key string `json:"key,omitempty" patchStrategy:"merge" patchMergeKey:"key" protobuf:"bytes,1,opt,name=key"`
0000000000000000000000000000000000000000;;		// Operator represents a key's relationship to the value.
0000000000000000000000000000000000000000;;		// Valid operators are Exists and Equal. Defaults to Equal.
0000000000000000000000000000000000000000;;		// Exists is equivalent to wildcard for value, so that a pod can
0000000000000000000000000000000000000000;;		// tolerate all taints of a particular category.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Operator TolerationOperator `json:"operator,omitempty" protobuf:"bytes,2,opt,name=operator,casttype=TolerationOperator"`
0000000000000000000000000000000000000000;;		// Value is the taint value the toleration matches to.
0000000000000000000000000000000000000000;;		// If the operator is Exists, the value should be empty, otherwise just a regular string.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Value string `json:"value,omitempty" protobuf:"bytes,3,opt,name=value"`
0000000000000000000000000000000000000000;;		// Effect indicates the taint effect to match. Empty means match all taint effects.
0000000000000000000000000000000000000000;;		// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Effect TaintEffect `json:"effect,omitempty" protobuf:"bytes,4,opt,name=effect,casttype=TaintEffect"`
0000000000000000000000000000000000000000;;		// TolerationSeconds represents the period of time the toleration (which must be
0000000000000000000000000000000000000000;;		// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
0000000000000000000000000000000000000000;;		// it is not set, which means tolerate the taint forever (do not evict). Zero and
0000000000000000000000000000000000000000;;		// negative values will be treated as 0 (evict immediately) by the system.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TolerationSeconds *int64 `json:"tolerationSeconds,omitempty" protobuf:"varint,5,opt,name=tolerationSeconds"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A toleration operator is the set of operators that can be used in a toleration.
0000000000000000000000000000000000000000;;	type TolerationOperator string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TolerationOpExists TolerationOperator = "Exists"
0000000000000000000000000000000000000000;;		TolerationOpEqual  TolerationOperator = "Equal"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// This annotation key will be used to contain an array of v1 JSON encoded Containers
0000000000000000000000000000000000000000;;		// for init containers. The annotation will be placed into the internal type and cleared.
0000000000000000000000000000000000000000;;		// This key is only recognized by version >= 1.4.
0000000000000000000000000000000000000000;;		PodInitContainersBetaAnnotationKey = "pod.beta.kubernetes.io/init-containers"
0000000000000000000000000000000000000000;;		// This annotation key will be used to contain an array of v1 JSON encoded Containers
0000000000000000000000000000000000000000;;		// for init containers. The annotation will be placed into the internal type and cleared.
0000000000000000000000000000000000000000;;		// This key is recognized by version >= 1.3. For version 1.4 code, this key
0000000000000000000000000000000000000000;;		// will have its value copied to the beta key.
0000000000000000000000000000000000000000;;		PodInitContainersAnnotationKey = "pod.alpha.kubernetes.io/init-containers"
0000000000000000000000000000000000000000;;		// This annotation key will be used to contain an array of v1 JSON encoded
0000000000000000000000000000000000000000;;		// ContainerStatuses for init containers. The annotation will be placed into the internal
0000000000000000000000000000000000000000;;		// type and cleared. This key is only recognized by version >= 1.4.
0000000000000000000000000000000000000000;;		PodInitContainerStatusesBetaAnnotationKey = "pod.beta.kubernetes.io/init-container-statuses"
0000000000000000000000000000000000000000;;		// This annotation key will be used to contain an array of v1 JSON encoded
0000000000000000000000000000000000000000;;		// ContainerStatuses for init containers. The annotation will be placed into the internal
0000000000000000000000000000000000000000;;		// type and cleared. This key is recognized by version >= 1.3. For version 1.4 code,
0000000000000000000000000000000000000000;;		// this key will have its value copied to the beta key.
0000000000000000000000000000000000000000;;		PodInitContainerStatusesAnnotationKey = "pod.alpha.kubernetes.io/init-container-statuses"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodSpec is a description of a pod.
0000000000000000000000000000000000000000;;	type PodSpec struct {
0000000000000000000000000000000000000000;;		// List of volumes that can be mounted by containers belonging to the pod.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/volumes
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=name
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Volumes []Volume `json:"volumes,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,1,rep,name=volumes"`
0000000000000000000000000000000000000000;;		// List of initialization containers belonging to the pod.
0000000000000000000000000000000000000000;;		// Init containers are executed in order prior to containers being started. If any
0000000000000000000000000000000000000000;;		// init container fails, the pod is considered to have failed and is handled according
0000000000000000000000000000000000000000;;		// to its restartPolicy. The name for an init container or normal container must be
0000000000000000000000000000000000000000;;		// unique among all containers.
0000000000000000000000000000000000000000;;		// Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes.
0000000000000000000000000000000000000000;;		// The resourceRequirements of an init container are taken into account during scheduling
0000000000000000000000000000000000000000;;		// by finding the highest request/limit for each resource type, and then using the max of
0000000000000000000000000000000000000000;;		// of that value or the sum of the normal containers. Limits are applied to init containers
0000000000000000000000000000000000000000;;		// in a similar fashion.
0000000000000000000000000000000000000000;;		// Init containers cannot currently be added or removed.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
0000000000000000000000000000000000000000;;		// +patchMergeKey=name
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		InitContainers []Container `json:"initContainers,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,20,rep,name=initContainers"`
0000000000000000000000000000000000000000;;		// List of containers belonging to the pod.
0000000000000000000000000000000000000000;;		// Containers cannot currently be added or removed.
0000000000000000000000000000000000000000;;		// There must be at least one container in a Pod.
0000000000000000000000000000000000000000;;		// Cannot be updated.
0000000000000000000000000000000000000000;;		// +patchMergeKey=name
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Containers []Container `json:"containers" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,2,rep,name=containers"`
0000000000000000000000000000000000000000;;		// Restart policy for all containers within the pod.
0000000000000000000000000000000000000000;;		// One of Always, OnFailure, Never.
0000000000000000000000000000000000000000;;		// Default to Always.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RestartPolicy RestartPolicy `json:"restartPolicy,omitempty" protobuf:"bytes,3,opt,name=restartPolicy,casttype=RestartPolicy"`
0000000000000000000000000000000000000000;;		// Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
0000000000000000000000000000000000000000;;		// Value must be non-negative integer. The value zero indicates delete immediately.
0000000000000000000000000000000000000000;;		// If this value is nil, the default grace period will be used instead.
0000000000000000000000000000000000000000;;		// The grace period is the duration in seconds after the processes running in the pod are sent
0000000000000000000000000000000000000000;;		// a termination signal and the time when the processes are forcibly halted with a kill signal.
0000000000000000000000000000000000000000;;		// Set this value longer than the expected cleanup time for your process.
0000000000000000000000000000000000000000;;		// Defaults to 30 seconds.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TerminationGracePeriodSeconds *int64 `json:"terminationGracePeriodSeconds,omitempty" protobuf:"varint,4,opt,name=terminationGracePeriodSeconds"`
0000000000000000000000000000000000000000;;		// Optional duration in seconds the pod may be active on the node relative to
0000000000000000000000000000000000000000;;		// StartTime before the system will actively try to mark it failed and kill associated containers.
0000000000000000000000000000000000000000;;		// Value must be a positive integer.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ActiveDeadlineSeconds *int64 `json:"activeDeadlineSeconds,omitempty" protobuf:"varint,5,opt,name=activeDeadlineSeconds"`
0000000000000000000000000000000000000000;;		// Set DNS policy for containers within the pod.
0000000000000000000000000000000000000000;;		// One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'.
0000000000000000000000000000000000000000;;		// Defaults to "ClusterFirst".
0000000000000000000000000000000000000000;;		// To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DNSPolicy DNSPolicy `json:"dnsPolicy,omitempty" protobuf:"bytes,6,opt,name=dnsPolicy,casttype=DNSPolicy"`
0000000000000000000000000000000000000000;;		// NodeSelector is a selector which must be true for the pod to fit on a node.
0000000000000000000000000000000000000000;;		// Selector which must match a node's labels for the pod to be scheduled on that node.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodeSelector map[string]string `json:"nodeSelector,omitempty" protobuf:"bytes,7,rep,name=nodeSelector"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ServiceAccountName string `json:"serviceAccountName,omitempty" protobuf:"bytes,8,opt,name=serviceAccountName"`
0000000000000000000000000000000000000000;;		// DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
0000000000000000000000000000000000000000;;		// Deprecated: Use serviceAccountName instead.
0000000000000000000000000000000000000000;;		// +k8s:conversion-gen=false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DeprecatedServiceAccount string `json:"serviceAccount,omitempty" protobuf:"bytes,9,opt,name=serviceAccount"`
0000000000000000000000000000000000000000;;		// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AutomountServiceAccountToken *bool `json:"automountServiceAccountToken,omitempty" protobuf:"varint,21,opt,name=automountServiceAccountToken"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
0000000000000000000000000000000000000000;;		// the scheduler simply schedules this pod onto that node, assuming that it fits resource
0000000000000000000000000000000000000000;;		// requirements.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodeName string `json:"nodeName,omitempty" protobuf:"bytes,10,opt,name=nodeName"`
0000000000000000000000000000000000000000;;		// Host networking requested for this pod. Use the host's network namespace.
0000000000000000000000000000000000000000;;		// If this option is set, the ports that will be used must be specified.
0000000000000000000000000000000000000000;;		// Default to false.
0000000000000000000000000000000000000000;;		// +k8s:conversion-gen=false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostNetwork bool `json:"hostNetwork,omitempty" protobuf:"varint,11,opt,name=hostNetwork"`
0000000000000000000000000000000000000000;;		// Use the host's pid namespace.
0000000000000000000000000000000000000000;;		// Optional: Default to false.
0000000000000000000000000000000000000000;;		// +k8s:conversion-gen=false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostPID bool `json:"hostPID,omitempty" protobuf:"varint,12,opt,name=hostPID"`
0000000000000000000000000000000000000000;;		// Use the host's ipc namespace.
0000000000000000000000000000000000000000;;		// Optional: Default to false.
0000000000000000000000000000000000000000;;		// +k8s:conversion-gen=false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostIPC bool `json:"hostIPC,omitempty" protobuf:"varint,13,opt,name=hostIPC"`
0000000000000000000000000000000000000000;;		// SecurityContext holds pod-level security attributes and common container settings.
0000000000000000000000000000000000000000;;		// Optional: Defaults to empty.  See type description for default values of each field.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SecurityContext *PodSecurityContext `json:"securityContext,omitempty" protobuf:"bytes,14,opt,name=securityContext"`
0000000000000000000000000000000000000000;;		// ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
0000000000000000000000000000000000000000;;		// If specified, these secrets will be passed to individual puller implementations for them to use. For example,
0000000000000000000000000000000000000000;;		// in the case of docker, only DockerConfig type secrets are honored.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=name
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		ImagePullSecrets []LocalObjectReference `json:"imagePullSecrets,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,15,rep,name=imagePullSecrets"`
0000000000000000000000000000000000000000;;		// Specifies the hostname of the Pod
0000000000000000000000000000000000000000;;		// If not specified, the pod's hostname will be set to a system-defined value.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hostname string `json:"hostname,omitempty" protobuf:"bytes,16,opt,name=hostname"`
0000000000000000000000000000000000000000;;		// If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
0000000000000000000000000000000000000000;;		// If not specified, the pod will not have a domainname at all.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Subdomain string `json:"subdomain,omitempty" protobuf:"bytes,17,opt,name=subdomain"`
0000000000000000000000000000000000000000;;		// If specified, the pod's scheduling constraints
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Affinity *Affinity `json:"affinity,omitempty" protobuf:"bytes,18,opt,name=affinity"`
0000000000000000000000000000000000000000;;		// If specified, the pod will be dispatched by specified scheduler.
0000000000000000000000000000000000000000;;		// If not specified, the pod will be dispatched by default scheduler.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SchedulerName string `json:"schedulerName,omitempty" protobuf:"bytes,19,opt,name=schedulerName"`
0000000000000000000000000000000000000000;;		// If specified, the pod's tolerations.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Tolerations []Toleration `json:"tolerations,omitempty" protobuf:"bytes,22,opt,name=tolerations"`
0000000000000000000000000000000000000000;;		// HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
0000000000000000000000000000000000000000;;		// file if specified. This is only valid for non-hostNetwork pods.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=ip
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		HostAliases []HostAlias `json:"hostAliases,omitempty" patchStrategy:"merge" patchMergeKey:"ip" protobuf:"bytes,23,rep,name=hostAliases"`
0000000000000000000000000000000000000000;;		// If specified, indicates the pod's priority. "SYSTEM" is a special keyword
0000000000000000000000000000000000000000;;		// which indicates the highest priority. Any other name must be defined by
0000000000000000000000000000000000000000;;		// creating a PriorityClass object with that name.
0000000000000000000000000000000000000000;;		// If not specified, the pod priority will be default or zero if there is no
0000000000000000000000000000000000000000;;		// default.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PriorityClassName string `json:"priorityClassName,omitempty" protobuf:"bytes,24,opt,name=priorityClassName"`
0000000000000000000000000000000000000000;;		// The priority value. Various system components use this field to find the
0000000000000000000000000000000000000000;;		// priority of the pod. When Priority Admission Controller is enabled, it
0000000000000000000000000000000000000000;;		// prevents users from setting this field. The admission controller populates
0000000000000000000000000000000000000000;;		// this field from PriorityClassName.
0000000000000000000000000000000000000000;;		// The higher the value, the higher the priority.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Priority *int32 `json:"priority,omitempty" protobuf:"bytes,25,opt,name=priority"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
0000000000000000000000000000000000000000;;	// pod's hosts file.
0000000000000000000000000000000000000000;;	type HostAlias struct {
0000000000000000000000000000000000000000;;		// IP address of the host file entry.
0000000000000000000000000000000000000000;;		IP string `json:"ip,omitempty" protobuf:"bytes,1,opt,name=ip"`
0000000000000000000000000000000000000000;;		// Hostnames for the above IP address.
0000000000000000000000000000000000000000;;		Hostnames []string `json:"hostnames,omitempty" protobuf:"bytes,2,rep,name=hostnames"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodSecurityContext holds pod-level security attributes and common container settings.
0000000000000000000000000000000000000000;;	// Some fields are also present in container.securityContext.  Field values of
0000000000000000000000000000000000000000;;	// container.securityContext take precedence over field values of PodSecurityContext.
0000000000000000000000000000000000000000;;	type PodSecurityContext struct {
0000000000000000000000000000000000000000;;		// The SELinux context to be applied to all containers.
0000000000000000000000000000000000000000;;		// If unspecified, the container runtime will allocate a random SELinux context for each
0000000000000000000000000000000000000000;;		// container.  May also be set in SecurityContext.  If set in
0000000000000000000000000000000000000000;;		// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
0000000000000000000000000000000000000000;;		// takes precedence for that container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SELinuxOptions *SELinuxOptions `json:"seLinuxOptions,omitempty" protobuf:"bytes,1,opt,name=seLinuxOptions"`
0000000000000000000000000000000000000000;;		// The UID to run the entrypoint of the container process.
0000000000000000000000000000000000000000;;		// Defaults to user specified in image metadata if unspecified.
0000000000000000000000000000000000000000;;		// May also be set in SecurityContext.  If set in both SecurityContext and
0000000000000000000000000000000000000000;;		// PodSecurityContext, the value specified in SecurityContext takes precedence
0000000000000000000000000000000000000000;;		// for that container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RunAsUser *int64 `json:"runAsUser,omitempty" protobuf:"varint,2,opt,name=runAsUser"`
0000000000000000000000000000000000000000;;		// Indicates that the container must run as a non-root user.
0000000000000000000000000000000000000000;;		// If true, the Kubelet will validate the image at runtime to ensure that it
0000000000000000000000000000000000000000;;		// does not run as UID 0 (root) and fail to start the container if it does.
0000000000000000000000000000000000000000;;		// If unset or false, no such validation will be performed.
0000000000000000000000000000000000000000;;		// May also be set in SecurityContext.  If set in both SecurityContext and
0000000000000000000000000000000000000000;;		// PodSecurityContext, the value specified in SecurityContext takes precedence.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" protobuf:"varint,3,opt,name=runAsNonRoot"`
0000000000000000000000000000000000000000;;		// A list of groups applied to the first process run in each container, in addition
0000000000000000000000000000000000000000;;		// to the container's primary GID.  If unspecified, no groups will be added to
0000000000000000000000000000000000000000;;		// any container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SupplementalGroups []int64 `json:"supplementalGroups,omitempty" protobuf:"varint,4,rep,name=supplementalGroups"`
0000000000000000000000000000000000000000;;		// A special supplemental group that applies to all containers in a pod.
0000000000000000000000000000000000000000;;		// Some volume types allow the Kubelet to change the ownership of that volume
0000000000000000000000000000000000000000;;		// to be owned by the pod:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 1. The owning GID will be the FSGroup
0000000000000000000000000000000000000000;;		// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
0000000000000000000000000000000000000000;;		// 3. The permission bits are OR'd with rw-rw----
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If unset, the Kubelet will not modify the ownership and permissions of any volume.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FSGroup *int64 `json:"fsGroup,omitempty" protobuf:"varint,5,opt,name=fsGroup"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodQOSClass defines the supported qos classes of Pods.
0000000000000000000000000000000000000000;;	type PodQOSClass string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// PodQOSGuaranteed is the Guaranteed qos class.
0000000000000000000000000000000000000000;;		PodQOSGuaranteed PodQOSClass = "Guaranteed"
0000000000000000000000000000000000000000;;		// PodQOSBurstable is the Burstable qos class.
0000000000000000000000000000000000000000;;		PodQOSBurstable PodQOSClass = "Burstable"
0000000000000000000000000000000000000000;;		// PodQOSBestEffort is the BestEffort qos class.
0000000000000000000000000000000000000000;;		PodQOSBestEffort PodQOSClass = "BestEffort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodStatus represents information about the status of a pod. Status may trail the actual
0000000000000000000000000000000000000000;;	// state of a system.
0000000000000000000000000000000000000000;;	type PodStatus struct {
0000000000000000000000000000000000000000;;		// Current condition of the pod.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Phase PodPhase `json:"phase,omitempty" protobuf:"bytes,1,opt,name=phase,casttype=PodPhase"`
0000000000000000000000000000000000000000;;		// Current service state of pod.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=type
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Conditions []PodCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,2,rep,name=conditions"`
0000000000000000000000000000000000000000;;		// A human readable message indicating details about why the pod is in this condition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,3,opt,name=message"`
0000000000000000000000000000000000000000;;		// A brief CamelCase message indicating details about why the pod is in this state.
0000000000000000000000000000000000000000;;		// e.g. 'OutOfDisk'
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string `json:"reason,omitempty" protobuf:"bytes,4,opt,name=reason"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HostIP string `json:"hostIP,omitempty" protobuf:"bytes,5,opt,name=hostIP"`
0000000000000000000000000000000000000000;;		// IP address allocated to the pod. Routable at least within the cluster.
0000000000000000000000000000000000000000;;		// Empty if not yet allocated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodIP string `json:"podIP,omitempty" protobuf:"bytes,6,opt,name=podIP"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RFC 3339 date and time at which the object was acknowledged by the Kubelet.
0000000000000000000000000000000000000000;;		// This is before the Kubelet pulled the container image(s) for the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StartTime *metav1.Time `json:"startTime,omitempty" protobuf:"bytes,7,opt,name=startTime"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The list has one entry per init container in the manifest. The most recent successful
0000000000000000000000000000000000000000;;		// init container will have ready = true, the most recently started container will have
0000000000000000000000000000000000000000;;		// startTime set.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
0000000000000000000000000000000000000000;;		InitContainerStatuses []ContainerStatus `json:"initContainerStatuses,omitempty" protobuf:"bytes,10,rep,name=initContainerStatuses"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The list has one entry per container in the manifest. Each entry is currently the output
0000000000000000000000000000000000000000;;		// of `docker inspect`.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ContainerStatuses []ContainerStatus `json:"containerStatuses,omitempty" protobuf:"bytes,8,rep,name=containerStatuses"`
0000000000000000000000000000000000000000;;		// The Quality of Service (QOS) classification assigned to the pod based on resource requirements
0000000000000000000000000000000000000000;;		// See PodQOSClass type for available QOS classes
0000000000000000000000000000000000000000;;		// More info: https://github.com/kubernetes/kubernetes/blob/master/docs/design/resource-qos.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		QOSClass PodQOSClass `json:"qosClass,omitempty" protobuf:"bytes,9,rep,name=qosClass"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodStatusResult is a wrapper for PodStatus returned by kubelet that can be encode/decoded
0000000000000000000000000000000000000000;;	type PodStatusResult struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;		// Most recently observed status of the pod.
0000000000000000000000000000000000000000;;		// This data may not be up to date.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status PodStatus `json:"status,omitempty" protobuf:"bytes,2,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pod is a collection of containers that can run on a host. This resource is created
0000000000000000000000000000000000000000;;	// by clients and scheduled onto hosts.
0000000000000000000000000000000000000000;;	type Pod struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Specification of the desired behavior of the pod.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec PodSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Most recently observed status of the pod.
0000000000000000000000000000000000000000;;		// This data may not be up to date.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status PodStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodList is a list of Pods.
0000000000000000000000000000000000000000;;	type PodList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of pods.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md
0000000000000000000000000000000000000000;;		Items []Pod `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodTemplateSpec describes the data a pod should have when created from a template
0000000000000000000000000000000000000000;;	type PodTemplateSpec struct {
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Specification of the desired behavior of the pod.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec PodSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodTemplate describes a template for creating copies of a predefined pod.
0000000000000000000000000000000000000000;;	type PodTemplate struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Template defines the pods that will be created from this pod template.
0000000000000000000000000000000000000000;;		// https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Template PodTemplateSpec `json:"template,omitempty" protobuf:"bytes,2,opt,name=template"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodTemplateList is a list of PodTemplates.
0000000000000000000000000000000000000000;;	type PodTemplateList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of pod templates
0000000000000000000000000000000000000000;;		Items []PodTemplate `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationControllerSpec is the specification of a replication controller.
0000000000000000000000000000000000000000;;	type ReplicationControllerSpec struct {
0000000000000000000000000000000000000000;;		// Replicas is the number of desired replicas.
0000000000000000000000000000000000000000;;		// This is a pointer to distinguish between explicit zero and unspecified.
0000000000000000000000000000000000000000;;		// Defaults to 1.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Replicas *int32 `json:"replicas,omitempty" protobuf:"varint,1,opt,name=replicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Minimum number of seconds for which a newly created pod should be ready
0000000000000000000000000000000000000000;;		// without any of its container crashing, for it to be considered available.
0000000000000000000000000000000000000000;;		// Defaults to 0 (pod will be considered available as soon as it is ready)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MinReadySeconds int32 `json:"minReadySeconds,omitempty" protobuf:"varint,4,opt,name=minReadySeconds"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Selector is a label query over pods that should match the Replicas count.
0000000000000000000000000000000000000000;;		// If Selector is empty, it is defaulted to the labels present on the Pod template.
0000000000000000000000000000000000000000;;		// Label keys and values that must match in order to be controlled by this replication
0000000000000000000000000000000000000000;;		// controller, if empty defaulted to labels on Pod template.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector map[string]string `json:"selector,omitempty" protobuf:"bytes,2,rep,name=selector"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TemplateRef is a reference to an object that describes the pod that will be created if
0000000000000000000000000000000000000000;;		// insufficient replicas are detected.
0000000000000000000000000000000000000000;;		// Reference to an object that describes the pod that will be created if insufficient replicas are detected.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// TemplateRef *ObjectReference `json:"templateRef,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Template is the object that describes the pod that will be created if
0000000000000000000000000000000000000000;;		// insufficient replicas are detected. This takes precedence over a TemplateRef.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Template *PodTemplateSpec `json:"template,omitempty" protobuf:"bytes,3,opt,name=template"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationControllerStatus represents the current status of a replication
0000000000000000000000000000000000000000;;	// controller.
0000000000000000000000000000000000000000;;	type ReplicationControllerStatus struct {
0000000000000000000000000000000000000000;;		// Replicas is the most recently oberved number of replicas.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
0000000000000000000000000000000000000000;;		Replicas int32 `json:"replicas" protobuf:"varint,1,opt,name=replicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of pods that have labels matching the labels of the pod template of the replication controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FullyLabeledReplicas int32 `json:"fullyLabeledReplicas,omitempty" protobuf:"varint,2,opt,name=fullyLabeledReplicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of ready replicas for this replication controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadyReplicas int32 `json:"readyReplicas,omitempty" protobuf:"varint,4,opt,name=readyReplicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of available replicas (ready for at least minReadySeconds) for this replication controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AvailableReplicas int32 `json:"availableReplicas,omitempty" protobuf:"varint,5,opt,name=availableReplicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ObservedGeneration reflects the generation of the most recently observed replication controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ObservedGeneration int64 `json:"observedGeneration,omitempty" protobuf:"varint,3,opt,name=observedGeneration"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Represents the latest available observations of a replication controller's current state.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=type
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Conditions []ReplicationControllerCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,6,rep,name=conditions"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ReplicationControllerConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid conditions of a replication controller.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ReplicationControllerReplicaFailure is added in a replication controller when one of its pods
0000000000000000000000000000000000000000;;		// fails to be created due to insufficient quota, limit ranges, pod security policy, node selectors,
0000000000000000000000000000000000000000;;		// etc. or deleted due to kubelet being down or finalizers are failing.
0000000000000000000000000000000000000000;;		ReplicationControllerReplicaFailure ReplicationControllerConditionType = "ReplicaFailure"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationControllerCondition describes the state of a replication controller at a certain point.
0000000000000000000000000000000000000000;;	type ReplicationControllerCondition struct {
0000000000000000000000000000000000000000;;		// Type of replication controller condition.
0000000000000000000000000000000000000000;;		Type ReplicationControllerConditionType `json:"type" protobuf:"bytes,1,opt,name=type,casttype=ReplicationControllerConditionType"`
0000000000000000000000000000000000000000;;		// Status of the condition, one of True, False, Unknown.
0000000000000000000000000000000000000000;;		Status ConditionStatus `json:"status" protobuf:"bytes,2,opt,name=status,casttype=ConditionStatus"`
0000000000000000000000000000000000000000;;		// The last time the condition transitioned from one status to another.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTransitionTime metav1.Time `json:"lastTransitionTime,omitempty" protobuf:"bytes,3,opt,name=lastTransitionTime"`
0000000000000000000000000000000000000000;;		// The reason for the condition's last transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string `json:"reason,omitempty" protobuf:"bytes,4,opt,name=reason"`
0000000000000000000000000000000000000000;;		// A human readable message indicating details about the transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,5,opt,name=message"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationController represents the configuration of a replication controller.
0000000000000000000000000000000000000000;;	type ReplicationController struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the Labels of a ReplicationController are empty, they are defaulted to
0000000000000000000000000000000000000000;;		// be the same as the Pod(s) that the replication controller manages.
0000000000000000000000000000000000000000;;		// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the specification of the desired behavior of the replication controller.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec ReplicationControllerSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status is the most recently observed status of the replication controller.
0000000000000000000000000000000000000000;;		// This data may be out of date by some window of time.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status ReplicationControllerStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplicationControllerList is a collection of replication controllers.
0000000000000000000000000000000000000000;;	type ReplicationControllerList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of replication controllers.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
0000000000000000000000000000000000000000;;		Items []ReplicationController `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Session Affinity Type string
0000000000000000000000000000000000000000;;	type ServiceAffinity string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ServiceAffinityClientIP is the Client IP based.
0000000000000000000000000000000000000000;;		ServiceAffinityClientIP ServiceAffinity = "ClientIP"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceAffinityNone - no session affinity.
0000000000000000000000000000000000000000;;		ServiceAffinityNone ServiceAffinity = "None"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Service Type string describes ingress methods for a service
0000000000000000000000000000000000000000;;	type ServiceType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ServiceTypeClusterIP means a service will only be accessible inside the
0000000000000000000000000000000000000000;;		// cluster, via the cluster IP.
0000000000000000000000000000000000000000;;		ServiceTypeClusterIP ServiceType = "ClusterIP"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceTypeNodePort means a service will be exposed on one port of
0000000000000000000000000000000000000000;;		// every node, in addition to 'ClusterIP' type.
0000000000000000000000000000000000000000;;		ServiceTypeNodePort ServiceType = "NodePort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceTypeLoadBalancer means a service will be exposed via an
0000000000000000000000000000000000000000;;		// external load balancer (if the cloud provider supports it), in addition
0000000000000000000000000000000000000000;;		// to 'NodePort' type.
0000000000000000000000000000000000000000;;		ServiceTypeLoadBalancer ServiceType = "LoadBalancer"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceTypeExternalName means a service consists of only a reference to
0000000000000000000000000000000000000000;;		// an external name that kubedns or equivalent will return as a CNAME
0000000000000000000000000000000000000000;;		// record, with no exposing or proxying of any pods involved.
0000000000000000000000000000000000000000;;		ServiceTypeExternalName ServiceType = "ExternalName"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Service External Traffic Policy Type string
0000000000000000000000000000000000000000;;	type ServiceExternalTrafficPolicyType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ServiceExternalTrafficPolicyTypeLocal specifies node-local endpoints behavior.
0000000000000000000000000000000000000000;;		ServiceExternalTrafficPolicyTypeLocal ServiceExternalTrafficPolicyType = "Local"
0000000000000000000000000000000000000000;;		// ServiceExternalTrafficPolicyTypeCluster specifies node-global (legacy) behavior.
0000000000000000000000000000000000000000;;		ServiceExternalTrafficPolicyTypeCluster ServiceExternalTrafficPolicyType = "Cluster"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceStatus represents the current status of a service.
0000000000000000000000000000000000000000;;	type ServiceStatus struct {
0000000000000000000000000000000000000000;;		// LoadBalancer contains the current status of the load-balancer,
0000000000000000000000000000000000000000;;		// if one is present.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LoadBalancer LoadBalancerStatus `json:"loadBalancer,omitempty" protobuf:"bytes,1,opt,name=loadBalancer"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancerStatus represents the status of a load-balancer.
0000000000000000000000000000000000000000;;	type LoadBalancerStatus struct {
0000000000000000000000000000000000000000;;		// Ingress is a list containing ingress points for the load-balancer.
0000000000000000000000000000000000000000;;		// Traffic intended for the service should be sent to these ingress points.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ingress []LoadBalancerIngress `json:"ingress,omitempty" protobuf:"bytes,1,rep,name=ingress"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadBalancerIngress represents the status of a load-balancer ingress point:
0000000000000000000000000000000000000000;;	// traffic intended for the service should be sent to an ingress point.
0000000000000000000000000000000000000000;;	type LoadBalancerIngress struct {
0000000000000000000000000000000000000000;;		// IP is set for load-balancer ingress points that are IP based
0000000000000000000000000000000000000000;;		// (typically GCE or OpenStack load-balancers)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		IP string `json:"ip,omitempty" protobuf:"bytes,1,opt,name=ip"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Hostname is set for load-balancer ingress points that are DNS based
0000000000000000000000000000000000000000;;		// (typically AWS load-balancers)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hostname string `json:"hostname,omitempty" protobuf:"bytes,2,opt,name=hostname"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceSpec describes the attributes that a user creates on a service.
0000000000000000000000000000000000000000;;	type ServiceSpec struct {
0000000000000000000000000000000000000000;;		// The list of ports that are exposed by this service.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
0000000000000000000000000000000000000000;;		// +patchMergeKey=port
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Ports []ServicePort `json:"ports,omitempty" patchStrategy:"merge" patchMergeKey:"port" protobuf:"bytes,1,rep,name=ports"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Route service traffic to pods with label keys and values matching this
0000000000000000000000000000000000000000;;		// selector. If empty or not present, the service is assumed to have an
0000000000000000000000000000000000000000;;		// external process managing its endpoints, which Kubernetes will not
0000000000000000000000000000000000000000;;		// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
0000000000000000000000000000000000000000;;		// Ignored if type is ExternalName.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/services-networking/service/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector map[string]string `json:"selector,omitempty" protobuf:"bytes,2,rep,name=selector"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clusterIP is the IP address of the service and is usually assigned
0000000000000000000000000000000000000000;;		// randomly by the master. If an address is specified manually and is not in
0000000000000000000000000000000000000000;;		// use by others, it will be allocated to the service; otherwise, creation
0000000000000000000000000000000000000000;;		// of the service will fail. This field can not be changed through updates.
0000000000000000000000000000000000000000;;		// Valid values are "None", empty string (""), or a valid IP address. "None"
0000000000000000000000000000000000000000;;		// can be specified for headless services when proxying is not required.
0000000000000000000000000000000000000000;;		// Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if
0000000000000000000000000000000000000000;;		// type is ExternalName.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ClusterIP string `json:"clusterIP,omitempty" protobuf:"bytes,3,opt,name=clusterIP"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// type determines how the Service is exposed. Defaults to ClusterIP. Valid
0000000000000000000000000000000000000000;;		// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
0000000000000000000000000000000000000000;;		// "ExternalName" maps to the specified externalName.
0000000000000000000000000000000000000000;;		// "ClusterIP" allocates a cluster-internal IP address for load-balancing to
0000000000000000000000000000000000000000;;		// endpoints. Endpoints are determined by the selector or if that is not
0000000000000000000000000000000000000000;;		// specified, by manual construction of an Endpoints object. If clusterIP is
0000000000000000000000000000000000000000;;		// "None", no virtual IP is allocated and the endpoints are published as a
0000000000000000000000000000000000000000;;		// set of endpoints rather than a stable IP.
0000000000000000000000000000000000000000;;		// "NodePort" builds on ClusterIP and allocates a port on every node which
0000000000000000000000000000000000000000;;		// routes to the clusterIP.
0000000000000000000000000000000000000000;;		// "LoadBalancer" builds on NodePort and creates an
0000000000000000000000000000000000000000;;		// external load-balancer (if supported in the current cloud) which routes
0000000000000000000000000000000000000000;;		// to the clusterIP.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type ServiceType `json:"type,omitempty" protobuf:"bytes,4,opt,name=type,casttype=ServiceType"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// externalIPs is a list of IP addresses for which nodes in the cluster
0000000000000000000000000000000000000000;;		// will also accept traffic for this service.  These IPs are not managed by
0000000000000000000000000000000000000000;;		// Kubernetes.  The user is responsible for ensuring that traffic arrives
0000000000000000000000000000000000000000;;		// at a node with this IP.  A common example is external load-balancers
0000000000000000000000000000000000000000;;		// that are not part of the Kubernetes system.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ExternalIPs []string `json:"externalIPs,omitempty" protobuf:"bytes,5,rep,name=externalIPs"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Supports "ClientIP" and "None". Used to maintain session affinity.
0000000000000000000000000000000000000000;;		// Enable client IP based session affinity.
0000000000000000000000000000000000000000;;		// Must be ClientIP or None.
0000000000000000000000000000000000000000;;		// Defaults to None.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SessionAffinity ServiceAffinity `json:"sessionAffinity,omitempty" protobuf:"bytes,7,opt,name=sessionAffinity,casttype=ServiceAffinity"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only applies to Service Type: LoadBalancer
0000000000000000000000000000000000000000;;		// LoadBalancer will get created with the IP specified in this field.
0000000000000000000000000000000000000000;;		// This feature depends on whether the underlying cloud-provider supports specifying
0000000000000000000000000000000000000000;;		// the loadBalancerIP when a load balancer is created.
0000000000000000000000000000000000000000;;		// This field will be ignored if the cloud-provider does not support the feature.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LoadBalancerIP string `json:"loadBalancerIP,omitempty" protobuf:"bytes,8,opt,name=loadBalancerIP"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If specified and supported by the platform, this will restrict traffic through the cloud-provider
0000000000000000000000000000000000000000;;		// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
0000000000000000000000000000000000000000;;		// cloud-provider does not support the feature."
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LoadBalancerSourceRanges []string `json:"loadBalancerSourceRanges,omitempty" protobuf:"bytes,9,opt,name=loadBalancerSourceRanges"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// externalName is the external reference that kubedns or equivalent will
0000000000000000000000000000000000000000;;		// return as a CNAME record for this service. No proxying will be involved.
0000000000000000000000000000000000000000;;		// Must be a valid DNS name and requires Type to be ExternalName.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ExternalName string `json:"externalName,omitempty" protobuf:"bytes,10,opt,name=externalName"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// externalTrafficPolicy denotes if this Service desires to route external
0000000000000000000000000000000000000000;;		// traffic to node-local or cluster-wide endpoints. "Local" preserves the
0000000000000000000000000000000000000000;;		// client source IP and avoids a second hop for LoadBalancer and Nodeport
0000000000000000000000000000000000000000;;		// type services, but risks potentially imbalanced traffic spreading.
0000000000000000000000000000000000000000;;		// "Cluster" obscures the client source IP and may cause a second hop to
0000000000000000000000000000000000000000;;		// another node, but should have good overall load-spreading.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ExternalTrafficPolicy ServiceExternalTrafficPolicyType `json:"externalTrafficPolicy,omitempty" protobuf:"bytes,11,opt,name=externalTrafficPolicy"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// healthCheckNodePort specifies the healthcheck nodePort for the service.
0000000000000000000000000000000000000000;;		// If not specified, HealthCheckNodePort is created by the service api
0000000000000000000000000000000000000000;;		// backend with the allocated nodePort. Will use user-specified nodePort value
0000000000000000000000000000000000000000;;		// if specified by the client. Only effects when Type is set to LoadBalancer
0000000000000000000000000000000000000000;;		// and ExternalTrafficPolicy is set to Local.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		HealthCheckNodePort int32 `json:"healthCheckNodePort,omitempty" protobuf:"bytes,12,opt,name=healthCheckNodePort"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServicePort contains information on service's port.
0000000000000000000000000000000000000000;;	type ServicePort struct {
0000000000000000000000000000000000000000;;		// The name of this port within the service. This must be a DNS_LABEL.
0000000000000000000000000000000000000000;;		// All ports within a ServiceSpec must have unique names. This maps to
0000000000000000000000000000000000000000;;		// the 'Name' field in EndpointPort objects.
0000000000000000000000000000000000000000;;		// Optional if only one ServicePort is defined on this service.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The IP protocol for this port. Supports "TCP" and "UDP".
0000000000000000000000000000000000000000;;		// Default is TCP.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Protocol Protocol `json:"protocol,omitempty" protobuf:"bytes,2,opt,name=protocol,casttype=Protocol"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The port that will be exposed by this service.
0000000000000000000000000000000000000000;;		Port int32 `json:"port" protobuf:"varint,3,opt,name=port"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number or name of the port to access on the pods targeted by the service.
0000000000000000000000000000000000000000;;		// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
0000000000000000000000000000000000000000;;		// If this is a string, it will be looked up as a named port in the
0000000000000000000000000000000000000000;;		// target Pod's container ports. If this is not specified, the value
0000000000000000000000000000000000000000;;		// of the 'port' field is used (an identity map).
0000000000000000000000000000000000000000;;		// This field is ignored for services with clusterIP=None, and should be
0000000000000000000000000000000000000000;;		// omitted or set equal to the 'port' field.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TargetPort intstr.IntOrString `json:"targetPort,omitempty" protobuf:"bytes,4,opt,name=targetPort"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The port on each node on which this service is exposed when type=NodePort or LoadBalancer.
0000000000000000000000000000000000000000;;		// Usually assigned by the system. If specified, it will be allocated to the service
0000000000000000000000000000000000000000;;		// if unused or else creation of the service will fail.
0000000000000000000000000000000000000000;;		// Default is to auto-allocate a port if the ServiceType of this Service requires one.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodePort int32 `json:"nodePort,omitempty" protobuf:"varint,5,opt,name=nodePort"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Service is a named abstraction of software service (for example, mysql) consisting of local port
0000000000000000000000000000000000000000;;	// (for example 3306) that the proxy listens on, and the selector that determines which pods
0000000000000000000000000000000000000000;;	// will answer requests sent through the proxy.
0000000000000000000000000000000000000000;;	type Service struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the behavior of a service.
0000000000000000000000000000000000000000;;		// https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec ServiceSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Most recently observed status of the service.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status ServiceStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ClusterIPNone - do not assign a cluster IP
0000000000000000000000000000000000000000;;		// no proxying required and no environment variables should be created for pods
0000000000000000000000000000000000000000;;		ClusterIPNone = "None"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceList holds a list of services.
0000000000000000000000000000000000000000;;	type ServiceList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of services
0000000000000000000000000000000000000000;;		Items []Service `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAccount binds together:
0000000000000000000000000000000000000000;;	// * a name, understood by users, and perhaps by peripheral systems, for an identity
0000000000000000000000000000000000000000;;	// * a principal that can be authenticated and authorized
0000000000000000000000000000000000000000;;	// * a set of secrets
0000000000000000000000000000000000000000;;	type ServiceAccount struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Secrets is the list of secrets allowed to be used by pods running using this ServiceAccount.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/configuration/secret
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=name
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Secrets []ObjectReference `json:"secrets,omitempty" patchStrategy:"merge" patchMergeKey:"name" protobuf:"bytes,2,rep,name=secrets"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
0000000000000000000000000000000000000000;;		// in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
0000000000000000000000000000000000000000;;		// can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ImagePullSecrets []LocalObjectReference `json:"imagePullSecrets,omitempty" protobuf:"bytes,3,rep,name=imagePullSecrets"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.
0000000000000000000000000000000000000000;;		// Can be overridden at the pod level.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AutomountServiceAccountToken *bool `json:"automountServiceAccountToken,omitempty" protobuf:"varint,4,opt,name=automountServiceAccountToken"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceAccountList is a list of ServiceAccount objects
0000000000000000000000000000000000000000;;	type ServiceAccountList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of ServiceAccounts.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
0000000000000000000000000000000000000000;;		Items []ServiceAccount `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Endpoints is a collection of endpoints that implement the actual service. Example:
0000000000000000000000000000000000000000;;	//   Name: "mysvc",
0000000000000000000000000000000000000000;;	//   Subsets: [
0000000000000000000000000000000000000000;;	//     {
0000000000000000000000000000000000000000;;	//       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
0000000000000000000000000000000000000000;;	//       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
0000000000000000000000000000000000000000;;	//     },
0000000000000000000000000000000000000000;;	//     {
0000000000000000000000000000000000000000;;	//       Addresses: [{"ip": "10.10.3.3"}],
0000000000000000000000000000000000000000;;	//       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
0000000000000000000000000000000000000000;;	//     },
0000000000000000000000000000000000000000;;	//  ]
0000000000000000000000000000000000000000;;	type Endpoints struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The set of all endpoints is the union of all subsets. Addresses are placed into
0000000000000000000000000000000000000000;;		// subsets according to the IPs they share. A single address with multiple ports,
0000000000000000000000000000000000000000;;		// some of which are ready and some of which are not (because they come from
0000000000000000000000000000000000000000;;		// different containers) will result in the address being displayed in different
0000000000000000000000000000000000000000;;		// subsets for the different ports. No address will appear in both Addresses and
0000000000000000000000000000000000000000;;		// NotReadyAddresses in the same subset.
0000000000000000000000000000000000000000;;		// Sets of addresses and ports that comprise a service.
0000000000000000000000000000000000000000;;		Subsets []EndpointSubset `json:"subsets" protobuf:"bytes,2,rep,name=subsets"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointSubset is a group of addresses with a common set of ports. The
0000000000000000000000000000000000000000;;	// expanded set of endpoints is the Cartesian product of Addresses x Ports.
0000000000000000000000000000000000000000;;	// For example, given:
0000000000000000000000000000000000000000;;	//   {
0000000000000000000000000000000000000000;;	//     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
0000000000000000000000000000000000000000;;	//     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	// The resulting set of endpoints can be viewed as:
0000000000000000000000000000000000000000;;	//     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
0000000000000000000000000000000000000000;;	//     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
0000000000000000000000000000000000000000;;	type EndpointSubset struct {
0000000000000000000000000000000000000000;;		// IP addresses which offer the related ports that are marked as ready. These endpoints
0000000000000000000000000000000000000000;;		// should be considered safe for load balancers and clients to utilize.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Addresses []EndpointAddress `json:"addresses,omitempty" protobuf:"bytes,1,rep,name=addresses"`
0000000000000000000000000000000000000000;;		// IP addresses which offer the related ports but are not currently marked as ready
0000000000000000000000000000000000000000;;		// because they have not yet finished starting, have recently failed a readiness check,
0000000000000000000000000000000000000000;;		// or have recently failed a liveness check.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NotReadyAddresses []EndpointAddress `json:"notReadyAddresses,omitempty" protobuf:"bytes,2,rep,name=notReadyAddresses"`
0000000000000000000000000000000000000000;;		// Port numbers available on the related IP addresses.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ports []EndpointPort `json:"ports,omitempty" protobuf:"bytes,3,rep,name=ports"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointAddress is a tuple that describes single IP address.
0000000000000000000000000000000000000000;;	type EndpointAddress struct {
0000000000000000000000000000000000000000;;		// The IP of this endpoint.
0000000000000000000000000000000000000000;;		// May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
0000000000000000000000000000000000000000;;		// or link-local multicast ((224.0.0.0/24).
0000000000000000000000000000000000000000;;		// IPv6 is also accepted but not fully supported on all platforms. Also, certain
0000000000000000000000000000000000000000;;		// kubernetes components, like kube-proxy, are not IPv6 ready.
0000000000000000000000000000000000000000;;		// TODO: This should allow hostname or IP, See #4447.
0000000000000000000000000000000000000000;;		IP string `json:"ip" protobuf:"bytes,1,opt,name=ip"`
0000000000000000000000000000000000000000;;		// The Hostname of this endpoint
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hostname string `json:"hostname,omitempty" protobuf:"bytes,3,opt,name=hostname"`
0000000000000000000000000000000000000000;;		// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodeName *string `json:"nodeName,omitempty" protobuf:"bytes,4,opt,name=nodeName"`
0000000000000000000000000000000000000000;;		// Reference to object providing the endpoint.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TargetRef *ObjectReference `json:"targetRef,omitempty" protobuf:"bytes,2,opt,name=targetRef"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointPort is a tuple that describes a single port.
0000000000000000000000000000000000000000;;	type EndpointPort struct {
0000000000000000000000000000000000000000;;		// The name of this port (corresponds to ServicePort.Name).
0000000000000000000000000000000000000000;;		// Must be a DNS_LABEL.
0000000000000000000000000000000000000000;;		// Optional only if one port is defined.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The port number of the endpoint.
0000000000000000000000000000000000000000;;		Port int32 `json:"port" protobuf:"varint,2,opt,name=port"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The IP protocol for this port.
0000000000000000000000000000000000000000;;		// Must be UDP or TCP.
0000000000000000000000000000000000000000;;		// Default is TCP.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Protocol Protocol `json:"protocol,omitempty" protobuf:"bytes,3,opt,name=protocol,casttype=Protocol"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EndpointsList is a list of endpoints.
0000000000000000000000000000000000000000;;	type EndpointsList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of endpoints.
0000000000000000000000000000000000000000;;		Items []Endpoints `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeSpec describes the attributes that a node is created with.
0000000000000000000000000000000000000000;;	type NodeSpec struct {
0000000000000000000000000000000000000000;;		// PodCIDR represents the pod IP range assigned to the node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodCIDR string `json:"podCIDR,omitempty" protobuf:"bytes,1,opt,name=podCIDR"`
0000000000000000000000000000000000000000;;		// External ID of the node assigned by some machine database (e.g. a cloud provider).
0000000000000000000000000000000000000000;;		// Deprecated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ExternalID string `json:"externalID,omitempty" protobuf:"bytes,2,opt,name=externalID"`
0000000000000000000000000000000000000000;;		// ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ProviderID string `json:"providerID,omitempty" protobuf:"bytes,3,opt,name=providerID"`
0000000000000000000000000000000000000000;;		// Unschedulable controls node schedulability of new pods. By default, node is schedulable.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Unschedulable bool `json:"unschedulable,omitempty" protobuf:"varint,4,opt,name=unschedulable"`
0000000000000000000000000000000000000000;;		// If specified, the node's taints.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Taints []Taint `json:"taints,omitempty" protobuf:"bytes,5,opt,name=taints"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DaemonEndpoint contains information about a single Daemon endpoint.
0000000000000000000000000000000000000000;;	type DaemonEndpoint struct {
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			The port tag was not properly in quotes in earlier releases, so it must be
0000000000000000000000000000000000000000;;			uppercased for backwards compat (since it was falling back to var name of
0000000000000000000000000000000000000000;;			'Port').
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Port number of the given endpoint.
0000000000000000000000000000000000000000;;		Port int32 `json:"Port" protobuf:"varint,1,opt,name=Port"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeDaemonEndpoints lists ports opened by daemons running on the Node.
0000000000000000000000000000000000000000;;	type NodeDaemonEndpoints struct {
0000000000000000000000000000000000000000;;		// Endpoint on which Kubelet is listening.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		KubeletEndpoint DaemonEndpoint `json:"kubeletEndpoint,omitempty" protobuf:"bytes,1,opt,name=kubeletEndpoint"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
0000000000000000000000000000000000000000;;	type NodeSystemInfo struct {
0000000000000000000000000000000000000000;;		// MachineID reported by the node. For unique machine identification
0000000000000000000000000000000000000000;;		// in the cluster this field is preferred. Learn more from man(5)
0000000000000000000000000000000000000000;;		// machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
0000000000000000000000000000000000000000;;		MachineID string `json:"machineID" protobuf:"bytes,1,opt,name=machineID"`
0000000000000000000000000000000000000000;;		// SystemUUID reported by the node. For unique machine identification
0000000000000000000000000000000000000000;;		// MachineID is preferred. This field is specific to Red Hat hosts
0000000000000000000000000000000000000000;;		// https://access.redhat.com/documentation/en-US/Red_Hat_Subscription_Management/1/html/RHSM/getting-system-uuid.html
0000000000000000000000000000000000000000;;		SystemUUID string `json:"systemUUID" protobuf:"bytes,2,opt,name=systemUUID"`
0000000000000000000000000000000000000000;;		// Boot ID reported by the node.
0000000000000000000000000000000000000000;;		BootID string `json:"bootID" protobuf:"bytes,3,opt,name=bootID"`
0000000000000000000000000000000000000000;;		// Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
0000000000000000000000000000000000000000;;		KernelVersion string `json:"kernelVersion" protobuf:"bytes,4,opt,name=kernelVersion"`
0000000000000000000000000000000000000000;;		// OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
0000000000000000000000000000000000000000;;		OSImage string `json:"osImage" protobuf:"bytes,5,opt,name=osImage"`
0000000000000000000000000000000000000000;;		// ContainerRuntime Version reported by the node through runtime remote API (e.g. docker://1.5.0).
0000000000000000000000000000000000000000;;		ContainerRuntimeVersion string `json:"containerRuntimeVersion" protobuf:"bytes,6,opt,name=containerRuntimeVersion"`
0000000000000000000000000000000000000000;;		// Kubelet Version reported by the node.
0000000000000000000000000000000000000000;;		KubeletVersion string `json:"kubeletVersion" protobuf:"bytes,7,opt,name=kubeletVersion"`
0000000000000000000000000000000000000000;;		// KubeProxy Version reported by the node.
0000000000000000000000000000000000000000;;		KubeProxyVersion string `json:"kubeProxyVersion" protobuf:"bytes,8,opt,name=kubeProxyVersion"`
0000000000000000000000000000000000000000;;		// The Operating System reported by the node
0000000000000000000000000000000000000000;;		OperatingSystem string `json:"operatingSystem" protobuf:"bytes,9,opt,name=operatingSystem"`
0000000000000000000000000000000000000000;;		// The Architecture reported by the node
0000000000000000000000000000000000000000;;		Architecture string `json:"architecture" protobuf:"bytes,10,opt,name=architecture"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeStatus is information about the current status of a node.
0000000000000000000000000000000000000000;;	type NodeStatus struct {
0000000000000000000000000000000000000000;;		// Capacity represents the total resources of a node.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Capacity ResourceList `json:"capacity,omitempty" protobuf:"bytes,1,rep,name=capacity,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;		// Allocatable represents the resources of a node that are available for scheduling.
0000000000000000000000000000000000000000;;		// Defaults to Capacity.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Allocatable ResourceList `json:"allocatable,omitempty" protobuf:"bytes,2,rep,name=allocatable,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;		// NodePhase is the recently observed lifecycle phase of the node.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
0000000000000000000000000000000000000000;;		// The field is never populated, and now is deprecated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Phase NodePhase `json:"phase,omitempty" protobuf:"bytes,3,opt,name=phase,casttype=NodePhase"`
0000000000000000000000000000000000000000;;		// Conditions is an array of current observed node conditions.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=type
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Conditions []NodeCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,4,rep,name=conditions"`
0000000000000000000000000000000000000000;;		// List of addresses reachable to the node.
0000000000000000000000000000000000000000;;		// Queried from cloud provider, if available.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=type
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Addresses []NodeAddress `json:"addresses,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,5,rep,name=addresses"`
0000000000000000000000000000000000000000;;		// Endpoints of daemons running on the Node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DaemonEndpoints NodeDaemonEndpoints `json:"daemonEndpoints,omitempty" protobuf:"bytes,6,opt,name=daemonEndpoints"`
0000000000000000000000000000000000000000;;		// Set of ids/uuids to uniquely identify the node.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/nodes/node/#info
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		NodeInfo NodeSystemInfo `json:"nodeInfo,omitempty" protobuf:"bytes,7,opt,name=nodeInfo"`
0000000000000000000000000000000000000000;;		// List of container images on this node
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Images []ContainerImage `json:"images,omitempty" protobuf:"bytes,8,rep,name=images"`
0000000000000000000000000000000000000000;;		// List of attachable volumes in use (mounted) by the node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumesInUse []UniqueVolumeName `json:"volumesInUse,omitempty" protobuf:"bytes,9,rep,name=volumesInUse"`
0000000000000000000000000000000000000000;;		// List of volumes that are attached to the node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumesAttached []AttachedVolume `json:"volumesAttached,omitempty" protobuf:"bytes,10,rep,name=volumesAttached"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UniqueVolumeName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachedVolume describes a volume attached to a node
0000000000000000000000000000000000000000;;	type AttachedVolume struct {
0000000000000000000000000000000000000000;;		// Name of the attached volume
0000000000000000000000000000000000000000;;		Name UniqueVolumeName `json:"name" protobuf:"bytes,1,rep,name=name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DevicePath represents the device path where the volume should be available
0000000000000000000000000000000000000000;;		DevicePath string `json:"devicePath" protobuf:"bytes,2,rep,name=devicePath"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AvoidPods describes pods that should avoid this node. This is the value for a
0000000000000000000000000000000000000000;;	// Node annotation with key scheduler.alpha.kubernetes.io/preferAvoidPods and
0000000000000000000000000000000000000000;;	// will eventually become a field of NodeStatus.
0000000000000000000000000000000000000000;;	type AvoidPods struct {
0000000000000000000000000000000000000000;;		// Bounded-sized list of signatures of pods that should avoid this node, sorted
0000000000000000000000000000000000000000;;		// in timestamp order from oldest to newest. Size of the slice is unspecified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PreferAvoidPods []PreferAvoidPodsEntry `json:"preferAvoidPods,omitempty" protobuf:"bytes,1,rep,name=preferAvoidPods"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describes a class of pods that should avoid this node.
0000000000000000000000000000000000000000;;	type PreferAvoidPodsEntry struct {
0000000000000000000000000000000000000000;;		// The class of pods.
0000000000000000000000000000000000000000;;		PodSignature PodSignature `json:"podSignature" protobuf:"bytes,1,opt,name=podSignature"`
0000000000000000000000000000000000000000;;		// Time at which this entry was added to the list.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		EvictionTime metav1.Time `json:"evictionTime,omitempty" protobuf:"bytes,2,opt,name=evictionTime"`
0000000000000000000000000000000000000000;;		// (brief) reason why this entry was added to the list.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string `json:"reason,omitempty" protobuf:"bytes,3,opt,name=reason"`
0000000000000000000000000000000000000000;;		// Human readable message indicating why this entry was added to the list.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,4,opt,name=message"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describes the class of pods that should avoid this node.
0000000000000000000000000000000000000000;;	// Exactly one field should be set.
0000000000000000000000000000000000000000;;	type PodSignature struct {
0000000000000000000000000000000000000000;;		// Reference to controller whose pods should avoid this node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodController *metav1.OwnerReference `json:"podController,omitempty" protobuf:"bytes,1,opt,name=podController"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Describe a container image
0000000000000000000000000000000000000000;;	type ContainerImage struct {
0000000000000000000000000000000000000000;;		// Names by which this image is known.
0000000000000000000000000000000000000000;;		// e.g. ["gcr.io/google_containers/hyperkube:v1.0.7", "dockerhub.io/google_containers/hyperkube:v1.0.7"]
0000000000000000000000000000000000000000;;		Names []string `json:"names" protobuf:"bytes,1,rep,name=names"`
0000000000000000000000000000000000000000;;		// The size of the image in bytes.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SizeBytes int64 `json:"sizeBytes,omitempty" protobuf:"varint,2,opt,name=sizeBytes"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodePhase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the valid phases of node.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NodePending means the node has been created/added by the system, but not configured.
0000000000000000000000000000000000000000;;		NodePending NodePhase = "Pending"
0000000000000000000000000000000000000000;;		// NodeRunning means the node has been configured and has Kubernetes components running.
0000000000000000000000000000000000000000;;		NodeRunning NodePhase = "Running"
0000000000000000000000000000000000000000;;		// NodeTerminated means the node has been removed from the cluster.
0000000000000000000000000000000000000000;;		NodeTerminated NodePhase = "Terminated"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodeConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid conditions of node. Currently, we don't have enough information to decide
0000000000000000000000000000000000000000;;	// node condition. In the future, we will add more. The proposed set of conditions are:
0000000000000000000000000000000000000000;;	// NodeReachable, NodeLive, NodeReady, NodeSchedulable, NodeRunnable.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NodeReady means kubelet is healthy and ready to accept pods.
0000000000000000000000000000000000000000;;		NodeReady NodeConditionType = "Ready"
0000000000000000000000000000000000000000;;		// NodeOutOfDisk means the kubelet will not accept new pods due to insufficient free disk
0000000000000000000000000000000000000000;;		// space on the node.
0000000000000000000000000000000000000000;;		NodeOutOfDisk NodeConditionType = "OutOfDisk"
0000000000000000000000000000000000000000;;		// NodeMemoryPressure means the kubelet is under pressure due to insufficient available memory.
0000000000000000000000000000000000000000;;		NodeMemoryPressure NodeConditionType = "MemoryPressure"
0000000000000000000000000000000000000000;;		// NodeDiskPressure means the kubelet is under pressure due to insufficient available disk.
0000000000000000000000000000000000000000;;		NodeDiskPressure NodeConditionType = "DiskPressure"
0000000000000000000000000000000000000000;;		// NodeNetworkUnavailable means that network for the node is not correctly configured.
0000000000000000000000000000000000000000;;		NodeNetworkUnavailable NodeConditionType = "NetworkUnavailable"
0000000000000000000000000000000000000000;;		// NodeInodePressure means the kubelet is under pressure due to insufficient available inodes.
0000000000000000000000000000000000000000;;		NodeInodePressure NodeConditionType = "InodePressure"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeCondition contains condition information for a node.
0000000000000000000000000000000000000000;;	type NodeCondition struct {
0000000000000000000000000000000000000000;;		// Type of node condition.
0000000000000000000000000000000000000000;;		Type NodeConditionType `json:"type" protobuf:"bytes,1,opt,name=type,casttype=NodeConditionType"`
0000000000000000000000000000000000000000;;		// Status of the condition, one of True, False, Unknown.
0000000000000000000000000000000000000000;;		Status ConditionStatus `json:"status" protobuf:"bytes,2,opt,name=status,casttype=ConditionStatus"`
0000000000000000000000000000000000000000;;		// Last time we got an update on a given condition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastHeartbeatTime metav1.Time `json:"lastHeartbeatTime,omitempty" protobuf:"bytes,3,opt,name=lastHeartbeatTime"`
0000000000000000000000000000000000000000;;		// Last time the condition transit from one status to another.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTransitionTime metav1.Time `json:"lastTransitionTime,omitempty" protobuf:"bytes,4,opt,name=lastTransitionTime"`
0000000000000000000000000000000000000000;;		// (brief) reason for the condition's last transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string `json:"reason,omitempty" protobuf:"bytes,5,opt,name=reason"`
0000000000000000000000000000000000000000;;		// Human readable message indicating details about last transition.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,6,opt,name=message"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodeAddressType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid address type of node.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NodeHostName    NodeAddressType = "Hostname"
0000000000000000000000000000000000000000;;		NodeExternalIP  NodeAddressType = "ExternalIP"
0000000000000000000000000000000000000000;;		NodeInternalIP  NodeAddressType = "InternalIP"
0000000000000000000000000000000000000000;;		NodeExternalDNS NodeAddressType = "ExternalDNS"
0000000000000000000000000000000000000000;;		NodeInternalDNS NodeAddressType = "InternalDNS"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeAddress contains information for the node's address.
0000000000000000000000000000000000000000;;	type NodeAddress struct {
0000000000000000000000000000000000000000;;		// Node address type, one of Hostname, ExternalIP or InternalIP.
0000000000000000000000000000000000000000;;		Type NodeAddressType `json:"type" protobuf:"bytes,1,opt,name=type,casttype=NodeAddressType"`
0000000000000000000000000000000000000000;;		// The node address.
0000000000000000000000000000000000000000;;		Address string `json:"address" protobuf:"bytes,2,opt,name=address"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceName is the name identifying various resources in a ResourceList.
0000000000000000000000000000000000000000;;	type ResourceName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resource names must be not more than 63 characters, consisting of upper- or lower-case alphanumeric characters,
0000000000000000000000000000000000000000;;	// with the -, _, and . characters allowed anywhere, except the first or last character.
0000000000000000000000000000000000000000;;	// The default convention, matching that for annotations, is to use lower-case names, with dashes, rather than
0000000000000000000000000000000000000000;;	// camel case, separating compound words.
0000000000000000000000000000000000000000;;	// Fully-qualified resource typenames are constructed from a DNS-style subdomain, followed by a slash `/` and a name.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// CPU, in cores. (500m = .5 cores)
0000000000000000000000000000000000000000;;		ResourceCPU ResourceName = "cpu"
0000000000000000000000000000000000000000;;		// Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		ResourceMemory ResourceName = "memory"
0000000000000000000000000000000000000000;;		// Volume size, in bytes (e,g. 5Gi = 5GiB = 5 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		ResourceStorage ResourceName = "storage"
0000000000000000000000000000000000000000;;		// Local Storage for container overlay filesystem, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		// The resource name for ResourceStorageOverlay is alpha and it can change across releases.
0000000000000000000000000000000000000000;;		ResourceStorageOverlay ResourceName = "storage.kubernetes.io/overlay"
0000000000000000000000000000000000000000;;		// Local Storage for scratch space, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		// The resource name for ResourceStorageScratch is alpha and it can change across releases.
0000000000000000000000000000000000000000;;		ResourceStorageScratch ResourceName = "storage.kubernetes.io/scratch"
0000000000000000000000000000000000000000;;		// NVIDIA GPU, in devices. Alpha, might change: although fractional and allowing values >1, only one whole device per node is assigned.
0000000000000000000000000000000000000000;;		ResourceNvidiaGPU ResourceName = "alpha.kubernetes.io/nvidia-gpu"
0000000000000000000000000000000000000000;;		// Number of Pods that may be running on this Node: see ResourcePods
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Namespace prefix for opaque counted resources (alpha).
0000000000000000000000000000000000000000;;		ResourceOpaqueIntPrefix = "pod.alpha.kubernetes.io/opaque-int-resource-"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceList is a set of (resource name, quantity) pairs.
0000000000000000000000000000000000000000;;	type ResourceList map[ResourceName]resource.Quantity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Node is a worker node in Kubernetes.
0000000000000000000000000000000000000000;;	// Each node will have a unique identifier in the cache (i.e. in etcd).
0000000000000000000000000000000000000000;;	type Node struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the behavior of a node.
0000000000000000000000000000000000000000;;		// https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec NodeSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Most recently observed status of the node.
0000000000000000000000000000000000000000;;		// Populated by the system.
0000000000000000000000000000000000000000;;		// Read-only.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status NodeStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeList is the whole list of all Nodes which have been registered with master.
0000000000000000000000000000000000000000;;	type NodeList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of nodes
0000000000000000000000000000000000000000;;		Items []Node `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FinalizerName is the name identifying a finalizer during namespace lifecycle.
0000000000000000000000000000000000000000;;	type FinalizerName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are internal finalizer values to Kubernetes, must be qualified name unless defined here or
0000000000000000000000000000000000000000;;	// in metav1.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		FinalizerKubernetes FinalizerName = "kubernetes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceSpec describes the attributes on a Namespace.
0000000000000000000000000000000000000000;;	type NamespaceSpec struct {
0000000000000000000000000000000000000000;;		// Finalizers is an opaque list of values that must be empty to permanently remove object from storage.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/design-proposals/namespaces.md#finalizers
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Finalizers []FinalizerName `json:"finalizers,omitempty" protobuf:"bytes,1,rep,name=finalizers,casttype=FinalizerName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceStatus is information about the current status of a Namespace.
0000000000000000000000000000000000000000;;	type NamespaceStatus struct {
0000000000000000000000000000000000000000;;		// Phase is the current lifecycle phase of the namespace.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/design-proposals/namespaces.md#phases
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Phase NamespacePhase `json:"phase,omitempty" protobuf:"bytes,1,opt,name=phase,casttype=NamespacePhase"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NamespacePhase string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the valid phases of a namespace.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NamespaceActive means the namespace is available for use in the system
0000000000000000000000000000000000000000;;		NamespaceActive NamespacePhase = "Active"
0000000000000000000000000000000000000000;;		// NamespaceTerminating means the namespace is undergoing graceful termination
0000000000000000000000000000000000000000;;		NamespaceTerminating NamespacePhase = "Terminating"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Namespace provides a scope for Names.
0000000000000000000000000000000000000000;;	// Use of multiple namespaces is optional.
0000000000000000000000000000000000000000;;	type Namespace struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the behavior of the Namespace.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec NamespaceSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status describes the current status of a Namespace.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status NamespaceStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NamespaceList is a list of Namespaces.
0000000000000000000000000000000000000000;;	type NamespaceList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is the list of Namespace objects in the list.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
0000000000000000000000000000000000000000;;		Items []Namespace `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
0000000000000000000000000000000000000000;;	// Deprecated in 1.7, please use the bindings subresource of pods instead.
0000000000000000000000000000000000000000;;	type Binding struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The target object that you want to bind to the standard object.
0000000000000000000000000000000000000000;;		Target ObjectReference `json:"target" protobuf:"bytes,2,opt,name=target"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
0000000000000000000000000000000000000000;;	// +k8s:openapi-gen=false
0000000000000000000000000000000000000000;;	type Preconditions struct {
0000000000000000000000000000000000000000;;		// Specifies the target UID.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UID *types.UID `json:"uid,omitempty" protobuf:"bytes,1,opt,name=uid,casttype=k8s.io/apimachinery/pkg/types.UID"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeletionPropagation decides if a deletion will propagate to the dependents of the object, and how the garbage collector will handle the propagation.
0000000000000000000000000000000000000000;;	type DeletionPropagation string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Orphans the dependents.
0000000000000000000000000000000000000000;;		DeletePropagationOrphan DeletionPropagation = "Orphan"
0000000000000000000000000000000000000000;;		// Deletes the object from the key-value store, the garbage collector will delete the dependents in the background.
0000000000000000000000000000000000000000;;		DeletePropagationBackground DeletionPropagation = "Background"
0000000000000000000000000000000000000000;;		// The object exists in the key-value store until the garbage collector deletes all the dependents whose ownerReference.blockOwnerDeletion=true from the key-value store.
0000000000000000000000000000000000000000;;		// API sever will put the "DeletingDependents" finalizer on the object, and sets its deletionTimestamp.
0000000000000000000000000000000000000000;;		// This policy is cascading, i.e., the dependents will be deleted with Foreground.
0000000000000000000000000000000000000000;;		DeletePropagationForeground DeletionPropagation = "Foreground"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteOptions may be provided when deleting an API object
0000000000000000000000000000000000000000;;	// DEPRECATED: This type has been moved to meta/v1 and will be removed soon.
0000000000000000000000000000000000000000;;	// +k8s:openapi-gen=false
0000000000000000000000000000000000000000;;	type DeleteOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The duration in seconds before the object should be deleted. Value must be non-negative integer.
0000000000000000000000000000000000000000;;		// The value zero indicates delete immediately. If this value is nil, the default grace period for the
0000000000000000000000000000000000000000;;		// specified type will be used.
0000000000000000000000000000000000000000;;		// Defaults to a per object value if not specified. zero means delete immediately.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		GracePeriodSeconds *int64 `json:"gracePeriodSeconds,omitempty" protobuf:"varint,1,opt,name=gracePeriodSeconds"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be
0000000000000000000000000000000000000000;;		// returned.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Preconditions *Preconditions `json:"preconditions,omitempty" protobuf:"bytes,2,opt,name=preconditions"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7.
0000000000000000000000000000000000000000;;		// Should the dependent objects be orphaned. If true/false, the "orphan"
0000000000000000000000000000000000000000;;		// finalizer will be added to/removed from the object's finalizers list.
0000000000000000000000000000000000000000;;		// Either this field or PropagationPolicy may be set, but not both.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		OrphanDependents *bool `json:"orphanDependents,omitempty" protobuf:"varint,3,opt,name=orphanDependents"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether and how garbage collection will be performed.
0000000000000000000000000000000000000000;;		// Either this field or OrphanDependents may be set, but not both.
0000000000000000000000000000000000000000;;		// The default policy is decided by the existing finalizer set in the
0000000000000000000000000000000000000000;;		// metadata.finalizers and the resource-specific default policy.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PropagationPolicy *DeletionPropagation `protobuf:"bytes,4,opt,name=propagationPolicy,casttype=DeletionPropagation"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListOptions is the query options to a standard REST list call.
0000000000000000000000000000000000000000;;	// DEPRECATED: This type has been moved to meta/v1 and will be removed soon.
0000000000000000000000000000000000000000;;	// +k8s:openapi-gen=false
0000000000000000000000000000000000000000;;	type ListOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A selector to restrict the list of returned objects by their labels.
0000000000000000000000000000000000000000;;		// Defaults to everything.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LabelSelector string `json:"labelSelector,omitempty" protobuf:"bytes,1,opt,name=labelSelector"`
0000000000000000000000000000000000000000;;		// A selector to restrict the list of returned objects by their fields.
0000000000000000000000000000000000000000;;		// Defaults to everything.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FieldSelector string `json:"fieldSelector,omitempty" protobuf:"bytes,2,opt,name=fieldSelector"`
0000000000000000000000000000000000000000;;		// If true, partially initialized resources are included in the response.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		IncludeUninitialized bool `json:"includeUninitialized,omitempty" protobuf:"varint,6,opt,name=includeUninitialized"`
0000000000000000000000000000000000000000;;		// Watch for changes to the described resources and return them as a stream of
0000000000000000000000000000000000000000;;		// add, update, and remove notifications. Specify resourceVersion.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Watch bool `json:"watch,omitempty" protobuf:"varint,3,opt,name=watch"`
0000000000000000000000000000000000000000;;		// When specified with a watch call, shows changes that occur after that particular version of a resource.
0000000000000000000000000000000000000000;;		// Defaults to changes from the beginning of history.
0000000000000000000000000000000000000000;;		// When specified for list:
0000000000000000000000000000000000000000;;		// - if unset, then the result is returned from remote storage based on quorum-read flag;
0000000000000000000000000000000000000000;;		// - if it's 0, then we simply return what we currently have in cache, no guarantee;
0000000000000000000000000000000000000000;;		// - if set to non zero, then the result is at least as fresh as given rv.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,4,opt,name=resourceVersion"`
0000000000000000000000000000000000000000;;		// Timeout for the list/watch call.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TimeoutSeconds *int64 `json:"timeoutSeconds,omitempty" protobuf:"varint,5,opt,name=timeoutSeconds"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodLogOptions is the query options for a Pod's logs REST call.
0000000000000000000000000000000000000000;;	type PodLogOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The container for which to stream logs. Defaults to only container if there is one container in the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Container string `json:"container,omitempty" protobuf:"bytes,1,opt,name=container"`
0000000000000000000000000000000000000000;;		// Follow the log stream of the pod. Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Follow bool `json:"follow,omitempty" protobuf:"varint,2,opt,name=follow"`
0000000000000000000000000000000000000000;;		// Return previous terminated container logs. Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Previous bool `json:"previous,omitempty" protobuf:"varint,3,opt,name=previous"`
0000000000000000000000000000000000000000;;		// A relative time in seconds before the current time from which to show logs. If this value
0000000000000000000000000000000000000000;;		// precedes the time a pod was started, only logs since the pod start will be returned.
0000000000000000000000000000000000000000;;		// If this value is in the future, no logs will be returned.
0000000000000000000000000000000000000000;;		// Only one of sinceSeconds or sinceTime may be specified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SinceSeconds *int64 `json:"sinceSeconds,omitempty" protobuf:"varint,4,opt,name=sinceSeconds"`
0000000000000000000000000000000000000000;;		// An RFC3339 timestamp from which to show logs. If this value
0000000000000000000000000000000000000000;;		// precedes the time a pod was started, only logs since the pod start will be returned.
0000000000000000000000000000000000000000;;		// If this value is in the future, no logs will be returned.
0000000000000000000000000000000000000000;;		// Only one of sinceSeconds or sinceTime may be specified.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SinceTime *metav1.Time `json:"sinceTime,omitempty" protobuf:"bytes,5,opt,name=sinceTime"`
0000000000000000000000000000000000000000;;		// If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
0000000000000000000000000000000000000000;;		// of log output. Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Timestamps bool `json:"timestamps,omitempty" protobuf:"varint,6,opt,name=timestamps"`
0000000000000000000000000000000000000000;;		// If set, the number of lines from the end of the logs to show. If not specified,
0000000000000000000000000000000000000000;;		// logs are shown from the creation of the container or sinceSeconds or sinceTime
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TailLines *int64 `json:"tailLines,omitempty" protobuf:"varint,7,opt,name=tailLines"`
0000000000000000000000000000000000000000;;		// If set, the number of bytes to read from the server before terminating the
0000000000000000000000000000000000000000;;		// log output. This may not display a complete final line of logging, and may return
0000000000000000000000000000000000000000;;		// slightly more or slightly less than the specified limit.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LimitBytes *int64 `json:"limitBytes,omitempty" protobuf:"varint,8,opt,name=limitBytes"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodAttachOptions is the query options to a Pod's remote attach call.
0000000000000000000000000000000000000000;;	// ---
0000000000000000000000000000000000000000;;	// TODO: merge w/ PodExecOptions below for stdin, stdout, etc
0000000000000000000000000000000000000000;;	// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
0000000000000000000000000000000000000000;;	type PodAttachOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stdin if true, redirects the standard input stream of the pod for this call.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stdin bool `json:"stdin,omitempty" protobuf:"varint,1,opt,name=stdin"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stdout if true indicates that stdout is to be redirected for the attach call.
0000000000000000000000000000000000000000;;		// Defaults to true.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stdout bool `json:"stdout,omitempty" protobuf:"varint,2,opt,name=stdout"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stderr if true indicates that stderr is to be redirected for the attach call.
0000000000000000000000000000000000000000;;		// Defaults to true.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stderr bool `json:"stderr,omitempty" protobuf:"varint,3,opt,name=stderr"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TTY if true indicates that a tty will be allocated for the attach call.
0000000000000000000000000000000000000000;;		// This is passed through the container runtime so the tty
0000000000000000000000000000000000000000;;		// is allocated on the worker node by the container runtime.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TTY bool `json:"tty,omitempty" protobuf:"varint,4,opt,name=tty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The container in which to execute the command.
0000000000000000000000000000000000000000;;		// Defaults to only container if there is only one container in the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Container string `json:"container,omitempty" protobuf:"bytes,5,opt,name=container"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodExecOptions is the query options to a Pod's remote exec call.
0000000000000000000000000000000000000000;;	// ---
0000000000000000000000000000000000000000;;	// TODO: This is largely identical to PodAttachOptions above, make sure they stay in sync and see about merging
0000000000000000000000000000000000000000;;	// and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
0000000000000000000000000000000000000000;;	type PodExecOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Redirect the standard input stream of the pod for this call.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stdin bool `json:"stdin,omitempty" protobuf:"varint,1,opt,name=stdin"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Redirect the standard output stream of the pod for this call.
0000000000000000000000000000000000000000;;		// Defaults to true.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stdout bool `json:"stdout,omitempty" protobuf:"varint,2,opt,name=stdout"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Redirect the standard error stream of the pod for this call.
0000000000000000000000000000000000000000;;		// Defaults to true.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Stderr bool `json:"stderr,omitempty" protobuf:"varint,3,opt,name=stderr"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TTY if true indicates that a tty will be allocated for the exec call.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TTY bool `json:"tty,omitempty" protobuf:"varint,4,opt,name=tty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Container in which to execute the command.
0000000000000000000000000000000000000000;;		// Defaults to only container if there is only one container in the pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Container string `json:"container,omitempty" protobuf:"bytes,5,opt,name=container"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Command is the remote command to execute. argv array. Not executed within a shell.
0000000000000000000000000000000000000000;;		Command []string `json:"command" protobuf:"bytes,6,rep,name=command"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodPortForwardOptions is the query options to a Pod's port forward call
0000000000000000000000000000000000000000;;	// when using WebSockets.
0000000000000000000000000000000000000000;;	// The `port` query parameter must specify the port or
0000000000000000000000000000000000000000;;	// ports (comma separated) to forward over.
0000000000000000000000000000000000000000;;	// Port forwarding over SPDY does not use these options. It requires the port
0000000000000000000000000000000000000000;;	// to be passed in the `port` header as part of request.
0000000000000000000000000000000000000000;;	type PodPortForwardOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of ports to forward
0000000000000000000000000000000000000000;;		// Required when using WebSockets
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Ports []int32 `json:"ports,omitempty" protobuf:"varint,1,rep,name=ports"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodProxyOptions is the query options to a Pod's proxy call.
0000000000000000000000000000000000000000;;	type PodProxyOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path is the URL path to use for the current proxy request to pod.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Path string `json:"path,omitempty" protobuf:"bytes,1,opt,name=path"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeProxyOptions is the query options to a Node's proxy call.
0000000000000000000000000000000000000000;;	type NodeProxyOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path is the URL path to use for the current proxy request to node.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Path string `json:"path,omitempty" protobuf:"bytes,1,opt,name=path"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceProxyOptions is the query options to a Service's proxy call.
0000000000000000000000000000000000000000;;	type ServiceProxyOptions struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path is the part of URLs that include service endpoints, suffixes,
0000000000000000000000000000000000000000;;		// and parameters to use for the current proxy request to service.
0000000000000000000000000000000000000000;;		// For example, the whole request URL is
0000000000000000000000000000000000000000;;		// http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
0000000000000000000000000000000000000000;;		// Path is _search?q=user:kimchy.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Path string `json:"path,omitempty" protobuf:"bytes,1,opt,name=path"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectReference contains enough information to let you inspect or modify the referred object.
0000000000000000000000000000000000000000;;	type ObjectReference struct {
0000000000000000000000000000000000000000;;		// Kind of the referent.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Kind string `json:"kind,omitempty" protobuf:"bytes,1,opt,name=kind"`
0000000000000000000000000000000000000000;;		// Namespace of the referent.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Namespace string `json:"namespace,omitempty" protobuf:"bytes,2,opt,name=namespace"`
0000000000000000000000000000000000000000;;		// Name of the referent.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty" protobuf:"bytes,3,opt,name=name"`
0000000000000000000000000000000000000000;;		// UID of the referent.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UID types.UID `json:"uid,omitempty" protobuf:"bytes,4,opt,name=uid,casttype=k8s.io/apimachinery/pkg/types.UID"`
0000000000000000000000000000000000000000;;		// API version of the referent.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		APIVersion string `json:"apiVersion,omitempty" protobuf:"bytes,5,opt,name=apiVersion"`
0000000000000000000000000000000000000000;;		// Specific resourceVersion to which this reference is made, if any.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceVersion string `json:"resourceVersion,omitempty" protobuf:"bytes,6,opt,name=resourceVersion"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If referring to a piece of an object instead of an entire object, this string
0000000000000000000000000000000000000000;;		// should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
0000000000000000000000000000000000000000;;		// For example, if the object reference is to a container within a pod, this would take on a value like:
0000000000000000000000000000000000000000;;		// "spec.containers{name}" (where "name" refers to the name of the container that triggered
0000000000000000000000000000000000000000;;		// the event) or if no container name is specified "spec.containers[2]" (container with
0000000000000000000000000000000000000000;;		// index 2 in this pod). This syntax is chosen only to have some well-defined way of
0000000000000000000000000000000000000000;;		// referencing a part of an object.
0000000000000000000000000000000000000000;;		// TODO: this design is not final and this field is subject to change in the future.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FieldPath string `json:"fieldPath,omitempty" protobuf:"bytes,7,opt,name=fieldPath"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LocalObjectReference contains enough information to let you locate the
0000000000000000000000000000000000000000;;	// referenced object inside the same namespace.
0000000000000000000000000000000000000000;;	type LocalObjectReference struct {
0000000000000000000000000000000000000000;;		// Name of the referent.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
0000000000000000000000000000000000000000;;		// TODO: Add other useful fields. apiVersion, kind, uid?
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SerializedReference is a reference to serialized object.
0000000000000000000000000000000000000000;;	type SerializedReference struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// The reference to an object in the system.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reference ObjectReference `json:"reference,omitempty" protobuf:"bytes,1,opt,name=reference"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventSource contains information for an event.
0000000000000000000000000000000000000000;;	type EventSource struct {
0000000000000000000000000000000000000000;;		// Component from which the event is generated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Component string `json:"component,omitempty" protobuf:"bytes,1,opt,name=component"`
0000000000000000000000000000000000000000;;		// Node name on which the event is generated.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Host string `json:"host,omitempty" protobuf:"bytes,2,opt,name=host"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid values for event types (new types could be added in future)
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Information only and will not cause any problems
0000000000000000000000000000000000000000;;		EventTypeNormal string = "Normal"
0000000000000000000000000000000000000000;;		// These events are to warn that something might go wrong
0000000000000000000000000000000000000000;;		EventTypeWarning string = "Warning"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Event is a report of an event somewhere in the cluster.
0000000000000000000000000000000000000000;;	// TODO: Decide whether to store these separately or with the object they apply to.
0000000000000000000000000000000000000000;;	type Event struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The object that this event is about.
0000000000000000000000000000000000000000;;		InvolvedObject ObjectReference `json:"involvedObject" protobuf:"bytes,2,opt,name=involvedObject"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This should be a short, machine understandable string that gives the reason
0000000000000000000000000000000000000000;;		// for the transition into the object's current status.
0000000000000000000000000000000000000000;;		// TODO: provide exact specification for format.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Reason string `json:"reason,omitempty" protobuf:"bytes,3,opt,name=reason"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A human-readable description of the status of this operation.
0000000000000000000000000000000000000000;;		// TODO: decide on maximum length.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,4,opt,name=message"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The component reporting this event. Should be a short machine understandable string.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Source EventSource `json:"source,omitempty" protobuf:"bytes,5,opt,name=source"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FirstTimestamp metav1.Time `json:"firstTimestamp,omitempty" protobuf:"bytes,6,opt,name=firstTimestamp"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The time at which the most recent occurrence of this event was recorded.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		LastTimestamp metav1.Time `json:"lastTimestamp,omitempty" protobuf:"bytes,7,opt,name=lastTimestamp"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of times this event has occurred.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Count int32 `json:"count,omitempty" protobuf:"varint,8,opt,name=count"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Type of this event (Normal, Warning), new types could be added in the future
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type string `json:"type,omitempty" protobuf:"bytes,9,opt,name=type"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventList is a list of events.
0000000000000000000000000000000000000000;;	type EventList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of events
0000000000000000000000000000000000000000;;		Items []Event `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List holds a list of objects, which may not be known by the server.
0000000000000000000000000000000000000000;;	type List struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of objects
0000000000000000000000000000000000000000;;		Items []runtime.RawExtension `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LimitType is a type of object that is limited
0000000000000000000000000000000000000000;;	type LimitType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Limit that applies to all pods in a namespace
0000000000000000000000000000000000000000;;		LimitTypePod LimitType = "Pod"
0000000000000000000000000000000000000000;;		// Limit that applies to all containers in a namespace
0000000000000000000000000000000000000000;;		LimitTypeContainer LimitType = "Container"
0000000000000000000000000000000000000000;;		// Limit that applies to all persistent volume claims in a namespace
0000000000000000000000000000000000000000;;		LimitTypePersistentVolumeClaim LimitType = "PersistentVolumeClaim"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
0000000000000000000000000000000000000000;;	type LimitRangeItem struct {
0000000000000000000000000000000000000000;;		// Type of resource that this limit applies to.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type LimitType `json:"type,omitempty" protobuf:"bytes,1,opt,name=type,casttype=LimitType"`
0000000000000000000000000000000000000000;;		// Max usage constraints on this kind by resource name.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Max ResourceList `json:"max,omitempty" protobuf:"bytes,2,rep,name=max,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;		// Min usage constraints on this kind by resource name.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Min ResourceList `json:"min,omitempty" protobuf:"bytes,3,rep,name=min,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;		// Default resource requirement limit value by resource name if resource limit is omitted.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Default ResourceList `json:"default,omitempty" protobuf:"bytes,4,rep,name=default,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;		// DefaultRequest is the default resource requirement request value by resource name if resource request is omitted.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultRequest ResourceList `json:"defaultRequest,omitempty" protobuf:"bytes,5,rep,name=defaultRequest,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;		// MaxLimitRequestRatio if specified, the named resource must have a request and limit that are both non-zero where limit divided by request is less than or equal to the enumerated value; this represents the max burst for the named resource.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MaxLimitRequestRatio ResourceList `json:"maxLimitRequestRatio,omitempty" protobuf:"bytes,6,rep,name=maxLimitRequestRatio,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LimitRangeSpec defines a min/max usage limit for resources that match on kind.
0000000000000000000000000000000000000000;;	type LimitRangeSpec struct {
0000000000000000000000000000000000000000;;		// Limits is the list of LimitRangeItem objects that are enforced.
0000000000000000000000000000000000000000;;		Limits []LimitRangeItem `json:"limits" protobuf:"bytes,1,rep,name=limits"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LimitRange sets resource usage limits for each kind of resource in a Namespace.
0000000000000000000000000000000000000000;;	type LimitRange struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the limits enforced.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec LimitRangeSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LimitRangeList is a list of LimitRange items.
0000000000000000000000000000000000000000;;	type LimitRangeList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is a list of LimitRange objects.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/design-proposals/admission_control_limit_range.md
0000000000000000000000000000000000000000;;		Items []LimitRange `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following identify resource constants for Kubernetes object types
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Pods, number
0000000000000000000000000000000000000000;;		ResourcePods ResourceName = "pods"
0000000000000000000000000000000000000000;;		// Services, number
0000000000000000000000000000000000000000;;		ResourceServices ResourceName = "services"
0000000000000000000000000000000000000000;;		// ReplicationControllers, number
0000000000000000000000000000000000000000;;		ResourceReplicationControllers ResourceName = "replicationcontrollers"
0000000000000000000000000000000000000000;;		// ResourceQuotas, number
0000000000000000000000000000000000000000;;		ResourceQuotas ResourceName = "resourcequotas"
0000000000000000000000000000000000000000;;		// ResourceSecrets, number
0000000000000000000000000000000000000000;;		ResourceSecrets ResourceName = "secrets"
0000000000000000000000000000000000000000;;		// ResourceConfigMaps, number
0000000000000000000000000000000000000000;;		ResourceConfigMaps ResourceName = "configmaps"
0000000000000000000000000000000000000000;;		// ResourcePersistentVolumeClaims, number
0000000000000000000000000000000000000000;;		ResourcePersistentVolumeClaims ResourceName = "persistentvolumeclaims"
0000000000000000000000000000000000000000;;		// ResourceServicesNodePorts, number
0000000000000000000000000000000000000000;;		ResourceServicesNodePorts ResourceName = "services.nodeports"
0000000000000000000000000000000000000000;;		// ResourceServicesLoadBalancers, number
0000000000000000000000000000000000000000;;		ResourceServicesLoadBalancers ResourceName = "services.loadbalancers"
0000000000000000000000000000000000000000;;		// CPU request, in cores. (500m = .5 cores)
0000000000000000000000000000000000000000;;		ResourceRequestsCPU ResourceName = "requests.cpu"
0000000000000000000000000000000000000000;;		// Memory request, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		ResourceRequestsMemory ResourceName = "requests.memory"
0000000000000000000000000000000000000000;;		// Storage request, in bytes
0000000000000000000000000000000000000000;;		ResourceRequestsStorage ResourceName = "requests.storage"
0000000000000000000000000000000000000000;;		// CPU limit, in cores. (500m = .5 cores)
0000000000000000000000000000000000000000;;		ResourceLimitsCPU ResourceName = "limits.cpu"
0000000000000000000000000000000000000000;;		// Memory limit, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
0000000000000000000000000000000000000000;;		ResourceLimitsMemory ResourceName = "limits.memory"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ResourceQuotaScope defines a filter that must match each object tracked by a quota
0000000000000000000000000000000000000000;;	type ResourceQuotaScope string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Match all pod objects where spec.activeDeadlineSeconds
0000000000000000000000000000000000000000;;		ResourceQuotaScopeTerminating ResourceQuotaScope = "Terminating"
0000000000000000000000000000000000000000;;		// Match all pod objects where !spec.activeDeadlineSeconds
0000000000000000000000000000000000000000;;		ResourceQuotaScopeNotTerminating ResourceQuotaScope = "NotTerminating"
0000000000000000000000000000000000000000;;		// Match all pod objects that have best effort quality of service
0000000000000000000000000000000000000000;;		ResourceQuotaScopeBestEffort ResourceQuotaScope = "BestEffort"
0000000000000000000000000000000000000000;;		// Match all pod objects that do not have best effort quality of service
0000000000000000000000000000000000000000;;		ResourceQuotaScopeNotBestEffort ResourceQuotaScope = "NotBestEffort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
0000000000000000000000000000000000000000;;	type ResourceQuotaSpec struct {
0000000000000000000000000000000000000000;;		// Hard is the set of desired hard limits for each named resource.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/design-proposals/admission_control_resource_quota.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hard ResourceList `json:"hard,omitempty" protobuf:"bytes,1,rep,name=hard,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;		// A collection of filters that must match each object tracked by a quota.
0000000000000000000000000000000000000000;;		// If not specified, the quota matches all objects.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Scopes []ResourceQuotaScope `json:"scopes,omitempty" protobuf:"bytes,2,rep,name=scopes,casttype=ResourceQuotaScope"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceQuotaStatus defines the enforced hard limits and observed use.
0000000000000000000000000000000000000000;;	type ResourceQuotaStatus struct {
0000000000000000000000000000000000000000;;		// Hard is the set of enforced hard limits for each named resource.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/design-proposals/admission_control_resource_quota.md
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Hard ResourceList `json:"hard,omitempty" protobuf:"bytes,1,rep,name=hard,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;		// Used is the current observed total usage of the resource in the namespace.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Used ResourceList `json:"used,omitempty" protobuf:"bytes,2,rep,name=used,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceQuota sets aggregate quota restrictions enforced per namespace
0000000000000000000000000000000000000000;;	type ResourceQuota struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the desired quota.
0000000000000000000000000000000000000000;;		// https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec ResourceQuotaSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status defines the actual enforced quota and its current usage.
0000000000000000000000000000000000000000;;		// https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status ResourceQuotaStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceQuotaList is a list of ResourceQuota items.
0000000000000000000000000000000000000000;;	type ResourceQuotaList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is a list of ResourceQuota objects.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/design-proposals/admission_control_resource_quota.md
0000000000000000000000000000000000000000;;		Items []ResourceQuota `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Secret holds secret data of a certain type. The total bytes of the values in
0000000000000000000000000000000000000000;;	// the Data field must be less than MaxSecretSize bytes.
0000000000000000000000000000000000000000;;	type Secret struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Data contains the secret data. Each key must consist of alphanumeric
0000000000000000000000000000000000000000;;		// characters, '-', '_' or '.'. The serialized form of the secret data is a
0000000000000000000000000000000000000000;;		// base64 encoded string, representing the arbitrary (possibly non-string)
0000000000000000000000000000000000000000;;		// data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Data map[string][]byte `json:"data,omitempty" protobuf:"bytes,2,rep,name=data"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// stringData allows specifying non-binary secret data in string form.
0000000000000000000000000000000000000000;;		// It is provided as a write-only convenience method.
0000000000000000000000000000000000000000;;		// All keys and values are merged into the data field on write, overwriting any existing values.
0000000000000000000000000000000000000000;;		// It is never output when reading from the API.
0000000000000000000000000000000000000000;;		// +k8s:conversion-gen=false
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		StringData map[string]string `json:"stringData,omitempty" protobuf:"bytes,4,rep,name=stringData"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Used to facilitate programmatic handling of secret data.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type SecretType `json:"type,omitempty" protobuf:"bytes,3,opt,name=type,casttype=SecretType"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const MaxSecretSize = 1 * 1024 * 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SecretType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// SecretTypeOpaque is the default. Arbitrary user-defined data
0000000000000000000000000000000000000000;;		SecretTypeOpaque SecretType = "Opaque"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeServiceAccountToken contains a token that identifies a service account to the API
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required fields:
0000000000000000000000000000000000000000;;		// - Secret.Annotations["kubernetes.io/service-account.name"] - the name of the ServiceAccount the token identifies
0000000000000000000000000000000000000000;;		// - Secret.Annotations["kubernetes.io/service-account.uid"] - the UID of the ServiceAccount the token identifies
0000000000000000000000000000000000000000;;		// - Secret.Data["token"] - a token that identifies the service account to the API
0000000000000000000000000000000000000000;;		SecretTypeServiceAccountToken SecretType = "kubernetes.io/service-account-token"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ServiceAccountNameKey is the key of the required annotation for SecretTypeServiceAccountToken secrets
0000000000000000000000000000000000000000;;		ServiceAccountNameKey = "kubernetes.io/service-account.name"
0000000000000000000000000000000000000000;;		// ServiceAccountUIDKey is the key of the required annotation for SecretTypeServiceAccountToken secrets
0000000000000000000000000000000000000000;;		ServiceAccountUIDKey = "kubernetes.io/service-account.uid"
0000000000000000000000000000000000000000;;		// ServiceAccountTokenKey is the key of the required data for SecretTypeServiceAccountToken secrets
0000000000000000000000000000000000000000;;		ServiceAccountTokenKey = "token"
0000000000000000000000000000000000000000;;		// ServiceAccountKubeconfigKey is the key of the optional kubeconfig data for SecretTypeServiceAccountToken secrets
0000000000000000000000000000000000000000;;		ServiceAccountKubeconfigKey = "kubernetes.kubeconfig"
0000000000000000000000000000000000000000;;		// ServiceAccountRootCAKey is the key of the optional root certificate authority for SecretTypeServiceAccountToken secrets
0000000000000000000000000000000000000000;;		ServiceAccountRootCAKey = "ca.crt"
0000000000000000000000000000000000000000;;		// ServiceAccountNamespaceKey is the key of the optional namespace to use as the default for namespaced API calls
0000000000000000000000000000000000000000;;		ServiceAccountNamespaceKey = "namespace"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeDockercfg contains a dockercfg file that follows the same format rules as ~/.dockercfg
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required fields:
0000000000000000000000000000000000000000;;		// - Secret.Data[".dockercfg"] - a serialized ~/.dockercfg file
0000000000000000000000000000000000000000;;		SecretTypeDockercfg SecretType = "kubernetes.io/dockercfg"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DockerConfigKey is the key of the required data for SecretTypeDockercfg secrets
0000000000000000000000000000000000000000;;		DockerConfigKey = ".dockercfg"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeDockerConfigJson contains a dockercfg file that follows the same format rules as ~/.docker/config.json
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required fields:
0000000000000000000000000000000000000000;;		// - Secret.Data[".dockerconfigjson"] - a serialized ~/.docker/config.json file
0000000000000000000000000000000000000000;;		SecretTypeDockerConfigJson SecretType = "kubernetes.io/dockerconfigjson"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DockerConfigJsonKey is the key of the required data for SecretTypeDockerConfigJson secrets
0000000000000000000000000000000000000000;;		DockerConfigJsonKey = ".dockerconfigjson"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeBasicAuth contains data needed for basic authentication.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required at least one of fields:
0000000000000000000000000000000000000000;;		// - Secret.Data["username"] - username used for authentication
0000000000000000000000000000000000000000;;		// - Secret.Data["password"] - password or token needed for authentication
0000000000000000000000000000000000000000;;		SecretTypeBasicAuth SecretType = "kubernetes.io/basic-auth"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BasicAuthUsernameKey is the key of the username for SecretTypeBasicAuth secrets
0000000000000000000000000000000000000000;;		BasicAuthUsernameKey = "username"
0000000000000000000000000000000000000000;;		// BasicAuthPasswordKey is the key of the password or token for SecretTypeBasicAuth secrets
0000000000000000000000000000000000000000;;		BasicAuthPasswordKey = "password"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecretTypeSSHAuth contains data needed for SSH authetication.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required field:
0000000000000000000000000000000000000000;;		// - Secret.Data["ssh-privatekey"] - private SSH key needed for authentication
0000000000000000000000000000000000000000;;		SecretTypeSSHAuth SecretType = "kubernetes.io/ssh-auth"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SSHAuthPrivateKey is the key of the required SSH private key for SecretTypeSSHAuth secrets
0000000000000000000000000000000000000000;;		SSHAuthPrivateKey = "ssh-privatekey"
0000000000000000000000000000000000000000;;		// SecretTypeTLS contains information about a TLS client or server secret. It
0000000000000000000000000000000000000000;;		// is primarily used with TLS termination of the Ingress resource, but may be
0000000000000000000000000000000000000000;;		// used in other types.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Required fields:
0000000000000000000000000000000000000000;;		// - Secret.Data["tls.key"] - TLS private key.
0000000000000000000000000000000000000000;;		//   Secret.Data["tls.crt"] - TLS certificate.
0000000000000000000000000000000000000000;;		// TODO: Consider supporting different formats, specifying CA/destinationCA.
0000000000000000000000000000000000000000;;		SecretTypeTLS SecretType = "kubernetes.io/tls"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLSCertKey is the key for tls certificates in a TLS secert.
0000000000000000000000000000000000000000;;		TLSCertKey = "tls.crt"
0000000000000000000000000000000000000000;;		// TLSPrivateKeyKey is the key for the private key field in a TLS secret.
0000000000000000000000000000000000000000;;		TLSPrivateKeyKey = "tls.key"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecretList is a list of Secret.
0000000000000000000000000000000000000000;;	type SecretList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is a list of secret objects.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/configuration/secret
0000000000000000000000000000000000000000;;		Items []Secret `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigMap holds configuration data for pods to consume.
0000000000000000000000000000000000000000;;	type ConfigMap struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Data contains the configuration data.
0000000000000000000000000000000000000000;;		// Each key must consist of alphanumeric characters, '-', '_' or '.'.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Data map[string]string `json:"data,omitempty" protobuf:"bytes,2,rep,name=data"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigMapList is a resource containing a list of ConfigMap objects.
0000000000000000000000000000000000000000;;	type ConfigMapList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is the list of ConfigMaps.
0000000000000000000000000000000000000000;;		Items []ConfigMap `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type and constants for component health validation.
0000000000000000000000000000000000000000;;	type ComponentConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the valid conditions for the component.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ComponentHealthy ComponentConditionType = "Healthy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Information about the condition of a component.
0000000000000000000000000000000000000000;;	type ComponentCondition struct {
0000000000000000000000000000000000000000;;		// Type of condition for a component.
0000000000000000000000000000000000000000;;		// Valid value: "Healthy"
0000000000000000000000000000000000000000;;		Type ComponentConditionType `json:"type" protobuf:"bytes,1,opt,name=type,casttype=ComponentConditionType"`
0000000000000000000000000000000000000000;;		// Status of the condition for a component.
0000000000000000000000000000000000000000;;		// Valid values for "Healthy": "True", "False", or "Unknown".
0000000000000000000000000000000000000000;;		Status ConditionStatus `json:"status" protobuf:"bytes,2,opt,name=status,casttype=ConditionStatus"`
0000000000000000000000000000000000000000;;		// Message about the condition for a component.
0000000000000000000000000000000000000000;;		// For example, information about a health check.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,3,opt,name=message"`
0000000000000000000000000000000000000000;;		// Condition error code for a component.
0000000000000000000000000000000000000000;;		// For example, a health check error code.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Error string `json:"error,omitempty" protobuf:"bytes,4,opt,name=error"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +nonNamespaced=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ComponentStatus (and ComponentStatusList) holds the cluster validation info.
0000000000000000000000000000000000000000;;	type ComponentStatus struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of component conditions observed
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		// +patchMergeKey=type
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Conditions []ComponentCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,2,rep,name=conditions"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status of all the conditions for the component as a list of ComponentStatus objects.
0000000000000000000000000000000000000000;;	type ComponentStatusList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of ComponentStatus objects.
0000000000000000000000000000000000000000;;		Items []ComponentStatus `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DownwardAPIVolumeSource represents a volume containing downward API info.
0000000000000000000000000000000000000000;;	// Downward API volumes support ownership management and SELinux relabeling.
0000000000000000000000000000000000000000;;	type DownwardAPIVolumeSource struct {
0000000000000000000000000000000000000000;;		// Items is a list of downward API volume file
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []DownwardAPIVolumeFile `json:"items,omitempty" protobuf:"bytes,1,rep,name=items"`
0000000000000000000000000000000000000000;;		// Optional: mode bits to use on created files by default. Must be a
0000000000000000000000000000000000000000;;		// value between 0 and 0777. Defaults to 0644.
0000000000000000000000000000000000000000;;		// Directories within the path are not affected by this setting.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		DefaultMode *int32 `json:"defaultMode,omitempty" protobuf:"varint,2,opt,name=defaultMode"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DownwardAPIVolumeSourceDefaultMode int32 = 0644
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DownwardAPIVolumeFile represents information to create the file containing the pod field
0000000000000000000000000000000000000000;;	type DownwardAPIVolumeFile struct {
0000000000000000000000000000000000000000;;		// Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
0000000000000000000000000000000000000000;;		Path string `json:"path" protobuf:"bytes,1,opt,name=path"`
0000000000000000000000000000000000000000;;		// Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		FieldRef *ObjectFieldSelector `json:"fieldRef,omitempty" protobuf:"bytes,2,opt,name=fieldRef"`
0000000000000000000000000000000000000000;;		// Selects a resource of the container: only resources limits and requests
0000000000000000000000000000000000000000;;		// (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ResourceFieldRef *ResourceFieldSelector `json:"resourceFieldRef,omitempty" protobuf:"bytes,3,opt,name=resourceFieldRef"`
0000000000000000000000000000000000000000;;		// Optional: mode bits to use on this file, must be a value between 0
0000000000000000000000000000000000000000;;		// and 0777. If not specified, the volume defaultMode will be used.
0000000000000000000000000000000000000000;;		// This might be in conflict with other options that affect the file
0000000000000000000000000000000000000000;;		// mode, like fsGroup, and the result can be other mode bits set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Mode *int32 `json:"mode,omitempty" protobuf:"varint,4,opt,name=mode"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents downward API info for projecting into a projected volume.
0000000000000000000000000000000000000000;;	// Note that this is identical to a downwardAPI volume source without the default
0000000000000000000000000000000000000000;;	// mode.
0000000000000000000000000000000000000000;;	type DownwardAPIProjection struct {
0000000000000000000000000000000000000000;;		// Items is a list of DownwardAPIVolume file
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Items []DownwardAPIVolumeFile `json:"items,omitempty" protobuf:"bytes,1,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecurityContext holds security configuration that will be applied to a container.
0000000000000000000000000000000000000000;;	// Some fields are present in both SecurityContext and PodSecurityContext.  When both
0000000000000000000000000000000000000000;;	// are set, the values in SecurityContext take precedence.
0000000000000000000000000000000000000000;;	type SecurityContext struct {
0000000000000000000000000000000000000000;;		// The capabilities to add/drop when running containers.
0000000000000000000000000000000000000000;;		// Defaults to the default set of capabilities granted by the container runtime.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Capabilities *Capabilities `json:"capabilities,omitempty" protobuf:"bytes,1,opt,name=capabilities"`
0000000000000000000000000000000000000000;;		// Run container in privileged mode.
0000000000000000000000000000000000000000;;		// Processes in privileged containers are essentially equivalent to root on the host.
0000000000000000000000000000000000000000;;		// Defaults to false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Privileged *bool `json:"privileged,omitempty" protobuf:"varint,2,opt,name=privileged"`
0000000000000000000000000000000000000000;;		// The SELinux context to be applied to the container.
0000000000000000000000000000000000000000;;		// If unspecified, the container runtime will allocate a random SELinux context for each
0000000000000000000000000000000000000000;;		// container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
0000000000000000000000000000000000000000;;		// PodSecurityContext, the value specified in SecurityContext takes precedence.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		SELinuxOptions *SELinuxOptions `json:"seLinuxOptions,omitempty" protobuf:"bytes,3,opt,name=seLinuxOptions"`
0000000000000000000000000000000000000000;;		// The UID to run the entrypoint of the container process.
0000000000000000000000000000000000000000;;		// Defaults to user specified in image metadata if unspecified.
0000000000000000000000000000000000000000;;		// May also be set in PodSecurityContext.  If set in both SecurityContext and
0000000000000000000000000000000000000000;;		// PodSecurityContext, the value specified in SecurityContext takes precedence.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RunAsUser *int64 `json:"runAsUser,omitempty" protobuf:"varint,4,opt,name=runAsUser"`
0000000000000000000000000000000000000000;;		// Indicates that the container must run as a non-root user.
0000000000000000000000000000000000000000;;		// If true, the Kubelet will validate the image at runtime to ensure that it
0000000000000000000000000000000000000000;;		// does not run as UID 0 (root) and fail to start the container if it does.
0000000000000000000000000000000000000000;;		// If unset or false, no such validation will be performed.
0000000000000000000000000000000000000000;;		// May also be set in PodSecurityContext.  If set in both SecurityContext and
0000000000000000000000000000000000000000;;		// PodSecurityContext, the value specified in SecurityContext takes precedence.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" protobuf:"varint,5,opt,name=runAsNonRoot"`
0000000000000000000000000000000000000000;;		// Whether this container has a read-only root filesystem.
0000000000000000000000000000000000000000;;		// Default is false.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty" protobuf:"varint,6,opt,name=readOnlyRootFilesystem"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SELinuxOptions are the labels to be applied to the container
0000000000000000000000000000000000000000;;	type SELinuxOptions struct {
0000000000000000000000000000000000000000;;		// User is a SELinux user label that applies to the container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		User string `json:"user,omitempty" protobuf:"bytes,1,opt,name=user"`
0000000000000000000000000000000000000000;;		// Role is a SELinux role label that applies to the container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Role string `json:"role,omitempty" protobuf:"bytes,2,opt,name=role"`
0000000000000000000000000000000000000000;;		// Type is a SELinux type label that applies to the container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type string `json:"type,omitempty" protobuf:"bytes,3,opt,name=type"`
0000000000000000000000000000000000000000;;		// Level is SELinux level label that applies to the container.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Level string `json:"level,omitempty" protobuf:"bytes,4,opt,name=level"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RangeAllocation is not a public type.
0000000000000000000000000000000000000000;;	type RangeAllocation struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Range is string that identifies the range represented by 'data'.
0000000000000000000000000000000000000000;;		Range string `json:"range" protobuf:"bytes,2,opt,name=range"`
0000000000000000000000000000000000000000;;		// Data is a bit array containing all allocated addresses in the previous segment.
0000000000000000000000000000000000000000;;		Data []byte `json:"data" protobuf:"bytes,3,opt,name=data"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// "default-scheduler" is the name of default scheduler.
0000000000000000000000000000000000000000;;		DefaultSchedulerName = "default-scheduler"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule
0000000000000000000000000000000000000000;;		// corresponding to every RequiredDuringScheduling affinity rule.
0000000000000000000000000000000000000000;;		// When the --hard-pod-affinity-weight scheduler flag is not specified,
0000000000000000000000000000000000000000;;		// DefaultHardPodAffinityWeight defines the weight of the implicit PreferredDuringScheduling affinity rule.
0000000000000000000000000000000000000000;;		DefaultHardPodAffinitySymmetricWeight int = 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sysctl defines a kernel parameter to be set
0000000000000000000000000000000000000000;;	type Sysctl struct {
0000000000000000000000000000000000000000;;		// Name of a property to set
0000000000000000000000000000000000000000;;		Name string `protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// Value of a property to set
0000000000000000000000000000000000000000;;		Value string `protobuf:"bytes,2,opt,name=value"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeResources is an object for conveying resource information about a node.
0000000000000000000000000000000000000000;;	// see http://releases.k8s.io/HEAD/docs/design/resources.md for more details.
0000000000000000000000000000000000000000;;	type NodeResources struct {
0000000000000000000000000000000000000000;;		// Capacity represents the available resources of a node
0000000000000000000000000000000000000000;;		Capacity ResourceList `protobuf:"bytes,1,rep,name=capacity,casttype=ResourceList,castkey=ResourceName"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Enable stdin for remote command execution
0000000000000000000000000000000000000000;;		ExecStdinParam = "input"
0000000000000000000000000000000000000000;;		// Enable stdout for remote command execution
0000000000000000000000000000000000000000;;		ExecStdoutParam = "output"
0000000000000000000000000000000000000000;;		// Enable stderr for remote command execution
0000000000000000000000000000000000000000;;		ExecStderrParam = "error"
0000000000000000000000000000000000000000;;		// Enable TTY for remote command execution
0000000000000000000000000000000000000000;;		ExecTTYParam = "tty"
0000000000000000000000000000000000000000;;		// Command to run for remote command execution
0000000000000000000000000000000000000000;;		ExecCommandParamm = "command"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of header that specifies stream type
0000000000000000000000000000000000000000;;		StreamType = "streamType"
0000000000000000000000000000000000000000;;		// Value for streamType header for stdin stream
0000000000000000000000000000000000000000;;		StreamTypeStdin = "stdin"
0000000000000000000000000000000000000000;;		// Value for streamType header for stdout stream
0000000000000000000000000000000000000000;;		StreamTypeStdout = "stdout"
0000000000000000000000000000000000000000;;		// Value for streamType header for stderr stream
0000000000000000000000000000000000000000;;		StreamTypeStderr = "stderr"
0000000000000000000000000000000000000000;;		// Value for streamType header for data stream
0000000000000000000000000000000000000000;;		StreamTypeData = "data"
0000000000000000000000000000000000000000;;		// Value for streamType header for error stream
0000000000000000000000000000000000000000;;		StreamTypeError = "error"
0000000000000000000000000000000000000000;;		// Value for streamType header for terminal resize stream
0000000000000000000000000000000000000000;;		StreamTypeResize = "resize"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of header that specifies the port being forwarded
0000000000000000000000000000000000000000;;		PortHeader = "port"
0000000000000000000000000000000000000000;;		// Name of header that specifies a request ID used to associate the error
0000000000000000000000000000000000000000;;		// and data streams for a single forwarded connection
0000000000000000000000000000000000000000;;		PortForwardRequestIDHeader = "requestID"
0000000000000000000000000000000000000000;;	)
