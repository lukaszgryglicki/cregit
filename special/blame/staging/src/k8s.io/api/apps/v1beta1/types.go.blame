0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
3153317738b4c67ab9f03b69f43680dd0ce93c63;pkg/apis/apps/v1alpha1/types.go[pkg/apis/apps/v1alpha1/types.go][staging/src/k8s.io/api/apps/v1beta1/types.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package v1beta1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/intstr"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// StatefulSetInitAnnotation if present, and set to false, indicates that a Pod's readiness should be ignored.
0000000000000000000000000000000000000000;;		StatefulSetInitAnnotation      = "pod.alpha.kubernetes.io/initialized"
0000000000000000000000000000000000000000;;		ControllerRevisionHashLabelKey = "controller-revision-hash"
0000000000000000000000000000000000000000;;		StatefulSetRevisionLabel       = ControllerRevisionHashLabelKey
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleSpec describes the attributes of a scale subresource
0000000000000000000000000000000000000000;;	type ScaleSpec struct {
0000000000000000000000000000000000000000;;		// desired number of instances for the scaled object.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Replicas int32 `json:"replicas,omitempty" protobuf:"varint,1,opt,name=replicas"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ScaleStatus represents the current status of a scale subresource.
0000000000000000000000000000000000000000;;	type ScaleStatus struct {
0000000000000000000000000000000000000000;;		// actual number of observed instances of the scaled object.
0000000000000000000000000000000000000000;;		Replicas int32 `json:"replicas" protobuf:"varint,1,opt,name=replicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// label query over pods that should match the replicas count. More info: http://kubernetes.io/docs/user-guide/labels#label-selectors
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector map[string]string `json:"selector,omitempty" protobuf:"bytes,2,rep,name=selector"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// label selector for pods that should match the replicas count. This is a serializated
0000000000000000000000000000000000000000;;		// version of both map-based and more expressive set-based selectors. This is done to
0000000000000000000000000000000000000000;;		// avoid introspection in the clients. The string will be in the same format as the
0000000000000000000000000000000000000000;;		// query-param syntax. If the target type only supports map-based selectors, both this
0000000000000000000000000000000000000000;;		// field and map-based selector field are populated.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		TargetSelector string `json:"targetSelector,omitempty" protobuf:"bytes,3,opt,name=targetSelector"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	// +noMethods=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scale represents a scaling request for a resource.
0000000000000000000000000000000000000000;;	type Scale struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object metadata; More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// defines the behavior of the scale. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec ScaleSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// current status of the scale. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status. Read-only.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status ScaleStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulSet represents a set of pods with consistent identities.
0000000000000000000000000000000000000000;;	// Identities are defined as:
0000000000000000000000000000000000000000;;	//  - Network: A single stable DNS and hostname.
0000000000000000000000000000000000000000;;	//  - Storage: As many VolumeClaims as requested.
0000000000000000000000000000000000000000;;	// The StatefulSet guarantees that a given network identity will always
0000000000000000000000000000000000000000;;	// map to the same storage identity.
0000000000000000000000000000000000000000;;	type StatefulSet struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spec defines the desired identities of pods in this set.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec StatefulSetSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status is the current status of Pods in this StatefulSet. This data
0000000000000000000000000000000000000000;;		// may be out of date by some window of time.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status StatefulSetStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PodManagementPolicyType defines the policy for creating pods under a stateful set.
0000000000000000000000000000000000000000;;	type PodManagementPolicyType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// OrderedReadyPodManagement will create pods in strictly increasing order on
0000000000000000000000000000000000000000;;		// scale up and strictly decreasing order on scale down, progressing only when
0000000000000000000000000000000000000000;;		// the previous pod is ready or terminated. At most one pod will be changed
0000000000000000000000000000000000000000;;		// at any time.
0000000000000000000000000000000000000000;;		OrderedReadyPodManagement PodManagementPolicyType = "OrderedReady"
0000000000000000000000000000000000000000;;		// ParallelPodManagement will create and delete pods as soon as the stateful set
0000000000000000000000000000000000000000;;		// replica count is changed, and will not wait for pods to be ready or complete
0000000000000000000000000000000000000000;;		// termination.
0000000000000000000000000000000000000000;;		ParallelPodManagement = "Parallel"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulSetUpdateStrategy indicates the strategy that the StatefulSet
0000000000000000000000000000000000000000;;	// controller will use to perform updates. It includes any additional parameters
0000000000000000000000000000000000000000;;	// necessary to perform the update for the indicated strategy.
0000000000000000000000000000000000000000;;	type StatefulSetUpdateStrategy struct {
0000000000000000000000000000000000000000;;		// Type indicates the type of the StatefulSetUpdateStrategy.
0000000000000000000000000000000000000000;;		Type StatefulSetUpdateStrategyType `json:"type,omitempty" protobuf:"bytes,1,opt,name=type,casttype=StatefulSetStrategyType"`
0000000000000000000000000000000000000000;;		// RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
0000000000000000000000000000000000000000;;		RollingUpdate *RollingUpdateStatefulSetStrategy `json:"rollingUpdate,omitempty" protobuf:"bytes,2,opt,name=rollingUpdate"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulSetUpdateStrategyType is a string enumeration type that enumerates
0000000000000000000000000000000000000000;;	// all possible update strategies for the StatefulSet controller.
0000000000000000000000000000000000000000;;	type StatefulSetUpdateStrategyType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// RollingUpdateStatefulSetStrategyType indicates that update will be
0000000000000000000000000000000000000000;;		// applied to all Pods in the StatefulSet with respect to the StatefulSet
0000000000000000000000000000000000000000;;		// ordering constraints. When a scale operation is performed with this
0000000000000000000000000000000000000000;;		// strategy, new Pods will be created from the specification version indicated
0000000000000000000000000000000000000000;;		// by the StatefulSet's updateRevision.
0000000000000000000000000000000000000000;;		RollingUpdateStatefulSetStrategyType = "RollingUpdate"
0000000000000000000000000000000000000000;;		// OnDeleteStatefulSetStrategyType triggers the legacy behavior. Version
0000000000000000000000000000000000000000;;		// tracking and ordered rolling restarts are disabled. Pods are recreated
0000000000000000000000000000000000000000;;		// from the StatefulSetSpec when they are manually deleted. When a scale
0000000000000000000000000000000000000000;;		// operation is performed with this strategy,specification version indicated
0000000000000000000000000000000000000000;;		// by the StatefulSet's currentRevision.
0000000000000000000000000000000000000000;;		OnDeleteStatefulSetStrategyType = "OnDelete"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
0000000000000000000000000000000000000000;;	type RollingUpdateStatefulSetStrategy struct {
0000000000000000000000000000000000000000;;		// Partition indicates the ordinal at which the StatefulSet should be
0000000000000000000000000000000000000000;;		// partitioned.
0000000000000000000000000000000000000000;;		Partition *int32 `json:"partition,omitempty" protobuf:"varint,1,opt,name=partition"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A StatefulSetSpec is the specification of a StatefulSet.
0000000000000000000000000000000000000000;;	type StatefulSetSpec struct {
0000000000000000000000000000000000000000;;		// replicas is the desired number of replicas of the given Template.
0000000000000000000000000000000000000000;;		// These are replicas in the sense that they are instantiations of the
0000000000000000000000000000000000000000;;		// same Template, but individual replicas also have a consistent identity.
0000000000000000000000000000000000000000;;		// If unspecified, defaults to 1.
0000000000000000000000000000000000000000;;		// TODO: Consider a rename of this field.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Replicas *int32 `json:"replicas,omitempty" protobuf:"varint,1,opt,name=replicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// selector is a label query over pods that should match the replica count.
0000000000000000000000000000000000000000;;		// If empty, defaulted to labels on the pod template.
0000000000000000000000000000000000000000;;		// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector *metav1.LabelSelector `json:"selector,omitempty" protobuf:"bytes,2,opt,name=selector"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// template is the object that describes the pod that will be created if
0000000000000000000000000000000000000000;;		// insufficient replicas are detected. Each pod stamped out by the StatefulSet
0000000000000000000000000000000000000000;;		// will fulfill this Template, but have a unique identity from the rest
0000000000000000000000000000000000000000;;		// of the StatefulSet.
0000000000000000000000000000000000000000;;		Template v1.PodTemplateSpec `json:"template" protobuf:"bytes,3,opt,name=template"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// volumeClaimTemplates is a list of claims that pods are allowed to reference.
0000000000000000000000000000000000000000;;		// The StatefulSet controller is responsible for mapping network identities to
0000000000000000000000000000000000000000;;		// claims in a way that maintains the identity of a pod. Every claim in
0000000000000000000000000000000000000000;;		// this list must have at least one matching (by name) volumeMount in one
0000000000000000000000000000000000000000;;		// container in the template. A claim in this list takes precedence over
0000000000000000000000000000000000000000;;		// any volumes in the template, with the same name.
0000000000000000000000000000000000000000;;		// TODO: Define the behavior if a claim already exists with the same name.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		VolumeClaimTemplates []v1.PersistentVolumeClaim `json:"volumeClaimTemplates,omitempty" protobuf:"bytes,4,rep,name=volumeClaimTemplates"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// serviceName is the name of the service that governs this StatefulSet.
0000000000000000000000000000000000000000;;		// This service must exist before the StatefulSet, and is responsible for
0000000000000000000000000000000000000000;;		// the network identity of the set. Pods get DNS/hostnames that follow the
0000000000000000000000000000000000000000;;		// pattern: pod-specific-string.serviceName.default.svc.cluster.local
0000000000000000000000000000000000000000;;		// where "pod-specific-string" is managed by the StatefulSet controller.
0000000000000000000000000000000000000000;;		ServiceName string `json:"serviceName" protobuf:"bytes,5,opt,name=serviceName"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// podManagementPolicy controls how pods are created during initial scale up,
0000000000000000000000000000000000000000;;		// when replacing pods on nodes, or when scaling down. The default policy is
0000000000000000000000000000000000000000;;		// `OrderedReady`, where pods are created in increasing order (pod-0, then
0000000000000000000000000000000000000000;;		// pod-1, etc) and the controller will wait until each pod is ready before
0000000000000000000000000000000000000000;;		// continuing. When scaling down, the pods are removed in the opposite order.
0000000000000000000000000000000000000000;;		// The alternative policy is `Parallel` which will create pods in parallel
0000000000000000000000000000000000000000;;		// to match the desired scale without waiting, and on scale down will delete
0000000000000000000000000000000000000000;;		// all pods at once.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		PodManagementPolicy PodManagementPolicyType `json:"podManagementPolicy,omitempty" protobuf:"bytes,6,opt,name=podManagementPolicy,casttype=PodManagementPolicyType"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// updateStrategy indicates the StatefulSetUpdateStrategy that will be
0000000000000000000000000000000000000000;;		// employed to update Pods in the StatefulSet when a revision is made to
0000000000000000000000000000000000000000;;		// Template.
0000000000000000000000000000000000000000;;		UpdateStrategy StatefulSetUpdateStrategy `json:"updateStrategy,omitempty" protobuf:"bytes,7,opt,name=updateStrategy"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// revisionHistoryLimit is the maximum number of revisions that will
0000000000000000000000000000000000000000;;		// be maintained in the StatefulSet's revision history. The revision history
0000000000000000000000000000000000000000;;		// consists of all revisions not represented by a currently applied
0000000000000000000000000000000000000000;;		// StatefulSetSpec version. The default value is 10.
0000000000000000000000000000000000000000;;		RevisionHistoryLimit *int32 `json:"revisionHistoryLimit,omitempty" protobuf:"varint,8,opt,name=revisionHistoryLimit"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulSetStatus represents the current state of a StatefulSet.
0000000000000000000000000000000000000000;;	type StatefulSetStatus struct {
0000000000000000000000000000000000000000;;		// observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
0000000000000000000000000000000000000000;;		// StatefulSet's generation, which is updated on mutation by the API Server.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ObservedGeneration *int64 `json:"observedGeneration,omitempty" protobuf:"varint,1,opt,name=observedGeneration"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// replicas is the number of Pods created by the StatefulSet controller.
0000000000000000000000000000000000000000;;		Replicas int32 `json:"replicas" protobuf:"varint,2,opt,name=replicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readyReplicas is the number of Pods created by the StatefulSet controller that have a Ready Condition.
0000000000000000000000000000000000000000;;		ReadyReplicas int32 `json:"readyReplicas,omitempty" protobuf:"varint,3,opt,name=readyReplicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
0000000000000000000000000000000000000000;;		// indicated by currentRevision.
0000000000000000000000000000000000000000;;		CurrentReplicas int32 `json:"currentReplicas,omitempty" protobuf:"varint,4,opt,name=currentReplicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
0000000000000000000000000000000000000000;;		// indicated by updateRevision.
0000000000000000000000000000000000000000;;		UpdatedReplicas int32 `json:"updatedReplicas,omitempty" protobuf:"varint,5,opt,name=updatedReplicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
0000000000000000000000000000000000000000;;		// sequence [0,currentReplicas).
0000000000000000000000000000000000000000;;		CurrentRevision string `json:"currentRevision,omitempty" protobuf:"bytes,6,opt,name=currentRevision"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
0000000000000000000000000000000000000000;;		// [replicas-updatedReplicas,replicas)
0000000000000000000000000000000000000000;;		UpdateRevision string `json:"updateRevision,omitempty" protobuf:"bytes,7,opt,name=updateRevision"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatefulSetList is a collection of StatefulSets.
0000000000000000000000000000000000000000;;	type StatefulSetList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;		Items           []StatefulSet `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deployment enables declarative updates for Pods and ReplicaSets.
0000000000000000000000000000000000000000;;	type Deployment struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Specification of the desired behavior of the Deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Spec DeploymentSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Most recently observed status of the Deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Status DeploymentStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentSpec is the specification of the desired behavior of the Deployment.
0000000000000000000000000000000000000000;;	type DeploymentSpec struct {
0000000000000000000000000000000000000000;;		// Number of desired pods. This is a pointer to distinguish between explicit
0000000000000000000000000000000000000000;;		// zero and not specified. Defaults to 1.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Replicas *int32 `json:"replicas,omitempty" protobuf:"varint,1,opt,name=replicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Label selector for pods. Existing ReplicaSets whose pods are
0000000000000000000000000000000000000000;;		// selected by this will be the ones affected by this deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Selector *metav1.LabelSelector `json:"selector,omitempty" protobuf:"bytes,2,opt,name=selector"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Template describes the pods that will be created.
0000000000000000000000000000000000000000;;		Template v1.PodTemplateSpec `json:"template" protobuf:"bytes,3,opt,name=template"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The deployment strategy to use to replace existing pods with new ones.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Strategy DeploymentStrategy `json:"strategy,omitempty" protobuf:"bytes,4,opt,name=strategy"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Minimum number of seconds for which a newly created pod should be ready
0000000000000000000000000000000000000000;;		// without any of its container crashing, for it to be considered available.
0000000000000000000000000000000000000000;;		// Defaults to 0 (pod will be considered available as soon as it is ready)
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MinReadySeconds int32 `json:"minReadySeconds,omitempty" protobuf:"varint,5,opt,name=minReadySeconds"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The number of old ReplicaSets to retain to allow rollback.
0000000000000000000000000000000000000000;;		// This is a pointer to distinguish between explicit zero and not specified.
0000000000000000000000000000000000000000;;		// Defaults to 2.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RevisionHistoryLimit *int32 `json:"revisionHistoryLimit,omitempty" protobuf:"varint,6,opt,name=revisionHistoryLimit"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Indicates that the deployment is paused.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Paused bool `json:"paused,omitempty" protobuf:"varint,7,opt,name=paused"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The config this deployment is rolling back to. Will be cleared after rollback is done.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RollbackTo *RollbackConfig `json:"rollbackTo,omitempty" protobuf:"bytes,8,opt,name=rollbackTo"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The maximum time in seconds for a deployment to make progress before it
0000000000000000000000000000000000000000;;		// is considered to be failed. The deployment controller will continue to
0000000000000000000000000000000000000000;;		// process failed deployments and a condition with a ProgressDeadlineExceeded
0000000000000000000000000000000000000000;;		// reason will be surfaced in the deployment status. Once autoRollback is
0000000000000000000000000000000000000000;;		// implemented, the deployment controller will automatically rollback failed
0000000000000000000000000000000000000000;;		// deployments. Note that progress will not be estimated during the time a
0000000000000000000000000000000000000000;;		// deployment is paused. Defaults to 600s.
0000000000000000000000000000000000000000;;		ProgressDeadlineSeconds *int32 `json:"progressDeadlineSeconds,omitempty" protobuf:"varint,9,opt,name=progressDeadlineSeconds"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentRollback stores the information required to rollback a deployment.
0000000000000000000000000000000000000000;;	type DeploymentRollback struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Required: This must match the Name of a deployment.
0000000000000000000000000000000000000000;;		Name string `json:"name" protobuf:"bytes,1,opt,name=name"`
0000000000000000000000000000000000000000;;		// The annotations to be updated to a deployment
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UpdatedAnnotations map[string]string `json:"updatedAnnotations,omitempty" protobuf:"bytes,2,rep,name=updatedAnnotations"`
0000000000000000000000000000000000000000;;		// The config of this deployment rollback.
0000000000000000000000000000000000000000;;		RollbackTo RollbackConfig `json:"rollbackTo" protobuf:"bytes,3,opt,name=rollbackTo"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RollbackConfig struct {
0000000000000000000000000000000000000000;;		// The revision to rollback to. If set to 0, rollback to the last revision.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Revision int64 `json:"revision,omitempty" protobuf:"varint,1,opt,name=revision"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DefaultDeploymentUniqueLabelKey is the default key of the selector that is added
0000000000000000000000000000000000000000;;		// to existing RCs (and label key that is added to its pods) to prevent the existing RCs
0000000000000000000000000000000000000000;;		// to select new pods (and old pods being select by new RC).
0000000000000000000000000000000000000000;;		DefaultDeploymentUniqueLabelKey string = "pod-template-hash"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentStrategy describes how to replace existing pods with new ones.
0000000000000000000000000000000000000000;;	type DeploymentStrategy struct {
0000000000000000000000000000000000000000;;		// Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Type DeploymentStrategyType `json:"type,omitempty" protobuf:"bytes,1,opt,name=type,casttype=DeploymentStrategyType"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rolling update config params. Present only if DeploymentStrategyType =
0000000000000000000000000000000000000000;;		// RollingUpdate.
0000000000000000000000000000000000000000;;		//---
0000000000000000000000000000000000000000;;		// TODO: Update this to follow our convention for oneOf, whatever we decide it
0000000000000000000000000000000000000000;;		// to be.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		RollingUpdate *RollingUpdateDeployment `json:"rollingUpdate,omitempty" protobuf:"bytes,2,opt,name=rollingUpdate"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentStrategyType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Kill all existing pods before creating new ones.
0000000000000000000000000000000000000000;;		RecreateDeploymentStrategyType DeploymentStrategyType = "Recreate"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Replace the old RCs by new one using rolling update i.e gradually scale down the old RCs and scale up the new one.
0000000000000000000000000000000000000000;;		RollingUpdateDeploymentStrategyType DeploymentStrategyType = "RollingUpdate"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Spec to control the desired behavior of rolling update.
0000000000000000000000000000000000000000;;	type RollingUpdateDeployment struct {
0000000000000000000000000000000000000000;;		// The maximum number of pods that can be unavailable during the update.
0000000000000000000000000000000000000000;;		// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
0000000000000000000000000000000000000000;;		// Absolute number is calculated from percentage by rounding down.
0000000000000000000000000000000000000000;;		// This can not be 0 if MaxSurge is 0.
0000000000000000000000000000000000000000;;		// Defaults to 25%.
0000000000000000000000000000000000000000;;		// Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods
0000000000000000000000000000000000000000;;		// immediately when the rolling update starts. Once new pods are ready, old RC
0000000000000000000000000000000000000000;;		// can be scaled down further, followed by scaling up the new RC, ensuring
0000000000000000000000000000000000000000;;		// that the total number of pods available at all times during the update is at
0000000000000000000000000000000000000000;;		// least 70% of desired pods.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MaxUnavailable *intstr.IntOrString `json:"maxUnavailable,omitempty" protobuf:"bytes,1,opt,name=maxUnavailable"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The maximum number of pods that can be scheduled above the desired number of
0000000000000000000000000000000000000000;;		// pods.
0000000000000000000000000000000000000000;;		// Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
0000000000000000000000000000000000000000;;		// This can not be 0 if MaxUnavailable is 0.
0000000000000000000000000000000000000000;;		// Absolute number is calculated from percentage by rounding up.
0000000000000000000000000000000000000000;;		// Defaults to 25%.
0000000000000000000000000000000000000000;;		// Example: when this is set to 30%, the new RC can be scaled up immediately when
0000000000000000000000000000000000000000;;		// the rolling update starts, such that the total number of old and new pods do not exceed
0000000000000000000000000000000000000000;;		// 130% of desired pods. Once old pods have been killed,
0000000000000000000000000000000000000000;;		// new RC can be scaled up further, ensuring that total number of pods running
0000000000000000000000000000000000000000;;		// at any time during the update is atmost 130% of desired pods.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		MaxSurge *intstr.IntOrString `json:"maxSurge,omitempty" protobuf:"bytes,2,opt,name=maxSurge"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentStatus is the most recently observed status of the Deployment.
0000000000000000000000000000000000000000;;	type DeploymentStatus struct {
0000000000000000000000000000000000000000;;		// The generation observed by the deployment controller.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ObservedGeneration int64 `json:"observedGeneration,omitempty" protobuf:"varint,1,opt,name=observedGeneration"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of non-terminated pods targeted by this deployment (their labels match the selector).
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		Replicas int32 `json:"replicas,omitempty" protobuf:"varint,2,opt,name=replicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of non-terminated pods targeted by this deployment that have the desired template spec.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UpdatedReplicas int32 `json:"updatedReplicas,omitempty" protobuf:"varint,3,opt,name=updatedReplicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of ready pods targeted by this deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		ReadyReplicas int32 `json:"readyReplicas,omitempty" protobuf:"varint,7,opt,name=readyReplicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		AvailableReplicas int32 `json:"availableReplicas,omitempty" protobuf:"varint,4,opt,name=availableReplicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of unavailable pods targeted by this deployment.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		UnavailableReplicas int32 `json:"unavailableReplicas,omitempty" protobuf:"varint,5,opt,name=unavailableReplicas"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Represents the latest available observations of a deployment's current state.
0000000000000000000000000000000000000000;;		// +patchMergeKey=type
0000000000000000000000000000000000000000;;		// +patchStrategy=merge
0000000000000000000000000000000000000000;;		Conditions []DeploymentCondition `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type" protobuf:"bytes,6,rep,name=conditions"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Count of hash collisions for the Deployment. The Deployment controller uses this
0000000000000000000000000000000000000000;;		// field as a collision avoidance mechanism when it needs to create the name for the
0000000000000000000000000000000000000000;;		// newest ReplicaSet.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		CollisionCount *int64 `json:"collisionCount,omitempty" protobuf:"varint,8,opt,name=collisionCount"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeploymentConditionType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are valid conditions of a deployment.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Available means the deployment is available, ie. at least the minimum available
0000000000000000000000000000000000000000;;		// replicas required are up and running for at least minReadySeconds.
0000000000000000000000000000000000000000;;		DeploymentAvailable DeploymentConditionType = "Available"
0000000000000000000000000000000000000000;;		// Progressing means the deployment is progressing. Progress for a deployment is
0000000000000000000000000000000000000000;;		// considered when a new replica set is created or adopted, and when new pods scale
0000000000000000000000000000000000000000;;		// up or old pods scale down. Progress is not estimated for paused deployments or
0000000000000000000000000000000000000000;;		// when progressDeadlineSeconds is not specified.
0000000000000000000000000000000000000000;;		DeploymentProgressing DeploymentConditionType = "Progressing"
0000000000000000000000000000000000000000;;		// ReplicaFailure is added in a deployment when one of its pods fails to be created
0000000000000000000000000000000000000000;;		// or deleted.
0000000000000000000000000000000000000000;;		DeploymentReplicaFailure DeploymentConditionType = "ReplicaFailure"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentCondition describes the state of a deployment at a certain point.
0000000000000000000000000000000000000000;;	type DeploymentCondition struct {
0000000000000000000000000000000000000000;;		// Type of deployment condition.
0000000000000000000000000000000000000000;;		Type DeploymentConditionType `json:"type" protobuf:"bytes,1,opt,name=type,casttype=DeploymentConditionType"`
0000000000000000000000000000000000000000;;		// Status of the condition, one of True, False, Unknown.
0000000000000000000000000000000000000000;;		Status v1.ConditionStatus `json:"status" protobuf:"bytes,2,opt,name=status,casttype=k8s.io/api/core/v1.ConditionStatus"`
0000000000000000000000000000000000000000;;		// The last time this condition was updated.
0000000000000000000000000000000000000000;;		LastUpdateTime metav1.Time `json:"lastUpdateTime,omitempty" protobuf:"bytes,6,opt,name=lastUpdateTime"`
0000000000000000000000000000000000000000;;		// Last time the condition transitioned from one status to another.
0000000000000000000000000000000000000000;;		LastTransitionTime metav1.Time `json:"lastTransitionTime,omitempty" protobuf:"bytes,7,opt,name=lastTransitionTime"`
0000000000000000000000000000000000000000;;		// The reason for the condition's last transition.
0000000000000000000000000000000000000000;;		Reason string `json:"reason,omitempty" protobuf:"bytes,4,opt,name=reason"`
0000000000000000000000000000000000000000;;		// A human readable message indicating details about the transition.
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty" protobuf:"bytes,5,opt,name=message"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeploymentList is a list of Deployments.
0000000000000000000000000000000000000000;;	type DeploymentList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard list metadata.
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is the list of Deployments.
0000000000000000000000000000000000000000;;		Items []Deployment `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// +genclient=true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllerRevision implements an immutable snapshot of state data. Clients
0000000000000000000000000000000000000000;;	// are responsible for serializing and deserializing the objects that contain
0000000000000000000000000000000000000000;;	// their internal state.
0000000000000000000000000000000000000000;;	// Once a ControllerRevision has been successfully created, it can not be updated.
0000000000000000000000000000000000000000;;	// The API Server will fail validation of all requests that attempt to mutate
0000000000000000000000000000000000000000;;	// the Data field. ControllerRevisions may, however, be deleted. Note that, due to its use by both
0000000000000000000000000000000000000000;;	// the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However,
0000000000000000000000000000000000000000;;	// it may be subject to name and representation changes in future releases, and clients should not
0000000000000000000000000000000000000000;;	// depend on its stability. It is primarily for internal use by controllers.
0000000000000000000000000000000000000000;;	type ControllerRevision struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;		// Standard object's metadata.
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Data is the serialized representation of the state.
0000000000000000000000000000000000000000;;		Data runtime.RawExtension `json:"data,omitempty" protobuf:"bytes,2,opt,name=data"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Revision indicates the revision of the state represented by Data.
0000000000000000000000000000000000000000;;		Revision int64 `json:"revision" protobuf:"varint,3,opt,name=revision"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ControllerRevisionList is a resource containing a list of ControllerRevision objects.
0000000000000000000000000000000000000000;;	type ControllerRevisionList struct {
0000000000000000000000000000000000000000;;		metav1.TypeMeta `json:",inline"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
0000000000000000000000000000000000000000;;		// +optional
0000000000000000000000000000000000000000;;		metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Items is the list of ControllerRevisions
0000000000000000000000000000000000000000;;		Items []ControllerRevision `json:"items" protobuf:"bytes,2,rep,name=items"`
0000000000000000000000000000000000000000;;	}
