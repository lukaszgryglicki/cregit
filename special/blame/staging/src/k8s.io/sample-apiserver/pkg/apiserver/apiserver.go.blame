0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
65e2658d07609908d94d45be9ecdd474b6d84de9;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/announced"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/registered"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/version"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/sample-apiserver/pkg/apis/wardle"
0000000000000000000000000000000000000000;;		"k8s.io/sample-apiserver/pkg/apis/wardle/install"
0000000000000000000000000000000000000000;;		"k8s.io/sample-apiserver/pkg/apis/wardle/v1alpha1"
0000000000000000000000000000000000000000;;		fischerstorage "k8s.io/sample-apiserver/pkg/registry/wardle/fischer"
0000000000000000000000000000000000000000;;		flunderstorage "k8s.io/sample-apiserver/pkg/registry/wardle/flunder"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		groupFactoryRegistry = make(announced.APIGroupFactoryRegistry)
0000000000000000000000000000000000000000;;		registry             = registered.NewOrDie("")
0000000000000000000000000000000000000000;;		Scheme               = runtime.NewScheme()
0000000000000000000000000000000000000000;;		Codecs               = serializer.NewCodecFactory(Scheme)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		install.Install(groupFactoryRegistry, registry, Scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we need to add the options to empty v1
0000000000000000000000000000000000000000;;		// TODO fix the server code to avoid this
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(Scheme, schema.GroupVersion{Version: "v1"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: keep the generic API server from wanting this
0000000000000000000000000000000000000000;;		unversioned := schema.GroupVersion{Group: "", Version: "v1"}
0000000000000000000000000000000000000000;;		Scheme.AddUnversionedTypes(unversioned,
0000000000000000000000000000000000000000;;			&metav1.Status{},
0000000000000000000000000000000000000000;;			&metav1.APIVersions{},
0000000000000000000000000000000000000000;;			&metav1.APIGroupList{},
0000000000000000000000000000000000000000;;			&metav1.APIGroup{},
0000000000000000000000000000000000000000;;			&metav1.APIResourceList{},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		GenericConfig *genericapiserver.Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WardleServer contains state for a Kubernetes cluster master/api server.
0000000000000000000000000000000000000000;;	type WardleServer struct {
0000000000000000000000000000000000000000;;		GenericAPIServer *genericapiserver.GenericAPIServer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type completedConfig struct {
0000000000000000000000000000000000000000;;		*Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete fills in any fields not set that are required to have valid data. It's mutating the receiver.
0000000000000000000000000000000000000000;;	func (c *Config) Complete() completedConfig {
0000000000000000000000000000000000000000;;		c.GenericConfig.Complete()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.GenericConfig.Version = &version.Info{
0000000000000000000000000000000000000000;;			Major: "1",
0000000000000000000000000000000000000000;;			Minor: "0",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return completedConfig{c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SkipComplete provides a way to construct a server instance without config completion.
0000000000000000000000000000000000000000;;	func (c *Config) SkipComplete() completedConfig {
0000000000000000000000000000000000000000;;		return completedConfig{c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new instance of WardleServer from the given config.
0000000000000000000000000000000000000000;;	func (c completedConfig) New() (*WardleServer, error) {
0000000000000000000000000000000000000000;;		genericServer, err := c.Config.GenericConfig.SkipComplete().New("sample-apiserver", genericapiserver.EmptyDelegate) // completion is done in Complete, no need for a second time
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &WardleServer{
0000000000000000000000000000000000000000;;			GenericAPIServer: genericServer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(wardle.GroupName, registry, Scheme, metav1.ParameterCodec, Codecs)
0000000000000000000000000000000000000000;;		apiGroupInfo.GroupMeta.GroupVersion = v1alpha1.SchemeGroupVersion
0000000000000000000000000000000000000000;;		v1alpha1storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		v1alpha1storage["flunders"] = flunderstorage.RESTInPeace(Scheme, c.GenericConfig.RESTOptionsGetter)
0000000000000000000000000000000000000000;;		v1alpha1storage["fischers"] = fischerstorage.RESTInPeace(Scheme, c.GenericConfig.RESTOptionsGetter)
0000000000000000000000000000000000000000;;		apiGroupInfo.VersionedResourcesStorageMap["v1alpha1"] = v1alpha1storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.GenericAPIServer.InstallAPIGroup(&apiGroupInfo); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
