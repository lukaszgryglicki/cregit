0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
09f1f01b22f6589767420d358a8d96c52abb423b;cmd/kubernetes-discovery/pkg/apiserver/handler_proxy.go[cmd/kubernetes-discovery/pkg/apiserver/handler_proxy.go][staging/src/k8s.io/kube-aggregator/pkg/apiserver/handler_proxy.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream/spdy"
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/proxy"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		genericfeatures "k8s.io/apiserver/pkg/features"
0000000000000000000000000000000000000000;;		utilfeature "k8s.io/apiserver/pkg/util/feature"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/transport"
0000000000000000000000000000000000000000;;		apiregistrationapi "k8s.io/kube-aggregator/pkg/apis/apiregistration"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// proxyHandler provides a http.Handler which will proxy traffic to locations
0000000000000000000000000000000000000000;;	// specified by items implementing Redirector.
0000000000000000000000000000000000000000;;	type proxyHandler struct {
0000000000000000000000000000000000000000;;		contextMapper genericapirequest.RequestContextMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// localDelegate is used to satisfy local APIServices
0000000000000000000000000000000000000000;;		localDelegate http.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// proxyClientCert/Key are the client cert used to identify this proxy. Backing APIServices use
0000000000000000000000000000000000000000;;		// this to confirm the proxy's identity
0000000000000000000000000000000000000000;;		proxyClientCert []byte
0000000000000000000000000000000000000000;;		proxyClientKey  []byte
0000000000000000000000000000000000000000;;		proxyTransport  *http.Transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Endpoints based routing to map from cluster IP to routable IP
0000000000000000000000000000000000000000;;		serviceResolver ServiceResolver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handlingInfo atomic.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type proxyHandlingInfo struct {
0000000000000000000000000000000000000000;;		// local indicates that this APIService is locally satisfied
0000000000000000000000000000000000000000;;		local bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// restConfig holds the information for building a roundtripper
0000000000000000000000000000000000000000;;		restConfig *restclient.Config
0000000000000000000000000000000000000000;;		// transportBuildingError is an error produced while building the transport.  If this
0000000000000000000000000000000000000000;;		// is non-nil, it will be reported to clients.
0000000000000000000000000000000000000000;;		transportBuildingError error
0000000000000000000000000000000000000000;;		// proxyRoundTripper is the re-useable portion of the transport.  It does not vary with any request.
0000000000000000000000000000000000000000;;		proxyRoundTripper http.RoundTripper
0000000000000000000000000000000000000000;;		// serviceName is the name of the service this handler proxies to
0000000000000000000000000000000000000000;;		serviceName string
0000000000000000000000000000000000000000;;		// namespace is the namespace the service lives in
0000000000000000000000000000000000000000;;		serviceNamespace string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *proxyHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		value := r.handlingInfo.Load()
0000000000000000000000000000000000000000;;		if value == nil {
0000000000000000000000000000000000000000;;			r.localDelegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handlingInfo := value.(proxyHandlingInfo)
0000000000000000000000000000000000000000;;		if handlingInfo.local {
0000000000000000000000000000000000000000;;			if r.localDelegate == nil {
0000000000000000000000000000000000000000;;				http.Error(w, "", http.StatusNotFound)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.localDelegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if handlingInfo.transportBuildingError != nil {
0000000000000000000000000000000000000000;;			http.Error(w, handlingInfo.transportBuildingError.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, ok := r.contextMapper.Get(req)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			http.Error(w, "missing context", http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		user, ok := genericapirequest.UserFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			http.Error(w, "missing user", http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// write a new location based on the existing request pointed at the target service
0000000000000000000000000000000000000000;;		location := &url.URL{}
0000000000000000000000000000000000000000;;		location.Scheme = "https"
0000000000000000000000000000000000000000;;		rloc, err := r.serviceResolver.ResolveEndpoint(handlingInfo.serviceNamespace, handlingInfo.serviceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, fmt.Sprintf("missing route (%s)", err.Error()), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		location.Host = rloc.Host
0000000000000000000000000000000000000000;;		location.Path = req.URL.Path
0000000000000000000000000000000000000000;;		location.RawQuery = req.URL.Query().Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WithContext creates a shallow clone of the request with the new context.
0000000000000000000000000000000000000000;;		newReq := req.WithContext(context.Background())
0000000000000000000000000000000000000000;;		newReq.Header = utilnet.CloneHeader(req.Header)
0000000000000000000000000000000000000000;;		newReq.URL = location
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if handlingInfo.proxyRoundTripper == nil {
0000000000000000000000000000000000000000;;			http.Error(w, "", http.StatusNotFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we need to wrap the roundtripper in another roundtripper which will apply the front proxy headers
0000000000000000000000000000000000000000;;		proxyRoundTripper, upgrade, err := maybeWrapForConnectionUpgrades(handlingInfo.restConfig, handlingInfo.proxyRoundTripper, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxyRoundTripper = transport.NewAuthProxyRoundTripper(user.GetName(), user.GetGroups(), user.GetExtra(), proxyRoundTripper)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we are upgrading, then the upgrade path tries to use this request with the TLS config we provide, but it does
0000000000000000000000000000000000000000;;		// NOT use the roundtripper.  Its a direct call that bypasses the round tripper.  This means that we have to
0000000000000000000000000000000000000000;;		// attach the "correct" user headers to the request ahead of time.  After the initial upgrade, we'll be back
0000000000000000000000000000000000000000;;		// at the roundtripper flow, so we only have to muck with this request, but we do have to do it.
0000000000000000000000000000000000000000;;		if upgrade {
0000000000000000000000000000000000000000;;			transport.SetAuthProxyHeaders(newReq, user.GetName(), user.GetGroups(), user.GetExtra())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := proxy.NewUpgradeAwareHandler(location, proxyRoundTripper, true, upgrade, &responder{w: w})
0000000000000000000000000000000000000000;;		handler.ServeHTTP(w, newReq)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maybeWrapForConnectionUpgrades wraps the roundtripper for upgrades.  The bool indicates if it was wrapped
0000000000000000000000000000000000000000;;	func maybeWrapForConnectionUpgrades(restConfig *restclient.Config, rt http.RoundTripper, req *http.Request) (http.RoundTripper, bool, error) {
0000000000000000000000000000000000000000;;		if !httpstream.IsUpgradeRequest(req) {
0000000000000000000000000000000000000000;;			return rt, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsConfig, err := restclient.TLSConfigFor(restConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		followRedirects := utilfeature.DefaultFeatureGate.Enabled(genericfeatures.StreamingProxyRedirects)
0000000000000000000000000000000000000000;;		upgradeRoundTripper := spdy.NewRoundTripper(tlsConfig, followRedirects)
0000000000000000000000000000000000000000;;		wrappedRT, err := restclient.HTTPWrappersForConfig(restConfig, upgradeRoundTripper)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return wrappedRT, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// responder implements rest.Responder for assisting a connector in writing objects or errors.
0000000000000000000000000000000000000000;;	type responder struct {
0000000000000000000000000000000000000000;;		w http.ResponseWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO this should properly handle content type negotiation
0000000000000000000000000000000000000000;;	// if the caller asked for protobuf and you write JSON bad things happen.
0000000000000000000000000000000000000000;;	func (r *responder) Object(statusCode int, obj runtime.Object) {
0000000000000000000000000000000000000000;;		responsewriters.WriteRawJSON(statusCode, obj, r.w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *responder) Error(err error) {
0000000000000000000000000000000000000000;;		http.Error(r.w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// these methods provide locked access to fields
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *proxyHandler) updateAPIService(apiService *apiregistrationapi.APIService) {
0000000000000000000000000000000000000000;;		if apiService.Spec.Service == nil {
0000000000000000000000000000000000000000;;			r.handlingInfo.Store(proxyHandlingInfo{local: true})
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newInfo := proxyHandlingInfo{
0000000000000000000000000000000000000000;;			restConfig: &restclient.Config{
0000000000000000000000000000000000000000;;				TLSClientConfig: restclient.TLSClientConfig{
0000000000000000000000000000000000000000;;					Insecure:   apiService.Spec.InsecureSkipTLSVerify,
0000000000000000000000000000000000000000;;					ServerName: apiService.Spec.Service.Name + "." + apiService.Spec.Service.Namespace + ".svc",
0000000000000000000000000000000000000000;;					CertData:   r.proxyClientCert,
0000000000000000000000000000000000000000;;					KeyData:    r.proxyClientKey,
0000000000000000000000000000000000000000;;					CAData:     apiService.Spec.CABundle,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			serviceName:      apiService.Spec.Service.Name,
0000000000000000000000000000000000000000;;			serviceNamespace: apiService.Spec.Service.Namespace,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newInfo.proxyRoundTripper, newInfo.transportBuildingError = restclient.TransportFor(newInfo.restConfig)
0000000000000000000000000000000000000000;;		if newInfo.transportBuildingError == nil && r.proxyTransport.Dial != nil {
0000000000000000000000000000000000000000;;			switch transport := newInfo.proxyRoundTripper.(type) {
0000000000000000000000000000000000000000;;			case *http.Transport:
0000000000000000000000000000000000000000;;				transport.Dial = r.proxyTransport.Dial
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				newInfo.transportBuildingError = fmt.Errorf("unable to set dialer for %s/%s as rest transport is of type %T", apiService.Spec.Service.Namespace, apiService.Spec.Service.Name, newInfo.proxyRoundTripper)
0000000000000000000000000000000000000000;;				glog.Warning(newInfo.transportBuildingError.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.handlingInfo.Store(newInfo)
0000000000000000000000000000000000000000;;	}
