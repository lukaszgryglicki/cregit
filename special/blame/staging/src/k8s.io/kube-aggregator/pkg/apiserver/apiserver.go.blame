0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
67d532dbf7c0c0269211b52030c9a0e19d6c22ee;cmd/kubernetes-discovery/pkg/apiserver/apiserver.go[cmd/kubernetes-discovery/pkg/apiserver/apiserver.go][staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/announced"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apimachinery/registered"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/registry/rest"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		kubeinformers "k8s.io/client-go/informers"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/pkg/version"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/pkg/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/openapi"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/transport"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/apis/apiregistration"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/apis/apiregistration/install"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/apis/apiregistration/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/client/clientset_generated/internalclientset"
0000000000000000000000000000000000000000;;		informers "k8s.io/kube-aggregator/pkg/client/informers/internalversion"
0000000000000000000000000000000000000000;;		listers "k8s.io/kube-aggregator/pkg/client/listers/apiregistration/internalversion"
0000000000000000000000000000000000000000;;		statuscontrollers "k8s.io/kube-aggregator/pkg/controllers/status"
0000000000000000000000000000000000000000;;		apiservicestorage "k8s.io/kube-aggregator/pkg/registry/apiservice/etcd"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		groupFactoryRegistry = make(announced.APIGroupFactoryRegistry)
0000000000000000000000000000000000000000;;		registry             = registered.NewOrDie("")
0000000000000000000000000000000000000000;;		Scheme               = runtime.NewScheme()
0000000000000000000000000000000000000000;;		Codecs               = serializer.NewCodecFactory(Scheme)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		LOAD_OPENAPI_SPEC_MAX_RETRIES = 10
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		install.Install(groupFactoryRegistry, registry, Scheme)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we need to add the options (like ListOptions) to empty v1
0000000000000000000000000000000000000000;;		metav1.AddToGroupVersion(Scheme, schema.GroupVersion{Group: "", Version: "v1"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unversioned := schema.GroupVersion{Group: "", Version: "v1"}
0000000000000000000000000000000000000000;;		Scheme.AddUnversionedTypes(unversioned,
0000000000000000000000000000000000000000;;			&metav1.Status{},
0000000000000000000000000000000000000000;;			&metav1.APIVersions{},
0000000000000000000000000000000000000000;;			&metav1.APIGroupList{},
0000000000000000000000000000000000000000;;			&metav1.APIGroup{},
0000000000000000000000000000000000000000;;			&metav1.APIResourceList{},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// legacyAPIServiceName is the fixed name of the only non-groupified API version
0000000000000000000000000000000000000000;;	const legacyAPIServiceName = "v1."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		GenericConfig *genericapiserver.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CoreKubeInformers is used to watch kube resources
0000000000000000000000000000000000000000;;		CoreKubeInformers kubeinformers.SharedInformerFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ProxyClientCert/Key are the client cert used to identify this proxy. Backing APIServices use
0000000000000000000000000000000000000000;;		// this to confirm the proxy's identity
0000000000000000000000000000000000000000;;		ProxyClientCert []byte
0000000000000000000000000000000000000000;;		ProxyClientKey  []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If present, the Dial method will be used for dialing out to delegate
0000000000000000000000000000000000000000;;		// apiservers.
0000000000000000000000000000000000000000;;		ProxyTransport *http.Transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mechanism by which the Aggregator will resolve services. Required.
0000000000000000000000000000000000000000;;		ServiceResolver ServiceResolver
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIAggregator contains state for a Kubernetes cluster master/api server.
0000000000000000000000000000000000000000;;	type APIAggregator struct {
0000000000000000000000000000000000000000;;		GenericAPIServer *genericapiserver.GenericAPIServer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delegateHandler http.Handler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contextMapper genericapirequest.RequestContextMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// proxyClientCert/Key are the client cert used to identify this proxy. Backing APIServices use
0000000000000000000000000000000000000000;;		// this to confirm the proxy's identity
0000000000000000000000000000000000000000;;		proxyClientCert []byte
0000000000000000000000000000000000000000;;		proxyClientKey  []byte
0000000000000000000000000000000000000000;;		proxyTransport  *http.Transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// proxyHandlers are the proxy handlers that are currently registered, keyed by apiservice.name
0000000000000000000000000000000000000000;;		proxyHandlers map[string]*proxyHandler
0000000000000000000000000000000000000000;;		// handledGroups are the groups that already have routes
0000000000000000000000000000000000000000;;		handledGroups sets.String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Swagger spec for each api service
0000000000000000000000000000000000000000;;		apiServiceSpecs map[string]*spec.Swagger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of the specs that needs to be loaded. When a spec is successfully loaded
0000000000000000000000000000000000000000;;		// it will be removed from this list and added to apiServiceSpecs.
0000000000000000000000000000000000000000;;		// Map values are retry counts. After a preset retries, it will stop
0000000000000000000000000000000000000000;;		// trying.
0000000000000000000000000000000000000000;;		toLoadAPISpec map[string]int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// protecting toLoadAPISpec and apiServiceSpecs
0000000000000000000000000000000000000000;;		specMutex sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rootSpec is the OpenAPI spec of the Aggregator server.
0000000000000000000000000000000000000000;;		rootSpec *spec.Swagger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delegationSpec is the delegation API Server's spec (most of API groups are in this spec).
0000000000000000000000000000000000000000;;		delegationSpec *spec.Swagger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lister is used to add group handling for /apis/<group> aggregator lookups based on
0000000000000000000000000000000000000000;;		// controller state
0000000000000000000000000000000000000000;;		lister listers.APIServiceLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// provided for easier embedding
0000000000000000000000000000000000000000;;		APIRegistrationInformers informers.SharedInformerFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Information needed to determine routing for the aggregator
0000000000000000000000000000000000000000;;		serviceResolver ServiceResolver
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type completedConfig struct {
0000000000000000000000000000000000000000;;		*Config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Complete fills in any fields not set that are required to have valid data. It's mutating the receiver.
0000000000000000000000000000000000000000;;	func (c *Config) Complete() completedConfig {
0000000000000000000000000000000000000000;;		// the kube aggregator wires its own discovery mechanism
0000000000000000000000000000000000000000;;		// TODO eventually collapse this by extracting all of the discovery out
0000000000000000000000000000000000000000;;		c.GenericConfig.EnableDiscovery = false
0000000000000000000000000000000000000000;;		c.GenericConfig.Complete()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version := version.Get()
0000000000000000000000000000000000000000;;		c.GenericConfig.Version = &version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return completedConfig{c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SkipComplete provides a way to construct a server instance without config completion.
0000000000000000000000000000000000000000;;	func (c *Config) SkipComplete() completedConfig {
0000000000000000000000000000000000000000;;		return completedConfig{c}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new instance of APIAggregator from the given config.
0000000000000000000000000000000000000000;;	func (c completedConfig) NewWithDelegate(delegationTarget genericapiserver.DelegationTarget) (*APIAggregator, error) {
0000000000000000000000000000000000000000;;		genericServer, err := c.Config.GenericConfig.SkipComplete().New("kube-aggregator", delegationTarget) // completion is done in Complete, no need for a second time
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiregistrationClient, err := internalclientset.NewForConfig(c.Config.GenericConfig.LoopbackClientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informerFactory := informers.NewSharedInformerFactory(
0000000000000000000000000000000000000000;;			apiregistrationClient,
0000000000000000000000000000000000000000;;			5*time.Minute, // this is effectively used as a refresh interval right now.  Might want to do something nicer later on.
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &APIAggregator{
0000000000000000000000000000000000000000;;			GenericAPIServer: genericServer,
0000000000000000000000000000000000000000;;			delegateHandler:  delegationTarget.UnprotectedHandler(),
0000000000000000000000000000000000000000;;			delegationSpec:   delegationTarget.OpenAPISpec(),
0000000000000000000000000000000000000000;;			contextMapper:    c.GenericConfig.RequestContextMapper,
0000000000000000000000000000000000000000;;			proxyClientCert:  c.ProxyClientCert,
0000000000000000000000000000000000000000;;			proxyClientKey:   c.ProxyClientKey,
0000000000000000000000000000000000000000;;			proxyTransport:   c.ProxyTransport,
0000000000000000000000000000000000000000;;			proxyHandlers:    map[string]*proxyHandler{},
0000000000000000000000000000000000000000;;			apiServiceSpecs:  map[string]*spec.Swagger{},
0000000000000000000000000000000000000000;;			toLoadAPISpec:    map[string]int{},
0000000000000000000000000000000000000000;;			handledGroups:    sets.String{},
0000000000000000000000000000000000000000;;			lister:           informerFactory.Apiregistration().InternalVersion().APIServices().Lister(),
0000000000000000000000000000000000000000;;			APIRegistrationInformers: informerFactory,
0000000000000000000000000000000000000000;;			serviceResolver:          c.ServiceResolver,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(apiregistration.GroupName, registry, Scheme, metav1.ParameterCodec, Codecs)
0000000000000000000000000000000000000000;;		apiGroupInfo.GroupMeta.GroupVersion = v1beta1.SchemeGroupVersion
0000000000000000000000000000000000000000;;		v1beta1storage := map[string]rest.Storage{}
0000000000000000000000000000000000000000;;		apiServiceREST := apiservicestorage.NewREST(Scheme, c.GenericConfig.RESTOptionsGetter)
0000000000000000000000000000000000000000;;		v1beta1storage["apiservices"] = apiServiceREST
0000000000000000000000000000000000000000;;		v1beta1storage["apiservices/status"] = apiservicestorage.NewStatusREST(Scheme, apiServiceREST)
0000000000000000000000000000000000000000;;		apiGroupInfo.VersionedResourcesStorageMap["v1beta1"] = v1beta1storage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.GenericAPIServer.InstallAPIGroup(&apiGroupInfo); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apisHandler := &apisHandler{
0000000000000000000000000000000000000000;;			codecs: Codecs,
0000000000000000000000000000000000000000;;			lister: s.lister,
0000000000000000000000000000000000000000;;			mapper: s.contextMapper,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.GenericAPIServer.Handler.NonGoRestfulMux.Handle("/apis", apisHandler)
0000000000000000000000000000000000000000;;		s.GenericAPIServer.Handler.NonGoRestfulMux.UnlistedHandle("/apis/", apisHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiserviceRegistrationController := NewAPIServiceRegistrationController(informerFactory.Apiregistration().InternalVersion().APIServices(), c.CoreKubeInformers.Core().V1().Services(), s)
0000000000000000000000000000000000000000;;		availableController := statuscontrollers.NewAvailableConditionController(
0000000000000000000000000000000000000000;;			informerFactory.Apiregistration().InternalVersion().APIServices(),
0000000000000000000000000000000000000000;;			c.CoreKubeInformers.Core().V1().Services(),
0000000000000000000000000000000000000000;;			c.CoreKubeInformers.Core().V1().Endpoints(),
0000000000000000000000000000000000000000;;			apiregistrationClient.Apiregistration(),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.GenericAPIServer.AddPostStartHook("start-kube-aggregator-informers", func(context genericapiserver.PostStartHookContext) error {
0000000000000000000000000000000000000000;;			informerFactory.Start(context.StopCh)
0000000000000000000000000000000000000000;;			c.CoreKubeInformers.Start(context.StopCh)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		s.GenericAPIServer.AddPostStartHook("apiservice-registration-controller", func(context genericapiserver.PostStartHookContext) error {
0000000000000000000000000000000000000000;;			go apiserviceRegistrationController.Run(context.StopCh)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		s.GenericAPIServer.AddPostStartHook("apiservice-status-available-controller", func(context genericapiserver.PostStartHookContext) error {
0000000000000000000000000000000000000000;;			go availableController.Run(context.StopCh)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.GenericAPIServer.PrepareOpenAPIService()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.GenericAPIServer.OpenAPIService != nil {
0000000000000000000000000000000000000000;;			s.rootSpec = s.GenericAPIServer.OpenAPIService.GetSpec()
0000000000000000000000000000000000000000;;			if err := s.updateOpenAPISpec(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.GenericAPIServer.OpenAPIService.AddUpdateHook(func(r *http.Request) {
0000000000000000000000000000000000000000;;				if s.tryLoadingOpenAPISpecs(r) {
0000000000000000000000000000000000000000;;					s.updateOpenAPISpec()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddAPIService adds an API service.  It is not thread-safe, so only call it on one thread at a time please.
0000000000000000000000000000000000000000;;	// It's a slow moving API, so its ok to run the controller on a single thread
0000000000000000000000000000000000000000;;	func (s *APIAggregator) AddAPIService(apiService *apiregistration.APIService) {
0000000000000000000000000000000000000000;;		// if the proxyHandler already exists, it needs to be updated. The aggregation bits do not
0000000000000000000000000000000000000000;;		// since they are wired against listers because they require multiple resources to respond
0000000000000000000000000000000000000000;;		if proxyHandler, exists := s.proxyHandlers[apiService.Name]; exists {
0000000000000000000000000000000000000000;;			proxyHandler.updateAPIService(apiService)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyPath := "/apis/" + apiService.Spec.Group + "/" + apiService.Spec.Version
0000000000000000000000000000000000000000;;		// v1. is a special case for the legacy API.  It proxies to a wider set of endpoints.
0000000000000000000000000000000000000000;;		if apiService.Name == legacyAPIServiceName {
0000000000000000000000000000000000000000;;			proxyPath = "/api"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// register the proxy handler
0000000000000000000000000000000000000000;;		proxyHandler := &proxyHandler{
0000000000000000000000000000000000000000;;			contextMapper:   s.contextMapper,
0000000000000000000000000000000000000000;;			localDelegate:   s.delegateHandler,
0000000000000000000000000000000000000000;;			proxyClientCert: s.proxyClientCert,
0000000000000000000000000000000000000000;;			proxyClientKey:  s.proxyClientKey,
0000000000000000000000000000000000000000;;			proxyTransport:  s.proxyTransport,
0000000000000000000000000000000000000000;;			serviceResolver: s.serviceResolver,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxyHandler.updateAPIService(apiService)
0000000000000000000000000000000000000000;;		s.proxyHandlers[apiService.Name] = proxyHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.deferLoadAPISpec(apiService.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(proxyPath, proxyHandler)
0000000000000000000000000000000000000000;;		s.GenericAPIServer.Handler.NonGoRestfulMux.UnlistedHandlePrefix(proxyPath+"/", proxyHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we're dealing with the legacy group, we're done here
0000000000000000000000000000000000000000;;		if apiService.Name == legacyAPIServiceName {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we've already registered the path with the handler, we don't want to do it again.
0000000000000000000000000000000000000000;;		if s.handledGroups.Has(apiService.Spec.Group) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// it's time to register the group aggregation endpoint
0000000000000000000000000000000000000000;;		groupPath := "/apis/" + apiService.Spec.Group
0000000000000000000000000000000000000000;;		groupDiscoveryHandler := &apiGroupHandler{
0000000000000000000000000000000000000000;;			codecs:        Codecs,
0000000000000000000000000000000000000000;;			groupName:     apiService.Spec.Group,
0000000000000000000000000000000000000000;;			lister:        s.lister,
0000000000000000000000000000000000000000;;			delegate:      s.delegateHandler,
0000000000000000000000000000000000000000;;			contextMapper: s.contextMapper,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// aggregation is protected
0000000000000000000000000000000000000000;;		s.GenericAPIServer.Handler.NonGoRestfulMux.Handle(groupPath, groupDiscoveryHandler)
0000000000000000000000000000000000000000;;		s.GenericAPIServer.Handler.NonGoRestfulMux.UnlistedHandle(groupPath+"/", groupDiscoveryHandler)
0000000000000000000000000000000000000000;;		s.handledGroups.Insert(apiService.Spec.Group)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *APIAggregator) deferLoadAPISpec(name string) {
0000000000000000000000000000000000000000;;		s.specMutex.Lock()
0000000000000000000000000000000000000000;;		defer s.specMutex.Unlock()
0000000000000000000000000000000000000000;;		s.toLoadAPISpec[name] = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *APIAggregator) deleteApiSpec(name string) {
0000000000000000000000000000000000000000;;		s.specMutex.Lock()
0000000000000000000000000000000000000000;;		defer s.specMutex.Unlock()
0000000000000000000000000000000000000000;;		delete(s.apiServiceSpecs, name)
0000000000000000000000000000000000000000;;		delete(s.toLoadAPISpec, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveAPIService removes the APIService from being handled.  It is not thread-safe, so only call it on one thread at a time please.
0000000000000000000000000000000000000000;;	// It's a slow moving API, so its ok to run the controller on a single thread.
0000000000000000000000000000000000000000;;	func (s *APIAggregator) RemoveAPIService(apiServiceName string) {
0000000000000000000000000000000000000000;;		version := apiregistration.APIServiceNameToGroupVersion(apiServiceName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyPath := "/apis/" + version.Group + "/" + version.Version
0000000000000000000000000000000000000000;;		// v1. is a special case for the legacy API.  It proxies to a wider set of endpoints.
0000000000000000000000000000000000000000;;		if apiServiceName == legacyAPIServiceName {
0000000000000000000000000000000000000000;;			proxyPath = "/api"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.GenericAPIServer.Handler.NonGoRestfulMux.Unregister(proxyPath)
0000000000000000000000000000000000000000;;		s.GenericAPIServer.Handler.NonGoRestfulMux.Unregister(proxyPath + "/")
0000000000000000000000000000000000000000;;		delete(s.proxyHandlers, apiServiceName)
0000000000000000000000000000000000000000;;		s.deleteApiSpec(apiServiceName)
0000000000000000000000000000000000000000;;		s.updateOpenAPISpec()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO unregister group level discovery when there are no more versions for the group
0000000000000000000000000000000000000000;;		// We don't need this right away because the handler properly delegates when no versions are present
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ *APIAggregator) loadOpenAPISpec(p *proxyHandler, r *http.Request) (*spec.Swagger, error) {
0000000000000000000000000000000000000000;;		value := p.handlingInfo.Load()
0000000000000000000000000000000000000000;;		if value == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handlingInfo := value.(proxyHandlingInfo)
0000000000000000000000000000000000000000;;		if handlingInfo.local {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loc, err := p.serviceResolver.ResolveEndpoint(handlingInfo.serviceNamespace, handlingInfo.serviceName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("missing route")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		host := loc.Host
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var w io.Reader
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", "/swagger.json", w)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.URL.Scheme = "https"
0000000000000000000000000000000000000000;;		req.URL.Host = host
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req = req.WithContext(context.Background())
0000000000000000000000000000000000000000;;		// Get user from the original request
0000000000000000000000000000000000000000;;		ctx, ok := p.contextMapper.Get(r)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("missing context")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		user, ok := genericapirequest.UserFrom(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("missing user")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxyRoundTripper := transport.NewAuthProxyRoundTripper(user.GetName(), user.GetGroups(), user.GetExtra(), handlingInfo.proxyRoundTripper)
0000000000000000000000000000000000000000;;		res, err := proxyRoundTripper.RoundTrip(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return nil, errors.New(res.Status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		buf.ReadFrom(res.Body)
0000000000000000000000000000000000000000;;		bytes := buf.Bytes()
0000000000000000000000000000000000000000;;		var s spec.Swagger
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(bytes, &s); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true if any Spec is loaded
0000000000000000000000000000000000000000;;	func (s *APIAggregator) tryLoadingOpenAPISpecs(r *http.Request) bool {
0000000000000000000000000000000000000000;;		s.specMutex.Lock()
0000000000000000000000000000000000000000;;		defer s.specMutex.Unlock()
0000000000000000000000000000000000000000;;		if len(s.toLoadAPISpec) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		loaded := false
0000000000000000000000000000000000000000;;		newList := map[string]int{}
0000000000000000000000000000000000000000;;		for name, retries := range s.toLoadAPISpec {
0000000000000000000000000000000000000000;;			if retries >= LOAD_OPENAPI_SPEC_MAX_RETRIES {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			proxyHandler := s.proxyHandlers[name]
0000000000000000000000000000000000000000;;			if spec, err := s.loadOpenAPISpec(proxyHandler, r); err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Failed to Load OpenAPI spec (try %d of %d) for %s, err=%s", retries+1, LOAD_OPENAPI_SPEC_MAX_RETRIES, name, err)
0000000000000000000000000000000000000000;;				newList[name] = retries + 1
0000000000000000000000000000000000000000;;			} else if spec != nil {
0000000000000000000000000000000000000000;;				s.apiServiceSpecs[name] = spec
0000000000000000000000000000000000000000;;				loaded = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.toLoadAPISpec = newList
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return loaded
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *APIAggregator) updateOpenAPISpec() error {
0000000000000000000000000000000000000000;;		s.specMutex.Lock()
0000000000000000000000000000000000000000;;		defer s.specMutex.Unlock()
0000000000000000000000000000000000000000;;		if s.GenericAPIServer.OpenAPIService == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sp, err := openapi.CloneSpec(s.rootSpec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		openapi.FilterSpecByPaths(sp, []string{"/apis/apiregistration.k8s.io/"})
0000000000000000000000000000000000000000;;		if _, found := sp.Paths.Paths["/version/"]; found {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Cleanup didn't work")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := openapi.MergeSpecs(sp, s.delegationSpec); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range s.apiServiceSpecs {
0000000000000000000000000000000000000000;;			version := apiregistration.APIServiceNameToGroupVersion(k)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			proxyPath := "/apis/" + version.Group + "/"
0000000000000000000000000000000000000000;;			// v1. is a special case for the legacy API.  It proxies to a wider set of endpoints.
0000000000000000000000000000000000000000;;			if k == legacyAPIServiceName {
0000000000000000000000000000000000000000;;				proxyPath = "/api/"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			spc, err := openapi.CloneSpec(v)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			openapi.FilterSpecByPaths(spc, []string{proxyPath})
0000000000000000000000000000000000000000;;			if err := openapi.MergeSpecs(sp, spc); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.GenericAPIServer.OpenAPIService.UpdateSpec(sp)
0000000000000000000000000000000000000000;;	}
