0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
434b5f0a908cabe13cf692cbf6af57970c14f900;cmd/kubernetes-discovery/pkg/apiserver/handler_apis.go[cmd/kubernetes-discovery/pkg/apiserver/handler_apis.go][staging/src/k8s.io/kube-aggregator/pkg/apiserver/handler_apis.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/handlers/responsewriters"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/endpoints/request"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiregistrationapi "k8s.io/kube-aggregator/pkg/apis/apiregistration"
0000000000000000000000000000000000000000;;		apiregistrationv1beta1api "k8s.io/kube-aggregator/pkg/apis/apiregistration/v1beta1"
0000000000000000000000000000000000000000;;		listers "k8s.io/kube-aggregator/pkg/client/listers/apiregistration/internalversion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// apisHandler serves the `/apis` endpoint.
0000000000000000000000000000000000000000;;	// This is registered as a filter so that it never collides with any explictly registered endpoints
0000000000000000000000000000000000000000;;	type apisHandler struct {
0000000000000000000000000000000000000000;;		codecs serializer.CodecFactory
0000000000000000000000000000000000000000;;		lister listers.APIServiceLister
0000000000000000000000000000000000000000;;		mapper request.RequestContextMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var discoveryGroup = metav1.APIGroup{
0000000000000000000000000000000000000000;;		Name: apiregistrationapi.GroupName,
0000000000000000000000000000000000000000;;		Versions: []metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				GroupVersion: apiregistrationv1beta1api.SchemeGroupVersion.String(),
0000000000000000000000000000000000000000;;				Version:      apiregistrationv1beta1api.SchemeGroupVersion.Version,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		PreferredVersion: metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;			GroupVersion: apiregistrationv1beta1api.SchemeGroupVersion.String(),
0000000000000000000000000000000000000000;;			Version:      apiregistrationv1beta1api.SchemeGroupVersion.Version,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *apisHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		ctx, ok := r.mapper.Get(req)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			responsewriters.InternalError(w, req, errors.New("no context found for request"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		discoveryGroupList := &metav1.APIGroupList{
0000000000000000000000000000000000000000;;			// always add OUR api group to the list first.  Since we'll never have a registered APIService for it
0000000000000000000000000000000000000000;;			// and since this is the crux of the API, having this first will give our names priority.  It's good to be king.
0000000000000000000000000000000000000000;;			Groups: []metav1.APIGroup{discoveryGroup},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiServices, err := r.lister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiServicesByGroup := apiregistrationapi.SortedByGroupAndVersion(apiServices)
0000000000000000000000000000000000000000;;		for _, apiGroupServers := range apiServicesByGroup {
0000000000000000000000000000000000000000;;			// skip the legacy group
0000000000000000000000000000000000000000;;			if len(apiGroupServers[0].Spec.Group) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			discoveryGroup := convertToDiscoveryAPIGroup(apiGroupServers)
0000000000000000000000000000000000000000;;			if discoveryGroup != nil {
0000000000000000000000000000000000000000;;				discoveryGroupList.Groups = append(discoveryGroupList.Groups, *discoveryGroup)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		responsewriters.WriteObjectNegotiated(ctx, r.codecs, schema.GroupVersion{}, w, req, http.StatusOK, discoveryGroupList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertToDiscoveryAPIGroup takes apiservices in a single group and returns a discovery compatible object.
0000000000000000000000000000000000000000;;	// if none of the services are available, it will return nil.
0000000000000000000000000000000000000000;;	func convertToDiscoveryAPIGroup(apiServices []*apiregistrationapi.APIService) *metav1.APIGroup {
0000000000000000000000000000000000000000;;		apiServicesByGroup := apiregistrationapi.SortedByGroupAndVersion(apiServices)[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var discoveryGroup *metav1.APIGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, apiService := range apiServicesByGroup {
0000000000000000000000000000000000000000;;			if !apiregistrationapi.IsAPIServiceConditionTrue(apiService, apiregistrationapi.Available) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// the first APIService which is valid becomes the default
0000000000000000000000000000000000000000;;			if discoveryGroup == nil {
0000000000000000000000000000000000000000;;				discoveryGroup = &metav1.APIGroup{
0000000000000000000000000000000000000000;;					Name: apiService.Spec.Group,
0000000000000000000000000000000000000000;;					PreferredVersion: metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;						GroupVersion: apiService.Spec.Group + "/" + apiService.Spec.Version,
0000000000000000000000000000000000000000;;						Version:      apiService.Spec.Version,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			discoveryGroup.Versions = append(discoveryGroup.Versions,
0000000000000000000000000000000000000000;;				metav1.GroupVersionForDiscovery{
0000000000000000000000000000000000000000;;					GroupVersion: apiService.Spec.Group + "/" + apiService.Spec.Version,
0000000000000000000000000000000000000000;;					Version:      apiService.Spec.Version,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return discoveryGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// apiGroupHandler serves the `/apis/<group>` endpoint.
0000000000000000000000000000000000000000;;	type apiGroupHandler struct {
0000000000000000000000000000000000000000;;		codecs        serializer.CodecFactory
0000000000000000000000000000000000000000;;		groupName     string
0000000000000000000000000000000000000000;;		contextMapper request.RequestContextMapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lister listers.APIServiceLister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delegate http.Handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *apiGroupHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		ctx, ok := r.contextMapper.Get(req)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			responsewriters.InternalError(w, req, errors.New("no context found for request"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiServices, err := r.lister.List(labels.Everything())
0000000000000000000000000000000000000000;;		if statusErr, ok := err.(*apierrors.StatusError); ok && err != nil {
0000000000000000000000000000000000000000;;			responsewriters.WriteRawJSON(int(statusErr.Status().Code), statusErr.Status(), w)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiServicesForGroup := []*apiregistrationapi.APIService{}
0000000000000000000000000000000000000000;;		for _, apiService := range apiServices {
0000000000000000000000000000000000000000;;			if apiService.Spec.Group == r.groupName {
0000000000000000000000000000000000000000;;				apiServicesForGroup = append(apiServicesForGroup, apiService)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(apiServicesForGroup) == 0 {
0000000000000000000000000000000000000000;;			r.delegate.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		discoveryGroup := convertToDiscoveryAPIGroup(apiServicesForGroup)
0000000000000000000000000000000000000000;;		if discoveryGroup == nil {
0000000000000000000000000000000000000000;;			http.Error(w, "", http.StatusNotFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		responsewriters.WriteObjectNegotiated(ctx, r.codecs, schema.GroupVersion{}, w, req, http.StatusOK, discoveryGroup)
0000000000000000000000000000000000000000;;	}
