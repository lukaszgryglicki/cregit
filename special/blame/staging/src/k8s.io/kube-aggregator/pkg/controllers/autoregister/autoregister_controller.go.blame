0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
6cac9bddb63e610919f8023fcd779e03c94bf204;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package autoregister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/apis/apiregistration"
0000000000000000000000000000000000000000;;		apiregistrationclient "k8s.io/kube-aggregator/pkg/client/clientset_generated/internalclientset/typed/apiregistration/internalversion"
0000000000000000000000000000000000000000;;		informers "k8s.io/kube-aggregator/pkg/client/informers/internalversion/apiregistration/internalversion"
0000000000000000000000000000000000000000;;		listers "k8s.io/kube-aggregator/pkg/client/listers/apiregistration/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/controllers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		AutoRegisterManagedLabel = "kube-aggregator.kubernetes.io/automanaged"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		cloner = conversion.NewCloner()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AutoAPIServiceRegistration is an interface which callers can re-declare locally and properly cast to for
0000000000000000000000000000000000000000;;	// adding and removing APIServices
0000000000000000000000000000000000000000;;	type AutoAPIServiceRegistration interface {
0000000000000000000000000000000000000000;;		// AddAPIServiceToSync adds an API service to auto-register.
0000000000000000000000000000000000000000;;		AddAPIServiceToSync(in *apiregistration.APIService)
0000000000000000000000000000000000000000;;		// RemoveAPIServiceToSync removes an API service to auto-register.
0000000000000000000000000000000000000000;;		RemoveAPIServiceToSync(name string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// autoRegisterController is used to keep a particular set of APIServices present in the API.  It is useful
0000000000000000000000000000000000000000;;	// for cases where you want to auto-register APIs like TPRs or groups from the core kube-apiserver
0000000000000000000000000000000000000000;;	type autoRegisterController struct {
0000000000000000000000000000000000000000;;		apiServiceLister listers.APIServiceLister
0000000000000000000000000000000000000000;;		apiServiceSynced cache.InformerSynced
0000000000000000000000000000000000000000;;		apiServiceClient apiregistrationclient.APIServicesGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiServicesToSyncLock sync.RWMutex
0000000000000000000000000000000000000000;;		apiServicesToSync     map[string]*apiregistration.APIService
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		syncHandler func(apiServiceName string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// queue is where incoming work is placed to de-dup and to allow "easy" rate limited requeues on errors
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewAutoRegisterController(apiServiceInformer informers.APIServiceInformer, apiServiceClient apiregistrationclient.APIServicesGetter) *autoRegisterController {
0000000000000000000000000000000000000000;;		c := &autoRegisterController{
0000000000000000000000000000000000000000;;			apiServiceLister:  apiServiceInformer.Lister(),
0000000000000000000000000000000000000000;;			apiServiceSynced:  apiServiceInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			apiServiceClient:  apiServiceClient,
0000000000000000000000000000000000000000;;			apiServicesToSync: map[string]*apiregistration.APIService{},
0000000000000000000000000000000000000000;;			queue:             workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "autoregister"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.syncHandler = c.checkAPIService
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiServiceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				cast := obj.(*apiregistration.APIService)
0000000000000000000000000000000000000000;;				c.queue.Add(cast.Name)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			UpdateFunc: func(_, obj interface{}) {
0000000000000000000000000000000000000000;;				cast := obj.(*apiregistration.APIService)
0000000000000000000000000000000000000000;;				c.queue.Add(cast.Name)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			DeleteFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				cast, ok := obj.(*apiregistration.APIService)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Couldn't get object from tombstone %#v", obj)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					cast, ok = tombstone.Obj.(*apiregistration.APIService)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						glog.V(2).Infof("Tombstone contained unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c.queue.Add(cast.Name)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *autoRegisterController) Run(threadiness int, stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		// don't let panics crash the process
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		// make sure the work queue is shutdown which will trigger workers to end
0000000000000000000000000000000000000000;;		defer c.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting autoregister controller")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down autoregister controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for your secondary caches to fill before starting your work
0000000000000000000000000000000000000000;;		if !controllers.WaitForCacheSync("autoregister", stopCh, c.apiServiceSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start up your worker threads based on threadiness.  Some controllers have multiple kinds of workers
0000000000000000000000000000000000000000;;		for i := 0; i < threadiness; i++ {
0000000000000000000000000000000000000000;;			// runWorker will loop until "something bad" happens.  The .Until will then rekick the worker
0000000000000000000000000000000000000000;;			// after one second
0000000000000000000000000000000000000000;;			go wait.Until(c.runWorker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait until we're told to stop
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *autoRegisterController) runWorker() {
0000000000000000000000000000000000000000;;		// hot loop until we're told to stop.  processNextWorkItem will automatically wait until there's work
0000000000000000000000000000000000000000;;		// available, so we don't worry about secondary waits
0000000000000000000000000000000000000000;;		for c.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processNextWorkItem deals with one key off the queue.  It returns false when it's time to quit.
0000000000000000000000000000000000000000;;	func (c *autoRegisterController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		// pull the next work item from queue.  It should be a key we use to lookup something in a cache
0000000000000000000000000000000000000000;;		key, quit := c.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// you always have to indicate to the queue that you've completed a piece of work
0000000000000000000000000000000000000000;;		defer c.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do your work on the key.  This method will contains your "do stuff" logic
0000000000000000000000000000000000000000;;		err := c.syncHandler(key.(string))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// if you had no error, tell the queue to stop tracking history for your key.  This will
0000000000000000000000000000000000000000;;			// reset things like failure counts for per-item rate limiting
0000000000000000000000000000000000000000;;			c.queue.Forget(key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// there was a failure so be sure to report it.  This method allows for pluggable error handling
0000000000000000000000000000000000000000;;		// which can be used for things like cluster-monitoring
0000000000000000000000000000000000000000;;		utilruntime.HandleError(fmt.Errorf("%v failed with : %v", key, err))
0000000000000000000000000000000000000000;;		// since we failed, we should requeue the item to work on later.  This method will add a backoff
0000000000000000000000000000000000000000;;		// to avoid hotlooping on particular items (they're probably still not going to work right away)
0000000000000000000000000000000000000000;;		// and overall controller protection (everything I've done is broken, this controller needs to
0000000000000000000000000000000000000000;;		// calm down or it can starve other useful work) cases.
0000000000000000000000000000000000000000;;		c.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *autoRegisterController) checkAPIService(name string) error {
0000000000000000000000000000000000000000;;		desired := c.GetAPIServiceToSync(name)
0000000000000000000000000000000000000000;;		curr, err := c.apiServiceLister.Get(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// we had a real error, just return it
0000000000000000000000000000000000000000;;		case err != nil && !apierrors.IsNotFound(err):
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we don't have an entry and we don't want one
0000000000000000000000000000000000000000;;		case apierrors.IsNotFound(err) && desired == nil:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we don't have an entry and we do want one
0000000000000000000000000000000000000000;;		case apierrors.IsNotFound(err) && desired != nil:
0000000000000000000000000000000000000000;;			_, err := c.apiServiceClient.APIServices().Create(desired)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we aren't trying to manage this APIService.  If the user removes the label, he's taken over management himself
0000000000000000000000000000000000000000;;		case curr.Labels[AutoRegisterManagedLabel] != "true":
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we have a spurious APIService that we're managing, delete it
0000000000000000000000000000000000000000;;		case desired == nil:
0000000000000000000000000000000000000000;;			return c.apiServiceClient.APIServices().Delete(curr.Name, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the specs already match, nothing for us to do
0000000000000000000000000000000000000000;;		case reflect.DeepEqual(curr.Spec, desired.Spec):
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we have an entry and we have a desired, now we deconflict.  Only a few fields matter.
0000000000000000000000000000000000000000;;		apiService := &apiregistration.APIService{}
0000000000000000000000000000000000000000;;		if err := apiregistration.DeepCopy_apiregistration_APIService(curr, apiService, cloner); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiService.Spec = desired.Spec
0000000000000000000000000000000000000000;;		_, err = c.apiServiceClient.APIServices().Update(apiService)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *autoRegisterController) GetAPIServiceToSync(name string) *apiregistration.APIService {
0000000000000000000000000000000000000000;;		c.apiServicesToSyncLock.RLock()
0000000000000000000000000000000000000000;;		defer c.apiServicesToSyncLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.apiServicesToSync[name]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *autoRegisterController) AddAPIServiceToSync(in *apiregistration.APIService) {
0000000000000000000000000000000000000000;;		c.apiServicesToSyncLock.Lock()
0000000000000000000000000000000000000000;;		defer c.apiServicesToSyncLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiService := &apiregistration.APIService{}
0000000000000000000000000000000000000000;;		if err := apiregistration.DeepCopy_apiregistration_APIService(in, apiService, cloner); err != nil {
0000000000000000000000000000000000000000;;			// this shouldn't happen
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiService.Labels == nil {
0000000000000000000000000000000000000000;;			apiService.Labels = map[string]string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiService.Labels[AutoRegisterManagedLabel] = "true"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.apiServicesToSync[apiService.Name] = apiService
0000000000000000000000000000000000000000;;		c.queue.Add(apiService.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *autoRegisterController) RemoveAPIServiceToSync(name string) {
0000000000000000000000000000000000000000;;		c.apiServicesToSyncLock.Lock()
0000000000000000000000000000000000000000;;		defer c.apiServicesToSyncLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(c.apiServicesToSync, name)
0000000000000000000000000000000000000000;;		c.queue.Add(name)
0000000000000000000000000000000000000000;;	}
