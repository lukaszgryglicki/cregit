0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
546da0ebbeb4fa1639497213f92ce04e56c1ec92;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package apiserver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		apierrors "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		v1informers "k8s.io/client-go/informers/core/v1"
0000000000000000000000000000000000000000;;		v1listers "k8s.io/client-go/listers/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/apis/apiregistration"
0000000000000000000000000000000000000000;;		apiregistrationclient "k8s.io/kube-aggregator/pkg/client/clientset_generated/internalclientset/typed/apiregistration/internalversion"
0000000000000000000000000000000000000000;;		informers "k8s.io/kube-aggregator/pkg/client/informers/internalversion/apiregistration/internalversion"
0000000000000000000000000000000000000000;;		listers "k8s.io/kube-aggregator/pkg/client/listers/apiregistration/internalversion"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/controllers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cloner = conversion.NewCloner()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AvailableConditionController struct {
0000000000000000000000000000000000000000;;		apiServiceClient apiregistrationclient.APIServicesGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiServiceLister listers.APIServiceLister
0000000000000000000000000000000000000000;;		apiServiceSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// serviceLister is used to get the IP to create the transport for
0000000000000000000000000000000000000000;;		serviceLister  v1listers.ServiceLister
0000000000000000000000000000000000000000;;		servicesSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointsLister v1listers.EndpointsLister
0000000000000000000000000000000000000000;;		endpointsSynced cache.InformerSynced
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To allow injection for testing.
0000000000000000000000000000000000000000;;		syncFn func(key string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		queue workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewAvailableConditionController(
0000000000000000000000000000000000000000;;		apiServiceInformer informers.APIServiceInformer,
0000000000000000000000000000000000000000;;		serviceInformer v1informers.ServiceInformer,
0000000000000000000000000000000000000000;;		endpointsInformer v1informers.EndpointsInformer,
0000000000000000000000000000000000000000;;		apiServiceClient apiregistrationclient.APIServicesGetter,
0000000000000000000000000000000000000000;;	) *AvailableConditionController {
0000000000000000000000000000000000000000;;		c := &AvailableConditionController{
0000000000000000000000000000000000000000;;			apiServiceClient: apiServiceClient,
0000000000000000000000000000000000000000;;			apiServiceLister: apiServiceInformer.Lister(),
0000000000000000000000000000000000000000;;			apiServiceSynced: apiServiceInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			serviceLister:    serviceInformer.Lister(),
0000000000000000000000000000000000000000;;			servicesSynced:   serviceInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			endpointsLister:  endpointsInformer.Lister(),
0000000000000000000000000000000000000000;;			endpointsSynced:  endpointsInformer.Informer().HasSynced,
0000000000000000000000000000000000000000;;			queue:            workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), "AvailableConditionController"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiServiceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    c.addAPIService,
0000000000000000000000000000000000000000;;			UpdateFunc: c.updateAPIService,
0000000000000000000000000000000000000000;;			DeleteFunc: c.deleteAPIService,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serviceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    c.addService,
0000000000000000000000000000000000000000;;			UpdateFunc: c.updateService,
0000000000000000000000000000000000000000;;			DeleteFunc: c.deleteService,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpointsInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc:    c.addEndpoints,
0000000000000000000000000000000000000000;;			UpdateFunc: c.updateEndpoints,
0000000000000000000000000000000000000000;;			DeleteFunc: c.deleteEndpoints,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.syncFn = c.sync
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) sync(key string) error {
0000000000000000000000000000000000000000;;		inAPIService, err := c.apiServiceLister.Get(key)
0000000000000000000000000000000000000000;;		if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiService := &apiregistration.APIService{}
0000000000000000000000000000000000000000;;		if err := apiregistration.DeepCopy_apiregistration_APIService(inAPIService, apiService, cloner); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		availableCondition := apiregistration.APIServiceCondition{
0000000000000000000000000000000000000000;;			Type:               apiregistration.Available,
0000000000000000000000000000000000000000;;			Status:             apiregistration.ConditionTrue,
0000000000000000000000000000000000000000;;			LastTransitionTime: metav1.Now(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// local API services are always considered available
0000000000000000000000000000000000000000;;		if apiService.Spec.Service == nil {
0000000000000000000000000000000000000000;;			availableCondition.Status = apiregistration.ConditionTrue
0000000000000000000000000000000000000000;;			availableCondition.Reason = "Local"
0000000000000000000000000000000000000000;;			availableCondition.Message = "Local APIServices are always available"
0000000000000000000000000000000000000000;;			apiregistration.SetAPIServiceCondition(apiService, availableCondition)
0000000000000000000000000000000000000000;;			_, err := c.apiServiceClient.APIServices().UpdateStatus(apiService)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		service, err := c.serviceLister.Services(apiService.Spec.Service.Namespace).Get(apiService.Spec.Service.Name)
0000000000000000000000000000000000000000;;		if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;			availableCondition.Status = apiregistration.ConditionFalse
0000000000000000000000000000000000000000;;			availableCondition.Reason = "ServiceNotFound"
0000000000000000000000000000000000000000;;			availableCondition.Message = fmt.Sprintf("service/%s in %q is not present", apiService.Spec.Service.Name, apiService.Spec.Service.Namespace)
0000000000000000000000000000000000000000;;			apiregistration.SetAPIServiceCondition(apiService, availableCondition)
0000000000000000000000000000000000000000;;			_, err := c.apiServiceClient.APIServices().UpdateStatus(apiService)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			availableCondition.Status = apiregistration.ConditionUnknown
0000000000000000000000000000000000000000;;			availableCondition.Reason = "ServiceAccessError"
0000000000000000000000000000000000000000;;			availableCondition.Message = fmt.Sprintf("service/%s in %q cannot be checked due to: %v", apiService.Spec.Service.Name, apiService.Spec.Service.Namespace, err)
0000000000000000000000000000000000000000;;			apiregistration.SetAPIServiceCondition(apiService, availableCondition)
0000000000000000000000000000000000000000;;			_, err := c.apiServiceClient.APIServices().UpdateStatus(apiService)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if service.Spec.Type == v1.ServiceTypeClusterIP {
0000000000000000000000000000000000000000;;			endpoints, err := c.endpointsLister.Endpoints(apiService.Spec.Service.Namespace).Get(apiService.Spec.Service.Name)
0000000000000000000000000000000000000000;;			if apierrors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				availableCondition.Status = apiregistration.ConditionFalse
0000000000000000000000000000000000000000;;				availableCondition.Reason = "EndpointsNotFound"
0000000000000000000000000000000000000000;;				availableCondition.Message = fmt.Sprintf("cannot find endpoints for service/%s in %q", apiService.Spec.Service.Name, apiService.Spec.Service.Namespace)
0000000000000000000000000000000000000000;;				apiregistration.SetAPIServiceCondition(apiService, availableCondition)
0000000000000000000000000000000000000000;;				_, err := c.apiServiceClient.APIServices().UpdateStatus(apiService)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				availableCondition.Status = apiregistration.ConditionUnknown
0000000000000000000000000000000000000000;;				availableCondition.Reason = "EndpointsAccessError"
0000000000000000000000000000000000000000;;				availableCondition.Message = fmt.Sprintf("service/%s in %q cannot be checked due to: %v", apiService.Spec.Service.Name, apiService.Spec.Service.Namespace, err)
0000000000000000000000000000000000000000;;				apiregistration.SetAPIServiceCondition(apiService, availableCondition)
0000000000000000000000000000000000000000;;				_, err := c.apiServiceClient.APIServices().UpdateStatus(apiService)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hasActiveEndpoints := false
0000000000000000000000000000000000000000;;			for _, subset := range endpoints.Subsets {
0000000000000000000000000000000000000000;;				if len(subset.Addresses) > 0 {
0000000000000000000000000000000000000000;;					hasActiveEndpoints = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !hasActiveEndpoints {
0000000000000000000000000000000000000000;;				availableCondition.Status = apiregistration.ConditionFalse
0000000000000000000000000000000000000000;;				availableCondition.Reason = "MissingEndpoints"
0000000000000000000000000000000000000000;;				availableCondition.Message = fmt.Sprintf("endpoints for service/%s in %q have no addresses", apiService.Spec.Service.Name, apiService.Spec.Service.Namespace)
0000000000000000000000000000000000000000;;				apiregistration.SetAPIServiceCondition(apiService, availableCondition)
0000000000000000000000000000000000000000;;				_, err := c.apiServiceClient.APIServices().UpdateStatus(apiService)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO actually try to hit the discovery endpoint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		availableCondition.Reason = "Passed"
0000000000000000000000000000000000000000;;		availableCondition.Message = "all checks passed"
0000000000000000000000000000000000000000;;		apiregistration.SetAPIServiceCondition(apiService, availableCondition)
0000000000000000000000000000000000000000;;		_, err = c.apiServiceClient.APIServices().UpdateStatus(apiService)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		defer c.queue.ShutDown()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Starting AvailableConditionController")
0000000000000000000000000000000000000000;;		defer glog.Infof("Shutting down AvailableConditionController")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !controllers.WaitForCacheSync("AvailableConditionController", stopCh, c.apiServiceSynced, c.servicesSynced, c.endpointsSynced) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only start one worker thread since its a slow moving API and the aggregation server adding bits
0000000000000000000000000000000000000000;;		// aren't threadsafe
0000000000000000000000000000000000000000;;		go wait.Until(c.runWorker, time.Second, stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) runWorker() {
0000000000000000000000000000000000000000;;		for c.processNextWorkItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processNextWorkItem deals with one key off the queue.  It returns false when it's time to quit.
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) processNextWorkItem() bool {
0000000000000000000000000000000000000000;;		key, quit := c.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer c.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := c.syncFn(key.(string))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			c.queue.Forget(key)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilruntime.HandleError(fmt.Errorf("%v failed with: %v", key, err))
0000000000000000000000000000000000000000;;		c.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) enqueue(obj *apiregistration.APIService) {
0000000000000000000000000000000000000000;;		key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Couldn't get key for object %#v: %v", obj, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.queue.Add(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) addAPIService(obj interface{}) {
0000000000000000000000000000000000000000;;		castObj := obj.(*apiregistration.APIService)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Adding %s", castObj.Name)
0000000000000000000000000000000000000000;;		c.enqueue(castObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) updateAPIService(obj, _ interface{}) {
0000000000000000000000000000000000000000;;		castObj := obj.(*apiregistration.APIService)
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Updating %s", castObj.Name)
0000000000000000000000000000000000000000;;		c.enqueue(castObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) deleteAPIService(obj interface{}) {
0000000000000000000000000000000000000000;;		castObj, ok := obj.(*apiregistration.APIService)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't get object from tombstone %#v", obj)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			castObj, ok = tombstone.Obj.(*apiregistration.APIService)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("Tombstone contained object that is not expected %#v", obj)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Deleting %q", castObj.Name)
0000000000000000000000000000000000000000;;		c.enqueue(castObj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// there aren't very many apiservices, just check them all.
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) getAPIServicesFor(obj runtime.Object) []*apiregistration.APIService {
0000000000000000000000000000000000000000;;		metadata, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ret []*apiregistration.APIService
0000000000000000000000000000000000000000;;		apiServiceList, _ := c.apiServiceLister.List(labels.Everything())
0000000000000000000000000000000000000000;;		for _, apiService := range apiServiceList {
0000000000000000000000000000000000000000;;			if apiService.Spec.Service == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if apiService.Spec.Service.Namespace == metadata.GetNamespace() && apiService.Spec.Service.Name == metadata.GetName() {
0000000000000000000000000000000000000000;;				ret = append(ret, apiService)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO, think of a way to avoid checking on every service manipulation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) addService(obj interface{}) {
0000000000000000000000000000000000000000;;		for _, apiService := range c.getAPIServicesFor(obj.(*v1.Service)) {
0000000000000000000000000000000000000000;;			c.enqueue(apiService)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) updateService(obj, _ interface{}) {
0000000000000000000000000000000000000000;;		for _, apiService := range c.getAPIServicesFor(obj.(*v1.Service)) {
0000000000000000000000000000000000000000;;			c.enqueue(apiService)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) deleteService(obj interface{}) {
0000000000000000000000000000000000000000;;		castObj, ok := obj.(*v1.Service)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't get object from tombstone %#v", obj)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			castObj, ok = tombstone.Obj.(*v1.Service)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("Tombstone contained object that is not expected %#v", obj)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, apiService := range c.getAPIServicesFor(castObj) {
0000000000000000000000000000000000000000;;			c.enqueue(apiService)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) addEndpoints(obj interface{}) {
0000000000000000000000000000000000000000;;		for _, apiService := range c.getAPIServicesFor(obj.(*v1.Endpoints)) {
0000000000000000000000000000000000000000;;			c.enqueue(apiService)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) updateEndpoints(obj, _ interface{}) {
0000000000000000000000000000000000000000;;		for _, apiService := range c.getAPIServicesFor(obj.(*v1.Endpoints)) {
0000000000000000000000000000000000000000;;			c.enqueue(apiService)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *AvailableConditionController) deleteEndpoints(obj interface{}) {
0000000000000000000000000000000000000000;;		castObj, ok := obj.(*v1.Endpoints)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("Couldn't get object from tombstone %#v", obj)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			castObj, ok = tombstone.Obj.(*v1.Endpoints)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				glog.Errorf("Tombstone contained object that is not expected %#v", obj)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, apiService := range c.getAPIServicesFor(castObj) {
0000000000000000000000000000000000000000;;			c.enqueue(apiService)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
