0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
d99a3ba5a0f25f9cda8ae939633d54a23954f88a;cmd/kubernetes-discovery/pkg/cmd/server/start.go[cmd/kubernetes-discovery/pkg/cmd/server/start.go][staging/src/k8s.io/kube-aggregator/pkg/cmd/server/start.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/spf13/cobra"
0000000000000000000000000000000000000000;;		"github.com/spf13/pflag"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		genericapiserver "k8s.io/apiserver/pkg/server"
0000000000000000000000000000000000000000;;		"k8s.io/apiserver/pkg/server/filters"
0000000000000000000000000000000000000000;;		genericoptions "k8s.io/apiserver/pkg/server/options"
0000000000000000000000000000000000000000;;		kubeinformers "k8s.io/client-go/informers"
0000000000000000000000000000000000000000;;		kubeclientset "k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/apis/apiregistration/v1beta1"
0000000000000000000000000000000000000000;;		"k8s.io/kube-aggregator/pkg/apiserver"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const defaultEtcdPathPrefix = "/registry/kube-aggregator.kubernetes.io/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AggregatorOptions struct {
0000000000000000000000000000000000000000;;		RecommendedOptions *genericoptions.RecommendedOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ProxyClientCert/Key are the client cert used to identify this proxy. Backing APIServices use
0000000000000000000000000000000000000000;;		// this to confirm the proxy's identity
0000000000000000000000000000000000000000;;		ProxyClientCertFile string
0000000000000000000000000000000000000000;;		ProxyClientKeyFile  string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CoreAPIKubeconfig is a filename for a kubeconfig file to contact the core API server wtih
0000000000000000000000000000000000000000;;		// If it is not set, the in cluster config is used
0000000000000000000000000000000000000000;;		CoreAPIKubeconfig string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		StdOut io.Writer
0000000000000000000000000000000000000000;;		StdErr io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCommandStartAggregator provides a CLI handler for 'start master' command
0000000000000000000000000000000000000000;;	func NewCommandStartAggregator(out, err io.Writer, stopCh <-chan struct{}) *cobra.Command {
0000000000000000000000000000000000000000;;		o := NewDefaultOptions(out, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmd := &cobra.Command{
0000000000000000000000000000000000000000;;			Short: "Launch a API aggregator and proxy server",
0000000000000000000000000000000000000000;;			Long:  "Launch a API aggregator and proxy server",
0000000000000000000000000000000000000000;;			RunE: func(c *cobra.Command, args []string) error {
0000000000000000000000000000000000000000;;				if err := o.Complete(); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := o.Validate(args); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := o.RunAggregator(stopCh); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.AddFlags(cmd.Flags())
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFlags is necessary because hyperkube doesn't work using cobra, so we have to have different registration and execution paths
0000000000000000000000000000000000000000;;	func (o *AggregatorOptions) AddFlags(fs *pflag.FlagSet) {
0000000000000000000000000000000000000000;;		o.RecommendedOptions.AddFlags(fs)
0000000000000000000000000000000000000000;;		fs.StringVar(&o.ProxyClientCertFile, "proxy-client-cert-file", o.ProxyClientCertFile, "client certificate used identify the proxy to the API server")
0000000000000000000000000000000000000000;;		fs.StringVar(&o.ProxyClientKeyFile, "proxy-client-key-file", o.ProxyClientKeyFile, "client certificate key used identify the proxy to the API server")
0000000000000000000000000000000000000000;;		fs.StringVar(&o.CoreAPIKubeconfig, "core-kubeconfig", o.CoreAPIKubeconfig, ""+
0000000000000000000000000000000000000000;;			"kubeconfig file pointing at the 'core' kubernetes server with enough rights to get,list,watch "+
0000000000000000000000000000000000000000;;			" services,endpoints.  If not set, the in-cluster config is used")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultOptions builds a "normal" set of options.  You wouldn't normally expose this, but hyperkube isn't cobra compatible
0000000000000000000000000000000000000000;;	func NewDefaultOptions(out, err io.Writer) *AggregatorOptions {
0000000000000000000000000000000000000000;;		o := &AggregatorOptions{
0000000000000000000000000000000000000000;;			RecommendedOptions: genericoptions.NewRecommendedOptions(defaultEtcdPathPrefix, apiserver.Scheme, apiserver.Codecs.LegacyCodec(v1beta1.SchemeGroupVersion)),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			StdOut: out,
0000000000000000000000000000000000000000;;			StdErr: err,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o AggregatorOptions) Validate(args []string) error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *AggregatorOptions) Complete() error {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o AggregatorOptions) RunAggregator(stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		// TODO have a "real" external address
0000000000000000000000000000000000000000;;		if err := o.RecommendedOptions.SecureServing.MaybeDefaultWithSelfSignedCerts("localhost", nil, nil); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error creating self-signed certificates: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serverConfig := genericapiserver.NewConfig(apiserver.Codecs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := o.RecommendedOptions.ApplyTo(serverConfig); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		serverConfig.LongRunningFunc = filters.BasicLongRunningRequestCheck(
0000000000000000000000000000000000000000;;			sets.NewString("watch", "proxy"),
0000000000000000000000000000000000000000;;			sets.NewString("attach", "exec", "proxy", "log", "portforward"),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var kubeconfig *rest.Config
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if len(o.CoreAPIKubeconfig) > 0 {
0000000000000000000000000000000000000000;;			loadingRules := &clientcmd.ClientConfigLoadingRules{ExplicitPath: o.CoreAPIKubeconfig}
0000000000000000000000000000000000000000;;			loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &clientcmd.ConfigOverrides{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubeconfig, err = loader.ClientConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			kubeconfig, err = rest.InClusterConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		coreAPIServerClient, err := kubeclientset.NewForConfig(kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kubeInformers := kubeinformers.NewSharedInformerFactory(coreAPIServerClient, 5*time.Minute)
0000000000000000000000000000000000000000;;		serviceResolver := apiserver.NewClusterIPServiceResolver(kubeInformers.Core().V1().Services().Lister())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := apiserver.Config{
0000000000000000000000000000000000000000;;			GenericConfig:     serverConfig,
0000000000000000000000000000000000000000;;			CoreKubeInformers: kubeInformers,
0000000000000000000000000000000000000000;;			ServiceResolver:   serviceResolver,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.ProxyClientCert, err = ioutil.ReadFile(o.ProxyClientCertFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config.ProxyClientKey, err = ioutil.ReadFile(o.ProxyClientKeyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server, err := config.Complete().NewWithDelegate(genericapiserver.EmptyDelegate)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return server.GenericAPIServer.PrepareRun().Run(stopCh)
0000000000000000000000000000000000000000;;	}
