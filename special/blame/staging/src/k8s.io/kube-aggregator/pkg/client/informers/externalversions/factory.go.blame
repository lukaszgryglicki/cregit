0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
715bed33f9339daaeb56bd20205fb26e96c2a67c;cmd/kubernetes-discovery/pkg/client/informers/factory.go[cmd/kubernetes-discovery/pkg/client/informers/factory.go][staging/src/k8s.io/kube-aggregator/pkg/client/informers/externalversions/factory.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file was automatically generated by informer-gen
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package externalversions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		runtime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		schema "k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		cache "k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		clientset "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset"
0000000000000000000000000000000000000000;;		apiregistration "k8s.io/kube-aggregator/pkg/client/informers/externalversions/apiregistration"
0000000000000000000000000000000000000000;;		internalinterfaces "k8s.io/kube-aggregator/pkg/client/informers/externalversions/internalinterfaces"
0000000000000000000000000000000000000000;;		reflect "reflect"
0000000000000000000000000000000000000000;;		sync "sync"
0000000000000000000000000000000000000000;;		time "time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sharedInformerFactory struct {
0000000000000000000000000000000000000000;;		client        clientset.Interface
0000000000000000000000000000000000000000;;		lock          sync.Mutex
0000000000000000000000000000000000000000;;		defaultResync time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informers map[reflect.Type]cache.SharedIndexInformer
0000000000000000000000000000000000000000;;		// startedInformers is used for tracking which informers have been started.
0000000000000000000000000000000000000000;;		// This allows Start() to be called multiple times safely.
0000000000000000000000000000000000000000;;		startedInformers map[reflect.Type]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSharedInformerFactory constructs a new instance of sharedInformerFactory
0000000000000000000000000000000000000000;;	func NewSharedInformerFactory(client clientset.Interface, defaultResync time.Duration) SharedInformerFactory {
0000000000000000000000000000000000000000;;		return &sharedInformerFactory{
0000000000000000000000000000000000000000;;			client:           client,
0000000000000000000000000000000000000000;;			defaultResync:    defaultResync,
0000000000000000000000000000000000000000;;			informers:        make(map[reflect.Type]cache.SharedIndexInformer),
0000000000000000000000000000000000000000;;			startedInformers: make(map[reflect.Type]bool),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start initializes all requested informers.
0000000000000000000000000000000000000000;;	func (f *sharedInformerFactory) Start(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for informerType, informer := range f.informers {
0000000000000000000000000000000000000000;;			if !f.startedInformers[informerType] {
0000000000000000000000000000000000000000;;				go informer.Run(stopCh)
0000000000000000000000000000000000000000;;				f.startedInformers[informerType] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForCacheSync waits for all started informers' cache were synced.
0000000000000000000000000000000000000000;;	func (f *sharedInformerFactory) WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool {
0000000000000000000000000000000000000000;;		informers := func() map[reflect.Type]cache.SharedIndexInformer {
0000000000000000000000000000000000000000;;			f.lock.Lock()
0000000000000000000000000000000000000000;;			defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			informers := map[reflect.Type]cache.SharedIndexInformer{}
0000000000000000000000000000000000000000;;			for informerType, informer := range f.informers {
0000000000000000000000000000000000000000;;				if f.startedInformers[informerType] {
0000000000000000000000000000000000000000;;					informers[informerType] = informer
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return informers
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res := map[reflect.Type]bool{}
0000000000000000000000000000000000000000;;		for informType, informer := range informers {
0000000000000000000000000000000000000000;;			res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InternalInformerFor returns the SharedIndexInformer for obj using an internal
0000000000000000000000000000000000000000;;	// client.
0000000000000000000000000000000000000000;;	func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		informerType := reflect.TypeOf(obj)
0000000000000000000000000000000000000000;;		informer, exists := f.informers[informerType]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			return informer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		informer = newFunc(f.client, f.defaultResync)
0000000000000000000000000000000000000000;;		f.informers[informerType] = informer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return informer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SharedInformerFactory provides shared informers for resources in all known
0000000000000000000000000000000000000000;;	// API group versions.
0000000000000000000000000000000000000000;;	type SharedInformerFactory interface {
0000000000000000000000000000000000000000;;		internalinterfaces.SharedInformerFactory
0000000000000000000000000000000000000000;;		ForResource(resource schema.GroupVersionResource) (GenericInformer, error)
0000000000000000000000000000000000000000;;		WaitForCacheSync(stopCh <-chan struct{}) map[reflect.Type]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Apiregistration() apiregistration.Interface
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *sharedInformerFactory) Apiregistration() apiregistration.Interface {
0000000000000000000000000000000000000000;;		return apiregistration.New(f)
0000000000000000000000000000000000000000;;	}
