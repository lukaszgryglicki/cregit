0000000000000000000000000000000000000000;;	#!/bin/bash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Copyright 2016 The Kubernetes Authors.
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	# you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	# You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	#     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	#
0000000000000000000000000000000000000000;;	# Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	# distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	# See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	# limitations under the License.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# starts kube-aggregator as a pod after you've run `local-up-cluster.sh`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	set -o errexit
0000000000000000000000000000000000000000;;	set -o nounset
0000000000000000000000000000000000000000;;	set -o pipefail
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	AGG_ROOT=$(dirname "${BASH_SOURCE}")/..
0000000000000000000000000000000000000000;;	KUBE_ROOT=${AGG_ROOT}/../../../..
0000000000000000000000000000000000000000;;	source "${KUBE_ROOT}/hack/lib/init.sh"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	AGGREGATOR_SECURE_PORT=${AGGREGATOR_SECURE_PORT:-31090}
0000000000000000000000000000000000000000;;	API_HOST=${API_HOST:-localhost}
0000000000000000000000000000000000000000;;	API_HOST_IP=${API_HOST_IP:-"127.0.0.1"}
0000000000000000000000000000000000000000;;	AGGREGATOR_CERT_DIR=${AGGREGATOR_CERT_DIR:-"/var/run/kubernetes/aggregator"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	KUBE_CERT_DIR=${KUBE_CERT_DIR:-"/var/run/kubernetes"}
0000000000000000000000000000000000000000;;	SERVING_CERT_CA_CERT=${SERVING_CERT_CA_CERT:-"${KUBE_CERT_DIR}/server-ca.crt"}
0000000000000000000000000000000000000000;;	CLIENT_CERT_CA_CERT=${CLIENT_CERT_CA_CERT:-"${KUBE_CERT_DIR}/client-ca.crt"}
0000000000000000000000000000000000000000;;	FRONT_PROXY_CLIENT_CERT_CA_CERT=${FRONT_PROXY_CLIENT_CERT_CA_CERT:-"${KUBE_CERT_DIR}/request-header-ca.crt"}
0000000000000000000000000000000000000000;;	SERVING_CERT=${SERVING_CERT:-"${KUBE_CERT_DIR}/serving-kube-aggregator.crt"}
0000000000000000000000000000000000000000;;	SERVING_KEY=${SERVING_KEY:-"${KUBE_CERT_DIR}/serving-kube-aggregator.key"}
0000000000000000000000000000000000000000;;	FRONT_PROXY_CLIENT_CERT=${FRONT_PROXY_CLIENT_CERT:-"${KUBE_CERT_DIR}/client-auth-proxy.crt"}
0000000000000000000000000000000000000000;;	FRONT_PROXY_CLIENT_KEY=${FRONT_PROXY_CLIENT_KEY:-"${KUBE_CERT_DIR}/client-auth-proxy.key"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# Ensure AGGREGATOR_CERT_DIR is created for auto-generated crt/key and kubeconfig
0000000000000000000000000000000000000000;;	mkdir -p "${AGGREGATOR_CERT_DIR}" &>/dev/null || sudo mkdir -p "${AGGREGATOR_CERT_DIR}"
0000000000000000000000000000000000000000;;	sudo=$(test -w "${AGGREGATOR_CERT_DIR}" || echo "sudo -E")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	# start_kube-aggregator relies on certificates created by start_apiserver
0000000000000000000000000000000000000000;;	function start_kube-aggregator {
0000000000000000000000000000000000000000;;		 # Create serving and client CA.  etcd only takes one arg
0000000000000000000000000000000000000000;;		kube::util::create_signing_certkey "${sudo}" "${AGGREGATOR_CERT_DIR}" "etcd" '"client auth","server auth"'
0000000000000000000000000000000000000000;;		kube::util::create_serving_certkey "${sudo}" "${AGGREGATOR_CERT_DIR}" "etcd-ca" etcd etcd.kube-public.svc
0000000000000000000000000000000000000000;;		# etcd doesn't seem to have separate signers for serving and client trust
0000000000000000000000000000000000000000;;		kube::util::create_client_certkey "${sudo}" "${AGGREGATOR_CERT_DIR}" "etcd-ca" kube-aggregator-etcd kube-aggregator-etcd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# don't fail if the namespace already exists or something
0000000000000000000000000000000000000000;;		# If this fails for some reason, the script will fail during creation of other resources
0000000000000000000000000000000000000000;;		kubectl create namespace kube-public || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# grant permission to run delegated authentication and authorization checks
0000000000000000000000000000000000000000;;		kubectl delete clusterrolebinding kube-aggregator:system:auth-delegator > /dev/null 2>&1 || true
0000000000000000000000000000000000000000;;		kubectl delete clusterrolebinding kube-aggregator:system:kube-aggregator > /dev/null 2>&1 || true
0000000000000000000000000000000000000000;;		kubectl create clusterrolebinding kube-aggregator:system:auth-delegator --clusterrole=system:auth-delegator --serviceaccount=kube-public:kube-aggregator
0000000000000000000000000000000000000000;;		kubectl create clusterrolebinding kube-aggregator:system:kube-aggregator --clusterrole=system:kube-aggregator --serviceaccount=kube-public:kube-aggregator
0000000000000000000000000000000000000000;;		kubectl delete rolebinding -n kube-system kube-aggregator:authentication-reader > /dev/null 2>&1 || true
0000000000000000000000000000000000000000;;		kubectl create rolebinding -n kube-system kube-aggregator:authentication-reader --role=extension-apiserver-authentication-reader --serviceaccount=kube-public:kube-aggregator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# make sure the resources we're about to create don't exist
0000000000000000000000000000000000000000;;		kubectl -n kube-public delete secret auth-proxy-client serving-etcd serving-kube-aggregator kube-aggregator-etcd > /dev/null 2>&1 || true
0000000000000000000000000000000000000000;;		kubectl -n kube-public delete configmap etcd-ca kube-aggregator-ca client-ca request-header-ca > /dev/null 2>&1 || true
0000000000000000000000000000000000000000;;		kubectl -n kube-public delete -f "${AGG_ROOT}/artifacts/self-contained" > /dev/null 2>&1 || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		${sudo} $(which kubectl) -n kube-public create secret tls auth-proxy-client --cert="${FRONT_PROXY_CLIENT_CERT}" --key="${FRONT_PROXY_CLIENT_KEY}"
0000000000000000000000000000000000000000;;		${sudo} $(which kubectl)  -n kube-public create secret tls serving-etcd --cert="${AGGREGATOR_CERT_DIR}/serving-etcd.crt" --key="${AGGREGATOR_CERT_DIR}/serving-etcd.key"
0000000000000000000000000000000000000000;;		${sudo} $(which kubectl)  -n kube-public create secret tls serving-kube-aggregator --cert="${SERVING_CERT}" --key="${SERVING_KEY}"
0000000000000000000000000000000000000000;;		${sudo} $(which kubectl)  -n kube-public create secret tls kube-aggregator-etcd --cert="${AGGREGATOR_CERT_DIR}/client-kube-aggregator-etcd.crt" --key="${AGGREGATOR_CERT_DIR}/client-kube-aggregator-etcd.key"
0000000000000000000000000000000000000000;;		kubectl -n kube-public create configmap etcd-ca --from-file="ca.crt=${AGGREGATOR_CERT_DIR}/etcd-ca.crt" || true
0000000000000000000000000000000000000000;;		kubectl -n kube-public create configmap kube-aggregator-ca --from-file="ca.crt=${SERVING_CERT_CA_CERT}" || true
0000000000000000000000000000000000000000;;		kubectl -n kube-public create configmap client-ca --from-file="ca.crt=${CLIENT_CERT_CA_CERT}" || true
0000000000000000000000000000000000000000;;		kubectl -n kube-public create configmap request-header-ca --from-file="ca.crt=${FRONT_PROXY_CLIENT_CERT_CA_CERT}" || true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubectl -n kube-public create -f "${AGG_ROOT}/artifacts/self-contained"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		# Wait for kube-aggregator to come up before launching the rest of the components.
0000000000000000000000000000000000000000;;		# This should work since we're creating a node port service.
0000000000000000000000000000000000000000;;		echo "Waiting for kube-aggregator to come up: https://${API_HOST_IP}:${AGGREGATOR_SECURE_PORT}/version"
0000000000000000000000000000000000000000;;		kube::util::wait_for_url "https://${API_HOST_IP}:${AGGREGATOR_SECURE_PORT}/version" "kube-aggregator: " 1 60 || exit 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kube::util::test_openssl_installed
0000000000000000000000000000000000000000;;	kube::util::ensure-cfssl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	start_kube-aggregator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	echo "kube-aggregator available at https://${API_HOST_IP}:${AGGREGATOR_SECURE_PORT} from 'api.kube-public.svc'"
