0000000000000000000000000000000000000000;;	# Authenticating inside the cluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This example shows you how to configure a client with client-go to authenticate
0000000000000000000000000000000000000000;;	to the Kubernetes API from an application running inside the Kubernetes cluster.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	client-go uses the [Service Account token][sa] mounted inside the Pod at the
0000000000000000000000000000000000000000;;	`/var/run/secrets/kubernetes.io/serviceaccount` path when the
0000000000000000000000000000000000000000;;	`rest.InClusterConfig()` is used.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Running this example
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	First compile the application for Linux:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    cd in-cluster-client-configuration
0000000000000000000000000000000000000000;;	    GOOS=linux go build -o ./app .
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Then package it to a docker image using the provided Dockerfile to run it on
0000000000000000000000000000000000000000;;	Kubernetes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you are running a [Minikube][mk] cluster, you can build this image directly
0000000000000000000000000000000000000000;;	on the Docker engine of the Minikube node without pushing it to a registry. To
0000000000000000000000000000000000000000;;	build the image on Minikube:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    eval $(minikube docker-env)
0000000000000000000000000000000000000000;;	    docker build -t in-cluster .
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you are not using Minikube, you should build this image and push it to a registry
0000000000000000000000000000000000000000;;	that your Kubernetes cluster can pull from.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Then, run the image in a Pod with a single instance Deployment:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    $ kubectl run --rm -i demo --image=in-cluster --image-pull-policy=Never
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    There are 4 pods in the cluster
0000000000000000000000000000000000000000;;	    There are 4 pods in the cluster
0000000000000000000000000000000000000000;;	    There are 4 pods in the cluster
0000000000000000000000000000000000000000;;	    ...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The example now runs on Kubernetes API and successfully queries the number of
0000000000000000000000000000000000000000;;	pods in the cluster every 10 seconds.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Clean up
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To stop this example and clean up the pod, press <kbd>Ctrl</kbd>+<kbd>C</kbd> on
0000000000000000000000000000000000000000;;	the `kubectl run` command and then run:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    kubectl delete deployment demo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[sa]: https://kubernetes.io/docs/admin/authentication/#service-account-tokens
0000000000000000000000000000000000000000;;	[mk]: https://kubernetes.io/docs/getting-started-guides/minikube/
