0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
0eb6222e789517ddbde121fe23773a3e49382dee;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note: the example only works with the code within the same release/branch.
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		appsv1beta1 "k8s.io/api/apps/v1beta1"
0000000000000000000000000000000000000000;;		apiv1 "k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		// Uncomment the following line to load the gcp plugin (only required to authenticate against GKE clusters).
0000000000000000000000000000000000000000;;		// _ "k8s.io/client-go/plugin/pkg/client/auth/gcp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		kubeconfig := flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;		if *kubeconfig == "" {
0000000000000000000000000000000000000000;;			panic("-kubeconfig not specified")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clientset, err := kubernetes.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deploymentsClient := clientset.AppsV1beta1().Deployments(apiv1.NamespaceDefault)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deployment := &appsv1beta1.Deployment{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name: "demo-deployment",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Spec: appsv1beta1.DeploymentSpec{
0000000000000000000000000000000000000000;;				Replicas: int32Ptr(2),
0000000000000000000000000000000000000000;;				Template: apiv1.PodTemplateSpec{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Labels: map[string]string{
0000000000000000000000000000000000000000;;							"app": "demo",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Spec: apiv1.PodSpec{
0000000000000000000000000000000000000000;;						Containers: []apiv1.Container{
0000000000000000000000000000000000000000;;							{
0000000000000000000000000000000000000000;;								Name:  "web",
0000000000000000000000000000000000000000;;								Image: "nginx:1.13",
0000000000000000000000000000000000000000;;								Ports: []apiv1.ContainerPort{
0000000000000000000000000000000000000000;;									{
0000000000000000000000000000000000000000;;										Name:          "http",
0000000000000000000000000000000000000000;;										Protocol:      apiv1.ProtocolTCP,
0000000000000000000000000000000000000000;;										ContainerPort: 80,
0000000000000000000000000000000000000000;;									},
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create Deployment
0000000000000000000000000000000000000000;;		fmt.Println("Creating deployment...")
0000000000000000000000000000000000000000;;		result, err := deploymentsClient.Create(deployment)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Printf("Created deployment %q.\n", result.GetObjectMeta().GetName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update Deployment
0000000000000000000000000000000000000000;;		prompt()
0000000000000000000000000000000000000000;;		fmt.Println("Updating deployment...")
0000000000000000000000000000000000000000;;		//    You have two options to Update() this Deployment:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//    1. Modify the "deployment" variable and call: Update(deployment).
0000000000000000000000000000000000000000;;		//       This works like the "kubectl replace" command and it overwrites/loses changes
0000000000000000000000000000000000000000;;		//       made by other clients between you Create() and Update() the object.
0000000000000000000000000000000000000000;;		//    2. Modify the "result" returned by Create()/Get() and retry Update(result) until
0000000000000000000000000000000000000000;;		//       you no longer get a conflict error. This way, you can preserve changes made
0000000000000000000000000000000000000000;;		//       by other clients between Create() and Update(). This is implemented below:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			result.Spec.Replicas = int32Ptr(1)                    // reduce replica count
0000000000000000000000000000000000000000;;			result.Spec.Template.Annotations = map[string]string{ // add annotations
0000000000000000000000000000000000000000;;				"foo": "bar",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := deploymentsClient.Update(result); errors.IsConflict(err) {
0000000000000000000000000000000000000000;;				// Deployment is modified in the meanwhile, query the latest version
0000000000000000000000000000000000000000;;				// and modify the retrieved object.
0000000000000000000000000000000000000000;;				fmt.Println("encountered conflict, retrying")
0000000000000000000000000000000000000000;;				result, err = deploymentsClient.Get("demo-deployment", metav1.GetOptions{})
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					panic(fmt.Errorf("Get failed: %+v", err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// TODO: You should sleep here with an exponential backoff to avoid
0000000000000000000000000000000000000000;;			// exhausting the apiserver, and add a limit/timeout on the retries to
0000000000000000000000000000000000000000;;			// avoid getting stuck in this loop indefintiely.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Println("Updated deployment...")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List Deployments
0000000000000000000000000000000000000000;;		prompt()
0000000000000000000000000000000000000000;;		fmt.Printf("Listing deployments in namespace %q:\n", apiv1.NamespaceDefault)
0000000000000000000000000000000000000000;;		list, err := deploymentsClient.List(metav1.ListOptions{})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, d := range list.Items {
0000000000000000000000000000000000000000;;			fmt.Printf(" * %s (%d replicas)\n", d.Name, *d.Spec.Replicas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete Deployment
0000000000000000000000000000000000000000;;		prompt()
0000000000000000000000000000000000000000;;		fmt.Println("Deleting deployment...")
0000000000000000000000000000000000000000;;		deletePolicy := metav1.DeletePropagationForeground
0000000000000000000000000000000000000000;;		if err := deploymentsClient.Delete("demo-deployment", &metav1.DeleteOptions{
0000000000000000000000000000000000000000;;			PropagationPolicy: &deletePolicy,
0000000000000000000000000000000000000000;;		}); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Println("Deleted deployment.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prompt() {
0000000000000000000000000000000000000000;;		fmt.Printf("-> Press Return key to continue.")
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(os.Stdin)
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := scanner.Err(); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Println()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func int32Ptr(i int32) *int32 { return &i }
