0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
fc3f17d80a5a07368583ee49e69d72f5f742510e;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		meta_v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/fields"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/cache"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/clientcmd"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/workqueue"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Controller struct {
0000000000000000000000000000000000000000;;		indexer  cache.Indexer
0000000000000000000000000000000000000000;;		queue    workqueue.RateLimitingInterface
0000000000000000000000000000000000000000;;		informer cache.Controller
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewController(queue workqueue.RateLimitingInterface, indexer cache.Indexer, informer cache.Controller) *Controller {
0000000000000000000000000000000000000000;;		return &Controller{
0000000000000000000000000000000000000000;;			informer: informer,
0000000000000000000000000000000000000000;;			indexer:  indexer,
0000000000000000000000000000000000000000;;			queue:    queue,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Controller) processNextItem() bool {
0000000000000000000000000000000000000000;;		// Wait until there is a new item in the working queue
0000000000000000000000000000000000000000;;		key, quit := c.queue.Get()
0000000000000000000000000000000000000000;;		if quit {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Tell the queue that we are done with processing this key. This unblocks the key for other workers
0000000000000000000000000000000000000000;;		// This allows safe parallel processing because two pods with the same key are never processed in
0000000000000000000000000000000000000000;;		// parallel.
0000000000000000000000000000000000000000;;		defer c.queue.Done(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Invoke the method containing the business logic
0000000000000000000000000000000000000000;;		err := c.syncToStdout(key.(string))
0000000000000000000000000000000000000000;;		// Handle the error if something went wrong during the execution of the business logic
0000000000000000000000000000000000000000;;		c.handleErr(err, key)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncToStdout is the business logic of the controller. In this controller it simply prints
0000000000000000000000000000000000000000;;	// information about the pod to stdout. In case an error happened, it has to simply return the error.
0000000000000000000000000000000000000000;;	// The retry logic should not be part of the business logic.
0000000000000000000000000000000000000000;;	func (c *Controller) syncToStdout(key string) error {
0000000000000000000000000000000000000000;;		obj, exists, err := c.indexer.GetByKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Fetching object with key %s from store failed with %v", key, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			// Below we will warm up our cache with a Pod, so that we will see a delete for one pod
0000000000000000000000000000000000000000;;			fmt.Printf("Pod %s does not exist anymore\n", key)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Note that you also have to check the uid if you have a local controlled resource, which
0000000000000000000000000000000000000000;;			// is dependent on the actual instance, to detect that a Pod was recreated with the same name
0000000000000000000000000000000000000000;;			fmt.Printf("Sync/Add/Update for Pod %s\n", obj.(*v1.Pod).GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleErr checks if an error happened and makes sure we will retry later.
0000000000000000000000000000000000000000;;	func (c *Controller) handleErr(err error, key interface{}) {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// Forget about the #AddRateLimited history of the key on every successful synchronization.
0000000000000000000000000000000000000000;;			// This ensures that future processing of updates for this key is not delayed because of
0000000000000000000000000000000000000000;;			// an outdated error history.
0000000000000000000000000000000000000000;;			c.queue.Forget(key)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This controller retries 5 times if something goes wrong. After that, it stops trying.
0000000000000000000000000000000000000000;;		if c.queue.NumRequeues(key) < 5 {
0000000000000000000000000000000000000000;;			glog.Infof("Error syncing pod %v: %v", key, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Re-enqueue the key rate limited. Based on the rate limiter on the
0000000000000000000000000000000000000000;;			// queue and the re-enqueue history, the key will be processed later again.
0000000000000000000000000000000000000000;;			c.queue.AddRateLimited(key)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.queue.Forget(key)
0000000000000000000000000000000000000000;;		// Report to an external entity that, even after several retries, we could not successfully process this key
0000000000000000000000000000000000000000;;		runtime.HandleError(err)
0000000000000000000000000000000000000000;;		glog.Infof("Dropping pod %q out of the queue: %v", key, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Controller) Run(threadiness int, stopCh chan struct{}) {
0000000000000000000000000000000000000000;;		defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let the workers stop when we are done
0000000000000000000000000000000000000000;;		defer c.queue.ShutDown()
0000000000000000000000000000000000000000;;		glog.Info("Starting Pod controller")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go c.informer.Run(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for all involved caches to be synced, before processing items from the queue is started
0000000000000000000000000000000000000000;;		if !cache.WaitForCacheSync(stopCh, c.informer.HasSynced) {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("Timed out waiting for caches to sync"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < threadiness; i++ {
0000000000000000000000000000000000000000;;			go wait.Until(c.runWorker, time.Second, stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-stopCh
0000000000000000000000000000000000000000;;		glog.Info("Stopping Pod controller")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Controller) runWorker() {
0000000000000000000000000000000000000000;;		for c.processNextItem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		var kubeconfig string
0000000000000000000000000000000000000000;;		var master string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag.StringVar(&kubeconfig, "kubeconfig", "", "absolute path to the kubeconfig file")
0000000000000000000000000000000000000000;;		flag.StringVar(&master, "master", "", "master url")
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// creates the connection
0000000000000000000000000000000000000000;;		config, err := clientcmd.BuildConfigFromFlags(master, kubeconfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// creates the clientset
0000000000000000000000000000000000000000;;		clientset, err := kubernetes.NewForConfig(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create the pod watcher
0000000000000000000000000000000000000000;;		podListWatcher := cache.NewListWatchFromClient(clientset.Core().RESTClient(), "pods", v1.NamespaceDefault, fields.Everything())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create the workqueue
0000000000000000000000000000000000000000;;		queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bind the workqueue to a cache with the help of an informer. This way we make sure that
0000000000000000000000000000000000000000;;		// whenever the cache is updated, the pod key is added to the workqueue.
0000000000000000000000000000000000000000;;		// Note that when we finally process the item from the workqueue, we might see a newer version
0000000000000000000000000000000000000000;;		// of the Pod than the version which was responsible for triggering the update.
0000000000000000000000000000000000000000;;		indexer, informer := cache.NewIndexerInformer(podListWatcher, &v1.Pod{}, 0, cache.ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;			AddFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				key, err := cache.MetaNamespaceKeyFunc(obj)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					queue.Add(key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			UpdateFunc: func(old interface{}, new interface{}) {
0000000000000000000000000000000000000000;;				key, err := cache.MetaNamespaceKeyFunc(new)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					queue.Add(key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			DeleteFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;				// IndexerInformer uses a delta queue, therefore for deletes we have to use this
0000000000000000000000000000000000000000;;				// key function.
0000000000000000000000000000000000000000;;				key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					queue.Add(key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, cache.Indexers{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		controller := NewController(queue, indexer, informer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We can now warm up the cache for initial synchronization.
0000000000000000000000000000000000000000;;		// Let's suppose that we knew about a pod "mypod" on our last run, therefore add it to the cache.
0000000000000000000000000000000000000000;;		// If this pod is not there anymore, the controller will be notified about the removal after the
0000000000000000000000000000000000000000;;		// cache has synchronized.
0000000000000000000000000000000000000000;;		indexer.Add(&v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: meta_v1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      "mypod",
0000000000000000000000000000000000000000;;				Namespace: v1.NamespaceDefault,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now let's start the controller
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;		go controller.Run(1, stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait forever
0000000000000000000000000000000000000000;;		select {}
0000000000000000000000000000000000000000;;	}
