0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/record/event_test.go[staging/src/k8s.io/client-go/1.4/tools/record/event_test.go][staging/src/k8s.io/client-go/tools/record/event_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package record
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		k8sruntime "k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/strategicpatch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/pkg/api/v1/ref"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testEventSink struct {
0000000000000000000000000000000000000000;;		OnCreate func(e *v1.Event) (*v1.Event, error)
0000000000000000000000000000000000000000;;		OnUpdate func(e *v1.Event) (*v1.Event, error)
0000000000000000000000000000000000000000;;		OnPatch  func(e *v1.Event, p []byte) (*v1.Event, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateEvent records the event for testing.
0000000000000000000000000000000000000000;;	func (t *testEventSink) Create(e *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		if t.OnCreate != nil {
0000000000000000000000000000000000000000;;			return t.OnCreate(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateEvent records the event for testing.
0000000000000000000000000000000000000000;;	func (t *testEventSink) Update(e *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		if t.OnUpdate != nil {
0000000000000000000000000000000000000000;;			return t.OnUpdate(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PatchEvent records the event for testing.
0000000000000000000000000000000000000000;;	func (t *testEventSink) Patch(e *v1.Event, p []byte) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		if t.OnPatch != nil {
0000000000000000000000000000000000000000;;			return t.OnPatch(e, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OnCreateFunc func(*v1.Event) (*v1.Event, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func OnCreateFactory(testCache map[string]*v1.Event, createEvent chan<- *v1.Event) OnCreateFunc {
0000000000000000000000000000000000000000;;		return func(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;			testCache[getEventKey(event)] = event
0000000000000000000000000000000000000000;;			createEvent <- event
0000000000000000000000000000000000000000;;			return event, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OnPatchFunc func(*v1.Event, []byte) (*v1.Event, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func OnPatchFactory(testCache map[string]*v1.Event, patchEvent chan<- *v1.Event) OnPatchFunc {
0000000000000000000000000000000000000000;;		return func(event *v1.Event, patch []byte) (*v1.Event, error) {
0000000000000000000000000000000000000000;;			cachedEvent, found := testCache[getEventKey(event)]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected error: couldn't find Event in testCache.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			originalData, err := json.Marshal(cachedEvent)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			patched, err := strategicpatch.StrategicMergePatch(originalData, patch, event)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			patchedObj := &v1.Event{}
0000000000000000000000000000000000000000;;			err = json.Unmarshal(patched, patchedObj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			patchEvent <- patchedObj
0000000000000000000000000000000000000000;;			return patchedObj, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEventf(t *testing.T) {
0000000000000000000000000000000000000000;;		testPod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				SelfLink:  "/api/version/pods/foo",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "baz",
0000000000000000000000000000000000000000;;				UID:       "bar",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testPod2 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				SelfLink:  "/api/version/pods/foo",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "baz",
0000000000000000000000000000000000000000;;				UID:       "differentUid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testRef, err := ref.GetPartialReference(scheme.Scheme, testPod, "spec.containers[2]")
0000000000000000000000000000000000000000;;		testRef2, err := ref.GetPartialReference(scheme.Scheme, testPod2, "spec.containers[3]")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			obj          k8sruntime.Object
0000000000000000000000000000000000000000;;			eventtype    string
0000000000000000000000000000000000000000;;			reason       string
0000000000000000000000000000000000000000;;			messageFmt   string
0000000000000000000000000000000000000000;;			elements     []interface{}
0000000000000000000000000000000000000000;;			expect       *v1.Event
0000000000000000000000000000000000000000;;			expectLog    string
0000000000000000000000000000000000000000;;			expectUpdate bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Started",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "bar",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[2]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Started",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   1,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"bar", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[2]"}): type: 'Normal' reason: 'Started' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testPod,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Killed",
0000000000000000000000000000000000000000;;				messageFmt: "some other verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "bar",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Killed",
0000000000000000000000000000000000000000;;					Message: "some other verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   1,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"bar", APIVersion:"version", ResourceVersion:"", FieldPath:""}): type: 'Normal' reason: 'Killed' some other verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Started",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "bar",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[2]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Started",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   2,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"bar", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[2]"}): type: 'Normal' reason: 'Started' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef2,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Started",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "differentUid",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[3]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Started",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   1,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"differentUid", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[3]"}): type: 'Normal' reason: 'Started' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Started",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "bar",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[2]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Started",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   3,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"bar", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[2]"}): type: 'Normal' reason: 'Started' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef2,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Stopped",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "differentUid",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[3]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Stopped",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   1,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"differentUid", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[3]"}): type: 'Normal' reason: 'Stopped' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef2,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Stopped",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "differentUid",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[3]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Stopped",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   2,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"differentUid", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[3]"}): type: 'Normal' reason: 'Stopped' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCache := map[string]*v1.Event{}
0000000000000000000000000000000000000000;;		logCalled := make(chan struct{})
0000000000000000000000000000000000000000;;		createEvent := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		updateEvent := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		patchEvent := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		testEvents := testEventSink{
0000000000000000000000000000000000000000;;			OnCreate: OnCreateFactory(testCache, createEvent),
0000000000000000000000000000000000000000;;			OnUpdate: func(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;				updateEvent <- event
0000000000000000000000000000000000000000;;				return event, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			OnPatch: OnPatchFactory(testCache, patchEvent),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster := NewBroadcasterForTests(0)
0000000000000000000000000000000000000000;;		sinkWatcher := eventBroadcaster.StartRecordingToSink(&testEvents)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		recorder := recorderWithFakeClock(v1.EventSource{Component: "eventTest"}, eventBroadcaster, clock)
0000000000000000000000000000000000000000;;		for index, item := range table {
0000000000000000000000000000000000000000;;			clock.Step(1 * time.Second)
0000000000000000000000000000000000000000;;			logWatcher := eventBroadcaster.StartLogging(func(formatter string, args ...interface{}) {
0000000000000000000000000000000000000000;;				if e, a := item.expectLog, fmt.Sprintf(formatter, args...); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("Expected '%v', got '%v'", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				logCalled <- struct{}{}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			recorder.Eventf(item.obj, item.eventtype, item.reason, item.messageFmt, item.elements...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			<-logCalled
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate event
0000000000000000000000000000000000000000;;			if item.expectUpdate {
0000000000000000000000000000000000000000;;				actualEvent := <-patchEvent
0000000000000000000000000000000000000000;;				validateEvent(strconv.Itoa(index), actualEvent, item.expect, t)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				actualEvent := <-createEvent
0000000000000000000000000000000000000000;;				validateEvent(strconv.Itoa(index), actualEvent, item.expect, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			logWatcher.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sinkWatcher.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recorderWithFakeClock(eventSource v1.EventSource, eventBroadcaster EventBroadcaster, clock clock.Clock) EventRecorder {
0000000000000000000000000000000000000000;;		return &recorderImpl{scheme.Scheme, eventSource, eventBroadcaster.(*eventBroadcasterImpl).Broadcaster, clock}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestWriteEventError(t *testing.T) {
0000000000000000000000000000000000000000;;		type entry struct {
0000000000000000000000000000000000000000;;			timesToSendError int
0000000000000000000000000000000000000000;;			attemptsWanted   int
0000000000000000000000000000000000000000;;			err              error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		table := map[string]*entry{
0000000000000000000000000000000000000000;;			"giveUp1": {
0000000000000000000000000000000000000000;;				timesToSendError: 1000,
0000000000000000000000000000000000000000;;				attemptsWanted:   1,
0000000000000000000000000000000000000000;;				err:              &restclient.RequestConstructionError{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"giveUp2": {
0000000000000000000000000000000000000000;;				timesToSendError: 1000,
0000000000000000000000000000000000000000;;				attemptsWanted:   1,
0000000000000000000000000000000000000000;;				err:              &errors.StatusError{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"retry1": {
0000000000000000000000000000000000000000;;				timesToSendError: 1000,
0000000000000000000000000000000000000000;;				attemptsWanted:   12,
0000000000000000000000000000000000000000;;				err:              &errors.UnexpectedObjectError{},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"retry2": {
0000000000000000000000000000000000000000;;				timesToSendError: 1000,
0000000000000000000000000000000000000000;;				attemptsWanted:   12,
0000000000000000000000000000000000000000;;				err:              fmt.Errorf("A weird error"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"succeedEventually": {
0000000000000000000000000000000000000000;;				timesToSendError: 2,
0000000000000000000000000000000000000000;;				attemptsWanted:   2,
0000000000000000000000000000000000000000;;				err:              fmt.Errorf("A weird error"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventCorrelator := NewEventCorrelator(clock.RealClock{})
0000000000000000000000000000000000000000;;		randGen := rand.New(rand.NewSource(time.Now().UnixNano()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for caseName, ent := range table {
0000000000000000000000000000000000000000;;			attempts := 0
0000000000000000000000000000000000000000;;			sink := &testEventSink{
0000000000000000000000000000000000000000;;				OnCreate: func(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;					attempts++
0000000000000000000000000000000000000000;;					if attempts < ent.timesToSendError {
0000000000000000000000000000000000000000;;						return nil, ent.err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return event, nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ev := &v1.Event{}
0000000000000000000000000000000000000000;;			recordToSink(sink, ev, eventCorrelator, randGen, 0)
0000000000000000000000000000000000000000;;			if attempts != ent.attemptsWanted {
0000000000000000000000000000000000000000;;				t.Errorf("case %v: wanted %d, got %d attempts", caseName, ent.attemptsWanted, attempts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdateExpiredEvent(t *testing.T) {
0000000000000000000000000000000000000000;;		eventCorrelator := NewEventCorrelator(clock.RealClock{})
0000000000000000000000000000000000000000;;		randGen := rand.New(rand.NewSource(time.Now().UnixNano()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var createdEvent *v1.Event
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sink := &testEventSink{
0000000000000000000000000000000000000000;;			OnPatch: func(*v1.Event, []byte) (*v1.Event, error) {
0000000000000000000000000000000000000000;;				return nil, &errors.StatusError{
0000000000000000000000000000000000000000;;					ErrStatus: metav1.Status{
0000000000000000000000000000000000000000;;						Code:   http.StatusNotFound,
0000000000000000000000000000000000000000;;						Reason: metav1.StatusReasonNotFound,
0000000000000000000000000000000000000000;;					}}
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			OnCreate: func(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;				createdEvent = event
0000000000000000000000000000000000000000;;				return event, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ev := &v1.Event{}
0000000000000000000000000000000000000000;;		ev.ResourceVersion = "updated-resource-version"
0000000000000000000000000000000000000000;;		ev.Count = 2
0000000000000000000000000000000000000000;;		recordToSink(sink, ev, eventCorrelator, randGen, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if createdEvent == nil {
0000000000000000000000000000000000000000;;			t.Error("Event did not get created after patch failed")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if createdEvent.ResourceVersion != "" {
0000000000000000000000000000000000000000;;			t.Errorf("Event did not have its resource version cleared, was %s", createdEvent.ResourceVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestLotsOfEvents(t *testing.T) {
0000000000000000000000000000000000000000;;		recorderCalled := make(chan struct{})
0000000000000000000000000000000000000000;;		loggerCalled := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fail each event a few times to ensure there's some load on the tested code.
0000000000000000000000000000000000000000;;		var counts [1000]int
0000000000000000000000000000000000000000;;		testEvents := testEventSink{
0000000000000000000000000000000000000000;;			OnCreate: func(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;				num, err := strconv.Atoi(event.Message)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Error(err)
0000000000000000000000000000000000000000;;					return event, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				counts[num]++
0000000000000000000000000000000000000000;;				if counts[num] < 5 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("fake error")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				recorderCalled <- struct{}{}
0000000000000000000000000000000000000000;;				return event, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := NewBroadcasterForTests(0)
0000000000000000000000000000000000000000;;		sinkWatcher := eventBroadcaster.StartRecordingToSink(&testEvents)
0000000000000000000000000000000000000000;;		logWatcher := eventBroadcaster.StartLogging(func(formatter string, args ...interface{}) {
0000000000000000000000000000000000000000;;			loggerCalled <- struct{}{}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		recorder := eventBroadcaster.NewRecorder(scheme.Scheme, v1.EventSource{Component: "eventTest"})
0000000000000000000000000000000000000000;;		ref := &v1.ObjectReference{
0000000000000000000000000000000000000000;;			Kind:       "Pod",
0000000000000000000000000000000000000000;;			Name:       "foo",
0000000000000000000000000000000000000000;;			Namespace:  "baz",
0000000000000000000000000000000000000000;;			UID:        "bar",
0000000000000000000000000000000000000000;;			APIVersion: "version",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < maxQueuedEvents; i++ {
0000000000000000000000000000000000000000;;			// we need to vary the reason to prevent aggregation
0000000000000000000000000000000000000000;;			go recorder.Eventf(ref, v1.EventTypeNormal, "Reason-"+string(i), strconv.Itoa(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make sure no events were dropped by either of the listeners.
0000000000000000000000000000000000000000;;		for i := 0; i < maxQueuedEvents; i++ {
0000000000000000000000000000000000000000;;			<-recorderCalled
0000000000000000000000000000000000000000;;			<-loggerCalled
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make sure that every event was attempted 5 times
0000000000000000000000000000000000000000;;		for i := 0; i < maxQueuedEvents; i++ {
0000000000000000000000000000000000000000;;			if counts[i] < 5 {
0000000000000000000000000000000000000000;;				t.Errorf("Only attempted to record event '%d' %d times.", i, counts[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sinkWatcher.Stop()
0000000000000000000000000000000000000000;;		logWatcher.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestEventfNoNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		testPod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				SelfLink: "/api/version/pods/foo",
0000000000000000000000000000000000000000;;				Name:     "foo",
0000000000000000000000000000000000000000;;				UID:      "bar",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testRef, err := ref.GetPartialReference(scheme.Scheme, testPod, "spec.containers[2]")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			obj          k8sruntime.Object
0000000000000000000000000000000000000000;;			eventtype    string
0000000000000000000000000000000000000000;;			reason       string
0000000000000000000000000000000000000000;;			messageFmt   string
0000000000000000000000000000000000000000;;			elements     []interface{}
0000000000000000000000000000000000000000;;			expect       *v1.Event
0000000000000000000000000000000000000000;;			expectLog    string
0000000000000000000000000000000000000000;;			expectUpdate bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Started",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "default",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "",
0000000000000000000000000000000000000000;;						UID:        "bar",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[2]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Started",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   1,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"", Name:"foo", UID:"bar", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[2]"}): type: 'Normal' reason: 'Started' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCache := map[string]*v1.Event{}
0000000000000000000000000000000000000000;;		logCalled := make(chan struct{})
0000000000000000000000000000000000000000;;		createEvent := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		updateEvent := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		patchEvent := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		testEvents := testEventSink{
0000000000000000000000000000000000000000;;			OnCreate: OnCreateFactory(testCache, createEvent),
0000000000000000000000000000000000000000;;			OnUpdate: func(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;				updateEvent <- event
0000000000000000000000000000000000000000;;				return event, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			OnPatch: OnPatchFactory(testCache, patchEvent),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventBroadcaster := NewBroadcasterForTests(0)
0000000000000000000000000000000000000000;;		sinkWatcher := eventBroadcaster.StartRecordingToSink(&testEvents)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		recorder := recorderWithFakeClock(v1.EventSource{Component: "eventTest"}, eventBroadcaster, clock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for index, item := range table {
0000000000000000000000000000000000000000;;			clock.Step(1 * time.Second)
0000000000000000000000000000000000000000;;			logWatcher := eventBroadcaster.StartLogging(func(formatter string, args ...interface{}) {
0000000000000000000000000000000000000000;;				if e, a := item.expectLog, fmt.Sprintf(formatter, args...); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("Expected '%v', got '%v'", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				logCalled <- struct{}{}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			recorder.Eventf(item.obj, item.eventtype, item.reason, item.messageFmt, item.elements...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			<-logCalled
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate event
0000000000000000000000000000000000000000;;			if item.expectUpdate {
0000000000000000000000000000000000000000;;				actualEvent := <-patchEvent
0000000000000000000000000000000000000000;;				validateEvent(strconv.Itoa(index), actualEvent, item.expect, t)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				actualEvent := <-createEvent
0000000000000000000000000000000000000000;;				validateEvent(strconv.Itoa(index), actualEvent, item.expect, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			logWatcher.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sinkWatcher.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestMultiSinkCache(t *testing.T) {
0000000000000000000000000000000000000000;;		testPod := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				SelfLink:  "/api/version/pods/foo",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "baz",
0000000000000000000000000000000000000000;;				UID:       "bar",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testPod2 := &v1.Pod{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				SelfLink:  "/api/version/pods/foo",
0000000000000000000000000000000000000000;;				Name:      "foo",
0000000000000000000000000000000000000000;;				Namespace: "baz",
0000000000000000000000000000000000000000;;				UID:       "differentUid",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		testRef, err := ref.GetPartialReference(scheme.Scheme, testPod, "spec.containers[2]")
0000000000000000000000000000000000000000;;		testRef2, err := ref.GetPartialReference(scheme.Scheme, testPod2, "spec.containers[3]")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			obj          k8sruntime.Object
0000000000000000000000000000000000000000;;			eventtype    string
0000000000000000000000000000000000000000;;			reason       string
0000000000000000000000000000000000000000;;			messageFmt   string
0000000000000000000000000000000000000000;;			elements     []interface{}
0000000000000000000000000000000000000000;;			expect       *v1.Event
0000000000000000000000000000000000000000;;			expectLog    string
0000000000000000000000000000000000000000;;			expectUpdate bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Started",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "bar",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[2]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Started",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   1,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"bar", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[2]"}): type: 'Normal' reason: 'Started' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testPod,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Killed",
0000000000000000000000000000000000000000;;				messageFmt: "some other verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "bar",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Killed",
0000000000000000000000000000000000000000;;					Message: "some other verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   1,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"bar", APIVersion:"version", ResourceVersion:"", FieldPath:""}): type: 'Normal' reason: 'Killed' some other verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Started",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "bar",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[2]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Started",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   2,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"bar", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[2]"}): type: 'Normal' reason: 'Started' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef2,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Started",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "differentUid",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[3]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Started",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   1,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"differentUid", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[3]"}): type: 'Normal' reason: 'Started' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Started",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "bar",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[2]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Started",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   3,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"bar", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[2]"}): type: 'Normal' reason: 'Started' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef2,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Stopped",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "differentUid",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[3]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Stopped",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   1,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"differentUid", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[3]"}): type: 'Normal' reason: 'Stopped' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				obj:        testRef2,
0000000000000000000000000000000000000000;;				eventtype:  v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				reason:     "Stopped",
0000000000000000000000000000000000000000;;				messageFmt: "some verbose message: %v",
0000000000000000000000000000000000000000;;				elements:   []interface{}{1},
0000000000000000000000000000000000000000;;				expect: &v1.Event{
0000000000000000000000000000000000000000;;					ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;						Name:      "foo",
0000000000000000000000000000000000000000;;						Namespace: "baz",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					InvolvedObject: v1.ObjectReference{
0000000000000000000000000000000000000000;;						Kind:       "Pod",
0000000000000000000000000000000000000000;;						Name:       "foo",
0000000000000000000000000000000000000000;;						Namespace:  "baz",
0000000000000000000000000000000000000000;;						UID:        "differentUid",
0000000000000000000000000000000000000000;;						APIVersion: "version",
0000000000000000000000000000000000000000;;						FieldPath:  "spec.containers[3]",
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Reason:  "Stopped",
0000000000000000000000000000000000000000;;					Message: "some verbose message: 1",
0000000000000000000000000000000000000000;;					Source:  v1.EventSource{Component: "eventTest"},
0000000000000000000000000000000000000000;;					Count:   2,
0000000000000000000000000000000000000000;;					Type:    v1.EventTypeNormal,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectLog:    `Event(v1.ObjectReference{Kind:"Pod", Namespace:"baz", Name:"foo", UID:"differentUid", APIVersion:"version", ResourceVersion:"", FieldPath:"spec.containers[3]"}): type: 'Normal' reason: 'Stopped' some verbose message: 1`,
0000000000000000000000000000000000000000;;				expectUpdate: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCache := map[string]*v1.Event{}
0000000000000000000000000000000000000000;;		createEvent := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		updateEvent := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		patchEvent := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		testEvents := testEventSink{
0000000000000000000000000000000000000000;;			OnCreate: OnCreateFactory(testCache, createEvent),
0000000000000000000000000000000000000000;;			OnUpdate: func(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;				updateEvent <- event
0000000000000000000000000000000000000000;;				return event, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			OnPatch: OnPatchFactory(testCache, patchEvent),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCache2 := map[string]*v1.Event{}
0000000000000000000000000000000000000000;;		createEvent2 := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		updateEvent2 := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		patchEvent2 := make(chan *v1.Event)
0000000000000000000000000000000000000000;;		testEvents2 := testEventSink{
0000000000000000000000000000000000000000;;			OnCreate: OnCreateFactory(testCache2, createEvent2),
0000000000000000000000000000000000000000;;			OnUpdate: func(event *v1.Event) (*v1.Event, error) {
0000000000000000000000000000000000000000;;				updateEvent2 <- event
0000000000000000000000000000000000000000;;				return event, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			OnPatch: OnPatchFactory(testCache2, patchEvent2),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eventBroadcaster := NewBroadcasterForTests(0)
0000000000000000000000000000000000000000;;		clock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		recorder := recorderWithFakeClock(v1.EventSource{Component: "eventTest"}, eventBroadcaster, clock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sinkWatcher := eventBroadcaster.StartRecordingToSink(&testEvents)
0000000000000000000000000000000000000000;;		for index, item := range table {
0000000000000000000000000000000000000000;;			clock.Step(1 * time.Second)
0000000000000000000000000000000000000000;;			recorder.Eventf(item.obj, item.eventtype, item.reason, item.messageFmt, item.elements...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate event
0000000000000000000000000000000000000000;;			if item.expectUpdate {
0000000000000000000000000000000000000000;;				actualEvent := <-patchEvent
0000000000000000000000000000000000000000;;				validateEvent(strconv.Itoa(index), actualEvent, item.expect, t)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				actualEvent := <-createEvent
0000000000000000000000000000000000000000;;				validateEvent(strconv.Itoa(index), actualEvent, item.expect, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Another StartRecordingToSink call should start to record events with new clean cache.
0000000000000000000000000000000000000000;;		sinkWatcher2 := eventBroadcaster.StartRecordingToSink(&testEvents2)
0000000000000000000000000000000000000000;;		for index, item := range table {
0000000000000000000000000000000000000000;;			clock.Step(1 * time.Second)
0000000000000000000000000000000000000000;;			recorder.Eventf(item.obj, item.eventtype, item.reason, item.messageFmt, item.elements...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// validate event
0000000000000000000000000000000000000000;;			if item.expectUpdate {
0000000000000000000000000000000000000000;;				actualEvent := <-patchEvent2
0000000000000000000000000000000000000000;;				validateEvent(strconv.Itoa(index), actualEvent, item.expect, t)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				actualEvent := <-createEvent2
0000000000000000000000000000000000000000;;				validateEvent(strconv.Itoa(index), actualEvent, item.expect, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sinkWatcher.Stop()
0000000000000000000000000000000000000000;;		sinkWatcher2.Stop()
0000000000000000000000000000000000000000;;	}
