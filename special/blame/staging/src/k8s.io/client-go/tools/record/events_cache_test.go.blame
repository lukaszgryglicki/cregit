0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/record/events_cache_test.go[staging/src/k8s.io/client-go/1.4/tools/record/events_cache_test.go][staging/src/k8s.io/client-go/tools/record/events_cache_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package record
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/diff"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeObjectReference(kind, name, namespace string) v1.ObjectReference {
0000000000000000000000000000000000000000;;		return v1.ObjectReference{
0000000000000000000000000000000000000000;;			Kind:       kind,
0000000000000000000000000000000000000000;;			Name:       name,
0000000000000000000000000000000000000000;;			Namespace:  namespace,
0000000000000000000000000000000000000000;;			UID:        "C934D34AFB20242",
0000000000000000000000000000000000000000;;			APIVersion: "version",
0000000000000000000000000000000000000000;;			FieldPath:  "spec.containers{mycontainer}",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeEvent(reason, message string, involvedObject v1.ObjectReference) v1.Event {
0000000000000000000000000000000000000000;;		eventTime := metav1.Now()
0000000000000000000000000000000000000000;;		event := v1.Event{
0000000000000000000000000000000000000000;;			Reason:         reason,
0000000000000000000000000000000000000000;;			Message:        message,
0000000000000000000000000000000000000000;;			InvolvedObject: involvedObject,
0000000000000000000000000000000000000000;;			Source: v1.EventSource{
0000000000000000000000000000000000000000;;				Component: "kubelet",
0000000000000000000000000000000000000000;;				Host:      "kublet.node1",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Count:          1,
0000000000000000000000000000000000000000;;			FirstTimestamp: eventTime,
0000000000000000000000000000000000000000;;			LastTimestamp:  eventTime,
0000000000000000000000000000000000000000;;			Type:           v1.EventTypeNormal,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeEvents(num int, template v1.Event) []v1.Event {
0000000000000000000000000000000000000000;;		events := []v1.Event{}
0000000000000000000000000000000000000000;;		for i := 0; i < num; i++ {
0000000000000000000000000000000000000000;;			events = append(events, template)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return events
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeUniqueEvents(num int) []v1.Event {
0000000000000000000000000000000000000000;;		events := []v1.Event{}
0000000000000000000000000000000000000000;;		kind := "Pod"
0000000000000000000000000000000000000000;;		for i := 0; i < num; i++ {
0000000000000000000000000000000000000000;;			reason := strings.Join([]string{"reason", string(i)}, "-")
0000000000000000000000000000000000000000;;			message := strings.Join([]string{"message", string(i)}, "-")
0000000000000000000000000000000000000000;;			name := strings.Join([]string{"pod", string(i)}, "-")
0000000000000000000000000000000000000000;;			namespace := strings.Join([]string{"ns", string(i)}, "-")
0000000000000000000000000000000000000000;;			involvedObject := makeObjectReference(kind, name, namespace)
0000000000000000000000000000000000000000;;			events = append(events, makeEvent(reason, message, involvedObject))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return events
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeSimilarEvents(num int, template v1.Event, messagePrefix string) []v1.Event {
0000000000000000000000000000000000000000;;		events := makeEvents(num, template)
0000000000000000000000000000000000000000;;		for i := range events {
0000000000000000000000000000000000000000;;			events[i].Message = strings.Join([]string{messagePrefix, string(i), events[i].Message}, "-")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return events
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setCount(event v1.Event, count int) v1.Event {
0000000000000000000000000000000000000000;;		event.Count = int32(count)
0000000000000000000000000000000000000000;;		return event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateEvent(messagePrefix string, actualEvent *v1.Event, expectedEvent *v1.Event, t *testing.T) (*v1.Event, error) {
0000000000000000000000000000000000000000;;		recvEvent := *actualEvent
0000000000000000000000000000000000000000;;		expectCompression := expectedEvent.Count > 1
0000000000000000000000000000000000000000;;		t.Logf("%v - expectedEvent.Count is %d\n", messagePrefix, expectedEvent.Count)
0000000000000000000000000000000000000000;;		// Just check that the timestamp was set.
0000000000000000000000000000000000000000;;		if recvEvent.FirstTimestamp.IsZero() || recvEvent.LastTimestamp.IsZero() {
0000000000000000000000000000000000000000;;			t.Errorf("%v - timestamp wasn't set: %#v", messagePrefix, recvEvent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		actualFirstTimestamp := recvEvent.FirstTimestamp
0000000000000000000000000000000000000000;;		actualLastTimestamp := recvEvent.LastTimestamp
0000000000000000000000000000000000000000;;		if actualFirstTimestamp.Equal(actualLastTimestamp) {
0000000000000000000000000000000000000000;;			if expectCompression {
0000000000000000000000000000000000000000;;				t.Errorf("%v - FirstTimestamp (%q) and LastTimestamp (%q) must be different to indicate event compression happened, but were the same. Actual Event: %#v", messagePrefix, actualFirstTimestamp, actualLastTimestamp, recvEvent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if expectedEvent.Count == 1 {
0000000000000000000000000000000000000000;;				t.Errorf("%v - FirstTimestamp (%q) and LastTimestamp (%q) must be equal to indicate only one occurrence of the event, but were different. Actual Event: %#v", messagePrefix, actualFirstTimestamp, actualLastTimestamp, recvEvent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Temp clear time stamps for comparison because actual values don't matter for comparison
0000000000000000000000000000000000000000;;		recvEvent.FirstTimestamp = expectedEvent.FirstTimestamp
0000000000000000000000000000000000000000;;		recvEvent.LastTimestamp = expectedEvent.LastTimestamp
0000000000000000000000000000000000000000;;		// Check that name has the right prefix.
0000000000000000000000000000000000000000;;		if n, en := recvEvent.Name, expectedEvent.Name; !strings.HasPrefix(n, en) {
0000000000000000000000000000000000000000;;			t.Errorf("%v - Name '%v' does not contain prefix '%v'", messagePrefix, n, en)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		recvEvent.Name = expectedEvent.Name
0000000000000000000000000000000000000000;;		if e, a := expectedEvent, &recvEvent; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("%v - diff: %s", messagePrefix, diff.ObjectGoPrintDiff(e, a))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		recvEvent.FirstTimestamp = actualFirstTimestamp
0000000000000000000000000000000000000000;;		recvEvent.LastTimestamp = actualLastTimestamp
0000000000000000000000000000000000000000;;		return actualEvent, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestDefaultEventFilterFunc ensures that no events are filtered
0000000000000000000000000000000000000000;;	func TestDefaultEventFilterFunc(t *testing.T) {
0000000000000000000000000000000000000000;;		event := makeEvent("end-of-world", "it was fun", makeObjectReference("Pod", "pod1", "other"))
0000000000000000000000000000000000000000;;		if DefaultEventFilterFunc(&event) {
0000000000000000000000000000000000000000;;			t.Fatalf("DefaultEventFilterFunc should always return false")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestEventAggregatorByReasonFunc ensures that two events are aggregated if they vary only by event.message
0000000000000000000000000000000000000000;;	func TestEventAggregatorByReasonFunc(t *testing.T) {
0000000000000000000000000000000000000000;;		event1 := makeEvent("end-of-world", "it was fun", makeObjectReference("Pod", "pod1", "other"))
0000000000000000000000000000000000000000;;		event2 := makeEvent("end-of-world", "it was awful", makeObjectReference("Pod", "pod1", "other"))
0000000000000000000000000000000000000000;;		event3 := makeEvent("nevermind", "it was a bug", makeObjectReference("Pod", "pod1", "other"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aggKey1, localKey1 := EventAggregatorByReasonFunc(&event1)
0000000000000000000000000000000000000000;;		aggKey2, localKey2 := EventAggregatorByReasonFunc(&event2)
0000000000000000000000000000000000000000;;		aggKey3, _ := EventAggregatorByReasonFunc(&event3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if aggKey1 != aggKey2 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v equal %v", aggKey1, aggKey2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if localKey1 == localKey2 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v to not equal %v", aggKey1, aggKey3)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if aggKey1 == aggKey3 {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v to not equal %v", aggKey1, aggKey3)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestEventAggregatorByReasonMessageFunc validates the proper output for an aggregate message
0000000000000000000000000000000000000000;;	func TestEventAggregatorByReasonMessageFunc(t *testing.T) {
0000000000000000000000000000000000000000;;		expectedPrefix := "(combined from similar events): "
0000000000000000000000000000000000000000;;		event1 := makeEvent("end-of-world", "it was fun", makeObjectReference("Pod", "pod1", "other"))
0000000000000000000000000000000000000000;;		actual := EventAggregatorByReasonMessageFunc(&event1)
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(actual, expectedPrefix) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %v to begin with prefix %v", actual, expectedPrefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TestEventCorrelator validates proper counting, aggregation of events
0000000000000000000000000000000000000000;;	func TestEventCorrelator(t *testing.T) {
0000000000000000000000000000000000000000;;		firstEvent := makeEvent("first", "i am first", makeObjectReference("Pod", "my-pod", "my-ns"))
0000000000000000000000000000000000000000;;		duplicateEvent := makeEvent("duplicate", "me again", makeObjectReference("Pod", "my-pod", "my-ns"))
0000000000000000000000000000000000000000;;		uniqueEvent := makeEvent("unique", "snowflake", makeObjectReference("Pod", "my-pod", "my-ns"))
0000000000000000000000000000000000000000;;		similarEvent := makeEvent("similar", "similar message", makeObjectReference("Pod", "my-pod", "my-ns"))
0000000000000000000000000000000000000000;;		similarEvent.InvolvedObject.FieldPath = "spec.containers{container1}"
0000000000000000000000000000000000000000;;		aggregateEvent := makeEvent(similarEvent.Reason, EventAggregatorByReasonMessageFunc(&similarEvent), similarEvent.InvolvedObject)
0000000000000000000000000000000000000000;;		similarButDifferentContainerEvent := similarEvent
0000000000000000000000000000000000000000;;		similarButDifferentContainerEvent.InvolvedObject.FieldPath = "spec.containers{container2}"
0000000000000000000000000000000000000000;;		scenario := map[string]struct {
0000000000000000000000000000000000000000;;			previousEvents  []v1.Event
0000000000000000000000000000000000000000;;			newEvent        v1.Event
0000000000000000000000000000000000000000;;			expectedEvent   v1.Event
0000000000000000000000000000000000000000;;			intervalSeconds int
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"create-a-single-event": {
0000000000000000000000000000000000000000;;				previousEvents:  []v1.Event{},
0000000000000000000000000000000000000000;;				newEvent:        firstEvent,
0000000000000000000000000000000000000000;;				expectedEvent:   setCount(firstEvent, 1),
0000000000000000000000000000000000000000;;				intervalSeconds: 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"the-same-event-should-just-count": {
0000000000000000000000000000000000000000;;				previousEvents:  makeEvents(1, duplicateEvent),
0000000000000000000000000000000000000000;;				newEvent:        duplicateEvent,
0000000000000000000000000000000000000000;;				expectedEvent:   setCount(duplicateEvent, 2),
0000000000000000000000000000000000000000;;				intervalSeconds: 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"the-same-event-should-just-count-even-if-more-than-aggregate": {
0000000000000000000000000000000000000000;;				previousEvents:  makeEvents(defaultAggregateMaxEvents, duplicateEvent),
0000000000000000000000000000000000000000;;				newEvent:        duplicateEvent,
0000000000000000000000000000000000000000;;				expectedEvent:   setCount(duplicateEvent, defaultAggregateMaxEvents+1),
0000000000000000000000000000000000000000;;				intervalSeconds: 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"create-many-unique-events": {
0000000000000000000000000000000000000000;;				previousEvents:  makeUniqueEvents(30),
0000000000000000000000000000000000000000;;				newEvent:        uniqueEvent,
0000000000000000000000000000000000000000;;				expectedEvent:   setCount(uniqueEvent, 1),
0000000000000000000000000000000000000000;;				intervalSeconds: 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"similar-events-should-aggregate-event": {
0000000000000000000000000000000000000000;;				previousEvents:  makeSimilarEvents(defaultAggregateMaxEvents-1, similarEvent, similarEvent.Message),
0000000000000000000000000000000000000000;;				newEvent:        similarEvent,
0000000000000000000000000000000000000000;;				expectedEvent:   setCount(aggregateEvent, 1),
0000000000000000000000000000000000000000;;				intervalSeconds: 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"similar-events-many-times-should-count-the-aggregate": {
0000000000000000000000000000000000000000;;				previousEvents:  makeSimilarEvents(defaultAggregateMaxEvents, similarEvent, similarEvent.Message),
0000000000000000000000000000000000000000;;				newEvent:        similarEvent,
0000000000000000000000000000000000000000;;				expectedEvent:   setCount(aggregateEvent, 2),
0000000000000000000000000000000000000000;;				intervalSeconds: 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"events-from-different-containers-do-not-aggregate": {
0000000000000000000000000000000000000000;;				previousEvents:  makeEvents(1, similarButDifferentContainerEvent),
0000000000000000000000000000000000000000;;				newEvent:        similarEvent,
0000000000000000000000000000000000000000;;				expectedEvent:   setCount(similarEvent, 1),
0000000000000000000000000000000000000000;;				intervalSeconds: 5,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			"similar-events-whose-interval-is-greater-than-aggregate-interval-do-not-aggregate": {
0000000000000000000000000000000000000000;;				previousEvents:  makeSimilarEvents(defaultAggregateMaxEvents-1, similarEvent, similarEvent.Message),
0000000000000000000000000000000000000000;;				newEvent:        similarEvent,
0000000000000000000000000000000000000000;;				expectedEvent:   setCount(similarEvent, 1),
0000000000000000000000000000000000000000;;				intervalSeconds: defaultAggregateIntervalInSeconds,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for testScenario, testInput := range scenario {
0000000000000000000000000000000000000000;;			eventInterval := time.Duration(testInput.intervalSeconds) * time.Second
0000000000000000000000000000000000000000;;			clock := clock.IntervalClock{Time: time.Now(), Duration: eventInterval}
0000000000000000000000000000000000000000;;			correlator := NewEventCorrelator(&clock)
0000000000000000000000000000000000000000;;			for i := range testInput.previousEvents {
0000000000000000000000000000000000000000;;				event := testInput.previousEvents[i]
0000000000000000000000000000000000000000;;				now := metav1.NewTime(clock.Now())
0000000000000000000000000000000000000000;;				event.FirstTimestamp = now
0000000000000000000000000000000000000000;;				event.LastTimestamp = now
0000000000000000000000000000000000000000;;				result, err := correlator.EventCorrelate(&event)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("scenario %v: unexpected error playing back prevEvents %v", testScenario, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				correlator.UpdateState(result.Event)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// update the input to current clock value
0000000000000000000000000000000000000000;;			now := metav1.NewTime(clock.Now())
0000000000000000000000000000000000000000;;			testInput.newEvent.FirstTimestamp = now
0000000000000000000000000000000000000000;;			testInput.newEvent.LastTimestamp = now
0000000000000000000000000000000000000000;;			result, err := correlator.EventCorrelate(&testInput.newEvent)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("scenario %v: unexpected error correlating input event %v", testScenario, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err = validateEvent(testScenario, result.Event, &testInput.expectedEvent, t)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("scenario %v: unexpected error validating result %v", testScenario, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
