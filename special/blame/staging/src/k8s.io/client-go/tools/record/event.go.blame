0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/record/event.go[staging/src/k8s.io/client-go/1.4/tools/record/event.go][staging/src/k8s.io/client-go/tools/record/event.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package record
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/pkg/api/v1/ref"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxTriesPerEvent = 12
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultSleepDuration = 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxQueuedEvents = 1000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventSink knows how to store events (client.Client implements it.)
0000000000000000000000000000000000000000;;	// EventSink must respect the namespace that will be embedded in 'event'.
0000000000000000000000000000000000000000;;	// It is assumed that EventSink will return the same sorts of errors as
0000000000000000000000000000000000000000;;	// pkg/client's REST client.
0000000000000000000000000000000000000000;;	type EventSink interface {
0000000000000000000000000000000000000000;;		Create(event *v1.Event) (*v1.Event, error)
0000000000000000000000000000000000000000;;		Update(event *v1.Event) (*v1.Event, error)
0000000000000000000000000000000000000000;;		Patch(oldEvent *v1.Event, data []byte) (*v1.Event, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventRecorder knows how to record events on behalf of an EventSource.
0000000000000000000000000000000000000000;;	type EventRecorder interface {
0000000000000000000000000000000000000000;;		// Event constructs an event from the given information and puts it in the queue for sending.
0000000000000000000000000000000000000000;;		// 'object' is the object this event is about. Event will make a reference-- or you may also
0000000000000000000000000000000000000000;;		// pass a reference to the object directly.
0000000000000000000000000000000000000000;;		// 'type' of this event, and can be one of Normal, Warning. New types could be added in future
0000000000000000000000000000000000000000;;		// 'reason' is the reason this event is generated. 'reason' should be short and unique; it
0000000000000000000000000000000000000000;;		// should be in UpperCamelCase format (starting with a capital letter). "reason" will be used
0000000000000000000000000000000000000000;;		// to automate handling of events, so imagine people writing switch statements to handle them.
0000000000000000000000000000000000000000;;		// You want to make that easy.
0000000000000000000000000000000000000000;;		// 'message' is intended to be human readable.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The resulting event will be created in the same namespace as the reference object.
0000000000000000000000000000000000000000;;		Event(object runtime.Object, eventtype, reason, message string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Eventf is just like Event, but with Sprintf for the message field.
0000000000000000000000000000000000000000;;		Eventf(object runtime.Object, eventtype, reason, messageFmt string, args ...interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PastEventf is just like Eventf, but with an option to specify the event's 'timestamp' field.
0000000000000000000000000000000000000000;;		PastEventf(object runtime.Object, timestamp metav1.Time, eventtype, reason, messageFmt string, args ...interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventBroadcaster knows how to receive events and send them to any EventSink, watcher, or log.
0000000000000000000000000000000000000000;;	type EventBroadcaster interface {
0000000000000000000000000000000000000000;;		// StartEventWatcher starts sending events received from this EventBroadcaster to the given
0000000000000000000000000000000000000000;;		// event handler function. The return value can be ignored or used to stop recording, if
0000000000000000000000000000000000000000;;		// desired.
0000000000000000000000000000000000000000;;		StartEventWatcher(eventHandler func(*v1.Event)) watch.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StartRecordingToSink starts sending events received from this EventBroadcaster to the given
0000000000000000000000000000000000000000;;		// sink. The return value can be ignored or used to stop recording, if desired.
0000000000000000000000000000000000000000;;		StartRecordingToSink(sink EventSink) watch.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// StartLogging starts sending events received from this EventBroadcaster to the given logging
0000000000000000000000000000000000000000;;		// function. The return value can be ignored or used to stop recording, if desired.
0000000000000000000000000000000000000000;;		StartLogging(logf func(format string, args ...interface{})) watch.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NewRecorder returns an EventRecorder that can be used to send events to this EventBroadcaster
0000000000000000000000000000000000000000;;		// with the event source set to the given event source.
0000000000000000000000000000000000000000;;		NewRecorder(scheme *runtime.Scheme, source v1.EventSource) EventRecorder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a new event broadcaster.
0000000000000000000000000000000000000000;;	func NewBroadcaster() EventBroadcaster {
0000000000000000000000000000000000000000;;		return &eventBroadcasterImpl{watch.NewBroadcaster(maxQueuedEvents, watch.DropIfChannelFull), defaultSleepDuration}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewBroadcasterForTests(sleepDuration time.Duration) EventBroadcaster {
0000000000000000000000000000000000000000;;		return &eventBroadcasterImpl{watch.NewBroadcaster(maxQueuedEvents, watch.DropIfChannelFull), sleepDuration}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type eventBroadcasterImpl struct {
0000000000000000000000000000000000000000;;		*watch.Broadcaster
0000000000000000000000000000000000000000;;		sleepDuration time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartRecordingToSink starts sending events received from the specified eventBroadcaster to the given sink.
0000000000000000000000000000000000000000;;	// The return value can be ignored or used to stop recording, if desired.
0000000000000000000000000000000000000000;;	// TODO: make me an object with parameterizable queue length and retry interval
0000000000000000000000000000000000000000;;	func (eventBroadcaster *eventBroadcasterImpl) StartRecordingToSink(sink EventSink) watch.Interface {
0000000000000000000000000000000000000000;;		// The default math/rand package functions aren't thread safe, so create a
0000000000000000000000000000000000000000;;		// new Rand object for each StartRecording call.
0000000000000000000000000000000000000000;;		randGen := rand.New(rand.NewSource(time.Now().UnixNano()))
0000000000000000000000000000000000000000;;		eventCorrelator := NewEventCorrelator(clock.RealClock{})
0000000000000000000000000000000000000000;;		return eventBroadcaster.StartEventWatcher(
0000000000000000000000000000000000000000;;			func(event *v1.Event) {
0000000000000000000000000000000000000000;;				recordToSink(sink, event, eventCorrelator, randGen, eventBroadcaster.sleepDuration)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func recordToSink(sink EventSink, event *v1.Event, eventCorrelator *EventCorrelator, randGen *rand.Rand, sleepDuration time.Duration) {
0000000000000000000000000000000000000000;;		// Make a copy before modification, because there could be multiple listeners.
0000000000000000000000000000000000000000;;		// Events are safe to copy like this.
0000000000000000000000000000000000000000;;		eventCopy := *event
0000000000000000000000000000000000000000;;		event = &eventCopy
0000000000000000000000000000000000000000;;		result, err := eventCorrelator.EventCorrelate(event)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result.Skip {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tries := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if recordEvent(sink, result.Event, result.Patch, result.Event.Count > 1, eventCorrelator) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tries++
0000000000000000000000000000000000000000;;			if tries >= maxTriesPerEvent {
0000000000000000000000000000000000000000;;				glog.Errorf("Unable to write event '%#v' (retry limit exceeded!)", event)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Randomize the first sleep so that various clients won't all be
0000000000000000000000000000000000000000;;			// synced up if the master goes down.
0000000000000000000000000000000000000000;;			if tries == 1 {
0000000000000000000000000000000000000000;;				time.Sleep(time.Duration(float64(sleepDuration) * randGen.Float64()))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				time.Sleep(sleepDuration)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isKeyNotFoundError(err error) bool {
0000000000000000000000000000000000000000;;		statusErr, _ := err.(*errors.StatusError)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if statusErr != nil && statusErr.Status().Code == http.StatusNotFound {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recordEvent attempts to write event to a sink. It returns true if the event
0000000000000000000000000000000000000000;;	// was successfully recorded or discarded, false if it should be retried.
0000000000000000000000000000000000000000;;	// If updateExistingEvent is false, it creates a new event, otherwise it updates
0000000000000000000000000000000000000000;;	// existing event.
0000000000000000000000000000000000000000;;	func recordEvent(sink EventSink, event *v1.Event, patch []byte, updateExistingEvent bool, eventCorrelator *EventCorrelator) bool {
0000000000000000000000000000000000000000;;		var newEvent *v1.Event
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if updateExistingEvent {
0000000000000000000000000000000000000000;;			newEvent, err = sink.Patch(event, patch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Update can fail because the event may have been removed and it no longer exists.
0000000000000000000000000000000000000000;;		if !updateExistingEvent || (updateExistingEvent && isKeyNotFoundError(err)) {
0000000000000000000000000000000000000000;;			// Making sure that ResourceVersion is empty on creation
0000000000000000000000000000000000000000;;			event.ResourceVersion = ""
0000000000000000000000000000000000000000;;			newEvent, err = sink.Create(event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// we need to update our event correlator with the server returned state to handle name/resourceversion
0000000000000000000000000000000000000000;;			eventCorrelator.UpdateState(newEvent)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we can't contact the server, then hold everything while we keep trying.
0000000000000000000000000000000000000000;;		// Otherwise, something about the event is malformed and we should abandon it.
0000000000000000000000000000000000000000;;		switch err.(type) {
0000000000000000000000000000000000000000;;		case *restclient.RequestConstructionError:
0000000000000000000000000000000000000000;;			// We will construct the request the same next time, so don't keep trying.
0000000000000000000000000000000000000000;;			glog.Errorf("Unable to construct event '%#v': '%v' (will not retry!)", event, err)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case *errors.StatusError:
0000000000000000000000000000000000000000;;			if errors.IsAlreadyExists(err) {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("Server rejected event '%#v': '%v' (will not retry!)", event, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.Errorf("Server rejected event '%#v': '%v' (will not retry!)", event, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case *errors.UnexpectedObjectError:
0000000000000000000000000000000000000000;;			// We don't expect this; it implies the server's response didn't match a
0000000000000000000000000000000000000000;;			// known pattern. Go ahead and retry.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// This case includes actual http transport errors. Go ahead and retry.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Errorf("Unable to write event: '%v' (may retry after sleeping)", err)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartLogging starts sending events received from this EventBroadcaster to the given logging function.
0000000000000000000000000000000000000000;;	// The return value can be ignored or used to stop recording, if desired.
0000000000000000000000000000000000000000;;	func (eventBroadcaster *eventBroadcasterImpl) StartLogging(logf func(format string, args ...interface{})) watch.Interface {
0000000000000000000000000000000000000000;;		return eventBroadcaster.StartEventWatcher(
0000000000000000000000000000000000000000;;			func(e *v1.Event) {
0000000000000000000000000000000000000000;;				logf("Event(%#v): type: '%v' reason: '%v' %v", e.InvolvedObject, e.Type, e.Reason, e.Message)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StartEventWatcher starts sending events received from this EventBroadcaster to the given event handler function.
0000000000000000000000000000000000000000;;	// The return value can be ignored or used to stop recording, if desired.
0000000000000000000000000000000000000000;;	func (eventBroadcaster *eventBroadcasterImpl) StartEventWatcher(eventHandler func(*v1.Event)) watch.Interface {
0000000000000000000000000000000000000000;;		watcher := eventBroadcaster.Watch()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				watchEvent, open := <-watcher.ResultChan()
0000000000000000000000000000000000000000;;				if !open {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				event, ok := watchEvent.Object.(*v1.Event)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					// This is all local, so there's no reason this should
0000000000000000000000000000000000000000;;					// ever happen.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				eventHandler(event)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return watcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRecorder returns an EventRecorder that records events with the given event source.
0000000000000000000000000000000000000000;;	func (eventBroadcaster *eventBroadcasterImpl) NewRecorder(scheme *runtime.Scheme, source v1.EventSource) EventRecorder {
0000000000000000000000000000000000000000;;		return &recorderImpl{scheme, source, eventBroadcaster.Broadcaster, clock.RealClock{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type recorderImpl struct {
0000000000000000000000000000000000000000;;		scheme *runtime.Scheme
0000000000000000000000000000000000000000;;		source v1.EventSource
0000000000000000000000000000000000000000;;		*watch.Broadcaster
0000000000000000000000000000000000000000;;		clock clock.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (recorder *recorderImpl) generateEvent(object runtime.Object, timestamp metav1.Time, eventtype, reason, message string) {
0000000000000000000000000000000000000000;;		ref, err := ref.GetReference(recorder.scheme, object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Could not construct reference to: '%#v' due to: '%v'. Will not report event: '%v' '%v' '%v'", object, err, eventtype, reason, message)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !validateEventType(eventtype) {
0000000000000000000000000000000000000000;;			glog.Errorf("Unsupported event type: '%v'", eventtype)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		event := recorder.makeEvent(ref, eventtype, reason, message)
0000000000000000000000000000000000000000;;		event.Source = recorder.source
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// NOTE: events should be a non-blocking operation
0000000000000000000000000000000000000000;;			defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;			recorder.Action(watch.Added, event)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateEventType(eventtype string) bool {
0000000000000000000000000000000000000000;;		switch eventtype {
0000000000000000000000000000000000000000;;		case v1.EventTypeNormal, v1.EventTypeWarning:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (recorder *recorderImpl) Event(object runtime.Object, eventtype, reason, message string) {
0000000000000000000000000000000000000000;;		recorder.generateEvent(object, metav1.Now(), eventtype, reason, message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (recorder *recorderImpl) Eventf(object runtime.Object, eventtype, reason, messageFmt string, args ...interface{}) {
0000000000000000000000000000000000000000;;		recorder.Event(object, eventtype, reason, fmt.Sprintf(messageFmt, args...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (recorder *recorderImpl) PastEventf(object runtime.Object, timestamp metav1.Time, eventtype, reason, messageFmt string, args ...interface{}) {
0000000000000000000000000000000000000000;;		recorder.generateEvent(object, timestamp, eventtype, reason, fmt.Sprintf(messageFmt, args...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (recorder *recorderImpl) makeEvent(ref *v1.ObjectReference, eventtype, reason, message string) *v1.Event {
0000000000000000000000000000000000000000;;		t := metav1.Time{Time: recorder.clock.Now()}
0000000000000000000000000000000000000000;;		namespace := ref.Namespace
0000000000000000000000000000000000000000;;		if namespace == "" {
0000000000000000000000000000000000000000;;			namespace = metav1.NamespaceDefault
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &v1.Event{
0000000000000000000000000000000000000000;;			ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;				Name:      fmt.Sprintf("%v.%x", ref.Name, t.UnixNano()),
0000000000000000000000000000000000000000;;				Namespace: namespace,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			InvolvedObject: *ref,
0000000000000000000000000000000000000000;;			Reason:         reason,
0000000000000000000000000000000000000000;;			Message:        message,
0000000000000000000000000000000000000000;;			FirstTimestamp: t,
0000000000000000000000000000000000000000;;			LastTimestamp:  t,
0000000000000000000000000000000000000000;;			Count:          1,
0000000000000000000000000000000000000000;;			Type:           eventtype,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
