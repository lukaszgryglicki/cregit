0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/auth/clientauth.go[staging/src/k8s.io/client-go/1.4/tools/auth/clientauth.go][staging/src/k8s.io/client-go/tools/auth/clientauth.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package auth defines a file format for holding authentication
0000000000000000000000000000000000000000;;	information needed by clients of Kubernetes.  Typically,
0000000000000000000000000000000000000000;;	a Kubernetes cluster will put auth info for the admin in a known
0000000000000000000000000000000000000000;;	location when it is created, and will (soon) put it in a known
0000000000000000000000000000000000000000;;	location within a Container's file tree for Containers that
0000000000000000000000000000000000000000;;	need access to the Kubernetes API.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Having a defined format allows:
0000000000000000000000000000000000000000;;	  - clients to be implmented in multiple languages
0000000000000000000000000000000000000000;;	  - applications which link clients to be portable across
0000000000000000000000000000000000000000;;	    clusters with different authentication styles (e.g.
0000000000000000000000000000000000000000;;	    some may use SSL Client certs, others may not, etc)
0000000000000000000000000000000000000000;;	  - when the format changes, applications only
0000000000000000000000000000000000000000;;	    need to update this code.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The file format is json, marshalled from a struct authcfg.Info.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Clinet libraries in other languages should use the same format.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It is not intended to store general preferences, such as default
0000000000000000000000000000000000000000;;	namespace, output options, etc.  CLIs (such as kubectl) and UIs should
0000000000000000000000000000000000000000;;	develop their own format and may wish to inline the authcfg.Info type.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The authcfg.Info is just a file format.  It is distinct from
0000000000000000000000000000000000000000;;	client.Config which holds options for creating a client.Client.
0000000000000000000000000000000000000000;;	Helper functions are provided in this package to fill in a
0000000000000000000000000000000000000000;;	client.Client from an authcfg.Info.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    import (
0000000000000000000000000000000000000000;;	        "pkg/client"
0000000000000000000000000000000000000000;;	        "pkg/client/auth"
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    info, err := auth.LoadFromFile(filename)
0000000000000000000000000000000000000000;;	    if err != nil {
0000000000000000000000000000000000000000;;	      // handle error
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	    clientConfig = client.Config{}
0000000000000000000000000000000000000000;;	    clientConfig.Host = "example.com:4901"
0000000000000000000000000000000000000000;;	    clientConfig = info.MergeWithConfig()
0000000000000000000000000000000000000000;;	    client := client.New(clientConfig)
0000000000000000000000000000000000000000;;	    client.Pods(ns).List()
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package auth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: need a way to rotate Tokens.  Therefore, need a way for client object to be reset when the authcfg is updated.
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Info holds Kubernetes API authorization config.  It is intended
0000000000000000000000000000000000000000;;	// to be read/written from a file as a JSON object.
0000000000000000000000000000000000000000;;	type Info struct {
0000000000000000000000000000000000000000;;		User        string
0000000000000000000000000000000000000000;;		Password    string
0000000000000000000000000000000000000000;;		CAFile      string
0000000000000000000000000000000000000000;;		CertFile    string
0000000000000000000000000000000000000000;;		KeyFile     string
0000000000000000000000000000000000000000;;		BearerToken string
0000000000000000000000000000000000000000;;		Insecure    *bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadFromFile parses an Info object from a file path.
0000000000000000000000000000000000000000;;	// If the file does not exist, then os.IsNotExist(err) == true
0000000000000000000000000000000000000000;;	func LoadFromFile(path string) (*Info, error) {
0000000000000000000000000000000000000000;;		var info Info
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(data, &info)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &info, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeWithConfig returns a copy of a client.Config with values from the Info.
0000000000000000000000000000000000000000;;	// The fields of client.Config with a corresponding field in the Info are set
0000000000000000000000000000000000000000;;	// with the value from the Info.
0000000000000000000000000000000000000000;;	func (info Info) MergeWithConfig(c restclient.Config) (restclient.Config, error) {
0000000000000000000000000000000000000000;;		var config restclient.Config = c
0000000000000000000000000000000000000000;;		config.Username = info.User
0000000000000000000000000000000000000000;;		config.Password = info.Password
0000000000000000000000000000000000000000;;		config.CAFile = info.CAFile
0000000000000000000000000000000000000000;;		config.CertFile = info.CertFile
0000000000000000000000000000000000000000;;		config.KeyFile = info.KeyFile
0000000000000000000000000000000000000000;;		config.BearerToken = info.BearerToken
0000000000000000000000000000000000000000;;		if info.Insecure != nil {
0000000000000000000000000000000000000000;;			config.Insecure = *info.Insecure
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (info Info) Complete() bool {
0000000000000000000000000000000000000000;;		return len(info.User) > 0 ||
0000000000000000000000000000000000000000;;			len(info.CertFile) > 0 ||
0000000000000000000000000000000000000000;;			len(info.BearerToken) > 0
0000000000000000000000000000000000000000;;	}
