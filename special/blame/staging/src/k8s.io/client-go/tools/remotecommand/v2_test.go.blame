0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
edbadd9258d8cb5de86636f529b0e84620db633f;pkg/client/unversioned/remotecommand/v2_test.go[pkg/client/unversioned/remotecommand/v2_test.go][staging/src/k8s.io/client-go/tools/remotecommand/v2_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remotecommand
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeReader struct {
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *fakeReader) Read([]byte) (int, error) { return 0, r.err }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeWriter struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (*fakeWriter) Write([]byte) (int, error) { return 0, nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeStreamCreator struct {
0000000000000000000000000000000000000000;;		created map[string]bool
0000000000000000000000000000000000000000;;		errors  map[string]error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ streamCreator = &fakeStreamCreator{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeStreamCreator) CreateStream(headers http.Header) (httpstream.Stream, error) {
0000000000000000000000000000000000000000;;		streamType := headers.Get(v1.StreamType)
0000000000000000000000000000000000000000;;		f.created[streamType] = true
0000000000000000000000000000000000000000;;		return nil, f.errors[streamType]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestV2CreateStreams(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name        string
0000000000000000000000000000000000000000;;			stdin       bool
0000000000000000000000000000000000000000;;			stdinError  error
0000000000000000000000000000000000000000;;			stdout      bool
0000000000000000000000000000000000000000;;			stdoutError error
0000000000000000000000000000000000000000;;			stderr      bool
0000000000000000000000000000000000000000;;			stderrError error
0000000000000000000000000000000000000000;;			errorError  error
0000000000000000000000000000000000000000;;			tty         bool
0000000000000000000000000000000000000000;;			expectError bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "stdin error",
0000000000000000000000000000000000000000;;				stdin:       true,
0000000000000000000000000000000000000000;;				stdinError:  errors.New("stdin error"),
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "stdout error",
0000000000000000000000000000000000000000;;				stdout:      true,
0000000000000000000000000000000000000000;;				stdoutError: errors.New("stdout error"),
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "stderr error",
0000000000000000000000000000000000000000;;				stderr:      true,
0000000000000000000000000000000000000000;;				stderrError: errors.New("stderr error"),
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "error stream error",
0000000000000000000000000000000000000000;;				stdin:       true,
0000000000000000000000000000000000000000;;				stdout:      true,
0000000000000000000000000000000000000000;;				stderr:      true,
0000000000000000000000000000000000000000;;				errorError:  errors.New("error stream error"),
0000000000000000000000000000000000000000;;				expectError: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "no errors",
0000000000000000000000000000000000000000;;				stdin:       true,
0000000000000000000000000000000000000000;;				stdout:      true,
0000000000000000000000000000000000000000;;				stderr:      true,
0000000000000000000000000000000000000000;;				expectError: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:        "no errors, stderr & tty set, don't expect stderr",
0000000000000000000000000000000000000000;;				stdin:       true,
0000000000000000000000000000000000000000;;				stdout:      true,
0000000000000000000000000000000000000000;;				stderr:      true,
0000000000000000000000000000000000000000;;				tty:         true,
0000000000000000000000000000000000000000;;				expectError: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			conn := &fakeStreamCreator{
0000000000000000000000000000000000000000;;				created: make(map[string]bool),
0000000000000000000000000000000000000000;;				errors: map[string]error{
0000000000000000000000000000000000000000;;					v1.StreamTypeStdin:  test.stdinError,
0000000000000000000000000000000000000000;;					v1.StreamTypeStdout: test.stdoutError,
0000000000000000000000000000000000000000;;					v1.StreamTypeStderr: test.stderrError,
0000000000000000000000000000000000000000;;					v1.StreamTypeError:  test.errorError,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			opts := StreamOptions{Tty: test.tty}
0000000000000000000000000000000000000000;;			if test.stdin {
0000000000000000000000000000000000000000;;				opts.Stdin = &fakeReader{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.stdout {
0000000000000000000000000000000000000000;;				opts.Stdout = &fakeWriter{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.stderr {
0000000000000000000000000000000000000000;;				opts.Stderr = &fakeWriter{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			h := newStreamProtocolV2(opts).(*streamProtocolV2)
0000000000000000000000000000000000000000;;			err := h.createStreams(conn)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectError {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected error", test.name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := test.stdinError, err; test.stdinError != nil && e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v, got %v", test.name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := test.stdoutError, err; test.stdoutError != nil && e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v, got %v", test.name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := test.stderrError, err; test.stderrError != nil && e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v, got %v", test.name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := test.errorError, err; test.errorError != nil && e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %v, got %v", test.name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !test.expectError && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.stdin && !conn.created[v1.StreamTypeStdin] {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected stdin stream", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.stdout && !conn.created[v1.StreamTypeStdout] {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected stdout stream", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.stderr {
0000000000000000000000000000000000000000;;				if test.tty && conn.created[v1.StreamTypeStderr] {
0000000000000000000000000000000000000000;;					t.Errorf("%s: unexpected stderr stream because tty is set", test.name)
0000000000000000000000000000000000000000;;				} else if !test.tty && !conn.created[v1.StreamTypeStderr] {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected stderr stream", test.name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !conn.created[v1.StreamTypeError] {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected error stream", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestV2ErrorStreamReading(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name          string
0000000000000000000000000000000000000000;;			stream        io.Reader
0000000000000000000000000000000000000000;;			expectedError error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "error reading from stream",
0000000000000000000000000000000000000000;;				stream:        &fakeReader{errors.New("foo")},
0000000000000000000000000000000000000000;;				expectedError: errors.New("error reading from error stream: foo"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:          "stream returns an error",
0000000000000000000000000000000000000000;;				stream:        strings.NewReader("some error"),
0000000000000000000000000000000000000000;;				expectedError: errors.New("error executing remote command: some error"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			h := newStreamProtocolV2(StreamOptions{}).(*streamProtocolV2)
0000000000000000000000000000000000000000;;			h.errorStream = test.stream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ch := watchErrorStream(h.errorStream, &errorDecoderV2{})
0000000000000000000000000000000000000000;;			if ch == nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected nil channel", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case err = <-ch:
0000000000000000000000000000000000000000;;			case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;				t.Fatalf("%s: timed out", test.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectedError != nil {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected an error", test.name)
0000000000000000000000000000000000000000;;				} else if e, a := test.expectedError, err; e.Error() != a.Error() {
0000000000000000000000000000000000000000;;					t.Errorf("%s: expected %q, got %q", test.name, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectedError == nil && err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected error: %v", test.name, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
