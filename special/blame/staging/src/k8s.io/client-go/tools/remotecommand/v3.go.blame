0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
edbadd9258d8cb5de86636f529b0e84620db633f;pkg/client/unversioned/remotecommand/v3.go[pkg/client/unversioned/remotecommand/v3.go][staging/src/k8s.io/client-go/tools/remotecommand/v3.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remotecommand
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamProtocolV3 implements version 3 of the streaming protocol for attach
0000000000000000000000000000000000000000;;	// and exec. This version adds support for resizing the container's terminal.
0000000000000000000000000000000000000000;;	type streamProtocolV3 struct {
0000000000000000000000000000000000000000;;		*streamProtocolV2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resizeStream io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ streamProtocolHandler = &streamProtocolV3{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStreamProtocolV3(options StreamOptions) streamProtocolHandler {
0000000000000000000000000000000000000000;;		return &streamProtocolV3{
0000000000000000000000000000000000000000;;			streamProtocolV2: newStreamProtocolV2(options).(*streamProtocolV2),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV3) createStreams(conn streamCreator) error {
0000000000000000000000000000000000000000;;		// set up the streams from v2
0000000000000000000000000000000000000000;;		if err := p.streamProtocolV2.createStreams(conn); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set up resize stream
0000000000000000000000000000000000000000;;		if p.Tty {
0000000000000000000000000000000000000000;;			headers := http.Header{}
0000000000000000000000000000000000000000;;			headers.Set(v1.StreamType, v1.StreamTypeResize)
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			p.resizeStream, err = conn.CreateStream(headers)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV3) handleResizes() {
0000000000000000000000000000000000000000;;		if p.resizeStream == nil || p.TerminalSizeQueue == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			encoder := json.NewEncoder(p.resizeStream)
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				size := p.TerminalSizeQueue.Next()
0000000000000000000000000000000000000000;;				if size == nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := encoder.Encode(&size); err != nil {
0000000000000000000000000000000000000000;;					runtime.HandleError(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV3) stream(conn streamCreator) error {
0000000000000000000000000000000000000000;;		if err := p.createStreams(conn); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now that all the streams have been created, proceed with reading & copying
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorChan := watchErrorStream(p.errorStream, &errorDecoderV3{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.handleResizes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.copyStdin()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		p.copyStdout(&wg)
0000000000000000000000000000000000000000;;		p.copyStderr(&wg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we're waiting for stdout/stderr to finish copying
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// waits for errorStream to finish reading with an error or nil
0000000000000000000000000000000000000000;;		return <-errorChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errorDecoderV3 struct {
0000000000000000000000000000000000000000;;		errorDecoderV2
0000000000000000000000000000000000000000;;	}
