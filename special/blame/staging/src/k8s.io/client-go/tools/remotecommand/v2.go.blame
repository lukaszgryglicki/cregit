0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f08f44425b522b3c3bc4b8976fb736e0b712fe75;pkg/client/unversioned/remotecommand/v2.go[pkg/client/unversioned/remotecommand/v2.go][staging/src/k8s.io/client-go/tools/remotecommand/v2.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remotecommand
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamProtocolV2 implements version 2 of the streaming protocol for attach
0000000000000000000000000000000000000000;;	// and exec. The original streaming protocol was metav1. As a result, this
0000000000000000000000000000000000000000;;	// version is referred to as version 2, even though it is the first actual
0000000000000000000000000000000000000000;;	// numbered version.
0000000000000000000000000000000000000000;;	type streamProtocolV2 struct {
0000000000000000000000000000000000000000;;		StreamOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorStream  io.Reader
0000000000000000000000000000000000000000;;		remoteStdin  io.ReadWriteCloser
0000000000000000000000000000000000000000;;		remoteStdout io.Reader
0000000000000000000000000000000000000000;;		remoteStderr io.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ streamProtocolHandler = &streamProtocolV2{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStreamProtocolV2(options StreamOptions) streamProtocolHandler {
0000000000000000000000000000000000000000;;		return &streamProtocolV2{
0000000000000000000000000000000000000000;;			StreamOptions: options,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV2) createStreams(conn streamCreator) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		headers := http.Header{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set up error stream
0000000000000000000000000000000000000000;;		headers.Set(v1.StreamType, v1.StreamTypeError)
0000000000000000000000000000000000000000;;		p.errorStream, err = conn.CreateStream(headers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set up stdin stream
0000000000000000000000000000000000000000;;		if p.Stdin != nil {
0000000000000000000000000000000000000000;;			headers.Set(v1.StreamType, v1.StreamTypeStdin)
0000000000000000000000000000000000000000;;			p.remoteStdin, err = conn.CreateStream(headers)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set up stdout stream
0000000000000000000000000000000000000000;;		if p.Stdout != nil {
0000000000000000000000000000000000000000;;			headers.Set(v1.StreamType, v1.StreamTypeStdout)
0000000000000000000000000000000000000000;;			p.remoteStdout, err = conn.CreateStream(headers)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set up stderr stream
0000000000000000000000000000000000000000;;		if p.Stderr != nil && !p.Tty {
0000000000000000000000000000000000000000;;			headers.Set(v1.StreamType, v1.StreamTypeStderr)
0000000000000000000000000000000000000000;;			p.remoteStderr, err = conn.CreateStream(headers)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV2) copyStdin() {
0000000000000000000000000000000000000000;;		if p.Stdin != nil {
0000000000000000000000000000000000000000;;			var once sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// copy from client's stdin to container's stdin
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if p.stdin is noninteractive, p.g. `echo abc | kubectl exec -i <pod> -- cat`, make sure
0000000000000000000000000000000000000000;;				// we close remoteStdin as soon as the copy from p.stdin to remoteStdin finishes. Otherwise
0000000000000000000000000000000000000000;;				// the executed command will remain running.
0000000000000000000000000000000000000000;;				defer once.Do(func() { p.remoteStdin.Close() })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err := io.Copy(p.remoteStdin, p.Stdin); err != nil {
0000000000000000000000000000000000000000;;					runtime.HandleError(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// read from remoteStdin until the stream is closed. this is essential to
0000000000000000000000000000000000000000;;			// be able to exit interactive sessions cleanly and not leak goroutines or
0000000000000000000000000000000000000000;;			// hang the client's terminal.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// TODO we aren't using go-dockerclient any more; revisit this to determine if it's still
0000000000000000000000000000000000000000;;			// required by engine-api.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// go-dockerclient's current hijack implementation
0000000000000000000000000000000000000000;;			// (https://github.com/fsouza/go-dockerclient/blob/89f3d56d93788dfe85f864a44f85d9738fca0670/client.go#L564)
0000000000000000000000000000000000000000;;			// waits for all three streams (stdin/stdout/stderr) to finish copying
0000000000000000000000000000000000000000;;			// before returning. When hijack finishes copying stdout/stderr, it calls
0000000000000000000000000000000000000000;;			// Close() on its side of remoteStdin, which allows this copy to complete.
0000000000000000000000000000000000000000;;			// When that happens, we must Close() on our side of remoteStdin, to
0000000000000000000000000000000000000000;;			// allow the copy in hijack to complete, and hijack to return.
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;				defer once.Do(func() { p.remoteStdin.Close() })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// this "copy" doesn't actually read anything - it's just here to wait for
0000000000000000000000000000000000000000;;				// the server to close remoteStdin.
0000000000000000000000000000000000000000;;				if _, err := io.Copy(ioutil.Discard, p.remoteStdin); err != nil {
0000000000000000000000000000000000000000;;					runtime.HandleError(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV2) copyStdout(wg *sync.WaitGroup) {
0000000000000000000000000000000000000000;;		if p.Stdout == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;			defer wg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := io.Copy(p.Stdout, p.remoteStdout); err != nil {
0000000000000000000000000000000000000000;;				runtime.HandleError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV2) copyStderr(wg *sync.WaitGroup) {
0000000000000000000000000000000000000000;;		if p.Stderr == nil || p.Tty {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer runtime.HandleCrash()
0000000000000000000000000000000000000000;;			defer wg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := io.Copy(p.Stderr, p.remoteStderr); err != nil {
0000000000000000000000000000000000000000;;				runtime.HandleError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV2) stream(conn streamCreator) error {
0000000000000000000000000000000000000000;;		if err := p.createStreams(conn); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now that all the streams have been created, proceed with reading & copying
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorChan := watchErrorStream(p.errorStream, &errorDecoderV2{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.copyStdin()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		p.copyStdout(&wg)
0000000000000000000000000000000000000000;;		p.copyStderr(&wg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we're waiting for stdout/stderr to finish copying
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// waits for errorStream to finish reading with an error or nil
0000000000000000000000000000000000000000;;		return <-errorChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errorDecoderV2 interprets the error channel data as plain text.
0000000000000000000000000000000000000000;;	type errorDecoderV2 struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *errorDecoderV2) decode(message []byte) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("error executing remote command: %s", message)
0000000000000000000000000000000000000000;;	}
