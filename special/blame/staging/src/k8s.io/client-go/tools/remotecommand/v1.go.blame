0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
f08f44425b522b3c3bc4b8976fb736e0b712fe75;pkg/client/unversioned/remotecommand/v1.go[pkg/client/unversioned/remotecommand/v1.go][staging/src/k8s.io/client-go/tools/remotecommand/v1.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remotecommand
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamProtocolV1 implements the first version of the streaming exec & attach
0000000000000000000000000000000000000000;;	// protocol. This version has some bugs, such as not being able to detect when
0000000000000000000000000000000000000000;;	// non-interactive stdin data has ended. See http://issues.k8s.io/13394 and
0000000000000000000000000000000000000000;;	// http://issues.k8s.io/13395 for more details.
0000000000000000000000000000000000000000;;	type streamProtocolV1 struct {
0000000000000000000000000000000000000000;;		StreamOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorStream  httpstream.Stream
0000000000000000000000000000000000000000;;		remoteStdin  httpstream.Stream
0000000000000000000000000000000000000000;;		remoteStdout httpstream.Stream
0000000000000000000000000000000000000000;;		remoteStderr httpstream.Stream
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ streamProtocolHandler = &streamProtocolV1{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStreamProtocolV1(options StreamOptions) streamProtocolHandler {
0000000000000000000000000000000000000000;;		return &streamProtocolV1{
0000000000000000000000000000000000000000;;			StreamOptions: options,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV1) stream(conn streamCreator) error {
0000000000000000000000000000000000000000;;		doneChan := make(chan struct{}, 2)
0000000000000000000000000000000000000000;;		errorChan := make(chan error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cp := func(s string, dst io.Writer, src io.Reader) {
0000000000000000000000000000000000000000;;			glog.V(6).Infof("Copying %s", s)
0000000000000000000000000000000000000000;;			defer glog.V(6).Infof("Done copying %s", s)
0000000000000000000000000000000000000000;;			if _, err := io.Copy(dst, src); err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;				glog.Errorf("Error copying %s: %v", s, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s == v1.StreamTypeStdout || s == v1.StreamTypeStderr {
0000000000000000000000000000000000000000;;				doneChan <- struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set up all the streams first
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		headers := http.Header{}
0000000000000000000000000000000000000000;;		headers.Set(v1.StreamType, v1.StreamTypeError)
0000000000000000000000000000000000000000;;		p.errorStream, err = conn.CreateStream(headers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer p.errorStream.Reset()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create all the streams first, then start the copy goroutines. The server doesn't start its copy
0000000000000000000000000000000000000000;;		// goroutines until it's received all of the streams. If the client creates the stdin stream and
0000000000000000000000000000000000000000;;		// immediately begins copying stdin data to the server, it's possible to overwhelm and wedge the
0000000000000000000000000000000000000000;;		// spdy frame handler in the server so that it is full of unprocessed frames. The frames aren't
0000000000000000000000000000000000000000;;		// getting processed because the server hasn't started its copying, and it won't do that until it
0000000000000000000000000000000000000000;;		// gets all the streams. By creating all the streams first, we ensure that the server is ready to
0000000000000000000000000000000000000000;;		// process data before the client starts sending any. See https://issues.k8s.io/16373 for more info.
0000000000000000000000000000000000000000;;		if p.Stdin != nil {
0000000000000000000000000000000000000000;;			headers.Set(v1.StreamType, v1.StreamTypeStdin)
0000000000000000000000000000000000000000;;			p.remoteStdin, err = conn.CreateStream(headers)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer p.remoteStdin.Reset()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Stdout != nil {
0000000000000000000000000000000000000000;;			headers.Set(v1.StreamType, v1.StreamTypeStdout)
0000000000000000000000000000000000000000;;			p.remoteStdout, err = conn.CreateStream(headers)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer p.remoteStdout.Reset()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Stderr != nil && !p.Tty {
0000000000000000000000000000000000000000;;			headers.Set(v1.StreamType, v1.StreamTypeStderr)
0000000000000000000000000000000000000000;;			p.remoteStderr, err = conn.CreateStream(headers)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer p.remoteStderr.Reset()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now that all the streams have been created, proceed with reading & copying
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// always read from errorStream
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			message, err := ioutil.ReadAll(p.errorStream)
0000000000000000000000000000000000000000;;			if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;				errorChan <- fmt.Errorf("Error reading from error stream: %s", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(message) > 0 {
0000000000000000000000000000000000000000;;				errorChan <- fmt.Errorf("Error executing remote command: %s", message)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Stdin != nil {
0000000000000000000000000000000000000000;;			// TODO this goroutine will never exit cleanly (the io.Copy never unblocks)
0000000000000000000000000000000000000000;;			// because stdin is not closed until the process exits. If we try to call
0000000000000000000000000000000000000000;;			// stdin.Close(), it returns no error but doesn't unblock the copy. It will
0000000000000000000000000000000000000000;;			// exit when the process exits, instead.
0000000000000000000000000000000000000000;;			go cp(v1.StreamTypeStdin, p.remoteStdin, p.Stdin)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		waitCount := 0
0000000000000000000000000000000000000000;;		completedStreams := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Stdout != nil {
0000000000000000000000000000000000000000;;			waitCount++
0000000000000000000000000000000000000000;;			go cp(v1.StreamTypeStdout, p.Stdout, p.remoteStdout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.Stderr != nil && !p.Tty {
0000000000000000000000000000000000000000;;			waitCount++
0000000000000000000000000000000000000000;;			go cp(v1.StreamTypeStderr, p.Stderr, p.remoteStderr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-doneChan:
0000000000000000000000000000000000000000;;				completedStreams++
0000000000000000000000000000000000000000;;				if completedStreams == waitCount {
0000000000000000000000000000000000000000;;					break Loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case err := <-errorChan:
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
