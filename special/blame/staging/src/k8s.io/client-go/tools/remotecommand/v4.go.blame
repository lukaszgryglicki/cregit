0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
2df164f249917e4ec9430d6dca3403c363780683;pkg/client/unversioned/remotecommand/v4.go[pkg/client/unversioned/remotecommand/v4.go][staging/src/k8s.io/client-go/tools/remotecommand/v4.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package remotecommand
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/remotecommand"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/exec"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamProtocolV4 implements version 4 of the streaming protocol for attach
0000000000000000000000000000000000000000;;	// and exec. This version adds support for exit codes on the error stream through
0000000000000000000000000000000000000000;;	// the use of metav1.Status instead of plain text messages.
0000000000000000000000000000000000000000;;	type streamProtocolV4 struct {
0000000000000000000000000000000000000000;;		*streamProtocolV3
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ streamProtocolHandler = &streamProtocolV4{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStreamProtocolV4(options StreamOptions) streamProtocolHandler {
0000000000000000000000000000000000000000;;		return &streamProtocolV4{
0000000000000000000000000000000000000000;;			streamProtocolV3: newStreamProtocolV3(options).(*streamProtocolV3),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV4) createStreams(conn streamCreator) error {
0000000000000000000000000000000000000000;;		return p.streamProtocolV3.createStreams(conn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV4) handleResizes() {
0000000000000000000000000000000000000000;;		p.streamProtocolV3.handleResizes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *streamProtocolV4) stream(conn streamCreator) error {
0000000000000000000000000000000000000000;;		if err := p.createStreams(conn); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now that all the streams have been created, proceed with reading & copying
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorChan := watchErrorStream(p.errorStream, &errorDecoderV4{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.handleResizes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.copyStdin()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		p.copyStdout(&wg)
0000000000000000000000000000000000000000;;		p.copyStderr(&wg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we're waiting for stdout/stderr to finish copying
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// waits for errorStream to finish reading with an error or nil
0000000000000000000000000000000000000000;;		return <-errorChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errorDecoderV4 interprets the json-marshaled metav1.Status on the error channel
0000000000000000000000000000000000000000;;	// and creates an exec.ExitError from it.
0000000000000000000000000000000000000000;;	type errorDecoderV4 struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *errorDecoderV4) decode(message []byte) error {
0000000000000000000000000000000000000000;;		status := metav1.Status{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(message, &status)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error stream protocol error: %v in %q", err, string(message))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch status.Status {
0000000000000000000000000000000000000000;;		case metav1.StatusSuccess:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case metav1.StatusFailure:
0000000000000000000000000000000000000000;;			if status.Reason == remotecommand.NonZeroExitCodeReason {
0000000000000000000000000000000000000000;;				if status.Details == nil {
0000000000000000000000000000000000000000;;					return errors.New("error stream protocol error: details must be set")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i := range status.Details.Causes {
0000000000000000000000000000000000000000;;					c := &status.Details.Causes[i]
0000000000000000000000000000000000000000;;					if c.Type != remotecommand.ExitCodeCauseType {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rc, err := strconv.ParseUint(c.Message, 10, 8)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return fmt.Errorf("error stream protocol error: invalid exit code value %q", c.Message)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return exec.CodeExitError{
0000000000000000000000000000000000000000;;						Err:  fmt.Errorf("command terminated with exit code %d", rc),
0000000000000000000000000000000000000000;;						Code: int(rc),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return fmt.Errorf("error stream protocol error: no %s cause given", remotecommand.ExitCodeCauseType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errors.New("error stream protocol error: unknown error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf(status.Message)
0000000000000000000000000000000000000000;;	}
