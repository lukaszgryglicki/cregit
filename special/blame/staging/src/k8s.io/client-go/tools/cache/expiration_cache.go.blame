0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/expiration_cache.go[staging/src/k8s.io/client-go/1.4/tools/cache/expiration_cache.go][staging/src/k8s.io/client-go/tools/cache/expiration_cache.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpirationCache implements the store interface
0000000000000000000000000000000000000000;;	//	1. All entries are automatically time stamped on insert
0000000000000000000000000000000000000000;;	//		a. The key is computed based off the original item/keyFunc
0000000000000000000000000000000000000000;;	//		b. The value inserted under that key is the timestamped item
0000000000000000000000000000000000000000;;	//	2. Expiration happens lazily on read based on the expiration policy
0000000000000000000000000000000000000000;;	//      a. No item can be inserted into the store while we're expiring
0000000000000000000000000000000000000000;;	//		   *any* item in the cache.
0000000000000000000000000000000000000000;;	//	3. Time-stamps are stripped off unexpired entries before return
0000000000000000000000000000000000000000;;	// Note that the ExpirationCache is inherently slower than a normal
0000000000000000000000000000000000000000;;	// threadSafeStore because it takes a write lock every time it checks if
0000000000000000000000000000000000000000;;	// an item has expired.
0000000000000000000000000000000000000000;;	type ExpirationCache struct {
0000000000000000000000000000000000000000;;		cacheStorage     ThreadSafeStore
0000000000000000000000000000000000000000;;		keyFunc          KeyFunc
0000000000000000000000000000000000000000;;		clock            clock.Clock
0000000000000000000000000000000000000000;;		expirationPolicy ExpirationPolicy
0000000000000000000000000000000000000000;;		// expirationLock is a write lock used to guarantee that we don't clobber
0000000000000000000000000000000000000000;;		// newly inserted objects because of a stale expiration timestamp comparison
0000000000000000000000000000000000000000;;		expirationLock sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpirationPolicy dictates when an object expires. Currently only abstracted out
0000000000000000000000000000000000000000;;	// so unittests don't rely on the system clock.
0000000000000000000000000000000000000000;;	type ExpirationPolicy interface {
0000000000000000000000000000000000000000;;		IsExpired(obj *timestampedEntry) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TTLPolicy implements a ttl based ExpirationPolicy.
0000000000000000000000000000000000000000;;	type TTLPolicy struct {
0000000000000000000000000000000000000000;;		//	 >0: Expire entries with an age > ttl
0000000000000000000000000000000000000000;;		//	<=0: Don't expire any entry
0000000000000000000000000000000000000000;;		Ttl time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clock used to calculate ttl expiration
0000000000000000000000000000000000000000;;		Clock clock.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsExpired returns true if the given object is older than the ttl, or it can't
0000000000000000000000000000000000000000;;	// determine its age.
0000000000000000000000000000000000000000;;	func (p *TTLPolicy) IsExpired(obj *timestampedEntry) bool {
0000000000000000000000000000000000000000;;		return p.Ttl > 0 && p.Clock.Since(obj.timestamp) > p.Ttl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timestampedEntry is the only type allowed in a ExpirationCache.
0000000000000000000000000000000000000000;;	type timestampedEntry struct {
0000000000000000000000000000000000000000;;		obj       interface{}
0000000000000000000000000000000000000000;;		timestamp time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getTimestampedEntry returns the timestampedEntry stored under the given key.
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) getTimestampedEntry(key string) (*timestampedEntry, bool) {
0000000000000000000000000000000000000000;;		item, _ := c.cacheStorage.Get(key)
0000000000000000000000000000000000000000;;		if tsEntry, ok := item.(*timestampedEntry); ok {
0000000000000000000000000000000000000000;;			return tsEntry, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getOrExpire retrieves the object from the timestampedEntry if and only if it hasn't
0000000000000000000000000000000000000000;;	// already expired. It holds a write lock across deletion.
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) getOrExpire(key string) (interface{}, bool) {
0000000000000000000000000000000000000000;;		// Prevent all inserts from the time we deem an item as "expired" to when we
0000000000000000000000000000000000000000;;		// delete it, so an un-expired item doesn't sneak in under the same key, just
0000000000000000000000000000000000000000;;		// before the Delete.
0000000000000000000000000000000000000000;;		c.expirationLock.Lock()
0000000000000000000000000000000000000000;;		defer c.expirationLock.Unlock()
0000000000000000000000000000000000000000;;		timestampedItem, exists := c.getTimestampedEntry(key)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.expirationPolicy.IsExpired(timestampedItem) {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Entry %v: %+v has expired", key, timestampedItem.obj)
0000000000000000000000000000000000000000;;			c.cacheStorage.Delete(key)
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return timestampedItem.obj, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetByKey returns the item stored under the key, or sets exists=false.
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) GetByKey(key string) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;		obj, exists := c.getOrExpire(key)
0000000000000000000000000000000000000000;;		return obj, exists, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns unexpired items. It purges the cache of expired items in the
0000000000000000000000000000000000000000;;	// process.
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) Get(obj interface{}) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;		key, err := c.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj, exists := c.getOrExpire(key)
0000000000000000000000000000000000000000;;		return obj, exists, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List retrieves a list of unexpired items. It purges the cache of expired
0000000000000000000000000000000000000000;;	// items in the process.
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) List() []interface{} {
0000000000000000000000000000000000000000;;		items := c.cacheStorage.List()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list := make([]interface{}, 0, len(items))
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			obj := item.(*timestampedEntry).obj
0000000000000000000000000000000000000000;;			if key, err := c.keyFunc(obj); err != nil {
0000000000000000000000000000000000000000;;				list = append(list, obj)
0000000000000000000000000000000000000000;;			} else if obj, exists := c.getOrExpire(key); exists {
0000000000000000000000000000000000000000;;				list = append(list, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListKeys returns a list of all keys in the expiration cache.
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) ListKeys() []string {
0000000000000000000000000000000000000000;;		return c.cacheStorage.ListKeys()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add timestamps an item and inserts it into the cache, overwriting entries
0000000000000000000000000000000000000000;;	// that might exist under the same key.
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) Add(obj interface{}) error {
0000000000000000000000000000000000000000;;		c.expirationLock.Lock()
0000000000000000000000000000000000000000;;		defer c.expirationLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key, err := c.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.cacheStorage.Add(key, &timestampedEntry{obj, c.clock.Now()})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update has not been implemented yet for lack of a use case, so this method
0000000000000000000000000000000000000000;;	// simply calls `Add`. This effectively refreshes the timestamp.
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) Update(obj interface{}) error {
0000000000000000000000000000000000000000;;		return c.Add(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes an item from the cache.
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) Delete(obj interface{}) error {
0000000000000000000000000000000000000000;;		c.expirationLock.Lock()
0000000000000000000000000000000000000000;;		defer c.expirationLock.Unlock()
0000000000000000000000000000000000000000;;		key, err := c.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.cacheStorage.Delete(key)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replace will convert all items in the given list to TimestampedEntries
0000000000000000000000000000000000000000;;	// before attempting the replace operation. The replace operation will
0000000000000000000000000000000000000000;;	// delete the contents of the ExpirationCache `c`.
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) Replace(list []interface{}, resourceVersion string) error {
0000000000000000000000000000000000000000;;		c.expirationLock.Lock()
0000000000000000000000000000000000000000;;		defer c.expirationLock.Unlock()
0000000000000000000000000000000000000000;;		items := map[string]interface{}{}
0000000000000000000000000000000000000000;;		ts := c.clock.Now()
0000000000000000000000000000000000000000;;		for _, item := range list {
0000000000000000000000000000000000000000;;			key, err := c.keyFunc(item)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return KeyError{item, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			items[key] = &timestampedEntry{item, ts}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.cacheStorage.Replace(items, resourceVersion)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resync will touch all objects to put them into the processing queue
0000000000000000000000000000000000000000;;	func (c *ExpirationCache) Resync() error {
0000000000000000000000000000000000000000;;		return c.cacheStorage.Resync()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTTLStore creates and returns a ExpirationCache with a TTLPolicy
0000000000000000000000000000000000000000;;	func NewTTLStore(keyFunc KeyFunc, ttl time.Duration) Store {
0000000000000000000000000000000000000000;;		return &ExpirationCache{
0000000000000000000000000000000000000000;;			cacheStorage:     NewThreadSafeStore(Indexers{}, Indices{}),
0000000000000000000000000000000000000000;;			keyFunc:          keyFunc,
0000000000000000000000000000000000000000;;			clock:            clock.RealClock{},
0000000000000000000000000000000000000000;;			expirationPolicy: &TTLPolicy{ttl, clock.RealClock{}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
