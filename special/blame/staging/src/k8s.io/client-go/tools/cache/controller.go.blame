0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
56aa78cadcbf7dfd7120e260481bc357739a5448;staging/src/k8s.io/client-go/1.5/tools/cache/controller.go[staging/src/k8s.io/client-go/1.5/tools/cache/controller.go][staging/src/k8s.io/client-go/tools/cache/controller.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config contains all the settings for a Controller.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// The queue for your objects; either a FIFO or
0000000000000000000000000000000000000000;;		// a DeltaFIFO. Your Process() function should accept
0000000000000000000000000000000000000000;;		// the output of this Queue's Pop() method.
0000000000000000000000000000000000000000;;		Queue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Something that can list and watch your objects.
0000000000000000000000000000000000000000;;		ListerWatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Something that can process your objects.
0000000000000000000000000000000000000000;;		Process ProcessFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The type of your objects.
0000000000000000000000000000000000000000;;		ObjectType runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reprocess everything at least this often.
0000000000000000000000000000000000000000;;		// Note that if it takes longer for you to clear the queue than this
0000000000000000000000000000000000000000;;		// period, you will end up processing items in the order determined
0000000000000000000000000000000000000000;;		// by FIFO.Replace(). Currently, this is random. If this is a
0000000000000000000000000000000000000000;;		// problem, we can change that replacement policy to append new
0000000000000000000000000000000000000000;;		// things to the end of the queue instead of replacing the entire
0000000000000000000000000000000000000000;;		// queue.
0000000000000000000000000000000000000000;;		FullResyncPeriod time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ShouldResync, if specified, is invoked when the controller's reflector determines the next
0000000000000000000000000000000000000000;;		// periodic sync should occur. If this returns true, it means the reflector should proceed with
0000000000000000000000000000000000000000;;		// the resync.
0000000000000000000000000000000000000000;;		ShouldResync ShouldResyncFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If true, when Process() returns an error, re-enqueue the object.
0000000000000000000000000000000000000000;;		// TODO: add interface to let you inject a delay/backoff or drop
0000000000000000000000000000000000000000;;		//       the object completely if desired. Pass the object in
0000000000000000000000000000000000000000;;		//       question to this interface as a parameter.
0000000000000000000000000000000000000000;;		RetryOnError bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ShouldResyncFunc is a type of function that indicates if a reflector should perform a
0000000000000000000000000000000000000000;;	// resync or not. It can be used by a shared informer to support multiple event handlers with custom
0000000000000000000000000000000000000000;;	// resync periods.
0000000000000000000000000000000000000000;;	type ShouldResyncFunc func() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProcessFunc processes a single object.
0000000000000000000000000000000000000000;;	type ProcessFunc func(obj interface{}) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Controller is a generic controller framework.
0000000000000000000000000000000000000000;;	type controller struct {
0000000000000000000000000000000000000000;;		config         Config
0000000000000000000000000000000000000000;;		reflector      *Reflector
0000000000000000000000000000000000000000;;		reflectorMutex sync.RWMutex
0000000000000000000000000000000000000000;;		clock          clock.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Controller interface {
0000000000000000000000000000000000000000;;		Run(stopCh <-chan struct{})
0000000000000000000000000000000000000000;;		HasSynced() bool
0000000000000000000000000000000000000000;;		LastSyncResourceVersion() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New makes a new Controller from the given Config.
0000000000000000000000000000000000000000;;	func New(c *Config) Controller {
0000000000000000000000000000000000000000;;		ctlr := &controller{
0000000000000000000000000000000000000000;;			config: *c,
0000000000000000000000000000000000000000;;			clock:  &clock.RealClock{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ctlr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run begins processing items, and will continue until a value is sent down stopCh.
0000000000000000000000000000000000000000;;	// It's an error to call Run more than once.
0000000000000000000000000000000000000000;;	// Run blocks; call via go.
0000000000000000000000000000000000000000;;	func (c *controller) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			<-stopCh
0000000000000000000000000000000000000000;;			c.config.Queue.Close()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		r := NewReflector(
0000000000000000000000000000000000000000;;			c.config.ListerWatcher,
0000000000000000000000000000000000000000;;			c.config.ObjectType,
0000000000000000000000000000000000000000;;			c.config.Queue,
0000000000000000000000000000000000000000;;			c.config.FullResyncPeriod,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		r.ShouldResync = c.config.ShouldResync
0000000000000000000000000000000000000000;;		r.clock = c.clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.reflectorMutex.Lock()
0000000000000000000000000000000000000000;;		c.reflector = r
0000000000000000000000000000000000000000;;		c.reflectorMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.RunUntil(stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wait.Until(c.processLoop, time.Second, stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true once this controller has completed an initial resource listing
0000000000000000000000000000000000000000;;	func (c *controller) HasSynced() bool {
0000000000000000000000000000000000000000;;		return c.config.Queue.HasSynced()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *controller) LastSyncResourceVersion() string {
0000000000000000000000000000000000000000;;		if c.reflector == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.reflector.LastSyncResourceVersion()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processLoop drains the work queue.
0000000000000000000000000000000000000000;;	// TODO: Consider doing the processing in parallel. This will require a little thought
0000000000000000000000000000000000000000;;	// to make sure that we don't end up processing the same object multiple times
0000000000000000000000000000000000000000;;	// concurrently.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: Plumb through the stopCh here (and down to the queue) so that this can
0000000000000000000000000000000000000000;;	// actually exit when the controller is stopped. Or just give up on this stuff
0000000000000000000000000000000000000000;;	// ever being stoppable. Converting this whole package to use Context would
0000000000000000000000000000000000000000;;	// also be helpful.
0000000000000000000000000000000000000000;;	func (c *controller) processLoop() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == FIFOClosedError {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c.config.RetryOnError {
0000000000000000000000000000000000000000;;					// This is the safe way to re-enqueue.
0000000000000000000000000000000000000000;;					c.config.Queue.AddIfNotPresent(obj)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceEventHandler can handle notifications for events that happen to a
0000000000000000000000000000000000000000;;	// resource. The events are informational only, so you can't return an
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	//  * OnAdd is called when an object is added.
0000000000000000000000000000000000000000;;	//  * OnUpdate is called when an object is modified. Note that oldObj is the
0000000000000000000000000000000000000000;;	//      last known state of the object-- it is possible that several changes
0000000000000000000000000000000000000000;;	//      were combined together, so you can't use this to see every single
0000000000000000000000000000000000000000;;	//      change. OnUpdate is also called when a re-list happens, and it will
0000000000000000000000000000000000000000;;	//      get called even if nothing changed. This is useful for periodically
0000000000000000000000000000000000000000;;	//      evaluating or syncing something.
0000000000000000000000000000000000000000;;	//  * OnDelete will get the final state of the item if it is known, otherwise
0000000000000000000000000000000000000000;;	//      it will get an object of type DeletedFinalStateUnknown. This can
0000000000000000000000000000000000000000;;	//      happen if the watch is closed and misses the delete event and we don't
0000000000000000000000000000000000000000;;	//      notice the deletion until the subsequent re-list.
0000000000000000000000000000000000000000;;	type ResourceEventHandler interface {
0000000000000000000000000000000000000000;;		OnAdd(obj interface{})
0000000000000000000000000000000000000000;;		OnUpdate(oldObj, newObj interface{})
0000000000000000000000000000000000000000;;		OnDelete(obj interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceEventHandlerFuncs is an adaptor to let you easily specify as many or
0000000000000000000000000000000000000000;;	// as few of the notification functions as you want while still implementing
0000000000000000000000000000000000000000;;	// ResourceEventHandler.
0000000000000000000000000000000000000000;;	type ResourceEventHandlerFuncs struct {
0000000000000000000000000000000000000000;;		AddFunc    func(obj interface{})
0000000000000000000000000000000000000000;;		UpdateFunc func(oldObj, newObj interface{})
0000000000000000000000000000000000000000;;		DeleteFunc func(obj interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OnAdd calls AddFunc if it's not nil.
0000000000000000000000000000000000000000;;	func (r ResourceEventHandlerFuncs) OnAdd(obj interface{}) {
0000000000000000000000000000000000000000;;		if r.AddFunc != nil {
0000000000000000000000000000000000000000;;			r.AddFunc(obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OnUpdate calls UpdateFunc if it's not nil.
0000000000000000000000000000000000000000;;	func (r ResourceEventHandlerFuncs) OnUpdate(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;		if r.UpdateFunc != nil {
0000000000000000000000000000000000000000;;			r.UpdateFunc(oldObj, newObj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OnDelete calls DeleteFunc if it's not nil.
0000000000000000000000000000000000000000;;	func (r ResourceEventHandlerFuncs) OnDelete(obj interface{}) {
0000000000000000000000000000000000000000;;		if r.DeleteFunc != nil {
0000000000000000000000000000000000000000;;			r.DeleteFunc(obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilteringResourceEventHandler applies the provided filter to all events coming
0000000000000000000000000000000000000000;;	// in, ensuring the appropriate nested handler method is invoked. An object
0000000000000000000000000000000000000000;;	// that starts passing the filter after an update is considered an add, and an
0000000000000000000000000000000000000000;;	// object that stops passing the filter after an update is considered a delete.
0000000000000000000000000000000000000000;;	type FilteringResourceEventHandler struct {
0000000000000000000000000000000000000000;;		FilterFunc func(obj interface{}) bool
0000000000000000000000000000000000000000;;		Handler    ResourceEventHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OnAdd calls the nested handler only if the filter succeeds
0000000000000000000000000000000000000000;;	func (r FilteringResourceEventHandler) OnAdd(obj interface{}) {
0000000000000000000000000000000000000000;;		if !r.FilterFunc(obj) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.Handler.OnAdd(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OnUpdate ensures the proper handler is called depending on whether the filter matches
0000000000000000000000000000000000000000;;	func (r FilteringResourceEventHandler) OnUpdate(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;		newer := r.FilterFunc(newObj)
0000000000000000000000000000000000000000;;		older := r.FilterFunc(oldObj)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case newer && older:
0000000000000000000000000000000000000000;;			r.Handler.OnUpdate(oldObj, newObj)
0000000000000000000000000000000000000000;;		case newer && !older:
0000000000000000000000000000000000000000;;			r.Handler.OnAdd(newObj)
0000000000000000000000000000000000000000;;		case !newer && older:
0000000000000000000000000000000000000000;;			r.Handler.OnDelete(oldObj)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// do nothing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OnDelete calls the nested handler only if the filter succeeds
0000000000000000000000000000000000000000;;	func (r FilteringResourceEventHandler) OnDelete(obj interface{}) {
0000000000000000000000000000000000000000;;		if !r.FilterFunc(obj) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.Handler.OnDelete(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeletionHandlingMetaNamespaceKeyFunc checks for
0000000000000000000000000000000000000000;;	// DeletedFinalStateUnknown objects before calling
0000000000000000000000000000000000000000;;	// MetaNamespaceKeyFunc.
0000000000000000000000000000000000000000;;	func DeletionHandlingMetaNamespaceKeyFunc(obj interface{}) (string, error) {
0000000000000000000000000000000000000000;;		if d, ok := obj.(DeletedFinalStateUnknown); ok {
0000000000000000000000000000000000000000;;			return d.Key, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return MetaNamespaceKeyFunc(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInformer returns a Store and a controller for populating the store
0000000000000000000000000000000000000000;;	// while also providing event notifications. You should only used the returned
0000000000000000000000000000000000000000;;	// Store for Get/List operations; Add/Modify/Deletes will cause the event
0000000000000000000000000000000000000000;;	// notifications to be faulty.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Parameters:
0000000000000000000000000000000000000000;;	//  * lw is list and watch functions for the source of the resource you want to
0000000000000000000000000000000000000000;;	//    be informed of.
0000000000000000000000000000000000000000;;	//  * objType is an object of the type that you expect to receive.
0000000000000000000000000000000000000000;;	//  * resyncPeriod: if non-zero, will re-list this often (you will get OnUpdate
0000000000000000000000000000000000000000;;	//    calls, even if nothing changed). Otherwise, re-list will be delayed as
0000000000000000000000000000000000000000;;	//    long as possible (until the upstream source closes the watch or times out,
0000000000000000000000000000000000000000;;	//    or you stop the controller).
0000000000000000000000000000000000000000;;	//  * h is the object you want notifications sent to.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func NewInformer(
0000000000000000000000000000000000000000;;		lw ListerWatcher,
0000000000000000000000000000000000000000;;		objType runtime.Object,
0000000000000000000000000000000000000000;;		resyncPeriod time.Duration,
0000000000000000000000000000000000000000;;		h ResourceEventHandler,
0000000000000000000000000000000000000000;;	) (Store, Controller) {
0000000000000000000000000000000000000000;;		// This will hold the client state, as we know it.
0000000000000000000000000000000000000000;;		clientState := NewStore(DeletionHandlingMetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This will hold incoming changes. Note how we pass clientState in as a
0000000000000000000000000000000000000000;;		// KeyLister, that way resync operations will result in the correct set
0000000000000000000000000000000000000000;;		// of update/delete deltas.
0000000000000000000000000000000000000000;;		fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, nil, clientState)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := &Config{
0000000000000000000000000000000000000000;;			Queue:            fifo,
0000000000000000000000000000000000000000;;			ListerWatcher:    lw,
0000000000000000000000000000000000000000;;			ObjectType:       objType,
0000000000000000000000000000000000000000;;			FullResyncPeriod: resyncPeriod,
0000000000000000000000000000000000000000;;			RetryOnError:     false,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Process: func(obj interface{}) error {
0000000000000000000000000000000000000000;;				// from oldest to newest
0000000000000000000000000000000000000000;;				for _, d := range obj.(Deltas) {
0000000000000000000000000000000000000000;;					switch d.Type {
0000000000000000000000000000000000000000;;					case Sync, Added, Updated:
0000000000000000000000000000000000000000;;						if old, exists, err := clientState.Get(d.Object); err == nil && exists {
0000000000000000000000000000000000000000;;							if err := clientState.Update(d.Object); err != nil {
0000000000000000000000000000000000000000;;								return err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							h.OnUpdate(old, d.Object)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							if err := clientState.Add(d.Object); err != nil {
0000000000000000000000000000000000000000;;								return err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							h.OnAdd(d.Object)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case Deleted:
0000000000000000000000000000000000000000;;						if err := clientState.Delete(d.Object); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						h.OnDelete(d.Object)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientState, New(cfg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewIndexerInformer returns a Indexer and a controller for populating the index
0000000000000000000000000000000000000000;;	// while also providing event notifications. You should only used the returned
0000000000000000000000000000000000000000;;	// Index for Get/List operations; Add/Modify/Deletes will cause the event
0000000000000000000000000000000000000000;;	// notifications to be faulty.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Parameters:
0000000000000000000000000000000000000000;;	//  * lw is list and watch functions for the source of the resource you want to
0000000000000000000000000000000000000000;;	//    be informed of.
0000000000000000000000000000000000000000;;	//  * objType is an object of the type that you expect to receive.
0000000000000000000000000000000000000000;;	//  * resyncPeriod: if non-zero, will re-list this often (you will get OnUpdate
0000000000000000000000000000000000000000;;	//    calls, even if nothing changed). Otherwise, re-list will be delayed as
0000000000000000000000000000000000000000;;	//    long as possible (until the upstream source closes the watch or times out,
0000000000000000000000000000000000000000;;	//    or you stop the controller).
0000000000000000000000000000000000000000;;	//  * h is the object you want notifications sent to.
0000000000000000000000000000000000000000;;	//  * indexers is the indexer for the received object type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func NewIndexerInformer(
0000000000000000000000000000000000000000;;		lw ListerWatcher,
0000000000000000000000000000000000000000;;		objType runtime.Object,
0000000000000000000000000000000000000000;;		resyncPeriod time.Duration,
0000000000000000000000000000000000000000;;		h ResourceEventHandler,
0000000000000000000000000000000000000000;;		indexers Indexers,
0000000000000000000000000000000000000000;;	) (Indexer, Controller) {
0000000000000000000000000000000000000000;;		// This will hold the client state, as we know it.
0000000000000000000000000000000000000000;;		clientState := NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This will hold incoming changes. Note how we pass clientState in as a
0000000000000000000000000000000000000000;;		// KeyLister, that way resync operations will result in the correct set
0000000000000000000000000000000000000000;;		// of update/delete deltas.
0000000000000000000000000000000000000000;;		fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, nil, clientState)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := &Config{
0000000000000000000000000000000000000000;;			Queue:            fifo,
0000000000000000000000000000000000000000;;			ListerWatcher:    lw,
0000000000000000000000000000000000000000;;			ObjectType:       objType,
0000000000000000000000000000000000000000;;			FullResyncPeriod: resyncPeriod,
0000000000000000000000000000000000000000;;			RetryOnError:     false,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Process: func(obj interface{}) error {
0000000000000000000000000000000000000000;;				// from oldest to newest
0000000000000000000000000000000000000000;;				for _, d := range obj.(Deltas) {
0000000000000000000000000000000000000000;;					switch d.Type {
0000000000000000000000000000000000000000;;					case Sync, Added, Updated:
0000000000000000000000000000000000000000;;						if old, exists, err := clientState.Get(d.Object); err == nil && exists {
0000000000000000000000000000000000000000;;							if err := clientState.Update(d.Object); err != nil {
0000000000000000000000000000000000000000;;								return err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							h.OnUpdate(old, d.Object)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							if err := clientState.Add(d.Object); err != nil {
0000000000000000000000000000000000000000;;								return err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							h.OnAdd(d.Object)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case Deleted:
0000000000000000000000000000000000000000;;						if err := clientState.Delete(d.Object); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						h.OnDelete(d.Object)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return clientState, New(cfg)
0000000000000000000000000000000000000000;;	}
