0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
56aa78cadcbf7dfd7120e260481bc357739a5448;staging/src/k8s.io/client-go/1.5/tools/cache/testing/fake_controller_source.go[staging/src/k8s.io/client-go/1.5/tools/cache/testing/fake_controller_source.go][staging/src/k8s.io/client-go/tools/cache/testing/fake_controller_source.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package framework
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakeControllerSource() *FakeControllerSource {
0000000000000000000000000000000000000000;;		return &FakeControllerSource{
0000000000000000000000000000000000000000;;			Items:       map[nnu]runtime.Object{},
0000000000000000000000000000000000000000;;			Broadcaster: watch.NewBroadcaster(100, watch.WaitIfChannelFull),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakePVControllerSource() *FakePVControllerSource {
0000000000000000000000000000000000000000;;		return &FakePVControllerSource{
0000000000000000000000000000000000000000;;			FakeControllerSource{
0000000000000000000000000000000000000000;;				Items:       map[nnu]runtime.Object{},
0000000000000000000000000000000000000000;;				Broadcaster: watch.NewBroadcaster(100, watch.WaitIfChannelFull),
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFakePVCControllerSource() *FakePVCControllerSource {
0000000000000000000000000000000000000000;;		return &FakePVCControllerSource{
0000000000000000000000000000000000000000;;			FakeControllerSource{
0000000000000000000000000000000000000000;;				Items:       map[nnu]runtime.Object{},
0000000000000000000000000000000000000000;;				Broadcaster: watch.NewBroadcaster(100, watch.WaitIfChannelFull),
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeControllerSource implements listing/watching for testing.
0000000000000000000000000000000000000000;;	type FakeControllerSource struct {
0000000000000000000000000000000000000000;;		lock        sync.RWMutex
0000000000000000000000000000000000000000;;		Items       map[nnu]runtime.Object
0000000000000000000000000000000000000000;;		changes     []watch.Event // one change per resourceVersion
0000000000000000000000000000000000000000;;		Broadcaster *watch.Broadcaster
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakePVControllerSource struct {
0000000000000000000000000000000000000000;;		FakeControllerSource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FakePVCControllerSource struct {
0000000000000000000000000000000000000000;;		FakeControllerSource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// namespace, name, uid to be used as a key.
0000000000000000000000000000000000000000;;	type nnu struct {
0000000000000000000000000000000000000000;;		namespace, name string
0000000000000000000000000000000000000000;;		uid             types.UID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds an object to the set and sends an add event to watchers.
0000000000000000000000000000000000000000;;	// obj's ResourceVersion is set.
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) Add(obj runtime.Object) {
0000000000000000000000000000000000000000;;		f.Change(watch.Event{Type: watch.Added, Object: obj}, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Modify updates an object in the set and sends a modified event to watchers.
0000000000000000000000000000000000000000;;	// obj's ResourceVersion is set.
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) Modify(obj runtime.Object) {
0000000000000000000000000000000000000000;;		f.Change(watch.Event{Type: watch.Modified, Object: obj}, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete deletes an object from the set and sends a delete event to watchers.
0000000000000000000000000000000000000000;;	// obj's ResourceVersion is set.
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) Delete(lastValue runtime.Object) {
0000000000000000000000000000000000000000;;		f.Change(watch.Event{Type: watch.Deleted, Object: lastValue}, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddDropWatch adds an object to the set but forgets to send an add event to
0000000000000000000000000000000000000000;;	// watchers.
0000000000000000000000000000000000000000;;	// obj's ResourceVersion is set.
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) AddDropWatch(obj runtime.Object) {
0000000000000000000000000000000000000000;;		f.Change(watch.Event{Type: watch.Added, Object: obj}, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ModifyDropWatch updates an object in the set but forgets to send a modify
0000000000000000000000000000000000000000;;	// event to watchers.
0000000000000000000000000000000000000000;;	// obj's ResourceVersion is set.
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) ModifyDropWatch(obj runtime.Object) {
0000000000000000000000000000000000000000;;		f.Change(watch.Event{Type: watch.Modified, Object: obj}, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteDropWatch deletes an object from the set but forgets to send a delete
0000000000000000000000000000000000000000;;	// event to watchers.
0000000000000000000000000000000000000000;;	// obj's ResourceVersion is set.
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) DeleteDropWatch(lastValue runtime.Object) {
0000000000000000000000000000000000000000;;		f.Change(watch.Event{Type: watch.Deleted, Object: lastValue}, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) key(accessor metav1.Object) nnu {
0000000000000000000000000000000000000000;;		return nnu{accessor.GetNamespace(), accessor.GetName(), accessor.GetUID()}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Change records the given event (setting the object's resource version) and
0000000000000000000000000000000000000000;;	// sends a watch event with the specified probability.
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) Change(e watch.Event, watchProbability float64) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(e.Object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err) // this is test code only
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resourceVersion := len(f.changes) + 1
0000000000000000000000000000000000000000;;		accessor.SetResourceVersion(strconv.Itoa(resourceVersion))
0000000000000000000000000000000000000000;;		f.changes = append(f.changes, e)
0000000000000000000000000000000000000000;;		key := f.key(accessor)
0000000000000000000000000000000000000000;;		switch e.Type {
0000000000000000000000000000000000000000;;		case watch.Added, watch.Modified:
0000000000000000000000000000000000000000;;			f.Items[key] = e.Object
0000000000000000000000000000000000000000;;		case watch.Deleted:
0000000000000000000000000000000000000000;;			delete(f.Items, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rand.Float64() < watchProbability {
0000000000000000000000000000000000000000;;			f.Broadcaster.Action(e.Type, e.Object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) getListItemsLocked() ([]runtime.Object, error) {
0000000000000000000000000000000000000000;;		list := make([]runtime.Object, 0, len(f.Items))
0000000000000000000000000000000000000000;;		for _, obj := range f.Items {
0000000000000000000000000000000000000000;;			// Must make a copy to allow clients to modify the object.
0000000000000000000000000000000000000000;;			// Otherwise, if they make a change and write it back, they
0000000000000000000000000000000000000000;;			// will inadvertently change our canonical copy (in
0000000000000000000000000000000000000000;;			// addition to racing with other clients).
0000000000000000000000000000000000000000;;			objCopy, err := scheme.Scheme.DeepCopy(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			list = append(list, objCopy.(runtime.Object))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list object, with its resource version set.
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) List(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		list, err := f.getListItemsLocked()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listObj := &v1.List{}
0000000000000000000000000000000000000000;;		if err := meta.SetList(listObj, list); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listAccessor, err := meta.ListAccessor(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceVersion := len(f.changes)
0000000000000000000000000000000000000000;;		listAccessor.SetResourceVersion(strconv.Itoa(resourceVersion))
0000000000000000000000000000000000000000;;		return listObj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list object, with its resource version set.
0000000000000000000000000000000000000000;;	func (f *FakePVControllerSource) List(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		list, err := f.FakeControllerSource.getListItemsLocked()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listObj := &v1.PersistentVolumeList{}
0000000000000000000000000000000000000000;;		if err := meta.SetList(listObj, list); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listAccessor, err := meta.ListAccessor(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceVersion := len(f.changes)
0000000000000000000000000000000000000000;;		listAccessor.SetResourceVersion(strconv.Itoa(resourceVersion))
0000000000000000000000000000000000000000;;		return listObj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list object, with its resource version set.
0000000000000000000000000000000000000000;;	func (f *FakePVCControllerSource) List(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		list, err := f.FakeControllerSource.getListItemsLocked()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listObj := &v1.PersistentVolumeClaimList{}
0000000000000000000000000000000000000000;;		if err := meta.SetList(listObj, list); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listAccessor, err := meta.ListAccessor(listObj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceVersion := len(f.changes)
0000000000000000000000000000000000000000;;		listAccessor.SetResourceVersion(strconv.Itoa(resourceVersion))
0000000000000000000000000000000000000000;;		return listObj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch returns a watch, which will be pre-populated with all changes
0000000000000000000000000000000000000000;;	// after resourceVersion.
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) Watch(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		rc, err := strconv.Atoi(options.ResourceVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rc < len(f.changes) {
0000000000000000000000000000000000000000;;			changes := []watch.Event{}
0000000000000000000000000000000000000000;;			for _, c := range f.changes[rc:] {
0000000000000000000000000000000000000000;;				// Must make a copy to allow clients to modify the
0000000000000000000000000000000000000000;;				// object.  Otherwise, if they make a change and write
0000000000000000000000000000000000000000;;				// it back, they will inadvertently change the our
0000000000000000000000000000000000000000;;				// canonical copy (in addition to racing with other
0000000000000000000000000000000000000000;;				// clients).
0000000000000000000000000000000000000000;;				objCopy, err := scheme.Scheme.DeepCopy(c.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				changes = append(changes, watch.Event{Type: c.Type, Object: objCopy.(runtime.Object)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return f.Broadcaster.WatchWithPrefix(changes), nil
0000000000000000000000000000000000000000;;		} else if rc > len(f.changes) {
0000000000000000000000000000000000000000;;			return nil, errors.New("resource version in the future not supported by this fake")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.Broadcaster.Watch(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Shutdown closes the underlying broadcaster, waiting for events to be
0000000000000000000000000000000000000000;;	// delivered. It's an error to call any method after calling shutdown. This is
0000000000000000000000000000000000000000;;	// enforced by Shutdown() leaving f locked.
0000000000000000000000000000000000000000;;	func (f *FakeControllerSource) Shutdown() {
0000000000000000000000000000000000000000;;		f.lock.Lock() // Purposely no unlock.
0000000000000000000000000000000000000000;;		f.Broadcaster.Shutdown()
0000000000000000000000000000000000000000;;	}
