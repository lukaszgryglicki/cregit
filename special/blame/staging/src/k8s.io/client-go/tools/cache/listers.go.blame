0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/listers.go[staging/src/k8s.io/client-go/1.4/tools/cache/listers.go][staging/src/k8s.io/client-go/tools/cache/listers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/labels"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppendFunc is used to add a matching item to whatever list the caller is using
0000000000000000000000000000000000000000;;	type AppendFunc func(interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ListAll(store Store, selector labels.Selector, appendFn AppendFunc) error {
0000000000000000000000000000000000000000;;		for _, m := range store.List() {
0000000000000000000000000000000000000000;;			metadata, err := meta.Accessor(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if selector.Matches(labels.Set(metadata.GetLabels())) {
0000000000000000000000000000000000000000;;				appendFn(m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ListAllByNamespace(indexer Indexer, namespace string, selector labels.Selector, appendFn AppendFunc) error {
0000000000000000000000000000000000000000;;		if namespace == metav1.NamespaceAll {
0000000000000000000000000000000000000000;;			for _, m := range indexer.List() {
0000000000000000000000000000000000000000;;				metadata, err := meta.Accessor(m)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if selector.Matches(labels.Set(metadata.GetLabels())) {
0000000000000000000000000000000000000000;;					appendFn(m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items, err := indexer.Index(NamespaceIndex, &metav1.ObjectMeta{Namespace: namespace})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Ignore error; do slow search without index.
0000000000000000000000000000000000000000;;			glog.Warningf("can not retrieve list of objects using index : %v", err)
0000000000000000000000000000000000000000;;			for _, m := range indexer.List() {
0000000000000000000000000000000000000000;;				metadata, err := meta.Accessor(m)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if metadata.GetNamespace() == namespace && selector.Matches(labels.Set(metadata.GetLabels())) {
0000000000000000000000000000000000000000;;					appendFn(m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, m := range items {
0000000000000000000000000000000000000000;;			metadata, err := meta.Accessor(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if selector.Matches(labels.Set(metadata.GetLabels())) {
0000000000000000000000000000000000000000;;				appendFn(m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenericLister is a lister skin on a generic Indexer
0000000000000000000000000000000000000000;;	type GenericLister interface {
0000000000000000000000000000000000000000;;		// List will return all objects across namespaces
0000000000000000000000000000000000000000;;		List(selector labels.Selector) (ret []runtime.Object, err error)
0000000000000000000000000000000000000000;;		// Get will attempt to retrieve assuming that name==key
0000000000000000000000000000000000000000;;		Get(name string) (runtime.Object, error)
0000000000000000000000000000000000000000;;		// ByNamespace will give you a GenericNamespaceLister for one namespace
0000000000000000000000000000000000000000;;		ByNamespace(namespace string) GenericNamespaceLister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenericNamespaceLister is a lister skin on a generic Indexer
0000000000000000000000000000000000000000;;	type GenericNamespaceLister interface {
0000000000000000000000000000000000000000;;		// List will return all objects in this namespace
0000000000000000000000000000000000000000;;		List(selector labels.Selector) (ret []runtime.Object, err error)
0000000000000000000000000000000000000000;;		// Get will attempt to retrieve by namespace and name
0000000000000000000000000000000000000000;;		Get(name string) (runtime.Object, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewGenericLister(indexer Indexer, resource schema.GroupResource) GenericLister {
0000000000000000000000000000000000000000;;		return &genericLister{indexer: indexer, resource: resource}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type genericLister struct {
0000000000000000000000000000000000000000;;		indexer  Indexer
0000000000000000000000000000000000000000;;		resource schema.GroupResource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *genericLister) List(selector labels.Selector) (ret []runtime.Object, err error) {
0000000000000000000000000000000000000000;;		err = ListAll(s.indexer, selector, func(m interface{}) {
0000000000000000000000000000000000000000;;			ret = append(ret, m.(runtime.Object))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return ret, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *genericLister) ByNamespace(namespace string) GenericNamespaceLister {
0000000000000000000000000000000000000000;;		return &genericNamespaceLister{indexer: s.indexer, namespace: namespace, resource: s.resource}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *genericLister) Get(name string) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		obj, exists, err := s.indexer.GetByKey(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return nil, errors.NewNotFound(s.resource, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj.(runtime.Object), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type genericNamespaceLister struct {
0000000000000000000000000000000000000000;;		indexer   Indexer
0000000000000000000000000000000000000000;;		namespace string
0000000000000000000000000000000000000000;;		resource  schema.GroupResource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *genericNamespaceLister) List(selector labels.Selector) (ret []runtime.Object, err error) {
0000000000000000000000000000000000000000;;		err = ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {
0000000000000000000000000000000000000000;;			ret = append(ret, m.(runtime.Object))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return ret, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *genericNamespaceLister) Get(name string) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		obj, exists, err := s.indexer.GetByKey(s.namespace + "/" + name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return nil, errors.NewNotFound(s.resource, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj.(runtime.Object), nil
0000000000000000000000000000000000000000;;	}
