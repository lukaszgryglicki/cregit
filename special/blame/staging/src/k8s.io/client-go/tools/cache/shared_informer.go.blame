0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
56aa78cadcbf7dfd7120e260481bc357739a5448;staging/src/k8s.io/client-go/1.5/tools/cache/shared_informer.go[staging/src/k8s.io/client-go/1.5/tools/cache/shared_informer.go][staging/src/k8s.io/client-go/tools/cache/shared_informer.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SharedInformer has a shared data cache and is capable of distributing notifications for changes
0000000000000000000000000000000000000000;;	// to the cache to multiple listeners who registered via AddEventHandler. If you use this, there is
0000000000000000000000000000000000000000;;	// one behavior change compared to a standard Informer.  When you receive a notification, the cache
0000000000000000000000000000000000000000;;	// will be AT LEAST as fresh as the notification, but it MAY be more fresh.  You should NOT depend
0000000000000000000000000000000000000000;;	// on the contents of the cache exactly matching the notification you've received in handler
0000000000000000000000000000000000000000;;	// functions.  If there was a create, followed by a delete, the cache may NOT have your item.  This
0000000000000000000000000000000000000000;;	// has advantages over the broadcaster since it allows us to share a common cache across many
0000000000000000000000000000000000000000;;	// controllers. Extending the broadcaster would have required us keep duplicate caches for each
0000000000000000000000000000000000000000;;	// watch.
0000000000000000000000000000000000000000;;	type SharedInformer interface {
0000000000000000000000000000000000000000;;		// AddEventHandler adds an event handler to the shared informer using the shared informer's resync
0000000000000000000000000000000000000000;;		// period.  Events to a single handler are delivered sequentially, but there is no coordination
0000000000000000000000000000000000000000;;		// between different handlers.
0000000000000000000000000000000000000000;;		AddEventHandler(handler ResourceEventHandler)
0000000000000000000000000000000000000000;;		// AddEventHandlerWithResyncPeriod adds an event handler to the shared informer using the
0000000000000000000000000000000000000000;;		// specified resync period.  Events to a single handler are delivered sequentially, but there is
0000000000000000000000000000000000000000;;		// no coordination between different handlers.
0000000000000000000000000000000000000000;;		AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration)
0000000000000000000000000000000000000000;;		// GetStore returns the Store.
0000000000000000000000000000000000000000;;		GetStore() Store
0000000000000000000000000000000000000000;;		// GetController gives back a synthetic interface that "votes" to start the informer
0000000000000000000000000000000000000000;;		GetController() Controller
0000000000000000000000000000000000000000;;		// Run starts the shared informer, which will be stopped when stopCh is closed.
0000000000000000000000000000000000000000;;		Run(stopCh <-chan struct{})
0000000000000000000000000000000000000000;;		// HasSynced returns true if the shared informer's store has synced.
0000000000000000000000000000000000000000;;		HasSynced() bool
0000000000000000000000000000000000000000;;		// LastSyncResourceVersion is the resource version observed when last synced with the underlying
0000000000000000000000000000000000000000;;		// store. The value returned is not synchronized with access to the underlying store and is not
0000000000000000000000000000000000000000;;		// thread-safe.
0000000000000000000000000000000000000000;;		LastSyncResourceVersion() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SharedIndexInformer interface {
0000000000000000000000000000000000000000;;		SharedInformer
0000000000000000000000000000000000000000;;		// AddIndexers add indexers to the informer before it starts.
0000000000000000000000000000000000000000;;		AddIndexers(indexers Indexers) error
0000000000000000000000000000000000000000;;		GetIndexer() Indexer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSharedInformer creates a new instance for the listwatcher.
0000000000000000000000000000000000000000;;	func NewSharedInformer(lw ListerWatcher, objType runtime.Object, resyncPeriod time.Duration) SharedInformer {
0000000000000000000000000000000000000000;;		return NewSharedIndexInformer(lw, objType, resyncPeriod, Indexers{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSharedIndexInformer creates a new instance for the listwatcher.
0000000000000000000000000000000000000000;;	func NewSharedIndexInformer(lw ListerWatcher, objType runtime.Object, defaultEventHandlerResyncPeriod time.Duration, indexers Indexers) SharedIndexInformer {
0000000000000000000000000000000000000000;;		realClock := &clock.RealClock{}
0000000000000000000000000000000000000000;;		sharedIndexInformer := &sharedIndexInformer{
0000000000000000000000000000000000000000;;			processor:                       &sharedProcessor{clock: realClock},
0000000000000000000000000000000000000000;;			indexer:                         NewIndexer(DeletionHandlingMetaNamespaceKeyFunc, indexers),
0000000000000000000000000000000000000000;;			listerWatcher:                   lw,
0000000000000000000000000000000000000000;;			objectType:                      objType,
0000000000000000000000000000000000000000;;			resyncCheckPeriod:               defaultEventHandlerResyncPeriod,
0000000000000000000000000000000000000000;;			defaultEventHandlerResyncPeriod: defaultEventHandlerResyncPeriod,
0000000000000000000000000000000000000000;;			cacheMutationDetector:           NewCacheMutationDetector(fmt.Sprintf("%T", objType)),
0000000000000000000000000000000000000000;;			clock: realClock,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sharedIndexInformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InformerSynced is a function that can be used to determine if an informer has synced.  This is useful for determining if caches have synced.
0000000000000000000000000000000000000000;;	type InformerSynced func() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncedPollPeriod controls how often you look at the status of your sync funcs
0000000000000000000000000000000000000000;;	const syncedPollPeriod = 100 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForCacheSync waits for caches to populate.  It returns true if it was successful, false
0000000000000000000000000000000000000000;;	// if the controller should shutdown
0000000000000000000000000000000000000000;;	func WaitForCacheSync(stopCh <-chan struct{}, cacheSyncs ...InformerSynced) bool {
0000000000000000000000000000000000000000;;		err := wait.PollUntil(syncedPollPeriod,
0000000000000000000000000000000000000000;;			func() (bool, error) {
0000000000000000000000000000000000000000;;				for _, syncFunc := range cacheSyncs {
0000000000000000000000000000000000000000;;					if !syncFunc() {
0000000000000000000000000000000000000000;;						return false, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			stopCh)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("stop requested")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("caches populated")
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sharedIndexInformer struct {
0000000000000000000000000000000000000000;;		indexer    Indexer
0000000000000000000000000000000000000000;;		controller Controller
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		processor             *sharedProcessor
0000000000000000000000000000000000000000;;		cacheMutationDetector CacheMutationDetector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This block is tracked to handle late initialization of the controller
0000000000000000000000000000000000000000;;		listerWatcher ListerWatcher
0000000000000000000000000000000000000000;;		objectType    runtime.Object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// resyncCheckPeriod is how often we want the reflector's resync timer to fire so it can call
0000000000000000000000000000000000000000;;		// shouldResync to check if any of our listeners need a resync.
0000000000000000000000000000000000000000;;		resyncCheckPeriod time.Duration
0000000000000000000000000000000000000000;;		// defaultEventHandlerResyncPeriod is the default resync period for any handlers added via
0000000000000000000000000000000000000000;;		// AddEventHandler (i.e. they don't specify one and just want to use the shared informer's default
0000000000000000000000000000000000000000;;		// value).
0000000000000000000000000000000000000000;;		defaultEventHandlerResyncPeriod time.Duration
0000000000000000000000000000000000000000;;		// clock allows for testability
0000000000000000000000000000000000000000;;		clock clock.Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		started     bool
0000000000000000000000000000000000000000;;		startedLock sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// blockDeltas gives a way to stop all event distribution so that a late event handler
0000000000000000000000000000000000000000;;		// can safely join the shared informer.
0000000000000000000000000000000000000000;;		blockDeltas sync.Mutex
0000000000000000000000000000000000000000;;		// stopCh is the channel used to stop the main Run process.  We have to track it so that
0000000000000000000000000000000000000000;;		// late joiners can have a proper stop
0000000000000000000000000000000000000000;;		stopCh <-chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dummyController hides the fact that a SharedInformer is different from a dedicated one
0000000000000000000000000000000000000000;;	// where a caller can `Run`.  The run method is disconnected in this case, because higher
0000000000000000000000000000000000000000;;	// level logic will decide when to start the SharedInformer and related controller.
0000000000000000000000000000000000000000;;	// Because returning information back is always asynchronous, the legacy callers shouldn't
0000000000000000000000000000000000000000;;	// notice any change in behavior.
0000000000000000000000000000000000000000;;	type dummyController struct {
0000000000000000000000000000000000000000;;		informer *sharedIndexInformer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *dummyController) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *dummyController) HasSynced() bool {
0000000000000000000000000000000000000000;;		return v.informer.HasSynced()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *dummyController) LastSyncResourceVersion() string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type updateNotification struct {
0000000000000000000000000000000000000000;;		oldObj interface{}
0000000000000000000000000000000000000000;;		newObj interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type addNotification struct {
0000000000000000000000000000000000000000;;		newObj interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deleteNotification struct {
0000000000000000000000000000000000000000;;		oldObj interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) Run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, nil, s.indexer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := &Config{
0000000000000000000000000000000000000000;;			Queue:            fifo,
0000000000000000000000000000000000000000;;			ListerWatcher:    s.listerWatcher,
0000000000000000000000000000000000000000;;			ObjectType:       s.objectType,
0000000000000000000000000000000000000000;;			FullResyncPeriod: s.resyncCheckPeriod,
0000000000000000000000000000000000000000;;			RetryOnError:     false,
0000000000000000000000000000000000000000;;			ShouldResync:     s.processor.shouldResync,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Process: s.HandleDeltas,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func() {
0000000000000000000000000000000000000000;;			s.startedLock.Lock()
0000000000000000000000000000000000000000;;			defer s.startedLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.controller = New(cfg)
0000000000000000000000000000000000000000;;			s.controller.(*controller).clock = s.clock
0000000000000000000000000000000000000000;;			s.started = true
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.stopCh = stopCh
0000000000000000000000000000000000000000;;		s.cacheMutationDetector.Run(stopCh)
0000000000000000000000000000000000000000;;		s.processor.run(stopCh)
0000000000000000000000000000000000000000;;		s.controller.Run(stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) isStarted() bool {
0000000000000000000000000000000000000000;;		s.startedLock.Lock()
0000000000000000000000000000000000000000;;		defer s.startedLock.Unlock()
0000000000000000000000000000000000000000;;		return s.started
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) HasSynced() bool {
0000000000000000000000000000000000000000;;		s.startedLock.Lock()
0000000000000000000000000000000000000000;;		defer s.startedLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.controller == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.controller.HasSynced()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) LastSyncResourceVersion() string {
0000000000000000000000000000000000000000;;		s.startedLock.Lock()
0000000000000000000000000000000000000000;;		defer s.startedLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.controller == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.controller.LastSyncResourceVersion()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) GetStore() Store {
0000000000000000000000000000000000000000;;		return s.indexer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) GetIndexer() Indexer {
0000000000000000000000000000000000000000;;		return s.indexer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) AddIndexers(indexers Indexers) error {
0000000000000000000000000000000000000000;;		s.startedLock.Lock()
0000000000000000000000000000000000000000;;		defer s.startedLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.started {
0000000000000000000000000000000000000000;;			return fmt.Errorf("informer has already started")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.indexer.AddIndexers(indexers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) GetController() Controller {
0000000000000000000000000000000000000000;;		return &dummyController{informer: s}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) AddEventHandler(handler ResourceEventHandler) {
0000000000000000000000000000000000000000;;		s.AddEventHandlerWithResyncPeriod(handler, s.defaultEventHandlerResyncPeriod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func determineResyncPeriod(desired, check time.Duration) time.Duration {
0000000000000000000000000000000000000000;;		if desired == 0 {
0000000000000000000000000000000000000000;;			return desired
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if check == 0 {
0000000000000000000000000000000000000000;;			glog.Warningf("The specified resyncPeriod %v is invalid because this shared informer doesn't support resyncing", desired)
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if desired < check {
0000000000000000000000000000000000000000;;			glog.Warningf("The specified resyncPeriod %v is being increased to the minimum resyncCheckPeriod %v", desired, check)
0000000000000000000000000000000000000000;;			return check
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return desired
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const minimumResyncPeriod = 1 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration) {
0000000000000000000000000000000000000000;;		s.startedLock.Lock()
0000000000000000000000000000000000000000;;		defer s.startedLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resyncPeriod > 0 {
0000000000000000000000000000000000000000;;			if resyncPeriod < minimumResyncPeriod {
0000000000000000000000000000000000000000;;				glog.Warningf("resyncPeriod %d is too small. Changing it to the minimum allowed value of %d", resyncPeriod, minimumResyncPeriod)
0000000000000000000000000000000000000000;;				resyncPeriod = minimumResyncPeriod
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if resyncPeriod < s.resyncCheckPeriod {
0000000000000000000000000000000000000000;;				if s.started {
0000000000000000000000000000000000000000;;					glog.Warningf("resyncPeriod %d is smaller than resyncCheckPeriod %d and the informer has already started. Changing it to %d", resyncPeriod, s.resyncCheckPeriod, s.resyncCheckPeriod)
0000000000000000000000000000000000000000;;					resyncPeriod = s.resyncCheckPeriod
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// if the event handler's resyncPeriod is smaller than the current resyncCheckPeriod, update
0000000000000000000000000000000000000000;;					// resyncCheckPeriod to match resyncPeriod and adjust the resync periods of all the listeners
0000000000000000000000000000000000000000;;					// accordingly
0000000000000000000000000000000000000000;;					s.resyncCheckPeriod = resyncPeriod
0000000000000000000000000000000000000000;;					s.processor.resyncCheckPeriodChanged(resyncPeriod)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listener := newProcessListener(handler, resyncPeriod, determineResyncPeriod(resyncPeriod, s.resyncCheckPeriod), s.clock.Now())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.started {
0000000000000000000000000000000000000000;;			s.processor.addListener(listener)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// in order to safely join, we have to
0000000000000000000000000000000000000000;;		// 1. stop sending add/update/delete notifications
0000000000000000000000000000000000000000;;		// 2. do a list against the store
0000000000000000000000000000000000000000;;		// 3. send synthetic "Add" events to the new handler
0000000000000000000000000000000000000000;;		// 4. unblock
0000000000000000000000000000000000000000;;		s.blockDeltas.Lock()
0000000000000000000000000000000000000000;;		defer s.blockDeltas.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.processor.addListener(listener)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go listener.run(s.stopCh)
0000000000000000000000000000000000000000;;		go listener.pop(s.stopCh)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		items := s.indexer.List()
0000000000000000000000000000000000000000;;		for i := range items {
0000000000000000000000000000000000000000;;			listener.add(addNotification{newObj: items[i]})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *sharedIndexInformer) HandleDeltas(obj interface{}) error {
0000000000000000000000000000000000000000;;		s.blockDeltas.Lock()
0000000000000000000000000000000000000000;;		defer s.blockDeltas.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// from oldest to newest
0000000000000000000000000000000000000000;;		for _, d := range obj.(Deltas) {
0000000000000000000000000000000000000000;;			switch d.Type {
0000000000000000000000000000000000000000;;			case Sync, Added, Updated:
0000000000000000000000000000000000000000;;				isSync := d.Type == Sync
0000000000000000000000000000000000000000;;				s.cacheMutationDetector.AddObject(d.Object)
0000000000000000000000000000000000000000;;				if old, exists, err := s.indexer.Get(d.Object); err == nil && exists {
0000000000000000000000000000000000000000;;					if err := s.indexer.Update(d.Object); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					s.processor.distribute(updateNotification{oldObj: old, newObj: d.Object}, isSync)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if err := s.indexer.Add(d.Object); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					s.processor.distribute(addNotification{newObj: d.Object}, isSync)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case Deleted:
0000000000000000000000000000000000000000;;				if err := s.indexer.Delete(d.Object); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s.processor.distribute(deleteNotification{oldObj: d.Object}, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sharedProcessor struct {
0000000000000000000000000000000000000000;;		listenersLock    sync.RWMutex
0000000000000000000000000000000000000000;;		listeners        []*processorListener
0000000000000000000000000000000000000000;;		syncingListeners []*processorListener
0000000000000000000000000000000000000000;;		clock            clock.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sharedProcessor) addListener(listener *processorListener) {
0000000000000000000000000000000000000000;;		p.listenersLock.Lock()
0000000000000000000000000000000000000000;;		defer p.listenersLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.listeners = append(p.listeners, listener)
0000000000000000000000000000000000000000;;		p.syncingListeners = append(p.syncingListeners, listener)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sharedProcessor) distribute(obj interface{}, sync bool) {
0000000000000000000000000000000000000000;;		p.listenersLock.RLock()
0000000000000000000000000000000000000000;;		defer p.listenersLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sync {
0000000000000000000000000000000000000000;;			for _, listener := range p.syncingListeners {
0000000000000000000000000000000000000000;;				listener.add(obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for _, listener := range p.listeners {
0000000000000000000000000000000000000000;;				listener.add(obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sharedProcessor) run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		p.listenersLock.RLock()
0000000000000000000000000000000000000000;;		defer p.listenersLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, listener := range p.listeners {
0000000000000000000000000000000000000000;;			go listener.run(stopCh)
0000000000000000000000000000000000000000;;			go listener.pop(stopCh)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldResync queries every listener to determine if any of them need a resync, based on each
0000000000000000000000000000000000000000;;	// listener's resyncPeriod.
0000000000000000000000000000000000000000;;	func (p *sharedProcessor) shouldResync() bool {
0000000000000000000000000000000000000000;;		p.listenersLock.Lock()
0000000000000000000000000000000000000000;;		defer p.listenersLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.syncingListeners = []*processorListener{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resyncNeeded := false
0000000000000000000000000000000000000000;;		now := p.clock.Now()
0000000000000000000000000000000000000000;;		for _, listener := range p.listeners {
0000000000000000000000000000000000000000;;			// need to loop through all the listeners to see if they need to resync so we can prepare any
0000000000000000000000000000000000000000;;			// listeners that are going to be resyncing.
0000000000000000000000000000000000000000;;			if listener.shouldResync(now) {
0000000000000000000000000000000000000000;;				resyncNeeded = true
0000000000000000000000000000000000000000;;				p.syncingListeners = append(p.syncingListeners, listener)
0000000000000000000000000000000000000000;;				listener.determineNextResync(now)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resyncNeeded
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *sharedProcessor) resyncCheckPeriodChanged(resyncCheckPeriod time.Duration) {
0000000000000000000000000000000000000000;;		p.listenersLock.RLock()
0000000000000000000000000000000000000000;;		defer p.listenersLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, listener := range p.listeners {
0000000000000000000000000000000000000000;;			resyncPeriod := determineResyncPeriod(listener.requestedResyncPeriod, resyncCheckPeriod)
0000000000000000000000000000000000000000;;			listener.setResyncPeriod(resyncPeriod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type processorListener struct {
0000000000000000000000000000000000000000;;		// lock/cond protects access to 'pendingNotifications'.
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;		cond sync.Cond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pendingNotifications is an unbounded slice that holds all notifications not yet distributed
0000000000000000000000000000000000000000;;		// there is one per listener, but a failing/stalled listener will have infinite pendingNotifications
0000000000000000000000000000000000000000;;		// added until we OOM.
0000000000000000000000000000000000000000;;		// TODO This is no worse that before, since reflectors were backed by unbounded DeltaFIFOs, but
0000000000000000000000000000000000000000;;		// we should try to do something better
0000000000000000000000000000000000000000;;		pendingNotifications []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nextCh chan interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler ResourceEventHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// requestedResyncPeriod is how frequently the listener wants a full resync from the shared informer
0000000000000000000000000000000000000000;;		requestedResyncPeriod time.Duration
0000000000000000000000000000000000000000;;		// resyncPeriod is how frequently the listener wants a full resync from the shared informer. This
0000000000000000000000000000000000000000;;		// value may differ from requestedResyncPeriod if the shared informer adjusts it to align with the
0000000000000000000000000000000000000000;;		// informer's overall resync check period.
0000000000000000000000000000000000000000;;		resyncPeriod time.Duration
0000000000000000000000000000000000000000;;		// nextResync is the earliest time the listener should get a full resync
0000000000000000000000000000000000000000;;		nextResync time.Time
0000000000000000000000000000000000000000;;		// resyncLock guards access to resyncPeriod and nextResync
0000000000000000000000000000000000000000;;		resyncLock sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newProcessListener(handler ResourceEventHandler, requestedResyncPeriod, resyncPeriod time.Duration, now time.Time) *processorListener {
0000000000000000000000000000000000000000;;		ret := &processorListener{
0000000000000000000000000000000000000000;;			pendingNotifications:  []interface{}{},
0000000000000000000000000000000000000000;;			nextCh:                make(chan interface{}),
0000000000000000000000000000000000000000;;			handler:               handler,
0000000000000000000000000000000000000000;;			requestedResyncPeriod: requestedResyncPeriod,
0000000000000000000000000000000000000000;;			resyncPeriod:          resyncPeriod,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret.cond.L = &ret.lock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret.determineNextResync(now)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *processorListener) add(notification interface{}) {
0000000000000000000000000000000000000000;;		p.lock.Lock()
0000000000000000000000000000000000000000;;		defer p.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.pendingNotifications = append(p.pendingNotifications, notification)
0000000000000000000000000000000000000000;;		p.cond.Broadcast()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *processorListener) pop(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			blockingGet := func() (interface{}, bool) {
0000000000000000000000000000000000000000;;				p.lock.Lock()
0000000000000000000000000000000000000000;;				defer p.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for len(p.pendingNotifications) == 0 {
0000000000000000000000000000000000000000;;					// check if we're shutdown
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case <-stopCh:
0000000000000000000000000000000000000000;;						return nil, true
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					p.cond.Wait()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nt := p.pendingNotifications[0]
0000000000000000000000000000000000000000;;				p.pendingNotifications = p.pendingNotifications[1:]
0000000000000000000000000000000000000000;;				return nt, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			notification, stopped := blockingGet()
0000000000000000000000000000000000000000;;			if stopped {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case p.nextCh <- notification:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *processorListener) run(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		defer utilruntime.HandleCrash()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var next interface{}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				func() {
0000000000000000000000000000000000000000;;					p.lock.Lock()
0000000000000000000000000000000000000000;;					defer p.lock.Unlock()
0000000000000000000000000000000000000000;;					p.cond.Broadcast()
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case next = <-p.nextCh:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch notification := next.(type) {
0000000000000000000000000000000000000000;;			case updateNotification:
0000000000000000000000000000000000000000;;				p.handler.OnUpdate(notification.oldObj, notification.newObj)
0000000000000000000000000000000000000000;;			case addNotification:
0000000000000000000000000000000000000000;;				p.handler.OnAdd(notification.newObj)
0000000000000000000000000000000000000000;;			case deleteNotification:
0000000000000000000000000000000000000000;;				p.handler.OnDelete(notification.oldObj)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				utilruntime.HandleError(fmt.Errorf("unrecognized notification: %#v", next))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldResync deterimines if the listener needs a resync. If the listener's resyncPeriod is 0,
0000000000000000000000000000000000000000;;	// this always returns false.
0000000000000000000000000000000000000000;;	func (p *processorListener) shouldResync(now time.Time) bool {
0000000000000000000000000000000000000000;;		p.resyncLock.Lock()
0000000000000000000000000000000000000000;;		defer p.resyncLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.resyncPeriod == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return now.After(p.nextResync) || now.Equal(p.nextResync)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *processorListener) determineNextResync(now time.Time) {
0000000000000000000000000000000000000000;;		p.resyncLock.Lock()
0000000000000000000000000000000000000000;;		defer p.resyncLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.nextResync = now.Add(p.resyncPeriod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *processorListener) setResyncPeriod(resyncPeriod time.Duration) {
0000000000000000000000000000000000000000;;		p.resyncLock.Lock()
0000000000000000000000000000000000000000;;		defer p.resyncLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.resyncPeriod = resyncPeriod
0000000000000000000000000000000000000000;;	}
