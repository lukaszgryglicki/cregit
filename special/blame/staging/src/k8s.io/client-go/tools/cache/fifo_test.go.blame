0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/fifo_test.go[staging/src/k8s.io/client-go/1.4/tools/cache/fifo_test.go][staging/src/k8s.io/client-go/tools/cache/fifo_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testFifoObjectKeyFunc(obj interface{}) (string, error) {
0000000000000000000000000000000000000000;;		return obj.(testFifoObject).name, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testFifoObject struct {
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		val  interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mkFifoObj(name string, val interface{}) testFifoObject {
0000000000000000000000000000000000000000;;		return testFifoObject{name: name, val: val}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFIFO_basic(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewFIFO(testFifoObjectKeyFunc)
0000000000000000000000000000000000000000;;		const amount = 500
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for i := 0; i < amount; i++ {
0000000000000000000000000000000000000000;;				f.Add(mkFifoObj(string([]rune{'a', rune(i)}), i+1))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for u := uint64(0); u < amount; u++ {
0000000000000000000000000000000000000000;;				f.Add(mkFifoObj(string([]rune{'b', rune(u)}), u+1))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lastInt := int(0)
0000000000000000000000000000000000000000;;		lastUint := uint64(0)
0000000000000000000000000000000000000000;;		for i := 0; i < amount*2; i++ {
0000000000000000000000000000000000000000;;			switch obj := Pop(f).(testFifoObject).val.(type) {
0000000000000000000000000000000000000000;;			case int:
0000000000000000000000000000000000000000;;				if obj <= lastInt {
0000000000000000000000000000000000000000;;					t.Errorf("got %v (int) out of order, last was %v", obj, lastInt)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lastInt = obj
0000000000000000000000000000000000000000;;			case uint64:
0000000000000000000000000000000000000000;;				if obj <= lastUint {
0000000000000000000000000000000000000000;;					t.Errorf("got %v (uint) out of order, last was %v", obj, lastUint)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					lastUint = obj
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected type %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFIFO_requeueOnPop(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewFIFO(testFifoObjectKeyFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		_, err := f.Pop(func(obj interface{}) error {
0000000000000000000000000000000000000000;;			if obj.(testFifoObject).name != "foo" {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ErrRequeue{Err: nil}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok, err := f.GetByKey("foo"); !ok || err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("object should have been requeued: %t %v", ok, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = f.Pop(func(obj interface{}) error {
0000000000000000000000000000000000000000;;			if obj.(testFifoObject).name != "foo" {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ErrRequeue{Err: fmt.Errorf("test error")}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == nil || err.Error() != "test error" {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok, err := f.GetByKey("foo"); !ok || err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("object should have been requeued: %t %v", ok, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = f.Pop(func(obj interface{}) error {
0000000000000000000000000000000000000000;;			if obj.(testFifoObject).name != "foo" {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok, err := f.GetByKey("foo"); ok || err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("object should have been removed: %t %v", ok, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFIFO_addUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewFIFO(testFifoObjectKeyFunc)
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		f.Update(mkFifoObj("foo", 15))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := []interface{}{mkFifoObj("foo", 15)}, f.List(); !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %+v, got %+v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := []string{"foo"}, f.ListKeys(); !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %+v, got %+v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got := make(chan testFifoObject, 2)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				got <- Pop(f).(testFifoObject)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		first := <-got
0000000000000000000000000000000000000000;;		if e, a := 15, first.val; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't get updated value (%v), got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case unexpected := <-got:
0000000000000000000000000000000000000000;;			t.Errorf("Got second value %v", unexpected.val)
0000000000000000000000000000000000000000;;		case <-time.After(50 * time.Millisecond):
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, exists, _ := f.Get(mkFifoObj("foo", ""))
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Errorf("item did not get removed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFIFO_addReplace(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewFIFO(testFifoObjectKeyFunc)
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		f.Replace([]interface{}{mkFifoObj("foo", 15)}, "15")
0000000000000000000000000000000000000000;;		got := make(chan testFifoObject, 2)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				got <- Pop(f).(testFifoObject)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		first := <-got
0000000000000000000000000000000000000000;;		if e, a := 15, first.val; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't get updated value (%v), got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case unexpected := <-got:
0000000000000000000000000000000000000000;;			t.Errorf("Got second value %v", unexpected.val)
0000000000000000000000000000000000000000;;		case <-time.After(50 * time.Millisecond):
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, exists, _ := f.Get(mkFifoObj("foo", ""))
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Errorf("item did not get removed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFIFO_detectLineJumpers(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewFIFO(testFifoObjectKeyFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("bar", 1))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 11))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 13))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("zab", 30))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 13, Pop(f).(testFifoObject).val; a != e {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 14)) // ensure foo doesn't jump back in line
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 1, Pop(f).(testFifoObject).val; a != e {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 30, Pop(f).(testFifoObject).val; a != e {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 14, Pop(f).(testFifoObject).val; a != e {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFIFO_addIfNotPresent(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewFIFO(testFifoObjectKeyFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("a", 1))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("b", 2))
0000000000000000000000000000000000000000;;		f.AddIfNotPresent(mkFifoObj("b", 3))
0000000000000000000000000000000000000000;;		f.AddIfNotPresent(mkFifoObj("c", 4))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 3, len(f.items); a != e {
0000000000000000000000000000000000000000;;			t.Fatalf("expected queue length %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedValues := []int{1, 2, 4}
0000000000000000000000000000000000000000;;		for _, expected := range expectedValues {
0000000000000000000000000000000000000000;;			if actual := Pop(f).(testFifoObject).val; actual != expected {
0000000000000000000000000000000000000000;;				t.Fatalf("expected value %d, got %d", expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestFIFO_HasSynced(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			actions        []func(f *FIFO)
0000000000000000000000000000000000000000;;			expectedSynced bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions:        []func(f *FIFO){},
0000000000000000000000000000000000000000;;				expectedSynced: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions: []func(f *FIFO){
0000000000000000000000000000000000000000;;					func(f *FIFO) { f.Add(mkFifoObj("a", 1)) },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSynced: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions: []func(f *FIFO){
0000000000000000000000000000000000000000;;					func(f *FIFO) { f.Replace([]interface{}{}, "0") },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSynced: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions: []func(f *FIFO){
0000000000000000000000000000000000000000;;					func(f *FIFO) { f.Replace([]interface{}{mkFifoObj("a", 1), mkFifoObj("b", 2)}, "0") },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSynced: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions: []func(f *FIFO){
0000000000000000000000000000000000000000;;					func(f *FIFO) { f.Replace([]interface{}{mkFifoObj("a", 1), mkFifoObj("b", 2)}, "0") },
0000000000000000000000000000000000000000;;					func(f *FIFO) { Pop(f) },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSynced: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions: []func(f *FIFO){
0000000000000000000000000000000000000000;;					func(f *FIFO) { f.Replace([]interface{}{mkFifoObj("a", 1), mkFifoObj("b", 2)}, "0") },
0000000000000000000000000000000000000000;;					func(f *FIFO) { Pop(f) },
0000000000000000000000000000000000000000;;					func(f *FIFO) { Pop(f) },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSynced: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			f := NewFIFO(testFifoObjectKeyFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, action := range test.actions {
0000000000000000000000000000000000000000;;				action(f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := test.expectedSynced, f.HasSynced(); a != e {
0000000000000000000000000000000000000000;;				t.Errorf("test case %v failed, expected: %v , got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
