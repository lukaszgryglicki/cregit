0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
1d1a70a7c4bce4e7fe7b5ea103d22ff74f7e9569;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		utilcache "k8s.io/apimachinery/pkg/util/cache"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MutationCache is able to take the result of update operations and stores them in an LRU
0000000000000000000000000000000000000000;;	// that can be used to provide a more current view of a requested object.  It requires interpreting
0000000000000000000000000000000000000000;;	// resourceVersions for comparisons.
0000000000000000000000000000000000000000;;	// Implementations must be thread-safe.
0000000000000000000000000000000000000000;;	// TODO find a way to layer this into an informer/lister
0000000000000000000000000000000000000000;;	type MutationCache interface {
0000000000000000000000000000000000000000;;		GetByKey(key string) (interface{}, bool, error)
0000000000000000000000000000000000000000;;		ByIndex(indexName, indexKey string) ([]interface{}, error)
0000000000000000000000000000000000000000;;		Mutation(interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResourceVersionComparator interface {
0000000000000000000000000000000000000000;;		CompareResourceVersion(lhs, rhs runtime.Object) int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewIntegerResourceVersionMutationCache returns a MutationCache that understands how to
0000000000000000000000000000000000000000;;	// deal with objects that have a resource version that:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   - is an integer
0000000000000000000000000000000000000000;;	//   - increases when updated
0000000000000000000000000000000000000000;;	//   - is comparable across the same resource in a namespace
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Most backends will have these semantics. Indexer may be nil. ttl controls how long an item
0000000000000000000000000000000000000000;;	// remains in the mutation cache before it is removed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If includeAdds is true, objects in the mutation cache will be returned even if they don't exist
0000000000000000000000000000000000000000;;	// in the underlying store. This is only safe if your use of the cache can handle mutation entries
0000000000000000000000000000000000000000;;	// remaining in the cache for up to ttl when mutations and deletes occur very closely in time.
0000000000000000000000000000000000000000;;	func NewIntegerResourceVersionMutationCache(backingCache Store, indexer Indexer, ttl time.Duration, includeAdds bool) MutationCache {
0000000000000000000000000000000000000000;;		return &mutationCache{
0000000000000000000000000000000000000000;;			backingCache:  backingCache,
0000000000000000000000000000000000000000;;			indexer:       indexer,
0000000000000000000000000000000000000000;;			mutationCache: utilcache.NewLRUExpireCache(100),
0000000000000000000000000000000000000000;;			comparator:    etcdObjectVersioner{},
0000000000000000000000000000000000000000;;			ttl:           ttl,
0000000000000000000000000000000000000000;;			includeAdds:   includeAdds,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mutationCache doesn't guarantee that it returns values added via Mutation since they can page out and
0000000000000000000000000000000000000000;;	// since you can't distinguish between, "didn't observe create" and "was deleted after create",
0000000000000000000000000000000000000000;;	// if the key is missing from the backing cache, we always return it as missing
0000000000000000000000000000000000000000;;	type mutationCache struct {
0000000000000000000000000000000000000000;;		lock          sync.Mutex
0000000000000000000000000000000000000000;;		backingCache  Store
0000000000000000000000000000000000000000;;		indexer       Indexer
0000000000000000000000000000000000000000;;		mutationCache *utilcache.LRUExpireCache
0000000000000000000000000000000000000000;;		includeAdds   bool
0000000000000000000000000000000000000000;;		ttl           time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		comparator ResourceVersionComparator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetByKey is never guaranteed to return back the value set in Mutation.  It could be paged out, it could
0000000000000000000000000000000000000000;;	// be older than another copy, the backingCache may be more recent or, you might have written twice into the same key.
0000000000000000000000000000000000000000;;	// You get a value that was valid at some snapshot of time and will always return the newer of backingCache and mutationCache.
0000000000000000000000000000000000000000;;	func (c *mutationCache) GetByKey(key string) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj, exists, err := c.backingCache.GetByKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			if !c.includeAdds {
0000000000000000000000000000000000000000;;				// we can't distinguish between, "didn't observe create" and "was deleted after create", so
0000000000000000000000000000000000000000;;				// if the key is missing, we always return it as missing
0000000000000000000000000000000000000000;;				return nil, false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj, exists = c.mutationCache.Get(key)
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				return nil, false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		objRuntime, ok := obj.(runtime.Object)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return obj, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.newerObject(key, objRuntime), true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByIndex returns the newer objects that match the provided index and indexer key.
0000000000000000000000000000000000000000;;	// Will return an error if no indexer was provided.
0000000000000000000000000000000000000000;;	func (c *mutationCache) ByIndex(name string, indexKey string) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		if c.indexer == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no indexer has been provided to the mutation cache")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keys, err := c.indexer.IndexKeys(name, indexKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var items []interface{}
0000000000000000000000000000000000000000;;		keySet := sets.NewString()
0000000000000000000000000000000000000000;;		for _, key := range keys {
0000000000000000000000000000000000000000;;			keySet.Insert(key)
0000000000000000000000000000000000000000;;			obj, exists, err := c.indexer.GetByKey(key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if objRuntime, ok := obj.(runtime.Object); ok {
0000000000000000000000000000000000000000;;				items = append(items, c.newerObject(key, objRuntime))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				items = append(items, obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.includeAdds {
0000000000000000000000000000000000000000;;			fn := c.indexer.GetIndexers()[name]
0000000000000000000000000000000000000000;;			// Keys() is returned oldest to newest, so full traversal does not alter the LRU behavior
0000000000000000000000000000000000000000;;			for _, key := range c.mutationCache.Keys() {
0000000000000000000000000000000000000000;;				updated, ok := c.mutationCache.Get(key)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if keySet.Has(key.(string)) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				elements, err := fn(updated)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("Unable to calculate an index entry for mutation cache entry %s: %v", key, err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, inIndex := range elements {
0000000000000000000000000000000000000000;;					if inIndex != indexKey {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					items = append(items, updated)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return items, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newerObject checks the mutation cache for a newer object and returns one if found. If the
0000000000000000000000000000000000000000;;	// mutated object is older than the backing object, it is removed from the  Must be
0000000000000000000000000000000000000000;;	// called while the lock is held.
0000000000000000000000000000000000000000;;	func (c *mutationCache) newerObject(key string, backing runtime.Object) runtime.Object {
0000000000000000000000000000000000000000;;		mutatedObj, exists := c.mutationCache.Get(key)
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return backing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mutatedObjRuntime, ok := mutatedObj.(runtime.Object)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return backing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.comparator.CompareResourceVersion(backing, mutatedObjRuntime) >= 0 {
0000000000000000000000000000000000000000;;			c.mutationCache.Remove(key)
0000000000000000000000000000000000000000;;			return backing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mutatedObjRuntime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mutation adds a change to the cache that can be returned in GetByKey if it is newer than the backingCache
0000000000000000000000000000000000000000;;	// copy.  If you call Mutation twice with the same object on different threads, one will win, but its not defined
0000000000000000000000000000000000000000;;	// which one.  This doesn't affect correctness, since the GetByKey guaranteed of "later of these two caches" is
0000000000000000000000000000000000000000;;	// preserved, but you may not get the version of the object you want.  The object you get is only guaranteed to
0000000000000000000000000000000000000000;;	// "one that was valid at some point in time", not "the one that I want".
0000000000000000000000000000000000000000;;	func (c *mutationCache) Mutation(obj interface{}) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key, err := DeletionHandlingMetaNamespaceKeyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// this is a "nice to have", so failures shouldn't do anything weird
0000000000000000000000000000000000000000;;			utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if objRuntime, ok := obj.(runtime.Object); ok {
0000000000000000000000000000000000000000;;			if mutatedObj, exists := c.mutationCache.Get(key); exists {
0000000000000000000000000000000000000000;;				if mutatedObjRuntime, ok := mutatedObj.(runtime.Object); ok {
0000000000000000000000000000000000000000;;					if c.comparator.CompareResourceVersion(objRuntime, mutatedObjRuntime) < 0 {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.mutationCache.Add(key, obj, c.ttl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// etcdObjectVersioner implements versioning and extracting etcd node information
0000000000000000000000000000000000000000;;	// for objects that have an embedded ObjectMeta or ListMeta field.
0000000000000000000000000000000000000000;;	type etcdObjectVersioner struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectResourceVersion implements Versioner
0000000000000000000000000000000000000000;;	func (a etcdObjectVersioner) ObjectResourceVersion(obj runtime.Object) (uint64, error) {
0000000000000000000000000000000000000000;;		accessor, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version := accessor.GetResourceVersion()
0000000000000000000000000000000000000000;;		if len(version) == 0 {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.ParseUint(version, 10, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompareResourceVersion compares etcd resource versions.  Outside this API they are all strings,
0000000000000000000000000000000000000000;;	// but etcd resource versions are special, they're actually ints, so we can easily compare them.
0000000000000000000000000000000000000000;;	func (a etcdObjectVersioner) CompareResourceVersion(lhs, rhs runtime.Object) int {
0000000000000000000000000000000000000000;;		lhsVersion, err := a.ObjectResourceVersion(lhs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// coder error
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rhsVersion, err := a.ObjectResourceVersion(rhs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// coder error
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if lhsVersion == rhsVersion {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lhsVersion < rhsVersion {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 1
0000000000000000000000000000000000000000;;	}
