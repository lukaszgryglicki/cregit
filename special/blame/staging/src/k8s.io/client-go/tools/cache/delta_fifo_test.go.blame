0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/delta_fifo_test.go[staging/src/k8s.io/client-go/1.4/tools/cache/delta_fifo_test.go][staging/src/k8s.io/client-go/tools/cache/delta_fifo_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// helper function to reduce stuttering
0000000000000000000000000000000000000000;;	func testPop(f *DeltaFIFO) testFifoObject {
0000000000000000000000000000000000000000;;		return Pop(f).(Deltas).Newest().Object.(testFifoObject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keyLookupFunc adapts a raw function to be a KeyLookup.
0000000000000000000000000000000000000000;;	type keyLookupFunc func() []testFifoObject
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListKeys just calls kl.
0000000000000000000000000000000000000000;;	func (kl keyLookupFunc) ListKeys() []string {
0000000000000000000000000000000000000000;;		result := []string{}
0000000000000000000000000000000000000000;;		for _, fifoObj := range kl() {
0000000000000000000000000000000000000000;;			result = append(result, fifoObj.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetByKey returns the key if it exists in the list returned by kl.
0000000000000000000000000000000000000000;;	func (kl keyLookupFunc) GetByKey(key string) (interface{}, bool, error) {
0000000000000000000000000000000000000000;;		for _, v := range kl() {
0000000000000000000000000000000000000000;;			if v.name == key {
0000000000000000000000000000000000000000;;				return v, true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_basic(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(testFifoObjectKeyFunc, nil, nil)
0000000000000000000000000000000000000000;;		const amount = 500
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for i := 0; i < amount; i++ {
0000000000000000000000000000000000000000;;				f.Add(mkFifoObj(string([]rune{'a', rune(i)}), i+1))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for u := uint64(0); u < amount; u++ {
0000000000000000000000000000000000000000;;				f.Add(mkFifoObj(string([]rune{'b', rune(u)}), u+1))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lastInt := int(0)
0000000000000000000000000000000000000000;;		lastUint := uint64(0)
0000000000000000000000000000000000000000;;		for i := 0; i < amount*2; i++ {
0000000000000000000000000000000000000000;;			switch obj := testPop(f).val.(type) {
0000000000000000000000000000000000000000;;			case int:
0000000000000000000000000000000000000000;;				if obj <= lastInt {
0000000000000000000000000000000000000000;;					t.Errorf("got %v (int) out of order, last was %v", obj, lastInt)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lastInt = obj
0000000000000000000000000000000000000000;;			case uint64:
0000000000000000000000000000000000000000;;				if obj <= lastUint {
0000000000000000000000000000000000000000;;					t.Errorf("got %v (uint) out of order, last was %v", obj, lastUint)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					lastUint = obj
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected type %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_requeueOnPop(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(testFifoObjectKeyFunc, nil, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		_, err := f.Pop(func(obj interface{}) error {
0000000000000000000000000000000000000000;;			if obj.(Deltas)[0].Object.(testFifoObject).name != "foo" {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ErrRequeue{Err: nil}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok, err := f.GetByKey("foo"); !ok || err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("object should have been requeued: %t %v", ok, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = f.Pop(func(obj interface{}) error {
0000000000000000000000000000000000000000;;			if obj.(Deltas)[0].Object.(testFifoObject).name != "foo" {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ErrRequeue{Err: fmt.Errorf("test error")}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err == nil || err.Error() != "test error" {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok, err := f.GetByKey("foo"); !ok || err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("object should have been requeued: %t %v", ok, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = f.Pop(func(obj interface{}) error {
0000000000000000000000000000000000000000;;			if obj.(Deltas)[0].Object.(testFifoObject).name != "foo" {
0000000000000000000000000000000000000000;;				t.Fatalf("unexpected object: %#v", obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected error: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok, err := f.GetByKey("foo"); ok || err != nil {
0000000000000000000000000000000000000000;;			t.Fatalf("object should have been removed: %t %v", ok, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_compressorWorks(t *testing.T) {
0000000000000000000000000000000000000000;;		oldestTypes := []DeltaType{}
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(
0000000000000000000000000000000000000000;;			testFifoObjectKeyFunc,
0000000000000000000000000000000000000000;;			// This function just keeps the most recent delta
0000000000000000000000000000000000000000;;			// and puts deleted ones in the list.
0000000000000000000000000000000000000000;;			DeltaCompressorFunc(func(d Deltas) Deltas {
0000000000000000000000000000000000000000;;				if n := len(d); n > 1 {
0000000000000000000000000000000000000000;;					oldestTypes = append(oldestTypes, d[0].Type)
0000000000000000000000000000000000000000;;					d = d[1:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return d
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if f.HasSynced() {
0000000000000000000000000000000000000000;;			t.Errorf("Expected HasSynced to be false before completion of initial population")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		f.Update(mkFifoObj("foo", 12))
0000000000000000000000000000000000000000;;		f.Replace([]interface{}{mkFifoObj("foo", 20)}, "0")
0000000000000000000000000000000000000000;;		f.Delete(mkFifoObj("foo", 22))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 25)) // flush the last one out
0000000000000000000000000000000000000000;;		expect := []DeltaType{Added, Updated, Sync, Deleted}
0000000000000000000000000000000000000000;;		if e, a := expect, oldestTypes; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := (Deltas{{Added, mkFifoObj("foo", 25)}}), Pop(f).(Deltas); !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !f.HasSynced() {
0000000000000000000000000000000000000000;;			t.Errorf("Expected HasSynced to be true after completion of initial population")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_addUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(testFifoObjectKeyFunc, nil, nil)
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		f.Update(mkFifoObj("foo", 12))
0000000000000000000000000000000000000000;;		f.Delete(mkFifoObj("foo", 15))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := []interface{}{mkFifoObj("foo", 15)}, f.List(); !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %+v, got %+v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := []string{"foo"}, f.ListKeys(); !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;			t.Errorf("Expected %+v, got %+v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		got := make(chan testFifoObject, 2)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				obj := testPop(f)
0000000000000000000000000000000000000000;;				t.Logf("got a thing %#v", obj)
0000000000000000000000000000000000000000;;				t.Logf("D len: %v", len(f.queue))
0000000000000000000000000000000000000000;;				got <- obj
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		first := <-got
0000000000000000000000000000000000000000;;		if e, a := 15, first.val; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't get updated value (%v), got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case unexpected := <-got:
0000000000000000000000000000000000000000;;			t.Errorf("Got second value %v", unexpected.val)
0000000000000000000000000000000000000000;;		case <-time.After(50 * time.Millisecond):
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, exists, _ := f.Get(mkFifoObj("foo", ""))
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Errorf("item did not get removed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_enqueueingNoLister(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(testFifoObjectKeyFunc, nil, nil)
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		f.Update(mkFifoObj("bar", 15))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("qux", 17))
0000000000000000000000000000000000000000;;		f.Delete(mkFifoObj("qux", 18))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This delete does not enqueue anything because baz doesn't exist.
0000000000000000000000000000000000000000;;		f.Delete(mkFifoObj("baz", 20))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectList := []int{10, 15, 18}
0000000000000000000000000000000000000000;;		for _, expect := range expectList {
0000000000000000000000000000000000000000;;			if e, a := expect, testPop(f).val; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Didn't get updated value (%v), got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 0, len(f.items); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("queue unexpectedly not empty: %v != %v\n%#v", e, a, f.items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_enqueueingWithLister(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(
0000000000000000000000000000000000000000;;			testFifoObjectKeyFunc,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			keyLookupFunc(func() []testFifoObject {
0000000000000000000000000000000000000000;;				return []testFifoObject{mkFifoObj("foo", 5), mkFifoObj("bar", 6), mkFifoObj("baz", 7)}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		f.Update(mkFifoObj("bar", 15))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This delete does enqueue the deletion, because "baz" is in the key lister.
0000000000000000000000000000000000000000;;		f.Delete(mkFifoObj("baz", 20))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectList := []int{10, 15, 20}
0000000000000000000000000000000000000000;;		for _, expect := range expectList {
0000000000000000000000000000000000000000;;			if e, a := expect, testPop(f).val; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Didn't get updated value (%v), got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 0, len(f.items); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("queue unexpectedly not empty: %v != %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_addReplace(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(testFifoObjectKeyFunc, nil, nil)
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		f.Replace([]interface{}{mkFifoObj("foo", 15)}, "0")
0000000000000000000000000000000000000000;;		got := make(chan testFifoObject, 2)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				got <- testPop(f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		first := <-got
0000000000000000000000000000000000000000;;		if e, a := 15, first.val; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("Didn't get updated value (%v), got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case unexpected := <-got:
0000000000000000000000000000000000000000;;			t.Errorf("Got second value %v", unexpected.val)
0000000000000000000000000000000000000000;;		case <-time.After(50 * time.Millisecond):
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, exists, _ := f.Get(mkFifoObj("foo", ""))
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			t.Errorf("item did not get removed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_ResyncNonExisting(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(
0000000000000000000000000000000000000000;;			testFifoObjectKeyFunc,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			keyLookupFunc(func() []testFifoObject {
0000000000000000000000000000000000000000;;				return []testFifoObject{mkFifoObj("foo", 5)}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		f.Delete(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		f.Resync()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deltas := f.items["foo"]
0000000000000000000000000000000000000000;;		if len(deltas) != 1 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected deltas length: %v", deltas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deltas[0].Type != Deleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected delta: %v", deltas[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_DeleteExistingNonPropagated(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(
0000000000000000000000000000000000000000;;			testFifoObjectKeyFunc,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			keyLookupFunc(func() []testFifoObject {
0000000000000000000000000000000000000000;;				return []testFifoObject{}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 5))
0000000000000000000000000000000000000000;;		f.Delete(mkFifoObj("foo", 6))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deltas := f.items["foo"]
0000000000000000000000000000000000000000;;		if len(deltas) != 2 {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected deltas length: %v", deltas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if deltas[len(deltas)-1].Type != Deleted {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected delta: %v", deltas[len(deltas)-1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_ReplaceMakesDeletions(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(
0000000000000000000000000000000000000000;;			testFifoObjectKeyFunc,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			keyLookupFunc(func() []testFifoObject {
0000000000000000000000000000000000000000;;				return []testFifoObject{mkFifoObj("foo", 5), mkFifoObj("bar", 6), mkFifoObj("baz", 7)}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		f.Delete(mkFifoObj("baz", 10))
0000000000000000000000000000000000000000;;		f.Replace([]interface{}{mkFifoObj("foo", 5)}, "0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedList := []Deltas{
0000000000000000000000000000000000000000;;			{{Deleted, mkFifoObj("baz", 10)}},
0000000000000000000000000000000000000000;;			{{Sync, mkFifoObj("foo", 5)}},
0000000000000000000000000000000000000000;;			// Since "bar" didn't have a delete event and wasn't in the Replace list
0000000000000000000000000000000000000000;;			// it should get a tombstone key with the right Obj.
0000000000000000000000000000000000000000;;			{{Deleted, DeletedFinalStateUnknown{Key: "bar", Obj: mkFifoObj("bar", 6)}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, expected := range expectedList {
0000000000000000000000000000000000000000;;			cur := Pop(f).(Deltas)
0000000000000000000000000000000000000000;;			if e, a := expected, cur; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_UpdateResyncRace(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(
0000000000000000000000000000000000000000;;			testFifoObjectKeyFunc,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			keyLookupFunc(func() []testFifoObject {
0000000000000000000000000000000000000000;;				return []testFifoObject{mkFifoObj("foo", 5)}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		f.Update(mkFifoObj("foo", 6))
0000000000000000000000000000000000000000;;		f.Resync()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedList := []Deltas{
0000000000000000000000000000000000000000;;			{{Updated, mkFifoObj("foo", 6)}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, expected := range expectedList {
0000000000000000000000000000000000000000;;			cur := Pop(f).(Deltas)
0000000000000000000000000000000000000000;;			if e, a := expected, cur; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_HasSyncedCorrectOnDeletion(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(
0000000000000000000000000000000000000000;;			testFifoObjectKeyFunc,
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			keyLookupFunc(func() []testFifoObject {
0000000000000000000000000000000000000000;;				return []testFifoObject{mkFifoObj("foo", 5), mkFifoObj("bar", 6), mkFifoObj("baz", 7)}
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		f.Replace([]interface{}{mkFifoObj("foo", 5)}, "0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedList := []Deltas{
0000000000000000000000000000000000000000;;			{{Sync, mkFifoObj("foo", 5)}},
0000000000000000000000000000000000000000;;			// Since "bar" didn't have a delete event and wasn't in the Replace list
0000000000000000000000000000000000000000;;			// it should get a tombstone key with the right Obj.
0000000000000000000000000000000000000000;;			{{Deleted, DeletedFinalStateUnknown{Key: "bar", Obj: mkFifoObj("bar", 6)}}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, expected := range expectedList {
0000000000000000000000000000000000000000;;			if f.HasSynced() {
0000000000000000000000000000000000000000;;				t.Errorf("Expected HasSynced to be false")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cur := Pop(f).(Deltas)
0000000000000000000000000000000000000000;;			if e, a := expected, cur; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %#v, got %#v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.HasSynced() {
0000000000000000000000000000000000000000;;			t.Errorf("Expected HasSynced to be true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_detectLineJumpers(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(testFifoObjectKeyFunc, nil, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 10))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("bar", 1))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 11))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 13))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("zab", 30))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 13, testPop(f).val; a != e {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("foo", 14)) // ensure foo doesn't jump back in line
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 1, testPop(f).val; a != e {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 30, testPop(f).val; a != e {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 14, testPop(f).val; a != e {
0000000000000000000000000000000000000000;;			t.Fatalf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_addIfNotPresent(t *testing.T) {
0000000000000000000000000000000000000000;;		f := NewDeltaFIFO(testFifoObjectKeyFunc, nil, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("b", 3))
0000000000000000000000000000000000000000;;		b3 := Pop(f)
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("c", 4))
0000000000000000000000000000000000000000;;		c4 := Pop(f)
0000000000000000000000000000000000000000;;		if e, a := 0, len(f.items); e != a {
0000000000000000000000000000000000000000;;			t.Fatalf("Expected %v, got %v items in queue", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("a", 1))
0000000000000000000000000000000000000000;;		f.Add(mkFifoObj("b", 2))
0000000000000000000000000000000000000000;;		f.AddIfNotPresent(b3)
0000000000000000000000000000000000000000;;		f.AddIfNotPresent(c4)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e, a := 3, len(f.items); a != e {
0000000000000000000000000000000000000000;;			t.Fatalf("expected queue length %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedValues := []int{1, 2, 4}
0000000000000000000000000000000000000000;;		for _, expected := range expectedValues {
0000000000000000000000000000000000000000;;			if actual := testPop(f).val; actual != expected {
0000000000000000000000000000000000000000;;				t.Fatalf("expected value %d, got %d", expected, actual)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_KeyOf(t *testing.T) {
0000000000000000000000000000000000000000;;		f := DeltaFIFO{keyFunc: testFifoObjectKeyFunc}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			obj interface{}
0000000000000000000000000000000000000000;;			key string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{obj: testFifoObject{name: "A"}, key: "A"},
0000000000000000000000000000000000000000;;			{obj: DeletedFinalStateUnknown{Key: "B", Obj: nil}, key: "B"},
0000000000000000000000000000000000000000;;			{obj: Deltas{{Object: testFifoObject{name: "C"}}}, key: "C"},
0000000000000000000000000000000000000000;;			{obj: Deltas{{Object: DeletedFinalStateUnknown{Key: "D", Obj: nil}}}, key: "D"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			got, err := f.KeyOf(item.obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("Unexpected error for %q: %v", item.obj, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.key, got; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("Expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestDeltaFIFO_HasSynced(t *testing.T) {
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			actions        []func(f *DeltaFIFO)
0000000000000000000000000000000000000000;;			expectedSynced bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions:        []func(f *DeltaFIFO){},
0000000000000000000000000000000000000000;;				expectedSynced: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions: []func(f *DeltaFIFO){
0000000000000000000000000000000000000000;;					func(f *DeltaFIFO) { f.Add(mkFifoObj("a", 1)) },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSynced: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions: []func(f *DeltaFIFO){
0000000000000000000000000000000000000000;;					func(f *DeltaFIFO) { f.Replace([]interface{}{}, "0") },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSynced: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions: []func(f *DeltaFIFO){
0000000000000000000000000000000000000000;;					func(f *DeltaFIFO) { f.Replace([]interface{}{mkFifoObj("a", 1), mkFifoObj("b", 2)}, "0") },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSynced: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions: []func(f *DeltaFIFO){
0000000000000000000000000000000000000000;;					func(f *DeltaFIFO) { f.Replace([]interface{}{mkFifoObj("a", 1), mkFifoObj("b", 2)}, "0") },
0000000000000000000000000000000000000000;;					func(f *DeltaFIFO) { Pop(f) },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSynced: false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				actions: []func(f *DeltaFIFO){
0000000000000000000000000000000000000000;;					func(f *DeltaFIFO) { f.Replace([]interface{}{mkFifoObj("a", 1), mkFifoObj("b", 2)}, "0") },
0000000000000000000000000000000000000000;;					func(f *DeltaFIFO) { Pop(f) },
0000000000000000000000000000000000000000;;					func(f *DeltaFIFO) { Pop(f) },
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectedSynced: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			f := NewDeltaFIFO(testFifoObjectKeyFunc, nil, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, action := range test.actions {
0000000000000000000000000000000000000000;;				action(f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := test.expectedSynced, f.HasSynced(); a != e {
0000000000000000000000000000000000000000;;				t.Errorf("test case %v failed, expected: %v , got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
