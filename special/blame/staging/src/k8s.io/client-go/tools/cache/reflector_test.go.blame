0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/reflector_test.go[staging/src/k8s.io/client-go/1.4/tools/cache/reflector_test.go][staging/src/k8s.io/client-go/tools/cache/reflector_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nevererrc chan error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testLW struct {
0000000000000000000000000000000000000000;;		ListFunc  func(options metav1.ListOptions) (runtime.Object, error)
0000000000000000000000000000000000000000;;		WatchFunc func(options metav1.ListOptions) (watch.Interface, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *testLW) List(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		return t.ListFunc(options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (t *testLW) Watch(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		return t.WatchFunc(options)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCloseWatchChannelOnError(t *testing.T) {
0000000000000000000000000000000000000000;;		r := NewReflector(&testLW{}, &v1.Pod{}, NewStore(MetaNamespaceKeyFunc), 0)
0000000000000000000000000000000000000000;;		pod := &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}}
0000000000000000000000000000000000000000;;		fw := watch.NewFake()
0000000000000000000000000000000000000000;;		r.listerWatcher = &testLW{
0000000000000000000000000000000000000000;;			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;				return fw, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return &v1.PodList{ListMeta: metav1.ListMeta{ResourceVersion: "1"}}, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go r.ListAndWatch(wait.NeverStop)
0000000000000000000000000000000000000000;;		fw.Error(pod)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case _, ok := <-fw.ResultChan():
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				t.Errorf("Watch channel left open after cancellation")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("the cancellation is at least %s late", wait.ForeverTestTimeout.String())
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestRunUntil(t *testing.T) {
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		store := NewStore(MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		r := NewReflector(&testLW{}, &v1.Pod{}, store, 0)
0000000000000000000000000000000000000000;;		fw := watch.NewFake()
0000000000000000000000000000000000000000;;		r.listerWatcher = &testLW{
0000000000000000000000000000000000000000;;			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;				return fw, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return &v1.PodList{ListMeta: metav1.ListMeta{ResourceVersion: "1"}}, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.RunUntil(stopCh)
0000000000000000000000000000000000000000;;		// Synchronously add a dummy pod into the watch channel so we
0000000000000000000000000000000000000000;;		// know the RunUntil go routine is in the watch handler.
0000000000000000000000000000000000000000;;		fw.Add(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}})
0000000000000000000000000000000000000000;;		close(stopCh)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case _, ok := <-fw.ResultChan():
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				t.Errorf("Watch channel left open after stopping the watch")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-time.After(wait.ForeverTestTimeout):
0000000000000000000000000000000000000000;;			t.Errorf("the cancellation is at least %s late", wait.ForeverTestTimeout.String())
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReflectorResyncChan(t *testing.T) {
0000000000000000000000000000000000000000;;		s := NewStore(MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		g := NewReflector(&testLW{}, &v1.Pod{}, s, time.Millisecond)
0000000000000000000000000000000000000000;;		a, _ := g.resyncChan()
0000000000000000000000000000000000000000;;		b := time.After(wait.ForeverTestTimeout)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-a:
0000000000000000000000000000000000000000;;			t.Logf("got timeout as expected")
0000000000000000000000000000000000000000;;		case <-b:
0000000000000000000000000000000000000000;;			t.Errorf("resyncChan() is at least 99 milliseconds late??")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BenchmarkReflectorResyncChanMany(b *testing.B) {
0000000000000000000000000000000000000000;;		s := NewStore(MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		g := NewReflector(&testLW{}, &v1.Pod{}, s, 25*time.Millisecond)
0000000000000000000000000000000000000000;;		// The improvement to this (calling the timer's Stop() method) makes
0000000000000000000000000000000000000000;;		// this benchmark about 40% faster.
0000000000000000000000000000000000000000;;		for i := 0; i < b.N; i++ {
0000000000000000000000000000000000000000;;			g.resyncPeriod = time.Duration(rand.Float64() * float64(time.Millisecond) * 25)
0000000000000000000000000000000000000000;;			_, stop := g.resyncChan()
0000000000000000000000000000000000000000;;			stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReflectorWatchHandlerError(t *testing.T) {
0000000000000000000000000000000000000000;;		s := NewStore(MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		g := NewReflector(&testLW{}, &v1.Pod{}, s, 0)
0000000000000000000000000000000000000000;;		fw := watch.NewFake()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			fw.Stop()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		var resumeRV string
0000000000000000000000000000000000000000;;		err := g.watchHandler(fw, &resumeRV, nevererrc, wait.NeverStop)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected non-error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReflectorWatchHandler(t *testing.T) {
0000000000000000000000000000000000000000;;		s := NewStore(MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		g := NewReflector(&testLW{}, &v1.Pod{}, s, 0)
0000000000000000000000000000000000000000;;		fw := watch.NewFake()
0000000000000000000000000000000000000000;;		s.Add(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})
0000000000000000000000000000000000000000;;		s.Add(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar"}})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			fw.Add(&v1.Service{ObjectMeta: metav1.ObjectMeta{Name: "rejected"}})
0000000000000000000000000000000000000000;;			fw.Delete(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "foo"}})
0000000000000000000000000000000000000000;;			fw.Modify(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "bar", ResourceVersion: "55"}})
0000000000000000000000000000000000000000;;			fw.Add(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "baz", ResourceVersion: "32"}})
0000000000000000000000000000000000000000;;			fw.Stop()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		var resumeRV string
0000000000000000000000000000000000000000;;		err := g.watchHandler(fw, &resumeRV, nevererrc, wait.NeverStop)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mkPod := func(id string, rv string) *v1.Pod {
0000000000000000000000000000000000000000;;			return &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: id, ResourceVersion: rv}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			Pod    *v1.Pod
0000000000000000000000000000000000000000;;			exists bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{mkPod("foo", ""), false},
0000000000000000000000000000000000000000;;			{mkPod("rejected", ""), false},
0000000000000000000000000000000000000000;;			{mkPod("bar", "55"), true},
0000000000000000000000000000000000000000;;			{mkPod("baz", "32"), true},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range table {
0000000000000000000000000000000000000000;;			obj, exists, _ := s.Get(item.Pod)
0000000000000000000000000000000000000000;;			if e, a := item.exists, exists; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %v, got %v", item.Pod, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := item.Pod.ResourceVersion, obj.(*v1.Pod).ResourceVersion; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: expected %v, got %v", item.Pod, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RV should send the last version we see.
0000000000000000000000000000000000000000;;		if e, a := "32", resumeRV; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// last sync resource version should be the last version synced with store
0000000000000000000000000000000000000000;;		if e, a := "32", g.LastSyncResourceVersion(); e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %v, got %v", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReflectorStopWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		s := NewStore(MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		g := NewReflector(&testLW{}, &v1.Pod{}, s, 0)
0000000000000000000000000000000000000000;;		fw := watch.NewFake()
0000000000000000000000000000000000000000;;		var resumeRV string
0000000000000000000000000000000000000000;;		stopWatch := make(chan struct{}, 1)
0000000000000000000000000000000000000000;;		stopWatch <- struct{}{}
0000000000000000000000000000000000000000;;		err := g.watchHandler(fw, &resumeRV, nevererrc, stopWatch)
0000000000000000000000000000000000000000;;		if err != errorStopRequested {
0000000000000000000000000000000000000000;;			t.Errorf("expected stop error, got %q", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReflectorListAndWatch(t *testing.T) {
0000000000000000000000000000000000000000;;		createdFakes := make(chan *watch.FakeWatcher)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The ListFunc says that it's at revision 1. Therefore, we expect our WatchFunc
0000000000000000000000000000000000000000;;		// to get called at the beginning of the watch with 1, and again with 3 when we
0000000000000000000000000000000000000000;;		// inject an error.
0000000000000000000000000000000000000000;;		expectedRVs := []string{"1", "3"}
0000000000000000000000000000000000000000;;		lw := &testLW{
0000000000000000000000000000000000000000;;			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;				rv := options.ResourceVersion
0000000000000000000000000000000000000000;;				fw := watch.NewFake()
0000000000000000000000000000000000000000;;				if e, a := expectedRVs[0], rv; e != a {
0000000000000000000000000000000000000000;;					t.Errorf("Expected rv %v, but got %v", e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				expectedRVs = expectedRVs[1:]
0000000000000000000000000000000000000000;;				// channel is not buffered because the for loop below needs to block. But
0000000000000000000000000000000000000000;;				// we don't want to block here, so report the new fake via a go routine.
0000000000000000000000000000000000000000;;				go func() { createdFakes <- fw }()
0000000000000000000000000000000000000000;;				return fw, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return &v1.PodList{ListMeta: metav1.ListMeta{ResourceVersion: "1"}}, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := NewFIFO(MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		r := NewReflector(lw, &v1.Pod{}, s, 0)
0000000000000000000000000000000000000000;;		go r.ListAndWatch(wait.NeverStop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ids := []string{"foo", "bar", "baz", "qux", "zoo"}
0000000000000000000000000000000000000000;;		var fw *watch.FakeWatcher
0000000000000000000000000000000000000000;;		for i, id := range ids {
0000000000000000000000000000000000000000;;			if fw == nil {
0000000000000000000000000000000000000000;;				fw = <-createdFakes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sendingRV := strconv.FormatUint(uint64(i+2), 10)
0000000000000000000000000000000000000000;;			fw.Add(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: id, ResourceVersion: sendingRV}})
0000000000000000000000000000000000000000;;			if sendingRV == "3" {
0000000000000000000000000000000000000000;;				// Inject a failure.
0000000000000000000000000000000000000000;;				fw.Stop()
0000000000000000000000000000000000000000;;				fw = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify we received the right ids with the right resource versions.
0000000000000000000000000000000000000000;;		for i, id := range ids {
0000000000000000000000000000000000000000;;			pod := Pop(s).(*v1.Pod)
0000000000000000000000000000000000000000;;			if e, a := id, pod.Name; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Expected %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := strconv.FormatUint(uint64(i+2), 10), pod.ResourceVersion; e != a {
0000000000000000000000000000000000000000;;				t.Errorf("%v: Expected %v, got %v", i, e, a)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(expectedRVs) != 0 {
0000000000000000000000000000000000000000;;			t.Error("called watchStarter an unexpected number of times")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReflectorListAndWatchWithErrors(t *testing.T) {
0000000000000000000000000000000000000000;;		mkPod := func(id string, rv string) *v1.Pod {
0000000000000000000000000000000000000000;;			return &v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: id, ResourceVersion: rv}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mkList := func(rv string, pods ...*v1.Pod) *v1.PodList {
0000000000000000000000000000000000000000;;			list := &v1.PodList{ListMeta: metav1.ListMeta{ResourceVersion: rv}}
0000000000000000000000000000000000000000;;			for _, pod := range pods {
0000000000000000000000000000000000000000;;				list.Items = append(list.Items, *pod)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return list
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		table := []struct {
0000000000000000000000000000000000000000;;			list     *v1.PodList
0000000000000000000000000000000000000000;;			listErr  error
0000000000000000000000000000000000000000;;			events   []watch.Event
0000000000000000000000000000000000000000;;			watchErr error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				list: mkList("1"),
0000000000000000000000000000000000000000;;				events: []watch.Event{
0000000000000000000000000000000000000000;;					{Type: watch.Added, Object: mkPod("foo", "2")},
0000000000000000000000000000000000000000;;					{Type: watch.Added, Object: mkPod("bar", "3")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				list: mkList("3", mkPod("foo", "2"), mkPod("bar", "3")),
0000000000000000000000000000000000000000;;				events: []watch.Event{
0000000000000000000000000000000000000000;;					{Type: watch.Deleted, Object: mkPod("foo", "4")},
0000000000000000000000000000000000000000;;					{Type: watch.Added, Object: mkPod("qux", "5")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				listErr: fmt.Errorf("a list error"),
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				list:     mkList("5", mkPod("bar", "3"), mkPod("qux", "5")),
0000000000000000000000000000000000000000;;				watchErr: fmt.Errorf("a watch error"),
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				list: mkList("5", mkPod("bar", "3"), mkPod("qux", "5")),
0000000000000000000000000000000000000000;;				events: []watch.Event{
0000000000000000000000000000000000000000;;					{Type: watch.Added, Object: mkPod("baz", "6")},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, {
0000000000000000000000000000000000000000;;				list: mkList("6", mkPod("bar", "3"), mkPod("qux", "5"), mkPod("baz", "6")),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := NewFIFO(MetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;		for line, item := range table {
0000000000000000000000000000000000000000;;			if item.list != nil {
0000000000000000000000000000000000000000;;				// Test that the list is what currently exists in the store.
0000000000000000000000000000000000000000;;				current := s.List()
0000000000000000000000000000000000000000;;				checkMap := map[string]string{}
0000000000000000000000000000000000000000;;				for _, item := range current {
0000000000000000000000000000000000000000;;					pod := item.(*v1.Pod)
0000000000000000000000000000000000000000;;					checkMap[pod.Name] = pod.ResourceVersion
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, pod := range item.list.Items {
0000000000000000000000000000000000000000;;					if e, a := pod.ResourceVersion, checkMap[pod.Name]; e != a {
0000000000000000000000000000000000000000;;						t.Errorf("%v: expected %v, got %v for pod %v", line, e, a, pod.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := len(item.list.Items), len(checkMap); e != a {
0000000000000000000000000000000000000000;;					t.Errorf("%v: expected %v, got %v", line, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			watchRet, watchErr := item.events, item.watchErr
0000000000000000000000000000000000000000;;			lw := &testLW{
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					if watchErr != nil {
0000000000000000000000000000000000000000;;						return nil, watchErr
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					watchErr = fmt.Errorf("second watch")
0000000000000000000000000000000000000000;;					fw := watch.NewFake()
0000000000000000000000000000000000000000;;					go func() {
0000000000000000000000000000000000000000;;						for _, e := range watchRet {
0000000000000000000000000000000000000000;;							fw.Action(e.Type, e.Object)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						fw.Stop()
0000000000000000000000000000000000000000;;					}()
0000000000000000000000000000000000000000;;					return fw, nil
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					return item.list, item.listErr
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r := NewReflector(lw, &v1.Pod{}, s, 0)
0000000000000000000000000000000000000000;;			r.ListAndWatch(wait.NeverStop)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestReflectorResync(t *testing.T) {
0000000000000000000000000000000000000000;;		iteration := 0
0000000000000000000000000000000000000000;;		stopCh := make(chan struct{})
0000000000000000000000000000000000000000;;		rerr := errors.New("expected resync reached")
0000000000000000000000000000000000000000;;		s := &FakeCustomStore{
0000000000000000000000000000000000000000;;			ResyncFunc: func() error {
0000000000000000000000000000000000000000;;				iteration++
0000000000000000000000000000000000000000;;				if iteration == 2 {
0000000000000000000000000000000000000000;;					return rerr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lw := &testLW{
0000000000000000000000000000000000000000;;			WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;				fw := watch.NewFake()
0000000000000000000000000000000000000000;;				return fw, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;				return &v1.PodList{ListMeta: metav1.ListMeta{ResourceVersion: "0"}}, nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resyncPeriod := 1 * time.Millisecond
0000000000000000000000000000000000000000;;		r := NewReflector(lw, &v1.Pod{}, s, resyncPeriod)
0000000000000000000000000000000000000000;;		if err := r.ListAndWatch(stopCh); err != nil {
0000000000000000000000000000000000000000;;			// error from Resync is not propaged up to here.
0000000000000000000000000000000000000000;;			t.Errorf("expected error %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if iteration != 2 {
0000000000000000000000000000000000000000;;			t.Errorf("exactly 2 iterations were expected, got: %v", iteration)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
