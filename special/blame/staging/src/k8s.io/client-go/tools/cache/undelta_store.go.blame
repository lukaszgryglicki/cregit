0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/undelta_store.go[staging/src/k8s.io/client-go/1.4/tools/cache/undelta_store.go][staging/src/k8s.io/client-go/tools/cache/undelta_store.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UndeltaStore listens to incremental updates and sends complete state on every change.
0000000000000000000000000000000000000000;;	// It implements the Store interface so that it can receive a stream of mirrored objects
0000000000000000000000000000000000000000;;	// from Reflector.  Whenever it receives any complete (Store.Replace) or incremental change
0000000000000000000000000000000000000000;;	// (Store.Add, Store.Update, Store.Delete), it sends the complete state by calling PushFunc.
0000000000000000000000000000000000000000;;	// It is thread-safe.  It guarantees that every change (Add, Update, Replace, Delete) results
0000000000000000000000000000000000000000;;	// in one call to PushFunc, but sometimes PushFunc may be called twice with the same values.
0000000000000000000000000000000000000000;;	// PushFunc should be thread safe.
0000000000000000000000000000000000000000;;	type UndeltaStore struct {
0000000000000000000000000000000000000000;;		Store
0000000000000000000000000000000000000000;;		PushFunc func([]interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Assert that it implements the Store interface.
0000000000000000000000000000000000000000;;	var _ Store = &UndeltaStore{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note about thread safety.  The Store implementation (cache.cache) uses a lock for all methods.
0000000000000000000000000000000000000000;;	// In the functions below, the lock gets released and reacquired betweend the {Add,Delete,etc}
0000000000000000000000000000000000000000;;	// and the List.  So, the following can happen, resulting in two identical calls to PushFunc.
0000000000000000000000000000000000000000;;	// time            thread 1                  thread 2
0000000000000000000000000000000000000000;;	// 0               UndeltaStore.Add(a)
0000000000000000000000000000000000000000;;	// 1                                         UndeltaStore.Add(b)
0000000000000000000000000000000000000000;;	// 2               Store.Add(a)
0000000000000000000000000000000000000000;;	// 3                                         Store.Add(b)
0000000000000000000000000000000000000000;;	// 4               Store.List() -> [a,b]
0000000000000000000000000000000000000000;;	// 5                                         Store.List() -> [a,b]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UndeltaStore) Add(obj interface{}) error {
0000000000000000000000000000000000000000;;		if err := u.Store.Add(obj); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.PushFunc(u.Store.List())
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UndeltaStore) Update(obj interface{}) error {
0000000000000000000000000000000000000000;;		if err := u.Store.Update(obj); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.PushFunc(u.Store.List())
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UndeltaStore) Delete(obj interface{}) error {
0000000000000000000000000000000000000000;;		if err := u.Store.Delete(obj); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.PushFunc(u.Store.List())
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *UndeltaStore) Replace(list []interface{}, resourceVersion string) error {
0000000000000000000000000000000000000000;;		if err := u.Store.Replace(list, resourceVersion); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.PushFunc(u.Store.List())
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewUndeltaStore returns an UndeltaStore implemented with a Store.
0000000000000000000000000000000000000000;;	func NewUndeltaStore(pushFunc func([]interface{}), keyFunc KeyFunc) *UndeltaStore {
0000000000000000000000000000000000000000;;		return &UndeltaStore{
0000000000000000000000000000000000000000;;			Store:    NewStore(keyFunc),
0000000000000000000000000000000000000000;;			PushFunc: pushFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
