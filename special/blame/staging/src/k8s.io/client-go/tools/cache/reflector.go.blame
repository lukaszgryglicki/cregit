0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/reflector.go[staging/src/k8s.io/client-go/1.4/tools/cache/reflector.go][staging/src/k8s.io/client-go/tools/cache/reflector.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"runtime/debug"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		apierrs "k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		utilruntime "k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reflector watches a specified resource and causes all changes to be reflected in the given store.
0000000000000000000000000000000000000000;;	type Reflector struct {
0000000000000000000000000000000000000000;;		// name identifies this reflector. By default it will be a file:line if possible.
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The type of object we expect to place in the store.
0000000000000000000000000000000000000000;;		expectedType reflect.Type
0000000000000000000000000000000000000000;;		// The destination to sync up with the watch source
0000000000000000000000000000000000000000;;		store Store
0000000000000000000000000000000000000000;;		// listerWatcher is used to perform lists and watches.
0000000000000000000000000000000000000000;;		listerWatcher ListerWatcher
0000000000000000000000000000000000000000;;		// period controls timing between one watch ending and
0000000000000000000000000000000000000000;;		// the beginning of the next one.
0000000000000000000000000000000000000000;;		period       time.Duration
0000000000000000000000000000000000000000;;		resyncPeriod time.Duration
0000000000000000000000000000000000000000;;		ShouldResync func() bool
0000000000000000000000000000000000000000;;		// clock allows tests to manipulate time
0000000000000000000000000000000000000000;;		clock clock.Clock
0000000000000000000000000000000000000000;;		// lastSyncResourceVersion is the resource version token last
0000000000000000000000000000000000000000;;		// observed when doing a sync with the underlying store
0000000000000000000000000000000000000000;;		// it is thread safe, but not synchronized with the underlying store
0000000000000000000000000000000000000000;;		lastSyncResourceVersion string
0000000000000000000000000000000000000000;;		// lastSyncResourceVersionMutex guards read/write access to lastSyncResourceVersion
0000000000000000000000000000000000000000;;		lastSyncResourceVersionMutex sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// We try to spread the load on apiserver by setting timeouts for
0000000000000000000000000000000000000000;;		// watch requests - it is random in [minWatchTimeout, 2*minWatchTimeout].
0000000000000000000000000000000000000000;;		// However, it can be modified to avoid periodic resync to break the
0000000000000000000000000000000000000000;;		// TCP connection.
0000000000000000000000000000000000000000;;		minWatchTimeout = 5 * time.Minute
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNamespaceKeyedIndexerAndReflector creates an Indexer and a Reflector
0000000000000000000000000000000000000000;;	// The indexer is configured to key on namespace
0000000000000000000000000000000000000000;;	func NewNamespaceKeyedIndexerAndReflector(lw ListerWatcher, expectedType interface{}, resyncPeriod time.Duration) (indexer Indexer, reflector *Reflector) {
0000000000000000000000000000000000000000;;		indexer = NewIndexer(MetaNamespaceKeyFunc, Indexers{"namespace": MetaNamespaceIndexFunc})
0000000000000000000000000000000000000000;;		reflector = NewReflector(lw, expectedType, indexer, resyncPeriod)
0000000000000000000000000000000000000000;;		return indexer, reflector
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReflector creates a new Reflector object which will keep the given store up to
0000000000000000000000000000000000000000;;	// date with the server's contents for the given resource. Reflector promises to
0000000000000000000000000000000000000000;;	// only put things in the store that have the type of expectedType, unless expectedType
0000000000000000000000000000000000000000;;	// is nil. If resyncPeriod is non-zero, then lists will be executed after every
0000000000000000000000000000000000000000;;	// resyncPeriod, so that you can use reflectors to periodically process everything as
0000000000000000000000000000000000000000;;	// well as incrementally processing the things that change.
0000000000000000000000000000000000000000;;	func NewReflector(lw ListerWatcher, expectedType interface{}, store Store, resyncPeriod time.Duration) *Reflector {
0000000000000000000000000000000000000000;;		return NewNamedReflector(getDefaultReflectorName(internalPackages...), lw, expectedType, store, resyncPeriod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNamedReflector same as NewReflector, but with a specified name for logging
0000000000000000000000000000000000000000;;	func NewNamedReflector(name string, lw ListerWatcher, expectedType interface{}, store Store, resyncPeriod time.Duration) *Reflector {
0000000000000000000000000000000000000000;;		r := &Reflector{
0000000000000000000000000000000000000000;;			name:          name,
0000000000000000000000000000000000000000;;			listerWatcher: lw,
0000000000000000000000000000000000000000;;			store:         store,
0000000000000000000000000000000000000000;;			expectedType:  reflect.TypeOf(expectedType),
0000000000000000000000000000000000000000;;			period:        time.Second,
0000000000000000000000000000000000000000;;			resyncPeriod:  resyncPeriod,
0000000000000000000000000000000000000000;;			clock:         &clock.RealClock{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// internalPackages are packages that ignored when creating a default reflector name. These packages are in the common
0000000000000000000000000000000000000000;;	// call chains to NewReflector, so they'd be low entropy names for reflectors
0000000000000000000000000000000000000000;;	var internalPackages = []string{"client-go/tools/cache/", "/runtime/asm_"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDefaultReflectorName walks back through the call stack until we find a caller from outside of the ignoredPackages
0000000000000000000000000000000000000000;;	// it returns back a shortpath/filename:line to aid in identification of this reflector when it starts logging
0000000000000000000000000000000000000000;;	func getDefaultReflectorName(ignoredPackages ...string) string {
0000000000000000000000000000000000000000;;		name := "????"
0000000000000000000000000000000000000000;;		const maxStack = 10
0000000000000000000000000000000000000000;;		for i := 1; i < maxStack; i++ {
0000000000000000000000000000000000000000;;			_, file, line, ok := goruntime.Caller(i)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				file, line, ok = extractStackCreator()
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i += maxStack
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasPackage(file, ignoredPackages) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			file = trimPackagePrefix(file)
0000000000000000000000000000000000000000;;			name = fmt.Sprintf("%s:%d", file, line)
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hasPackage returns true if the file is in one of the ignored packages.
0000000000000000000000000000000000000000;;	func hasPackage(file string, ignoredPackages []string) bool {
0000000000000000000000000000000000000000;;		for _, ignoredPackage := range ignoredPackages {
0000000000000000000000000000000000000000;;			if strings.Contains(file, ignoredPackage) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// trimPackagePrefix reduces duplicate values off the front of a package name.
0000000000000000000000000000000000000000;;	func trimPackagePrefix(file string) string {
0000000000000000000000000000000000000000;;		if l := strings.LastIndex(file, "k8s.io/client-go/pkg/"); l >= 0 {
0000000000000000000000000000000000000000;;			return file[l+len("k8s.io/client-go/"):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l := strings.LastIndex(file, "/src/"); l >= 0 {
0000000000000000000000000000000000000000;;			return file[l+5:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l := strings.LastIndex(file, "/pkg/"); l >= 0 {
0000000000000000000000000000000000000000;;			return file[l+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return file
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var stackCreator = regexp.MustCompile(`(?m)^created by (.*)\n\s+(.*):(\d+) \+0x[[:xdigit:]]+$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extractStackCreator retrieves the goroutine file and line that launched this stack. Returns false
0000000000000000000000000000000000000000;;	// if the creator cannot be located.
0000000000000000000000000000000000000000;;	// TODO: Go does not expose this via runtime https://github.com/golang/go/issues/11440
0000000000000000000000000000000000000000;;	func extractStackCreator() (string, int, bool) {
0000000000000000000000000000000000000000;;		stack := debug.Stack()
0000000000000000000000000000000000000000;;		matches := stackCreator.FindStringSubmatch(string(stack))
0000000000000000000000000000000000000000;;		if matches == nil || len(matches) != 4 {
0000000000000000000000000000000000000000;;			return "", 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		line, err := strconv.Atoi(matches[3])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return matches[2], line, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run starts a watch and handles watch events. Will restart the watch if it is closed.
0000000000000000000000000000000000000000;;	// Run starts a goroutine and returns immediately.
0000000000000000000000000000000000000000;;	func (r *Reflector) Run() {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Starting reflector %v (%s) from %s", r.expectedType, r.resyncPeriod, r.name)
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			if err := r.ListAndWatch(wait.NeverStop); err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, r.period, wait.NeverStop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunUntil starts a watch and handles watch events. Will restart the watch if it is closed.
0000000000000000000000000000000000000000;;	// RunUntil starts a goroutine and returns immediately. It will exit when stopCh is closed.
0000000000000000000000000000000000000000;;	func (r *Reflector) RunUntil(stopCh <-chan struct{}) {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Starting reflector %v (%s) from %s", r.expectedType, r.resyncPeriod, r.name)
0000000000000000000000000000000000000000;;		go wait.Until(func() {
0000000000000000000000000000000000000000;;			if err := r.ListAndWatch(stopCh); err != nil {
0000000000000000000000000000000000000000;;				utilruntime.HandleError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}, r.period, stopCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// nothing will ever be sent down this channel
0000000000000000000000000000000000000000;;		neverExitWatch <-chan time.Time = make(chan time.Time)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Used to indicate that watching stopped so that a resync could happen.
0000000000000000000000000000000000000000;;		errorResyncRequested = errors.New("resync channel fired")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Used to indicate that watching stopped because of a signal from the stop
0000000000000000000000000000000000000000;;		// channel passed in from a client of the reflector.
0000000000000000000000000000000000000000;;		errorStopRequested = errors.New("Stop requested")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resyncChan returns a channel which will receive something when a resync is
0000000000000000000000000000000000000000;;	// required, and a cleanup function.
0000000000000000000000000000000000000000;;	func (r *Reflector) resyncChan() (<-chan time.Time, func() bool) {
0000000000000000000000000000000000000000;;		if r.resyncPeriod == 0 {
0000000000000000000000000000000000000000;;			return neverExitWatch, func() bool { return false }
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The cleanup function is required: imagine the scenario where watches
0000000000000000000000000000000000000000;;		// always fail so we end up listing frequently. Then, if we don't
0000000000000000000000000000000000000000;;		// manually stop the timer, we could end up with many timers active
0000000000000000000000000000000000000000;;		// concurrently.
0000000000000000000000000000000000000000;;		t := r.clock.NewTimer(r.resyncPeriod)
0000000000000000000000000000000000000000;;		return t.C(), t.Stop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListAndWatch first lists all items and get the resource version at the moment of call,
0000000000000000000000000000000000000000;;	// and then use the resource version to watch.
0000000000000000000000000000000000000000;;	// It returns error if ListAndWatch didn't even try to initialize watch.
0000000000000000000000000000000000000000;;	func (r *Reflector) ListAndWatch(stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Listing and watching %v from %s", r.expectedType, r.name)
0000000000000000000000000000000000000000;;		var resourceVersion string
0000000000000000000000000000000000000000;;		resyncCh, cleanup := r.resyncChan()
0000000000000000000000000000000000000000;;		defer cleanup()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Explicitly set "0" as resource version - it's fine for the List()
0000000000000000000000000000000000000000;;		// to be served from cache and potentially be delayed relative to
0000000000000000000000000000000000000000;;		// etcd contents. Reflector framework will catch up via Watch() eventually.
0000000000000000000000000000000000000000;;		options := metav1.ListOptions{ResourceVersion: "0"}
0000000000000000000000000000000000000000;;		list, err := r.listerWatcher.List(options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s: Failed to list %v: %v", r.name, r.expectedType, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listMetaInterface, err := meta.ListAccessor(list)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s: Unable to understand list result %#v: %v", r.name, list, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resourceVersion = listMetaInterface.GetResourceVersion()
0000000000000000000000000000000000000000;;		items, err := meta.ExtractList(list)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s: Unable to understand list result %#v (%v)", r.name, list, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := r.syncWith(items, resourceVersion); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s: Unable to sync list result: %v", r.name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.setLastSyncResourceVersion(resourceVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resyncerrc := make(chan error, 1)
0000000000000000000000000000000000000000;;		cancelCh := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(cancelCh)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-resyncCh:
0000000000000000000000000000000000000000;;				case <-stopCh:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				case <-cancelCh:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if r.ShouldResync == nil || r.ShouldResync() {
0000000000000000000000000000000000000000;;					glog.V(4).Infof("%s: forcing resync", r.name)
0000000000000000000000000000000000000000;;					if err := r.store.Resync(); err != nil {
0000000000000000000000000000000000000000;;						resyncerrc <- err
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cleanup()
0000000000000000000000000000000000000000;;				resyncCh, cleanup = r.resyncChan()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			timemoutseconds := int64(minWatchTimeout.Seconds() * (rand.Float64() + 1.0))
0000000000000000000000000000000000000000;;			options = metav1.ListOptions{
0000000000000000000000000000000000000000;;				ResourceVersion: resourceVersion,
0000000000000000000000000000000000000000;;				// We want to avoid situations of hanging watchers. Stop any wachers that do not
0000000000000000000000000000000000000000;;				// receive any events within the timeout window.
0000000000000000000000000000000000000000;;				TimeoutSeconds: &timemoutseconds,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w, err := r.listerWatcher.Watch(options)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				switch err {
0000000000000000000000000000000000000000;;				case io.EOF:
0000000000000000000000000000000000000000;;					// watch closed normally
0000000000000000000000000000000000000000;;				case io.ErrUnexpectedEOF:
0000000000000000000000000000000000000000;;					glog.V(1).Infof("%s: Watch for %v closed with unexpected EOF: %v", r.name, r.expectedType, err)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("%s: Failed to watch %v: %v", r.name, r.expectedType, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If this is "connection refused" error, it means that most likely apiserver is not responsive.
0000000000000000000000000000000000000000;;				// It doesn't make sense to re-list all objects because most likely we will be able to restart
0000000000000000000000000000000000000000;;				// watch where we ended.
0000000000000000000000000000000000000000;;				// If that's the case wait and resend watch request.
0000000000000000000000000000000000000000;;				if urlError, ok := err.(*url.Error); ok {
0000000000000000000000000000000000000000;;					if opError, ok := urlError.Err.(*net.OpError); ok {
0000000000000000000000000000000000000000;;						if errno, ok := opError.Err.(syscall.Errno); ok && errno == syscall.ECONNREFUSED {
0000000000000000000000000000000000000000;;							time.Sleep(time.Second)
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := r.watchHandler(w, &resourceVersion, resyncerrc, stopCh); err != nil {
0000000000000000000000000000000000000000;;				if err != errorStopRequested {
0000000000000000000000000000000000000000;;					glog.Warningf("%s: watch of %v ended with: %v", r.name, r.expectedType, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncWith replaces the store's items with the given list.
0000000000000000000000000000000000000000;;	func (r *Reflector) syncWith(items []runtime.Object, resourceVersion string) error {
0000000000000000000000000000000000000000;;		found := make([]interface{}, 0, len(items))
0000000000000000000000000000000000000000;;		for _, item := range items {
0000000000000000000000000000000000000000;;			found = append(found, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.store.Replace(found, resourceVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchHandler watches w and keeps *resourceVersion up to date.
0000000000000000000000000000000000000000;;	func (r *Reflector) watchHandler(w watch.Interface, resourceVersion *string, errc chan error, stopCh <-chan struct{}) error {
0000000000000000000000000000000000000000;;		start := r.clock.Now()
0000000000000000000000000000000000000000;;		eventCount := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stopping the watcher should be idempotent and if we return from this function there's no way
0000000000000000000000000000000000000000;;		// we're coming back in with the same watch interface.
0000000000000000000000000000000000000000;;		defer w.Stop()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopCh:
0000000000000000000000000000000000000000;;				return errorStopRequested
0000000000000000000000000000000000000000;;			case err := <-errc:
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			case event, ok := <-w.ResultChan():
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					break loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if event.Type == watch.Error {
0000000000000000000000000000000000000000;;					return apierrs.FromObject(event.Object)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, a := r.expectedType, reflect.TypeOf(event.Object); e != nil && e != a {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("%s: expected type %v, but watch event object had type %v", r.name, e, a))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				meta, err := meta.Accessor(event.Object)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("%s: unable to understand watch event %#v", r.name, event))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newResourceVersion := meta.GetResourceVersion()
0000000000000000000000000000000000000000;;				switch event.Type {
0000000000000000000000000000000000000000;;				case watch.Added:
0000000000000000000000000000000000000000;;					err := r.store.Add(event.Object)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						utilruntime.HandleError(fmt.Errorf("%s: unable to add watch event object (%#v) to store: %v", r.name, event.Object, err))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case watch.Modified:
0000000000000000000000000000000000000000;;					err := r.store.Update(event.Object)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						utilruntime.HandleError(fmt.Errorf("%s: unable to update watch event object (%#v) to store: %v", r.name, event.Object, err))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case watch.Deleted:
0000000000000000000000000000000000000000;;					// TODO: Will any consumers need access to the "last known
0000000000000000000000000000000000000000;;					// state", which is passed in event.Object? If so, may need
0000000000000000000000000000000000000000;;					// to change this.
0000000000000000000000000000000000000000;;					err := r.store.Delete(event.Object)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						utilruntime.HandleError(fmt.Errorf("%s: unable to delete watch event object (%#v) from store: %v", r.name, event.Object, err))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					utilruntime.HandleError(fmt.Errorf("%s: unable to understand watch event %#v", r.name, event))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*resourceVersion = newResourceVersion
0000000000000000000000000000000000000000;;				r.setLastSyncResourceVersion(newResourceVersion)
0000000000000000000000000000000000000000;;				eventCount++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watchDuration := r.clock.Now().Sub(start)
0000000000000000000000000000000000000000;;		if watchDuration < 1*time.Second && eventCount == 0 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("%s: Unexpected watch close - watch lasted less than a second and no items received", r.name)
0000000000000000000000000000000000000000;;			return errors.New("very short watch")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("%s: Watch close - %v total %v items received", r.name, r.expectedType, eventCount)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LastSyncResourceVersion is the resource version observed when last sync with the underlying store
0000000000000000000000000000000000000000;;	// The value returned is not synchronized with access to the underlying store and is not thread-safe
0000000000000000000000000000000000000000;;	func (r *Reflector) LastSyncResourceVersion() string {
0000000000000000000000000000000000000000;;		r.lastSyncResourceVersionMutex.RLock()
0000000000000000000000000000000000000000;;		defer r.lastSyncResourceVersionMutex.RUnlock()
0000000000000000000000000000000000000000;;		return r.lastSyncResourceVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Reflector) setLastSyncResourceVersion(v string) {
0000000000000000000000000000000000000000;;		r.lastSyncResourceVersionMutex.Lock()
0000000000000000000000000000000000000000;;		defer r.lastSyncResourceVersionMutex.Unlock()
0000000000000000000000000000000000000000;;		r.lastSyncResourceVersion = v
0000000000000000000000000000000000000000;;	}
