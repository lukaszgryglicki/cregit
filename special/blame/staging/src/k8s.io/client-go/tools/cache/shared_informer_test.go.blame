0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
ce525e11040b282e9dc04a7390e476fdc7c44944;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/clock"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		fcache "k8s.io/client-go/tools/cache/testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testListener struct {
0000000000000000000000000000000000000000;;		lock              sync.RWMutex
0000000000000000000000000000000000000000;;		resyncPeriod      time.Duration
0000000000000000000000000000000000000000;;		expectedItemNames sets.String
0000000000000000000000000000000000000000;;		receivedItemNames []string
0000000000000000000000000000000000000000;;		name              string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTestListener(name string, resyncPeriod time.Duration, expected ...string) *testListener {
0000000000000000000000000000000000000000;;		l := &testListener{
0000000000000000000000000000000000000000;;			resyncPeriod:      resyncPeriod,
0000000000000000000000000000000000000000;;			expectedItemNames: sets.NewString(expected...),
0000000000000000000000000000000000000000;;			name:              name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *testListener) OnAdd(obj interface{}) {
0000000000000000000000000000000000000000;;		l.handle(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *testListener) OnUpdate(old, new interface{}) {
0000000000000000000000000000000000000000;;		l.handle(new)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *testListener) OnDelete(obj interface{}) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *testListener) handle(obj interface{}) {
0000000000000000000000000000000000000000;;		key, _ := MetaNamespaceKeyFunc(obj)
0000000000000000000000000000000000000000;;		fmt.Printf("%s: handle: %v\n", l.name, key)
0000000000000000000000000000000000000000;;		l.lock.Lock()
0000000000000000000000000000000000000000;;		defer l.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objectMeta, _ := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		l.receivedItemNames = append(l.receivedItemNames, objectMeta.GetName())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *testListener) ok() bool {
0000000000000000000000000000000000000000;;		fmt.Println("polling")
0000000000000000000000000000000000000000;;		err := wait.PollImmediate(100*time.Millisecond, 2*time.Second, func() (bool, error) {
0000000000000000000000000000000000000000;;			if l.satisfiedExpectations() {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait just a bit to allow any unexpected stragglers to come in
0000000000000000000000000000000000000000;;		fmt.Println("sleeping")
0000000000000000000000000000000000000000;;		time.Sleep(1 * time.Second)
0000000000000000000000000000000000000000;;		fmt.Println("final check")
0000000000000000000000000000000000000000;;		return l.satisfiedExpectations()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *testListener) satisfiedExpectations() bool {
0000000000000000000000000000000000000000;;		l.lock.RLock()
0000000000000000000000000000000000000000;;		defer l.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return len(l.receivedItemNames) == l.expectedItemNames.Len() && sets.NewString(l.receivedItemNames...).Equal(l.expectedItemNames)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestListenerResyncPeriods(t *testing.T) {
0000000000000000000000000000000000000000;;		// source simulates an apiserver object endpoint.
0000000000000000000000000000000000000000;;		source := fcache.NewFakeControllerSource()
0000000000000000000000000000000000000000;;		source.Add(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "pod1"}})
0000000000000000000000000000000000000000;;		source.Add(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: "pod2"}})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create the shared informer and resync every 1s
0000000000000000000000000000000000000000;;		informer := NewSharedInformer(source, &v1.Pod{}, 1*time.Second).(*sharedIndexInformer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		informer.clock = clock
0000000000000000000000000000000000000000;;		informer.processor.clock = clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listener 1, never resync
0000000000000000000000000000000000000000;;		listener1 := newTestListener("listener1", 0, "pod1", "pod2")
0000000000000000000000000000000000000000;;		informer.AddEventHandlerWithResyncPeriod(listener1, listener1.resyncPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listener 2, resync every 2s
0000000000000000000000000000000000000000;;		listener2 := newTestListener("listener2", 2*time.Second, "pod1", "pod2")
0000000000000000000000000000000000000000;;		informer.AddEventHandlerWithResyncPeriod(listener2, listener2.resyncPeriod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listener 3, resync every 3s
0000000000000000000000000000000000000000;;		listener3 := newTestListener("listener3", 3*time.Second, "pod1", "pod2")
0000000000000000000000000000000000000000;;		informer.AddEventHandlerWithResyncPeriod(listener3, listener3.resyncPeriod)
0000000000000000000000000000000000000000;;		listeners := []*testListener{listener1, listener2, listener3}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go informer.Run(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure all listeners got the initial List
0000000000000000000000000000000000000000;;		for _, listener := range listeners {
0000000000000000000000000000000000000000;;			if !listener.ok() {
0000000000000000000000000000000000000000;;				t.Errorf("%s: expected %v, got %v", listener.name, listener.expectedItemNames, listener.receivedItemNames)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reset
0000000000000000000000000000000000000000;;		for _, listener := range listeners {
0000000000000000000000000000000000000000;;			listener.receivedItemNames = []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// advance so listener2 gets a resync
0000000000000000000000000000000000000000;;		clock.Step(2 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure listener2 got the resync
0000000000000000000000000000000000000000;;		if !listener2.ok() {
0000000000000000000000000000000000000000;;			t.Errorf("%s: expected %v, got %v", listener2.name, listener2.expectedItemNames, listener2.receivedItemNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait a bit to give errant items a chance to go to 1 and 3
0000000000000000000000000000000000000000;;		time.Sleep(1 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure listeners 1 and 3 got nothing
0000000000000000000000000000000000000000;;		if len(listener1.receivedItemNames) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("listener1: should not have resynced (got %d)", len(listener1.receivedItemNames))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(listener3.receivedItemNames) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("listener3: should not have resynced (got %d)", len(listener3.receivedItemNames))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reset
0000000000000000000000000000000000000000;;		for _, listener := range listeners {
0000000000000000000000000000000000000000;;			listener.receivedItemNames = []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// advance so listener3 gets a resync
0000000000000000000000000000000000000000;;		clock.Step(1 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure listener3 got the resync
0000000000000000000000000000000000000000;;		if !listener3.ok() {
0000000000000000000000000000000000000000;;			t.Errorf("%s: expected %v, got %v", listener3.name, listener3.expectedItemNames, listener3.receivedItemNames)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait a bit to give errant items a chance to go to 1 and 2
0000000000000000000000000000000000000000;;		time.Sleep(1 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// make sure listeners 1 and 2 got nothing
0000000000000000000000000000000000000000;;		if len(listener1.receivedItemNames) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("listener1: should not have resynced (got %d)", len(listener1.receivedItemNames))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(listener2.receivedItemNames) != 0 {
0000000000000000000000000000000000000000;;			t.Errorf("listener2: should not have resynced (got %d)", len(listener2.receivedItemNames))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestResyncCheckPeriod(t *testing.T) {
0000000000000000000000000000000000000000;;		// source simulates an apiserver object endpoint.
0000000000000000000000000000000000000000;;		source := fcache.NewFakeControllerSource()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create the shared informer and resync every 12 hours
0000000000000000000000000000000000000000;;		informer := NewSharedInformer(source, &v1.Pod{}, 12*time.Hour).(*sharedIndexInformer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clock := clock.NewFakeClock(time.Now())
0000000000000000000000000000000000000000;;		informer.clock = clock
0000000000000000000000000000000000000000;;		informer.processor.clock = clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listener 1, never resync
0000000000000000000000000000000000000000;;		listener1 := newTestListener("listener1", 0)
0000000000000000000000000000000000000000;;		informer.AddEventHandlerWithResyncPeriod(listener1, listener1.resyncPeriod)
0000000000000000000000000000000000000000;;		if e, a := 12*time.Hour, informer.resyncCheckPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := time.Duration(0), informer.processor.listeners[0].resyncPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listener 2, resync every minute
0000000000000000000000000000000000000000;;		listener2 := newTestListener("listener2", 1*time.Minute)
0000000000000000000000000000000000000000;;		informer.AddEventHandlerWithResyncPeriod(listener2, listener2.resyncPeriod)
0000000000000000000000000000000000000000;;		if e, a := 1*time.Minute, informer.resyncCheckPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := time.Duration(0), informer.processor.listeners[0].resyncPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 1*time.Minute, informer.processor.listeners[1].resyncPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listener 3, resync every 55 seconds
0000000000000000000000000000000000000000;;		listener3 := newTestListener("listener3", 55*time.Second)
0000000000000000000000000000000000000000;;		informer.AddEventHandlerWithResyncPeriod(listener3, listener3.resyncPeriod)
0000000000000000000000000000000000000000;;		if e, a := 55*time.Second, informer.resyncCheckPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := time.Duration(0), informer.processor.listeners[0].resyncPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 1*time.Minute, informer.processor.listeners[1].resyncPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 55*time.Second, informer.processor.listeners[2].resyncPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// listener 4, resync every 5 seconds
0000000000000000000000000000000000000000;;		listener4 := newTestListener("listener4", 5*time.Second)
0000000000000000000000000000000000000000;;		informer.AddEventHandlerWithResyncPeriod(listener4, listener4.resyncPeriod)
0000000000000000000000000000000000000000;;		if e, a := 5*time.Second, informer.resyncCheckPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := time.Duration(0), informer.processor.listeners[0].resyncPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 1*time.Minute, informer.processor.listeners[1].resyncPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 55*time.Second, informer.processor.listeners[2].resyncPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e, a := 5*time.Second, informer.processor.listeners[3].resyncPeriod; e != a {
0000000000000000000000000000000000000000;;			t.Errorf("expected %d, got %d", e, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
