0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/thread_safe_store.go[staging/src/k8s.io/client-go/1.4/tools/cache/thread_safe_store.go][staging/src/k8s.io/client-go/tools/cache/thread_safe_store.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ThreadSafeStore is an interface that allows concurrent access to a storage backend.
0000000000000000000000000000000000000000;;	// TL;DR caveats: you must not modify anything returned by Get or List as it will break
0000000000000000000000000000000000000000;;	// the indexing feature in addition to not being thread safe.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The guarantees of thread safety provided by List/Get are only valid if the caller
0000000000000000000000000000000000000000;;	// treats returned items as read-only. For example, a pointer inserted in the store
0000000000000000000000000000000000000000;;	// through `Add` will be returned as is by `Get`. Multiple clients might invoke `Get`
0000000000000000000000000000000000000000;;	// on the same key and modify the pointer in a non-thread-safe way. Also note that
0000000000000000000000000000000000000000;;	// modifying objects stored by the indexers (if any) will *not* automatically lead
0000000000000000000000000000000000000000;;	// to a re-index. So it's not a good idea to directly modify the objects returned by
0000000000000000000000000000000000000000;;	// Get/List, in general.
0000000000000000000000000000000000000000;;	type ThreadSafeStore interface {
0000000000000000000000000000000000000000;;		Add(key string, obj interface{})
0000000000000000000000000000000000000000;;		Update(key string, obj interface{})
0000000000000000000000000000000000000000;;		Delete(key string)
0000000000000000000000000000000000000000;;		Get(key string) (item interface{}, exists bool)
0000000000000000000000000000000000000000;;		List() []interface{}
0000000000000000000000000000000000000000;;		ListKeys() []string
0000000000000000000000000000000000000000;;		Replace(map[string]interface{}, string)
0000000000000000000000000000000000000000;;		Index(indexName string, obj interface{}) ([]interface{}, error)
0000000000000000000000000000000000000000;;		IndexKeys(indexName, indexKey string) ([]string, error)
0000000000000000000000000000000000000000;;		ListIndexFuncValues(name string) []string
0000000000000000000000000000000000000000;;		ByIndex(indexName, indexKey string) ([]interface{}, error)
0000000000000000000000000000000000000000;;		GetIndexers() Indexers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AddIndexers adds more indexers to this store.  If you call this after you already have data
0000000000000000000000000000000000000000;;		// in the store, the results are undefined.
0000000000000000000000000000000000000000;;		AddIndexers(newIndexers Indexers) error
0000000000000000000000000000000000000000;;		Resync() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// threadSafeMap implements ThreadSafeStore
0000000000000000000000000000000000000000;;	type threadSafeMap struct {
0000000000000000000000000000000000000000;;		lock  sync.RWMutex
0000000000000000000000000000000000000000;;		items map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// indexers maps a name to an IndexFunc
0000000000000000000000000000000000000000;;		indexers Indexers
0000000000000000000000000000000000000000;;		// indices maps a name to an Index
0000000000000000000000000000000000000000;;		indices Indices
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) Add(key string, obj interface{}) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		oldObject := c.items[key]
0000000000000000000000000000000000000000;;		c.items[key] = obj
0000000000000000000000000000000000000000;;		c.updateIndices(oldObject, obj, key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) Update(key string, obj interface{}) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		oldObject := c.items[key]
0000000000000000000000000000000000000000;;		c.items[key] = obj
0000000000000000000000000000000000000000;;		c.updateIndices(oldObject, obj, key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) Delete(key string) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		if obj, exists := c.items[key]; exists {
0000000000000000000000000000000000000000;;			c.deleteFromIndices(obj, key)
0000000000000000000000000000000000000000;;			delete(c.items, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) Get(key string) (item interface{}, exists bool) {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		item, exists = c.items[key]
0000000000000000000000000000000000000000;;		return item, exists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) List() []interface{} {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		list := make([]interface{}, 0, len(c.items))
0000000000000000000000000000000000000000;;		for _, item := range c.items {
0000000000000000000000000000000000000000;;			list = append(list, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListKeys returns a list of all the keys of the objects currently
0000000000000000000000000000000000000000;;	// in the threadSafeMap.
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) ListKeys() []string {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		list := make([]string, 0, len(c.items))
0000000000000000000000000000000000000000;;		for key := range c.items {
0000000000000000000000000000000000000000;;			list = append(list, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) Replace(items map[string]interface{}, resourceVersion string) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.items = items
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rebuild any index
0000000000000000000000000000000000000000;;		c.indices = Indices{}
0000000000000000000000000000000000000000;;		for key, item := range c.items {
0000000000000000000000000000000000000000;;			c.updateIndices(nil, item, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Index returns a list of items that match on the index function
0000000000000000000000000000000000000000;;	// Index is thread-safe so long as you treat all items as immutable
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) Index(indexName string, obj interface{}) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indexFunc := c.indexers[indexName]
0000000000000000000000000000000000000000;;		if indexFunc == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Index with name %s does not exist", indexName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indexKeys, err := indexFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		index := c.indices[indexName]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// need to de-dupe the return list.  Since multiple keys are allowed, this can happen.
0000000000000000000000000000000000000000;;		returnKeySet := sets.String{}
0000000000000000000000000000000000000000;;		for _, indexKey := range indexKeys {
0000000000000000000000000000000000000000;;			set := index[indexKey]
0000000000000000000000000000000000000000;;			for _, key := range set.UnsortedList() {
0000000000000000000000000000000000000000;;				returnKeySet.Insert(key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list := make([]interface{}, 0, returnKeySet.Len())
0000000000000000000000000000000000000000;;		for absoluteKey := range returnKeySet {
0000000000000000000000000000000000000000;;			list = append(list, c.items[absoluteKey])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByIndex returns a list of items that match an exact value on the index function
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) ByIndex(indexName, indexKey string) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indexFunc := c.indexers[indexName]
0000000000000000000000000000000000000000;;		if indexFunc == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Index with name %s does not exist", indexName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		index := c.indices[indexName]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		set := index[indexKey]
0000000000000000000000000000000000000000;;		list := make([]interface{}, 0, set.Len())
0000000000000000000000000000000000000000;;		for _, key := range set.List() {
0000000000000000000000000000000000000000;;			list = append(list, c.items[key])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IndexKeys returns a list of keys that match on the index function.
0000000000000000000000000000000000000000;;	// IndexKeys is thread-safe so long as you treat all items as immutable.
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) IndexKeys(indexName, indexKey string) ([]string, error) {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		indexFunc := c.indexers[indexName]
0000000000000000000000000000000000000000;;		if indexFunc == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Index with name %s does not exist", indexName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		index := c.indices[indexName]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		set := index[indexKey]
0000000000000000000000000000000000000000;;		return set.List(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) ListIndexFuncValues(indexName string) []string {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		index := c.indices[indexName]
0000000000000000000000000000000000000000;;		names := make([]string, 0, len(index))
0000000000000000000000000000000000000000;;		for key := range index {
0000000000000000000000000000000000000000;;			names = append(names, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) GetIndexers() Indexers {
0000000000000000000000000000000000000000;;		return c.indexers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) AddIndexers(newIndexers Indexers) error {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.items) > 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot add indexers to running index")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldKeys := sets.StringKeySet(c.indexers)
0000000000000000000000000000000000000000;;		newKeys := sets.StringKeySet(newIndexers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldKeys.HasAny(newKeys.List()...) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("indexer conflict: %v", oldKeys.Intersection(newKeys))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range newIndexers {
0000000000000000000000000000000000000000;;			c.indexers[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// updateIndices modifies the objects location in the managed indexes, if this is an update, you must provide an oldObj
0000000000000000000000000000000000000000;;	// updateIndices must be called from a function that already has a lock on the cache
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) updateIndices(oldObj interface{}, newObj interface{}, key string) error {
0000000000000000000000000000000000000000;;		// if we got an old object, we need to remove it before we add it again
0000000000000000000000000000000000000000;;		if oldObj != nil {
0000000000000000000000000000000000000000;;			c.deleteFromIndices(oldObj, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, indexFunc := range c.indexers {
0000000000000000000000000000000000000000;;			indexValues, err := indexFunc(newObj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			index := c.indices[name]
0000000000000000000000000000000000000000;;			if index == nil {
0000000000000000000000000000000000000000;;				index = Index{}
0000000000000000000000000000000000000000;;				c.indices[name] = index
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, indexValue := range indexValues {
0000000000000000000000000000000000000000;;				set := index[indexValue]
0000000000000000000000000000000000000000;;				if set == nil {
0000000000000000000000000000000000000000;;					set = sets.String{}
0000000000000000000000000000000000000000;;					index[indexValue] = set
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				set.Insert(key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteFromIndices removes the object from each of the managed indexes
0000000000000000000000000000000000000000;;	// it is intended to be called from a function that already has a lock on the cache
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) deleteFromIndices(obj interface{}, key string) error {
0000000000000000000000000000000000000000;;		for name, indexFunc := range c.indexers {
0000000000000000000000000000000000000000;;			indexValues, err := indexFunc(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			index := c.indices[name]
0000000000000000000000000000000000000000;;			if index == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, indexValue := range indexValues {
0000000000000000000000000000000000000000;;				set := index[indexValue]
0000000000000000000000000000000000000000;;				if set != nil {
0000000000000000000000000000000000000000;;					set.Delete(key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *threadSafeMap) Resync() error {
0000000000000000000000000000000000000000;;		// Nothing to do
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewThreadSafeStore(indexers Indexers, indices Indices) ThreadSafeStore {
0000000000000000000000000000000000000000;;		return &threadSafeMap{
0000000000000000000000000000000000000000;;			items:    map[string]interface{}{},
0000000000000000000000000000000000000000;;			indexers: indexers,
0000000000000000000000000000000000000000;;			indices:  indices,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
