0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/delta_fifo.go[staging/src/k8s.io/client-go/1.4/tools/cache/delta_fifo.go][staging/src/k8s.io/client-go/tools/cache/delta_fifo.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDeltaFIFO returns a Store which can be used process changes to items.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// keyFunc is used to figure out what key an object should have. (It's
0000000000000000000000000000000000000000;;	// exposed in the returned DeltaFIFO's KeyOf() method, with bonus features.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 'compressor' may compress as many or as few items as it wants
0000000000000000000000000000000000000000;;	// (including returning an empty slice), but it should do what it
0000000000000000000000000000000000000000;;	// does quickly since it is called while the queue is locked.
0000000000000000000000000000000000000000;;	// 'compressor' may be nil if you don't want any delta compression.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 'keyLister' is expected to return a list of keys that the consumer of
0000000000000000000000000000000000000000;;	// this queue "knows about". It is used to decide which items are missing
0000000000000000000000000000000000000000;;	// when Replace() is called; 'Deleted' deltas are produced for these items.
0000000000000000000000000000000000000000;;	// It may be nil if you don't need to detect all deletions.
0000000000000000000000000000000000000000;;	// TODO: consider merging keyLister with this object, tracking a list of
0000000000000000000000000000000000000000;;	//       "known" keys when Pop() is called. Have to think about how that
0000000000000000000000000000000000000000;;	//       affects error retrying.
0000000000000000000000000000000000000000;;	// TODO(lavalamp): I believe there is a possible race only when using an
0000000000000000000000000000000000000000;;	//                 external known object source that the above TODO would
0000000000000000000000000000000000000000;;	//                 fix.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Also see the comment on DeltaFIFO.
0000000000000000000000000000000000000000;;	func NewDeltaFIFO(keyFunc KeyFunc, compressor DeltaCompressor, knownObjects KeyListerGetter) *DeltaFIFO {
0000000000000000000000000000000000000000;;		f := &DeltaFIFO{
0000000000000000000000000000000000000000;;			items:           map[string]Deltas{},
0000000000000000000000000000000000000000;;			queue:           []string{},
0000000000000000000000000000000000000000;;			keyFunc:         keyFunc,
0000000000000000000000000000000000000000;;			deltaCompressor: compressor,
0000000000000000000000000000000000000000;;			knownObjects:    knownObjects,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.cond.L = &f.lock
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeltaFIFO is like FIFO, but allows you to process deletes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// DeltaFIFO is a producer-consumer queue, where a Reflector is
0000000000000000000000000000000000000000;;	// intended to be the producer, and the consumer is whatever calls
0000000000000000000000000000000000000000;;	// the Pop() method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// DeltaFIFO solves this use case:
0000000000000000000000000000000000000000;;	//  * You want to process every object change (delta) at most once.
0000000000000000000000000000000000000000;;	//  * When you process an object, you want to see everything
0000000000000000000000000000000000000000;;	//    that's happened to it since you last processed it.
0000000000000000000000000000000000000000;;	//  * You want to process the deletion of objects.
0000000000000000000000000000000000000000;;	//  * You might want to periodically reprocess objects.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// DeltaFIFO's Pop(), Get(), and GetByKey() methods return
0000000000000000000000000000000000000000;;	// interface{} to satisfy the Store/Queue interfaces, but it
0000000000000000000000000000000000000000;;	// will always return an object of type Deltas.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A note on threading: If you call Pop() in parallel from multiple
0000000000000000000000000000000000000000;;	// threads, you could end up with multiple threads processing slightly
0000000000000000000000000000000000000000;;	// different versions of the same object.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A note on the KeyLister used by the DeltaFIFO: It's main purpose is
0000000000000000000000000000000000000000;;	// to list keys that are "known", for the purpose of figuring out which
0000000000000000000000000000000000000000;;	// items have been deleted when Replace() or Delete() are called. The deleted
0000000000000000000000000000000000000000;;	// object will be included in the DeleteFinalStateUnknown markers. These objects
0000000000000000000000000000000000000000;;	// could be stale.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// You may provide a function to compress deltas (e.g., represent a
0000000000000000000000000000000000000000;;	// series of Updates as a single Update).
0000000000000000000000000000000000000000;;	type DeltaFIFO struct {
0000000000000000000000000000000000000000;;		// lock/cond protects access to 'items' and 'queue'.
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;		cond sync.Cond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We depend on the property that items in the set are in
0000000000000000000000000000000000000000;;		// the queue and vice versa, and that all Deltas in this
0000000000000000000000000000000000000000;;		// map have at least one Delta.
0000000000000000000000000000000000000000;;		items map[string]Deltas
0000000000000000000000000000000000000000;;		queue []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// populated is true if the first batch of items inserted by Replace() has been populated
0000000000000000000000000000000000000000;;		// or Delete/Add/Update was called first.
0000000000000000000000000000000000000000;;		populated bool
0000000000000000000000000000000000000000;;		// initialPopulationCount is the number of items inserted by the first call of Replace()
0000000000000000000000000000000000000000;;		initialPopulationCount int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keyFunc is used to make the key used for queued item
0000000000000000000000000000000000000000;;		// insertion and retrieval, and should be deterministic.
0000000000000000000000000000000000000000;;		keyFunc KeyFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// deltaCompressor tells us how to combine two or more
0000000000000000000000000000000000000000;;		// deltas. It may be nil.
0000000000000000000000000000000000000000;;		deltaCompressor DeltaCompressor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// knownObjects list keys that are "known", for the
0000000000000000000000000000000000000000;;		// purpose of figuring out which items have been deleted
0000000000000000000000000000000000000000;;		// when Replace() or Delete() is called.
0000000000000000000000000000000000000000;;		knownObjects KeyListerGetter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Indication the queue is closed.
0000000000000000000000000000000000000000;;		// Used to indicate a queue is closed so a control loop can exit when a queue is empty.
0000000000000000000000000000000000000000;;		// Currently, not used to gate any of CRED operations.
0000000000000000000000000000000000000000;;		closed     bool
0000000000000000000000000000000000000000;;		closedLock sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ = Queue(&DeltaFIFO{}) // DeltaFIFO is a Queue
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrZeroLengthDeltasObject is returned in a KeyError if a Deltas
0000000000000000000000000000000000000000;;		// object with zero length is encountered (should be impossible,
0000000000000000000000000000000000000000;;		// even if such an object is accidentally produced by a DeltaCompressor--
0000000000000000000000000000000000000000;;		// but included for completeness).
0000000000000000000000000000000000000000;;		ErrZeroLengthDeltasObject = errors.New("0 length Deltas object; can't get key")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close the queue.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) Close() {
0000000000000000000000000000000000000000;;		f.closedLock.Lock()
0000000000000000000000000000000000000000;;		defer f.closedLock.Unlock()
0000000000000000000000000000000000000000;;		f.closed = true
0000000000000000000000000000000000000000;;		f.cond.Broadcast()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyOf exposes f's keyFunc, but also detects the key of a Deltas object or
0000000000000000000000000000000000000000;;	// DeletedFinalStateUnknown objects.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) KeyOf(obj interface{}) (string, error) {
0000000000000000000000000000000000000000;;		if d, ok := obj.(Deltas); ok {
0000000000000000000000000000000000000000;;			if len(d) == 0 {
0000000000000000000000000000000000000000;;				return "", KeyError{obj, ErrZeroLengthDeltasObject}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj = d.Newest().Object
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d, ok := obj.(DeletedFinalStateUnknown); ok {
0000000000000000000000000000000000000000;;			return d.Key, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.keyFunc(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return true if an Add/Update/Delete/AddIfNotPresent are called first,
0000000000000000000000000000000000000000;;	// or an Update called first but the first batch of items inserted by Replace() has been popped
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) HasSynced() bool {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		return f.populated && f.initialPopulationCount == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add inserts an item, and puts it in the queue. The item is only enqueued
0000000000000000000000000000000000000000;;	// if it doesn't already exist in the set.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) Add(obj interface{}) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		f.populated = true
0000000000000000000000000000000000000000;;		return f.queueActionLocked(Added, obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update is just like Add, but makes an Updated Delta.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) Update(obj interface{}) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		f.populated = true
0000000000000000000000000000000000000000;;		return f.queueActionLocked(Updated, obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete is just like Add, but makes an Deleted Delta. If the item does not
0000000000000000000000000000000000000000;;	// already exist, it will be ignored. (It may have already been deleted by a
0000000000000000000000000000000000000000;;	// Replace (re-list), for example.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) Delete(obj interface{}) error {
0000000000000000000000000000000000000000;;		id, err := f.KeyOf(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		f.populated = true
0000000000000000000000000000000000000000;;		if f.knownObjects == nil {
0000000000000000000000000000000000000000;;			if _, exists := f.items[id]; !exists {
0000000000000000000000000000000000000000;;				// Presumably, this was deleted when a relist happened.
0000000000000000000000000000000000000000;;				// Don't provide a second report of the same deletion.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// We only want to skip the "deletion" action if the object doesn't
0000000000000000000000000000000000000000;;			// exist in knownObjects and it doesn't have corresponding item in items.
0000000000000000000000000000000000000000;;			// Note that even if there is a "deletion" action in items, we can ignore it,
0000000000000000000000000000000000000000;;			// because it will be deduped automatically in "queueActionLocked"
0000000000000000000000000000000000000000;;			_, exists, err := f.knownObjects.GetByKey(id)
0000000000000000000000000000000000000000;;			_, itemsExist := f.items[id]
0000000000000000000000000000000000000000;;			if err == nil && !exists && !itemsExist {
0000000000000000000000000000000000000000;;				// Presumably, this was deleted when a relist happened.
0000000000000000000000000000000000000000;;				// Don't provide a second report of the same deletion.
0000000000000000000000000000000000000000;;				// TODO(lavalamp): This may be racy-- we aren't properly locked
0000000000000000000000000000000000000000;;				// with knownObjects.
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.queueActionLocked(Deleted, obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddIfNotPresent inserts an item, and puts it in the queue. If the item is already
0000000000000000000000000000000000000000;;	// present in the set, it is neither enqueued nor added to the set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is useful in a single producer/consumer scenario so that the consumer can
0000000000000000000000000000000000000000;;	// safely retry items without contending with the producer and potentially enqueueing
0000000000000000000000000000000000000000;;	// stale items.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Important: obj must be a Deltas (the output of the Pop() function). Yes, this is
0000000000000000000000000000000000000000;;	// different from the Add/Update/Delete functions.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) AddIfNotPresent(obj interface{}) error {
0000000000000000000000000000000000000000;;		deltas, ok := obj.(Deltas)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("object must be of type deltas, but got: %#v", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		id, err := f.KeyOf(deltas.Newest().Object)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		f.addIfNotPresent(id, deltas)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addIfNotPresent inserts deltas under id if it does not exist, and assumes the caller
0000000000000000000000000000000000000000;;	// already holds the fifo lock.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) addIfNotPresent(id string, deltas Deltas) {
0000000000000000000000000000000000000000;;		f.populated = true
0000000000000000000000000000000000000000;;		if _, exists := f.items[id]; exists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.queue = append(f.queue, id)
0000000000000000000000000000000000000000;;		f.items[id] = deltas
0000000000000000000000000000000000000000;;		f.cond.Broadcast()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// re-listing and watching can deliver the same update multiple times in any
0000000000000000000000000000000000000000;;	// order. This will combine the most recent two deltas if they are the same.
0000000000000000000000000000000000000000;;	func dedupDeltas(deltas Deltas) Deltas {
0000000000000000000000000000000000000000;;		n := len(deltas)
0000000000000000000000000000000000000000;;		if n < 2 {
0000000000000000000000000000000000000000;;			return deltas
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a := &deltas[n-1]
0000000000000000000000000000000000000000;;		b := &deltas[n-2]
0000000000000000000000000000000000000000;;		if out := isDup(a, b); out != nil {
0000000000000000000000000000000000000000;;			d := append(Deltas{}, deltas[:n-2]...)
0000000000000000000000000000000000000000;;			return append(d, *out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return deltas
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If a & b represent the same event, returns the delta that ought to be kept.
0000000000000000000000000000000000000000;;	// Otherwise, returns nil.
0000000000000000000000000000000000000000;;	// TODO: is there anything other than deletions that need deduping?
0000000000000000000000000000000000000000;;	func isDup(a, b *Delta) *Delta {
0000000000000000000000000000000000000000;;		if out := isDeletionDup(a, b); out != nil {
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Detect other duplicate situations? Are there any?
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keep the one with the most information if both are deletions.
0000000000000000000000000000000000000000;;	func isDeletionDup(a, b *Delta) *Delta {
0000000000000000000000000000000000000000;;		if b.Type != Deleted || a.Type != Deleted {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Do more sophisticated checks, or is this sufficient?
0000000000000000000000000000000000000000;;		if _, ok := b.Object.(DeletedFinalStateUnknown); ok {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// willObjectBeDeletedLocked returns true only if the last delta for the
0000000000000000000000000000000000000000;;	// given object is Delete. Caller must lock first.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) willObjectBeDeletedLocked(id string) bool {
0000000000000000000000000000000000000000;;		deltas := f.items[id]
0000000000000000000000000000000000000000;;		return len(deltas) > 0 && deltas[len(deltas)-1].Type == Deleted
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// queueActionLocked appends to the delta list for the object, calling
0000000000000000000000000000000000000000;;	// f.deltaCompressor if needed. Caller must lock first.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) queueActionLocked(actionType DeltaType, obj interface{}) error {
0000000000000000000000000000000000000000;;		id, err := f.KeyOf(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If object is supposed to be deleted (last event is Deleted),
0000000000000000000000000000000000000000;;		// then we should ignore Sync events, because it would result in
0000000000000000000000000000000000000000;;		// recreation of this object.
0000000000000000000000000000000000000000;;		if actionType == Sync && f.willObjectBeDeletedLocked(id) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newDeltas := append(f.items[id], Delta{actionType, obj})
0000000000000000000000000000000000000000;;		newDeltas = dedupDeltas(newDeltas)
0000000000000000000000000000000000000000;;		if f.deltaCompressor != nil {
0000000000000000000000000000000000000000;;			newDeltas = f.deltaCompressor.Compress(newDeltas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, exists := f.items[id]
0000000000000000000000000000000000000000;;		if len(newDeltas) > 0 {
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				f.queue = append(f.queue, id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.items[id] = newDeltas
0000000000000000000000000000000000000000;;			f.cond.Broadcast()
0000000000000000000000000000000000000000;;		} else if exists {
0000000000000000000000000000000000000000;;			// The compression step removed all deltas, so
0000000000000000000000000000000000000000;;			// we need to remove this from our map (extra items
0000000000000000000000000000000000000000;;			// in the queue are ignored if they are not in the
0000000000000000000000000000000000000000;;			// map).
0000000000000000000000000000000000000000;;			delete(f.items, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list of all the items; it returns the object
0000000000000000000000000000000000000000;;	// from the most recent Delta.
0000000000000000000000000000000000000000;;	// You should treat the items returned inside the deltas as immutable.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) List() []interface{} {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		return f.listLocked()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) listLocked() []interface{} {
0000000000000000000000000000000000000000;;		list := make([]interface{}, 0, len(f.items))
0000000000000000000000000000000000000000;;		for _, item := range f.items {
0000000000000000000000000000000000000000;;			// Copy item's slice so operations on this slice (delta
0000000000000000000000000000000000000000;;			// compression) won't interfere with the object we return.
0000000000000000000000000000000000000000;;			item = copyDeltas(item)
0000000000000000000000000000000000000000;;			list = append(list, item.Newest().Object)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListKeys returns a list of all the keys of the objects currently
0000000000000000000000000000000000000000;;	// in the FIFO.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) ListKeys() []string {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		list := make([]string, 0, len(f.items))
0000000000000000000000000000000000000000;;		for key := range f.items {
0000000000000000000000000000000000000000;;			list = append(list, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the complete list of deltas for the requested item,
0000000000000000000000000000000000000000;;	// or sets exists=false.
0000000000000000000000000000000000000000;;	// You should treat the items returned inside the deltas as immutable.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) Get(obj interface{}) (item interface{}, exists bool, err error) {
0000000000000000000000000000000000000000;;		key, err := f.KeyOf(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.GetByKey(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetByKey returns the complete list of deltas for the requested item,
0000000000000000000000000000000000000000;;	// setting exists=false if that list is empty.
0000000000000000000000000000000000000000;;	// You should treat the items returned inside the deltas as immutable.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) GetByKey(key string) (item interface{}, exists bool, err error) {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		d, exists := f.items[key]
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			// Copy item's slice so operations on this slice (delta
0000000000000000000000000000000000000000;;			// compression) won't interfere with the object we return.
0000000000000000000000000000000000000000;;			d = copyDeltas(d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d, exists, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks if the queue is closed
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) IsClosed() bool {
0000000000000000000000000000000000000000;;		f.closedLock.Lock()
0000000000000000000000000000000000000000;;		defer f.closedLock.Unlock()
0000000000000000000000000000000000000000;;		if f.closed {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pop blocks until an item is added to the queue, and then returns it.  If
0000000000000000000000000000000000000000;;	// multiple items are ready, they are returned in the order in which they were
0000000000000000000000000000000000000000;;	// added/updated. The item is removed from the queue (and the store) before it
0000000000000000000000000000000000000000;;	// is returned, so if you don't successfully process it, you need to add it back
0000000000000000000000000000000000000000;;	// with AddIfNotPresent().
0000000000000000000000000000000000000000;;	// process function is called under lock, so it is safe update data structures
0000000000000000000000000000000000000000;;	// in it that need to be in sync with the queue (e.g. knownKeys). The PopProcessFunc
0000000000000000000000000000000000000000;;	// may return an instance of ErrRequeue with a nested error to indicate the current
0000000000000000000000000000000000000000;;	// item should be requeued (equivalent to calling AddIfNotPresent under the lock).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Pop returns a 'Deltas', which has a complete list of all the things
0000000000000000000000000000000000000000;;	// that happened to the object (deltas) while it was sitting in the queue.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) Pop(process PopProcessFunc) (interface{}, error) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			for len(f.queue) == 0 {
0000000000000000000000000000000000000000;;				// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.
0000000000000000000000000000000000000000;;				// When Close() is called, the f.closed is set and the condition is broadcasted.
0000000000000000000000000000000000000000;;				// Which causes this loop to continue and return from the Pop().
0000000000000000000000000000000000000000;;				if f.IsClosed() {
0000000000000000000000000000000000000000;;					return nil, FIFOClosedError
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				f.cond.Wait()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			id := f.queue[0]
0000000000000000000000000000000000000000;;			f.queue = f.queue[1:]
0000000000000000000000000000000000000000;;			item, ok := f.items[id]
0000000000000000000000000000000000000000;;			if f.initialPopulationCount > 0 {
0000000000000000000000000000000000000000;;				f.initialPopulationCount--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// Item may have been deleted subsequently.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(f.items, id)
0000000000000000000000000000000000000000;;			err := process(item)
0000000000000000000000000000000000000000;;			if e, ok := err.(ErrRequeue); ok {
0000000000000000000000000000000000000000;;				f.addIfNotPresent(id, item)
0000000000000000000000000000000000000000;;				err = e.Err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Don't need to copyDeltas here, because we're transferring
0000000000000000000000000000000000000000;;			// ownership to the caller.
0000000000000000000000000000000000000000;;			return item, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replace will delete the contents of 'f', using instead the given map.
0000000000000000000000000000000000000000;;	// 'f' takes ownership of the map, you should not reference the map again
0000000000000000000000000000000000000000;;	// after calling this function. f's queue is reset, too; upon return, it
0000000000000000000000000000000000000000;;	// will contain the items in the map, in no particular order.
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) Replace(list []interface{}, resourceVersion string) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		keys := make(sets.String, len(list))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, item := range list {
0000000000000000000000000000000000000000;;			key, err := f.KeyOf(item)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return KeyError{item, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keys.Insert(key)
0000000000000000000000000000000000000000;;			if err := f.queueActionLocked(Sync, item); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("couldn't enqueue object: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.knownObjects == nil {
0000000000000000000000000000000000000000;;			// Do deletion detection against our own list.
0000000000000000000000000000000000000000;;			for k, oldItem := range f.items {
0000000000000000000000000000000000000000;;				if keys.Has(k) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var deletedObj interface{}
0000000000000000000000000000000000000000;;				if n := oldItem.Newest(); n != nil {
0000000000000000000000000000000000000000;;					deletedObj = n.Object
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := f.queueActionLocked(Deleted, DeletedFinalStateUnknown{k, deletedObj}); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !f.populated {
0000000000000000000000000000000000000000;;				f.populated = true
0000000000000000000000000000000000000000;;				f.initialPopulationCount = len(list)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Detect deletions not already in the queue.
0000000000000000000000000000000000000000;;		// TODO(lavalamp): This may be racy-- we aren't properly locked
0000000000000000000000000000000000000000;;		// with knownObjects. Unproven.
0000000000000000000000000000000000000000;;		knownKeys := f.knownObjects.ListKeys()
0000000000000000000000000000000000000000;;		queuedDeletions := 0
0000000000000000000000000000000000000000;;		for _, k := range knownKeys {
0000000000000000000000000000000000000000;;			if keys.Has(k) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			deletedObj, exists, err := f.knownObjects.GetByKey(k)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				deletedObj = nil
0000000000000000000000000000000000000000;;				glog.Errorf("Unexpected error %v during lookup of key %v, placing DeleteFinalStateUnknown marker without object", err, k)
0000000000000000000000000000000000000000;;			} else if !exists {
0000000000000000000000000000000000000000;;				deletedObj = nil
0000000000000000000000000000000000000000;;				glog.Infof("Key %v does not exist in known objects store, placing DeleteFinalStateUnknown marker without object", k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			queuedDeletions++
0000000000000000000000000000000000000000;;			if err := f.queueActionLocked(Deleted, DeletedFinalStateUnknown{k, deletedObj}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !f.populated {
0000000000000000000000000000000000000000;;			f.populated = true
0000000000000000000000000000000000000000;;			f.initialPopulationCount = len(list) + queuedDeletions
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resync will send a sync event for each item
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) Resync() error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keys := f.knownObjects.ListKeys()
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			if err := f.syncKeyLocked(k); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) syncKey(key string) error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.syncKeyLocked(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *DeltaFIFO) syncKeyLocked(key string) error {
0000000000000000000000000000000000000000;;		obj, exists, err := f.knownObjects.GetByKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Unexpected error %v during lookup of key %v, unable to queue object for sync", err, key)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if !exists {
0000000000000000000000000000000000000000;;			glog.Infof("Key %v does not exist in known objects store, unable to queue object for sync", key)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we are doing Resync() and there is already an event queued for that object,
0000000000000000000000000000000000000000;;		// we ignore the Resync for it. This is to avoid the race, in which the resync
0000000000000000000000000000000000000000;;		// comes with the previous value of object (since queueing an event for the object
0000000000000000000000000000000000000000;;		// doesn't trigger changing the underlying store <knownObjects>.
0000000000000000000000000000000000000000;;		id, err := f.KeyOf(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(f.items[id]) > 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := f.queueActionLocked(Sync, obj); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("couldn't queue object: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A KeyListerGetter is anything that knows how to list its keys and look up by key.
0000000000000000000000000000000000000000;;	type KeyListerGetter interface {
0000000000000000000000000000000000000000;;		KeyLister
0000000000000000000000000000000000000000;;		KeyGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A KeyLister is anything that knows how to list its keys.
0000000000000000000000000000000000000000;;	type KeyLister interface {
0000000000000000000000000000000000000000;;		ListKeys() []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A KeyGetter is anything that knows how to get the value stored under a given key.
0000000000000000000000000000000000000000;;	type KeyGetter interface {
0000000000000000000000000000000000000000;;		GetByKey(key string) (interface{}, bool, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeltaCompressor is an algorithm that removes redundant changes.
0000000000000000000000000000000000000000;;	type DeltaCompressor interface {
0000000000000000000000000000000000000000;;		Compress(Deltas) Deltas
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeltaCompressorFunc should remove redundant changes; but changes that
0000000000000000000000000000000000000000;;	// are redundant depend on one's desired semantics, so this is an
0000000000000000000000000000000000000000;;	// injectable function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// DeltaCompressorFunc adapts a raw function to be a DeltaCompressor.
0000000000000000000000000000000000000000;;	type DeltaCompressorFunc func(Deltas) Deltas
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compress just calls dc.
0000000000000000000000000000000000000000;;	func (dc DeltaCompressorFunc) Compress(d Deltas) Deltas {
0000000000000000000000000000000000000000;;		return dc(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeltaType is the type of a change (addition, deletion, etc)
0000000000000000000000000000000000000000;;	type DeltaType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Added   DeltaType = "Added"
0000000000000000000000000000000000000000;;		Updated DeltaType = "Updated"
0000000000000000000000000000000000000000;;		Deleted DeltaType = "Deleted"
0000000000000000000000000000000000000000;;		// The other types are obvious. You'll get Sync deltas when:
0000000000000000000000000000000000000000;;		//  * A watch expires/errors out and a new list/watch cycle is started.
0000000000000000000000000000000000000000;;		//  * You've turned on periodic syncs.
0000000000000000000000000000000000000000;;		// (Anything that trigger's DeltaFIFO's Replace() method.)
0000000000000000000000000000000000000000;;		Sync DeltaType = "Sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delta is the type stored by a DeltaFIFO. It tells you what change
0000000000000000000000000000000000000000;;	// happened, and the object's state after* that change.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// [*] Unless the change is a deletion, and then you'll get the final
0000000000000000000000000000000000000000;;	//     state of the object before it was deleted.
0000000000000000000000000000000000000000;;	type Delta struct {
0000000000000000000000000000000000000000;;		Type   DeltaType
0000000000000000000000000000000000000000;;		Object interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deltas is a list of one or more 'Delta's to an individual object.
0000000000000000000000000000000000000000;;	// The oldest delta is at index 0, the newest delta is the last one.
0000000000000000000000000000000000000000;;	type Deltas []Delta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Oldest is a convenience function that returns the oldest delta, or
0000000000000000000000000000000000000000;;	// nil if there are no deltas.
0000000000000000000000000000000000000000;;	func (d Deltas) Oldest() *Delta {
0000000000000000000000000000000000000000;;		if len(d) > 0 {
0000000000000000000000000000000000000000;;			return &d[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Newest is a convenience function that returns the newest delta, or
0000000000000000000000000000000000000000;;	// nil if there are no deltas.
0000000000000000000000000000000000000000;;	func (d Deltas) Newest() *Delta {
0000000000000000000000000000000000000000;;		if n := len(d); n > 0 {
0000000000000000000000000000000000000000;;			return &d[n-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyDeltas returns a shallow copy of d; that is, it copies the slice but not
0000000000000000000000000000000000000000;;	// the objects in the slice. This allows Get/List to return an object that we
0000000000000000000000000000000000000000;;	// know won't be clobbered by a subsequent call to a delta compressor.
0000000000000000000000000000000000000000;;	func copyDeltas(d Deltas) Deltas {
0000000000000000000000000000000000000000;;		d2 := make(Deltas, len(d))
0000000000000000000000000000000000000000;;		copy(d2, d)
0000000000000000000000000000000000000000;;		return d2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeletedFinalStateUnknown is placed into a DeltaFIFO in the case where
0000000000000000000000000000000000000000;;	// an object was deleted but the watch deletion event was missed. In this
0000000000000000000000000000000000000000;;	// case we don't know the final "resting" state of the object, so there's
0000000000000000000000000000000000000000;;	// a chance the included `Obj` is stale.
0000000000000000000000000000000000000000;;	type DeletedFinalStateUnknown struct {
0000000000000000000000000000000000000000;;		Key string
0000000000000000000000000000000000000000;;		Obj interface{}
0000000000000000000000000000000000000000;;	}
