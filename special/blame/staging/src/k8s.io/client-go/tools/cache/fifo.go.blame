0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/fifo.go[staging/src/k8s.io/client-go/1.4/tools/cache/fifo.go][staging/src/k8s.io/client-go/tools/cache/fifo.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PopProcessFunc is passed to Pop() method of Queue interface.
0000000000000000000000000000000000000000;;	// It is supposed to process the element popped from the queue.
0000000000000000000000000000000000000000;;	type PopProcessFunc func(interface{}) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrRequeue may be returned by a PopProcessFunc to safely requeue
0000000000000000000000000000000000000000;;	// the current item. The value of Err will be returned from Pop.
0000000000000000000000000000000000000000;;	type ErrRequeue struct {
0000000000000000000000000000000000000000;;		// Err is returned by the Pop function
0000000000000000000000000000000000000000;;		Err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var FIFOClosedError error = errors.New("DeltaFIFO: manipulating with closed queue")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e ErrRequeue) Error() string {
0000000000000000000000000000000000000000;;		if e.Err == nil {
0000000000000000000000000000000000000000;;			return "the popped item should be requeued without returning an error"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e.Err.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Queue is exactly like a Store, but has a Pop() method too.
0000000000000000000000000000000000000000;;	type Queue interface {
0000000000000000000000000000000000000000;;		Store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pop blocks until it has something to process.
0000000000000000000000000000000000000000;;		// It returns the object that was process and the result of processing.
0000000000000000000000000000000000000000;;		// The PopProcessFunc may return an ErrRequeue{...} to indicate the item
0000000000000000000000000000000000000000;;		// should be requeued before releasing the lock on the queue.
0000000000000000000000000000000000000000;;		Pop(PopProcessFunc) (interface{}, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AddIfNotPresent adds a value previously
0000000000000000000000000000000000000000;;		// returned by Pop back into the queue as long
0000000000000000000000000000000000000000;;		// as nothing else (presumably more recent)
0000000000000000000000000000000000000000;;		// has since been added.
0000000000000000000000000000000000000000;;		AddIfNotPresent(interface{}) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return true if the first batch of items has been popped
0000000000000000000000000000000000000000;;		HasSynced() bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close queue
0000000000000000000000000000000000000000;;		Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helper function for popping from Queue.
0000000000000000000000000000000000000000;;	// WARNING: Do NOT use this function in non-test code to avoid races
0000000000000000000000000000000000000000;;	// unless you really really really really know what you are doing.
0000000000000000000000000000000000000000;;	func Pop(queue Queue) interface{} {
0000000000000000000000000000000000000000;;		var result interface{}
0000000000000000000000000000000000000000;;		queue.Pop(func(obj interface{}) error {
0000000000000000000000000000000000000000;;			result = obj
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FIFO receives adds and updates from a Reflector, and puts them in a queue for
0000000000000000000000000000000000000000;;	// FIFO order processing. If multiple adds/updates of a single item happen while
0000000000000000000000000000000000000000;;	// an item is in the queue before it has been processed, it will only be
0000000000000000000000000000000000000000;;	// processed once, and when it is processed, the most recent version will be
0000000000000000000000000000000000000000;;	// processed. This can't be done with a channel.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// FIFO solves this use case:
0000000000000000000000000000000000000000;;	//  * You want to process every object (exactly) once.
0000000000000000000000000000000000000000;;	//  * You want to process the most recent version of the object when you process it.
0000000000000000000000000000000000000000;;	//  * You do not want to process deleted objects, they should be removed from the queue.
0000000000000000000000000000000000000000;;	//  * You do not want to periodically reprocess objects.
0000000000000000000000000000000000000000;;	// Compare with DeltaFIFO for other use cases.
0000000000000000000000000000000000000000;;	type FIFO struct {
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;		cond sync.Cond
0000000000000000000000000000000000000000;;		// We depend on the property that items in the set are in the queue and vice versa.
0000000000000000000000000000000000000000;;		items map[string]interface{}
0000000000000000000000000000000000000000;;		queue []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// populated is true if the first batch of items inserted by Replace() has been populated
0000000000000000000000000000000000000000;;		// or Delete/Add/Update was called first.
0000000000000000000000000000000000000000;;		populated bool
0000000000000000000000000000000000000000;;		// initialPopulationCount is the number of items inserted by the first call of Replace()
0000000000000000000000000000000000000000;;		initialPopulationCount int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keyFunc is used to make the key used for queued item insertion and retrieval, and
0000000000000000000000000000000000000000;;		// should be deterministic.
0000000000000000000000000000000000000000;;		keyFunc KeyFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Indication the queue is closed.
0000000000000000000000000000000000000000;;		// Used to indicate a queue is closed so a control loop can exit when a queue is empty.
0000000000000000000000000000000000000000;;		// Currently, not used to gate any of CRED operations.
0000000000000000000000000000000000000000;;		closed     bool
0000000000000000000000000000000000000000;;		closedLock sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_ = Queue(&FIFO{}) // FIFO is a Queue
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close the queue.
0000000000000000000000000000000000000000;;	func (f *FIFO) Close() {
0000000000000000000000000000000000000000;;		f.closedLock.Lock()
0000000000000000000000000000000000000000;;		defer f.closedLock.Unlock()
0000000000000000000000000000000000000000;;		f.closed = true
0000000000000000000000000000000000000000;;		f.cond.Broadcast()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return true if an Add/Update/Delete/AddIfNotPresent are called first,
0000000000000000000000000000000000000000;;	// or an Update called first but the first batch of items inserted by Replace() has been popped
0000000000000000000000000000000000000000;;	func (f *FIFO) HasSynced() bool {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		return f.populated && f.initialPopulationCount == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add inserts an item, and puts it in the queue. The item is only enqueued
0000000000000000000000000000000000000000;;	// if it doesn't already exist in the set.
0000000000000000000000000000000000000000;;	func (f *FIFO) Add(obj interface{}) error {
0000000000000000000000000000000000000000;;		id, err := f.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		f.populated = true
0000000000000000000000000000000000000000;;		if _, exists := f.items[id]; !exists {
0000000000000000000000000000000000000000;;			f.queue = append(f.queue, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.items[id] = obj
0000000000000000000000000000000000000000;;		f.cond.Broadcast()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddIfNotPresent inserts an item, and puts it in the queue. If the item is already
0000000000000000000000000000000000000000;;	// present in the set, it is neither enqueued nor added to the set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is useful in a single producer/consumer scenario so that the consumer can
0000000000000000000000000000000000000000;;	// safely retry items without contending with the producer and potentially enqueueing
0000000000000000000000000000000000000000;;	// stale items.
0000000000000000000000000000000000000000;;	func (f *FIFO) AddIfNotPresent(obj interface{}) error {
0000000000000000000000000000000000000000;;		id, err := f.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		f.addIfNotPresent(id, obj)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addIfNotPresent assumes the fifo lock is already held and adds the the provided
0000000000000000000000000000000000000000;;	// item to the queue under id if it does not already exist.
0000000000000000000000000000000000000000;;	func (f *FIFO) addIfNotPresent(id string, obj interface{}) {
0000000000000000000000000000000000000000;;		f.populated = true
0000000000000000000000000000000000000000;;		if _, exists := f.items[id]; exists {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.queue = append(f.queue, id)
0000000000000000000000000000000000000000;;		f.items[id] = obj
0000000000000000000000000000000000000000;;		f.cond.Broadcast()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update is the same as Add in this implementation.
0000000000000000000000000000000000000000;;	func (f *FIFO) Update(obj interface{}) error {
0000000000000000000000000000000000000000;;		return f.Add(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes an item. It doesn't add it to the queue, because
0000000000000000000000000000000000000000;;	// this implementation assumes the consumer only cares about the objects,
0000000000000000000000000000000000000000;;	// not the order in which they were created/added.
0000000000000000000000000000000000000000;;	func (f *FIFO) Delete(obj interface{}) error {
0000000000000000000000000000000000000000;;		id, err := f.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		f.populated = true
0000000000000000000000000000000000000000;;		delete(f.items, id)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list of all the items.
0000000000000000000000000000000000000000;;	func (f *FIFO) List() []interface{} {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		list := make([]interface{}, 0, len(f.items))
0000000000000000000000000000000000000000;;		for _, item := range f.items {
0000000000000000000000000000000000000000;;			list = append(list, item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListKeys returns a list of all the keys of the objects currently
0000000000000000000000000000000000000000;;	// in the FIFO.
0000000000000000000000000000000000000000;;	func (f *FIFO) ListKeys() []string {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		list := make([]string, 0, len(f.items))
0000000000000000000000000000000000000000;;		for key := range f.items {
0000000000000000000000000000000000000000;;			list = append(list, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return list
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the requested item, or sets exists=false.
0000000000000000000000000000000000000000;;	func (f *FIFO) Get(obj interface{}) (item interface{}, exists bool, err error) {
0000000000000000000000000000000000000000;;		key, err := f.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.GetByKey(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetByKey returns the requested item, or sets exists=false.
0000000000000000000000000000000000000000;;	func (f *FIFO) GetByKey(key string) (item interface{}, exists bool, err error) {
0000000000000000000000000000000000000000;;		f.lock.RLock()
0000000000000000000000000000000000000000;;		defer f.lock.RUnlock()
0000000000000000000000000000000000000000;;		item, exists = f.items[key]
0000000000000000000000000000000000000000;;		return item, exists, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks if the queue is closed
0000000000000000000000000000000000000000;;	func (f *FIFO) IsClosed() bool {
0000000000000000000000000000000000000000;;		f.closedLock.Lock()
0000000000000000000000000000000000000000;;		defer f.closedLock.Unlock()
0000000000000000000000000000000000000000;;		if f.closed {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pop waits until an item is ready and processes it. If multiple items are
0000000000000000000000000000000000000000;;	// ready, they are returned in the order in which they were added/updated.
0000000000000000000000000000000000000000;;	// The item is removed from the queue (and the store) before it is processed,
0000000000000000000000000000000000000000;;	// so if you don't successfully process it, it should be added back with
0000000000000000000000000000000000000000;;	// AddIfNotPresent(). process function is called under lock, so it is safe
0000000000000000000000000000000000000000;;	// update data structures in it that need to be in sync with the queue.
0000000000000000000000000000000000000000;;	func (f *FIFO) Pop(process PopProcessFunc) (interface{}, error) {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			for len(f.queue) == 0 {
0000000000000000000000000000000000000000;;				// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.
0000000000000000000000000000000000000000;;				// When Close() is called, the f.closed is set and the condition is broadcasted.
0000000000000000000000000000000000000000;;				// Which causes this loop to continue and return from the Pop().
0000000000000000000000000000000000000000;;				if f.IsClosed() {
0000000000000000000000000000000000000000;;					return nil, FIFOClosedError
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				f.cond.Wait()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			id := f.queue[0]
0000000000000000000000000000000000000000;;			f.queue = f.queue[1:]
0000000000000000000000000000000000000000;;			if f.initialPopulationCount > 0 {
0000000000000000000000000000000000000000;;				f.initialPopulationCount--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			item, ok := f.items[id]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// Item may have been deleted subsequently.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(f.items, id)
0000000000000000000000000000000000000000;;			err := process(item)
0000000000000000000000000000000000000000;;			if e, ok := err.(ErrRequeue); ok {
0000000000000000000000000000000000000000;;				f.addIfNotPresent(id, item)
0000000000000000000000000000000000000000;;				err = e.Err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return item, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replace will delete the contents of 'f', using instead the given map.
0000000000000000000000000000000000000000;;	// 'f' takes ownership of the map, you should not reference the map again
0000000000000000000000000000000000000000;;	// after calling this function. f's queue is reset, too; upon return, it
0000000000000000000000000000000000000000;;	// will contain the items in the map, in no particular order.
0000000000000000000000000000000000000000;;	func (f *FIFO) Replace(list []interface{}, resourceVersion string) error {
0000000000000000000000000000000000000000;;		items := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for _, item := range list {
0000000000000000000000000000000000000000;;			key, err := f.keyFunc(item)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return KeyError{item, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			items[key] = item
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !f.populated {
0000000000000000000000000000000000000000;;			f.populated = true
0000000000000000000000000000000000000000;;			f.initialPopulationCount = len(items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.items = items
0000000000000000000000000000000000000000;;		f.queue = f.queue[:0]
0000000000000000000000000000000000000000;;		for id := range items {
0000000000000000000000000000000000000000;;			f.queue = append(f.queue, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(f.queue) > 0 {
0000000000000000000000000000000000000000;;			f.cond.Broadcast()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resync will touch all objects to put them into the processing queue
0000000000000000000000000000000000000000;;	func (f *FIFO) Resync() error {
0000000000000000000000000000000000000000;;		f.lock.Lock()
0000000000000000000000000000000000000000;;		defer f.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inQueue := sets.NewString()
0000000000000000000000000000000000000000;;		for _, id := range f.queue {
0000000000000000000000000000000000000000;;			inQueue.Insert(id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for id := range f.items {
0000000000000000000000000000000000000000;;			if !inQueue.Has(id) {
0000000000000000000000000000000000000000;;				f.queue = append(f.queue, id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(f.queue) > 0 {
0000000000000000000000000000000000000000;;			f.cond.Broadcast()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFIFO returns a Store which can be used to queue up items to
0000000000000000000000000000000000000000;;	// process.
0000000000000000000000000000000000000000;;	func NewFIFO(keyFunc KeyFunc) *FIFO {
0000000000000000000000000000000000000000;;		f := &FIFO{
0000000000000000000000000000000000000000;;			items:   map[string]interface{}{},
0000000000000000000000000000000000000000;;			queue:   []string{},
0000000000000000000000000000000000000000;;			keyFunc: keyFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.cond.L = &f.lock
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
