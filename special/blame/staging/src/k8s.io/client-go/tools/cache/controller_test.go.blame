0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
56aa78cadcbf7dfd7120e260481bc357739a5448;staging/src/k8s.io/client-go/1.5/tools/cache/controller_test.go[staging/src/k8s.io/client-go/1.5/tools/cache/controller_test.go][staging/src/k8s.io/client-go/tools/cache/controller_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/sets"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		fcache "k8s.io/client-go/tools/cache/testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/gofuzz"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Example() {
0000000000000000000000000000000000000000;;		// source simulates an apiserver object endpoint.
0000000000000000000000000000000000000000;;		source := fcache.NewFakeControllerSource()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This will hold the downstream state, as we know it.
0000000000000000000000000000000000000000;;		downstream := NewStore(DeletionHandlingMetaNamespaceKeyFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This will hold incoming changes. Note how we pass downstream in as a
0000000000000000000000000000000000000000;;		// KeyLister, that way resync operations will result in the correct set
0000000000000000000000000000000000000000;;		// of update/delete deltas.
0000000000000000000000000000000000000000;;		fifo := NewDeltaFIFO(MetaNamespaceKeyFunc, nil, downstream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let's do threadsafe output to get predictable test results.
0000000000000000000000000000000000000000;;		deletionCounter := make(chan string, 1000)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := &Config{
0000000000000000000000000000000000000000;;			Queue:            fifo,
0000000000000000000000000000000000000000;;			ListerWatcher:    source,
0000000000000000000000000000000000000000;;			ObjectType:       &v1.Pod{},
0000000000000000000000000000000000000000;;			FullResyncPeriod: time.Millisecond * 100,
0000000000000000000000000000000000000000;;			RetryOnError:     false,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Let's implement a simple controller that just deletes
0000000000000000000000000000000000000000;;			// everything that comes in.
0000000000000000000000000000000000000000;;			Process: func(obj interface{}) error {
0000000000000000000000000000000000000000;;				// Obj is from the Pop method of the Queue we make above.
0000000000000000000000000000000000000000;;				newest := obj.(Deltas).Newest()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if newest.Type != Deleted {
0000000000000000000000000000000000000000;;					// Update our downstream store.
0000000000000000000000000000000000000000;;					err := downstream.Add(newest.Object)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Delete this object.
0000000000000000000000000000000000000000;;					source.Delete(newest.Object.(runtime.Object))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// Update our downstream store.
0000000000000000000000000000000000000000;;					err := downstream.Delete(newest.Object)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// fifo's KeyOf is easiest, because it handles
0000000000000000000000000000000000000000;;					// DeletedFinalStateUnknown markers.
0000000000000000000000000000000000000000;;					key, err := fifo.KeyOf(newest.Object)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Report this deletion.
0000000000000000000000000000000000000000;;					deletionCounter <- key
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the controller and run it until we close stop.
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;		go New(cfg).Run(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let's add a few objects to the source.
0000000000000000000000000000000000000000;;		testIDs := []string{"a-hello", "b-controller", "c-framework"}
0000000000000000000000000000000000000000;;		for _, name := range testIDs {
0000000000000000000000000000000000000000;;			// Note that these pods are not valid-- the fake source doesn't
0000000000000000000000000000000000000000;;			// call validation or anything.
0000000000000000000000000000000000000000;;			source.Add(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: name}})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let's wait for the controller to process the things we just added.
0000000000000000000000000000000000000000;;		outputSet := sets.String{}
0000000000000000000000000000000000000000;;		for i := 0; i < len(testIDs); i++ {
0000000000000000000000000000000000000000;;			outputSet.Insert(<-deletionCounter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, key := range outputSet.List() {
0000000000000000000000000000000000000000;;			fmt.Println(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Output:
0000000000000000000000000000000000000000;;		// a-hello
0000000000000000000000000000000000000000;;		// b-controller
0000000000000000000000000000000000000000;;		// c-framework
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ExampleNewInformer() {
0000000000000000000000000000000000000000;;		// source simulates an apiserver object endpoint.
0000000000000000000000000000000000000000;;		source := fcache.NewFakeControllerSource()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let's do threadsafe output to get predictable test results.
0000000000000000000000000000000000000000;;		deletionCounter := make(chan string, 1000)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a controller that immediately deletes anything added to it, and
0000000000000000000000000000000000000000;;		// logs anything deleted.
0000000000000000000000000000000000000000;;		_, controller := NewInformer(
0000000000000000000000000000000000000000;;			source,
0000000000000000000000000000000000000000;;			&v1.Pod{},
0000000000000000000000000000000000000000;;			time.Millisecond*100,
0000000000000000000000000000000000000000;;			ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;					source.Delete(obj.(runtime.Object))
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				DeleteFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;					key, err := DeletionHandlingMetaNamespaceKeyFunc(obj)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						key = "oops something went wrong with the key"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Report this deletion.
0000000000000000000000000000000000000000;;					deletionCounter <- key
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run the controller and run it until we close stop.
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		defer close(stop)
0000000000000000000000000000000000000000;;		go controller.Run(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let's add a few objects to the source.
0000000000000000000000000000000000000000;;		testIDs := []string{"a-hello", "b-controller", "c-framework"}
0000000000000000000000000000000000000000;;		for _, name := range testIDs {
0000000000000000000000000000000000000000;;			// Note that these pods are not valid-- the fake source doesn't
0000000000000000000000000000000000000000;;			// call validation or anything.
0000000000000000000000000000000000000000;;			source.Add(&v1.Pod{ObjectMeta: metav1.ObjectMeta{Name: name}})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let's wait for the controller to process the things we just added.
0000000000000000000000000000000000000000;;		outputSet := sets.String{}
0000000000000000000000000000000000000000;;		for i := 0; i < len(testIDs); i++ {
0000000000000000000000000000000000000000;;			outputSet.Insert(<-deletionCounter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, key := range outputSet.List() {
0000000000000000000000000000000000000000;;			fmt.Println(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Output:
0000000000000000000000000000000000000000;;		// a-hello
0000000000000000000000000000000000000000;;		// b-controller
0000000000000000000000000000000000000000;;		// c-framework
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHammerController(t *testing.T) {
0000000000000000000000000000000000000000;;		// This test executes a bunch of requests through the fake source and
0000000000000000000000000000000000000000;;		// controller framework to make sure there's no locking/threading
0000000000000000000000000000000000000000;;		// errors. If an error happens, it should hang forever or trigger the
0000000000000000000000000000000000000000;;		// race detector.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// source simulates an apiserver object endpoint.
0000000000000000000000000000000000000000;;		source := fcache.NewFakeControllerSource()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let's do threadsafe output to get predictable test results.
0000000000000000000000000000000000000000;;		outputSetLock := sync.Mutex{}
0000000000000000000000000000000000000000;;		// map of key to operations done on the key
0000000000000000000000000000000000000000;;		outputSet := map[string][]string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		recordFunc := func(eventType string, obj interface{}) {
0000000000000000000000000000000000000000;;			key, err := DeletionHandlingMetaNamespaceKeyFunc(obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Errorf("something wrong with key: %v", err)
0000000000000000000000000000000000000000;;				key = "oops something went wrong with the key"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Record some output when items are deleted.
0000000000000000000000000000000000000000;;			outputSetLock.Lock()
0000000000000000000000000000000000000000;;			defer outputSetLock.Unlock()
0000000000000000000000000000000000000000;;			outputSet[key] = append(outputSet[key], eventType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a controller which just logs all the changes it gets.
0000000000000000000000000000000000000000;;		_, controller := NewInformer(
0000000000000000000000000000000000000000;;			source,
0000000000000000000000000000000000000000;;			&v1.Pod{},
0000000000000000000000000000000000000000;;			time.Millisecond*100,
0000000000000000000000000000000000000000;;			ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				AddFunc:    func(obj interface{}) { recordFunc("add", obj) },
0000000000000000000000000000000000000000;;				UpdateFunc: func(oldObj, newObj interface{}) { recordFunc("update", newObj) },
0000000000000000000000000000000000000000;;				DeleteFunc: func(obj interface{}) { recordFunc("delete", obj) },
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if controller.HasSynced() {
0000000000000000000000000000000000000000;;			t.Errorf("Expected HasSynced() to return false before we started the controller")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run the controller and run it until we close stop.
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		go controller.Run(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let's wait for the controller to do its initial sync
0000000000000000000000000000000000000000;;		wait.Poll(100*time.Millisecond, wait.ForeverTestTimeout, func() (bool, error) {
0000000000000000000000000000000000000000;;			return controller.HasSynced(), nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if !controller.HasSynced() {
0000000000000000000000000000000000000000;;			t.Errorf("Expected HasSynced() to return true after the initial sync")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wg := sync.WaitGroup{}
0000000000000000000000000000000000000000;;		const threads = 3
0000000000000000000000000000000000000000;;		wg.Add(threads)
0000000000000000000000000000000000000000;;		for i := 0; i < threads; i++ {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				// Let's add a few objects to the source.
0000000000000000000000000000000000000000;;				currentNames := sets.String{}
0000000000000000000000000000000000000000;;				rs := rand.NewSource(rand.Int63())
0000000000000000000000000000000000000000;;				f := fuzz.New().NilChance(.5).NumElements(0, 2).RandSource(rs)
0000000000000000000000000000000000000000;;				r := rand.New(rs) // Mustn't use r and f concurrently!
0000000000000000000000000000000000000000;;				for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;					var name string
0000000000000000000000000000000000000000;;					var isNew bool
0000000000000000000000000000000000000000;;					if currentNames.Len() == 0 || r.Intn(3) == 1 {
0000000000000000000000000000000000000000;;						f.Fuzz(&name)
0000000000000000000000000000000000000000;;						isNew = true
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						l := currentNames.List()
0000000000000000000000000000000000000000;;						name = l[r.Intn(len(l))]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					pod := &v1.Pod{}
0000000000000000000000000000000000000000;;					f.Fuzz(pod)
0000000000000000000000000000000000000000;;					pod.ObjectMeta.Name = name
0000000000000000000000000000000000000000;;					pod.ObjectMeta.Namespace = "default"
0000000000000000000000000000000000000000;;					// Add, update, or delete randomly.
0000000000000000000000000000000000000000;;					// Note that these pods are not valid-- the fake source doesn't
0000000000000000000000000000000000000000;;					// call validation or perform any other checking.
0000000000000000000000000000000000000000;;					if isNew {
0000000000000000000000000000000000000000;;						currentNames.Insert(name)
0000000000000000000000000000000000000000;;						source.Add(pod)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					switch r.Intn(2) {
0000000000000000000000000000000000000000;;					case 0:
0000000000000000000000000000000000000000;;						currentNames.Insert(name)
0000000000000000000000000000000000000000;;						source.Modify(pod)
0000000000000000000000000000000000000000;;					case 1:
0000000000000000000000000000000000000000;;						currentNames.Delete(name)
0000000000000000000000000000000000000000;;						source.Delete(pod)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let's wait for the controller to finish processing the things we just added.
0000000000000000000000000000000000000000;;		// TODO: look in the queue to see how many items need to be processed.
0000000000000000000000000000000000000000;;		time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;		close(stop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: Verify that no goroutines were leaked here and that everything shut
0000000000000000000000000000000000000000;;		// down cleanly.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outputSetLock.Lock()
0000000000000000000000000000000000000000;;		t.Logf("got: %#v", outputSet)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUpdate(t *testing.T) {
0000000000000000000000000000000000000000;;		// This test is going to exercise the various paths that result in a
0000000000000000000000000000000000000000;;		// call to update.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// source simulates an apiserver object endpoint.
0000000000000000000000000000000000000000;;		source := fcache.NewFakeControllerSource()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			FROM = "from"
0000000000000000000000000000000000000000;;			TO   = "to"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// These are the transitions we expect to see; because this is
0000000000000000000000000000000000000000;;		// asynchronous, there are a lot of valid possibilities.
0000000000000000000000000000000000000000;;		type pair struct{ from, to string }
0000000000000000000000000000000000000000;;		allowedTransitions := map[pair]bool{
0000000000000000000000000000000000000000;;			{FROM, TO}: true,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Because a resync can happen when we've already observed one
0000000000000000000000000000000000000000;;			// of the above but before the item is deleted.
0000000000000000000000000000000000000000;;			{TO, TO}: true,
0000000000000000000000000000000000000000;;			// Because a resync could happen before we observe an update.
0000000000000000000000000000000000000000;;			{FROM, FROM}: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pod := func(name, check string, final bool) *v1.Pod {
0000000000000000000000000000000000000000;;			p := &v1.Pod{
0000000000000000000000000000000000000000;;				ObjectMeta: metav1.ObjectMeta{
0000000000000000000000000000000000000000;;					Name:   name,
0000000000000000000000000000000000000000;;					Labels: map[string]string{"check": check},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if final {
0000000000000000000000000000000000000000;;				p.Labels["final"] = "true"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deletePod := func(p *v1.Pod) bool {
0000000000000000000000000000000000000000;;			return p.Labels["final"] == "true"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []func(string){
0000000000000000000000000000000000000000;;			func(name string) {
0000000000000000000000000000000000000000;;				name = "a-" + name
0000000000000000000000000000000000000000;;				source.Add(pod(name, FROM, false))
0000000000000000000000000000000000000000;;				source.Modify(pod(name, TO, true))
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const threads = 3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var testDoneWG sync.WaitGroup
0000000000000000000000000000000000000000;;		testDoneWG.Add(threads * len(tests))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a controller that deletes things once it observes an update.
0000000000000000000000000000000000000000;;		// It calls Done() on the wait group on deletions so we can tell when
0000000000000000000000000000000000000000;;		// everything we've added has been deleted.
0000000000000000000000000000000000000000;;		watchCh := make(chan struct{})
0000000000000000000000000000000000000000;;		_, controller := NewInformer(
0000000000000000000000000000000000000000;;			&testLW{
0000000000000000000000000000000000000000;;				WatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;					watch, err := source.Watch(options)
0000000000000000000000000000000000000000;;					close(watchCh)
0000000000000000000000000000000000000000;;					return watch, err
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				ListFunc: func(options metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;					return source.List(options)
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			&v1.Pod{},
0000000000000000000000000000000000000000;;			0,
0000000000000000000000000000000000000000;;			ResourceEventHandlerFuncs{
0000000000000000000000000000000000000000;;				UpdateFunc: func(oldObj, newObj interface{}) {
0000000000000000000000000000000000000000;;					o, n := oldObj.(*v1.Pod), newObj.(*v1.Pod)
0000000000000000000000000000000000000000;;					from, to := o.Labels["check"], n.Labels["check"]
0000000000000000000000000000000000000000;;					if !allowedTransitions[pair{from, to}] {
0000000000000000000000000000000000000000;;						t.Errorf("observed transition %q -> %q for %v", from, to, n.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if deletePod(n) {
0000000000000000000000000000000000000000;;						source.Delete(n)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				DeleteFunc: func(obj interface{}) {
0000000000000000000000000000000000000000;;					testDoneWG.Done()
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run the controller and run it until we close stop.
0000000000000000000000000000000000000000;;		// Once Run() is called, calls to testDoneWG.Done() might start, so
0000000000000000000000000000000000000000;;		// all testDoneWG.Add() calls must happen before this point
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		go controller.Run(stop)
0000000000000000000000000000000000000000;;		<-watchCh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// run every test a few times, in parallel
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(threads * len(tests))
0000000000000000000000000000000000000000;;		for i := 0; i < threads; i++ {
0000000000000000000000000000000000000000;;			for j, f := range tests {
0000000000000000000000000000000000000000;;				go func(name string, f func(string)) {
0000000000000000000000000000000000000000;;					defer wg.Done()
0000000000000000000000000000000000000000;;					f(name)
0000000000000000000000000000000000000000;;				}(fmt.Sprintf("%v-%v", i, j), f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Let's wait for the controller to process the things we just added.
0000000000000000000000000000000000000000;;		testDoneWG.Wait()
0000000000000000000000000000000000000000;;		close(stop)
0000000000000000000000000000000000000000;;	}
