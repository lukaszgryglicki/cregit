0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/cache/store.go[staging/src/k8s.io/client-go/1.4/tools/cache/store.go][staging/src/k8s.io/client-go/tools/cache/store.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Store is a generic object storage interface. Reflector knows how to watch a server
0000000000000000000000000000000000000000;;	// and update a store. A generic store is provided, which allows Reflector to be used
0000000000000000000000000000000000000000;;	// as a local caching system, and an LRU store, which allows Reflector to work like a
0000000000000000000000000000000000000000;;	// queue of items yet to be processed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Store makes no assumptions about stored object identity; it is the responsibility
0000000000000000000000000000000000000000;;	// of a Store implementation to provide a mechanism to correctly key objects and to
0000000000000000000000000000000000000000;;	// define the contract for obtaining objects by some arbitrary key type.
0000000000000000000000000000000000000000;;	type Store interface {
0000000000000000000000000000000000000000;;		Add(obj interface{}) error
0000000000000000000000000000000000000000;;		Update(obj interface{}) error
0000000000000000000000000000000000000000;;		Delete(obj interface{}) error
0000000000000000000000000000000000000000;;		List() []interface{}
0000000000000000000000000000000000000000;;		ListKeys() []string
0000000000000000000000000000000000000000;;		Get(obj interface{}) (item interface{}, exists bool, err error)
0000000000000000000000000000000000000000;;		GetByKey(key string) (item interface{}, exists bool, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Replace will delete the contents of the store, using instead the
0000000000000000000000000000000000000000;;		// given list. Store takes ownership of the list, you should not reference
0000000000000000000000000000000000000000;;		// it after calling this function.
0000000000000000000000000000000000000000;;		Replace([]interface{}, string) error
0000000000000000000000000000000000000000;;		Resync() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyFunc knows how to make a key from an object. Implementations should be deterministic.
0000000000000000000000000000000000000000;;	type KeyFunc func(obj interface{}) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyError will be returned any time a KeyFunc gives an error; it includes the object
0000000000000000000000000000000000000000;;	// at fault.
0000000000000000000000000000000000000000;;	type KeyError struct {
0000000000000000000000000000000000000000;;		Obj interface{}
0000000000000000000000000000000000000000;;		Err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error gives a human-readable description of the error.
0000000000000000000000000000000000000000;;	func (k KeyError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("couldn't create key for object %+v: %v", k.Obj, k.Err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExplicitKey can be passed to MetaNamespaceKeyFunc if you have the key for
0000000000000000000000000000000000000000;;	// the object but not the object itself.
0000000000000000000000000000000000000000;;	type ExplicitKey string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetaNamespaceKeyFunc is a convenient default KeyFunc which knows how to make
0000000000000000000000000000000000000000;;	// keys for API objects which implement meta.Interface.
0000000000000000000000000000000000000000;;	// The key uses the format <namespace>/<name> unless <namespace> is empty, then
0000000000000000000000000000000000000000;;	// it's just <name>.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: replace key-as-string with a key-as-struct so that this
0000000000000000000000000000000000000000;;	// packing/unpacking won't be necessary.
0000000000000000000000000000000000000000;;	func MetaNamespaceKeyFunc(obj interface{}) (string, error) {
0000000000000000000000000000000000000000;;		if key, ok := obj.(ExplicitKey); ok {
0000000000000000000000000000000000000000;;			return string(key), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		meta, err := meta.Accessor(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("object has no meta: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(meta.GetNamespace()) > 0 {
0000000000000000000000000000000000000000;;			return meta.GetNamespace() + "/" + meta.GetName(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return meta.GetName(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SplitMetaNamespaceKey returns the namespace and name that
0000000000000000000000000000000000000000;;	// MetaNamespaceKeyFunc encoded into key.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: replace key-as-string with a key-as-struct so that this
0000000000000000000000000000000000000000;;	// packing/unpacking won't be necessary.
0000000000000000000000000000000000000000;;	func SplitMetaNamespaceKey(key string) (namespace, name string, err error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(key, "/")
0000000000000000000000000000000000000000;;		switch len(parts) {
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			// name only, no namespace
0000000000000000000000000000000000000000;;			return "", parts[0], nil
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			// namespace and name
0000000000000000000000000000000000000000;;			return parts[0], parts[1], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", "", fmt.Errorf("unexpected key format: %q", key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cache responsibilities are limited to:
0000000000000000000000000000000000000000;;	//	1. Computing keys for objects via keyFunc
0000000000000000000000000000000000000000;;	//  2. Invoking methods of a ThreadSafeStorage interface
0000000000000000000000000000000000000000;;	type cache struct {
0000000000000000000000000000000000000000;;		// cacheStorage bears the burden of thread safety for the cache
0000000000000000000000000000000000000000;;		cacheStorage ThreadSafeStore
0000000000000000000000000000000000000000;;		// keyFunc is used to make the key for objects stored in and retrieved from items, and
0000000000000000000000000000000000000000;;		// should be deterministic.
0000000000000000000000000000000000000000;;		keyFunc KeyFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Store = &cache{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add inserts an item into the cache.
0000000000000000000000000000000000000000;;	func (c *cache) Add(obj interface{}) error {
0000000000000000000000000000000000000000;;		key, err := c.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.cacheStorage.Add(key, obj)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update sets an item in the cache to its updated state.
0000000000000000000000000000000000000000;;	func (c *cache) Update(obj interface{}) error {
0000000000000000000000000000000000000000;;		key, err := c.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.cacheStorage.Update(key, obj)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes an item from the cache.
0000000000000000000000000000000000000000;;	func (c *cache) Delete(obj interface{}) error {
0000000000000000000000000000000000000000;;		key, err := c.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.cacheStorage.Delete(key)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list of all the items.
0000000000000000000000000000000000000000;;	// List is completely threadsafe as long as you treat all items as immutable.
0000000000000000000000000000000000000000;;	func (c *cache) List() []interface{} {
0000000000000000000000000000000000000000;;		return c.cacheStorage.List()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListKeys returns a list of all the keys of the objects currently
0000000000000000000000000000000000000000;;	// in the cache.
0000000000000000000000000000000000000000;;	func (c *cache) ListKeys() []string {
0000000000000000000000000000000000000000;;		return c.cacheStorage.ListKeys()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetIndexers returns the indexers of cache
0000000000000000000000000000000000000000;;	func (c *cache) GetIndexers() Indexers {
0000000000000000000000000000000000000000;;		return c.cacheStorage.GetIndexers()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Index returns a list of items that match on the index function
0000000000000000000000000000000000000000;;	// Index is thread-safe so long as you treat all items as immutable
0000000000000000000000000000000000000000;;	func (c *cache) Index(indexName string, obj interface{}) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		return c.cacheStorage.Index(indexName, obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cache) IndexKeys(indexName, indexKey string) ([]string, error) {
0000000000000000000000000000000000000000;;		return c.cacheStorage.IndexKeys(indexName, indexKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListIndexFuncValues returns the list of generated values of an Index func
0000000000000000000000000000000000000000;;	func (c *cache) ListIndexFuncValues(indexName string) []string {
0000000000000000000000000000000000000000;;		return c.cacheStorage.ListIndexFuncValues(indexName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cache) ByIndex(indexName, indexKey string) ([]interface{}, error) {
0000000000000000000000000000000000000000;;		return c.cacheStorage.ByIndex(indexName, indexKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *cache) AddIndexers(newIndexers Indexers) error {
0000000000000000000000000000000000000000;;		return c.cacheStorage.AddIndexers(newIndexers)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the requested item, or sets exists=false.
0000000000000000000000000000000000000000;;	// Get is completely threadsafe as long as you treat all items as immutable.
0000000000000000000000000000000000000000;;	func (c *cache) Get(obj interface{}) (item interface{}, exists bool, err error) {
0000000000000000000000000000000000000000;;		key, err := c.keyFunc(obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, false, KeyError{obj, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.GetByKey(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetByKey returns the request item, or exists=false.
0000000000000000000000000000000000000000;;	// GetByKey is completely threadsafe as long as you treat all items as immutable.
0000000000000000000000000000000000000000;;	func (c *cache) GetByKey(key string) (item interface{}, exists bool, err error) {
0000000000000000000000000000000000000000;;		item, exists = c.cacheStorage.Get(key)
0000000000000000000000000000000000000000;;		return item, exists, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replace will delete the contents of 'c', using instead the given list.
0000000000000000000000000000000000000000;;	// 'c' takes ownership of the list, you should not reference the list again
0000000000000000000000000000000000000000;;	// after calling this function.
0000000000000000000000000000000000000000;;	func (c *cache) Replace(list []interface{}, resourceVersion string) error {
0000000000000000000000000000000000000000;;		items := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for _, item := range list {
0000000000000000000000000000000000000000;;			key, err := c.keyFunc(item)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return KeyError{item, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			items[key] = item
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.cacheStorage.Replace(items, resourceVersion)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resync touches all items in the store to force processing
0000000000000000000000000000000000000000;;	func (c *cache) Resync() error {
0000000000000000000000000000000000000000;;		return c.cacheStorage.Resync()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStore returns a Store implemented simply with a map and a lock.
0000000000000000000000000000000000000000;;	func NewStore(keyFunc KeyFunc) Store {
0000000000000000000000000000000000000000;;		return &cache{
0000000000000000000000000000000000000000;;			cacheStorage: NewThreadSafeStore(Indexers{}, Indices{}),
0000000000000000000000000000000000000000;;			keyFunc:      keyFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewIndexer returns an Indexer implemented simply with a map and a lock.
0000000000000000000000000000000000000000;;	func NewIndexer(keyFunc KeyFunc, indexers Indexers) Indexer {
0000000000000000000000000000000000000000;;		return &cache{
0000000000000000000000000000000000000000;;			cacheStorage: NewThreadSafeStore(indexers, Indices{}),
0000000000000000000000000000000000000000;;			keyFunc:      keyFunc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
