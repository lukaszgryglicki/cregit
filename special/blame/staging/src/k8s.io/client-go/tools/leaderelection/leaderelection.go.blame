0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
ed2078732cc7b6f4a74587cc53017fa4819ac966;pkg/client/leaderelection/leaderelection.go[pkg/client/leaderelection/leaderelection.go][staging/src/k8s.io/client-go/tools/leaderelection/leaderelection.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package leaderelection implements leader election of a set of endpoints.
0000000000000000000000000000000000000000;;	// It uses an annotation in the endpoints object to store the record of the
0000000000000000000000000000000000000000;;	// election state.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This implementation does not guarantee that only one client is acting as a
0000000000000000000000000000000000000000;;	// leader (a.k.a. fencing). A client observes timestamps captured locally to
0000000000000000000000000000000000000000;;	// infer the state of the leader election. Thus the implementation is tolerant
0000000000000000000000000000000000000000;;	// to arbitrary clock skew, but is not tolerant to arbitrary clock skew rate.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// However the level of tolerance to skew rate can be configured by setting
0000000000000000000000000000000000000000;;	// RenewDeadline and LeaseDuration appropriately. The tolerance expressed as a
0000000000000000000000000000000000000000;;	// maximum tolerated ratio of time passed on the fastest node to time passed on
0000000000000000000000000000000000000000;;	// the slowest node can be approximately achieved with a configuration that sets
0000000000000000000000000000000000000000;;	// the same ratio of LeaseDuration to RenewDeadline. For example if a user wanted
0000000000000000000000000000000000000000;;	// to tolerate some nodes progressing forward in time twice as fast as other nodes,
0000000000000000000000000000000000000000;;	// the user could set LeaseDuration to 60 seconds and RenewDeadline to 30 seconds.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// While not required, some method of clock synchronization between nodes in the
0000000000000000000000000000000000000000;;	// cluster is highly recommended. It's important to keep in mind when configuring
0000000000000000000000000000000000000000;;	// this client that the tolerance to skew rate varies inversely to master
0000000000000000000000000000000000000000;;	// availability.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Larger clusters often have a more lenient SLA for API latency. This should be
0000000000000000000000000000000000000000;;	// taken into account when configuring the client. The rate of leader transitions
0000000000000000000000000000000000000000;;	// should be monitored and RetryPeriod and LeaseDuration should be increased
0000000000000000000000000000000000000000;;	// until the rate is stable and acceptably low. It's important to keep in mind
0000000000000000000000000000000000000000;;	// when configuring this client that the tolerance to API latency varies inversely
0000000000000000000000000000000000000000;;	// to master availability.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// DISCLAIMER: this is an alpha API. This library will likely change significantly
0000000000000000000000000000000000000000;;	// or even be removed entirely in subsequent releases. Depend on this API at
0000000000000000000000000000000000000000;;	// your own risk.
0000000000000000000000000000000000000000;;	package leaderelection
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/wait"
0000000000000000000000000000000000000000;;		rl "k8s.io/client-go/tools/leaderelection/resourcelock"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		JitterFactor = 1.2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLeaderElector creates a LeaderElector from a LeaderElectionConfig
0000000000000000000000000000000000000000;;	func NewLeaderElector(lec LeaderElectionConfig) (*LeaderElector, error) {
0000000000000000000000000000000000000000;;		if lec.LeaseDuration <= lec.RenewDeadline {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("leaseDuration must be greater than renewDeadline")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lec.RenewDeadline <= time.Duration(JitterFactor*float64(lec.RetryPeriod)) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("renewDeadline must be greater than retryPeriod*JitterFactor")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lec.Lock == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Lock must not be nil.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &LeaderElector{
0000000000000000000000000000000000000000;;			config: lec,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LeaderElectionConfig struct {
0000000000000000000000000000000000000000;;		// Lock is the resource that will be used for locking
0000000000000000000000000000000000000000;;		Lock rl.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LeaseDuration is the duration that non-leader candidates will
0000000000000000000000000000000000000000;;		// wait to force acquire leadership. This is measured against time of
0000000000000000000000000000000000000000;;		// last observed ack.
0000000000000000000000000000000000000000;;		LeaseDuration time.Duration
0000000000000000000000000000000000000000;;		// RenewDeadline is the duration that the acting master will retry
0000000000000000000000000000000000000000;;		// refreshing leadership before giving up.
0000000000000000000000000000000000000000;;		RenewDeadline time.Duration
0000000000000000000000000000000000000000;;		// RetryPeriod is the duration the LeaderElector clients should wait
0000000000000000000000000000000000000000;;		// between tries of actions.
0000000000000000000000000000000000000000;;		RetryPeriod time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Callbacks are callbacks that are triggered during certain lifecycle
0000000000000000000000000000000000000000;;		// events of the LeaderElector
0000000000000000000000000000000000000000;;		Callbacks LeaderCallbacks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LeaderCallbacks are callbacks that are triggered during certain
0000000000000000000000000000000000000000;;	// lifecycle events of the LeaderElector. These are invoked asynchronously.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// possible future callbacks:
0000000000000000000000000000000000000000;;	//  * OnChallenge()
0000000000000000000000000000000000000000;;	type LeaderCallbacks struct {
0000000000000000000000000000000000000000;;		// OnStartedLeading is called when a LeaderElector client starts leading
0000000000000000000000000000000000000000;;		OnStartedLeading func(stop <-chan struct{})
0000000000000000000000000000000000000000;;		// OnStoppedLeading is called when a LeaderElector client stops leading
0000000000000000000000000000000000000000;;		OnStoppedLeading func()
0000000000000000000000000000000000000000;;		// OnNewLeader is called when the client observes a leader that is
0000000000000000000000000000000000000000;;		// not the previously observed leader. This includes the first observed
0000000000000000000000000000000000000000;;		// leader when the client starts.
0000000000000000000000000000000000000000;;		OnNewLeader func(identity string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LeaderElector is a leader election client.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// possible future methods:
0000000000000000000000000000000000000000;;	//  * (le *LeaderElector) IsLeader()
0000000000000000000000000000000000000000;;	//  * (le *LeaderElector) GetLeader()
0000000000000000000000000000000000000000;;	type LeaderElector struct {
0000000000000000000000000000000000000000;;		config LeaderElectionConfig
0000000000000000000000000000000000000000;;		// internal bookkeeping
0000000000000000000000000000000000000000;;		observedRecord rl.LeaderElectionRecord
0000000000000000000000000000000000000000;;		observedTime   time.Time
0000000000000000000000000000000000000000;;		// used to implement OnNewLeader(), may lag slightly from the
0000000000000000000000000000000000000000;;		// value observedRecord.HolderIdentity if the transition has
0000000000000000000000000000000000000000;;		// not yet been reported.
0000000000000000000000000000000000000000;;		reportedLeader string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run starts the leader election loop
0000000000000000000000000000000000000000;;	func (le *LeaderElector) Run() {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			runtime.HandleCrash()
0000000000000000000000000000000000000000;;			le.config.Callbacks.OnStoppedLeading()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		le.acquire()
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		go le.config.Callbacks.OnStartedLeading(stop)
0000000000000000000000000000000000000000;;		le.renew()
0000000000000000000000000000000000000000;;		close(stop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RunOrDie starts a client with the provided config or panics if the config
0000000000000000000000000000000000000000;;	// fails to validate.
0000000000000000000000000000000000000000;;	func RunOrDie(lec LeaderElectionConfig) {
0000000000000000000000000000000000000000;;		le, err := NewLeaderElector(lec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		le.Run()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLeader returns the identity of the last observed leader or returns the empty string if
0000000000000000000000000000000000000000;;	// no leader has yet been observed.
0000000000000000000000000000000000000000;;	func (le *LeaderElector) GetLeader() string {
0000000000000000000000000000000000000000;;		return le.observedRecord.HolderIdentity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsLeader returns true if the last observed leader was this client else returns false.
0000000000000000000000000000000000000000;;	func (le *LeaderElector) IsLeader() bool {
0000000000000000000000000000000000000000;;		return le.observedRecord.HolderIdentity == le.config.Lock.Identity()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// acquire loops calling tryAcquireOrRenew and returns immediately when tryAcquireOrRenew succeeds.
0000000000000000000000000000000000000000;;	func (le *LeaderElector) acquire() {
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		glog.Infof("attempting to acquire leader lease...")
0000000000000000000000000000000000000000;;		wait.JitterUntil(func() {
0000000000000000000000000000000000000000;;			succeeded := le.tryAcquireOrRenew()
0000000000000000000000000000000000000000;;			le.maybeReportTransition()
0000000000000000000000000000000000000000;;			desc := le.config.Lock.Describe()
0000000000000000000000000000000000000000;;			if !succeeded {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("failed to acquire lease %v", desc)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			le.config.Lock.RecordEvent("became leader")
0000000000000000000000000000000000000000;;			glog.Infof("successfully acquired lease %v", desc)
0000000000000000000000000000000000000000;;			close(stop)
0000000000000000000000000000000000000000;;		}, le.config.RetryPeriod, JitterFactor, true, stop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// renew loops calling tryAcquireOrRenew and returns immediately when tryAcquireOrRenew fails.
0000000000000000000000000000000000000000;;	func (le *LeaderElector) renew() {
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		wait.Until(func() {
0000000000000000000000000000000000000000;;			err := wait.Poll(le.config.RetryPeriod, le.config.RenewDeadline, func() (bool, error) {
0000000000000000000000000000000000000000;;				return le.tryAcquireOrRenew(), nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			le.maybeReportTransition()
0000000000000000000000000000000000000000;;			desc := le.config.Lock.Describe()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("successfully renewed lease %v", desc)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			le.config.Lock.RecordEvent("stopped leading")
0000000000000000000000000000000000000000;;			glog.Infof("failed to renew lease %v", desc)
0000000000000000000000000000000000000000;;			close(stop)
0000000000000000000000000000000000000000;;		}, 0, stop)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tryAcquireOrRenew tries to acquire a leader lease if it is not already acquired,
0000000000000000000000000000000000000000;;	// else it tries to renew the lease if it has already been acquired. Returns true
0000000000000000000000000000000000000000;;	// on success else returns false.
0000000000000000000000000000000000000000;;	func (le *LeaderElector) tryAcquireOrRenew() bool {
0000000000000000000000000000000000000000;;		now := metav1.Now()
0000000000000000000000000000000000000000;;		leaderElectionRecord := rl.LeaderElectionRecord{
0000000000000000000000000000000000000000;;			HolderIdentity:       le.config.Lock.Identity(),
0000000000000000000000000000000000000000;;			LeaseDurationSeconds: int(le.config.LeaseDuration / time.Second),
0000000000000000000000000000000000000000;;			RenewTime:            now,
0000000000000000000000000000000000000000;;			AcquireTime:          now,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. obtain or create the ElectionRecord
0000000000000000000000000000000000000000;;		oldLeaderElectionRecord, err := le.config.Lock.Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !errors.IsNotFound(err) {
0000000000000000000000000000000000000000;;				glog.Errorf("error retrieving resource lock %v: %v", le.config.Lock.Describe(), err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = le.config.Lock.Create(leaderElectionRecord); err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("error initially creating leader election record: %v", err)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			le.observedRecord = leaderElectionRecord
0000000000000000000000000000000000000000;;			le.observedTime = time.Now()
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2. Record obtained, check the Identity & Time
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(le.observedRecord, *oldLeaderElectionRecord) {
0000000000000000000000000000000000000000;;			le.observedRecord = *oldLeaderElectionRecord
0000000000000000000000000000000000000000;;			le.observedTime = time.Now()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if le.observedTime.Add(le.config.LeaseDuration).After(now.Time) &&
0000000000000000000000000000000000000000;;			oldLeaderElectionRecord.HolderIdentity != le.config.Lock.Identity() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("lock is held by %v and has not yet expired", oldLeaderElectionRecord.HolderIdentity)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 3. We're going to try to update. The leaderElectionRecord is set to it's default
0000000000000000000000000000000000000000;;		// here. Let's correct it before updating.
0000000000000000000000000000000000000000;;		if oldLeaderElectionRecord.HolderIdentity == le.config.Lock.Identity() {
0000000000000000000000000000000000000000;;			leaderElectionRecord.AcquireTime = oldLeaderElectionRecord.AcquireTime
0000000000000000000000000000000000000000;;			leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update the lock itself
0000000000000000000000000000000000000000;;		if err = le.config.Lock.Update(leaderElectionRecord); err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to update lock: %v", err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		le.observedRecord = leaderElectionRecord
0000000000000000000000000000000000000000;;		le.observedTime = time.Now()
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *LeaderElector) maybeReportTransition() {
0000000000000000000000000000000000000000;;		if l.observedRecord.HolderIdentity == l.reportedLeader {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.reportedLeader = l.observedRecord.HolderIdentity
0000000000000000000000000000000000000000;;		if l.config.Callbacks.OnNewLeader != nil {
0000000000000000000000000000000000000000;;			go l.config.Callbacks.OnNewLeader(l.reportedLeader)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
