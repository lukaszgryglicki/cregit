0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
ed2078732cc7b6f4a74587cc53017fa4819ac966;pkg/client/leaderelection/leaderelection_test.go[pkg/client/leaderelection/leaderelection_test.go][staging/src/k8s.io/client-go/tools/leaderelection/leaderelection_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package leaderelection
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/errors"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		fakecorev1 "k8s.io/client-go/kubernetes/typed/core/v1/fake"
0000000000000000000000000000000000000000;;		core "k8s.io/client-go/testing"
0000000000000000000000000000000000000000;;		rl "k8s.io/client-go/tools/leaderelection/resourcelock"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/tools/record"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createLockObject(objectType string, objectMeta metav1.ObjectMeta) (obj runtime.Object) {
0000000000000000000000000000000000000000;;		switch objectType {
0000000000000000000000000000000000000000;;		case "endpoints":
0000000000000000000000000000000000000000;;			obj = &v1.Endpoints{ObjectMeta: objectMeta}
0000000000000000000000000000000000000000;;		case "configmaps":
0000000000000000000000000000000000000000;;			obj = &v1.ConfigMap{ObjectMeta: objectMeta}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("unexpected objType:" + objectType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Will test leader election using endpoints as the resource
0000000000000000000000000000000000000000;;	func TestTryAcquireOrRenewEndpoints(t *testing.T) {
0000000000000000000000000000000000000000;;		testTryAcquireOrRenew(t, "endpoints")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func testTryAcquireOrRenew(t *testing.T, objectType string) {
0000000000000000000000000000000000000000;;		future := time.Now().Add(1000 * time.Hour)
0000000000000000000000000000000000000000;;		past := time.Now().Add(-1000 * time.Hour)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			observedRecord rl.LeaderElectionRecord
0000000000000000000000000000000000000000;;			observedTime   time.Time
0000000000000000000000000000000000000000;;			reactors       []struct {
0000000000000000000000000000000000000000;;				verb     string
0000000000000000000000000000000000000000;;				reaction core.ReactionFunc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			expectSuccess    bool
0000000000000000000000000000000000000000;;			transitionLeader bool
0000000000000000000000000000000000000000;;			outHolder        string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			// acquire from no object
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				reactors: []struct {
0000000000000000000000000000000000000000;;					verb     string
0000000000000000000000000000000000000000;;					reaction core.ReactionFunc
0000000000000000000000000000000000000000;;				}{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						verb: "get",
0000000000000000000000000000000000000000;;						reaction: func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;							return true, nil, errors.NewNotFound(action.(core.GetAction).GetResource().GroupResource(), action.(core.GetAction).GetName())
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						verb: "create",
0000000000000000000000000000000000000000;;						reaction: func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;							return true, action.(core.CreateAction).GetObject(), nil
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expectSuccess: true,
0000000000000000000000000000000000000000;;				outHolder:     "baz",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// acquire from unled object
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				reactors: []struct {
0000000000000000000000000000000000000000;;					verb     string
0000000000000000000000000000000000000000;;					reaction core.ReactionFunc
0000000000000000000000000000000000000000;;				}{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						verb: "get",
0000000000000000000000000000000000000000;;						reaction: func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;							objectMeta := metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Namespace: action.GetNamespace(),
0000000000000000000000000000000000000000;;								Name:      action.(core.GetAction).GetName(),
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return true, createLockObject(objectType, objectMeta), nil
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						verb: "update",
0000000000000000000000000000000000000000;;						reaction: func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;							return true, action.(core.CreateAction).GetObject(), nil
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectSuccess:    true,
0000000000000000000000000000000000000000;;				transitionLeader: true,
0000000000000000000000000000000000000000;;				outHolder:        "baz",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// acquire from led, unacked object
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				reactors: []struct {
0000000000000000000000000000000000000000;;					verb     string
0000000000000000000000000000000000000000;;					reaction core.ReactionFunc
0000000000000000000000000000000000000000;;				}{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						verb: "get",
0000000000000000000000000000000000000000;;						reaction: func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;							objectMeta := metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Namespace: action.GetNamespace(),
0000000000000000000000000000000000000000;;								Name:      action.(core.GetAction).GetName(),
0000000000000000000000000000000000000000;;								Annotations: map[string]string{
0000000000000000000000000000000000000000;;									rl.LeaderElectionRecordAnnotationKey: `{"holderIdentity":"bing"}`,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return true, createLockObject(objectType, objectMeta), nil
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						verb: "update",
0000000000000000000000000000000000000000;;						reaction: func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;							return true, action.(core.CreateAction).GetObject(), nil
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				observedRecord: rl.LeaderElectionRecord{HolderIdentity: "bing"},
0000000000000000000000000000000000000000;;				observedTime:   past,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectSuccess:    true,
0000000000000000000000000000000000000000;;				transitionLeader: true,
0000000000000000000000000000000000000000;;				outHolder:        "baz",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// don't acquire from led, acked object
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				reactors: []struct {
0000000000000000000000000000000000000000;;					verb     string
0000000000000000000000000000000000000000;;					reaction core.ReactionFunc
0000000000000000000000000000000000000000;;				}{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						verb: "get",
0000000000000000000000000000000000000000;;						reaction: func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;							objectMeta := metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Namespace: action.GetNamespace(),
0000000000000000000000000000000000000000;;								Name:      action.(core.GetAction).GetName(),
0000000000000000000000000000000000000000;;								Annotations: map[string]string{
0000000000000000000000000000000000000000;;									rl.LeaderElectionRecordAnnotationKey: `{"holderIdentity":"bing"}`,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return true, createLockObject(objectType, objectMeta), nil
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				observedTime: future,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectSuccess: false,
0000000000000000000000000000000000000000;;				outHolder:     "bing",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			// renew already acquired object
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				reactors: []struct {
0000000000000000000000000000000000000000;;					verb     string
0000000000000000000000000000000000000000;;					reaction core.ReactionFunc
0000000000000000000000000000000000000000;;				}{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						verb: "get",
0000000000000000000000000000000000000000;;						reaction: func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;							objectMeta := metav1.ObjectMeta{
0000000000000000000000000000000000000000;;								Namespace: action.GetNamespace(),
0000000000000000000000000000000000000000;;								Name:      action.(core.GetAction).GetName(),
0000000000000000000000000000000000000000;;								Annotations: map[string]string{
0000000000000000000000000000000000000000;;									rl.LeaderElectionRecordAnnotationKey: `{"holderIdentity":"baz"}`,
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return true, createLockObject(objectType, objectMeta), nil
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						verb: "update",
0000000000000000000000000000000000000000;;						reaction: func(action core.Action) (handled bool, ret runtime.Object, err error) {
0000000000000000000000000000000000000000;;							return true, action.(core.CreateAction).GetObject(), nil
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				observedTime:   future,
0000000000000000000000000000000000000000;;				observedRecord: rl.LeaderElectionRecord{HolderIdentity: "baz"},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				expectSuccess: true,
0000000000000000000000000000000000000000;;				outHolder:     "baz",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, test := range tests {
0000000000000000000000000000000000000000;;			// OnNewLeader is called async so we have to wait for it.
0000000000000000000000000000000000000000;;			var wg sync.WaitGroup
0000000000000000000000000000000000000000;;			wg.Add(1)
0000000000000000000000000000000000000000;;			var reportedLeader string
0000000000000000000000000000000000000000;;			var lock rl.Interface
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			objectMeta := metav1.ObjectMeta{Namespace: "foo", Name: "bar"}
0000000000000000000000000000000000000000;;			resourceLockConfig := rl.ResourceLockConfig{
0000000000000000000000000000000000000000;;				Identity:      "baz",
0000000000000000000000000000000000000000;;				EventRecorder: &record.FakeRecorder{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c := &fakecorev1.FakeCoreV1{Fake: &core.Fake{}}
0000000000000000000000000000000000000000;;			for _, reactor := range test.reactors {
0000000000000000000000000000000000000000;;				c.AddReactor(reactor.verb, objectType, reactor.reaction)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.AddReactor("*", "*", func(action core.Action) (bool, runtime.Object, error) {
0000000000000000000000000000000000000000;;				t.Errorf("[%v] unreachable action. testclient called too many times: %+v", i, action)
0000000000000000000000000000000000000000;;				return true, nil, fmt.Errorf("unreachable action")
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch objectType {
0000000000000000000000000000000000000000;;			case "endpoints":
0000000000000000000000000000000000000000;;				lock = &rl.EndpointsLock{
0000000000000000000000000000000000000000;;					EndpointsMeta: objectMeta,
0000000000000000000000000000000000000000;;					LockConfig:    resourceLockConfig,
0000000000000000000000000000000000000000;;					Client:        c,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case "configmaps":
0000000000000000000000000000000000000000;;				lock = &rl.ConfigMapLock{
0000000000000000000000000000000000000000;;					ConfigMapMeta: objectMeta,
0000000000000000000000000000000000000000;;					LockConfig:    resourceLockConfig,
0000000000000000000000000000000000000000;;					Client:        c,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lec := LeaderElectionConfig{
0000000000000000000000000000000000000000;;				Lock:          lock,
0000000000000000000000000000000000000000;;				LeaseDuration: 10 * time.Second,
0000000000000000000000000000000000000000;;				Callbacks: LeaderCallbacks{
0000000000000000000000000000000000000000;;					OnNewLeader: func(l string) {
0000000000000000000000000000000000000000;;						defer wg.Done()
0000000000000000000000000000000000000000;;						reportedLeader = l
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			le := &LeaderElector{
0000000000000000000000000000000000000000;;				config:         lec,
0000000000000000000000000000000000000000;;				observedRecord: test.observedRecord,
0000000000000000000000000000000000000000;;				observedTime:   test.observedTime,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if test.expectSuccess != le.tryAcquireOrRenew() {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]unexpected result of tryAcquireOrRenew: [succeded=%v]", i, !test.expectSuccess)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			le.observedRecord.AcquireTime = metav1.Time{}
0000000000000000000000000000000000000000;;			le.observedRecord.RenewTime = metav1.Time{}
0000000000000000000000000000000000000000;;			if le.observedRecord.HolderIdentity != test.outHolder {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]expected holder:\n\t%+v\ngot:\n\t%+v", i, test.outHolder, le.observedRecord.HolderIdentity)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(test.reactors) != len(c.Actions()) {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]wrong number of api interactions", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if test.transitionLeader && le.observedRecord.LeaderTransitions != 1 {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]leader should have transitioned but did not", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !test.transitionLeader && le.observedRecord.LeaderTransitions != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]leader should not have transitioned but did", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			le.maybeReportTransition()
0000000000000000000000000000000000000000;;			wg.Wait()
0000000000000000000000000000000000000000;;			if reportedLeader != test.outHolder {
0000000000000000000000000000000000000000;;				t.Errorf("[%v]reported leader was not the new leader. expected %q, got %q", i, test.outHolder, reportedLeader)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Will test leader election using configmap as the resource
0000000000000000000000000000000000000000;;	func TestTryAcquireOrRenewConfigMaps(t *testing.T) {
0000000000000000000000000000000000000000;;		testTryAcquireOrRenew(t, "configmaps")
0000000000000000000000000000000000000000;;	}
