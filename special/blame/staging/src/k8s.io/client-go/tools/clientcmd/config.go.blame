0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/clientcmd/config.go[staging/src/k8s.io/client-go/1.4/tools/clientcmd/config.go][staging/src/k8s.io/client-go/tools/clientcmd/config.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package clientcmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigAccess is used by subcommands and methods in this package to load and modify the appropriate config files
0000000000000000000000000000000000000000;;	type ConfigAccess interface {
0000000000000000000000000000000000000000;;		// GetLoadingPrecedence returns the slice of files that should be used for loading and inspecting the config
0000000000000000000000000000000000000000;;		GetLoadingPrecedence() []string
0000000000000000000000000000000000000000;;		// GetStartingConfig returns the config that subcommands should being operating against.  It may or may not be merged depending on loading rules
0000000000000000000000000000000000000000;;		GetStartingConfig() (*clientcmdapi.Config, error)
0000000000000000000000000000000000000000;;		// GetDefaultFilename returns the name of the file you should write into (create if necessary), if you're trying to create a new stanza as opposed to updating an existing one.
0000000000000000000000000000000000000000;;		GetDefaultFilename() string
0000000000000000000000000000000000000000;;		// IsExplicitFile indicates whether or not this command is interested in exactly one file.  This implementation only ever does that  via a flag, but implementations that handle local, global, and flags may have more
0000000000000000000000000000000000000000;;		IsExplicitFile() bool
0000000000000000000000000000000000000000;;		// GetExplicitFile returns the particular file this command is operating against.  This implementation only ever has one, but implementations that handle local, global, and flags may have more
0000000000000000000000000000000000000000;;		GetExplicitFile() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PathOptions struct {
0000000000000000000000000000000000000000;;		// GlobalFile is the full path to the file to load as the global (final) option
0000000000000000000000000000000000000000;;		GlobalFile string
0000000000000000000000000000000000000000;;		// EnvVar is the env var name that points to the list of kubeconfig files to load
0000000000000000000000000000000000000000;;		EnvVar string
0000000000000000000000000000000000000000;;		// ExplicitFileFlag is the name of the flag to use for prompting for the kubeconfig file
0000000000000000000000000000000000000000;;		ExplicitFileFlag string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GlobalFileSubpath is an optional value used for displaying help
0000000000000000000000000000000000000000;;		GlobalFileSubpath string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LoadingRules *ClientConfigLoadingRules
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *PathOptions) GetEnvVarFiles() []string {
0000000000000000000000000000000000000000;;		if len(o.EnvVar) == 0 {
0000000000000000000000000000000000000000;;			return []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		envVarValue := os.Getenv(o.EnvVar)
0000000000000000000000000000000000000000;;		if len(envVarValue) == 0 {
0000000000000000000000000000000000000000;;			return []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return filepath.SplitList(envVarValue)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *PathOptions) GetLoadingPrecedence() []string {
0000000000000000000000000000000000000000;;		if envVarFiles := o.GetEnvVarFiles(); len(envVarFiles) > 0 {
0000000000000000000000000000000000000000;;			return envVarFiles
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return []string{o.GlobalFile}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *PathOptions) GetStartingConfig() (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		// don't mutate the original
0000000000000000000000000000000000000000;;		loadingRules := *o.LoadingRules
0000000000000000000000000000000000000000;;		loadingRules.Precedence = o.GetLoadingPrecedence()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig := NewNonInteractiveDeferredLoadingClientConfig(&loadingRules, &ConfigOverrides{})
0000000000000000000000000000000000000000;;		rawConfig, err := clientConfig.RawConfig()
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return clientcmdapi.NewConfig(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &rawConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *PathOptions) GetDefaultFilename() string {
0000000000000000000000000000000000000000;;		if o.IsExplicitFile() {
0000000000000000000000000000000000000000;;			return o.GetExplicitFile()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if envVarFiles := o.GetEnvVarFiles(); len(envVarFiles) > 0 {
0000000000000000000000000000000000000000;;			if len(envVarFiles) == 1 {
0000000000000000000000000000000000000000;;				return envVarFiles[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if any of the envvar files already exists, return it
0000000000000000000000000000000000000000;;			for _, envVarFile := range envVarFiles {
0000000000000000000000000000000000000000;;				if _, err := os.Stat(envVarFile); err == nil {
0000000000000000000000000000000000000000;;					return envVarFile
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// otherwise, return the last one in the list
0000000000000000000000000000000000000000;;			return envVarFiles[len(envVarFiles)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o.GlobalFile
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *PathOptions) IsExplicitFile() bool {
0000000000000000000000000000000000000000;;		if len(o.LoadingRules.ExplicitPath) > 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *PathOptions) GetExplicitFile() string {
0000000000000000000000000000000000000000;;		return o.LoadingRules.ExplicitPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDefaultPathOptions() *PathOptions {
0000000000000000000000000000000000000000;;		ret := &PathOptions{
0000000000000000000000000000000000000000;;			GlobalFile:       RecommendedHomeFile,
0000000000000000000000000000000000000000;;			EnvVar:           RecommendedConfigPathEnvVar,
0000000000000000000000000000000000000000;;			ExplicitFileFlag: RecommendedConfigPathFlag,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			GlobalFileSubpath: path.Join(RecommendedHomeDir, RecommendedFileName),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			LoadingRules: NewDefaultClientConfigLoadingRules(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret.LoadingRules.DoNotResolvePaths = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ModifyConfig takes a Config object, iterates through Clusters, AuthInfos, and Contexts, uses the LocationOfOrigin if specified or
0000000000000000000000000000000000000000;;	// uses the default destination file to write the results into.  This results in multiple file reads, but it's very easy to follow.
0000000000000000000000000000000000000000;;	// Preferences and CurrentContext should always be set in the default destination file.  Since we can't distinguish between empty and missing values
0000000000000000000000000000000000000000;;	// (no nil strings), we're forced have separate handling for them.  In the kubeconfig cases, newConfig should have at most one difference,
0000000000000000000000000000000000000000;;	// that means that this code will only write into a single file.  If you want to relativizePaths, you must provide a fully qualified path in any
0000000000000000000000000000000000000000;;	// modified element.
0000000000000000000000000000000000000000;;	func ModifyConfig(configAccess ConfigAccess, newConfig clientcmdapi.Config, relativizePaths bool) error {
0000000000000000000000000000000000000000;;		possibleSources := configAccess.GetLoadingPrecedence()
0000000000000000000000000000000000000000;;		// sort the possible kubeconfig files so we always "lock" in the same order
0000000000000000000000000000000000000000;;		// to avoid deadlock (note: this can fail w/ symlinks, but... come on).
0000000000000000000000000000000000000000;;		sort.Strings(possibleSources)
0000000000000000000000000000000000000000;;		for _, filename := range possibleSources {
0000000000000000000000000000000000000000;;			if err := lockFile(filename); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer unlockFile(filename)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startingConfig, err := configAccess.GetStartingConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We need to find all differences, locate their original files, read a partial config to modify only that stanza and write out the file.
0000000000000000000000000000000000000000;;		// Special case the test for current context and preferences since those always write to the default file.
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(*startingConfig, newConfig) {
0000000000000000000000000000000000000000;;			// nothing to do
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if startingConfig.CurrentContext != newConfig.CurrentContext {
0000000000000000000000000000000000000000;;			if err := writeCurrentContext(configAccess, newConfig.CurrentContext); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(startingConfig.Preferences, newConfig.Preferences) {
0000000000000000000000000000000000000000;;			if err := writePreferences(configAccess, newConfig.Preferences); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Search every cluster, authInfo, and context.  First from new to old for differences, then from old to new for deletions
0000000000000000000000000000000000000000;;		for key, cluster := range newConfig.Clusters {
0000000000000000000000000000000000000000;;			startingCluster, exists := startingConfig.Clusters[key]
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(cluster, startingCluster) || !exists {
0000000000000000000000000000000000000000;;				destinationFile := cluster.LocationOfOrigin
0000000000000000000000000000000000000000;;				if len(destinationFile) == 0 {
0000000000000000000000000000000000000000;;					destinationFile = configAccess.GetDefaultFilename()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				configToWrite, err := getConfigFromFile(destinationFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t := *cluster
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				configToWrite.Clusters[key] = &t
0000000000000000000000000000000000000000;;				configToWrite.Clusters[key].LocationOfOrigin = destinationFile
0000000000000000000000000000000000000000;;				if relativizePaths {
0000000000000000000000000000000000000000;;					if err := RelativizeClusterLocalPaths(configToWrite.Clusters[key]); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := WriteToFile(*configToWrite, destinationFile); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, context := range newConfig.Contexts {
0000000000000000000000000000000000000000;;			startingContext, exists := startingConfig.Contexts[key]
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(context, startingContext) || !exists {
0000000000000000000000000000000000000000;;				destinationFile := context.LocationOfOrigin
0000000000000000000000000000000000000000;;				if len(destinationFile) == 0 {
0000000000000000000000000000000000000000;;					destinationFile = configAccess.GetDefaultFilename()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				configToWrite, err := getConfigFromFile(destinationFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				configToWrite.Contexts[key] = context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := WriteToFile(*configToWrite, destinationFile); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, authInfo := range newConfig.AuthInfos {
0000000000000000000000000000000000000000;;			startingAuthInfo, exists := startingConfig.AuthInfos[key]
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(authInfo, startingAuthInfo) || !exists {
0000000000000000000000000000000000000000;;				destinationFile := authInfo.LocationOfOrigin
0000000000000000000000000000000000000000;;				if len(destinationFile) == 0 {
0000000000000000000000000000000000000000;;					destinationFile = configAccess.GetDefaultFilename()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				configToWrite, err := getConfigFromFile(destinationFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t := *authInfo
0000000000000000000000000000000000000000;;				configToWrite.AuthInfos[key] = &t
0000000000000000000000000000000000000000;;				configToWrite.AuthInfos[key].LocationOfOrigin = destinationFile
0000000000000000000000000000000000000000;;				if relativizePaths {
0000000000000000000000000000000000000000;;					if err := RelativizeAuthInfoLocalPaths(configToWrite.AuthInfos[key]); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := WriteToFile(*configToWrite, destinationFile); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, cluster := range startingConfig.Clusters {
0000000000000000000000000000000000000000;;			if _, exists := newConfig.Clusters[key]; !exists {
0000000000000000000000000000000000000000;;				destinationFile := cluster.LocationOfOrigin
0000000000000000000000000000000000000000;;				if len(destinationFile) == 0 {
0000000000000000000000000000000000000000;;					destinationFile = configAccess.GetDefaultFilename()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				configToWrite, err := getConfigFromFile(destinationFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				delete(configToWrite.Clusters, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := WriteToFile(*configToWrite, destinationFile); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, context := range startingConfig.Contexts {
0000000000000000000000000000000000000000;;			if _, exists := newConfig.Contexts[key]; !exists {
0000000000000000000000000000000000000000;;				destinationFile := context.LocationOfOrigin
0000000000000000000000000000000000000000;;				if len(destinationFile) == 0 {
0000000000000000000000000000000000000000;;					destinationFile = configAccess.GetDefaultFilename()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				configToWrite, err := getConfigFromFile(destinationFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				delete(configToWrite.Contexts, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := WriteToFile(*configToWrite, destinationFile); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, authInfo := range startingConfig.AuthInfos {
0000000000000000000000000000000000000000;;			if _, exists := newConfig.AuthInfos[key]; !exists {
0000000000000000000000000000000000000000;;				destinationFile := authInfo.LocationOfOrigin
0000000000000000000000000000000000000000;;				if len(destinationFile) == 0 {
0000000000000000000000000000000000000000;;					destinationFile = configAccess.GetDefaultFilename()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				configToWrite, err := getConfigFromFile(destinationFile)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				delete(configToWrite.AuthInfos, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := WriteToFile(*configToWrite, destinationFile); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PersisterForUser(configAccess ConfigAccess, user string) restclient.AuthProviderConfigPersister {
0000000000000000000000000000000000000000;;		return &persister{configAccess, user}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type persister struct {
0000000000000000000000000000000000000000;;		configAccess ConfigAccess
0000000000000000000000000000000000000000;;		user         string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *persister) Persist(config map[string]string) error {
0000000000000000000000000000000000000000;;		newConfig, err := p.configAccess.GetStartingConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		authInfo, ok := newConfig.AuthInfos[p.user]
0000000000000000000000000000000000000000;;		if ok && authInfo.AuthProvider != nil {
0000000000000000000000000000000000000000;;			authInfo.AuthProvider.Config = config
0000000000000000000000000000000000000000;;			ModifyConfig(p.configAccess, *newConfig, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeCurrentContext takes three possible paths.
0000000000000000000000000000000000000000;;	// If newCurrentContext is the same as the startingConfig's current context, then we exit.
0000000000000000000000000000000000000000;;	// If newCurrentContext has a value, then that value is written into the default destination file.
0000000000000000000000000000000000000000;;	// If newCurrentContext is empty, then we find the config file that is setting the CurrentContext and clear the value from that file
0000000000000000000000000000000000000000;;	func writeCurrentContext(configAccess ConfigAccess, newCurrentContext string) error {
0000000000000000000000000000000000000000;;		if startingConfig, err := configAccess.GetStartingConfig(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if startingConfig.CurrentContext == newCurrentContext {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if configAccess.IsExplicitFile() {
0000000000000000000000000000000000000000;;			file := configAccess.GetExplicitFile()
0000000000000000000000000000000000000000;;			currConfig, err := getConfigFromFile(file)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currConfig.CurrentContext = newCurrentContext
0000000000000000000000000000000000000000;;			if err := WriteToFile(*currConfig, file); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(newCurrentContext) > 0 {
0000000000000000000000000000000000000000;;			destinationFile := configAccess.GetDefaultFilename()
0000000000000000000000000000000000000000;;			config, err := getConfigFromFile(destinationFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config.CurrentContext = newCurrentContext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := WriteToFile(*config, destinationFile); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we're supposed to be clearing the current context.  We need to find the first spot in the chain that is setting it and clear it
0000000000000000000000000000000000000000;;		for _, file := range configAccess.GetLoadingPrecedence() {
0000000000000000000000000000000000000000;;			if _, err := os.Stat(file); err == nil {
0000000000000000000000000000000000000000;;				currConfig, err := getConfigFromFile(file)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(currConfig.CurrentContext) > 0 {
0000000000000000000000000000000000000000;;					currConfig.CurrentContext = newCurrentContext
0000000000000000000000000000000000000000;;					if err := WriteToFile(*currConfig, file); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors.New("no config found to write context")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writePreferences(configAccess ConfigAccess, newPrefs clientcmdapi.Preferences) error {
0000000000000000000000000000000000000000;;		if startingConfig, err := configAccess.GetStartingConfig(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else if reflect.DeepEqual(startingConfig.Preferences, newPrefs) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if configAccess.IsExplicitFile() {
0000000000000000000000000000000000000000;;			file := configAccess.GetExplicitFile()
0000000000000000000000000000000000000000;;			currConfig, err := getConfigFromFile(file)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currConfig.Preferences = newPrefs
0000000000000000000000000000000000000000;;			if err := WriteToFile(*currConfig, file); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, file := range configAccess.GetLoadingPrecedence() {
0000000000000000000000000000000000000000;;			currConfig, err := getConfigFromFile(file)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(currConfig.Preferences, newPrefs) {
0000000000000000000000000000000000000000;;				currConfig.Preferences = newPrefs
0000000000000000000000000000000000000000;;				if err := WriteToFile(*currConfig, file); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return errors.New("no config found to write preferences")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getConfigFromFile tries to read a kubeconfig file and if it can't, returns an error.  One exception, missing files result in empty configs, not an error.
0000000000000000000000000000000000000000;;	func getConfigFromFile(filename string) (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		config, err := LoadFromFile(filename)
0000000000000000000000000000000000000000;;		if err != nil && !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config == nil {
0000000000000000000000000000000000000000;;			config = clientcmdapi.NewConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetConfigFromFileOrDie tries to read a kubeconfig file and if it can't, it calls exit.  One exception, missing files result in empty configs, not an exit
0000000000000000000000000000000000000000;;	func GetConfigFromFileOrDie(filename string) *clientcmdapi.Config {
0000000000000000000000000000000000000000;;		config, err := getConfigFromFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.FatalDepth(1, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return config
0000000000000000000000000000000000000000;;	}
