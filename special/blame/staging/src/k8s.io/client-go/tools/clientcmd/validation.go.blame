0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/clientcmd/validation.go[staging/src/k8s.io/client-go/1.4/tools/clientcmd/validation.go][staging/src/k8s.io/client-go/tools/clientcmd/validation.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package clientcmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/validation"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrNoContext   = errors.New("no context chosen")
0000000000000000000000000000000000000000;;		ErrEmptyConfig = errors.New("no configuration has been provided")
0000000000000000000000000000000000000000;;		// message is for consistency with old behavior
0000000000000000000000000000000000000000;;		ErrEmptyCluster = errors.New("cluster has no server defined")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type errContextNotFound struct {
0000000000000000000000000000000000000000;;		ContextName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *errContextNotFound) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("context was not found for specified context: %v", e.ContextName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsContextNotFound returns a boolean indicating whether the error is known to
0000000000000000000000000000000000000000;;	// report that a context was not found
0000000000000000000000000000000000000000;;	func IsContextNotFound(err error) bool {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := err.(*errContextNotFound); ok || err == ErrNoContext {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Contains(err.Error(), "context was not found for specified context")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmptyConfig returns true if the provided error indicates the provided configuration
0000000000000000000000000000000000000000;;	// is empty.
0000000000000000000000000000000000000000;;	func IsEmptyConfig(err error) bool {
0000000000000000000000000000000000000000;;		switch t := err.(type) {
0000000000000000000000000000000000000000;;		case errConfigurationInvalid:
0000000000000000000000000000000000000000;;			return len(t) == 1 && t[0] == ErrEmptyConfig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err == ErrEmptyConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errConfigurationInvalid is a set of errors indicating the configuration is invalid.
0000000000000000000000000000000000000000;;	type errConfigurationInvalid []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errConfigurationInvalid implements error and Aggregate
0000000000000000000000000000000000000000;;	var _ error = errConfigurationInvalid{}
0000000000000000000000000000000000000000;;	var _ utilerrors.Aggregate = errConfigurationInvalid{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newErrConfigurationInvalid(errs []error) error {
0000000000000000000000000000000000000000;;		switch len(errs) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errConfigurationInvalid(errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error implements the error interface
0000000000000000000000000000000000000000;;	func (e errConfigurationInvalid) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("invalid configuration: %v", utilerrors.NewAggregate(e).Error())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Errors implements the AggregateError interface
0000000000000000000000000000000000000000;;	func (e errConfigurationInvalid) Errors() []error {
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsConfigurationInvalid returns true if the provided error indicates the configuration is invalid.
0000000000000000000000000000000000000000;;	func IsConfigurationInvalid(err error) bool {
0000000000000000000000000000000000000000;;		switch err.(type) {
0000000000000000000000000000000000000000;;		case *errContextNotFound, errConfigurationInvalid:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return IsContextNotFound(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate checks for errors in the Config.  It does not return early so that it can find as many errors as possible.
0000000000000000000000000000000000000000;;	func Validate(config clientcmdapi.Config) error {
0000000000000000000000000000000000000000;;		validationErrors := make([]error, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if clientcmdapi.IsConfigEmpty(&config) {
0000000000000000000000000000000000000000;;			return newErrConfigurationInvalid([]error{ErrEmptyConfig})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(config.CurrentContext) != 0 {
0000000000000000000000000000000000000000;;			if _, exists := config.Contexts[config.CurrentContext]; !exists {
0000000000000000000000000000000000000000;;				validationErrors = append(validationErrors, &errContextNotFound{config.CurrentContext})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for contextName, context := range config.Contexts {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, validateContext(contextName, *context, config)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for authInfoName, authInfo := range config.AuthInfos {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, validateAuthInfo(authInfoName, *authInfo)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for clusterName, clusterInfo := range config.Clusters {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, validateClusterInfo(clusterName, *clusterInfo)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newErrConfigurationInvalid(validationErrors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfirmUsable looks a particular context and determines if that particular part of the config is useable.  There might still be errors in the config,
0000000000000000000000000000000000000000;;	// but no errors in the sections requested or referenced.  It does not return early so that it can find as many errors as possible.
0000000000000000000000000000000000000000;;	func ConfirmUsable(config clientcmdapi.Config, passedContextName string) error {
0000000000000000000000000000000000000000;;		validationErrors := make([]error, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if clientcmdapi.IsConfigEmpty(&config) {
0000000000000000000000000000000000000000;;			return newErrConfigurationInvalid([]error{ErrEmptyConfig})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var contextName string
0000000000000000000000000000000000000000;;		if len(passedContextName) != 0 {
0000000000000000000000000000000000000000;;			contextName = passedContextName
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			contextName = config.CurrentContext
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(contextName) == 0 {
0000000000000000000000000000000000000000;;			return ErrNoContext
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context, exists := config.Contexts[contextName]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, &errContextNotFound{contextName})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if exists {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, validateContext(contextName, *context, config)...)
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, validateAuthInfo(context.AuthInfo, *config.AuthInfos[context.AuthInfo])...)
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, validateClusterInfo(context.Cluster, *config.Clusters[context.Cluster])...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newErrConfigurationInvalid(validationErrors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateClusterInfo looks for conflicts and errors in the cluster info
0000000000000000000000000000000000000000;;	func validateClusterInfo(clusterName string, clusterInfo clientcmdapi.Cluster) []error {
0000000000000000000000000000000000000000;;		validationErrors := make([]error, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		emptyCluster := clientcmdapi.NewCluster()
0000000000000000000000000000000000000000;;		if reflect.DeepEqual(*emptyCluster, clusterInfo) {
0000000000000000000000000000000000000000;;			return []error{ErrEmptyCluster}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(clusterInfo.Server) == 0 {
0000000000000000000000000000000000000000;;			if len(clusterName) == 0 {
0000000000000000000000000000000000000000;;				validationErrors = append(validationErrors, fmt.Errorf("default cluster has no server defined"))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				validationErrors = append(validationErrors, fmt.Errorf("no server found for cluster %q", clusterName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make sure CA data and CA file aren't both specified
0000000000000000000000000000000000000000;;		if len(clusterInfo.CertificateAuthority) != 0 && len(clusterInfo.CertificateAuthorityData) != 0 {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, fmt.Errorf("certificate-authority-data and certificate-authority are both specified for %v. certificate-authority-data will override.", clusterName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(clusterInfo.CertificateAuthority) != 0 {
0000000000000000000000000000000000000000;;			clientCertCA, err := os.Open(clusterInfo.CertificateAuthority)
0000000000000000000000000000000000000000;;			defer clientCertCA.Close()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				validationErrors = append(validationErrors, fmt.Errorf("unable to read certificate-authority %v for %v due to %v", clusterInfo.CertificateAuthority, clusterName, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return validationErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateAuthInfo looks for conflicts and errors in the auth info
0000000000000000000000000000000000000000;;	func validateAuthInfo(authInfoName string, authInfo clientcmdapi.AuthInfo) []error {
0000000000000000000000000000000000000000;;		validationErrors := make([]error, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usingAuthPath := false
0000000000000000000000000000000000000000;;		methods := make([]string, 0, 3)
0000000000000000000000000000000000000000;;		if len(authInfo.Token) != 0 {
0000000000000000000000000000000000000000;;			methods = append(methods, "token")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(authInfo.Username) != 0 || len(authInfo.Password) != 0 {
0000000000000000000000000000000000000000;;			methods = append(methods, "basicAuth")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(authInfo.ClientCertificate) != 0 || len(authInfo.ClientCertificateData) != 0 {
0000000000000000000000000000000000000000;;			// Make sure cert data and file aren't both specified
0000000000000000000000000000000000000000;;			if len(authInfo.ClientCertificate) != 0 && len(authInfo.ClientCertificateData) != 0 {
0000000000000000000000000000000000000000;;				validationErrors = append(validationErrors, fmt.Errorf("client-cert-data and client-cert are both specified for %v. client-cert-data will override.", authInfoName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Make sure key data and file aren't both specified
0000000000000000000000000000000000000000;;			if len(authInfo.ClientKey) != 0 && len(authInfo.ClientKeyData) != 0 {
0000000000000000000000000000000000000000;;				validationErrors = append(validationErrors, fmt.Errorf("client-key-data and client-key are both specified for %v; client-key-data will override", authInfoName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Make sure a key is specified
0000000000000000000000000000000000000000;;			if len(authInfo.ClientKey) == 0 && len(authInfo.ClientKeyData) == 0 {
0000000000000000000000000000000000000000;;				validationErrors = append(validationErrors, fmt.Errorf("client-key-data or client-key must be specified for %v to use the clientCert authentication method.", authInfoName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(authInfo.ClientCertificate) != 0 {
0000000000000000000000000000000000000000;;				clientCertFile, err := os.Open(authInfo.ClientCertificate)
0000000000000000000000000000000000000000;;				defer clientCertFile.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					validationErrors = append(validationErrors, fmt.Errorf("unable to read client-cert %v for %v due to %v", authInfo.ClientCertificate, authInfoName, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(authInfo.ClientKey) != 0 {
0000000000000000000000000000000000000000;;				clientKeyFile, err := os.Open(authInfo.ClientKey)
0000000000000000000000000000000000000000;;				defer clientKeyFile.Close()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					validationErrors = append(validationErrors, fmt.Errorf("unable to read client-key %v for %v due to %v", authInfo.ClientKey, authInfoName, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// authPath also provides information for the client to identify the server, so allow multiple auth methods in that case
0000000000000000000000000000000000000000;;		if (len(methods) > 1) && (!usingAuthPath) {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, fmt.Errorf("more than one authentication method found for %v; found %v, only one is allowed", authInfoName, methods))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ImpersonateGroups or ImpersonateUserExtra should be requested with a user
0000000000000000000000000000000000000000;;		if (len(authInfo.ImpersonateGroups) > 0 || len(authInfo.ImpersonateUserExtra) > 0) && (len(authInfo.Impersonate) == 0) {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, fmt.Errorf("requesting groups or user-extra for %v without impersonating a user", authInfoName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return validationErrors
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateContext looks for errors in the context.  It is not transitive, so errors in the reference authInfo or cluster configs are not included in this return
0000000000000000000000000000000000000000;;	func validateContext(contextName string, context clientcmdapi.Context, config clientcmdapi.Config) []error {
0000000000000000000000000000000000000000;;		validationErrors := make([]error, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(context.AuthInfo) == 0 {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, fmt.Errorf("user was not specified for context %q", contextName))
0000000000000000000000000000000000000000;;		} else if _, exists := config.AuthInfos[context.AuthInfo]; !exists {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, fmt.Errorf("user %q was not found for context %q", context.AuthInfo, contextName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(context.Cluster) == 0 {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, fmt.Errorf("cluster was not specified for context %q", contextName))
0000000000000000000000000000000000000000;;		} else if _, exists := config.Clusters[context.Cluster]; !exists {
0000000000000000000000000000000000000000;;			validationErrors = append(validationErrors, fmt.Errorf("cluster %q was not found for context %q", context.Cluster, contextName))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(context.Namespace) != 0 {
0000000000000000000000000000000000000000;;			if len(validation.IsDNS1123Label(context.Namespace)) != 0 {
0000000000000000000000000000000000000000;;				validationErrors = append(validationErrors, fmt.Errorf("namespace %q for context %q does not conform to the kubernetes DNS_LABEL rules", context.Namespace, contextName))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return validationErrors
0000000000000000000000000000000000000000;;	}
