0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
d10b1f959147a31c5c09894b7b1a124d48d4e949;staging/src/k8s.io/client-go/1.5/tools/clientcmd/merged_client_builder_test.go[staging/src/k8s.io/client-go/1.5/tools/clientcmd/merged_client_builder_test.go][staging/src/k8s.io/client-go/tools/clientcmd/merged_client_builder_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package clientcmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testLoader struct {
0000000000000000000000000000000000000000;;		ClientConfigLoader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		called bool
0000000000000000000000000000000000000000;;		config *clientcmdapi.Config
0000000000000000000000000000000000000000;;		err    error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *testLoader) Load() (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		l.called = true
0000000000000000000000000000000000000000;;		return l.config, l.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testClientConfig struct {
0000000000000000000000000000000000000000;;		config             *restclient.Config
0000000000000000000000000000000000000000;;		namespace          string
0000000000000000000000000000000000000000;;		namespaceSpecified bool
0000000000000000000000000000000000000000;;		err                error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *testClientConfig) RawConfig() (clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		return clientcmdapi.Config{}, fmt.Errorf("unexpected call")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *testClientConfig) ClientConfig() (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		return c.config, c.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *testClientConfig) Namespace() (string, bool, error) {
0000000000000000000000000000000000000000;;		return c.namespace, c.namespaceSpecified, c.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (c *testClientConfig) ConfigAccess() ConfigAccess {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testICC struct {
0000000000000000000000000000000000000000;;		testClientConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		possible bool
0000000000000000000000000000000000000000;;		called   bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (icc *testICC) Possible() bool {
0000000000000000000000000000000000000000;;		icc.called = true
0000000000000000000000000000000000000000;;		return icc.possible
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInClusterConfig(t *testing.T) {
0000000000000000000000000000000000000000;;		default1 := &DirectClientConfig{
0000000000000000000000000000000000000000;;			config:      *createValidTestConfig(),
0000000000000000000000000000000000000000;;			contextName: "clean",
0000000000000000000000000000000000000000;;			overrides:   &ConfigOverrides{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		invalidDefaultConfig := clientcmdapi.NewConfig()
0000000000000000000000000000000000000000;;		invalidDefaultConfig.Clusters["clean"] = &clientcmdapi.Cluster{
0000000000000000000000000000000000000000;;			Server: "http://localhost:8080",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		invalidDefaultConfig.Contexts["other"] = &clientcmdapi.Context{
0000000000000000000000000000000000000000;;			Cluster: "clean",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		invalidDefaultConfig.CurrentContext = "clean"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultInvalid := &DirectClientConfig{
0000000000000000000000000000000000000000;;			config:    *invalidDefaultConfig,
0000000000000000000000000000000000000000;;			overrides: &ConfigOverrides{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := defaultInvalid.ClientConfig(); err == nil || !IsConfigurationInvalid(err) {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config1, err := default1.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config2 := &restclient.Config{Host: "config2"}
0000000000000000000000000000000000000000;;		err1 := fmt.Errorf("unique error")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			clientConfig  *testClientConfig
0000000000000000000000000000000000000000;;			icc           *testICC
0000000000000000000000000000000000000000;;			defaultConfig *DirectClientConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			checkedICC bool
0000000000000000000000000000000000000000;;			result     *restclient.Config
0000000000000000000000000000000000000000;;			err        error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"in-cluster checked on other error": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{err: ErrEmptyConfig},
0000000000000000000000000000000000000000;;				icc:          &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;				result:     nil,
0000000000000000000000000000000000000000;;				err:        ErrEmptyConfig,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster not checked on non-empty error": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{err: ErrEmptyCluster},
0000000000000000000000000000000000000000;;				icc:          &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: false,
0000000000000000000000000000000000000000;;				result:     nil,
0000000000000000000000000000000000000000;;				err:        ErrEmptyCluster,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster checked when config is default": {
0000000000000000000000000000000000000000;;				defaultConfig: default1,
0000000000000000000000000000000000000000;;				clientConfig:  &testClientConfig{config: config1},
0000000000000000000000000000000000000000;;				icc:           &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;				result:     config1,
0000000000000000000000000000000000000000;;				err:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster not checked when default config is invalid": {
0000000000000000000000000000000000000000;;				defaultConfig: defaultInvalid,
0000000000000000000000000000000000000000;;				clientConfig:  &testClientConfig{config: config1},
0000000000000000000000000000000000000000;;				icc:           &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: false,
0000000000000000000000000000000000000000;;				result:     config1,
0000000000000000000000000000000000000000;;				err:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster not checked when config is not equal to default": {
0000000000000000000000000000000000000000;;				defaultConfig: default1,
0000000000000000000000000000000000000000;;				clientConfig:  &testClientConfig{config: config2},
0000000000000000000000000000000000000000;;				icc:           &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: false,
0000000000000000000000000000000000000000;;				result:     config2,
0000000000000000000000000000000000000000;;				err:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster checked when config is not equal to default and error is empty": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{config: config2, err: ErrEmptyConfig},
0000000000000000000000000000000000000000;;				icc:          &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;				result:     config2,
0000000000000000000000000000000000000000;;				err:        ErrEmptyConfig,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster error returned when config is empty": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{err: ErrEmptyConfig},
0000000000000000000000000000000000000000;;				icc: &testICC{
0000000000000000000000000000000000000000;;					possible: true,
0000000000000000000000000000000000000000;;					testClientConfig: testClientConfig{
0000000000000000000000000000000000000000;;						err: err1,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;				result:     nil,
0000000000000000000000000000000000000000;;				err:        err1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster config returned when config is empty": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{err: ErrEmptyConfig},
0000000000000000000000000000000000000000;;				icc: &testICC{
0000000000000000000000000000000000000000;;					possible: true,
0000000000000000000000000000000000000000;;					testClientConfig: testClientConfig{
0000000000000000000000000000000000000000;;						config: config2,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;				result:     config2,
0000000000000000000000000000000000000000;;				err:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster not checked when standard default is invalid": {
0000000000000000000000000000000000000000;;				defaultConfig: &DefaultClientConfig,
0000000000000000000000000000000000000000;;				clientConfig:  &testClientConfig{config: config2},
0000000000000000000000000000000000000000;;				icc:           &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: false,
0000000000000000000000000000000000000000;;				result:     config2,
0000000000000000000000000000000000000000;;				err:        nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, test := range testCases {
0000000000000000000000000000000000000000;;			c := &DeferredLoadingClientConfig{icc: test.icc}
0000000000000000000000000000000000000000;;			c.loader = &ClientConfigLoadingRules{DefaultClientConfig: test.defaultConfig}
0000000000000000000000000000000000000000;;			c.clientConfig = test.clientConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cfg, err := c.ClientConfig()
0000000000000000000000000000000000000000;;			if test.icc.called != test.checkedICC {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected in-cluster-config call %t", name, test.icc.called)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != test.err || cfg != test.result {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected result: %v %#v", name, err, cfg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestInClusterConfigNamespace(t *testing.T) {
0000000000000000000000000000000000000000;;		err1 := fmt.Errorf("unique error")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		testCases := map[string]struct {
0000000000000000000000000000000000000000;;			clientConfig *testClientConfig
0000000000000000000000000000000000000000;;			icc          *testICC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			checkedICC bool
0000000000000000000000000000000000000000;;			result     string
0000000000000000000000000000000000000000;;			ok         bool
0000000000000000000000000000000000000000;;			err        error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"in-cluster checked on empty error": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{err: ErrEmptyConfig},
0000000000000000000000000000000000000000;;				icc:          &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;				err:        ErrEmptyConfig,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster not checked on non-empty error": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{err: ErrEmptyCluster},
0000000000000000000000000000000000000000;;				icc:          &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err: ErrEmptyCluster,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster checked when config is default": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{},
0000000000000000000000000000000000000000;;				icc:          &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster not checked when config is not equal to default": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{namespace: "test", namespaceSpecified: true},
0000000000000000000000000000000000000000;;				icc:          &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				result: "test",
0000000000000000000000000000000000000000;;				ok:     true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster checked when namespace is not specified, but is defaulted": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{namespace: "test", namespaceSpecified: false},
0000000000000000000000000000000000000000;;				icc:          &testICC{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;				result:     "test",
0000000000000000000000000000000000000000;;				ok:         false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster error returned when config is empty": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{err: ErrEmptyConfig},
0000000000000000000000000000000000000000;;				icc: &testICC{
0000000000000000000000000000000000000000;;					possible: true,
0000000000000000000000000000000000000000;;					testClientConfig: testClientConfig{
0000000000000000000000000000000000000000;;						err: err1,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;				err:        err1,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster config returned when config is empty": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{err: ErrEmptyConfig},
0000000000000000000000000000000000000000;;				icc: &testICC{
0000000000000000000000000000000000000000;;					possible: true,
0000000000000000000000000000000000000000;;					testClientConfig: testClientConfig{
0000000000000000000000000000000000000000;;						namespace:          "test",
0000000000000000000000000000000000000000;;						namespaceSpecified: true,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;				result:     "test",
0000000000000000000000000000000000000000;;				ok:         true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"in-cluster config returned when config is empty and namespace is defaulted but not explicitly set": {
0000000000000000000000000000000000000000;;				clientConfig: &testClientConfig{err: ErrEmptyConfig},
0000000000000000000000000000000000000000;;				icc: &testICC{
0000000000000000000000000000000000000000;;					possible: true,
0000000000000000000000000000000000000000;;					testClientConfig: testClientConfig{
0000000000000000000000000000000000000000;;						namespace:          "test",
0000000000000000000000000000000000000000;;						namespaceSpecified: false,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				checkedICC: true,
0000000000000000000000000000000000000000;;				result:     "test",
0000000000000000000000000000000000000000;;				ok:         false,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, test := range testCases {
0000000000000000000000000000000000000000;;			c := &DeferredLoadingClientConfig{icc: test.icc}
0000000000000000000000000000000000000000;;			c.clientConfig = test.clientConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ns, ok, err := c.Namespace()
0000000000000000000000000000000000000000;;			if test.icc.called != test.checkedICC {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected in-cluster-config call %t", name, test.icc.called)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != test.err || ns != test.result || ok != test.ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected result: %v %s %t", name, err, ns, ok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
