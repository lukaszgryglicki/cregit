0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/clientcmd/loader.go[staging/src/k8s.io/client-go/1.4/tools/clientcmd/loader.go][staging/src/k8s.io/client-go/tools/clientcmd/loader.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package clientcmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		goruntime "runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/imdario/mergo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		utilerrors "k8s.io/apimachinery/pkg/util/errors"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;		clientcmdlatest "k8s.io/client-go/tools/clientcmd/api/latest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/homedir"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		RecommendedConfigPathFlag   = "kubeconfig"
0000000000000000000000000000000000000000;;		RecommendedConfigPathEnvVar = "KUBECONFIG"
0000000000000000000000000000000000000000;;		RecommendedHomeDir          = ".kube"
0000000000000000000000000000000000000000;;		RecommendedFileName         = "config"
0000000000000000000000000000000000000000;;		RecommendedSchemaName       = "schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		RecommendedConfigDir  = path.Join(homedir.HomeDir(), RecommendedHomeDir)
0000000000000000000000000000000000000000;;		RecommendedHomeFile   = path.Join(RecommendedConfigDir, RecommendedFileName)
0000000000000000000000000000000000000000;;		RecommendedSchemaFile = path.Join(RecommendedConfigDir, RecommendedSchemaName)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// currentMigrationRules returns a map that holds the history of recommended home directories used in previous versions.
0000000000000000000000000000000000000000;;	// Any future changes to RecommendedHomeFile and related are expected to add a migration rule here, in order to make
0000000000000000000000000000000000000000;;	// sure existing config files are migrated to their new locations properly.
0000000000000000000000000000000000000000;;	func currentMigrationRules() map[string]string {
0000000000000000000000000000000000000000;;		oldRecommendedHomeFile := path.Join(os.Getenv("HOME"), "/.kube/.kubeconfig")
0000000000000000000000000000000000000000;;		oldRecommendedWindowsHomeFile := path.Join(os.Getenv("HOME"), RecommendedHomeDir, RecommendedFileName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		migrationRules := map[string]string{}
0000000000000000000000000000000000000000;;		migrationRules[RecommendedHomeFile] = oldRecommendedHomeFile
0000000000000000000000000000000000000000;;		if goruntime.GOOS == "windows" {
0000000000000000000000000000000000000000;;			migrationRules[RecommendedHomeFile] = oldRecommendedWindowsHomeFile
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return migrationRules
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClientConfigLoader interface {
0000000000000000000000000000000000000000;;		ConfigAccess
0000000000000000000000000000000000000000;;		// IsDefaultConfig returns true if the returned config matches the defaults.
0000000000000000000000000000000000000000;;		IsDefaultConfig(*restclient.Config) bool
0000000000000000000000000000000000000000;;		// Load returns the latest config
0000000000000000000000000000000000000000;;		Load() (*clientcmdapi.Config, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KubeconfigGetter func() (*clientcmdapi.Config, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClientConfigGetter struct {
0000000000000000000000000000000000000000;;		kubeconfigGetter KubeconfigGetter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConfigGetter implements the ClientConfigLoader interface.
0000000000000000000000000000000000000000;;	var _ ClientConfigLoader = &ClientConfigGetter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *ClientConfigGetter) Load() (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		return g.kubeconfigGetter()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *ClientConfigGetter) GetLoadingPrecedence() []string {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (g *ClientConfigGetter) GetStartingConfig() (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		return g.kubeconfigGetter()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (g *ClientConfigGetter) GetDefaultFilename() string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (g *ClientConfigGetter) IsExplicitFile() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (g *ClientConfigGetter) GetExplicitFile() string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (g *ClientConfigGetter) IsDefaultConfig(config *restclient.Config) bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConfigLoadingRules is an ExplicitPath and string slice of specific locations that are used for merging together a Config
0000000000000000000000000000000000000000;;	// Callers can put the chain together however they want, but we'd recommend:
0000000000000000000000000000000000000000;;	// EnvVarPathFiles if set (a list of files if set) OR the HomeDirectoryPath
0000000000000000000000000000000000000000;;	// ExplicitPath is special, because if a user specifically requests a certain file be used and error is reported if thie file is not present
0000000000000000000000000000000000000000;;	type ClientConfigLoadingRules struct {
0000000000000000000000000000000000000000;;		ExplicitPath string
0000000000000000000000000000000000000000;;		Precedence   []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MigrationRules is a map of destination files to source files.  If a destination file is not present, then the source file is checked.
0000000000000000000000000000000000000000;;		// If the source file is present, then it is copied to the destination file BEFORE any further loading happens.
0000000000000000000000000000000000000000;;		MigrationRules map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DoNotResolvePaths indicates whether or not to resolve paths with respect to the originating files.  This is phrased as a negative so
0000000000000000000000000000000000000000;;		// that a default object that doesn't set this will usually get the behavior it wants.
0000000000000000000000000000000000000000;;		DoNotResolvePaths bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultClientConfig is an optional field indicating what rules to use to calculate a default configuration.
0000000000000000000000000000000000000000;;		// This should match the overrides passed in to ClientConfig loader.
0000000000000000000000000000000000000000;;		DefaultClientConfig ClientConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConfigLoadingRules implements the ClientConfigLoader interface.
0000000000000000000000000000000000000000;;	var _ ClientConfigLoader = &ClientConfigLoadingRules{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultClientConfigLoadingRules returns a ClientConfigLoadingRules object with default fields filled in.  You are not required to
0000000000000000000000000000000000000000;;	// use this constructor
0000000000000000000000000000000000000000;;	func NewDefaultClientConfigLoadingRules() *ClientConfigLoadingRules {
0000000000000000000000000000000000000000;;		chain := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		envVarFiles := os.Getenv(RecommendedConfigPathEnvVar)
0000000000000000000000000000000000000000;;		if len(envVarFiles) != 0 {
0000000000000000000000000000000000000000;;			chain = append(chain, filepath.SplitList(envVarFiles)...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			chain = append(chain, RecommendedHomeFile)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ClientConfigLoadingRules{
0000000000000000000000000000000000000000;;			Precedence:     chain,
0000000000000000000000000000000000000000;;			MigrationRules: currentMigrationRules(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Load starts by running the MigrationRules and then
0000000000000000000000000000000000000000;;	// takes the loading rules and returns a Config object based on following rules.
0000000000000000000000000000000000000000;;	//   if the ExplicitPath, return the unmerged explicit file
0000000000000000000000000000000000000000;;	//   Otherwise, return a merged config based on the Precedence slice
0000000000000000000000000000000000000000;;	// A missing ExplicitPath file produces an error. Empty filenames or other missing files are ignored.
0000000000000000000000000000000000000000;;	// Read errors or files with non-deserializable content produce errors.
0000000000000000000000000000000000000000;;	// The first file to set a particular map key wins and map key's value is never changed.
0000000000000000000000000000000000000000;;	// BUT, if you set a struct value that is NOT contained inside of map, the value WILL be changed.
0000000000000000000000000000000000000000;;	// This results in some odd looking logic to merge in one direction, merge in the other, and then merge the two.
0000000000000000000000000000000000000000;;	// It also means that if two files specify a "red-user", only values from the first file's red-user are used.  Even
0000000000000000000000000000000000000000;;	// non-conflicting entries from the second file's "red-user" are discarded.
0000000000000000000000000000000000000000;;	// Relative paths inside of the .kubeconfig files are resolved against the .kubeconfig file's parent folder
0000000000000000000000000000000000000000;;	// and only absolute file paths are returned.
0000000000000000000000000000000000000000;;	func (rules *ClientConfigLoadingRules) Load() (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		if err := rules.Migrate(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errlist := []error{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeConfigFiles := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure a file we were explicitly told to use exists
0000000000000000000000000000000000000000;;		if len(rules.ExplicitPath) > 0 {
0000000000000000000000000000000000000000;;			if _, err := os.Stat(rules.ExplicitPath); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kubeConfigFiles = append(kubeConfigFiles, rules.ExplicitPath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			kubeConfigFiles = append(kubeConfigFiles, rules.Precedence...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kubeconfigs := []*clientcmdapi.Config{}
0000000000000000000000000000000000000000;;		// read and cache the config files so that we only look at them once
0000000000000000000000000000000000000000;;		for _, filename := range kubeConfigFiles {
0000000000000000000000000000000000000000;;			if len(filename) == 0 {
0000000000000000000000000000000000000000;;				// no work to do
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			config, err := LoadFromFile(filename)
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				// skip missing files
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errlist = append(errlist, fmt.Errorf("Error loading config file \"%s\": %v", filename, err))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			kubeconfigs = append(kubeconfigs, config)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// first merge all of our maps
0000000000000000000000000000000000000000;;		mapConfig := clientcmdapi.NewConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, kubeconfig := range kubeconfigs {
0000000000000000000000000000000000000000;;			mergo.Merge(mapConfig, kubeconfig)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// merge all of the struct values in the reverse order so that priority is given correctly
0000000000000000000000000000000000000000;;		// errors are not added to the list the second time
0000000000000000000000000000000000000000;;		nonMapConfig := clientcmdapi.NewConfig()
0000000000000000000000000000000000000000;;		for i := len(kubeconfigs) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			kubeconfig := kubeconfigs[i]
0000000000000000000000000000000000000000;;			mergo.Merge(nonMapConfig, kubeconfig)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// since values are overwritten, but maps values are not, we can merge the non-map config on top of the map config and
0000000000000000000000000000000000000000;;		// get the values we expect.
0000000000000000000000000000000000000000;;		config := clientcmdapi.NewConfig()
0000000000000000000000000000000000000000;;		mergo.Merge(config, mapConfig)
0000000000000000000000000000000000000000;;		mergo.Merge(config, nonMapConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rules.ResolvePaths() {
0000000000000000000000000000000000000000;;			if err := ResolveLocalPaths(config); err != nil {
0000000000000000000000000000000000000000;;				errlist = append(errlist, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config, utilerrors.NewAggregate(errlist)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Migrate uses the MigrationRules map.  If a destination file is not present, then the source file is checked.
0000000000000000000000000000000000000000;;	// If the source file is present, then it is copied to the destination file BEFORE any further loading happens.
0000000000000000000000000000000000000000;;	func (rules *ClientConfigLoadingRules) Migrate() error {
0000000000000000000000000000000000000000;;		if rules.MigrationRules == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for destination, source := range rules.MigrationRules {
0000000000000000000000000000000000000000;;			if _, err := os.Stat(destination); err == nil {
0000000000000000000000000000000000000000;;				// if the destination already exists, do nothing
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if os.IsPermission(err) {
0000000000000000000000000000000000000000;;				// if we can't access the file, skip it
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				// if we had an error other than non-existence, fail
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if sourceInfo, err := os.Stat(source); err != nil {
0000000000000000000000000000000000000000;;				if os.IsNotExist(err) || os.IsPermission(err) {
0000000000000000000000000000000000000000;;					// if the source file doesn't exist or we can't access it, there's no work to do.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if we had an error other than non-existence, fail
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			} else if sourceInfo.IsDir() {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot migrate %v to %v because it is a directory", source, destination)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			in, err := os.Open(source)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer in.Close()
0000000000000000000000000000000000000000;;			out, err := os.Create(destination)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer out.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err = io.Copy(out, in); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLoadingPrecedence implements ConfigAccess
0000000000000000000000000000000000000000;;	func (rules *ClientConfigLoadingRules) GetLoadingPrecedence() []string {
0000000000000000000000000000000000000000;;		return rules.Precedence
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetStartingConfig implements ConfigAccess
0000000000000000000000000000000000000000;;	func (rules *ClientConfigLoadingRules) GetStartingConfig() (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		clientConfig := NewNonInteractiveDeferredLoadingClientConfig(rules, &ConfigOverrides{})
0000000000000000000000000000000000000000;;		rawConfig, err := clientConfig.RawConfig()
0000000000000000000000000000000000000000;;		if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			return clientcmdapi.NewConfig(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &rawConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDefaultFilename implements ConfigAccess
0000000000000000000000000000000000000000;;	func (rules *ClientConfigLoadingRules) GetDefaultFilename() string {
0000000000000000000000000000000000000000;;		// Explicit file if we have one.
0000000000000000000000000000000000000000;;		if rules.IsExplicitFile() {
0000000000000000000000000000000000000000;;			return rules.GetExplicitFile()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Otherwise, first existing file from precedence.
0000000000000000000000000000000000000000;;		for _, filename := range rules.GetLoadingPrecedence() {
0000000000000000000000000000000000000000;;			if _, err := os.Stat(filename); err == nil {
0000000000000000000000000000000000000000;;				return filename
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If none exists, use the first from precedence.
0000000000000000000000000000000000000000;;		if len(rules.Precedence) > 0 {
0000000000000000000000000000000000000000;;			return rules.Precedence[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsExplicitFile implements ConfigAccess
0000000000000000000000000000000000000000;;	func (rules *ClientConfigLoadingRules) IsExplicitFile() bool {
0000000000000000000000000000000000000000;;		return len(rules.ExplicitPath) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetExplicitFile implements ConfigAccess
0000000000000000000000000000000000000000;;	func (rules *ClientConfigLoadingRules) GetExplicitFile() string {
0000000000000000000000000000000000000000;;		return rules.ExplicitPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDefaultConfig returns true if the provided configuration matches the default
0000000000000000000000000000000000000000;;	func (rules *ClientConfigLoadingRules) IsDefaultConfig(config *restclient.Config) bool {
0000000000000000000000000000000000000000;;		if rules.DefaultClientConfig == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defaultConfig, err := rules.DefaultClientConfig.ClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(config, defaultConfig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadFromFile takes a filename and deserializes the contents into Config object
0000000000000000000000000000000000000000;;	func LoadFromFile(filename string) (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		kubeconfigBytes, err := ioutil.ReadFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		config, err := Load(kubeconfigBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(6).Infoln("Config loaded from file", filename)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set LocationOfOrigin on every Cluster, User, and Context
0000000000000000000000000000000000000000;;		for key, obj := range config.AuthInfos {
0000000000000000000000000000000000000000;;			obj.LocationOfOrigin = filename
0000000000000000000000000000000000000000;;			config.AuthInfos[key] = obj
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key, obj := range config.Clusters {
0000000000000000000000000000000000000000;;			obj.LocationOfOrigin = filename
0000000000000000000000000000000000000000;;			config.Clusters[key] = obj
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key, obj := range config.Contexts {
0000000000000000000000000000000000000000;;			obj.LocationOfOrigin = filename
0000000000000000000000000000000000000000;;			config.Contexts[key] = obj
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.AuthInfos == nil {
0000000000000000000000000000000000000000;;			config.AuthInfos = map[string]*clientcmdapi.AuthInfo{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.Clusters == nil {
0000000000000000000000000000000000000000;;			config.Clusters = map[string]*clientcmdapi.Cluster{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if config.Contexts == nil {
0000000000000000000000000000000000000000;;			config.Contexts = map[string]*clientcmdapi.Context{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return config, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Load takes a byte slice and deserializes the contents into Config object.
0000000000000000000000000000000000000000;;	// Encapsulates deserialization without assuming the source is a file.
0000000000000000000000000000000000000000;;	func Load(data []byte) (*clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		config := clientcmdapi.NewConfig()
0000000000000000000000000000000000000000;;		// if there's no data in a file, return the default object instead of failing (DecodeInto reject empty input)
0000000000000000000000000000000000000000;;		if len(data) == 0 {
0000000000000000000000000000000000000000;;			return config, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decoded, _, err := clientcmdlatest.Codec.Decode(data, &schema.GroupVersionKind{Version: clientcmdlatest.Version, Kind: "Config"}, config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return decoded.(*clientcmdapi.Config), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteToFile serializes the config to yaml and writes it out to a file.  If not present, it creates the file with the mode 0600.  If it is present
0000000000000000000000000000000000000000;;	// it stomps the contents
0000000000000000000000000000000000000000;;	func WriteToFile(config clientcmdapi.Config, filename string) error {
0000000000000000000000000000000000000000;;		content, err := Write(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dir := filepath.Dir(filename)
0000000000000000000000000000000000000000;;		if _, err := os.Stat(dir); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			if err = os.MkdirAll(dir, 0755); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ioutil.WriteFile(filename, content, 0600); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lockFile(filename string) error {
0000000000000000000000000000000000000000;;		// TODO: find a way to do this with actual file locks. Will
0000000000000000000000000000000000000000;;		// probably need seperate solution for windows and linux.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure the dir exists before we try to create a lock file.
0000000000000000000000000000000000000000;;		dir := filepath.Dir(filename)
0000000000000000000000000000000000000000;;		if _, err := os.Stat(dir); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			if err = os.MkdirAll(dir, 0755); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(lockName(filename), os.O_CREATE|os.O_EXCL, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Close()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unlockFile(filename string) error {
0000000000000000000000000000000000000000;;		return os.Remove(lockName(filename))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lockName(filename string) string {
0000000000000000000000000000000000000000;;		return filename + ".lock"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write serializes the config to yaml.
0000000000000000000000000000000000000000;;	// Encapsulates serialization without assuming the destination is a file.
0000000000000000000000000000000000000000;;	func Write(config clientcmdapi.Config) ([]byte, error) {
0000000000000000000000000000000000000000;;		return runtime.Encode(clientcmdlatest.Codec, &config)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rules ClientConfigLoadingRules) ResolvePaths() bool {
0000000000000000000000000000000000000000;;		return !rules.DoNotResolvePaths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolveLocalPaths resolves all relative paths in the config object with respect to the stanza's LocationOfOrigin
0000000000000000000000000000000000000000;;	// this cannot be done directly inside of LoadFromFile because doing so there would make it impossible to load a file without
0000000000000000000000000000000000000000;;	// modification of its contents.
0000000000000000000000000000000000000000;;	func ResolveLocalPaths(config *clientcmdapi.Config) error {
0000000000000000000000000000000000000000;;		for _, cluster := range config.Clusters {
0000000000000000000000000000000000000000;;			if len(cluster.LocationOfOrigin) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			base, err := filepath.Abs(filepath.Dir(cluster.LocationOfOrigin))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Could not determine the absolute path of config file %s: %v", cluster.LocationOfOrigin, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := ResolvePaths(GetClusterFileReferences(cluster), base); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, authInfo := range config.AuthInfos {
0000000000000000000000000000000000000000;;			if len(authInfo.LocationOfOrigin) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			base, err := filepath.Abs(filepath.Dir(authInfo.LocationOfOrigin))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Could not determine the absolute path of config file %s: %v", authInfo.LocationOfOrigin, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := ResolvePaths(GetAuthInfoFileReferences(authInfo), base); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RelativizeClusterLocalPaths first absolutizes the paths by calling ResolveLocalPaths.  This assumes that any NEW path is already
0000000000000000000000000000000000000000;;	// absolute, but any existing path will be resolved relative to LocationOfOrigin
0000000000000000000000000000000000000000;;	func RelativizeClusterLocalPaths(cluster *clientcmdapi.Cluster) error {
0000000000000000000000000000000000000000;;		if len(cluster.LocationOfOrigin) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no location of origin for %s", cluster.Server)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		base, err := filepath.Abs(filepath.Dir(cluster.LocationOfOrigin))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("could not determine the absolute path of config file %s: %v", cluster.LocationOfOrigin, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ResolvePaths(GetClusterFileReferences(cluster), base); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := RelativizePathWithNoBacksteps(GetClusterFileReferences(cluster), base); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RelativizeAuthInfoLocalPaths first absolutizes the paths by calling ResolveLocalPaths.  This assumes that any NEW path is already
0000000000000000000000000000000000000000;;	// absolute, but any existing path will be resolved relative to LocationOfOrigin
0000000000000000000000000000000000000000;;	func RelativizeAuthInfoLocalPaths(authInfo *clientcmdapi.AuthInfo) error {
0000000000000000000000000000000000000000;;		if len(authInfo.LocationOfOrigin) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("no location of origin for %v", authInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		base, err := filepath.Abs(filepath.Dir(authInfo.LocationOfOrigin))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("could not determine the absolute path of config file %s: %v", authInfo.LocationOfOrigin, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ResolvePaths(GetAuthInfoFileReferences(authInfo), base); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := RelativizePathWithNoBacksteps(GetAuthInfoFileReferences(authInfo), base); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RelativizeConfigPaths(config *clientcmdapi.Config, base string) error {
0000000000000000000000000000000000000000;;		return RelativizePathWithNoBacksteps(GetConfigFileReferences(config), base)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ResolveConfigPaths(config *clientcmdapi.Config, base string) error {
0000000000000000000000000000000000000000;;		return ResolvePaths(GetConfigFileReferences(config), base)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetConfigFileReferences(config *clientcmdapi.Config) []*string {
0000000000000000000000000000000000000000;;		refs := []*string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, cluster := range config.Clusters {
0000000000000000000000000000000000000000;;			refs = append(refs, GetClusterFileReferences(cluster)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, authInfo := range config.AuthInfos {
0000000000000000000000000000000000000000;;			refs = append(refs, GetAuthInfoFileReferences(authInfo)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return refs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetClusterFileReferences(cluster *clientcmdapi.Cluster) []*string {
0000000000000000000000000000000000000000;;		return []*string{&cluster.CertificateAuthority}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetAuthInfoFileReferences(authInfo *clientcmdapi.AuthInfo) []*string {
0000000000000000000000000000000000000000;;		return []*string{&authInfo.ClientCertificate, &authInfo.ClientKey, &authInfo.TokenFile}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolvePaths updates the given refs to be absolute paths, relative to the given base directory
0000000000000000000000000000000000000000;;	func ResolvePaths(refs []*string, base string) error {
0000000000000000000000000000000000000000;;		for _, ref := range refs {
0000000000000000000000000000000000000000;;			// Don't resolve empty paths
0000000000000000000000000000000000000000;;			if len(*ref) > 0 {
0000000000000000000000000000000000000000;;				// Don't resolve absolute paths
0000000000000000000000000000000000000000;;				if !filepath.IsAbs(*ref) {
0000000000000000000000000000000000000000;;					*ref = filepath.Join(base, *ref)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RelativizePathWithNoBacksteps updates the given refs to be relative paths, relative to the given base directory as long as they do not require backsteps.
0000000000000000000000000000000000000000;;	// Any path requiring a backstep is left as-is as long it is absolute.  Any non-absolute path that can't be relativized produces an error
0000000000000000000000000000000000000000;;	func RelativizePathWithNoBacksteps(refs []*string, base string) error {
0000000000000000000000000000000000000000;;		for _, ref := range refs {
0000000000000000000000000000000000000000;;			// Don't relativize empty paths
0000000000000000000000000000000000000000;;			if len(*ref) > 0 {
0000000000000000000000000000000000000000;;				rel, err := MakeRelative(*ref, base)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if we have a backstep, don't mess with the path
0000000000000000000000000000000000000000;;				if strings.HasPrefix(rel, "../") {
0000000000000000000000000000000000000000;;					if filepath.IsAbs(*ref) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					return fmt.Errorf("%v requires backsteps and is not absolute", *ref)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				*ref = rel
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakeRelative(path, base string) (string, error) {
0000000000000000000000000000000000000000;;		if len(path) > 0 {
0000000000000000000000000000000000000000;;			rel, err := filepath.Rel(base, path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return path, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return rel, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path, nil
0000000000000000000000000000000000000000;;	}
