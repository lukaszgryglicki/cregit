0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/clientcmd/client_config.go[staging/src/k8s.io/client-go/1.4/tools/clientcmd/client_config.go][staging/src/k8s.io/client-go/tools/clientcmd/client_config.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package clientcmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/imdario/mergo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		clientauth "k8s.io/client-go/tools/auth"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ClusterDefaults has the same behavior as the old EnvVar and DefaultCluster fields
0000000000000000000000000000000000000000;;		// DEPRECATED will be replaced
0000000000000000000000000000000000000000;;		ClusterDefaults = clientcmdapi.Cluster{Server: getDefaultServer()}
0000000000000000000000000000000000000000;;		// DefaultClientConfig represents the legacy behavior of this package for defaulting
0000000000000000000000000000000000000000;;		// DEPRECATED will be replace
0000000000000000000000000000000000000000;;		DefaultClientConfig = DirectClientConfig{*clientcmdapi.NewConfig(), "", &ConfigOverrides{
0000000000000000000000000000000000000000;;			ClusterDefaults: ClusterDefaults,
0000000000000000000000000000000000000000;;		}, nil, NewDefaultClientConfigLoadingRules(), promptedCredentials{}}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDefaultServer returns a default setting for DefaultClientConfig
0000000000000000000000000000000000000000;;	// DEPRECATED
0000000000000000000000000000000000000000;;	func getDefaultServer() string {
0000000000000000000000000000000000000000;;		if server := os.Getenv("KUBERNETES_MASTER"); len(server) > 0 {
0000000000000000000000000000000000000000;;			return server
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "http://localhost:8080"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConfig is used to make it easy to get an api server client
0000000000000000000000000000000000000000;;	type ClientConfig interface {
0000000000000000000000000000000000000000;;		// RawConfig returns the merged result of all overrides
0000000000000000000000000000000000000000;;		RawConfig() (clientcmdapi.Config, error)
0000000000000000000000000000000000000000;;		// ClientConfig returns a complete client config
0000000000000000000000000000000000000000;;		ClientConfig() (*restclient.Config, error)
0000000000000000000000000000000000000000;;		// Namespace returns the namespace resulting from the merged
0000000000000000000000000000000000000000;;		// result of all overrides and a boolean indicating if it was
0000000000000000000000000000000000000000;;		// overridden
0000000000000000000000000000000000000000;;		Namespace() (string, bool, error)
0000000000000000000000000000000000000000;;		// ConfigAccess returns the rules for loading/persisting the config.
0000000000000000000000000000000000000000;;		ConfigAccess() ConfigAccess
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PersistAuthProviderConfigForUser func(user string) restclient.AuthProviderConfigPersister
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type promptedCredentials struct {
0000000000000000000000000000000000000000;;		username string
0000000000000000000000000000000000000000;;		password string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DirectClientConfig is a ClientConfig interface that is backed by a clientcmdapi.Config, options overrides, and an optional fallbackReader for auth information
0000000000000000000000000000000000000000;;	type DirectClientConfig struct {
0000000000000000000000000000000000000000;;		config         clientcmdapi.Config
0000000000000000000000000000000000000000;;		contextName    string
0000000000000000000000000000000000000000;;		overrides      *ConfigOverrides
0000000000000000000000000000000000000000;;		fallbackReader io.Reader
0000000000000000000000000000000000000000;;		configAccess   ConfigAccess
0000000000000000000000000000000000000000;;		// promptedCredentials store the credentials input by the user
0000000000000000000000000000000000000000;;		promptedCredentials promptedCredentials
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultClientConfig creates a DirectClientConfig using the config.CurrentContext as the context name
0000000000000000000000000000000000000000;;	func NewDefaultClientConfig(config clientcmdapi.Config, overrides *ConfigOverrides) ClientConfig {
0000000000000000000000000000000000000000;;		return &DirectClientConfig{config, config.CurrentContext, overrides, nil, NewDefaultClientConfigLoadingRules(), promptedCredentials{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNonInteractiveClientConfig creates a DirectClientConfig using the passed context name and does not have a fallback reader for auth information
0000000000000000000000000000000000000000;;	func NewNonInteractiveClientConfig(config clientcmdapi.Config, contextName string, overrides *ConfigOverrides, configAccess ConfigAccess) ClientConfig {
0000000000000000000000000000000000000000;;		return &DirectClientConfig{config, contextName, overrides, nil, configAccess, promptedCredentials{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInteractiveClientConfig creates a DirectClientConfig using the passed context name and a reader in case auth information is not provided via files or flags
0000000000000000000000000000000000000000;;	func NewInteractiveClientConfig(config clientcmdapi.Config, contextName string, overrides *ConfigOverrides, fallbackReader io.Reader, configAccess ConfigAccess) ClientConfig {
0000000000000000000000000000000000000000;;		return &DirectClientConfig{config, contextName, overrides, fallbackReader, configAccess, promptedCredentials{}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) RawConfig() (clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		return config.config, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConfig implements ClientConfig
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) ClientConfig() (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		// check that getAuthInfo, getContext, and getCluster do not return an error.
0000000000000000000000000000000000000000;;		// Do this before checking if the curent config is usable in the event that an
0000000000000000000000000000000000000000;;		// AuthInfo, Context, or Cluster config with user-defined names are not found.
0000000000000000000000000000000000000000;;		// This provides a user with the immediate cause for error if one is found
0000000000000000000000000000000000000000;;		configAuthInfo, err := config.getAuthInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = config.getContext()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configClusterInfo, err := config.getCluster()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := config.ConfirmUsable(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig := &restclient.Config{}
0000000000000000000000000000000000000000;;		clientConfig.Host = configClusterInfo.Server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(config.overrides.Timeout) > 0 {
0000000000000000000000000000000000000000;;			timeout, err := ParseTimeout(config.overrides.Timeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			clientConfig.Timeout = timeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u, err := url.ParseRequestURI(clientConfig.Host); err == nil && u.Opaque == "" && len(u.Path) > 1 {
0000000000000000000000000000000000000000;;			u.RawQuery = ""
0000000000000000000000000000000000000000;;			u.Fragment = ""
0000000000000000000000000000000000000000;;			clientConfig.Host = u.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(configAuthInfo.Impersonate) > 0 {
0000000000000000000000000000000000000000;;			clientConfig.Impersonate = restclient.ImpersonationConfig{
0000000000000000000000000000000000000000;;				UserName: configAuthInfo.Impersonate,
0000000000000000000000000000000000000000;;				Groups:   configAuthInfo.ImpersonateGroups,
0000000000000000000000000000000000000000;;				Extra:    configAuthInfo.ImpersonateUserExtra,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only try to read the auth information if we are secure
0000000000000000000000000000000000000000;;		if restclient.IsConfigTransportTLS(*clientConfig) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// mergo is a first write wins for map value and a last writing wins for interface values
0000000000000000000000000000000000000000;;			// NOTE: This behavior changed with https://github.com/imdario/mergo/commit/d304790b2ed594794496464fadd89d2bb266600a.
0000000000000000000000000000000000000000;;			//       Our mergo.Merge version is older than this change.
0000000000000000000000000000000000000000;;			var persister restclient.AuthProviderConfigPersister
0000000000000000000000000000000000000000;;			if config.configAccess != nil {
0000000000000000000000000000000000000000;;				authInfoName, _ := config.getAuthInfoName()
0000000000000000000000000000000000000000;;				persister = PersisterForUser(config.configAccess, authInfoName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			userAuthPartialConfig, err := config.getUserIdentificationPartialConfig(configAuthInfo, config.fallbackReader, persister)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mergo.Merge(clientConfig, userAuthPartialConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serverAuthPartialConfig, err := getServerIdentificationPartialConfig(configAuthInfo, configClusterInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mergo.Merge(clientConfig, serverAuthPartialConfig)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clientConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientauth.Info object contain both user identification and server identification.  We want different precedence orders for
0000000000000000000000000000000000000000;;	// both, so we have to split the objects and merge them separately
0000000000000000000000000000000000000000;;	// we want this order of precedence for the server identification
0000000000000000000000000000000000000000;;	// 1.  configClusterInfo (the final result of command line flags and merged .kubeconfig files)
0000000000000000000000000000000000000000;;	// 2.  configAuthInfo.auth-path (this file can contain information that conflicts with #1, and we want #1 to win the priority)
0000000000000000000000000000000000000000;;	// 3.  load the ~/.kubernetes_auth file as a default
0000000000000000000000000000000000000000;;	func getServerIdentificationPartialConfig(configAuthInfo clientcmdapi.AuthInfo, configClusterInfo clientcmdapi.Cluster) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		mergedConfig := &restclient.Config{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// configClusterInfo holds the information identify the server provided by .kubeconfig
0000000000000000000000000000000000000000;;		configClientConfig := &restclient.Config{}
0000000000000000000000000000000000000000;;		configClientConfig.CAFile = configClusterInfo.CertificateAuthority
0000000000000000000000000000000000000000;;		configClientConfig.CAData = configClusterInfo.CertificateAuthorityData
0000000000000000000000000000000000000000;;		configClientConfig.Insecure = configClusterInfo.InsecureSkipTLSVerify
0000000000000000000000000000000000000000;;		mergo.Merge(mergedConfig, configClientConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mergedConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientauth.Info object contain both user identification and server identification.  We want different precedence orders for
0000000000000000000000000000000000000000;;	// both, so we have to split the objects and merge them separately
0000000000000000000000000000000000000000;;	// we want this order of precedence for user identifcation
0000000000000000000000000000000000000000;;	// 1.  configAuthInfo minus auth-path (the final result of command line flags and merged .kubeconfig files)
0000000000000000000000000000000000000000;;	// 2.  configAuthInfo.auth-path (this file can contain information that conflicts with #1, and we want #1 to win the priority)
0000000000000000000000000000000000000000;;	// 3.  if there is not enough information to identify the user, load try the ~/.kubernetes_auth file
0000000000000000000000000000000000000000;;	// 4.  if there is not enough information to identify the user, prompt if possible
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) getUserIdentificationPartialConfig(configAuthInfo clientcmdapi.AuthInfo, fallbackReader io.Reader, persistAuthConfig restclient.AuthProviderConfigPersister) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		mergedConfig := &restclient.Config{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// blindly overwrite existing values based on precedence
0000000000000000000000000000000000000000;;		if len(configAuthInfo.Token) > 0 {
0000000000000000000000000000000000000000;;			mergedConfig.BearerToken = configAuthInfo.Token
0000000000000000000000000000000000000000;;		} else if len(configAuthInfo.TokenFile) > 0 {
0000000000000000000000000000000000000000;;			tokenBytes, err := ioutil.ReadFile(configAuthInfo.TokenFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mergedConfig.BearerToken = string(tokenBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(configAuthInfo.Impersonate) > 0 {
0000000000000000000000000000000000000000;;			mergedConfig.Impersonate = restclient.ImpersonationConfig{
0000000000000000000000000000000000000000;;				UserName: configAuthInfo.Impersonate,
0000000000000000000000000000000000000000;;				Groups:   configAuthInfo.ImpersonateGroups,
0000000000000000000000000000000000000000;;				Extra:    configAuthInfo.ImpersonateUserExtra,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(configAuthInfo.ClientCertificate) > 0 || len(configAuthInfo.ClientCertificateData) > 0 {
0000000000000000000000000000000000000000;;			mergedConfig.CertFile = configAuthInfo.ClientCertificate
0000000000000000000000000000000000000000;;			mergedConfig.CertData = configAuthInfo.ClientCertificateData
0000000000000000000000000000000000000000;;			mergedConfig.KeyFile = configAuthInfo.ClientKey
0000000000000000000000000000000000000000;;			mergedConfig.KeyData = configAuthInfo.ClientKeyData
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(configAuthInfo.Username) > 0 || len(configAuthInfo.Password) > 0 {
0000000000000000000000000000000000000000;;			mergedConfig.Username = configAuthInfo.Username
0000000000000000000000000000000000000000;;			mergedConfig.Password = configAuthInfo.Password
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if configAuthInfo.AuthProvider != nil {
0000000000000000000000000000000000000000;;			mergedConfig.AuthProvider = configAuthInfo.AuthProvider
0000000000000000000000000000000000000000;;			mergedConfig.AuthConfigPersister = persistAuthConfig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if there still isn't enough information to authenticate the user, try prompting
0000000000000000000000000000000000000000;;		if !canIdentifyUser(*mergedConfig) && (fallbackReader != nil) {
0000000000000000000000000000000000000000;;			if len(config.promptedCredentials.username) > 0 && len(config.promptedCredentials.password) > 0 {
0000000000000000000000000000000000000000;;				mergedConfig.Username = config.promptedCredentials.username
0000000000000000000000000000000000000000;;				mergedConfig.Password = config.promptedCredentials.password
0000000000000000000000000000000000000000;;				return mergedConfig, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prompter := NewPromptingAuthLoader(fallbackReader)
0000000000000000000000000000000000000000;;			promptedAuthInfo, err := prompter.Prompt()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			promptedConfig := makeUserIdentificationConfig(*promptedAuthInfo)
0000000000000000000000000000000000000000;;			previouslyMergedConfig := mergedConfig
0000000000000000000000000000000000000000;;			mergedConfig = &restclient.Config{}
0000000000000000000000000000000000000000;;			mergo.Merge(mergedConfig, promptedConfig)
0000000000000000000000000000000000000000;;			mergo.Merge(mergedConfig, previouslyMergedConfig)
0000000000000000000000000000000000000000;;			config.promptedCredentials.username = mergedConfig.Username
0000000000000000000000000000000000000000;;			config.promptedCredentials.password = mergedConfig.Password
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mergedConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeUserIdentificationFieldsConfig returns a client.Config capable of being merged using mergo for only user identification information
0000000000000000000000000000000000000000;;	func makeUserIdentificationConfig(info clientauth.Info) *restclient.Config {
0000000000000000000000000000000000000000;;		config := &restclient.Config{}
0000000000000000000000000000000000000000;;		config.Username = info.User
0000000000000000000000000000000000000000;;		config.Password = info.Password
0000000000000000000000000000000000000000;;		config.CertFile = info.CertFile
0000000000000000000000000000000000000000;;		config.KeyFile = info.KeyFile
0000000000000000000000000000000000000000;;		config.BearerToken = info.BearerToken
0000000000000000000000000000000000000000;;		return config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeUserIdentificationFieldsConfig returns a client.Config capable of being merged using mergo for only server identification information
0000000000000000000000000000000000000000;;	func makeServerIdentificationConfig(info clientauth.Info) restclient.Config {
0000000000000000000000000000000000000000;;		config := restclient.Config{}
0000000000000000000000000000000000000000;;		config.CAFile = info.CAFile
0000000000000000000000000000000000000000;;		if info.Insecure != nil {
0000000000000000000000000000000000000000;;			config.Insecure = *info.Insecure
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return config
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func canIdentifyUser(config restclient.Config) bool {
0000000000000000000000000000000000000000;;		return len(config.Username) > 0 ||
0000000000000000000000000000000000000000;;			(len(config.CertFile) > 0 || len(config.CertData) > 0) ||
0000000000000000000000000000000000000000;;			len(config.BearerToken) > 0 ||
0000000000000000000000000000000000000000;;			config.AuthProvider != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Namespace implements ClientConfig
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) Namespace() (string, bool, error) {
0000000000000000000000000000000000000000;;		if config.overrides != nil && config.overrides.Context.Namespace != "" {
0000000000000000000000000000000000000000;;			// In the event we have an empty config but we do have a namespace override, we should return
0000000000000000000000000000000000000000;;			// the namespace override instead of having config.ConfirmUsable() return an error. This allows
0000000000000000000000000000000000000000;;			// things like in-cluster clients to execute `kubectl get pods --namespace=foo` and have the
0000000000000000000000000000000000000000;;			// --namespace flag honored instead of being ignored.
0000000000000000000000000000000000000000;;			return config.overrides.Context.Namespace, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := config.ConfirmUsable(); err != nil {
0000000000000000000000000000000000000000;;			return "", false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configContext, err := config.getContext()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(configContext.Namespace) == 0 {
0000000000000000000000000000000000000000;;			return v1.NamespaceDefault, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return configContext.Namespace, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigAccess implements ClientConfig
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) ConfigAccess() ConfigAccess {
0000000000000000000000000000000000000000;;		return config.configAccess
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfirmUsable looks a particular context and determines if that particular part of the config is useable.  There might still be errors in the config,
0000000000000000000000000000000000000000;;	// but no errors in the sections requested or referenced.  It does not return early so that it can find as many errors as possible.
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) ConfirmUsable() error {
0000000000000000000000000000000000000000;;		validationErrors := make([]error, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var contextName string
0000000000000000000000000000000000000000;;		if len(config.contextName) != 0 {
0000000000000000000000000000000000000000;;			contextName = config.contextName
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			contextName = config.config.CurrentContext
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(contextName) > 0 {
0000000000000000000000000000000000000000;;			_, exists := config.config.Contexts[contextName]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				validationErrors = append(validationErrors, &errContextNotFound{contextName})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authInfoName, _ := config.getAuthInfoName()
0000000000000000000000000000000000000000;;		authInfo, _ := config.getAuthInfo()
0000000000000000000000000000000000000000;;		validationErrors = append(validationErrors, validateAuthInfo(authInfoName, authInfo)...)
0000000000000000000000000000000000000000;;		clusterName, _ := config.getClusterName()
0000000000000000000000000000000000000000;;		cluster, _ := config.getCluster()
0000000000000000000000000000000000000000;;		validationErrors = append(validationErrors, validateClusterInfo(clusterName, cluster)...)
0000000000000000000000000000000000000000;;		// when direct client config is specified, and our only error is that no server is defined, we should
0000000000000000000000000000000000000000;;		// return a standard "no config" error
0000000000000000000000000000000000000000;;		if len(validationErrors) == 1 && validationErrors[0] == ErrEmptyCluster {
0000000000000000000000000000000000000000;;			return newErrConfigurationInvalid([]error{ErrEmptyConfig})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newErrConfigurationInvalid(validationErrors)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getContextName returns the default, or user-set context name, and a boolean that indicates
0000000000000000000000000000000000000000;;	// whether the default context name has been overwritten by a user-set flag, or left as its default value
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) getContextName() (string, bool) {
0000000000000000000000000000000000000000;;		if len(config.overrides.CurrentContext) != 0 {
0000000000000000000000000000000000000000;;			return config.overrides.CurrentContext, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.contextName) != 0 {
0000000000000000000000000000000000000000;;			return config.contextName, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return config.config.CurrentContext, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getAuthInfoName returns a string containing the current authinfo name for the current context,
0000000000000000000000000000000000000000;;	// and a boolean indicating  whether the default authInfo name is overwritten by a user-set flag, or
0000000000000000000000000000000000000000;;	// left as its default value
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) getAuthInfoName() (string, bool) {
0000000000000000000000000000000000000000;;		if len(config.overrides.Context.AuthInfo) != 0 {
0000000000000000000000000000000000000000;;			return config.overrides.Context.AuthInfo, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		context, _ := config.getContext()
0000000000000000000000000000000000000000;;		return context.AuthInfo, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getClusterName returns a string containing the default, or user-set cluster name, and a boolean
0000000000000000000000000000000000000000;;	// indicating whether the default clusterName has been overwritten by a user-set flag, or left as
0000000000000000000000000000000000000000;;	// its default value
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) getClusterName() (string, bool) {
0000000000000000000000000000000000000000;;		if len(config.overrides.Context.Cluster) != 0 {
0000000000000000000000000000000000000000;;			return config.overrides.Context.Cluster, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		context, _ := config.getContext()
0000000000000000000000000000000000000000;;		return context.Cluster, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getContext returns the clientcmdapi.Context, or an error if a required context is not found.
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) getContext() (clientcmdapi.Context, error) {
0000000000000000000000000000000000000000;;		contexts := config.config.Contexts
0000000000000000000000000000000000000000;;		contextName, required := config.getContextName()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mergedContext := clientcmdapi.NewContext()
0000000000000000000000000000000000000000;;		if configContext, exists := contexts[contextName]; exists {
0000000000000000000000000000000000000000;;			mergo.Merge(mergedContext, configContext)
0000000000000000000000000000000000000000;;		} else if required {
0000000000000000000000000000000000000000;;			return clientcmdapi.Context{}, fmt.Errorf("context %q does not exist", contextName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mergo.Merge(mergedContext, config.overrides.Context)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return *mergedContext, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getAuthInfo returns the clientcmdapi.AuthInfo, or an error if a required auth info is not found.
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) getAuthInfo() (clientcmdapi.AuthInfo, error) {
0000000000000000000000000000000000000000;;		authInfos := config.config.AuthInfos
0000000000000000000000000000000000000000;;		authInfoName, required := config.getAuthInfoName()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mergedAuthInfo := clientcmdapi.NewAuthInfo()
0000000000000000000000000000000000000000;;		if configAuthInfo, exists := authInfos[authInfoName]; exists {
0000000000000000000000000000000000000000;;			mergo.Merge(mergedAuthInfo, configAuthInfo)
0000000000000000000000000000000000000000;;		} else if required {
0000000000000000000000000000000000000000;;			return clientcmdapi.AuthInfo{}, fmt.Errorf("auth info %q does not exist", authInfoName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mergo.Merge(mergedAuthInfo, config.overrides.AuthInfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return *mergedAuthInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getCluster returns the clientcmdapi.Cluster, or an error if a required cluster is not found.
0000000000000000000000000000000000000000;;	func (config *DirectClientConfig) getCluster() (clientcmdapi.Cluster, error) {
0000000000000000000000000000000000000000;;		clusterInfos := config.config.Clusters
0000000000000000000000000000000000000000;;		clusterInfoName, required := config.getClusterName()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mergedClusterInfo := clientcmdapi.NewCluster()
0000000000000000000000000000000000000000;;		mergo.Merge(mergedClusterInfo, config.overrides.ClusterDefaults)
0000000000000000000000000000000000000000;;		if configClusterInfo, exists := clusterInfos[clusterInfoName]; exists {
0000000000000000000000000000000000000000;;			mergo.Merge(mergedClusterInfo, configClusterInfo)
0000000000000000000000000000000000000000;;		} else if required {
0000000000000000000000000000000000000000;;			return clientcmdapi.Cluster{}, fmt.Errorf("cluster %q does not exist", clusterInfoName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mergo.Merge(mergedClusterInfo, config.overrides.ClusterInfo)
0000000000000000000000000000000000000000;;		// An override of --insecure-skip-tls-verify=true and no accompanying CA/CA data should clear already-set CA/CA data
0000000000000000000000000000000000000000;;		// otherwise, a kubeconfig containing a CA reference would return an error that "CA and insecure-skip-tls-verify couldn't both be set"
0000000000000000000000000000000000000000;;		caLen := len(config.overrides.ClusterInfo.CertificateAuthority)
0000000000000000000000000000000000000000;;		caDataLen := len(config.overrides.ClusterInfo.CertificateAuthorityData)
0000000000000000000000000000000000000000;;		if config.overrides.ClusterInfo.InsecureSkipTLSVerify && caLen == 0 && caDataLen == 0 {
0000000000000000000000000000000000000000;;			mergedClusterInfo.CertificateAuthority = ""
0000000000000000000000000000000000000000;;			mergedClusterInfo.CertificateAuthorityData = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return *mergedClusterInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// inClusterClientConfig makes a config that will work from within a kubernetes cluster container environment.
0000000000000000000000000000000000000000;;	// Can take options overrides for flags explicitly provided to the command inside the cluster container.
0000000000000000000000000000000000000000;;	type inClusterClientConfig struct {
0000000000000000000000000000000000000000;;		overrides               *ConfigOverrides
0000000000000000000000000000000000000000;;		inClusterConfigProvider func() (*restclient.Config, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ ClientConfig = &inClusterClientConfig{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *inClusterClientConfig) RawConfig() (clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		return clientcmdapi.Config{}, fmt.Errorf("inCluster environment config doesn't support multiple clusters")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *inClusterClientConfig) ClientConfig() (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		if config.inClusterConfigProvider == nil {
0000000000000000000000000000000000000000;;			config.inClusterConfigProvider = restclient.InClusterConfig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		icc, err := config.inClusterConfigProvider()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// in-cluster configs only takes a host, token, or CA file
0000000000000000000000000000000000000000;;		// if any of them were individually provided, ovewrite anything else
0000000000000000000000000000000000000000;;		if config.overrides != nil {
0000000000000000000000000000000000000000;;			if server := config.overrides.ClusterInfo.Server; len(server) > 0 {
0000000000000000000000000000000000000000;;				icc.Host = server
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if token := config.overrides.AuthInfo.Token; len(token) > 0 {
0000000000000000000000000000000000000000;;				icc.BearerToken = token
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if certificateAuthorityFile := config.overrides.ClusterInfo.CertificateAuthority; len(certificateAuthorityFile) > 0 {
0000000000000000000000000000000000000000;;				icc.TLSClientConfig.CAFile = certificateAuthorityFile
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return icc, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *inClusterClientConfig) Namespace() (string, bool, error) {
0000000000000000000000000000000000000000;;		// This way assumes you've set the POD_NAMESPACE environment variable using the downward API.
0000000000000000000000000000000000000000;;		// This check has to be done first for backwards compatibility with the way InClusterConfig was originally set up
0000000000000000000000000000000000000000;;		if ns := os.Getenv("POD_NAMESPACE"); ns != "" {
0000000000000000000000000000000000000000;;			return ns, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fall back to the namespace associated with the service account token, if available
0000000000000000000000000000000000000000;;		if data, err := ioutil.ReadFile("/var/run/secrets/kubernetes.io/serviceaccount/namespace"); err == nil {
0000000000000000000000000000000000000000;;			if ns := strings.TrimSpace(string(data)); len(ns) > 0 {
0000000000000000000000000000000000000000;;				return ns, false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "default", false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *inClusterClientConfig) ConfigAccess() ConfigAccess {
0000000000000000000000000000000000000000;;		return NewDefaultClientConfigLoadingRules()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Possible returns true if loading an inside-kubernetes-cluster is possible.
0000000000000000000000000000000000000000;;	func (config *inClusterClientConfig) Possible() bool {
0000000000000000000000000000000000000000;;		fi, err := os.Stat("/var/run/secrets/kubernetes.io/serviceaccount/token")
0000000000000000000000000000000000000000;;		return os.Getenv("KUBERNETES_SERVICE_HOST") != "" &&
0000000000000000000000000000000000000000;;			os.Getenv("KUBERNETES_SERVICE_PORT") != "" &&
0000000000000000000000000000000000000000;;			err == nil && !fi.IsDir()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildConfigFromFlags is a helper function that builds configs from a master
0000000000000000000000000000000000000000;;	// url or a kubeconfig filepath. These are passed in as command line flags for cluster
0000000000000000000000000000000000000000;;	// components. Warnings should reflect this usage. If neither masterUrl or kubeconfigPath
0000000000000000000000000000000000000000;;	// are passed in we fallback to inClusterConfig. If inClusterConfig fails, we fallback
0000000000000000000000000000000000000000;;	// to the default config.
0000000000000000000000000000000000000000;;	func BuildConfigFromFlags(masterUrl, kubeconfigPath string) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		if kubeconfigPath == "" && masterUrl == "" {
0000000000000000000000000000000000000000;;			glog.Warningf("Neither --kubeconfig nor --master was specified.  Using the inClusterConfig.  This might not work.")
0000000000000000000000000000000000000000;;			kubeconfig, err := restclient.InClusterConfig()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return kubeconfig, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.Warning("error creating inClusterConfig, falling back to default config: ", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return NewNonInteractiveDeferredLoadingClientConfig(
0000000000000000000000000000000000000000;;			&ClientConfigLoadingRules{ExplicitPath: kubeconfigPath},
0000000000000000000000000000000000000000;;			&ConfigOverrides{ClusterInfo: clientcmdapi.Cluster{Server: masterUrl}}).ClientConfig()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildConfigFromKubeconfigGetter is a helper function that builds configs from a master
0000000000000000000000000000000000000000;;	// url and a kubeconfigGetter.
0000000000000000000000000000000000000000;;	func BuildConfigFromKubeconfigGetter(masterUrl string, kubeconfigGetter KubeconfigGetter) (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		// TODO: We do not need a DeferredLoader here. Refactor code and see if we can use DirectClientConfig here.
0000000000000000000000000000000000000000;;		cc := NewNonInteractiveDeferredLoadingClientConfig(
0000000000000000000000000000000000000000;;			&ClientConfigGetter{kubeconfigGetter: kubeconfigGetter},
0000000000000000000000000000000000000000;;			&ConfigOverrides{ClusterInfo: clientcmdapi.Cluster{Server: masterUrl}})
0000000000000000000000000000000000000000;;		return cc.ClientConfig()
0000000000000000000000000000000000000000;;	}
