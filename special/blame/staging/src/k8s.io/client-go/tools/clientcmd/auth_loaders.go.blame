0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/clientcmd/auth_loaders.go[staging/src/k8s.io/client-go/1.4/tools/clientcmd/auth_loaders.go][staging/src/k8s.io/client-go/tools/clientcmd/auth_loaders.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package clientcmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/howeyc/gopass"
0000000000000000000000000000000000000000;;		clientauth "k8s.io/client-go/tools/auth"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthLoaders are used to build clientauth.Info objects.
0000000000000000000000000000000000000000;;	type AuthLoader interface {
0000000000000000000000000000000000000000;;		// LoadAuth takes a path to a config file and can then do anything it needs in order to return a valid clientauth.Info
0000000000000000000000000000000000000000;;		LoadAuth(path string) (*clientauth.Info, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// default implementation of an AuthLoader
0000000000000000000000000000000000000000;;	type defaultAuthLoader struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadAuth for defaultAuthLoader simply delegates to clientauth.LoadFromFile
0000000000000000000000000000000000000000;;	func (*defaultAuthLoader) LoadAuth(path string) (*clientauth.Info, error) {
0000000000000000000000000000000000000000;;		return clientauth.LoadFromFile(path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PromptingAuthLoader struct {
0000000000000000000000000000000000000000;;		reader io.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadAuth parses an AuthInfo object from a file path. It prompts user and creates file if it doesn't exist.
0000000000000000000000000000000000000000;;	func (a *PromptingAuthLoader) LoadAuth(path string) (*clientauth.Info, error) {
0000000000000000000000000000000000000000;;		// Prompt for user/pass and write a file if none exists.
0000000000000000000000000000000000000000;;		if _, err := os.Stat(path); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			authPtr, err := a.Prompt()
0000000000000000000000000000000000000000;;			auth := *authPtr
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data, err := json.Marshal(auth)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return &auth, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = ioutil.WriteFile(path, data, 0600)
0000000000000000000000000000000000000000;;			return &auth, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		authPtr, err := clientauth.LoadFromFile(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return authPtr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prompt pulls the user and password from a reader
0000000000000000000000000000000000000000;;	func (a *PromptingAuthLoader) Prompt() (*clientauth.Info, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		auth := &clientauth.Info{}
0000000000000000000000000000000000000000;;		auth.User, err = promptForString("Username", a.reader, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		auth.Password, err = promptForString("Password", nil, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return auth, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func promptForString(field string, r io.Reader, show bool) (result string, err error) {
0000000000000000000000000000000000000000;;		fmt.Printf("Please enter %s: ", field)
0000000000000000000000000000000000000000;;		if show {
0000000000000000000000000000000000000000;;			_, err = fmt.Fscan(r, &result)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var data []byte
0000000000000000000000000000000000000000;;			data, err = gopass.GetPasswdMasked()
0000000000000000000000000000000000000000;;			result = string(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPromptingAuthLoader is an AuthLoader that parses an AuthInfo object from a file path. It prompts user and creates file if it doesn't exist.
0000000000000000000000000000000000000000;;	func NewPromptingAuthLoader(reader io.Reader) *PromptingAuthLoader {
0000000000000000000000000000000000000000;;		return &PromptingAuthLoader{reader}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDefaultAuthLoader returns a default implementation of an AuthLoader that only reads from a config file
0000000000000000000000000000000000000000;;	func NewDefaultAuthLoader() AuthLoader {
0000000000000000000000000000000000000000;;		return &defaultAuthLoader{}
0000000000000000000000000000000000000000;;	}
