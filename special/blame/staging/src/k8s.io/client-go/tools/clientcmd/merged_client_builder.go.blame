0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/clientcmd/merged_client_builder.go[staging/src/k8s.io/client-go/1.4/tools/clientcmd/merged_client_builder.go][staging/src/k8s.io/client-go/tools/clientcmd/merged_client_builder.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package clientcmd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		clientcmdapi "k8s.io/client-go/tools/clientcmd/api"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeferredLoadingClientConfig is a ClientConfig interface that is backed by a client config loader.
0000000000000000000000000000000000000000;;	// It is used in cases where the loading rules may change after you've instantiated them and you want to be sure that
0000000000000000000000000000000000000000;;	// the most recent rules are used.  This is useful in cases where you bind flags to loading rule parameters before
0000000000000000000000000000000000000000;;	// the parse happens and you want your calling code to be ignorant of how the values are being mutated to avoid
0000000000000000000000000000000000000000;;	// passing extraneous information down a call stack
0000000000000000000000000000000000000000;;	type DeferredLoadingClientConfig struct {
0000000000000000000000000000000000000000;;		loader         ClientConfigLoader
0000000000000000000000000000000000000000;;		overrides      *ConfigOverrides
0000000000000000000000000000000000000000;;		fallbackReader io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig ClientConfig
0000000000000000000000000000000000000000;;		loadingLock  sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// provided for testing
0000000000000000000000000000000000000000;;		icc InClusterConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InClusterConfig abstracts details of whether the client is running in a cluster for testing.
0000000000000000000000000000000000000000;;	type InClusterConfig interface {
0000000000000000000000000000000000000000;;		ClientConfig
0000000000000000000000000000000000000000;;		Possible() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNonInteractiveDeferredLoadingClientConfig creates a ConfigClientClientConfig using the passed context name
0000000000000000000000000000000000000000;;	func NewNonInteractiveDeferredLoadingClientConfig(loader ClientConfigLoader, overrides *ConfigOverrides) ClientConfig {
0000000000000000000000000000000000000000;;		return &DeferredLoadingClientConfig{loader: loader, overrides: overrides, icc: &inClusterClientConfig{overrides: overrides}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewInteractiveDeferredLoadingClientConfig creates a ConfigClientClientConfig using the passed context name and the fallback auth reader
0000000000000000000000000000000000000000;;	func NewInteractiveDeferredLoadingClientConfig(loader ClientConfigLoader, overrides *ConfigOverrides, fallbackReader io.Reader) ClientConfig {
0000000000000000000000000000000000000000;;		return &DeferredLoadingClientConfig{loader: loader, overrides: overrides, icc: &inClusterClientConfig{overrides: overrides}, fallbackReader: fallbackReader}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *DeferredLoadingClientConfig) createClientConfig() (ClientConfig, error) {
0000000000000000000000000000000000000000;;		if config.clientConfig == nil {
0000000000000000000000000000000000000000;;			config.loadingLock.Lock()
0000000000000000000000000000000000000000;;			defer config.loadingLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if config.clientConfig == nil {
0000000000000000000000000000000000000000;;				mergedConfig, err := config.loader.Load()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var mergedClientConfig ClientConfig
0000000000000000000000000000000000000000;;				if config.fallbackReader != nil {
0000000000000000000000000000000000000000;;					mergedClientConfig = NewInteractiveClientConfig(*mergedConfig, config.overrides.CurrentContext, config.overrides, config.fallbackReader, config.loader)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					mergedClientConfig = NewNonInteractiveClientConfig(*mergedConfig, config.overrides.CurrentContext, config.overrides, config.loader)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				config.clientConfig = mergedClientConfig
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return config.clientConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (config *DeferredLoadingClientConfig) RawConfig() (clientcmdapi.Config, error) {
0000000000000000000000000000000000000000;;		mergedConfig, err := config.createClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return clientcmdapi.Config{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mergedConfig.RawConfig()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConfig implements ClientConfig
0000000000000000000000000000000000000000;;	func (config *DeferredLoadingClientConfig) ClientConfig() (*restclient.Config, error) {
0000000000000000000000000000000000000000;;		mergedClientConfig, err := config.createClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// load the configuration and return on non-empty errors and if the
0000000000000000000000000000000000000000;;		// content differs from the default config
0000000000000000000000000000000000000000;;		mergedConfig, err := mergedClientConfig.ClientConfig()
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			if !IsEmptyConfig(err) {
0000000000000000000000000000000000000000;;				// return on any error except empty config
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case mergedConfig != nil:
0000000000000000000000000000000000000000;;			// the configuration is valid, but if this is equal to the defaults we should try
0000000000000000000000000000000000000000;;			// in-cluster configuration
0000000000000000000000000000000000000000;;			if !config.loader.IsDefaultConfig(mergedConfig) {
0000000000000000000000000000000000000000;;				return mergedConfig, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for in-cluster configuration and use it
0000000000000000000000000000000000000000;;		if config.icc.Possible() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Using in-cluster configuration")
0000000000000000000000000000000000000000;;			return config.icc.ClientConfig()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// return the result of the merged client config
0000000000000000000000000000000000000000;;		return mergedConfig, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Namespace implements KubeConfig
0000000000000000000000000000000000000000;;	func (config *DeferredLoadingClientConfig) Namespace() (string, bool, error) {
0000000000000000000000000000000000000000;;		mergedKubeConfig, err := config.createClientConfig()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ns, overridden, err := mergedKubeConfig.Namespace()
0000000000000000000000000000000000000000;;		// if we get an error and it is not empty config, or if the merged config defined an explicit namespace, or
0000000000000000000000000000000000000000;;		// if in-cluster config is not possible, return immediately
0000000000000000000000000000000000000000;;		if (err != nil && !IsEmptyConfig(err)) || overridden || !config.icc.Possible() {
0000000000000000000000000000000000000000;;			// return on any error except empty config
0000000000000000000000000000000000000000;;			return ns, overridden, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ns) > 0 {
0000000000000000000000000000000000000000;;			// if we got a non-default namespace from the kubeconfig, use it
0000000000000000000000000000000000000000;;			if ns != v1.NamespaceDefault {
0000000000000000000000000000000000000000;;				return ns, false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if we got a default namespace, determine whether it was explicit or implicit
0000000000000000000000000000000000000000;;			if raw, err := mergedKubeConfig.RawConfig(); err == nil {
0000000000000000000000000000000000000000;;				if context := raw.Contexts[raw.CurrentContext]; context != nil && len(context.Namespace) > 0 {
0000000000000000000000000000000000000000;;					return ns, false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Using in-cluster namespace")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allow the namespace from the service account token directory to be used.
0000000000000000000000000000000000000000;;		return config.icc.Namespace()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigAccess implements ClientConfig
0000000000000000000000000000000000000000;;	func (config *DeferredLoadingClientConfig) ConfigAccess() ConfigAccess {
0000000000000000000000000000000000000000;;		return config.loader
0000000000000000000000000000000000000000;;	}
