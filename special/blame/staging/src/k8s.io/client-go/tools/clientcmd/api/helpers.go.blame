0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/clientcmd/api/helpers.go[staging/src/k8s.io/client-go/1.4/tools/clientcmd/api/helpers.go][staging/src/k8s.io/client-go/tools/clientcmd/api/helpers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package api
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		sDec, _ := base64.StdEncoding.DecodeString("REDACTED+")
0000000000000000000000000000000000000000;;		redactedBytes = []byte(string(sDec))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsConfigEmpty returns true if the config is empty.
0000000000000000000000000000000000000000;;	func IsConfigEmpty(config *Config) bool {
0000000000000000000000000000000000000000;;		return len(config.AuthInfos) == 0 && len(config.Clusters) == 0 && len(config.Contexts) == 0 &&
0000000000000000000000000000000000000000;;			len(config.CurrentContext) == 0 &&
0000000000000000000000000000000000000000;;			len(config.Preferences.Extensions) == 0 && !config.Preferences.Colors &&
0000000000000000000000000000000000000000;;			len(config.Extensions) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MinifyConfig read the current context and uses that to keep only the relevant pieces of config
0000000000000000000000000000000000000000;;	// This is useful for making secrets based on kubeconfig files
0000000000000000000000000000000000000000;;	func MinifyConfig(config *Config) error {
0000000000000000000000000000000000000000;;		if len(config.CurrentContext) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("current-context must exist in order to minify")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currContext, exists := config.Contexts[config.CurrentContext]
0000000000000000000000000000000000000000;;		if !exists {
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot locate context %v", config.CurrentContext)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newContexts := map[string]*Context{}
0000000000000000000000000000000000000000;;		newContexts[config.CurrentContext] = currContext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newClusters := map[string]*Cluster{}
0000000000000000000000000000000000000000;;		if len(currContext.Cluster) > 0 {
0000000000000000000000000000000000000000;;			if _, exists := config.Clusters[currContext.Cluster]; !exists {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot locate cluster %v", currContext.Cluster)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newClusters[currContext.Cluster] = config.Clusters[currContext.Cluster]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newAuthInfos := map[string]*AuthInfo{}
0000000000000000000000000000000000000000;;		if len(currContext.AuthInfo) > 0 {
0000000000000000000000000000000000000000;;			if _, exists := config.AuthInfos[currContext.AuthInfo]; !exists {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot locate user %v", currContext.AuthInfo)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newAuthInfos[currContext.AuthInfo] = config.AuthInfos[currContext.AuthInfo]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config.AuthInfos = newAuthInfos
0000000000000000000000000000000000000000;;		config.Clusters = newClusters
0000000000000000000000000000000000000000;;		config.Contexts = newContexts
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var redactedBytes []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flatten redacts raw data entries from the config object for a human-readable view.
0000000000000000000000000000000000000000;;	func ShortenConfig(config *Config) {
0000000000000000000000000000000000000000;;		// trick json encoder into printing a human readable string in the raw data
0000000000000000000000000000000000000000;;		// by base64 decoding what we want to print. Relies on implementation of
0000000000000000000000000000000000000000;;		// http://golang.org/pkg/encoding/json/#Marshal using base64 to encode []byte
0000000000000000000000000000000000000000;;		for key, authInfo := range config.AuthInfos {
0000000000000000000000000000000000000000;;			if len(authInfo.ClientKeyData) > 0 {
0000000000000000000000000000000000000000;;				authInfo.ClientKeyData = redactedBytes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(authInfo.ClientCertificateData) > 0 {
0000000000000000000000000000000000000000;;				authInfo.ClientCertificateData = redactedBytes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config.AuthInfos[key] = authInfo
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key, cluster := range config.Clusters {
0000000000000000000000000000000000000000;;			if len(cluster.CertificateAuthorityData) > 0 {
0000000000000000000000000000000000000000;;				cluster.CertificateAuthorityData = redactedBytes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config.Clusters[key] = cluster
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flatten changes the config object into a self contained config (useful for making secrets)
0000000000000000000000000000000000000000;;	func FlattenConfig(config *Config) error {
0000000000000000000000000000000000000000;;		for key, authInfo := range config.AuthInfos {
0000000000000000000000000000000000000000;;			baseDir, err := MakeAbs(path.Dir(authInfo.LocationOfOrigin), "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := FlattenContent(&authInfo.ClientCertificate, &authInfo.ClientCertificateData, baseDir); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := FlattenContent(&authInfo.ClientKey, &authInfo.ClientKeyData, baseDir); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			config.AuthInfos[key] = authInfo
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key, cluster := range config.Clusters {
0000000000000000000000000000000000000000;;			baseDir, err := MakeAbs(path.Dir(cluster.LocationOfOrigin), "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := FlattenContent(&cluster.CertificateAuthority, &cluster.CertificateAuthorityData, baseDir); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			config.Clusters[key] = cluster
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FlattenContent(path *string, contents *[]byte, baseDir string) error {
0000000000000000000000000000000000000000;;		if len(*path) != 0 {
0000000000000000000000000000000000000000;;			if len(*contents) > 0 {
0000000000000000000000000000000000000000;;				return errors.New("cannot have values for both path and contents")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			absPath := ResolvePath(*path, baseDir)
0000000000000000000000000000000000000000;;			*contents, err = ioutil.ReadFile(absPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			*path = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolvePath returns the path as an absolute paths, relative to the given base directory
0000000000000000000000000000000000000000;;	func ResolvePath(path string, base string) string {
0000000000000000000000000000000000000000;;		// Don't resolve empty paths
0000000000000000000000000000000000000000;;		if len(path) > 0 {
0000000000000000000000000000000000000000;;			// Don't resolve absolute paths
0000000000000000000000000000000000000000;;			if !filepath.IsAbs(path) {
0000000000000000000000000000000000000000;;				return filepath.Join(base, path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakeAbs(path, base string) (string, error) {
0000000000000000000000000000000000000000;;		if filepath.IsAbs(path) {
0000000000000000000000000000000000000000;;			return path, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(base) == 0 {
0000000000000000000000000000000000000000;;			cwd, err := os.Getwd()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			base = cwd
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filepath.Join(base, path), nil
0000000000000000000000000000000000000000;;	}
