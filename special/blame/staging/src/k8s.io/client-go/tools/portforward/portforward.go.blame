0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/tools/portforward/portforward.go[staging/src/k8s.io/client-go/1.4/tools/portforward/portforward.go][staging/src/k8s.io/client-go/tools/portforward/portforward.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package portforward
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/httpstream"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO move to API machinery and re-unify with kubelet/server/portfoward
0000000000000000000000000000000000000000;;	// The subprotocol "portforward.k8s.io" is used for port forwarding.
0000000000000000000000000000000000000000;;	const PortForwardProtocolV1Name = "portforward.k8s.io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PortForwarder knows how to listen for local connections and forward them to
0000000000000000000000000000000000000000;;	// a remote pod via an upgraded HTTP request.
0000000000000000000000000000000000000000;;	type PortForwarder struct {
0000000000000000000000000000000000000000;;		ports    []ForwardedPort
0000000000000000000000000000000000000000;;		stopChan <-chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dialer        httpstream.Dialer
0000000000000000000000000000000000000000;;		streamConn    httpstream.Connection
0000000000000000000000000000000000000000;;		listeners     []io.Closer
0000000000000000000000000000000000000000;;		Ready         chan struct{}
0000000000000000000000000000000000000000;;		requestIDLock sync.Mutex
0000000000000000000000000000000000000000;;		requestID     int
0000000000000000000000000000000000000000;;		out           io.Writer
0000000000000000000000000000000000000000;;		errOut        io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForwardedPort contains a Local:Remote port pairing.
0000000000000000000000000000000000000000;;	type ForwardedPort struct {
0000000000000000000000000000000000000000;;		Local  uint16
0000000000000000000000000000000000000000;;		Remote uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		valid port specifications:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		5000
0000000000000000000000000000000000000000;;		- forwards from localhost:5000 to pod:5000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		8888:5000
0000000000000000000000000000000000000000;;		- forwards from localhost:8888 to pod:5000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		0:5000
0000000000000000000000000000000000000000;;		:5000
0000000000000000000000000000000000000000;;		- selects a random available local port,
0000000000000000000000000000000000000000;;		  forwards from localhost:<random port> to pod:5000
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func parsePorts(ports []string) ([]ForwardedPort, error) {
0000000000000000000000000000000000000000;;		var forwards []ForwardedPort
0000000000000000000000000000000000000000;;		for _, portString := range ports {
0000000000000000000000000000000000000000;;			parts := strings.Split(portString, ":")
0000000000000000000000000000000000000000;;			var localString, remoteString string
0000000000000000000000000000000000000000;;			if len(parts) == 1 {
0000000000000000000000000000000000000000;;				localString = parts[0]
0000000000000000000000000000000000000000;;				remoteString = parts[0]
0000000000000000000000000000000000000000;;			} else if len(parts) == 2 {
0000000000000000000000000000000000000000;;				localString = parts[0]
0000000000000000000000000000000000000000;;				if localString == "" {
0000000000000000000000000000000000000000;;					// support :5000
0000000000000000000000000000000000000000;;					localString = "0"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				remoteString = parts[1]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Invalid port format '%s'", portString)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			localPort, err := strconv.ParseUint(localString, 10, 16)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error parsing local port '%s': %s", localString, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			remotePort, err := strconv.ParseUint(remoteString, 10, 16)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Error parsing remote port '%s': %s", remoteString, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if remotePort == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Remote port must be > 0")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			forwards = append(forwards, ForwardedPort{uint16(localPort), uint16(remotePort)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return forwards, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new PortForwarder.
0000000000000000000000000000000000000000;;	func New(dialer httpstream.Dialer, ports []string, stopChan <-chan struct{}, readyChan chan struct{}, out, errOut io.Writer) (*PortForwarder, error) {
0000000000000000000000000000000000000000;;		if len(ports) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("You must specify at least 1 port")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parsedPorts, err := parsePorts(ports)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &PortForwarder{
0000000000000000000000000000000000000000;;			dialer:   dialer,
0000000000000000000000000000000000000000;;			ports:    parsedPorts,
0000000000000000000000000000000000000000;;			stopChan: stopChan,
0000000000000000000000000000000000000000;;			Ready:    readyChan,
0000000000000000000000000000000000000000;;			out:      out,
0000000000000000000000000000000000000000;;			errOut:   errOut,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForwardPorts formats and executes a port forwarding request. The connection will remain
0000000000000000000000000000000000000000;;	// open until stopChan is closed.
0000000000000000000000000000000000000000;;	func (pf *PortForwarder) ForwardPorts() error {
0000000000000000000000000000000000000000;;		defer pf.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		pf.streamConn, _, err = pf.dialer.Dial(PortForwardProtocolV1Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error upgrading connection: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer pf.streamConn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pf.forward()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// forward dials the remote host specific in req, upgrades the request, starts
0000000000000000000000000000000000000000;;	// listeners for each port specified in ports, and forwards local connections
0000000000000000000000000000000000000000;;	// to the remote host via streams.
0000000000000000000000000000000000000000;;	func (pf *PortForwarder) forward() error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listenSuccess := false
0000000000000000000000000000000000000000;;		for _, port := range pf.ports {
0000000000000000000000000000000000000000;;			err = pf.listenOnPort(&port)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err == nil:
0000000000000000000000000000000000000000;;				listenSuccess = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if pf.errOut != nil {
0000000000000000000000000000000000000000;;					fmt.Fprintf(pf.errOut, "Unable to listen on port %d: %v\n", port.Local, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !listenSuccess {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unable to listen on any of the requested ports: %v", pf.ports)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pf.Ready != nil {
0000000000000000000000000000000000000000;;			close(pf.Ready)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for interrupt or conn closure
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-pf.stopChan:
0000000000000000000000000000000000000000;;		case <-pf.streamConn.CloseChan():
0000000000000000000000000000000000000000;;			runtime.HandleError(errors.New("lost connection to pod"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listenOnPort delegates tcp4 and tcp6 listener creation and waits for connections on both of these addresses.
0000000000000000000000000000000000000000;;	// If both listener creation fail, an error is raised.
0000000000000000000000000000000000000000;;	func (pf *PortForwarder) listenOnPort(port *ForwardedPort) error {
0000000000000000000000000000000000000000;;		errTcp4 := pf.listenOnPortAndAddress(port, "tcp4", "127.0.0.1")
0000000000000000000000000000000000000000;;		errTcp6 := pf.listenOnPortAndAddress(port, "tcp6", "[::1]")
0000000000000000000000000000000000000000;;		if errTcp4 != nil && errTcp6 != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("All listeners failed to create with the following errors: %s, %s", errTcp4, errTcp6)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listenOnPortAndAddress delegates listener creation and waits for new connections
0000000000000000000000000000000000000000;;	// in the background f
0000000000000000000000000000000000000000;;	func (pf *PortForwarder) listenOnPortAndAddress(port *ForwardedPort, protocol string, address string) error {
0000000000000000000000000000000000000000;;		listener, err := pf.getListener(protocol, address, port)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pf.listeners = append(pf.listeners, listener)
0000000000000000000000000000000000000000;;		go pf.waitForConnection(listener, *port)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getListener creates a listener on the interface targeted by the given hostname on the given port with
0000000000000000000000000000000000000000;;	// the given protocol. protocol is in net.Listen style which basically admits values like tcp, tcp4, tcp6
0000000000000000000000000000000000000000;;	func (pf *PortForwarder) getListener(protocol string, hostname string, port *ForwardedPort) (net.Listener, error) {
0000000000000000000000000000000000000000;;		listener, err := net.Listen(protocol, net.JoinHostPort(hostname, strconv.Itoa(int(port.Local))))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unable to create listener: Error %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		listenerAddress := listener.Addr().String()
0000000000000000000000000000000000000000;;		host, localPort, _ := net.SplitHostPort(listenerAddress)
0000000000000000000000000000000000000000;;		localPortUInt, err := strconv.ParseUint(localPort, 10, 16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Error parsing local port: %s from %s (%s)", err, listenerAddress, host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		port.Local = uint16(localPortUInt)
0000000000000000000000000000000000000000;;		if pf.out != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(pf.out, "Forwarding from %s:%d -> %d\n", hostname, localPortUInt, port.Remote)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return listener, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitForConnection waits for new connections to listener and handles them in
0000000000000000000000000000000000000000;;	// the background.
0000000000000000000000000000000000000000;;	func (pf *PortForwarder) waitForConnection(listener net.Listener, port ForwardedPort) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			conn, err := listener.Accept()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO consider using something like https://github.com/hydrogen18/stoppableListener?
0000000000000000000000000000000000000000;;				if !strings.Contains(strings.ToLower(err.Error()), "use of closed network connection") {
0000000000000000000000000000000000000000;;					runtime.HandleError(fmt.Errorf("Error accepting connection on port %d: %v", port.Local, err))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			go pf.handleConnection(conn, port)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pf *PortForwarder) nextRequestID() int {
0000000000000000000000000000000000000000;;		pf.requestIDLock.Lock()
0000000000000000000000000000000000000000;;		defer pf.requestIDLock.Unlock()
0000000000000000000000000000000000000000;;		id := pf.requestID
0000000000000000000000000000000000000000;;		pf.requestID++
0000000000000000000000000000000000000000;;		return id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleConnection copies data between the local connection and the stream to
0000000000000000000000000000000000000000;;	// the remote server.
0000000000000000000000000000000000000000;;	func (pf *PortForwarder) handleConnection(conn net.Conn, port ForwardedPort) {
0000000000000000000000000000000000000000;;		defer conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pf.out != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(pf.out, "Handling connection for %d\n", port.Local)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		requestID := pf.nextRequestID()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create error stream
0000000000000000000000000000000000000000;;		headers := http.Header{}
0000000000000000000000000000000000000000;;		headers.Set(v1.StreamType, v1.StreamTypeError)
0000000000000000000000000000000000000000;;		headers.Set(v1.PortHeader, fmt.Sprintf("%d", port.Remote))
0000000000000000000000000000000000000000;;		headers.Set(v1.PortForwardRequestIDHeader, strconv.Itoa(requestID))
0000000000000000000000000000000000000000;;		errorStream, err := pf.streamConn.CreateStream(headers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("error creating error stream for port %d -> %d: %v", port.Local, port.Remote, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// we're not writing to this stream
0000000000000000000000000000000000000000;;		errorStream.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorChan := make(chan error)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			message, err := ioutil.ReadAll(errorStream)
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				errorChan <- fmt.Errorf("error reading from error stream for port %d -> %d: %v", port.Local, port.Remote, err)
0000000000000000000000000000000000000000;;			case len(message) > 0:
0000000000000000000000000000000000000000;;				errorChan <- fmt.Errorf("an error occurred forwarding %d -> %d: %v", port.Local, port.Remote, string(message))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(errorChan)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create data stream
0000000000000000000000000000000000000000;;		headers.Set(v1.StreamType, v1.StreamTypeData)
0000000000000000000000000000000000000000;;		dataStream, err := pf.streamConn.CreateStream(headers)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(fmt.Errorf("error creating forwarding stream for port %d -> %d: %v", port.Local, port.Remote, err))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		localError := make(chan struct{})
0000000000000000000000000000000000000000;;		remoteDone := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// Copy from the remote side to the local port.
0000000000000000000000000000000000000000;;			if _, err := io.Copy(conn, dataStream); err != nil && !strings.Contains(err.Error(), "use of closed network connection") {
0000000000000000000000000000000000000000;;				runtime.HandleError(fmt.Errorf("error copying from remote stream to local connection: %v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// inform the select below that the remote copy is done
0000000000000000000000000000000000000000;;			close(remoteDone)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			// inform server we're not sending any more data after copy unblocks
0000000000000000000000000000000000000000;;			defer dataStream.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Copy from the local port to the remote side.
0000000000000000000000000000000000000000;;			if _, err := io.Copy(dataStream, conn); err != nil && !strings.Contains(err.Error(), "use of closed network connection") {
0000000000000000000000000000000000000000;;				runtime.HandleError(fmt.Errorf("error copying from local connection to remote stream: %v", err))
0000000000000000000000000000000000000000;;				// break out of the select below without waiting for the other copy to finish
0000000000000000000000000000000000000000;;				close(localError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for either a local->remote error or for copying from remote->local to finish
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-remoteDone:
0000000000000000000000000000000000000000;;		case <-localError:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// always expect something on errorChan (it may be nil)
0000000000000000000000000000000000000000;;		err = <-errorChan
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			runtime.HandleError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pf *PortForwarder) Close() {
0000000000000000000000000000000000000000;;		// stop all listeners
0000000000000000000000000000000000000000;;		for _, l := range pf.listeners {
0000000000000000000000000000000000000000;;			if err := l.Close(); err != nil {
0000000000000000000000000000000000000000;;				runtime.HandleError(fmt.Errorf("error closing listener: %v", err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
