0000000000000000000000000000000000000000;;	//This package is copied from Go library text/template.
0000000000000000000000000000000000000000;;	//The original private functions eq, ge, gt, le, lt, and ne
0000000000000000000000000000000000000000;;	//are exported as public functions.
0000000000000000000000000000000000000000;;	package template
c409b014ea1f485f8bb92a9a6eadc2cc636553b1;staging/src/k8s.io/client-go/pkg/third_party/forked/golang/template/funcs.go[staging/src/k8s.io/client-go/pkg/third_party/forked/golang/template/funcs.go][staging/src/k8s.io/client-go/third_party/forked/golang/template/funcs.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var Equal = eq
0000000000000000000000000000000000000000;;	var GreaterEqual = ge
0000000000000000000000000000000000000000;;	var Greater = gt
0000000000000000000000000000000000000000;;	var LessEqual = le
0000000000000000000000000000000000000000;;	var Less = lt
0000000000000000000000000000000000000000;;	var NotEqual = ne
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FuncMap is the type of the map defining the mapping from names to functions.
0000000000000000000000000000000000000000;;	// Each function must have either a single return value, or two return values of
0000000000000000000000000000000000000000;;	// which the second has type error. In that case, if the second (error)
0000000000000000000000000000000000000000;;	// return value evaluates to non-nil during execution, execution terminates and
0000000000000000000000000000000000000000;;	// Execute returns that error.
0000000000000000000000000000000000000000;;	type FuncMap map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var builtins = FuncMap{
0000000000000000000000000000000000000000;;		"and":      and,
0000000000000000000000000000000000000000;;		"call":     call,
0000000000000000000000000000000000000000;;		"html":     HTMLEscaper,
0000000000000000000000000000000000000000;;		"index":    index,
0000000000000000000000000000000000000000;;		"js":       JSEscaper,
0000000000000000000000000000000000000000;;		"len":      length,
0000000000000000000000000000000000000000;;		"not":      not,
0000000000000000000000000000000000000000;;		"or":       or,
0000000000000000000000000000000000000000;;		"print":    fmt.Sprint,
0000000000000000000000000000000000000000;;		"printf":   fmt.Sprintf,
0000000000000000000000000000000000000000;;		"println":  fmt.Sprintln,
0000000000000000000000000000000000000000;;		"urlquery": URLQueryEscaper,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Comparisons
0000000000000000000000000000000000000000;;		"eq": eq, // ==
0000000000000000000000000000000000000000;;		"ge": ge, // >=
0000000000000000000000000000000000000000;;		"gt": gt, // >
0000000000000000000000000000000000000000;;		"le": le, // <=
0000000000000000000000000000000000000000;;		"lt": lt, // <
0000000000000000000000000000000000000000;;		"ne": ne, // !=
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var builtinFuncs = createValueFuncs(builtins)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createValueFuncs turns a FuncMap into a map[string]reflect.Value
0000000000000000000000000000000000000000;;	func createValueFuncs(funcMap FuncMap) map[string]reflect.Value {
0000000000000000000000000000000000000000;;		m := make(map[string]reflect.Value)
0000000000000000000000000000000000000000;;		addValueFuncs(m, funcMap)
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addValueFuncs adds to values the functions in funcs, converting them to reflect.Values.
0000000000000000000000000000000000000000;;	func addValueFuncs(out map[string]reflect.Value, in FuncMap) {
0000000000000000000000000000000000000000;;		for name, fn := range in {
0000000000000000000000000000000000000000;;			v := reflect.ValueOf(fn)
0000000000000000000000000000000000000000;;			if v.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;				panic("value for " + name + " not a function")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !goodFunc(v.Type()) {
0000000000000000000000000000000000000000;;				panic(fmt.Errorf("can't install method/function %q with %d results", name, v.Type().NumOut()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out[name] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddFuncs adds to values the functions in funcs. It does no checking of the input -
0000000000000000000000000000000000000000;;	// call addValueFuncs first.
0000000000000000000000000000000000000000;;	func addFuncs(out, in FuncMap) {
0000000000000000000000000000000000000000;;		for name, fn := range in {
0000000000000000000000000000000000000000;;			out[name] = fn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// goodFunc checks that the function or method has the right result signature.
0000000000000000000000000000000000000000;;	func goodFunc(typ reflect.Type) bool {
0000000000000000000000000000000000000000;;		// We allow functions with 1 result or 2 results where the second is an error.
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case typ.NumOut() == 1:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case typ.NumOut() == 2 && typ.Out(1) == errorType:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findFunction looks for a function in the template, and global map.
0000000000000000000000000000000000000000;;	func findFunction(name string) (reflect.Value, bool) {
0000000000000000000000000000000000000000;;		if fn := builtinFuncs[name]; fn.IsValid() {
0000000000000000000000000000000000000000;;			return fn, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reflect.Value{}, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Indexing.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// index returns the result of indexing its first argument by the following
0000000000000000000000000000000000000000;;	// arguments.  Thus "index x 1 2 3" is, in Go syntax, x[1][2][3]. Each
0000000000000000000000000000000000000000;;	// indexed item must be a map, slice, or array.
0000000000000000000000000000000000000000;;	func index(item interface{}, indices ...interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(item)
0000000000000000000000000000000000000000;;		for _, i := range indices {
0000000000000000000000000000000000000000;;			index := reflect.ValueOf(i)
0000000000000000000000000000000000000000;;			var isNil bool
0000000000000000000000000000000000000000;;			if v, isNil = indirect(v); isNil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("index of nil pointer")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch v.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Array, reflect.Slice, reflect.String:
0000000000000000000000000000000000000000;;				var x int64
0000000000000000000000000000000000000000;;				switch index.Kind() {
0000000000000000000000000000000000000000;;				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;					x = index.Int()
0000000000000000000000000000000000000000;;				case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;					x = int64(index.Uint())
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("cannot index slice/array with type %s", index.Type())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if x < 0 || x >= int64(v.Len()) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("index out of range: %d", x)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v = v.Index(int(x))
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				if !index.IsValid() {
0000000000000000000000000000000000000000;;					index = reflect.Zero(v.Type().Key())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !index.Type().AssignableTo(v.Type().Key()) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("%s is not index type for %s", index.Type(), v.Type())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if x := v.MapIndex(index); x.IsValid() {
0000000000000000000000000000000000000000;;					v = x
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					v = reflect.Zero(v.Type().Elem())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("can't index item of type %s", v.Type())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.Interface(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Length
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// length returns the length of the item, with an error if it has no defined length.
0000000000000000000000000000000000000000;;	func length(item interface{}) (int, error) {
0000000000000000000000000000000000000000;;		v, isNil := indirect(reflect.ValueOf(item))
0000000000000000000000000000000000000000;;		if isNil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("len of nil pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:
0000000000000000000000000000000000000000;;			return v.Len(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("len of type %s", v.Type())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Function invocation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// call returns the result of evaluating the first argument as a function.
0000000000000000000000000000000000000000;;	// The function must return 1 result, or 2 results, the second of which is an error.
0000000000000000000000000000000000000000;;	func call(fn interface{}, args ...interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(fn)
0000000000000000000000000000000000000000;;		typ := v.Type()
0000000000000000000000000000000000000000;;		if typ.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("non-function of type %s", typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !goodFunc(typ) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("function called with %d args; should be 1 or 2", typ.NumOut())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		numIn := typ.NumIn()
0000000000000000000000000000000000000000;;		var dddType reflect.Type
0000000000000000000000000000000000000000;;		if typ.IsVariadic() {
0000000000000000000000000000000000000000;;			if len(args) < numIn-1 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("wrong number of args: got %d want at least %d", len(args), numIn-1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dddType = typ.In(numIn - 1).Elem()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if len(args) != numIn {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("wrong number of args: got %d want %d", len(args), numIn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		argv := make([]reflect.Value, len(args))
0000000000000000000000000000000000000000;;		for i, arg := range args {
0000000000000000000000000000000000000000;;			value := reflect.ValueOf(arg)
0000000000000000000000000000000000000000;;			// Compute the expected type. Clumsy because of variadics.
0000000000000000000000000000000000000000;;			var argType reflect.Type
0000000000000000000000000000000000000000;;			if !typ.IsVariadic() || i < numIn-1 {
0000000000000000000000000000000000000000;;				argType = typ.In(i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				argType = dddType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !value.IsValid() && canBeNil(argType) {
0000000000000000000000000000000000000000;;				value = reflect.Zero(argType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !value.Type().AssignableTo(argType) {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("arg %d has type %s; should be %s", i, value.Type(), argType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			argv[i] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := v.Call(argv)
0000000000000000000000000000000000000000;;		if len(result) == 2 && !result[1].IsNil() {
0000000000000000000000000000000000000000;;			return result[0].Interface(), result[1].Interface().(error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result[0].Interface(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Boolean logic.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func truth(a interface{}) bool {
0000000000000000000000000000000000000000;;		t, _ := isTrue(reflect.ValueOf(a))
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// and computes the Boolean AND of its arguments, returning
0000000000000000000000000000000000000000;;	// the first false argument it encounters, or the last argument.
0000000000000000000000000000000000000000;;	func and(arg0 interface{}, args ...interface{}) interface{} {
0000000000000000000000000000000000000000;;		if !truth(arg0) {
0000000000000000000000000000000000000000;;			return arg0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range args {
0000000000000000000000000000000000000000;;			arg0 = args[i]
0000000000000000000000000000000000000000;;			if !truth(arg0) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return arg0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// or computes the Boolean OR of its arguments, returning
0000000000000000000000000000000000000000;;	// the first true argument it encounters, or the last argument.
0000000000000000000000000000000000000000;;	func or(arg0 interface{}, args ...interface{}) interface{} {
0000000000000000000000000000000000000000;;		if truth(arg0) {
0000000000000000000000000000000000000000;;			return arg0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range args {
0000000000000000000000000000000000000000;;			arg0 = args[i]
0000000000000000000000000000000000000000;;			if truth(arg0) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return arg0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// not returns the Boolean negation of its argument.
0000000000000000000000000000000000000000;;	func not(arg interface{}) (truth bool) {
0000000000000000000000000000000000000000;;		truth, _ = isTrue(reflect.ValueOf(arg))
0000000000000000000000000000000000000000;;		return !truth
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Comparison.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: Perhaps allow comparison between signed and unsigned integers.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errBadComparisonType = errors.New("invalid type for comparison")
0000000000000000000000000000000000000000;;		errBadComparison     = errors.New("incompatible types for comparison")
0000000000000000000000000000000000000000;;		errNoComparison      = errors.New("missing argument for comparison")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type kind int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		invalidKind kind = iota
0000000000000000000000000000000000000000;;		boolKind
0000000000000000000000000000000000000000;;		complexKind
0000000000000000000000000000000000000000;;		intKind
0000000000000000000000000000000000000000;;		floatKind
0000000000000000000000000000000000000000;;		integerKind
0000000000000000000000000000000000000000;;		stringKind
0000000000000000000000000000000000000000;;		uintKind
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func basicKind(v reflect.Value) (kind, error) {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return boolKind, nil
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return intKind, nil
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			return uintKind, nil
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return floatKind, nil
0000000000000000000000000000000000000000;;		case reflect.Complex64, reflect.Complex128:
0000000000000000000000000000000000000000;;			return complexKind, nil
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return stringKind, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return invalidKind, errBadComparisonType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// eq evaluates the comparison a == b || a == c || ...
0000000000000000000000000000000000000000;;	func eq(arg1 interface{}, arg2 ...interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		v1 := reflect.ValueOf(arg1)
0000000000000000000000000000000000000000;;		k1, err := basicKind(v1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(arg2) == 0 {
0000000000000000000000000000000000000000;;			return false, errNoComparison
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, arg := range arg2 {
0000000000000000000000000000000000000000;;			v2 := reflect.ValueOf(arg)
0000000000000000000000000000000000000000;;			k2, err := basicKind(v2)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			truth := false
0000000000000000000000000000000000000000;;			if k1 != k2 {
0000000000000000000000000000000000000000;;				// Special case: Can compare integer values regardless of type's sign.
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case k1 == intKind && k2 == uintKind:
0000000000000000000000000000000000000000;;					truth = v1.Int() >= 0 && uint64(v1.Int()) == v2.Uint()
0000000000000000000000000000000000000000;;				case k1 == uintKind && k2 == intKind:
0000000000000000000000000000000000000000;;					truth = v2.Int() >= 0 && v1.Uint() == uint64(v2.Int())
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return false, errBadComparison
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				switch k1 {
0000000000000000000000000000000000000000;;				case boolKind:
0000000000000000000000000000000000000000;;					truth = v1.Bool() == v2.Bool()
0000000000000000000000000000000000000000;;				case complexKind:
0000000000000000000000000000000000000000;;					truth = v1.Complex() == v2.Complex()
0000000000000000000000000000000000000000;;				case floatKind:
0000000000000000000000000000000000000000;;					truth = v1.Float() == v2.Float()
0000000000000000000000000000000000000000;;				case intKind:
0000000000000000000000000000000000000000;;					truth = v1.Int() == v2.Int()
0000000000000000000000000000000000000000;;				case stringKind:
0000000000000000000000000000000000000000;;					truth = v1.String() == v2.String()
0000000000000000000000000000000000000000;;				case uintKind:
0000000000000000000000000000000000000000;;					truth = v1.Uint() == v2.Uint()
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					panic("invalid kind")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if truth {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ne evaluates the comparison a != b.
0000000000000000000000000000000000000000;;	func ne(arg1, arg2 interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		// != is the inverse of ==.
0000000000000000000000000000000000000000;;		equal, err := eq(arg1, arg2)
0000000000000000000000000000000000000000;;		return !equal, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lt evaluates the comparison a < b.
0000000000000000000000000000000000000000;;	func lt(arg1, arg2 interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		v1 := reflect.ValueOf(arg1)
0000000000000000000000000000000000000000;;		k1, err := basicKind(v1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v2 := reflect.ValueOf(arg2)
0000000000000000000000000000000000000000;;		k2, err := basicKind(v2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		truth := false
0000000000000000000000000000000000000000;;		if k1 != k2 {
0000000000000000000000000000000000000000;;			// Special case: Can compare integer values regardless of type's sign.
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case k1 == intKind && k2 == uintKind:
0000000000000000000000000000000000000000;;				truth = v1.Int() < 0 || uint64(v1.Int()) < v2.Uint()
0000000000000000000000000000000000000000;;			case k1 == uintKind && k2 == intKind:
0000000000000000000000000000000000000000;;				truth = v2.Int() >= 0 && v1.Uint() < uint64(v2.Int())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false, errBadComparison
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			switch k1 {
0000000000000000000000000000000000000000;;			case boolKind, complexKind:
0000000000000000000000000000000000000000;;				return false, errBadComparisonType
0000000000000000000000000000000000000000;;			case floatKind:
0000000000000000000000000000000000000000;;				truth = v1.Float() < v2.Float()
0000000000000000000000000000000000000000;;			case intKind:
0000000000000000000000000000000000000000;;				truth = v1.Int() < v2.Int()
0000000000000000000000000000000000000000;;			case stringKind:
0000000000000000000000000000000000000000;;				truth = v1.String() < v2.String()
0000000000000000000000000000000000000000;;			case uintKind:
0000000000000000000000000000000000000000;;				truth = v1.Uint() < v2.Uint()
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("invalid kind")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return truth, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// le evaluates the comparison <= b.
0000000000000000000000000000000000000000;;	func le(arg1, arg2 interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		// <= is < or ==.
0000000000000000000000000000000000000000;;		lessThan, err := lt(arg1, arg2)
0000000000000000000000000000000000000000;;		if lessThan || err != nil {
0000000000000000000000000000000000000000;;			return lessThan, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return eq(arg1, arg2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gt evaluates the comparison a > b.
0000000000000000000000000000000000000000;;	func gt(arg1, arg2 interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		// > is the inverse of <=.
0000000000000000000000000000000000000000;;		lessOrEqual, err := le(arg1, arg2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return !lessOrEqual, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ge evaluates the comparison a >= b.
0000000000000000000000000000000000000000;;	func ge(arg1, arg2 interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		// >= is the inverse of <.
0000000000000000000000000000000000000000;;		lessThan, err := lt(arg1, arg2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return !lessThan, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTML escaping.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		htmlQuot = []byte("&#34;") // shorter than "&quot;"
0000000000000000000000000000000000000000;;		htmlApos = []byte("&#39;") // shorter than "&apos;" and apos was not in HTML until HTML5
0000000000000000000000000000000000000000;;		htmlAmp  = []byte("&amp;")
0000000000000000000000000000000000000000;;		htmlLt   = []byte("&lt;")
0000000000000000000000000000000000000000;;		htmlGt   = []byte("&gt;")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.
0000000000000000000000000000000000000000;;	func HTMLEscape(w io.Writer, b []byte) {
0000000000000000000000000000000000000000;;		last := 0
0000000000000000000000000000000000000000;;		for i, c := range b {
0000000000000000000000000000000000000000;;			var html []byte
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				html = htmlQuot
0000000000000000000000000000000000000000;;			case '\'':
0000000000000000000000000000000000000000;;				html = htmlApos
0000000000000000000000000000000000000000;;			case '&':
0000000000000000000000000000000000000000;;				html = htmlAmp
0000000000000000000000000000000000000000;;			case '<':
0000000000000000000000000000000000000000;;				html = htmlLt
0000000000000000000000000000000000000000;;			case '>':
0000000000000000000000000000000000000000;;				html = htmlGt
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(b[last:i])
0000000000000000000000000000000000000000;;			w.Write(html)
0000000000000000000000000000000000000000;;			last = i + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(b[last:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.
0000000000000000000000000000000000000000;;	func HTMLEscapeString(s string) string {
0000000000000000000000000000000000000000;;		// Avoid allocation if we can.
0000000000000000000000000000000000000000;;		if strings.IndexAny(s, `'"&<>`) < 0 {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		HTMLEscape(&b, []byte(s))
0000000000000000000000000000000000000000;;		return b.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTMLEscaper returns the escaped HTML equivalent of the textual
0000000000000000000000000000000000000000;;	// representation of its arguments.
0000000000000000000000000000000000000000;;	func HTMLEscaper(args ...interface{}) string {
0000000000000000000000000000000000000000;;		return HTMLEscapeString(evalArgs(args))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JavaScript escaping.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		jsLowUni = []byte(`\u00`)
0000000000000000000000000000000000000000;;		hex      = []byte("0123456789ABCDEF")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsBackslash = []byte(`\\`)
0000000000000000000000000000000000000000;;		jsApos      = []byte(`\'`)
0000000000000000000000000000000000000000;;		jsQuot      = []byte(`\"`)
0000000000000000000000000000000000000000;;		jsLt        = []byte(`\x3C`)
0000000000000000000000000000000000000000;;		jsGt        = []byte(`\x3E`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.
0000000000000000000000000000000000000000;;	func JSEscape(w io.Writer, b []byte) {
0000000000000000000000000000000000000000;;		last := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(b); i++ {
0000000000000000000000000000000000000000;;			c := b[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !jsIsSpecial(rune(c)) {
0000000000000000000000000000000000000000;;				// fast path: nothing to do
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write(b[last:i])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				// Quotes, slashes and angle brackets get quoted.
0000000000000000000000000000000000000000;;				// Control characters get written as \u00XX.
0000000000000000000000000000000000000000;;				switch c {
0000000000000000000000000000000000000000;;				case '\\':
0000000000000000000000000000000000000000;;					w.Write(jsBackslash)
0000000000000000000000000000000000000000;;				case '\'':
0000000000000000000000000000000000000000;;					w.Write(jsApos)
0000000000000000000000000000000000000000;;				case '"':
0000000000000000000000000000000000000000;;					w.Write(jsQuot)
0000000000000000000000000000000000000000;;				case '<':
0000000000000000000000000000000000000000;;					w.Write(jsLt)
0000000000000000000000000000000000000000;;				case '>':
0000000000000000000000000000000000000000;;					w.Write(jsGt)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					w.Write(jsLowUni)
0000000000000000000000000000000000000000;;					t, b := c>>4, c&0x0f
0000000000000000000000000000000000000000;;					w.Write(hex[t : t+1])
0000000000000000000000000000000000000000;;					w.Write(hex[b : b+1])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Unicode rune.
0000000000000000000000000000000000000000;;				r, size := utf8.DecodeRune(b[i:])
0000000000000000000000000000000000000000;;				if unicode.IsPrint(r) {
0000000000000000000000000000000000000000;;					w.Write(b[i : i+size])
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fmt.Fprintf(w, "\\u%04X", r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i += size - 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			last = i + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(b[last:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.
0000000000000000000000000000000000000000;;	func JSEscapeString(s string) string {
0000000000000000000000000000000000000000;;		// Avoid allocation if we can.
0000000000000000000000000000000000000000;;		if strings.IndexFunc(s, jsIsSpecial) < 0 {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		JSEscape(&b, []byte(s))
0000000000000000000000000000000000000000;;		return b.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jsIsSpecial(r rune) bool {
0000000000000000000000000000000000000000;;		switch r {
0000000000000000000000000000000000000000;;		case '\\', '\'', '"', '<', '>':
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r < ' ' || utf8.RuneSelf <= r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSEscaper returns the escaped JavaScript equivalent of the textual
0000000000000000000000000000000000000000;;	// representation of its arguments.
0000000000000000000000000000000000000000;;	func JSEscaper(args ...interface{}) string {
0000000000000000000000000000000000000000;;		return JSEscapeString(evalArgs(args))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URLQueryEscaper returns the escaped value of the textual representation of
0000000000000000000000000000000000000000;;	// its arguments in a form suitable for embedding in a URL query.
0000000000000000000000000000000000000000;;	func URLQueryEscaper(args ...interface{}) string {
0000000000000000000000000000000000000000;;		return url.QueryEscape(evalArgs(args))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// evalArgs formats the list of arguments into a string. It is therefore equivalent to
0000000000000000000000000000000000000000;;	//	fmt.Sprint(args...)
0000000000000000000000000000000000000000;;	// except that each argument is indirected (if a pointer), as required,
0000000000000000000000000000000000000000;;	// using the same rules as the default string evaluation during template
0000000000000000000000000000000000000000;;	// execution.
0000000000000000000000000000000000000000;;	func evalArgs(args []interface{}) string {
0000000000000000000000000000000000000000;;		ok := false
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		// Fast path for simple common case.
0000000000000000000000000000000000000000;;		if len(args) == 1 {
0000000000000000000000000000000000000000;;			s, ok = args[0].(string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			for i, arg := range args {
0000000000000000000000000000000000000000;;				a, ok := printableValue(reflect.ValueOf(arg))
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					args[i] = a
0000000000000000000000000000000000000000;;				} // else left fmt do its thing
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = fmt.Sprint(args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
