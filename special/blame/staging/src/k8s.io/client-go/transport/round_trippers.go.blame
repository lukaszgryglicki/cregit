0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/transport/round_trippers.go[staging/src/k8s.io/client-go/1.4/transport/round_trippers.go][staging/src/k8s.io/client-go/transport/round_trippers.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		utilnet "k8s.io/apimachinery/pkg/util/net"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTTPWrappersForConfig wraps a round tripper with any relevant layered
0000000000000000000000000000000000000000;;	// behavior from the config. Exposed to allow more clients that need HTTP-like
0000000000000000000000000000000000000000;;	// behavior but then must hijack the underlying connection (like WebSocket or
0000000000000000000000000000000000000000;;	// HTTP2 clients). Pure HTTP clients should use the RoundTripper returned from
0000000000000000000000000000000000000000;;	// New.
0000000000000000000000000000000000000000;;	func HTTPWrappersForConfig(config *Config, rt http.RoundTripper) (http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		if config.WrapTransport != nil {
0000000000000000000000000000000000000000;;			rt = config.WrapTransport(rt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rt = DebugWrappers(rt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set authentication wrappers
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case config.HasBasicAuth() && config.HasTokenAuth():
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("username/password or bearer token may be set, but not both")
0000000000000000000000000000000000000000;;		case config.HasTokenAuth():
0000000000000000000000000000000000000000;;			rt = NewBearerAuthRoundTripper(config.BearerToken, rt)
0000000000000000000000000000000000000000;;		case config.HasBasicAuth():
0000000000000000000000000000000000000000;;			rt = NewBasicAuthRoundTripper(config.Username, config.Password, rt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.UserAgent) > 0 {
0000000000000000000000000000000000000000;;			rt = NewUserAgentRoundTripper(config.UserAgent, rt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(config.Impersonate.UserName) > 0 ||
0000000000000000000000000000000000000000;;			len(config.Impersonate.Groups) > 0 ||
0000000000000000000000000000000000000000;;			len(config.Impersonate.Extra) > 0 {
0000000000000000000000000000000000000000;;			rt = NewImpersonatingRoundTripper(config.Impersonate, rt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rt, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DebugWrappers wraps a round tripper and logs based on the current log level.
0000000000000000000000000000000000000000;;	func DebugWrappers(rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case bool(glog.V(9)):
0000000000000000000000000000000000000000;;			rt = newDebuggingRoundTripper(rt, debugCurlCommand, debugURLTiming, debugResponseHeaders)
0000000000000000000000000000000000000000;;		case bool(glog.V(8)):
0000000000000000000000000000000000000000;;			rt = newDebuggingRoundTripper(rt, debugJustURL, debugRequestHeaders, debugResponseStatus, debugResponseHeaders)
0000000000000000000000000000000000000000;;		case bool(glog.V(7)):
0000000000000000000000000000000000000000;;			rt = newDebuggingRoundTripper(rt, debugJustURL, debugRequestHeaders, debugResponseStatus)
0000000000000000000000000000000000000000;;		case bool(glog.V(6)):
0000000000000000000000000000000000000000;;			rt = newDebuggingRoundTripper(rt, debugURLTiming)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type requestCanceler interface {
0000000000000000000000000000000000000000;;		CancelRequest(*http.Request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type authProxyRoundTripper struct {
0000000000000000000000000000000000000000;;		username string
0000000000000000000000000000000000000000;;		groups   []string
0000000000000000000000000000000000000000;;		extra    map[string][]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rt http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAuthProxyRoundTripper provides a roundtripper which will add auth proxy fields to requests for
0000000000000000000000000000000000000000;;	// authentication terminating proxy cases
0000000000000000000000000000000000000000;;	// assuming you pull the user from the context:
0000000000000000000000000000000000000000;;	// username is the user.Info.GetName() of the user
0000000000000000000000000000000000000000;;	// groups is the user.Info.GetGroups() of the user
0000000000000000000000000000000000000000;;	// extra is the user.Info.GetExtra() of the user
0000000000000000000000000000000000000000;;	// extra can contain any additional information that the authenticator
0000000000000000000000000000000000000000;;	// thought was interesting, for example authorization scopes.
0000000000000000000000000000000000000000;;	// In order to faithfully round-trip through an impersonation flow, these keys
0000000000000000000000000000000000000000;;	// MUST be lowercase.
0000000000000000000000000000000000000000;;	func NewAuthProxyRoundTripper(username string, groups []string, extra map[string][]string, rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &authProxyRoundTripper{
0000000000000000000000000000000000000000;;			username: username,
0000000000000000000000000000000000000000;;			groups:   groups,
0000000000000000000000000000000000000000;;			extra:    extra,
0000000000000000000000000000000000000000;;			rt:       rt,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *authProxyRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		req = utilnet.CloneRequest(req)
0000000000000000000000000000000000000000;;		SetAuthProxyHeaders(req, rt.username, rt.groups, rt.extra)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rt.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetAuthProxyHeaders stomps the auth proxy header fields.  It mutates its argument.
0000000000000000000000000000000000000000;;	func SetAuthProxyHeaders(req *http.Request, username string, groups []string, extra map[string][]string) {
0000000000000000000000000000000000000000;;		req.Header.Del("X-Remote-User")
0000000000000000000000000000000000000000;;		req.Header.Del("X-Remote-Group")
0000000000000000000000000000000000000000;;		for key := range req.Header {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(strings.ToLower(key), strings.ToLower("X-Remote-Extra-")) {
0000000000000000000000000000000000000000;;				req.Header.Del(key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.Header.Set("X-Remote-User", username)
0000000000000000000000000000000000000000;;		for _, group := range groups {
0000000000000000000000000000000000000000;;			req.Header.Add("X-Remote-Group", group)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key, values := range extra {
0000000000000000000000000000000000000000;;			for _, value := range values {
0000000000000000000000000000000000000000;;				req.Header.Add("X-Remote-Extra-"+key, value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *authProxyRoundTripper) CancelRequest(req *http.Request) {
0000000000000000000000000000000000000000;;		if canceler, ok := rt.rt.(requestCanceler); ok {
0000000000000000000000000000000000000000;;			canceler.CancelRequest(req)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("CancelRequest not implemented")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *authProxyRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.rt }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type userAgentRoundTripper struct {
0000000000000000000000000000000000000000;;		agent string
0000000000000000000000000000000000000000;;		rt    http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewUserAgentRoundTripper(agent string, rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &userAgentRoundTripper{agent, rt}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *userAgentRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if len(req.Header.Get("User-Agent")) != 0 {
0000000000000000000000000000000000000000;;			return rt.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req = utilnet.CloneRequest(req)
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", rt.agent)
0000000000000000000000000000000000000000;;		return rt.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *userAgentRoundTripper) CancelRequest(req *http.Request) {
0000000000000000000000000000000000000000;;		if canceler, ok := rt.rt.(requestCanceler); ok {
0000000000000000000000000000000000000000;;			canceler.CancelRequest(req)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("CancelRequest not implemented")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *userAgentRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.rt }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type basicAuthRoundTripper struct {
0000000000000000000000000000000000000000;;		username string
0000000000000000000000000000000000000000;;		password string
0000000000000000000000000000000000000000;;		rt       http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBasicAuthRoundTripper will apply a BASIC auth authorization header to a
0000000000000000000000000000000000000000;;	// request unless it has already been set.
0000000000000000000000000000000000000000;;	func NewBasicAuthRoundTripper(username, password string, rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &basicAuthRoundTripper{username, password, rt}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *basicAuthRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if len(req.Header.Get("Authorization")) != 0 {
0000000000000000000000000000000000000000;;			return rt.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req = utilnet.CloneRequest(req)
0000000000000000000000000000000000000000;;		req.SetBasicAuth(rt.username, rt.password)
0000000000000000000000000000000000000000;;		return rt.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *basicAuthRoundTripper) CancelRequest(req *http.Request) {
0000000000000000000000000000000000000000;;		if canceler, ok := rt.rt.(requestCanceler); ok {
0000000000000000000000000000000000000000;;			canceler.CancelRequest(req)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("CancelRequest not implemented")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *basicAuthRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.rt }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These correspond to the headers used in pkg/apis/authentication.  We don't want the package dependency,
0000000000000000000000000000000000000000;;	// but you must not change the values.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ImpersonateUserHeader is used to impersonate a particular user during an API server request
0000000000000000000000000000000000000000;;		ImpersonateUserHeader = "Impersonate-User"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ImpersonateGroupHeader is used to impersonate a particular group during an API server request.
0000000000000000000000000000000000000000;;		// It can be repeated multiplied times for multiple groups.
0000000000000000000000000000000000000000;;		ImpersonateGroupHeader = "Impersonate-Group"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ImpersonateUserExtraHeaderPrefix is a prefix for a header used to impersonate an entry in the
0000000000000000000000000000000000000000;;		// extra map[string][]string for user.Info.  The key for the `extra` map is suffix.
0000000000000000000000000000000000000000;;		// The same key can be repeated multiple times to have multiple elements in the slice under a single key.
0000000000000000000000000000000000000000;;		// For instance:
0000000000000000000000000000000000000000;;		// Impersonate-Extra-Foo: one
0000000000000000000000000000000000000000;;		// Impersonate-Extra-Foo: two
0000000000000000000000000000000000000000;;		// results in extra["Foo"] = []string{"one", "two"}
0000000000000000000000000000000000000000;;		ImpersonateUserExtraHeaderPrefix = "Impersonate-Extra-"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type impersonatingRoundTripper struct {
0000000000000000000000000000000000000000;;		impersonate ImpersonationConfig
0000000000000000000000000000000000000000;;		delegate    http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewImpersonatingRoundTripper will add an Act-As header to a request unless it has already been set.
0000000000000000000000000000000000000000;;	func NewImpersonatingRoundTripper(impersonate ImpersonationConfig, delegate http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &impersonatingRoundTripper{impersonate, delegate}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *impersonatingRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		// use the user header as marker for the rest.
0000000000000000000000000000000000000000;;		if len(req.Header.Get(ImpersonateUserHeader)) != 0 {
0000000000000000000000000000000000000000;;			return rt.delegate.RoundTrip(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req = utilnet.CloneRequest(req)
0000000000000000000000000000000000000000;;		req.Header.Set(ImpersonateUserHeader, rt.impersonate.UserName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, group := range rt.impersonate.Groups {
0000000000000000000000000000000000000000;;			req.Header.Add(ImpersonateGroupHeader, group)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, vv := range rt.impersonate.Extra {
0000000000000000000000000000000000000000;;			for _, v := range vv {
0000000000000000000000000000000000000000;;				req.Header.Add(ImpersonateUserExtraHeaderPrefix+k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rt.delegate.RoundTrip(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *impersonatingRoundTripper) CancelRequest(req *http.Request) {
0000000000000000000000000000000000000000;;		if canceler, ok := rt.delegate.(requestCanceler); ok {
0000000000000000000000000000000000000000;;			canceler.CancelRequest(req)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("CancelRequest not implemented")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *impersonatingRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.delegate }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bearerAuthRoundTripper struct {
0000000000000000000000000000000000000000;;		bearer string
0000000000000000000000000000000000000000;;		rt     http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBearerAuthRoundTripper adds the provided bearer token to a request
0000000000000000000000000000000000000000;;	// unless the authorization header has already been set.
0000000000000000000000000000000000000000;;	func NewBearerAuthRoundTripper(bearer string, rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &bearerAuthRoundTripper{bearer, rt}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *bearerAuthRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if len(req.Header.Get("Authorization")) != 0 {
0000000000000000000000000000000000000000;;			return rt.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req = utilnet.CloneRequest(req)
0000000000000000000000000000000000000000;;		req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", rt.bearer))
0000000000000000000000000000000000000000;;		return rt.rt.RoundTrip(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *bearerAuthRoundTripper) CancelRequest(req *http.Request) {
0000000000000000000000000000000000000000;;		if canceler, ok := rt.rt.(requestCanceler); ok {
0000000000000000000000000000000000000000;;			canceler.CancelRequest(req)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("CancelRequest not implemented")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *bearerAuthRoundTripper) WrappedRoundTripper() http.RoundTripper { return rt.rt }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// requestInfo keeps track of information about a request/response combination
0000000000000000000000000000000000000000;;	type requestInfo struct {
0000000000000000000000000000000000000000;;		RequestHeaders http.Header
0000000000000000000000000000000000000000;;		RequestVerb    string
0000000000000000000000000000000000000000;;		RequestURL     string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ResponseStatus  string
0000000000000000000000000000000000000000;;		ResponseHeaders http.Header
0000000000000000000000000000000000000000;;		ResponseErr     error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Duration time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newRequestInfo creates a new RequestInfo based on an http request
0000000000000000000000000000000000000000;;	func newRequestInfo(req *http.Request) *requestInfo {
0000000000000000000000000000000000000000;;		return &requestInfo{
0000000000000000000000000000000000000000;;			RequestURL:     req.URL.String(),
0000000000000000000000000000000000000000;;			RequestVerb:    req.Method,
0000000000000000000000000000000000000000;;			RequestHeaders: req.Header,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// complete adds information about the response to the requestInfo
0000000000000000000000000000000000000000;;	func (r *requestInfo) complete(response *http.Response, err error) {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.ResponseErr = err
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.ResponseStatus = response.Status
0000000000000000000000000000000000000000;;		r.ResponseHeaders = response.Header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toCurl returns a string that can be run as a command in a terminal (minus the body)
0000000000000000000000000000000000000000;;	func (r *requestInfo) toCurl() string {
0000000000000000000000000000000000000000;;		headers := ""
0000000000000000000000000000000000000000;;		for key, values := range r.RequestHeaders {
0000000000000000000000000000000000000000;;			for _, value := range values {
0000000000000000000000000000000000000000;;				headers += fmt.Sprintf(` -H %q`, fmt.Sprintf("%s: %s", key, value))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("curl -k -v -X%s %s %s", r.RequestVerb, headers, r.RequestURL)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// debuggingRoundTripper will display information about the requests passing
0000000000000000000000000000000000000000;;	// through it based on what is configured
0000000000000000000000000000000000000000;;	type debuggingRoundTripper struct {
0000000000000000000000000000000000000000;;		delegatedRoundTripper http.RoundTripper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		levels map[debugLevel]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type debugLevel int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		debugJustURL debugLevel = iota
0000000000000000000000000000000000000000;;		debugURLTiming
0000000000000000000000000000000000000000;;		debugCurlCommand
0000000000000000000000000000000000000000;;		debugRequestHeaders
0000000000000000000000000000000000000000;;		debugResponseStatus
0000000000000000000000000000000000000000;;		debugResponseHeaders
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDebuggingRoundTripper(rt http.RoundTripper, levels ...debugLevel) *debuggingRoundTripper {
0000000000000000000000000000000000000000;;		drt := &debuggingRoundTripper{
0000000000000000000000000000000000000000;;			delegatedRoundTripper: rt,
0000000000000000000000000000000000000000;;			levels:                make(map[debugLevel]bool, len(levels)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range levels {
0000000000000000000000000000000000000000;;			drt.levels[v] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return drt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *debuggingRoundTripper) CancelRequest(req *http.Request) {
0000000000000000000000000000000000000000;;		if canceler, ok := rt.delegatedRoundTripper.(requestCanceler); ok {
0000000000000000000000000000000000000000;;			canceler.CancelRequest(req)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.Errorf("CancelRequest not implemented")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *debuggingRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		reqInfo := newRequestInfo(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rt.levels[debugJustURL] {
0000000000000000000000000000000000000000;;			glog.Infof("%s %s", reqInfo.RequestVerb, reqInfo.RequestURL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt.levels[debugCurlCommand] {
0000000000000000000000000000000000000000;;			glog.Infof("%s", reqInfo.toCurl())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt.levels[debugRequestHeaders] {
0000000000000000000000000000000000000000;;			glog.Infof("Request Headers:")
0000000000000000000000000000000000000000;;			for key, values := range reqInfo.RequestHeaders {
0000000000000000000000000000000000000000;;				for _, value := range values {
0000000000000000000000000000000000000000;;					glog.Infof("    %s: %s", key, value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		startTime := time.Now()
0000000000000000000000000000000000000000;;		response, err := rt.delegatedRoundTripper.RoundTrip(req)
0000000000000000000000000000000000000000;;		reqInfo.Duration = time.Since(startTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reqInfo.complete(response, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rt.levels[debugURLTiming] {
0000000000000000000000000000000000000000;;			glog.Infof("%s %s %s in %d milliseconds", reqInfo.RequestVerb, reqInfo.RequestURL, reqInfo.ResponseStatus, reqInfo.Duration.Nanoseconds()/int64(time.Millisecond))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt.levels[debugResponseStatus] {
0000000000000000000000000000000000000000;;			glog.Infof("Response Status: %s in %d milliseconds", reqInfo.ResponseStatus, reqInfo.Duration.Nanoseconds()/int64(time.Millisecond))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt.levels[debugResponseHeaders] {
0000000000000000000000000000000000000000;;			glog.Infof("Response Headers:")
0000000000000000000000000000000000000000;;			for key, values := range reqInfo.ResponseHeaders {
0000000000000000000000000000000000000000;;				for _, value := range values {
0000000000000000000000000000000000000000;;					glog.Infof("    %s: %s", key, value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return response, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *debuggingRoundTripper) WrappedRoundTripper() http.RoundTripper {
0000000000000000000000000000000000000000;;		return rt.delegatedRoundTripper
0000000000000000000000000000000000000000;;	}
