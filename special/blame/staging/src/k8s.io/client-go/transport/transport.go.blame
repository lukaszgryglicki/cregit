0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/transport/transport.go[staging/src/k8s.io/client-go/1.4/transport/transport.go][staging/src/k8s.io/client-go/transport/transport.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns an http.RoundTripper that will provide the authentication
0000000000000000000000000000000000000000;;	// or transport level security defined by the provided Config.
0000000000000000000000000000000000000000;;	func New(config *Config) (http.RoundTripper, error) {
0000000000000000000000000000000000000000;;		// Set transport level security
0000000000000000000000000000000000000000;;		if config.Transport != nil && (config.HasCA() || config.HasCertAuth() || config.TLS.Insecure) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("using a custom transport with TLS certificate options or the insecure flag is not allowed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			rt  http.RoundTripper
0000000000000000000000000000000000000000;;			err error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.Transport != nil {
0000000000000000000000000000000000000000;;			rt = config.Transport
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rt, err = tlsCache.get(config)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return HTTPWrappersForConfig(config, rt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TLSConfigFor returns a tls.Config that will provide the transport level security defined
0000000000000000000000000000000000000000;;	// by the provided Config. Will return nil if no transport level security is requested.
0000000000000000000000000000000000000000;;	func TLSConfigFor(c *Config) (*tls.Config, error) {
0000000000000000000000000000000000000000;;		if !(c.HasCA() || c.HasCertAuth() || c.TLS.Insecure) {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.HasCA() && c.TLS.Insecure {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("specifying a root certificates file with the insecure flag is not allowed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := loadTLSFiles(c); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tlsConfig := &tls.Config{
0000000000000000000000000000000000000000;;			// Can't use SSLv3 because of POODLE and BEAST
0000000000000000000000000000000000000000;;			// Can't use TLSv1.0 because of POODLE and BEAST using CBC cipher
0000000000000000000000000000000000000000;;			// Can't use TLSv1.1 because of RC4 cipher usage
0000000000000000000000000000000000000000;;			MinVersion:         tls.VersionTLS12,
0000000000000000000000000000000000000000;;			InsecureSkipVerify: c.TLS.Insecure,
0000000000000000000000000000000000000000;;			ServerName:         c.TLS.ServerName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.HasCA() {
0000000000000000000000000000000000000000;;			tlsConfig.RootCAs = rootCertPool(c.TLS.CAData)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.HasCertAuth() {
0000000000000000000000000000000000000000;;			cert, err := tls.X509KeyPair(c.TLS.CertData, c.TLS.KeyData)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConfig.Certificates = []tls.Certificate{cert}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tlsConfig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// loadTLSFiles copies the data from the CertFile, KeyFile, and CAFile fields into the CertData,
0000000000000000000000000000000000000000;;	// KeyData, and CAFile fields, or returns an error. If no error is returned, all three fields are
0000000000000000000000000000000000000000;;	// either populated or were empty to start.
0000000000000000000000000000000000000000;;	func loadTLSFiles(c *Config) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		c.TLS.CAData, err = dataFromSliceOrFile(c.TLS.CAData, c.TLS.CAFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.TLS.CertData, err = dataFromSliceOrFile(c.TLS.CertData, c.TLS.CertFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.TLS.KeyData, err = dataFromSliceOrFile(c.TLS.KeyData, c.TLS.KeyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dataFromSliceOrFile returns data from the slice (if non-empty), or from the file,
0000000000000000000000000000000000000000;;	// or an error if an error occurred reading the file
0000000000000000000000000000000000000000;;	func dataFromSliceOrFile(data []byte, file string) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(data) > 0 {
0000000000000000000000000000000000000000;;			return data, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(file) > 0 {
0000000000000000000000000000000000000000;;			fileData, err := ioutil.ReadFile(file)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []byte{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fileData, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rootCertPool returns nil if caData is empty.  When passed along, this will mean "use system CAs".
0000000000000000000000000000000000000000;;	// When caData is not empty, it will be the ONLY information used in the CertPool.
0000000000000000000000000000000000000000;;	func rootCertPool(caData []byte) *x509.CertPool {
0000000000000000000000000000000000000000;;		// What we really want is a copy of x509.systemRootsPool, but that isn't exposed.  It's difficult to build (see the go
0000000000000000000000000000000000000000;;		// code for a look at the platform specific insanity), so we'll use the fact that RootCAs == nil gives us the system values
0000000000000000000000000000000000000000;;		// It doesn't allow trusting either/or, but hopefully that won't be an issue
0000000000000000000000000000000000000000;;		if len(caData) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we have caData, use it
0000000000000000000000000000000000000000;;		certPool := x509.NewCertPool()
0000000000000000000000000000000000000000;;		certPool.AppendCertsFromPEM(caData)
0000000000000000000000000000000000000000;;		return certPool
0000000000000000000000000000000000000000;;	}
