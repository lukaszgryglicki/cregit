0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/transport/round_trippers_test.go[staging/src/k8s.io/client-go/1.4/transport/round_trippers_test.go][staging/src/k8s.io/client-go/transport/round_trippers_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type testRoundTripper struct {
0000000000000000000000000000000000000000;;		Request  *http.Request
0000000000000000000000000000000000000000;;		Response *http.Response
0000000000000000000000000000000000000000;;		Err      error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rt *testRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		rt.Request = req
0000000000000000000000000000000000000000;;		return rt.Response, rt.Err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBearerAuthRoundTripper(t *testing.T) {
0000000000000000000000000000000000000000;;		rt := &testRoundTripper{}
0000000000000000000000000000000000000000;;		req := &http.Request{}
0000000000000000000000000000000000000000;;		NewBearerAuthRoundTripper("test", rt).RoundTrip(req)
0000000000000000000000000000000000000000;;		if rt.Request == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected nil request: %v", rt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt.Request == req {
0000000000000000000000000000000000000000;;			t.Fatalf("round tripper should have copied request object: %#v", rt.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt.Request.Header.Get("Authorization") != "Bearer test" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected authorization header: %#v", rt.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestBasicAuthRoundTripper(t *testing.T) {
0000000000000000000000000000000000000000;;		for n, tc := range map[string]struct {
0000000000000000000000000000000000000000;;			user string
0000000000000000000000000000000000000000;;			pass string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"basic":   {user: "user", pass: "pass"},
0000000000000000000000000000000000000000;;			"no pass": {user: "user"},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			rt := &testRoundTripper{}
0000000000000000000000000000000000000000;;			req := &http.Request{}
0000000000000000000000000000000000000000;;			NewBasicAuthRoundTripper(tc.user, tc.pass, rt).RoundTrip(req)
0000000000000000000000000000000000000000;;			if rt.Request == nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: unexpected nil request: %v", n, rt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rt.Request == req {
0000000000000000000000000000000000000000;;				t.Fatalf("%s: round tripper should have copied request object: %#v", n, rt.Request)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if user, pass, found := rt.Request.BasicAuth(); !found || user != tc.user || pass != tc.pass {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected authorization header: %#v", n, rt.Request)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestUserAgentRoundTripper(t *testing.T) {
0000000000000000000000000000000000000000;;		rt := &testRoundTripper{}
0000000000000000000000000000000000000000;;		req := &http.Request{
0000000000000000000000000000000000000000;;			Header: make(http.Header),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("User-Agent", "other")
0000000000000000000000000000000000000000;;		NewUserAgentRoundTripper("test", rt).RoundTrip(req)
0000000000000000000000000000000000000000;;		if rt.Request == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected nil request: %v", rt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt.Request != req {
0000000000000000000000000000000000000000;;			t.Fatalf("round tripper should not have copied request object: %#v", rt.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt.Request.Header.Get("User-Agent") != "other" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected user agent header: %#v", rt.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req = &http.Request{}
0000000000000000000000000000000000000000;;		NewUserAgentRoundTripper("test", rt).RoundTrip(req)
0000000000000000000000000000000000000000;;		if rt.Request == nil {
0000000000000000000000000000000000000000;;			t.Fatalf("unexpected nil request: %v", rt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt.Request == req {
0000000000000000000000000000000000000000;;			t.Fatalf("round tripper should have copied request object: %#v", rt.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt.Request.Header.Get("User-Agent") != "test" {
0000000000000000000000000000000000000000;;			t.Errorf("unexpected user agent header: %#v", rt.Request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestImpersonationRoundTripper(t *testing.T) {
0000000000000000000000000000000000000000;;		tcs := []struct {
0000000000000000000000000000000000000000;;			name                string
0000000000000000000000000000000000000000;;			impersonationConfig ImpersonationConfig
0000000000000000000000000000000000000000;;			expected            map[string][]string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "all",
0000000000000000000000000000000000000000;;				impersonationConfig: ImpersonationConfig{
0000000000000000000000000000000000000000;;					UserName: "user",
0000000000000000000000000000000000000000;;					Groups:   []string{"one", "two"},
0000000000000000000000000000000000000000;;					Extra: map[string][]string{
0000000000000000000000000000000000000000;;						"first":  {"A", "a"},
0000000000000000000000000000000000000000;;						"second": {"B", "b"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				expected: map[string][]string{
0000000000000000000000000000000000000000;;					ImpersonateUserHeader:                       {"user"},
0000000000000000000000000000000000000000;;					ImpersonateGroupHeader:                      {"one", "two"},
0000000000000000000000000000000000000000;;					ImpersonateUserExtraHeaderPrefix + "First":  {"A", "a"},
0000000000000000000000000000000000000000;;					ImpersonateUserExtraHeaderPrefix + "Second": {"B", "b"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tcs {
0000000000000000000000000000000000000000;;			rt := &testRoundTripper{}
0000000000000000000000000000000000000000;;			req := &http.Request{
0000000000000000000000000000000000000000;;				Header: make(http.Header),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			NewImpersonatingRoundTripper(tc.impersonationConfig, rt).RoundTrip(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k, v := range rt.Request.Header {
0000000000000000000000000000000000000000;;				expected, ok := tc.expected[k]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Errorf("%v missing %v=%v", tc.name, k, v)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(expected, v) {
0000000000000000000000000000000000000000;;					t.Errorf("%v expected %v: %v, got %v", tc.name, k, expected, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, v := range tc.expected {
0000000000000000000000000000000000000000;;				expected, ok := rt.Request.Header[k]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t.Errorf("%v missing %v=%v", tc.name, k, v)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(expected, v) {
0000000000000000000000000000000000000000;;					t.Errorf("%v expected %v: %v, got %v", tc.name, k, expected, v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAuthProxyRoundTripper(t *testing.T) {
0000000000000000000000000000000000000000;;		for n, tc := range map[string]struct {
0000000000000000000000000000000000000000;;			username string
0000000000000000000000000000000000000000;;			groups   []string
0000000000000000000000000000000000000000;;			extra    map[string][]string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			"allfields": {
0000000000000000000000000000000000000000;;				username: "user",
0000000000000000000000000000000000000000;;				groups:   []string{"groupA", "groupB"},
0000000000000000000000000000000000000000;;				extra: map[string][]string{
0000000000000000000000000000000000000000;;					"one": {"alpha", "bravo"},
0000000000000000000000000000000000000000;;					"two": {"charlie", "delta"},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		} {
0000000000000000000000000000000000000000;;			rt := &testRoundTripper{}
0000000000000000000000000000000000000000;;			req := &http.Request{}
0000000000000000000000000000000000000000;;			NewAuthProxyRoundTripper(tc.username, tc.groups, tc.extra, rt).RoundTrip(req)
0000000000000000000000000000000000000000;;			if rt.Request == nil {
0000000000000000000000000000000000000000;;				t.Errorf("%s: unexpected nil request: %v", n, rt)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rt.Request == req {
0000000000000000000000000000000000000000;;				t.Errorf("%s: round tripper should have copied request object: %#v", n, rt.Request)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actualUsernames, ok := rt.Request.Header["X-Remote-User"]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s missing value", n)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := []string{tc.username}, actualUsernames; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected %v, got %v", n, e, a)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			actualGroups, ok := rt.Request.Header["X-Remote-Group"]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				t.Errorf("%s missing value", n)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := tc.groups, actualGroups; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected %v, got %v", n, e, a)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			actualExtra := map[string][]string{}
0000000000000000000000000000000000000000;;			for key, values := range rt.Request.Header {
0000000000000000000000000000000000000000;;				if strings.HasPrefix(strings.ToLower(key), strings.ToLower("X-Remote-Extra-")) {
0000000000000000000000000000000000000000;;					extraKey := strings.ToLower(key[len("X-Remote-Extra-"):])
0000000000000000000000000000000000000000;;					actualExtra[extraKey] = append(actualExtra[key], values...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e, a := tc.extra, actualExtra; !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;				t.Errorf("%s expected %v, got %v", n, e, a)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
