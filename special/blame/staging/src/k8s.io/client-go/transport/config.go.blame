0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2015 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/transport/config.go[staging/src/k8s.io/client-go/1.4/transport/config.go][staging/src/k8s.io/client-go/transport/config.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package transport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config holds various options for establishing a transport.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// UserAgent is an optional field that specifies the caller of this
0000000000000000000000000000000000000000;;		// request.
0000000000000000000000000000000000000000;;		UserAgent string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The base TLS configuration for this transport.
0000000000000000000000000000000000000000;;		TLS TLSConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Username and password for basic authentication
0000000000000000000000000000000000000000;;		Username string
0000000000000000000000000000000000000000;;		Password string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bearer token for authentication
0000000000000000000000000000000000000000;;		BearerToken string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Impersonate is the config that this Config will impersonate using
0000000000000000000000000000000000000000;;		Impersonate ImpersonationConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Transport may be used for custom HTTP behavior. This attribute may
0000000000000000000000000000000000000000;;		// not be specified with the TLS client certificate options. Use
0000000000000000000000000000000000000000;;		// WrapTransport for most client level operations.
0000000000000000000000000000000000000000;;		Transport http.RoundTripper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WrapTransport will be invoked for custom HTTP behavior after the
0000000000000000000000000000000000000000;;		// underlying transport is initialized (either the transport created
0000000000000000000000000000000000000000;;		// from TLSClientConfig, Transport, or http.DefaultTransport). The
0000000000000000000000000000000000000000;;		// config may layer other RoundTrippers on top of the returned
0000000000000000000000000000000000000000;;		// RoundTripper.
0000000000000000000000000000000000000000;;		WrapTransport func(rt http.RoundTripper) http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImpersonationConfig has all the available impersonation options
0000000000000000000000000000000000000000;;	type ImpersonationConfig struct {
0000000000000000000000000000000000000000;;		// UserName matches user.Info.GetName()
0000000000000000000000000000000000000000;;		UserName string
0000000000000000000000000000000000000000;;		// Groups matches user.Info.GetGroups()
0000000000000000000000000000000000000000;;		Groups []string
0000000000000000000000000000000000000000;;		// Extra matches user.Info.GetExtra()
0000000000000000000000000000000000000000;;		Extra map[string][]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasCA returns whether the configuration has a certificate authority or not.
0000000000000000000000000000000000000000;;	func (c *Config) HasCA() bool {
0000000000000000000000000000000000000000;;		return len(c.TLS.CAData) > 0 || len(c.TLS.CAFile) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasBasicAuth returns whether the configuration has basic authentication or not.
0000000000000000000000000000000000000000;;	func (c *Config) HasBasicAuth() bool {
0000000000000000000000000000000000000000;;		return len(c.Username) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasTokenAuth returns whether the configuration has token authentication or not.
0000000000000000000000000000000000000000;;	func (c *Config) HasTokenAuth() bool {
0000000000000000000000000000000000000000;;		return len(c.BearerToken) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasCertAuth returns whether the configuration has certificate authentication or not.
0000000000000000000000000000000000000000;;	func (c *Config) HasCertAuth() bool {
0000000000000000000000000000000000000000;;		return len(c.TLS.CertData) != 0 || len(c.TLS.CertFile) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TLSConfig holds the information needed to set up a TLS transport.
0000000000000000000000000000000000000000;;	type TLSConfig struct {
0000000000000000000000000000000000000000;;		CAFile   string // Path of the PEM-encoded server trusted root certificates.
0000000000000000000000000000000000000000;;		CertFile string // Path of the PEM-encoded client certificate.
0000000000000000000000000000000000000000;;		KeyFile  string // Path of the PEM-encoded client key.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Insecure   bool   // Server should be accessed without verifying the certificate. For testing only.
0000000000000000000000000000000000000000;;		ServerName string // Override for the server name passed to the server for SNI and used to verify certificates.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CAData   []byte // Bytes of the PEM-encoded server trusted root certificates. Supercedes CAFile.
0000000000000000000000000000000000000000;;		CertData []byte // Bytes of the PEM-encoded client certificate. Supercedes CertFile.
0000000000000000000000000000000000000000;;		KeyData  []byte // Bytes of the PEM-encoded client key. Supercedes KeyFile.
0000000000000000000000000000000000000000;;	}
