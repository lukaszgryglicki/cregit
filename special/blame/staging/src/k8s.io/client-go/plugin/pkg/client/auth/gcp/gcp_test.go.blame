0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
c409b014ea1f485f8bb92a9a6eadc2cc636553b1;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gcp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeOutput struct {
0000000000000000000000000000000000000000;;		args   []string
0000000000000000000000000000000000000000;;		output string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		wantCmd []string
0000000000000000000000000000000000000000;;		// Output for fakeExec, keyed by command
0000000000000000000000000000000000000000;;		execOutputs = map[string]fakeOutput{
0000000000000000000000000000000000000000;;			"/default/no/args": {
0000000000000000000000000000000000000000;;				args: []string{},
0000000000000000000000000000000000000000;;				output: `{
0000000000000000000000000000000000000000;;	  "access_token": "faketoken",
0000000000000000000000000000000000000000;;	  "token_expiry": "2016-10-31T22:31:09.123000000Z"
0000000000000000000000000000000000000000;;	}`},
0000000000000000000000000000000000000000;;			"/default/legacy/args": {
0000000000000000000000000000000000000000;;				args: []string{"arg1", "arg2", "arg3"},
0000000000000000000000000000000000000000;;				output: `{
0000000000000000000000000000000000000000;;	  "access_token": "faketoken",
0000000000000000000000000000000000000000;;	  "token_expiry": "2016-10-31T22:31:09.123000000Z"
0000000000000000000000000000000000000000;;	}`},
0000000000000000000000000000000000000000;;			"/space in path/customkeys": {
0000000000000000000000000000000000000000;;				args: []string{"can", "haz", "auth"},
0000000000000000000000000000000000000000;;				output: `{
0000000000000000000000000000000000000000;;	  "token": "faketoken",
0000000000000000000000000000000000000000;;	  "token_expiry": {
0000000000000000000000000000000000000000;;	    "datetime": "2016-10-31 22:31:09.123"
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}`},
0000000000000000000000000000000000000000;;			"missing/tokenkey/noargs": {
0000000000000000000000000000000000000000;;				args: []string{},
0000000000000000000000000000000000000000;;				output: `{
0000000000000000000000000000000000000000;;	  "broken": "faketoken",
0000000000000000000000000000000000000000;;	  "token_expiry": {
0000000000000000000000000000000000000000;;	    "datetime": "2016-10-31 22:31:09.123000000Z"
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	}`},
0000000000000000000000000000000000000000;;			"missing/expirykey/legacyargs": {
0000000000000000000000000000000000000000;;				args: []string{"split", "on", "whitespace"},
0000000000000000000000000000000000000000;;				output: `{
0000000000000000000000000000000000000000;;	  "access_token": "faketoken",
0000000000000000000000000000000000000000;;	  "expires": "2016-10-31T22:31:09.123000000Z"
0000000000000000000000000000000000000000;;	}`},
0000000000000000000000000000000000000000;;			"invalid expiry/timestamp": {
0000000000000000000000000000000000000000;;				args: []string{"foo", "--bar", "--baz=abc,def"},
0000000000000000000000000000000000000000;;				output: `{
0000000000000000000000000000000000000000;;	  "access_token": "faketoken",
0000000000000000000000000000000000000000;;	  "token_expiry": "sometime soon, idk"
0000000000000000000000000000000000000000;;	}`},
0000000000000000000000000000000000000000;;			"badjson": {
0000000000000000000000000000000000000000;;				args: []string{},
0000000000000000000000000000000000000000;;				output: `{
0000000000000000000000000000000000000000;;	  "access_token": "faketoken",
0000000000000000000000000000000000000000;;	  "token_expiry": "sometime soon, idk"
0000000000000000000000000000000000000000;;	  ------
0000000000000000000000000000000000000000;;	`},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fakeExec(command string, args ...string) *exec.Cmd {
0000000000000000000000000000000000000000;;		cs := []string{"-test.run=TestHelperProcess", "--", command}
0000000000000000000000000000000000000000;;		cs = append(cs, args...)
0000000000000000000000000000000000000000;;		cmd := exec.Command(os.Args[0], cs...)
0000000000000000000000000000000000000000;;		cmd.Env = []string{"GO_WANT_HELPER_PROCESS=1"}
0000000000000000000000000000000000000000;;		return cmd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestHelperProcess(t *testing.T) {
0000000000000000000000000000000000000000;;		if os.Getenv("GO_WANT_HELPER_PROCESS") != "1" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Strip out the leading args used to exec into this function.
0000000000000000000000000000000000000000;;		gotCmd := os.Args[3]
0000000000000000000000000000000000000000;;		gotArgs := os.Args[4:]
0000000000000000000000000000000000000000;;		output, ok := execOutputs[gotCmd]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stdout, "unexpected call cmd=%q args=%v\n", gotCmd, gotArgs)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		} else if !reflect.DeepEqual(output.args, gotArgs) {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stdout, "call cmd=%q got args %v, want: %v\n", gotCmd, gotArgs, output.args)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stdout, output.output)
0000000000000000000000000000000000000000;;		os.Exit(0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func errEquiv(got, want error) bool {
0000000000000000000000000000000000000000;;		if got == want {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if got != nil && want != nil {
0000000000000000000000000000000000000000;;			return strings.Contains(got.Error(), want.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCmdTokenSource(t *testing.T) {
0000000000000000000000000000000000000000;;		execCommand = fakeExec
0000000000000000000000000000000000000000;;		fakeExpiry := time.Date(2016, 10, 31, 22, 31, 9, 123000000, time.UTC)
0000000000000000000000000000000000000000;;		customFmt := "2006-01-02 15:04:05.999999999"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name             string
0000000000000000000000000000000000000000;;			gcpConfig        map[string]string
0000000000000000000000000000000000000000;;			tok              *oauth2.Token
0000000000000000000000000000000000000000;;			newErr, tokenErr error
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"default",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"cmd-path": "/default/no/args",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&oauth2.Token{
0000000000000000000000000000000000000000;;					AccessToken: "faketoken",
0000000000000000000000000000000000000000;;					TokenType:   "Bearer",
0000000000000000000000000000000000000000;;					Expiry:      fakeExpiry,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"default legacy args",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"cmd-path": "/default/legacy/args arg1 arg2 arg3",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&oauth2.Token{
0000000000000000000000000000000000000000;;					AccessToken: "faketoken",
0000000000000000000000000000000000000000;;					TokenType:   "Bearer",
0000000000000000000000000000000000000000;;					Expiry:      fakeExpiry,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"custom keys",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"cmd-path":   "/space in path/customkeys",
0000000000000000000000000000000000000000;;					"cmd-args":   "can haz auth",
0000000000000000000000000000000000000000;;					"token-key":  "{.token}",
0000000000000000000000000000000000000000;;					"expiry-key": "{.token_expiry.datetime}",
0000000000000000000000000000000000000000;;					"time-fmt":   customFmt,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&oauth2.Token{
0000000000000000000000000000000000000000;;					AccessToken: "faketoken",
0000000000000000000000000000000000000000;;					TokenType:   "Bearer",
0000000000000000000000000000000000000000;;					Expiry:      fakeExpiry,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"missing cmd",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"cmd-path": "",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				fmt.Errorf("missing access token cmd"),
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"missing token-key",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"cmd-path":  "missing/tokenkey/noargs",
0000000000000000000000000000000000000000;;					"token-key": "{.token}",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				fmt.Errorf("error parsing token-key %q", "{.token}"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"missing expiry-key",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"cmd-path":   "missing/expirykey/legacyargs split on whitespace",
0000000000000000000000000000000000000000;;					"expiry-key": "{.expiry}",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				fmt.Errorf("error parsing expiry-key %q", "{.expiry}"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"invalid expiry timestamp",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"cmd-path": "invalid expiry/timestamp",
0000000000000000000000000000000000000000;;					"cmd-args": "foo --bar --baz=abc,def",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&oauth2.Token{
0000000000000000000000000000000000000000;;					AccessToken: "faketoken",
0000000000000000000000000000000000000000;;					TokenType:   "Bearer",
0000000000000000000000000000000000000000;;					Expiry:      time.Time{},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"bad JSON",
0000000000000000000000000000000000000000;;				map[string]string{
0000000000000000000000000000000000000000;;					"cmd-path": "badjson",
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				nil,
0000000000000000000000000000000000000000;;				fmt.Errorf("invalid character '-' after object key:value pair"),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tests {
0000000000000000000000000000000000000000;;			provider, err := newGCPAuthProvider("", tc.gcpConfig, nil /* persister */)
0000000000000000000000000000000000000000;;			if !errEquiv(err, tc.newErr) {
0000000000000000000000000000000000000000;;				t.Errorf("%q newGCPAuthProvider error: got %v, want %v", tc.name, err, tc.newErr)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ts := provider.(*gcpAuthProvider).tokenSource.(*cachedTokenSource).source.(*commandTokenSource)
0000000000000000000000000000000000000000;;			wantCmd = append([]string{ts.cmd}, ts.args...)
0000000000000000000000000000000000000000;;			tok, err := ts.Token()
0000000000000000000000000000000000000000;;			if !errEquiv(err, tc.tokenErr) {
0000000000000000000000000000000000000000;;				t.Errorf("%q Token() error: got %v, want %v", tc.name, err, tc.tokenErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reflect.DeepEqual(tok, tc.tok) {
0000000000000000000000000000000000000000;;				t.Errorf("%q Token() got %v, want %v", tc.name, tok, tc.tok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePersister struct {
0000000000000000000000000000000000000000;;		lk    sync.Mutex
0000000000000000000000000000000000000000;;		cache map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePersister) Persist(cache map[string]string) error {
0000000000000000000000000000000000000000;;		f.lk.Lock()
0000000000000000000000000000000000000000;;		defer f.lk.Unlock()
0000000000000000000000000000000000000000;;		f.cache = map[string]string{}
0000000000000000000000000000000000000000;;		for k, v := range cache {
0000000000000000000000000000000000000000;;			f.cache[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakePersister) read() map[string]string {
0000000000000000000000000000000000000000;;		ret := map[string]string{}
0000000000000000000000000000000000000000;;		f.lk.Lock()
0000000000000000000000000000000000000000;;		defer f.lk.Unlock()
0000000000000000000000000000000000000000;;		for k, v := range f.cache {
0000000000000000000000000000000000000000;;			ret[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeTokenSource struct {
0000000000000000000000000000000000000000;;		token *oauth2.Token
0000000000000000000000000000000000000000;;		err   error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fakeTokenSource) Token() (*oauth2.Token, error) {
0000000000000000000000000000000000000000;;		return f.token, f.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestCachedTokenSource(t *testing.T) {
0000000000000000000000000000000000000000;;		tok := &oauth2.Token{AccessToken: "fakeaccesstoken"}
0000000000000000000000000000000000000000;;		persister := &fakePersister{}
0000000000000000000000000000000000000000;;		source := &fakeTokenSource{
0000000000000000000000000000000000000000;;			token: tok,
0000000000000000000000000000000000000000;;			err:   nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cache := map[string]string{
0000000000000000000000000000000000000000;;			"foo": "bar",
0000000000000000000000000000000000000000;;			"baz": "bazinga",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ts, err := newCachedTokenSource("fakeaccesstoken", "", persister, source, cache)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(10)
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i++ {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				_, err := ts.Token()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					t.Errorf("unexpected error: %s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				wg.Done()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Wait()
0000000000000000000000000000000000000000;;		cache["access-token"] = "fakeaccesstoken"
0000000000000000000000000000000000000000;;		cache["expiry"] = tok.Expiry.Format(time.RFC3339Nano)
0000000000000000000000000000000000000000;;		if got := persister.read(); !reflect.DeepEqual(got, cache) {
0000000000000000000000000000000000000000;;			t.Errorf("got cache %v, want %v", got, cache)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MockTransport struct {
0000000000000000000000000000000000000000;;		res *http.Response
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *MockTransport) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return t.res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClearingCredentials(t *testing.T) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeExpiry := time.Now().Add(time.Hour)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache := map[string]string{
0000000000000000000000000000000000000000;;			"access-token": "fakeToken",
0000000000000000000000000000000000000000;;			"expiry":       fakeExpiry.String(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cts := cachedTokenSource{
0000000000000000000000000000000000000000;;			source:      nil,
0000000000000000000000000000000000000000;;			accessToken: cache["access-token"],
0000000000000000000000000000000000000000;;			expiry:      fakeExpiry,
0000000000000000000000000000000000000000;;			persister:   nil,
0000000000000000000000000000000000000000;;			cache:       nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name  string
0000000000000000000000000000000000000000;;			res   http.Response
0000000000000000000000000000000000000000;;			cache map[string]string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Unauthorized",
0000000000000000000000000000000000000000;;				http.Response{StatusCode: 401},
0000000000000000000000000000000000000000;;				make(map[string]string),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				"Authorized",
0000000000000000000000000000000000000000;;				http.Response{StatusCode: 200},
0000000000000000000000000000000000000000;;				cache,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		persister := &fakePersister{}
0000000000000000000000000000000000000000;;		req := http.Request{Header: http.Header{}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tc := range tests {
0000000000000000000000000000000000000000;;			authProvider := gcpAuthProvider{&cts, persister}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fakeTransport := MockTransport{&tc.res}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transport := (authProvider.WrapTransport(&fakeTransport))
0000000000000000000000000000000000000000;;			persister.Persist(cache)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			transport.RoundTrip(&req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if got := persister.read(); !reflect.DeepEqual(got, tc.cache) {
0000000000000000000000000000000000000000;;				t.Errorf("got cache %v, want %v", got, tc.cache)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
