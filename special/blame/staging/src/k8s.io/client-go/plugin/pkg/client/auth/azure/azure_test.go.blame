0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
7bc85960378c0694bf63900c53c3f4e15ad14e5c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest/adal"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestAzureTokenSource(t *testing.T) {
0000000000000000000000000000000000000000;;		fakeAccessToken := "fake token 1"
0000000000000000000000000000000000000000;;		fakeSource := fakeTokenSource{
0000000000000000000000000000000000000000;;			accessToken: fakeAccessToken,
0000000000000000000000000000000000000000;;			expiresOn:   strconv.FormatInt(time.Now().Add(3600*time.Second).Unix(), 10),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfg := make(map[string]string)
0000000000000000000000000000000000000000;;		persiter := &fakePersister{cache: make(map[string]string)}
0000000000000000000000000000000000000000;;		tokenCache := newAzureTokenCache()
0000000000000000000000000000000000000000;;		tokenSource := newAzureTokenSource(&fakeSource, tokenCache, cfg, persiter)
0000000000000000000000000000000000000000;;		token, err := tokenSource.Token()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to retrieve the token form cache: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wantCacheLen := 1
0000000000000000000000000000000000000000;;		if len(tokenCache.cache) != wantCacheLen {
0000000000000000000000000000000000000000;;			t.Errorf("Token() cache length error: got %v, want %v", len(tokenCache.cache), wantCacheLen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if token != tokenCache.cache[azureTokenKey] {
0000000000000000000000000000000000000000;;			t.Error("Token() returned token != cached token")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wantCfg := token2Cfg(token)
0000000000000000000000000000000000000000;;		persistedCfg := persiter.Cache()
0000000000000000000000000000000000000000;;		for k, v := range persistedCfg {
0000000000000000000000000000000000000000;;			if strings.Compare(v, wantCfg[k]) != 0 {
0000000000000000000000000000000000000000;;				t.Errorf("Token() persisted cfg %s: got %v, want %v", k, v, wantCfg[k])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fakeSource.accessToken = "fake token 2"
0000000000000000000000000000000000000000;;		token, err = tokenSource.Token()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("failed to retrieve the cached token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if token.token.AccessToken != fakeAccessToken {
0000000000000000000000000000000000000000;;			t.Errorf("Token() didn't return the cached token")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakePersister struct {
0000000000000000000000000000000000000000;;		lock  sync.Mutex
0000000000000000000000000000000000000000;;		cache map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *fakePersister) Persist(cache map[string]string) error {
0000000000000000000000000000000000000000;;		p.lock.Lock()
0000000000000000000000000000000000000000;;		defer p.lock.Unlock()
0000000000000000000000000000000000000000;;		p.cache = map[string]string{}
0000000000000000000000000000000000000000;;		for k, v := range cache {
0000000000000000000000000000000000000000;;			p.cache[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *fakePersister) Cache() map[string]string {
0000000000000000000000000000000000000000;;		ret := map[string]string{}
0000000000000000000000000000000000000000;;		p.lock.Lock()
0000000000000000000000000000000000000000;;		defer p.lock.Unlock()
0000000000000000000000000000000000000000;;		for k, v := range p.cache {
0000000000000000000000000000000000000000;;			ret[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeTokenSource struct {
0000000000000000000000000000000000000000;;		expiresOn   string
0000000000000000000000000000000000000000;;		accessToken string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *fakeTokenSource) Token() (*azureToken, error) {
0000000000000000000000000000000000000000;;		return &azureToken{
0000000000000000000000000000000000000000;;			token:       newFackeAzureToken(ts.accessToken, ts.expiresOn),
0000000000000000000000000000000000000000;;			clientID:    "fake",
0000000000000000000000000000000000000000;;			tenantID:    "fake",
0000000000000000000000000000000000000000;;			apiserverID: "fake",
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func token2Cfg(token *azureToken) map[string]string {
0000000000000000000000000000000000000000;;		cfg := make(map[string]string)
0000000000000000000000000000000000000000;;		cfg[cfgAccessToken] = token.token.AccessToken
0000000000000000000000000000000000000000;;		cfg[cfgRefreshToken] = token.token.RefreshToken
0000000000000000000000000000000000000000;;		cfg[cfgClientID] = token.clientID
0000000000000000000000000000000000000000;;		cfg[cfgTenantID] = token.tenantID
0000000000000000000000000000000000000000;;		cfg[cfgApiserverID] = token.apiserverID
0000000000000000000000000000000000000000;;		cfg[cfgExpiresIn] = token.token.ExpiresIn
0000000000000000000000000000000000000000;;		cfg[cfgExpiresOn] = token.token.ExpiresOn
0000000000000000000000000000000000000000;;		return cfg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFackeAzureToken(accessToken string, expiresOn string) adal.Token {
0000000000000000000000000000000000000000;;		return adal.Token{
0000000000000000000000000000000000000000;;			AccessToken:  accessToken,
0000000000000000000000000000000000000000;;			RefreshToken: "fake",
0000000000000000000000000000000000000000;;			ExpiresIn:    "3600",
0000000000000000000000000000000000000000;;			ExpiresOn:    expiresOn,
0000000000000000000000000000000000000000;;			NotBefore:    expiresOn,
0000000000000000000000000000000000000000;;			Resource:     "fake",
0000000000000000000000000000000000000000;;			Type:         "fake",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
