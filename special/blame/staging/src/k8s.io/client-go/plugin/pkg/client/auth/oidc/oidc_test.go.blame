0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
56aa78cadcbf7dfd7120e260481bc357739a5448;staging/src/k8s.io/client-go/1.5/plugin/pkg/client/auth/oidc/oidc_test.go[staging/src/k8s.io/client-go/1.5/plugin/pkg/client/auth/oidc/oidc_test.go][staging/src/k8s.io/client-go/plugin/pkg/client/auth/oidc/oidc_test.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package oidc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestJSONTime(t *testing.T) {
0000000000000000000000000000000000000000;;		data := `{
0000000000000000000000000000000000000000;;			"t1": 1493851263,
0000000000000000000000000000000000000000;;			"t2": 1.493851263e9
0000000000000000000000000000000000000000;;		}`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var v struct {
0000000000000000000000000000000000000000;;			T1 jsonTime `json:"t1"`
0000000000000000000000000000000000000000;;			T2 jsonTime `json:"t2"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal([]byte(data), &v); err != nil {
0000000000000000000000000000000000000000;;			t.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wantT1 := time.Unix(1493851263, 0)
0000000000000000000000000000000000000000;;		wantT2 := time.Unix(1493851263, 0)
0000000000000000000000000000000000000000;;		gotT1 := time.Time(v.T1)
0000000000000000000000000000000000000000;;		gotT2 := time.Time(v.T2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !wantT1.Equal(gotT1) {
0000000000000000000000000000000000000000;;			t.Errorf("t1 value: wanted %s got %s", wantT1, gotT1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !wantT2.Equal(gotT2) {
0000000000000000000000000000000000000000;;			t.Errorf("t2 value: wanted %s got %s", wantT2, gotT2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeJWT(header, payload, sig string) string {
0000000000000000000000000000000000000000;;		e := func(s string) string {
0000000000000000000000000000000000000000;;			return base64.RawURLEncoding.EncodeToString([]byte(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return e(header) + "." + e(payload) + "." + e(sig)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestExpired(t *testing.T) {
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nowFunc := func() time.Time { return now }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tests := []struct {
0000000000000000000000000000000000000000;;			name        string
0000000000000000000000000000000000000000;;			idToken     string
0000000000000000000000000000000000000000;;			wantErr     bool
0000000000000000000000000000000000000000;;			wantExpired bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "valid",
0000000000000000000000000000000000000000;;				idToken: encodeJWT(
0000000000000000000000000000000000000000;;					"{}",
0000000000000000000000000000000000000000;;					fmt.Sprintf(`{"exp":%d}`, now.Add(time.Hour).Unix()),
0000000000000000000000000000000000000000;;					"blah", // signature isn't veified.
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "expired",
0000000000000000000000000000000000000000;;				idToken: encodeJWT(
0000000000000000000000000000000000000000;;					"{}",
0000000000000000000000000000000000000000;;					fmt.Sprintf(`{"exp":%d}`, now.Add(-time.Hour).Unix()),
0000000000000000000000000000000000000000;;					"blah", // signature isn't veified.
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				wantExpired: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name: "bad exp claim",
0000000000000000000000000000000000000000;;				idToken: encodeJWT(
0000000000000000000000000000000000000000;;					"{}",
0000000000000000000000000000000000000000;;					`{"exp":"foobar"}`,
0000000000000000000000000000000000000000;;					"blah", // signature isn't veified.
0000000000000000000000000000000000000000;;				),
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				name:    "not an id token",
0000000000000000000000000000000000000000;;				idToken: "notanidtoken",
0000000000000000000000000000000000000000;;				wantErr: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, test := range tests {
0000000000000000000000000000000000000000;;			t.Run(test.name, func(t *testing.T) {
0000000000000000000000000000000000000000;;				valid, err := idTokenExpired(nowFunc, test.idToken)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if !test.wantErr {
0000000000000000000000000000000000000000;;						t.Errorf("parse error: %v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if test.wantExpired == valid {
0000000000000000000000000000000000000000;;					t.Errorf("wanted expired %t, got %", test.wantExpired, !valid)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TestClientCache(t *testing.T) {
0000000000000000000000000000000000000000;;		cache := newClientCache()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := cache.getClient("issuer1", "id1"); ok {
0000000000000000000000000000000000000000;;			t.Fatalf("got client before putting one in the cache")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cli1 := new(oidcAuthProvider)
0000000000000000000000000000000000000000;;		cli2 := new(oidcAuthProvider)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gotcli := cache.setClient("issuer1", "id1", cli1)
0000000000000000000000000000000000000000;;		if cli1 != gotcli {
0000000000000000000000000000000000000000;;			t.Fatalf("set first client and got a different one")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gotcli = cache.setClient("issuer1", "id1", cli2)
0000000000000000000000000000000000000000;;		if cli1 != gotcli {
0000000000000000000000000000000000000000;;			t.Fatalf("set a second client and didn't get the first")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
