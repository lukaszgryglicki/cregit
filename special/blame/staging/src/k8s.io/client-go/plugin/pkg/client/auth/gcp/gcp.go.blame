0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
56aa78cadcbf7dfd7120e260481bc357739a5448;staging/src/k8s.io/client-go/1.5/plugin/pkg/client/auth/gcp/gcp.go[staging/src/k8s.io/client-go/1.5/plugin/pkg/client/auth/gcp/gcp.go][staging/src/k8s.io/client-go/plugin/pkg/client/auth/gcp/gcp.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package gcp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2/google"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/util/yaml"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/jsonpath"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if err := restclient.RegisterAuthProviderPlugin("gcp", newGCPAuthProvider); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to register gcp auth plugin: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stubbable for testing
0000000000000000000000000000000000000000;;	var execCommand = exec.Command
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gcpAuthProvider is an auth provider plugin that uses GCP credentials to provide
0000000000000000000000000000000000000000;;	// tokens for kubectl to authenticate itself to the apiserver. A sample json config
0000000000000000000000000000000000000000;;	// is provided below with all recognized options described.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// {
0000000000000000000000000000000000000000;;	//   'auth-provider': {
0000000000000000000000000000000000000000;;	//     # Required
0000000000000000000000000000000000000000;;	//     "name": "gcp",
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     'config': {
0000000000000000000000000000000000000000;;	//       # Caching options
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       # Raw string data representing cached access token.
0000000000000000000000000000000000000000;;	//       "access-token": "ya29.CjWdA4GiBPTt",
0000000000000000000000000000000000000000;;	//       # RFC3339Nano expiration timestamp for cached access token.
0000000000000000000000000000000000000000;;	//       "expiry": "2016-10-31 22:31:9.123",
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       # Command execution options
0000000000000000000000000000000000000000;;	//       # These options direct the plugin to execute a specified command and parse
0000000000000000000000000000000000000000;;	//       # token and expiry time from the output of the command.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       # Command to execute for access token. Command output will be parsed as JSON.
0000000000000000000000000000000000000000;;	//       # If "cmd-args" is not present, this value will be split on whitespace, with
0000000000000000000000000000000000000000;;	//       # the first element interpreted as the command, remaining elements as args.
0000000000000000000000000000000000000000;;	//       "cmd-path": "/usr/bin/gcloud",
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       # Arguments to pass to command to execute for access token.
0000000000000000000000000000000000000000;;	//       "cmd-args": "config config-helper --output=json"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       # JSONPath to the string field that represents the access token in
0000000000000000000000000000000000000000;;	//       # command output. If omitted, defaults to "{.access_token}".
0000000000000000000000000000000000000000;;	//       "token-key": "{.credential.access_token}",
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       # JSONPath to the string field that represents expiration timestamp
0000000000000000000000000000000000000000;;	//       # of the access token in the command output. If omitted, defaults to
0000000000000000000000000000000000000000;;	//       # "{.token_expiry}"
0000000000000000000000000000000000000000;;	//       "expiry-key": ""{.credential.token_expiry}",
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       # golang reference time in the format that the expiration timestamp uses.
0000000000000000000000000000000000000000;;	//       # If omitted, defaults to time.RFC3339Nano
0000000000000000000000000000000000000000;;	//       "time-fmt": "2006-01-02 15:04:05.999999999"
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type gcpAuthProvider struct {
0000000000000000000000000000000000000000;;		tokenSource oauth2.TokenSource
0000000000000000000000000000000000000000;;		persister   restclient.AuthProviderConfigPersister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newGCPAuthProvider(_ string, gcpConfig map[string]string, persister restclient.AuthProviderConfigPersister) (restclient.AuthProvider, error) {
0000000000000000000000000000000000000000;;		var ts oauth2.TokenSource
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if cmd, useCmd := gcpConfig["cmd-path"]; useCmd {
0000000000000000000000000000000000000000;;			if len(cmd) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("missing access token cmd")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var args []string
0000000000000000000000000000000000000000;;			if cmdArgs, ok := gcpConfig["cmd-args"]; ok {
0000000000000000000000000000000000000000;;				args = strings.Fields(cmdArgs)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fields := strings.Fields(cmd)
0000000000000000000000000000000000000000;;				cmd = fields[0]
0000000000000000000000000000000000000000;;				args = fields[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ts = newCmdTokenSource(cmd, args, gcpConfig["token-key"], gcpConfig["expiry-key"], gcpConfig["time-fmt"])
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ts, err = google.DefaultTokenSource(context.Background(), "https://www.googleapis.com/auth/cloud-platform")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cts, err := newCachedTokenSource(gcpConfig["access-token"], gcpConfig["expiry"], persister, ts, gcpConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &gcpAuthProvider{cts, persister}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *gcpAuthProvider) WrapTransport(rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &conditionalTransport{&oauth2.Transport{Source: g.tokenSource, Base: rt}, g.persister}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *gcpAuthProvider) Login() error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cachedTokenSource struct {
0000000000000000000000000000000000000000;;		lk          sync.Mutex
0000000000000000000000000000000000000000;;		source      oauth2.TokenSource
0000000000000000000000000000000000000000;;		accessToken string
0000000000000000000000000000000000000000;;		expiry      time.Time
0000000000000000000000000000000000000000;;		persister   restclient.AuthProviderConfigPersister
0000000000000000000000000000000000000000;;		cache       map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCachedTokenSource(accessToken, expiry string, persister restclient.AuthProviderConfigPersister, ts oauth2.TokenSource, cache map[string]string) (*cachedTokenSource, error) {
0000000000000000000000000000000000000000;;		var expiryTime time.Time
0000000000000000000000000000000000000000;;		if parsedTime, err := time.Parse(time.RFC3339Nano, expiry); err == nil {
0000000000000000000000000000000000000000;;			expiryTime = parsedTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cache == nil {
0000000000000000000000000000000000000000;;			cache = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &cachedTokenSource{
0000000000000000000000000000000000000000;;			source:      ts,
0000000000000000000000000000000000000000;;			accessToken: accessToken,
0000000000000000000000000000000000000000;;			expiry:      expiryTime,
0000000000000000000000000000000000000000;;			persister:   persister,
0000000000000000000000000000000000000000;;			cache:       cache,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *cachedTokenSource) Token() (*oauth2.Token, error) {
0000000000000000000000000000000000000000;;		tok := t.cachedToken()
0000000000000000000000000000000000000000;;		if tok.Valid() && !tok.Expiry.IsZero() {
0000000000000000000000000000000000000000;;			return tok, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tok, err := t.source.Token()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cache := t.update(tok)
0000000000000000000000000000000000000000;;		if t.persister != nil {
0000000000000000000000000000000000000000;;			if err := t.persister.Persist(cache); err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Failed to persist token: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tok, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *cachedTokenSource) cachedToken() *oauth2.Token {
0000000000000000000000000000000000000000;;		t.lk.Lock()
0000000000000000000000000000000000000000;;		defer t.lk.Unlock()
0000000000000000000000000000000000000000;;		return &oauth2.Token{
0000000000000000000000000000000000000000;;			AccessToken: t.accessToken,
0000000000000000000000000000000000000000;;			TokenType:   "Bearer",
0000000000000000000000000000000000000000;;			Expiry:      t.expiry,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *cachedTokenSource) update(tok *oauth2.Token) map[string]string {
0000000000000000000000000000000000000000;;		t.lk.Lock()
0000000000000000000000000000000000000000;;		defer t.lk.Unlock()
0000000000000000000000000000000000000000;;		t.accessToken = tok.AccessToken
0000000000000000000000000000000000000000;;		t.expiry = tok.Expiry
0000000000000000000000000000000000000000;;		ret := map[string]string{}
0000000000000000000000000000000000000000;;		for k, v := range t.cache {
0000000000000000000000000000000000000000;;			ret[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret["access-token"] = t.accessToken
0000000000000000000000000000000000000000;;		ret["expiry"] = t.expiry.Format(time.RFC3339Nano)
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type commandTokenSource struct {
0000000000000000000000000000000000000000;;		cmd       string
0000000000000000000000000000000000000000;;		args      []string
0000000000000000000000000000000000000000;;		tokenKey  string
0000000000000000000000000000000000000000;;		expiryKey string
0000000000000000000000000000000000000000;;		timeFmt   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCmdTokenSource(cmd string, args []string, tokenKey, expiryKey, timeFmt string) *commandTokenSource {
0000000000000000000000000000000000000000;;		if len(timeFmt) == 0 {
0000000000000000000000000000000000000000;;			timeFmt = time.RFC3339Nano
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(tokenKey) == 0 {
0000000000000000000000000000000000000000;;			tokenKey = "{.access_token}"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(expiryKey) == 0 {
0000000000000000000000000000000000000000;;			expiryKey = "{.token_expiry}"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &commandTokenSource{
0000000000000000000000000000000000000000;;			cmd:       cmd,
0000000000000000000000000000000000000000;;			args:      args,
0000000000000000000000000000000000000000;;			tokenKey:  tokenKey,
0000000000000000000000000000000000000000;;			expiryKey: expiryKey,
0000000000000000000000000000000000000000;;			timeFmt:   timeFmt,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *commandTokenSource) Token() (*oauth2.Token, error) {
0000000000000000000000000000000000000000;;		fullCmd := strings.Join(append([]string{c.cmd}, c.args...), " ")
0000000000000000000000000000000000000000;;		cmd := execCommand(c.cmd, c.args...)
0000000000000000000000000000000000000000;;		output, err := cmd.Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error executing access token command %q: err=%v output=%s", fullCmd, err, output)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token, err := c.parseTokenCmdOutput(output)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing output for access token command %q: %v", fullCmd, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return token, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *commandTokenSource) parseTokenCmdOutput(output []byte) (*oauth2.Token, error) {
0000000000000000000000000000000000000000;;		output, err := yaml.ToJSON(output)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var data interface{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(output, &data); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		accessToken, err := parseJSONPath(data, "token-key", c.tokenKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing token-key %q from %q: %v", c.tokenKey, string(output), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expiryStr, err := parseJSONPath(data, "expiry-key", c.expiryKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing expiry-key %q from %q: %v", c.expiryKey, string(output), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var expiry time.Time
0000000000000000000000000000000000000000;;		if t, err := time.Parse(c.timeFmt, expiryStr); err != nil {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Failed to parse token expiry from %s (fmt=%s): %v", expiryStr, c.timeFmt, err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			expiry = t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &oauth2.Token{
0000000000000000000000000000000000000000;;			AccessToken: accessToken,
0000000000000000000000000000000000000000;;			TokenType:   "Bearer",
0000000000000000000000000000000000000000;;			Expiry:      expiry,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseJSONPath(input interface{}, name, template string) (string, error) {
0000000000000000000000000000000000000000;;		j := jsonpath.New(name)
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		if err := j.Parse(template); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := j.Execute(buf, input); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type conditionalTransport struct {
0000000000000000000000000000000000000000;;		oauthTransport *oauth2.Transport
0000000000000000000000000000000000000000;;		persister      restclient.AuthProviderConfigPersister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *conditionalTransport) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if len(req.Header.Get("Authorization")) != 0 {
0000000000000000000000000000000000000000;;			return t.oauthTransport.Base.RoundTrip(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := t.oauthTransport.RoundTrip(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if res.StatusCode == 401 {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("The credentials that were supplied are invalid for the target cluster")
0000000000000000000000000000000000000000;;			emptyCache := make(map[string]string)
0000000000000000000000000000000000000000;;			t.persister.Persist(emptyCache)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
