0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
56aa78cadcbf7dfd7120e260481bc357739a5448;staging/src/k8s.io/client-go/1.5/plugin/pkg/client/auth/oidc/oidc.go[staging/src/k8s.io/client-go/1.5/plugin/pkg/client/auth/oidc/oidc.go][staging/src/k8s.io/client-go/plugin/pkg/client/auth/oidc/oidc.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package oidc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/oauth2"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cfgIssuerUrl                = "idp-issuer-url"
0000000000000000000000000000000000000000;;		cfgClientID                 = "client-id"
0000000000000000000000000000000000000000;;		cfgClientSecret             = "client-secret"
0000000000000000000000000000000000000000;;		cfgCertificateAuthority     = "idp-certificate-authority"
0000000000000000000000000000000000000000;;		cfgCertificateAuthorityData = "idp-certificate-authority-data"
0000000000000000000000000000000000000000;;		cfgIDToken                  = "id-token"
0000000000000000000000000000000000000000;;		cfgRefreshToken             = "refresh-token"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unused. Scopes aren't sent during refreshing.
0000000000000000000000000000000000000000;;		cfgExtraScopes = "extra-scopes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if err := restclient.RegisterAuthProviderPlugin("oidc", newOIDCAuthProvider); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to register oidc auth plugin: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// expiryDelta determines how earlier a token should be considered
0000000000000000000000000000000000000000;;	// expired than its actual expiration time. It is used to avoid late
0000000000000000000000000000000000000000;;	// expirations due to client-server time mismatches.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE(ericchiang): this is take from golang.org/x/oauth2
0000000000000000000000000000000000000000;;	const expiryDelta = 10 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cache = newClientCache()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Like TLS transports, keep a cache of OIDC clients indexed by issuer URL. This ensures
0000000000000000000000000000000000000000;;	// current requests from different clients don't concurrently attempt to refresh the same
0000000000000000000000000000000000000000;;	// set of credentials.
0000000000000000000000000000000000000000;;	type clientCache struct {
0000000000000000000000000000000000000000;;		mu sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cache map[cacheKey]*oidcAuthProvider
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newClientCache() *clientCache {
0000000000000000000000000000000000000000;;		return &clientCache{cache: make(map[cacheKey]*oidcAuthProvider)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cacheKey struct {
0000000000000000000000000000000000000000;;		// Canonical issuer URL string of the provider.
0000000000000000000000000000000000000000;;		issuerURL string
0000000000000000000000000000000000000000;;		clientID  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *clientCache) getClient(issuer, clientID string) (*oidcAuthProvider, bool) {
0000000000000000000000000000000000000000;;		c.mu.RLock()
0000000000000000000000000000000000000000;;		defer c.mu.RUnlock()
0000000000000000000000000000000000000000;;		client, ok := c.cache[cacheKey{issuer, clientID}]
0000000000000000000000000000000000000000;;		return client, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setClient attempts to put the client in the cache but may return any clients
0000000000000000000000000000000000000000;;	// with the same keys set before. This is so there's only ever one client for a provider.
0000000000000000000000000000000000000000;;	func (c *clientCache) setClient(issuer, clientID string, client *oidcAuthProvider) *oidcAuthProvider {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		defer c.mu.Unlock()
0000000000000000000000000000000000000000;;		key := cacheKey{issuer, clientID}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If another client has already initialized a client for the given provider we want
0000000000000000000000000000000000000000;;		// to use that client instead of the one we're trying to set. This is so all transports
0000000000000000000000000000000000000000;;		// share a client and can coordinate around the same mutex when refreshing and writing
0000000000000000000000000000000000000000;;		// to the kubeconfig.
0000000000000000000000000000000000000000;;		if oldClient, ok := c.cache[key]; ok {
0000000000000000000000000000000000000000;;			return oldClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.cache[key] = client
0000000000000000000000000000000000000000;;		return client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newOIDCAuthProvider(_ string, cfg map[string]string, persister restclient.AuthProviderConfigPersister) (restclient.AuthProvider, error) {
0000000000000000000000000000000000000000;;		issuer := cfg[cfgIssuerUrl]
0000000000000000000000000000000000000000;;		if issuer == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Must provide %s", cfgIssuerUrl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientID := cfg[cfgClientID]
0000000000000000000000000000000000000000;;		if clientID == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Must provide %s", cfgClientID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check cache for existing provider.
0000000000000000000000000000000000000000;;		if provider, ok := cache.getClient(issuer, clientID); ok {
0000000000000000000000000000000000000000;;			return provider, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cfg[cfgExtraScopes]) > 0 {
0000000000000000000000000000000000000000;;			glog.V(2).Infof("%s auth provider field depricated, refresh request don't send scopes",
0000000000000000000000000000000000000000;;				cfgExtraScopes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var certAuthData []byte
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if cfg[cfgCertificateAuthorityData] != "" {
0000000000000000000000000000000000000000;;			certAuthData, err = base64.StdEncoding.DecodeString(cfg[cfgCertificateAuthorityData])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientConfig := restclient.Config{
0000000000000000000000000000000000000000;;			TLSClientConfig: restclient.TLSClientConfig{
0000000000000000000000000000000000000000;;				CAFile: cfg[cfgCertificateAuthority],
0000000000000000000000000000000000000000;;				CAData: certAuthData,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		trans, err := restclient.TransportFor(&clientConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hc := &http.Client{Transport: trans}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		provider := &oidcAuthProvider{
0000000000000000000000000000000000000000;;			client:    hc,
0000000000000000000000000000000000000000;;			now:       time.Now,
0000000000000000000000000000000000000000;;			cfg:       cfg,
0000000000000000000000000000000000000000;;			persister: persister,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cache.setClient(issuer, clientID, provider), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type oidcAuthProvider struct {
0000000000000000000000000000000000000000;;		client *http.Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Method for determining the current time.
0000000000000000000000000000000000000000;;		now func() time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mutex guards persisting to the kubeconfig file and allows synchronized
0000000000000000000000000000000000000000;;		// updates to the in-memory config. It also ensures concurrent calls to
0000000000000000000000000000000000000000;;		// the RoundTripper only trigger a single refresh request.
0000000000000000000000000000000000000000;;		mu        sync.Mutex
0000000000000000000000000000000000000000;;		cfg       map[string]string
0000000000000000000000000000000000000000;;		persister restclient.AuthProviderConfigPersister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *oidcAuthProvider) WrapTransport(rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &roundTripper{
0000000000000000000000000000000000000000;;			wrapped:  rt,
0000000000000000000000000000000000000000;;			provider: p,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *oidcAuthProvider) Login() error {
0000000000000000000000000000000000000000;;		return errors.New("not yet implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type roundTripper struct {
0000000000000000000000000000000000000000;;		provider *oidcAuthProvider
0000000000000000000000000000000000000000;;		wrapped  http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *roundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if len(req.Header.Get("Authorization")) != 0 {
0000000000000000000000000000000000000000;;			return r.wrapped.RoundTrip(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		token, err := r.provider.idToken()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// shallow copy of the struct
0000000000000000000000000000000000000000;;		r2 := new(http.Request)
0000000000000000000000000000000000000000;;		*r2 = *req
0000000000000000000000000000000000000000;;		// deep copy of the Header so we don't modify the original
0000000000000000000000000000000000000000;;		// request's Header (as per RoundTripper contract).
0000000000000000000000000000000000000000;;		r2.Header = make(http.Header)
0000000000000000000000000000000000000000;;		for k, s := range req.Header {
0000000000000000000000000000000000000000;;			r2.Header[k] = s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r2.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.wrapped.RoundTrip(r2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *oidcAuthProvider) idToken() (string, error) {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if idToken, ok := p.cfg[cfgIDToken]; ok && len(idToken) > 0 {
0000000000000000000000000000000000000000;;			valid, err := idTokenExpired(p.now, idToken)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if valid {
0000000000000000000000000000000000000000;;				// If the cached id token is still valid use it.
0000000000000000000000000000000000000000;;				return idToken, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to request a new token using the refresh token.
0000000000000000000000000000000000000000;;		rt, ok := p.cfg[cfgRefreshToken]
0000000000000000000000000000000000000000;;		if !ok || len(rt) == 0 {
0000000000000000000000000000000000000000;;			return "", errors.New("No valid id-token, and cannot refresh without refresh-token")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine provider's OAuth2 token endpoint.
0000000000000000000000000000000000000000;;		tokenURL, err := tokenEndpoint(p.client, p.cfg[cfgIssuerUrl])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := oauth2.Config{
0000000000000000000000000000000000000000;;			ClientID:     p.cfg[cfgClientID],
0000000000000000000000000000000000000000;;			ClientSecret: p.cfg[cfgClientSecret],
0000000000000000000000000000000000000000;;			Endpoint:     oauth2.Endpoint{TokenURL: tokenURL},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx := context.WithValue(context.Background(), oauth2.HTTPClient, p.client)
0000000000000000000000000000000000000000;;		token, err := config.TokenSource(ctx, &oauth2.Token{RefreshToken: rt}).Token()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to refresh token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		idToken, ok := token.Extra("id_token").(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("token response did not contain an id_token")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new config to persist.
0000000000000000000000000000000000000000;;		newCfg := make(map[string]string)
0000000000000000000000000000000000000000;;		for key, val := range p.cfg {
0000000000000000000000000000000000000000;;			newCfg[key] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the refresh token if the server returned another one.
0000000000000000000000000000000000000000;;		if token.RefreshToken != "" && token.RefreshToken != rt {
0000000000000000000000000000000000000000;;			newCfg[cfgRefreshToken] = token.RefreshToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newCfg[cfgIDToken] = idToken
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Persist new config and if successful, update the in memory config.
0000000000000000000000000000000000000000;;		if err = p.persister.Persist(newCfg); err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("could not perist new tokens: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.cfg = newCfg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return idToken, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tokenEndpoint uses OpenID Connect discovery to determine the OAuth2 token
0000000000000000000000000000000000000000;;	// endpoint for the provider, the endpoint the client will use the refresh
0000000000000000000000000000000000000000;;	// token against.
0000000000000000000000000000000000000000;;	func tokenEndpoint(client *http.Client, issuer string) (string, error) {
0000000000000000000000000000000000000000;;		// Well known URL for getting OpenID Connect metadata.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig
0000000000000000000000000000000000000000;;		wellKnown := strings.TrimSuffix(issuer, "/") + "/.well-known/openid-configuration"
0000000000000000000000000000000000000000;;		resp, err := client.Get(wellKnown)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			// Don't produce an error that's too huge (e.g. if we get HTML back for some reason).
0000000000000000000000000000000000000000;;			const n = 80
0000000000000000000000000000000000000000;;			if len(body) > n {
0000000000000000000000000000000000000000;;				body = append(body[:n], []byte("...")...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("oidc: failed to query metadata endpoint %s: %q", resp.Status, body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Metadata object. We only care about the token_endpoint, the thing endpoint
0000000000000000000000000000000000000000;;		// we'll be refreshing against.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata
0000000000000000000000000000000000000000;;		var metadata struct {
0000000000000000000000000000000000000000;;			TokenURL string `json:"token_endpoint"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(body, &metadata); err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("oidc: failed to decode provider discovery object: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if metadata.TokenURL == "" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("oidc: discovery object doesn't contain a token_endpoint")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metadata.TokenURL, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func idTokenExpired(now func() time.Time, idToken string) (bool, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(idToken, ".")
0000000000000000000000000000000000000000;;		if len(parts) != 3 {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("ID Token is not a valid JWT")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		payload, err := base64.RawURLEncoding.DecodeString(parts[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var claims struct {
0000000000000000000000000000000000000000;;			Expiry jsonTime `json:"exp"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(payload, &claims); err != nil {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("parsing claims: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return now().Add(expiryDelta).Before(time.Time(claims.Expiry)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// jsonTime is a json.Unmarshaler that parses a unix timestamp.
0000000000000000000000000000000000000000;;	// Because JSON numbers don't differentiate between ints and floats,
0000000000000000000000000000000000000000;;	// we want to ensure we can parse either.
0000000000000000000000000000000000000000;;	type jsonTime time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *jsonTime) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var n json.Number
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &n); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var unix int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t, err := n.Int64(); err == nil {
0000000000000000000000000000000000000000;;			unix = t
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f, err := n.Float64()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unix = int64(f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*j = jsonTime(time.Unix(unix, 0))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j jsonTime) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return json.Marshal(time.Time(j).Unix())
0000000000000000000000000000000000000000;;	}
