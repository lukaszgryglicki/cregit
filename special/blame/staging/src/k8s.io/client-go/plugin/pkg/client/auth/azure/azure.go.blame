0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2017 The Kubernetes Authors.
7bc85960378c0694bf63900c53c3f4e15ad14e5c;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package azure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest/adal"
0000000000000000000000000000000000000000;;		"github.com/Azure/go-autorest/autorest/azure"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		azureTokenKey = "azureTokenKey"
0000000000000000000000000000000000000000;;		tokenType     = "Bearer"
0000000000000000000000000000000000000000;;		authHeader    = "Authorization"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfgClientID     = "client-id"
0000000000000000000000000000000000000000;;		cfgTenantID     = "tenant-id"
0000000000000000000000000000000000000000;;		cfgAccessToken  = "access-token"
0000000000000000000000000000000000000000;;		cfgRefreshToken = "refresh-token"
0000000000000000000000000000000000000000;;		cfgExpiresIn    = "expires-in"
0000000000000000000000000000000000000000;;		cfgExpiresOn    = "expires-on"
0000000000000000000000000000000000000000;;		cfgEnvironment  = "environment"
0000000000000000000000000000000000000000;;		cfgApiserverID  = "apiserver-id"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if err := restclient.RegisterAuthProviderPlugin("azure", newAzureAuthProvider); err != nil {
0000000000000000000000000000000000000000;;			glog.Fatalf("Failed to register azure auth plugin: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cache = newAzureTokenCache()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureTokenCache struct {
0000000000000000000000000000000000000000;;		lock  sync.Mutex
0000000000000000000000000000000000000000;;		cache map[string]*azureToken
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAzureTokenCache() *azureTokenCache {
0000000000000000000000000000000000000000;;		return &azureTokenCache{cache: make(map[string]*azureToken)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *azureTokenCache) getToken(tokenKey string) *azureToken {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		return c.cache[tokenKey]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *azureTokenCache) setToken(tokenKey string, token *azureToken) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.cache[tokenKey] = token
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAzureAuthProvider(_ string, cfg map[string]string, persister restclient.AuthProviderConfigPersister) (restclient.AuthProvider, error) {
0000000000000000000000000000000000000000;;		var ts tokenSource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		environment, err := azure.EnvironmentFromName(cfg[cfgEnvironment])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			environment = azure.PublicCloud
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ts, err = newAzureTokenSourceDeviceCode(environment, cfg[cfgClientID], cfg[cfgTenantID], cfg[cfgApiserverID])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("creating a new azure token source for device code authentication: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cacheSource := newAzureTokenSource(ts, cache, cfg, persister)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &azureAuthProvider{
0000000000000000000000000000000000000000;;			tokenSource: cacheSource,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureAuthProvider struct {
0000000000000000000000000000000000000000;;		tokenSource tokenSource
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *azureAuthProvider) Login() error {
0000000000000000000000000000000000000000;;		return errors.New("not yet implemented")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *azureAuthProvider) WrapTransport(rt http.RoundTripper) http.RoundTripper {
0000000000000000000000000000000000000000;;		return &azureRoundTripper{
0000000000000000000000000000000000000000;;			tokenSource:  p.tokenSource,
0000000000000000000000000000000000000000;;			roundTripper: rt,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureRoundTripper struct {
0000000000000000000000000000000000000000;;		tokenSource  tokenSource
0000000000000000000000000000000000000000;;		roundTripper http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *azureRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if len(req.Header.Get(authHeader)) != 0 {
0000000000000000000000000000000000000000;;			return r.roundTripper.RoundTrip(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token, err := r.tokenSource.Token()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to acquire a token: %v", err)
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("acquiring a token for authorization header: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// clone the request in order to avoid modifying the headers of the original request
0000000000000000000000000000000000000000;;		req2 := new(http.Request)
0000000000000000000000000000000000000000;;		*req2 = *req
0000000000000000000000000000000000000000;;		req2.Header = make(http.Header, len(req.Header))
0000000000000000000000000000000000000000;;		for k, s := range req.Header {
0000000000000000000000000000000000000000;;			req2.Header[k] = append([]string(nil), s...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req2.Header.Set(authHeader, fmt.Sprintf("%s %s", tokenType, token.token.AccessToken))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.roundTripper.RoundTrip(req2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureToken struct {
0000000000000000000000000000000000000000;;		token       adal.Token
0000000000000000000000000000000000000000;;		clientID    string
0000000000000000000000000000000000000000;;		tenantID    string
0000000000000000000000000000000000000000;;		apiserverID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tokenSource interface {
0000000000000000000000000000000000000000;;		Token() (*azureToken, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureTokenSource struct {
0000000000000000000000000000000000000000;;		source    tokenSource
0000000000000000000000000000000000000000;;		cache     *azureTokenCache
0000000000000000000000000000000000000000;;		lock      sync.Mutex
0000000000000000000000000000000000000000;;		cfg       map[string]string
0000000000000000000000000000000000000000;;		persister restclient.AuthProviderConfigPersister
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAzureTokenSource(source tokenSource, cache *azureTokenCache, cfg map[string]string, persister restclient.AuthProviderConfigPersister) tokenSource {
0000000000000000000000000000000000000000;;		return &azureTokenSource{
0000000000000000000000000000000000000000;;			source:    source,
0000000000000000000000000000000000000000;;			cache:     cache,
0000000000000000000000000000000000000000;;			cfg:       cfg,
0000000000000000000000000000000000000000;;			persister: persister,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token fetches a token from the cache of configuration if present otherwise
0000000000000000000000000000000000000000;;	// acquires a new token from the configured source. Automatically refreshes
0000000000000000000000000000000000000000;;	// the token if expired.
0000000000000000000000000000000000000000;;	func (ts *azureTokenSource) Token() (*azureToken, error) {
0000000000000000000000000000000000000000;;		ts.lock.Lock()
0000000000000000000000000000000000000000;;		defer ts.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		token := ts.cache.getToken(azureTokenKey)
0000000000000000000000000000000000000000;;		if token == nil {
0000000000000000000000000000000000000000;;			token, err = ts.retrieveTokenFromCfg()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				token, err = ts.source.Token()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("acquiring a new fresh token: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !token.token.IsExpired() {
0000000000000000000000000000000000000000;;				ts.cache.setToken(azureTokenKey, token)
0000000000000000000000000000000000000000;;				err = ts.storeTokenInCfg(token)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("storing the token in configuration: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if token.token.IsExpired() {
0000000000000000000000000000000000000000;;			token, err = ts.refreshToken(token)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("refreshing the expired token: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ts.cache.setToken(azureTokenKey, token)
0000000000000000000000000000000000000000;;			err = ts.storeTokenInCfg(token)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("storing the refreshed token in configuration: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return token, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *azureTokenSource) retrieveTokenFromCfg() (*azureToken, error) {
0000000000000000000000000000000000000000;;		accessToken := ts.cfg[cfgAccessToken]
0000000000000000000000000000000000000000;;		if accessToken == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no access token in cfg: %s", cfgAccessToken)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		refreshToken := ts.cfg[cfgRefreshToken]
0000000000000000000000000000000000000000;;		if refreshToken == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no refresh token in cfg: %s", cfgRefreshToken)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clientID := ts.cfg[cfgClientID]
0000000000000000000000000000000000000000;;		if clientID == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no client ID in cfg: %s", cfgClientID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tenantID := ts.cfg[cfgTenantID]
0000000000000000000000000000000000000000;;		if tenantID == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no tenant ID in cfg: %s", cfgTenantID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiserverID := ts.cfg[cfgApiserverID]
0000000000000000000000000000000000000000;;		if apiserverID == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no apiserver ID in cfg: %s", apiserverID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expiresIn := ts.cfg[cfgExpiresIn]
0000000000000000000000000000000000000000;;		if expiresIn == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no expiresIn in cfg: %s", cfgExpiresIn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expiresOn := ts.cfg[cfgExpiresOn]
0000000000000000000000000000000000000000;;		if expiresOn == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no expiresOn in cfg: %s", cfgExpiresOn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &azureToken{
0000000000000000000000000000000000000000;;			token: adal.Token{
0000000000000000000000000000000000000000;;				AccessToken:  accessToken,
0000000000000000000000000000000000000000;;				RefreshToken: refreshToken,
0000000000000000000000000000000000000000;;				ExpiresIn:    expiresIn,
0000000000000000000000000000000000000000;;				ExpiresOn:    expiresOn,
0000000000000000000000000000000000000000;;				NotBefore:    expiresOn,
0000000000000000000000000000000000000000;;				Resource:     fmt.Sprintf("spn:%s", apiserverID),
0000000000000000000000000000000000000000;;				Type:         tokenType,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			clientID:    clientID,
0000000000000000000000000000000000000000;;			tenantID:    tenantID,
0000000000000000000000000000000000000000;;			apiserverID: apiserverID,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *azureTokenSource) storeTokenInCfg(token *azureToken) error {
0000000000000000000000000000000000000000;;		newCfg := make(map[string]string)
0000000000000000000000000000000000000000;;		newCfg[cfgAccessToken] = token.token.AccessToken
0000000000000000000000000000000000000000;;		newCfg[cfgRefreshToken] = token.token.RefreshToken
0000000000000000000000000000000000000000;;		newCfg[cfgClientID] = token.clientID
0000000000000000000000000000000000000000;;		newCfg[cfgTenantID] = token.tenantID
0000000000000000000000000000000000000000;;		newCfg[cfgApiserverID] = token.apiserverID
0000000000000000000000000000000000000000;;		newCfg[cfgExpiresIn] = token.token.ExpiresIn
0000000000000000000000000000000000000000;;		newCfg[cfgExpiresOn] = token.token.ExpiresOn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := ts.persister.Persist(newCfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("persisting the configuration: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ts.cfg = newCfg
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *azureTokenSource) refreshToken(token *azureToken) (*azureToken, error) {
0000000000000000000000000000000000000000;;		oauthConfig, err := adal.NewOAuthConfig(azure.PublicCloud.ActiveDirectoryEndpoint, token.tenantID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("building the OAuth configuration for token refresh: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		callback := func(t adal.Token) error {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		spt, err := adal.NewServicePrincipalTokenFromManualToken(
0000000000000000000000000000000000000000;;			*oauthConfig,
0000000000000000000000000000000000000000;;			token.clientID,
0000000000000000000000000000000000000000;;			token.apiserverID,
0000000000000000000000000000000000000000;;			token.token,
0000000000000000000000000000000000000000;;			callback)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("creating new service principal for token refresh: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := spt.Refresh(); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("refreshing token: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &azureToken{
0000000000000000000000000000000000000000;;			token:       spt.Token,
0000000000000000000000000000000000000000;;			clientID:    token.clientID,
0000000000000000000000000000000000000000;;			tenantID:    token.tenantID,
0000000000000000000000000000000000000000;;			apiserverID: token.apiserverID,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type azureTokenSourceDeviceCode struct {
0000000000000000000000000000000000000000;;		environment azure.Environment
0000000000000000000000000000000000000000;;		clientID    string
0000000000000000000000000000000000000000;;		tenantID    string
0000000000000000000000000000000000000000;;		apiserverID string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAzureTokenSourceDeviceCode(environment azure.Environment, clientID string, tenantID string, apiserverID string) (tokenSource, error) {
0000000000000000000000000000000000000000;;		if clientID == "" {
0000000000000000000000000000000000000000;;			return nil, errors.New("client-id is empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tenantID == "" {
0000000000000000000000000000000000000000;;			return nil, errors.New("tenant-id is empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiserverID == "" {
0000000000000000000000000000000000000000;;			return nil, errors.New("apiserver-id is empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &azureTokenSourceDeviceCode{
0000000000000000000000000000000000000000;;			environment: environment,
0000000000000000000000000000000000000000;;			clientID:    clientID,
0000000000000000000000000000000000000000;;			tenantID:    tenantID,
0000000000000000000000000000000000000000;;			apiserverID: apiserverID,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ts *azureTokenSourceDeviceCode) Token() (*azureToken, error) {
0000000000000000000000000000000000000000;;		oauthConfig, err := adal.NewOAuthConfig(ts.environment.ActiveDirectoryEndpoint, ts.tenantID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("building the OAuth configuration for device code authentication: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client := &autorest.Client{}
0000000000000000000000000000000000000000;;		deviceCode, err := adal.InitiateDeviceAuth(client, *oauthConfig, ts.clientID, ts.apiserverID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("initialing the device code authentication: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = fmt.Fprintln(os.Stderr, *deviceCode.Message)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("prompting the device code message: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		token, err := adal.WaitForUserCompletion(client, deviceCode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("waiting for device code authentication to complete: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &azureToken{
0000000000000000000000000000000000000000;;			token:       *token,
0000000000000000000000000000000000000000;;			clientID:    ts.clientID,
0000000000000000000000000000000000000000;;			tenantID:    ts.tenantID,
0000000000000000000000000000000000000000;;			apiserverID: ts.apiserverID,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
