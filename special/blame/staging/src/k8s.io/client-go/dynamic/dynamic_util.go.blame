0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/dynamic/dynamic_util.go[staging/src/k8s.io/client-go/1.4/dynamic/dynamic_util.go][staging/src/k8s.io/client-go/dynamic/dynamic_util.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dynamic
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VersionInterfaces provides an object converter and metadata
0000000000000000000000000000000000000000;;	// accessor appropriate for use with unstructured objects.
0000000000000000000000000000000000000000;;	func VersionInterfaces(schema.GroupVersion) (*meta.VersionInterfaces, error) {
0000000000000000000000000000000000000000;;		return &meta.VersionInterfaces{
0000000000000000000000000000000000000000;;			ObjectConvertor:  &unstructured.UnstructuredObjectConverter{},
0000000000000000000000000000000000000000;;			MetadataAccessor: meta.NewAccessor(),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDiscoveryRESTMapper returns a RESTMapper based on discovery information.
0000000000000000000000000000000000000000;;	func NewDiscoveryRESTMapper(resources []*metav1.APIResourceList, versionFunc meta.VersionInterfacesFunc) (*meta.DefaultRESTMapper, error) {
0000000000000000000000000000000000000000;;		rm := meta.NewDefaultRESTMapper(nil, versionFunc)
0000000000000000000000000000000000000000;;		for _, resourceList := range resources {
0000000000000000000000000000000000000000;;			gv, err := schema.ParseGroupVersion(resourceList.GroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, resource := range resourceList.APIResources {
0000000000000000000000000000000000000000;;				gvk := gv.WithKind(resource.Kind)
0000000000000000000000000000000000000000;;				scope := meta.RESTScopeRoot
0000000000000000000000000000000000000000;;				if resource.Namespaced {
0000000000000000000000000000000000000000;;					scope = meta.RESTScopeNamespace
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rm.Add(gvk, scope)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rm, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectTyper provides an ObjectTyper implementation for
0000000000000000000000000000000000000000;;	// unstructured.Unstructured object based on discovery information.
0000000000000000000000000000000000000000;;	type ObjectTyper struct {
0000000000000000000000000000000000000000;;		registered map[schema.GroupVersionKind]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewObjectTyper constructs an ObjectTyper from discovery information.
0000000000000000000000000000000000000000;;	func NewObjectTyper(resources []*metav1.APIResourceList) (runtime.ObjectTyper, error) {
0000000000000000000000000000000000000000;;		ot := &ObjectTyper{registered: make(map[schema.GroupVersionKind]bool)}
0000000000000000000000000000000000000000;;		for _, resourceList := range resources {
0000000000000000000000000000000000000000;;			gv, err := schema.ParseGroupVersion(resourceList.GroupVersion)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, resource := range resourceList.APIResources {
0000000000000000000000000000000000000000;;				ot.registered[gv.WithKind(resource.Kind)] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ot, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectKinds returns a slice of one element with the
0000000000000000000000000000000000000000;;	// group,version,kind of the provided object, or an error if the
0000000000000000000000000000000000000000;;	// object is not *unstructured.Unstructured or has no group,version,kind
0000000000000000000000000000000000000000;;	// information.
0000000000000000000000000000000000000000;;	func (ot *ObjectTyper) ObjectKinds(obj runtime.Object) ([]schema.GroupVersionKind, bool, error) {
0000000000000000000000000000000000000000;;		if _, ok := obj.(*unstructured.Unstructured); !ok {
0000000000000000000000000000000000000000;;			return nil, false, fmt.Errorf("type %T is invalid for dynamic object typer", obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []schema.GroupVersionKind{obj.GetObjectKind().GroupVersionKind()}, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recognizes returns true if the provided group,version,kind was in
0000000000000000000000000000000000000000;;	// the discovery information.
0000000000000000000000000000000000000000;;	func (ot *ObjectTyper) Recognizes(gvk schema.GroupVersionKind) bool {
0000000000000000000000000000000000000000;;		return ot.registered[gvk]
0000000000000000000000000000000000000000;;	}
