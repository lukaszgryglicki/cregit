0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/dynamic/client_pool.go[staging/src/k8s.io/client-go/1.4/dynamic/client_pool.go][staging/src/k8s.io/client-go/dynamic/client_pool.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package dynamic
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/api/meta"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientPool manages a pool of dynamic clients.
0000000000000000000000000000000000000000;;	type ClientPool interface {
0000000000000000000000000000000000000000;;		// ClientForGroupVersionKind returns a client configured for the specified groupVersionResource.
0000000000000000000000000000000000000000;;		// Resource may be empty.
0000000000000000000000000000000000000000;;		ClientForGroupVersionResource(resource schema.GroupVersionResource) (*Client, error)
0000000000000000000000000000000000000000;;		// ClientForGroupVersionKind returns a client configured for the specified groupVersionKind.
0000000000000000000000000000000000000000;;		// Kind may be empty.
0000000000000000000000000000000000000000;;		ClientForGroupVersionKind(kind schema.GroupVersionKind) (*Client, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// APIPathResolverFunc knows how to convert a groupVersion to its API path. The Kind field is
0000000000000000000000000000000000000000;;	// optional.
0000000000000000000000000000000000000000;;	type APIPathResolverFunc func(kind schema.GroupVersionKind) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LegacyAPIPathResolverFunc can resolve paths properly with the legacy API.
0000000000000000000000000000000000000000;;	func LegacyAPIPathResolverFunc(kind schema.GroupVersionKind) string {
0000000000000000000000000000000000000000;;		if len(kind.Group) == 0 {
0000000000000000000000000000000000000000;;			return "/api"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "/apis"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clientPoolImpl implements ClientPool and caches clients for the resource group versions
0000000000000000000000000000000000000000;;	// is asked to retrieve. This type is thread safe.
0000000000000000000000000000000000000000;;	type clientPoolImpl struct {
0000000000000000000000000000000000000000;;		lock                sync.RWMutex
0000000000000000000000000000000000000000;;		config              *restclient.Config
0000000000000000000000000000000000000000;;		clients             map[schema.GroupVersion]*Client
0000000000000000000000000000000000000000;;		apiPathResolverFunc APIPathResolverFunc
0000000000000000000000000000000000000000;;		mapper              meta.RESTMapper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientPool returns a ClientPool from the specified config. It reuses clients for the the same
0000000000000000000000000000000000000000;;	// group version. It is expected this type may be wrapped by specific logic that special cases certain
0000000000000000000000000000000000000000;;	// resources or groups.
0000000000000000000000000000000000000000;;	func NewClientPool(config *restclient.Config, mapper meta.RESTMapper, apiPathResolverFunc APIPathResolverFunc) ClientPool {
0000000000000000000000000000000000000000;;		confCopy := *config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &clientPoolImpl{
0000000000000000000000000000000000000000;;			config:              &confCopy,
0000000000000000000000000000000000000000;;			clients:             map[schema.GroupVersion]*Client{},
0000000000000000000000000000000000000000;;			apiPathResolverFunc: apiPathResolverFunc,
0000000000000000000000000000000000000000;;			mapper:              mapper,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instantiates a new dynamic client pool with the given config.
0000000000000000000000000000000000000000;;	func NewDynamicClientPool(cfg *restclient.Config) ClientPool {
0000000000000000000000000000000000000000;;		// restMapper is not needed when using LegacyAPIPathResolverFunc
0000000000000000000000000000000000000000;;		emptyMapper := meta.MultiRESTMapper{}
0000000000000000000000000000000000000000;;		return NewClientPool(cfg, emptyMapper, LegacyAPIPathResolverFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientForGroupVersionResource uses the provided RESTMapper to identify the appropriate resource. Resource may
0000000000000000000000000000000000000000;;	// be empty. If no matching kind is found the underlying client for that group is still returned.
0000000000000000000000000000000000000000;;	func (c *clientPoolImpl) ClientForGroupVersionResource(resource schema.GroupVersionResource) (*Client, error) {
0000000000000000000000000000000000000000;;		kinds, err := c.mapper.KindsFor(resource)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if meta.IsNoMatchError(err) {
0000000000000000000000000000000000000000;;				return c.ClientForGroupVersionKind(schema.GroupVersionKind{Group: resource.Group, Version: resource.Version})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.ClientForGroupVersionKind(kinds[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientForGroupVersion returns a client for the specified groupVersion, creates one if none exists. Kind
0000000000000000000000000000000000000000;;	// in the GroupVersionKind may be empty.
0000000000000000000000000000000000000000;;	func (c *clientPoolImpl) ClientForGroupVersionKind(kind schema.GroupVersionKind) (*Client, error) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gv := kind.GroupVersion()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do we have a client already configured?
0000000000000000000000000000000000000000;;		if existingClient, found := c.clients[gv]; found {
0000000000000000000000000000000000000000;;			return existingClient, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// avoid changing the original config
0000000000000000000000000000000000000000;;		confCopy := *c.config
0000000000000000000000000000000000000000;;		conf := &confCopy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we need to set the api path based on group version, if no group, default to legacy path
0000000000000000000000000000000000000000;;		conf.APIPath = c.apiPathResolverFunc(kind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we need to make a client
0000000000000000000000000000000000000000;;		conf.GroupVersion = &gv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dynamicClient, err := NewClient(conf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.clients[gv] = dynamicClient
0000000000000000000000000000000000000000;;		return dynamicClient, nil
0000000000000000000000000000000000000000;;	}
