0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2016 The Kubernetes Authors.
7ae9f03395c6627a081201b94a92727a999ac034;staging/src/k8s.io/client-go/1.4/dynamic/client.go[staging/src/k8s.io/client-go/1.4/dynamic/client.go][staging/src/k8s.io/client-go/dynamic/client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package dynamic provides a client interface to arbitrary Kubernetes
0000000000000000000000000000000000000000;;	// APIs that exposes common high level operations and exposes common
0000000000000000000000000000000000000000;;	// metadata.
0000000000000000000000000000000000000000;;	package dynamic
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"k8s.io/api/core/v1"
0000000000000000000000000000000000000000;;		metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/conversion/queryparams"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/schema"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/runtime/serializer"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/types"
0000000000000000000000000000000000000000;;		"k8s.io/apimachinery/pkg/watch"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/kubernetes/scheme"
0000000000000000000000000000000000000000;;		restclient "k8s.io/client-go/rest"
0000000000000000000000000000000000000000;;		"k8s.io/client-go/util/flowcontrol"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client is a Kubernetes client that allows you to access metadata
0000000000000000000000000000000000000000;;	// and manipulate metadata of a Kubernetes API group.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		cl             *restclient.RESTClient
0000000000000000000000000000000000000000;;		parameterCodec runtime.ParameterCodec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient returns a new client based on the passed in config. The
0000000000000000000000000000000000000000;;	// codec is ignored, as the dynamic client uses it's own codec.
0000000000000000000000000000000000000000;;	func NewClient(conf *restclient.Config) (*Client, error) {
0000000000000000000000000000000000000000;;		// avoid changing the original config
0000000000000000000000000000000000000000;;		confCopy := *conf
0000000000000000000000000000000000000000;;		conf = &confCopy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contentConfig := ContentConfig()
0000000000000000000000000000000000000000;;		contentConfig.GroupVersion = conf.GroupVersion
0000000000000000000000000000000000000000;;		if conf.NegotiatedSerializer != nil {
0000000000000000000000000000000000000000;;			contentConfig.NegotiatedSerializer = conf.NegotiatedSerializer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conf.ContentConfig = contentConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if conf.APIPath == "" {
0000000000000000000000000000000000000000;;			conf.APIPath = "/api"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(conf.UserAgent) == 0 {
0000000000000000000000000000000000000000;;			conf.UserAgent = restclient.DefaultKubernetesUserAgent()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cl, err := restclient.RESTClientFor(conf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Client{cl: cl}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRateLimiter returns rate limier.
0000000000000000000000000000000000000000;;	func (c *Client) GetRateLimiter() flowcontrol.RateLimiter {
0000000000000000000000000000000000000000;;		return c.cl.GetRateLimiter()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resource returns an API interface to the specified resource for this client's
0000000000000000000000000000000000000000;;	// group and version. If resource is not a namespaced resource, then namespace
0000000000000000000000000000000000000000;;	// is ignored. The ResourceClient inherits the parameter codec of c.
0000000000000000000000000000000000000000;;	func (c *Client) Resource(resource *metav1.APIResource, namespace string) *ResourceClient {
0000000000000000000000000000000000000000;;		return &ResourceClient{
0000000000000000000000000000000000000000;;			cl:             c.cl,
0000000000000000000000000000000000000000;;			resource:       resource,
0000000000000000000000000000000000000000;;			ns:             namespace,
0000000000000000000000000000000000000000;;			parameterCodec: c.parameterCodec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParameterCodec returns a client with the provided parameter codec.
0000000000000000000000000000000000000000;;	func (c *Client) ParameterCodec(parameterCodec runtime.ParameterCodec) *Client {
0000000000000000000000000000000000000000;;		return &Client{
0000000000000000000000000000000000000000;;			cl:             c.cl,
0000000000000000000000000000000000000000;;			parameterCodec: parameterCodec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourceClient is an API interface to a specific resource under a
0000000000000000000000000000000000000000;;	// dynamic client.
0000000000000000000000000000000000000000;;	type ResourceClient struct {
0000000000000000000000000000000000000000;;		cl             *restclient.RESTClient
0000000000000000000000000000000000000000;;		resource       *metav1.APIResource
0000000000000000000000000000000000000000;;		ns             string
0000000000000000000000000000000000000000;;		parameterCodec runtime.ParameterCodec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a list of objects for this resource.
0000000000000000000000000000000000000000;;	func (rc *ResourceClient) List(opts metav1.ListOptions) (runtime.Object, error) {
0000000000000000000000000000000000000000;;		parameterEncoder := rc.parameterCodec
0000000000000000000000000000000000000000;;		if parameterEncoder == nil {
0000000000000000000000000000000000000000;;			parameterEncoder = defaultParameterEncoder
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rc.cl.Get().
0000000000000000000000000000000000000000;;			NamespaceIfScoped(rc.ns, rc.resource.Namespaced).
0000000000000000000000000000000000000000;;			Resource(rc.resource.Name).
0000000000000000000000000000000000000000;;			VersionedParams(&opts, parameterEncoder).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Get()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get gets the resource with the specified name.
0000000000000000000000000000000000000000;;	func (rc *ResourceClient) Get(name string, opts metav1.GetOptions) (*unstructured.Unstructured, error) {
0000000000000000000000000000000000000000;;		parameterEncoder := rc.parameterCodec
0000000000000000000000000000000000000000;;		if parameterEncoder == nil {
0000000000000000000000000000000000000000;;			parameterEncoder = defaultParameterEncoder
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := new(unstructured.Unstructured)
0000000000000000000000000000000000000000;;		err := rc.cl.Get().
0000000000000000000000000000000000000000;;			NamespaceIfScoped(rc.ns, rc.resource.Namespaced).
0000000000000000000000000000000000000000;;			Resource(rc.resource.Name).
0000000000000000000000000000000000000000;;			VersionedParams(&opts, parameterEncoder).
0000000000000000000000000000000000000000;;			Name(name).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete deletes the resource with the specified name.
0000000000000000000000000000000000000000;;	func (rc *ResourceClient) Delete(name string, opts *metav1.DeleteOptions) error {
0000000000000000000000000000000000000000;;		return rc.cl.Delete().
0000000000000000000000000000000000000000;;			NamespaceIfScoped(rc.ns, rc.resource.Namespaced).
0000000000000000000000000000000000000000;;			Resource(rc.resource.Name).
0000000000000000000000000000000000000000;;			Name(name).
0000000000000000000000000000000000000000;;			Body(opts).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteCollection deletes a collection of objects.
0000000000000000000000000000000000000000;;	func (rc *ResourceClient) DeleteCollection(deleteOptions *metav1.DeleteOptions, listOptions metav1.ListOptions) error {
0000000000000000000000000000000000000000;;		parameterEncoder := rc.parameterCodec
0000000000000000000000000000000000000000;;		if parameterEncoder == nil {
0000000000000000000000000000000000000000;;			parameterEncoder = defaultParameterEncoder
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rc.cl.Delete().
0000000000000000000000000000000000000000;;			NamespaceIfScoped(rc.ns, rc.resource.Namespaced).
0000000000000000000000000000000000000000;;			Resource(rc.resource.Name).
0000000000000000000000000000000000000000;;			VersionedParams(&listOptions, parameterEncoder).
0000000000000000000000000000000000000000;;			Body(deleteOptions).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates the provided resource.
0000000000000000000000000000000000000000;;	func (rc *ResourceClient) Create(obj *unstructured.Unstructured) (*unstructured.Unstructured, error) {
0000000000000000000000000000000000000000;;		result := new(unstructured.Unstructured)
0000000000000000000000000000000000000000;;		err := rc.cl.Post().
0000000000000000000000000000000000000000;;			NamespaceIfScoped(rc.ns, rc.resource.Namespaced).
0000000000000000000000000000000000000000;;			Resource(rc.resource.Name).
0000000000000000000000000000000000000000;;			Body(obj).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update updates the provided resource.
0000000000000000000000000000000000000000;;	func (rc *ResourceClient) Update(obj *unstructured.Unstructured) (*unstructured.Unstructured, error) {
0000000000000000000000000000000000000000;;		result := new(unstructured.Unstructured)
0000000000000000000000000000000000000000;;		if len(obj.GetName()) == 0 {
0000000000000000000000000000000000000000;;			return result, errors.New("object missing name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := rc.cl.Put().
0000000000000000000000000000000000000000;;			NamespaceIfScoped(rc.ns, rc.resource.Namespaced).
0000000000000000000000000000000000000000;;			Resource(rc.resource.Name).
0000000000000000000000000000000000000000;;			Name(obj.GetName()).
0000000000000000000000000000000000000000;;			Body(obj).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch returns a watch.Interface that watches the resource.
0000000000000000000000000000000000000000;;	func (rc *ResourceClient) Watch(opts metav1.ListOptions) (watch.Interface, error) {
0000000000000000000000000000000000000000;;		parameterEncoder := rc.parameterCodec
0000000000000000000000000000000000000000;;		if parameterEncoder == nil {
0000000000000000000000000000000000000000;;			parameterEncoder = defaultParameterEncoder
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts.Watch = true
0000000000000000000000000000000000000000;;		return rc.cl.Get().
0000000000000000000000000000000000000000;;			NamespaceIfScoped(rc.ns, rc.resource.Namespaced).
0000000000000000000000000000000000000000;;			Resource(rc.resource.Name).
0000000000000000000000000000000000000000;;			VersionedParams(&opts, parameterEncoder).
0000000000000000000000000000000000000000;;			Watch()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *ResourceClient) Patch(name string, pt types.PatchType, data []byte) (*unstructured.Unstructured, error) {
0000000000000000000000000000000000000000;;		result := new(unstructured.Unstructured)
0000000000000000000000000000000000000000;;		err := rc.cl.Patch(pt).
0000000000000000000000000000000000000000;;			NamespaceIfScoped(rc.ns, rc.resource.Namespaced).
0000000000000000000000000000000000000000;;			Resource(rc.resource.Name).
0000000000000000000000000000000000000000;;			Name(name).
0000000000000000000000000000000000000000;;			Body(data).
0000000000000000000000000000000000000000;;			Do().
0000000000000000000000000000000000000000;;			Into(result)
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dynamicCodec is a codec that wraps the standard unstructured codec
0000000000000000000000000000000000000000;;	// with special handling for Status objects.
0000000000000000000000000000000000000000;;	type dynamicCodec struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dynamicCodec) Decode(data []byte, gvk *schema.GroupVersionKind, obj runtime.Object) (runtime.Object, *schema.GroupVersionKind, error) {
0000000000000000000000000000000000000000;;		obj, gvk, err := unstructured.UnstructuredJSONScheme.Decode(data, gvk, obj)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := obj.(*metav1.Status); !ok && strings.ToLower(gvk.Kind) == "status" {
0000000000000000000000000000000000000000;;			obj = &metav1.Status{}
0000000000000000000000000000000000000000;;			err := json.Unmarshal(data, obj)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return obj, gvk, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dynamicCodec) Encode(obj runtime.Object, w io.Writer) error {
0000000000000000000000000000000000000000;;		return unstructured.UnstructuredJSONScheme.Encode(obj, w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContentConfig returns a restclient.ContentConfig for dynamic types.
0000000000000000000000000000000000000000;;	func ContentConfig() restclient.ContentConfig {
0000000000000000000000000000000000000000;;		var jsonInfo runtime.SerializerInfo
0000000000000000000000000000000000000000;;		// TODO: scheme.Codecs here should become "pkg/apis/server/scheme" which is the minimal core you need
0000000000000000000000000000000000000000;;		// to talk to a kubernetes server
0000000000000000000000000000000000000000;;		for _, info := range scheme.Codecs.SupportedMediaTypes() {
0000000000000000000000000000000000000000;;			if info.MediaType == runtime.ContentTypeJSON {
0000000000000000000000000000000000000000;;				jsonInfo = info
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonInfo.Serializer = dynamicCodec{}
0000000000000000000000000000000000000000;;		jsonInfo.PrettySerializer = nil
0000000000000000000000000000000000000000;;		return restclient.ContentConfig{
0000000000000000000000000000000000000000;;			AcceptContentTypes:   runtime.ContentTypeJSON,
0000000000000000000000000000000000000000;;			ContentType:          runtime.ContentTypeJSON,
0000000000000000000000000000000000000000;;			NegotiatedSerializer: serializer.NegotiatedSerializerWrapper(jsonInfo),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// paramaterCodec is a codec converts an API object to query
0000000000000000000000000000000000000000;;	// parameters without trying to convert to the target version.
0000000000000000000000000000000000000000;;	type parameterCodec struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (parameterCodec) EncodeParameters(obj runtime.Object, to schema.GroupVersion) (url.Values, error) {
0000000000000000000000000000000000000000;;		return queryparams.Convert(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (parameterCodec) DecodeParameters(parameters url.Values, from schema.GroupVersion, into runtime.Object) error {
0000000000000000000000000000000000000000;;		return errors.New("DecodeParameters not implemented on dynamic parameterCodec")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultParameterEncoder runtime.ParameterCodec = parameterCodec{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type versionedParameterEncoderWithV1Fallback struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (versionedParameterEncoderWithV1Fallback) EncodeParameters(obj runtime.Object, to schema.GroupVersion) (url.Values, error) {
0000000000000000000000000000000000000000;;		ret, err := scheme.ParameterCodec.EncodeParameters(obj, to)
0000000000000000000000000000000000000000;;		if err != nil && runtime.IsNotRegisteredError(err) {
0000000000000000000000000000000000000000;;			// fallback to v1
0000000000000000000000000000000000000000;;			return scheme.ParameterCodec.EncodeParameters(obj, v1.SchemeGroupVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (versionedParameterEncoderWithV1Fallback) DecodeParameters(parameters url.Values, from schema.GroupVersion, into runtime.Object) error {
0000000000000000000000000000000000000000;;		return errors.New("DecodeParameters not implemented on versionedParameterEncoderWithV1Fallback")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VersionedParameterEncoderWithV1Fallback is useful for encoding query
0000000000000000000000000000000000000000;;	// parameters for custom resources. It tries to convert object to the
0000000000000000000000000000000000000000;;	// specified version before converting it to query parameters, and falls back to
0000000000000000000000000000000000000000;;	// converting to v1 if the object is not registered in the specified version.
0000000000000000000000000000000000000000;;	// For the record, currently API server always treats query parameters sent to a
0000000000000000000000000000000000000000;;	// custom resource endpoint as v1.
0000000000000000000000000000000000000000;;	var VersionedParameterEncoderWithV1Fallback runtime.ParameterCodec = versionedParameterEncoderWithV1Fallback{}
